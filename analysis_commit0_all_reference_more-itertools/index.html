
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference more itertools - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-more-itertools" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference more itertools
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-more-itertools"><strong>Reference (Gold)</strong>: more-itertools</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">662</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">663</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">663</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/more_itertools/more.py b/more_itertools/more.py</span>
<span class="gh">index 4906f6d..3bf2c76 100755</span>
<span class="gd">--- a/more_itertools/more.py</span>
<span class="gi">+++ b/more_itertools/more.py</span>
<span class="gu">@@ -1,44 +1,161 @@</span>
<span class="w"> </span>import math
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from collections import Counter, defaultdict, deque, abc
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from contextlib import suppress
<span class="w"> </span>from functools import cached_property, partial, reduce, wraps
<span class="w"> </span>from heapq import heapify, heapreplace
<span class="gd">-from itertools import chain, combinations, compress, count, cycle, dropwhile, groupby, islice, repeat, starmap, takewhile, tee, zip_longest, product</span>
<span class="gi">+from itertools import (</span>
<span class="gi">+    chain,</span>
<span class="gi">+    combinations,</span>
<span class="gi">+    compress,</span>
<span class="gi">+    count,</span>
<span class="gi">+    cycle,</span>
<span class="gi">+    dropwhile,</span>
<span class="gi">+    groupby,</span>
<span class="gi">+    islice,</span>
<span class="gi">+    repeat,</span>
<span class="gi">+    starmap,</span>
<span class="gi">+    takewhile,</span>
<span class="gi">+    tee,</span>
<span class="gi">+    zip_longest,</span>
<span class="gi">+    product,</span>
<span class="gi">+)</span>
<span class="w"> </span>from math import comb, e, exp, factorial, floor, fsum, log, log1p, perm, tau
<span class="w"> </span>from queue import Empty, Queue
<span class="w"> </span>from random import random, randrange, shuffle, uniform
<span class="w"> </span>from operator import itemgetter, mul, sub, gt, lt, le
<span class="w"> </span>from sys import hexversion, maxsize
<span class="w"> </span>from time import monotonic
<span class="gd">-from .recipes import _marker, _zip_equal, UnequalIterablesError, consume, flatten, powerset, take, unique_everseen, all_equal, batched</span>
<span class="gd">-__all__ = [&#39;AbortThread&#39;, &#39;SequenceView&#39;, &#39;UnequalIterablesError&#39;,</span>
<span class="gd">-    &#39;adjacent&#39;, &#39;all_unique&#39;, &#39;always_iterable&#39;, &#39;always_reversible&#39;,</span>
<span class="gd">-    &#39;bucket&#39;, &#39;callback_iter&#39;, &#39;chunked&#39;, &#39;chunked_even&#39;, &#39;circular_shifts&#39;,</span>
<span class="gd">-    &#39;collapse&#39;, &#39;combination_index&#39;, &#39;combination_with_replacement_index&#39;,</span>
<span class="gd">-    &#39;consecutive_groups&#39;, &#39;constrained_batches&#39;, &#39;consumer&#39;, &#39;count_cycle&#39;,</span>
<span class="gd">-    &#39;countable&#39;, &#39;dft&#39;, &#39;difference&#39;, &#39;distinct_combinations&#39;,</span>
<span class="gd">-    &#39;distinct_permutations&#39;, &#39;distribute&#39;, &#39;divide&#39;, &#39;doublestarmap&#39;,</span>
<span class="gd">-    &#39;duplicates_everseen&#39;, &#39;duplicates_justseen&#39;, &#39;classify_unique&#39;,</span>
<span class="gd">-    &#39;exactly_n&#39;, &#39;filter_except&#39;, &#39;filter_map&#39;, &#39;first&#39;, &#39;gray_product&#39;,</span>
<span class="gd">-    &#39;groupby_transform&#39;, &#39;ichunked&#39;, &#39;iequals&#39;, &#39;idft&#39;, &#39;ilen&#39;,</span>
<span class="gd">-    &#39;interleave&#39;, &#39;interleave_evenly&#39;, &#39;interleave_longest&#39;, &#39;intersperse&#39;,</span>
<span class="gd">-    &#39;is_sorted&#39;, &#39;islice_extended&#39;, &#39;iterate&#39;, &#39;iter_suppress&#39;,</span>
<span class="gd">-    &#39;join_mappings&#39;, &#39;last&#39;, &#39;locate&#39;, &#39;longest_common_prefix&#39;, &#39;lstrip&#39;,</span>
<span class="gd">-    &#39;make_decorator&#39;, &#39;map_except&#39;, &#39;map_if&#39;, &#39;map_reduce&#39;, &#39;mark_ends&#39;,</span>
<span class="gd">-    &#39;minmax&#39;, &#39;nth_or_last&#39;, &#39;nth_permutation&#39;, &#39;nth_product&#39;,</span>
<span class="gd">-    &#39;nth_combination_with_replacement&#39;, &#39;numeric_range&#39;, &#39;one&#39;, &#39;only&#39;,</span>
<span class="gd">-    &#39;outer_product&#39;, &#39;padded&#39;, &#39;partial_product&#39;, &#39;partitions&#39;, &#39;peekable&#39;,</span>
<span class="gd">-    &#39;permutation_index&#39;, &#39;powerset_of_sets&#39;, &#39;product_index&#39;, &#39;raise_&#39;,</span>
<span class="gd">-    &#39;repeat_each&#39;, &#39;repeat_last&#39;, &#39;replace&#39;, &#39;rlocate&#39;, &#39;rstrip&#39;,</span>
<span class="gd">-    &#39;run_length&#39;, &#39;sample&#39;, &#39;seekable&#39;, &#39;set_partitions&#39;, &#39;side_effect&#39;,</span>
<span class="gd">-    &#39;sliced&#39;, &#39;sort_together&#39;, &#39;split_after&#39;, &#39;split_at&#39;, &#39;split_before&#39;,</span>
<span class="gd">-    &#39;split_into&#39;, &#39;split_when&#39;, &#39;spy&#39;, &#39;stagger&#39;, &#39;strip&#39;, &#39;strictly_n&#39;,</span>
<span class="gd">-    &#39;substrings&#39;, &#39;substrings_indexes&#39;, &#39;takewhile_inclusive&#39;,</span>
<span class="gd">-    &#39;time_limited&#39;, &#39;unique_in_window&#39;, &#39;unique_to_each&#39;, &#39;unzip&#39;,</span>
<span class="gd">-    &#39;value_chain&#39;, &#39;windowed&#39;, &#39;windowed_complete&#39;, &#39;with_iter&#39;,</span>
<span class="gd">-    &#39;zip_broadcast&#39;, &#39;zip_equal&#39;, &#39;zip_offset&#39;]</span>
<span class="gi">+</span>
<span class="gi">+from .recipes import (</span>
<span class="gi">+    _marker,</span>
<span class="gi">+    _zip_equal,</span>
<span class="gi">+    UnequalIterablesError,</span>
<span class="gi">+    consume,</span>
<span class="gi">+    flatten,</span>
<span class="gi">+    powerset,</span>
<span class="gi">+    take,</span>
<span class="gi">+    unique_everseen,</span>
<span class="gi">+    all_equal,</span>
<span class="gi">+    batched,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;AbortThread&#39;,</span>
<span class="gi">+    &#39;SequenceView&#39;,</span>
<span class="gi">+    &#39;UnequalIterablesError&#39;,</span>
<span class="gi">+    &#39;adjacent&#39;,</span>
<span class="gi">+    &#39;all_unique&#39;,</span>
<span class="gi">+    &#39;always_iterable&#39;,</span>
<span class="gi">+    &#39;always_reversible&#39;,</span>
<span class="gi">+    &#39;bucket&#39;,</span>
<span class="gi">+    &#39;callback_iter&#39;,</span>
<span class="gi">+    &#39;chunked&#39;,</span>
<span class="gi">+    &#39;chunked_even&#39;,</span>
<span class="gi">+    &#39;circular_shifts&#39;,</span>
<span class="gi">+    &#39;collapse&#39;,</span>
<span class="gi">+    &#39;combination_index&#39;,</span>
<span class="gi">+    &#39;combination_with_replacement_index&#39;,</span>
<span class="gi">+    &#39;consecutive_groups&#39;,</span>
<span class="gi">+    &#39;constrained_batches&#39;,</span>
<span class="gi">+    &#39;consumer&#39;,</span>
<span class="gi">+    &#39;count_cycle&#39;,</span>
<span class="gi">+    &#39;countable&#39;,</span>
<span class="gi">+    &#39;dft&#39;,</span>
<span class="gi">+    &#39;difference&#39;,</span>
<span class="gi">+    &#39;distinct_combinations&#39;,</span>
<span class="gi">+    &#39;distinct_permutations&#39;,</span>
<span class="gi">+    &#39;distribute&#39;,</span>
<span class="gi">+    &#39;divide&#39;,</span>
<span class="gi">+    &#39;doublestarmap&#39;,</span>
<span class="gi">+    &#39;duplicates_everseen&#39;,</span>
<span class="gi">+    &#39;duplicates_justseen&#39;,</span>
<span class="gi">+    &#39;classify_unique&#39;,</span>
<span class="gi">+    &#39;exactly_n&#39;,</span>
<span class="gi">+    &#39;filter_except&#39;,</span>
<span class="gi">+    &#39;filter_map&#39;,</span>
<span class="gi">+    &#39;first&#39;,</span>
<span class="gi">+    &#39;gray_product&#39;,</span>
<span class="gi">+    &#39;groupby_transform&#39;,</span>
<span class="gi">+    &#39;ichunked&#39;,</span>
<span class="gi">+    &#39;iequals&#39;,</span>
<span class="gi">+    &#39;idft&#39;,</span>
<span class="gi">+    &#39;ilen&#39;,</span>
<span class="gi">+    &#39;interleave&#39;,</span>
<span class="gi">+    &#39;interleave_evenly&#39;,</span>
<span class="gi">+    &#39;interleave_longest&#39;,</span>
<span class="gi">+    &#39;intersperse&#39;,</span>
<span class="gi">+    &#39;is_sorted&#39;,</span>
<span class="gi">+    &#39;islice_extended&#39;,</span>
<span class="gi">+    &#39;iterate&#39;,</span>
<span class="gi">+    &#39;iter_suppress&#39;,</span>
<span class="gi">+    &#39;join_mappings&#39;,</span>
<span class="gi">+    &#39;last&#39;,</span>
<span class="gi">+    &#39;locate&#39;,</span>
<span class="gi">+    &#39;longest_common_prefix&#39;,</span>
<span class="gi">+    &#39;lstrip&#39;,</span>
<span class="gi">+    &#39;make_decorator&#39;,</span>
<span class="gi">+    &#39;map_except&#39;,</span>
<span class="gi">+    &#39;map_if&#39;,</span>
<span class="gi">+    &#39;map_reduce&#39;,</span>
<span class="gi">+    &#39;mark_ends&#39;,</span>
<span class="gi">+    &#39;minmax&#39;,</span>
<span class="gi">+    &#39;nth_or_last&#39;,</span>
<span class="gi">+    &#39;nth_permutation&#39;,</span>
<span class="gi">+    &#39;nth_product&#39;,</span>
<span class="gi">+    &#39;nth_combination_with_replacement&#39;,</span>
<span class="gi">+    &#39;numeric_range&#39;,</span>
<span class="gi">+    &#39;one&#39;,</span>
<span class="gi">+    &#39;only&#39;,</span>
<span class="gi">+    &#39;outer_product&#39;,</span>
<span class="gi">+    &#39;padded&#39;,</span>
<span class="gi">+    &#39;partial_product&#39;,</span>
<span class="gi">+    &#39;partitions&#39;,</span>
<span class="gi">+    &#39;peekable&#39;,</span>
<span class="gi">+    &#39;permutation_index&#39;,</span>
<span class="gi">+    &#39;powerset_of_sets&#39;,</span>
<span class="gi">+    &#39;product_index&#39;,</span>
<span class="gi">+    &#39;raise_&#39;,</span>
<span class="gi">+    &#39;repeat_each&#39;,</span>
<span class="gi">+    &#39;repeat_last&#39;,</span>
<span class="gi">+    &#39;replace&#39;,</span>
<span class="gi">+    &#39;rlocate&#39;,</span>
<span class="gi">+    &#39;rstrip&#39;,</span>
<span class="gi">+    &#39;run_length&#39;,</span>
<span class="gi">+    &#39;sample&#39;,</span>
<span class="gi">+    &#39;seekable&#39;,</span>
<span class="gi">+    &#39;set_partitions&#39;,</span>
<span class="gi">+    &#39;side_effect&#39;,</span>
<span class="gi">+    &#39;sliced&#39;,</span>
<span class="gi">+    &#39;sort_together&#39;,</span>
<span class="gi">+    &#39;split_after&#39;,</span>
<span class="gi">+    &#39;split_at&#39;,</span>
<span class="gi">+    &#39;split_before&#39;,</span>
<span class="gi">+    &#39;split_into&#39;,</span>
<span class="gi">+    &#39;split_when&#39;,</span>
<span class="gi">+    &#39;spy&#39;,</span>
<span class="gi">+    &#39;stagger&#39;,</span>
<span class="gi">+    &#39;strip&#39;,</span>
<span class="gi">+    &#39;strictly_n&#39;,</span>
<span class="gi">+    &#39;substrings&#39;,</span>
<span class="gi">+    &#39;substrings_indexes&#39;,</span>
<span class="gi">+    &#39;takewhile_inclusive&#39;,</span>
<span class="gi">+    &#39;time_limited&#39;,</span>
<span class="gi">+    &#39;unique_in_window&#39;,</span>
<span class="gi">+    &#39;unique_to_each&#39;,</span>
<span class="gi">+    &#39;unzip&#39;,</span>
<span class="gi">+    &#39;value_chain&#39;,</span>
<span class="gi">+    &#39;windowed&#39;,</span>
<span class="gi">+    &#39;windowed_complete&#39;,</span>
<span class="gi">+    &#39;with_iter&#39;,</span>
<span class="gi">+    &#39;zip_broadcast&#39;,</span>
<span class="gi">+    &#39;zip_equal&#39;,</span>
<span class="gi">+    &#39;zip_offset&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# math.sumprod is available for Python 3.12+</span>
<span class="w"> </span>_fsumprod = getattr(math, &#39;sumprod&#39;, lambda x, y: fsum(map(mul, x, y)))


<span class="gu">@@ -61,7 +178,20 @@ def chunked(iterable, n, strict=False):</span>
<span class="w"> </span>    list is yielded.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterator = iter(partial(take, n, iter(iterable)), [])</span>
<span class="gi">+    if strict:</span>
<span class="gi">+        if n is None:</span>
<span class="gi">+            raise ValueError(&#39;n must not be None when using strict mode.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def ret():</span>
<span class="gi">+            for chunk in iterator:</span>
<span class="gi">+                if len(chunk) != n:</span>
<span class="gi">+                    raise ValueError(&#39;iterable is not divisible by n.&#39;)</span>
<span class="gi">+                yield chunk</span>
<span class="gi">+</span>
<span class="gi">+        return iter(ret())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return iterator</span>


<span class="w"> </span>def first(iterable, default=_marker):
<span class="gu">@@ -81,7 +211,14 @@ def first(iterable, default=_marker):</span>
<span class="w"> </span>    ``next(iter(iterable), default)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        return item</span>
<span class="gi">+    if default is _marker:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &#39;first() was called on an empty iterable, and no &#39;</span>
<span class="gi">+            &#39;default value was provided.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+    return default</span>


<span class="w"> </span>def last(iterable, default=_marker):
<span class="gu">@@ -96,7 +233,21 @@ def last(iterable, default=_marker):</span>
<span class="w"> </span>    If *default* is not provided and there are no items in the iterable,
<span class="w"> </span>    raise ``ValueError``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(iterable, Sequence):</span>
<span class="gi">+            return iterable[-1]</span>
<span class="gi">+        # Work around https://bugs.python.org/issue38525</span>
<span class="gi">+        elif hasattr(iterable, &#39;__reversed__&#39;) and (hexversion != 0x030800F0):</span>
<span class="gi">+            return next(reversed(iterable))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return deque(iterable, maxlen=1)[-1]</span>
<span class="gi">+    except (IndexError, TypeError, StopIteration):</span>
<span class="gi">+        if default is _marker:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &#39;last() was called on an empty iterable, and no default was &#39;</span>
<span class="gi">+                &#39;provided.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        return default</span>


<span class="w"> </span>def nth_or_last(iterable, n, default=_marker):
<span class="gu">@@ -113,7 +264,7 @@ def nth_or_last(iterable, n, default=_marker):</span>
<span class="w"> </span>    If *default* is not provided and there are no items in the iterable,
<span class="w"> </span>    raise ``ValueError``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return last(islice(iterable, n + 1), default=default)</span>


<span class="w"> </span>class peekable:
<span class="gu">@@ -196,7 +347,14 @@ class peekable:</span>
<span class="w"> </span>        provided, raise ``StopIteration``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._cache:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._cache.append(next(self._it))</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                if default is _marker:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                return default</span>
<span class="gi">+        return self._cache[0]</span>

<span class="w"> </span>    def prepend(self, *items):
<span class="w"> </span>        &quot;&quot;&quot;Stack up items to be the next ones returned from ``next()`` or
<span class="gu">@@ -227,21 +385,50 @@ class peekable:</span>
<span class="w"> </span>            StopIteration

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache.extendleft(reversed(items))</span>

<span class="w"> </span>    def __next__(self):
<span class="w"> </span>        if self._cache:
<span class="w"> </span>            return self._cache.popleft()
<span class="gi">+</span>
<span class="w"> </span>        return next(self._it)

<span class="gi">+    def _get_slice(self, index):</span>
<span class="gi">+        # Normalize the slice&#39;s arguments</span>
<span class="gi">+        step = 1 if (index.step is None) else index.step</span>
<span class="gi">+        if step &gt; 0:</span>
<span class="gi">+            start = 0 if (index.start is None) else index.start</span>
<span class="gi">+            stop = maxsize if (index.stop is None) else index.stop</span>
<span class="gi">+        elif step &lt; 0:</span>
<span class="gi">+            start = -1 if (index.start is None) else index.start</span>
<span class="gi">+            stop = (-maxsize - 1) if (index.stop is None) else index.stop</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;slice step cannot be zero&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # If either the start or stop index is negative, we&#39;ll need to cache</span>
<span class="gi">+        # the rest of the iterable in order to slice from the right side.</span>
<span class="gi">+        if (start &lt; 0) or (stop &lt; 0):</span>
<span class="gi">+            self._cache.extend(self._it)</span>
<span class="gi">+        # Otherwise we&#39;ll need to find the rightmost index and cache to that</span>
<span class="gi">+        # point.</span>
<span class="gi">+        else:</span>
<span class="gi">+            n = min(max(start, stop) + 1, maxsize)</span>
<span class="gi">+            cache_len = len(self._cache)</span>
<span class="gi">+            if n &gt;= cache_len:</span>
<span class="gi">+                self._cache.extend(islice(self._it, n - cache_len))</span>
<span class="gi">+</span>
<span class="gi">+        return list(self._cache)[index]</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getitem__(self, index):
<span class="w"> </span>        if isinstance(index, slice):
<span class="w"> </span>            return self._get_slice(index)
<span class="gi">+</span>
<span class="w"> </span>        cache_len = len(self._cache)
<span class="w"> </span>        if index &lt; 0:
<span class="w"> </span>            self._cache.extend(self._it)
<span class="w"> </span>        elif index &gt;= cache_len:
<span class="w"> </span>            self._cache.extend(islice(self._it, index + 1 - cache_len))
<span class="gi">+</span>
<span class="w"> </span>        return self._cache[index]


<span class="gu">@@ -267,7 +454,14 @@ def consumer(func):</span>
<span class="w"> </span>    ``t.send()`` could be used.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        gen = func(*args, **kwargs)</span>
<span class="gi">+        next(gen)</span>
<span class="gi">+        return gen</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def ilen(iterable):
<span class="gu">@@ -279,7 +473,10 @@ def ilen(iterable):</span>
<span class="w"> </span>    This consumes the iterable, so handle with care.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This is the &quot;most beautiful of the fast variants&quot; of this function.</span>
<span class="gi">+    # If you think you can improve on it, please ensure that your version</span>
<span class="gi">+    # is both 10x faster and 10x more beautiful.</span>
<span class="gi">+    return sum(compress(repeat(1), zip(iterable)))</span>


<span class="w"> </span>def iterate(func, start):
<span class="gu">@@ -290,7 +487,12 @@ def iterate(func, start):</span>
<span class="w"> </span>    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        yield start</span>
<span class="gi">+        try:</span>
<span class="gi">+            start = func(start)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            break</span>


<span class="w"> </span>def with_iter(context_manager):
<span class="gu">@@ -304,7 +506,8 @@ def with_iter(context_manager):</span>
<span class="w"> </span>    ``with_iter``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with context_manager as iterable:</span>
<span class="gi">+        yield from iterable</span>


<span class="w"> </span>def one(iterable, too_short=None, too_long=None):
<span class="gu">@@ -351,7 +554,31 @@ def one(iterable, too_short=None, too_long=None):</span>
<span class="w"> </span>    contents less destructively.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        first_value = next(it)</span>
<span class="gi">+    except StopIteration as exc:</span>
<span class="gi">+        raise (</span>
<span class="gi">+            too_short or ValueError(&#39;too few items in iterable (expected 1)&#39;)</span>
<span class="gi">+        ) from exc</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        second_value = next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &#39;Expected exactly one item in iterable, but got {!r}, {!r}, &#39;</span>
<span class="gi">+            &#39;and perhaps more.&#39;.format(first_value, second_value)</span>
<span class="gi">+        )</span>
<span class="gi">+        raise too_long or ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    return first_value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def raise_(exception, *args):</span>
<span class="gi">+    raise exception(*args)</span>


<span class="w"> </span>def strictly_n(iterable, n, too_short=None, too_long=None):
<span class="gu">@@ -401,7 +628,34 @@ def strictly_n(iterable, n, too_short=None, too_long=None):</span>
<span class="w"> </span>        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if too_short is None:</span>
<span class="gi">+        too_short = lambda item_count: raise_(</span>
<span class="gi">+            ValueError,</span>
<span class="gi">+            &#39;Too few items in iterable (got {})&#39;.format(item_count),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if too_long is None:</span>
<span class="gi">+        too_long = lambda item_count: raise_(</span>
<span class="gi">+            ValueError,</span>
<span class="gi">+            &#39;Too many items in iterable (got at least {})&#39;.format(item_count),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    for i in range(n):</span>
<span class="gi">+        try:</span>
<span class="gi">+            item = next(it)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            too_short(i)</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield item</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        too_long(n + 1)</span>


<span class="w"> </span>def distinct_permutations(iterable, r=None):
<span class="gu">@@ -447,7 +701,111 @@ def distinct_permutations(iterable, r=None):</span>
<span class="w"> </span>            (&#39;3&#39;, 2, 1)
<span class="w"> </span>        ]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Algorithm: https://w.wiki/Qai</span>
<span class="gi">+    def _full(A):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # Yield the permutation we have</span>
<span class="gi">+            yield tuple(A)</span>
<span class="gi">+</span>
<span class="gi">+            # Find the largest index i such that A[i] &lt; A[i + 1]</span>
<span class="gi">+            for i in range(size - 2, -1, -1):</span>
<span class="gi">+                if A[i] &lt; A[i + 1]:</span>
<span class="gi">+                    break</span>
<span class="gi">+            #  If no such index exists, this permutation is the last one</span>
<span class="gi">+            else:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Find the largest index j greater than j such that A[i] &lt; A[j]</span>
<span class="gi">+            for j in range(size - 1, i, -1):</span>
<span class="gi">+                if A[i] &lt; A[j]:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            # Swap the value of A[i] with that of A[j], then reverse the</span>
<span class="gi">+            # sequence from A[i + 1] to form the new permutation</span>
<span class="gi">+            A[i], A[j] = A[j], A[i]</span>
<span class="gi">+            A[i + 1 :] = A[: i - size : -1]  # A[i + 1:][::-1]</span>
<span class="gi">+</span>
<span class="gi">+    # Algorithm: modified from the above</span>
<span class="gi">+    def _partial(A, r):</span>
<span class="gi">+        # Split A into the first r items and the last r items</span>
<span class="gi">+        head, tail = A[:r], A[r:]</span>
<span class="gi">+        right_head_indexes = range(r - 1, -1, -1)</span>
<span class="gi">+        left_tail_indexes = range(len(tail))</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # Yield the permutation we have</span>
<span class="gi">+            yield tuple(head)</span>
<span class="gi">+</span>
<span class="gi">+            # Starting from the right, find the first index of the head with</span>
<span class="gi">+            # value smaller than the maximum value of the tail - call it i.</span>
<span class="gi">+            pivot = tail[-1]</span>
<span class="gi">+            for i in right_head_indexes:</span>
<span class="gi">+                if head[i] &lt; pivot:</span>
<span class="gi">+                    break</span>
<span class="gi">+                pivot = head[i]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Starting from the left, find the first value of the tail</span>
<span class="gi">+            # with a value greater than head[i] and swap.</span>
<span class="gi">+            for j in left_tail_indexes:</span>
<span class="gi">+                if tail[j] &gt; head[i]:</span>
<span class="gi">+                    head[i], tail[j] = tail[j], head[i]</span>
<span class="gi">+                    break</span>
<span class="gi">+            # If we didn&#39;t find one, start from the right and find the first</span>
<span class="gi">+            # index of the head with a value greater than head[i] and swap.</span>
<span class="gi">+            else:</span>
<span class="gi">+                for j in right_head_indexes:</span>
<span class="gi">+                    if head[j] &gt; head[i]:</span>
<span class="gi">+                        head[i], head[j] = head[j], head[i]</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]</span>
<span class="gi">+            tail += head[: i - r : -1]  # head[i + 1:][::-1]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            head[i:], tail[:] = tail[: r - i], tail[r - i :]</span>
<span class="gi">+</span>
<span class="gi">+    items = list(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        items.sort()</span>
<span class="gi">+        sortable = True</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        sortable = False</span>
<span class="gi">+</span>
<span class="gi">+        indices_dict = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        for item in items:</span>
<span class="gi">+            indices_dict[items.index(item)].append(item)</span>
<span class="gi">+</span>
<span class="gi">+        indices = [items.index(item) for item in items]</span>
<span class="gi">+        indices.sort()</span>
<span class="gi">+</span>
<span class="gi">+        equivalent_items = {k: cycle(v) for k, v in indices_dict.items()}</span>
<span class="gi">+</span>
<span class="gi">+        def permuted_items(permuted_indices):</span>
<span class="gi">+            return tuple(</span>
<span class="gi">+                next(equivalent_items[index]) for index in permuted_indices</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    size = len(items)</span>
<span class="gi">+    if r is None:</span>
<span class="gi">+        r = size</span>
<span class="gi">+</span>
<span class="gi">+    # functools.partial(_partial, ... )</span>
<span class="gi">+    algorithm = _full if (r == size) else partial(_partial, r=r)</span>
<span class="gi">+</span>
<span class="gi">+    if 0 &lt; r &lt;= size:</span>
<span class="gi">+        if sortable:</span>
<span class="gi">+            return algorithm(items)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (</span>
<span class="gi">+                permuted_items(permuted_indices)</span>
<span class="gi">+                for permuted_indices in algorithm(indices)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    return iter(() if r else ((),))</span>


<span class="w"> </span>def intersperse(e, iterable, n=1):
<span class="gu">@@ -461,7 +819,19 @@ def intersperse(e, iterable, n=1):</span>
<span class="w"> </span>        [1, 2, None, 3, 4, None, 5]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise ValueError(&#39;n must be &gt; 0&#39;)</span>
<span class="gi">+    elif n == 1:</span>
<span class="gi">+        # interleave(repeat(e), iterable) -&gt; e, x_0, e, x_1, e, x_2...</span>
<span class="gi">+        # islice(..., 1, None) -&gt; x_0, e, x_1, e, x_2...</span>
<span class="gi">+        return islice(interleave(repeat(e), iterable), 1, None)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # interleave(filler, chunks) -&gt; [e], [x_0, x_1], [e], [x_2, x_3]...</span>
<span class="gi">+        # islice(..., 1, None) -&gt; [x_0, x_1], [e], [x_2, x_3]...</span>
<span class="gi">+        # flatten(...) -&gt; x_0, x_1, e, x_2, x_3...</span>
<span class="gi">+        filler = repeat([e])</span>
<span class="gi">+        chunks = chunked(iterable, n)</span>
<span class="gi">+        return flatten(islice(interleave(filler, chunks), 1, None))</span>


<span class="w"> </span>def unique_to_each(*iterables):
<span class="gu">@@ -491,7 +861,10 @@ def unique_to_each(*iterables):</span>
<span class="w"> </span>    It is assumed that the elements of each iterable are hashable.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = [list(it) for it in iterables]</span>
<span class="gi">+    counts = Counter(chain.from_iterable(map(set, pool)))</span>
<span class="gi">+    uniques = {element for element in counts if counts[element] == 1}</span>
<span class="gi">+    return [list(filter(uniques.__contains__, it)) for it in pool]</span>


<span class="w"> </span>def windowed(seq, n, fillvalue=None, step=1):
<span class="gu">@@ -521,7 +894,35 @@ def windowed(seq, n, fillvalue=None, step=1):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(windowed(chain(padding, iterable), 3))
<span class="w"> </span>        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt; 0:</span>
<span class="gi">+        raise ValueError(&#39;n must be &gt;= 0&#39;)</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        yield ()</span>
<span class="gi">+        return</span>
<span class="gi">+    if step &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;step must be &gt;= 1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    iterable = iter(seq)</span>
<span class="gi">+</span>
<span class="gi">+    # Generate first window</span>
<span class="gi">+    window = deque(islice(iterable, n), maxlen=n)</span>
<span class="gi">+</span>
<span class="gi">+    # Deal with the first window not being full</span>
<span class="gi">+    if not window:</span>
<span class="gi">+        return</span>
<span class="gi">+    if len(window) &lt; n:</span>
<span class="gi">+        yield tuple(window) + ((fillvalue,) * (n - len(window)))</span>
<span class="gi">+        return</span>
<span class="gi">+    yield tuple(window)</span>
<span class="gi">+</span>
<span class="gi">+    # Create the filler for the next windows. The padding ensures</span>
<span class="gi">+    # we have just enough elements to fill the last window.</span>
<span class="gi">+    padding = (fillvalue,) * (n - 1 if step &gt;= n else step - 1)</span>
<span class="gi">+    filler = map(window.append, chain(iterable, padding))</span>
<span class="gi">+</span>
<span class="gi">+    # Generate the rest of the windows</span>
<span class="gi">+    for _ in islice(filler, step - 1, None, step):</span>
<span class="gi">+        yield tuple(window)</span>


<span class="w"> </span>def substrings(iterable):
<span class="gu">@@ -536,7 +937,18 @@ def substrings(iterable):</span>
<span class="w"> </span>        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The length-1 substrings</span>
<span class="gi">+    seq = []</span>
<span class="gi">+    for item in iter(iterable):</span>
<span class="gi">+        seq.append(item)</span>
<span class="gi">+        yield (item,)</span>
<span class="gi">+    seq = tuple(seq)</span>
<span class="gi">+    item_count = len(seq)</span>
<span class="gi">+</span>
<span class="gi">+    # And the rest</span>
<span class="gi">+    for n in range(2, item_count + 1):</span>
<span class="gi">+        for i in range(item_count - n + 1):</span>
<span class="gi">+            yield seq[i : i + n]</span>


<span class="w"> </span>def substrings_indexes(seq, reverse=False):
<span class="gu">@@ -565,7 +977,12 @@ def substrings_indexes(seq, reverse=False):</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    r = range(1, len(seq) + 1)</span>
<span class="gi">+    if reverse:</span>
<span class="gi">+        r = reversed(r)</span>
<span class="gi">+    return (</span>
<span class="gi">+        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class bucket:
<span class="gu">@@ -613,12 +1030,14 @@ class bucket:</span>
<span class="w"> </span>    def __contains__(self, value):
<span class="w"> </span>        if not self._validator(value):
<span class="w"> </span>            return False
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            item = next(self[value])
<span class="w"> </span>        except StopIteration:
<span class="w"> </span>            return False
<span class="w"> </span>        else:
<span class="w"> </span>            self._cache[value].appendleft(item)
<span class="gi">+</span>
<span class="w"> </span>        return True

<span class="w"> </span>    def _get_values(self, value):
<span class="gu">@@ -627,18 +1046,38 @@ class bucket:</span>
<span class="w"> </span>        Items that don&#39;t match are stored in the local cache as they
<span class="w"> </span>        are encountered.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # If we&#39;ve cached some items that match the target value, emit</span>
<span class="gi">+            # the first one and evict it from the cache.</span>
<span class="gi">+            if self._cache[value]:</span>
<span class="gi">+                yield self._cache[value].popleft()</span>
<span class="gi">+            # Otherwise we need to advance the parent iterator to search for</span>
<span class="gi">+            # a matching item, caching the rest.</span>
<span class="gi">+            else:</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        item = next(self._it)</span>
<span class="gi">+                    except StopIteration:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    item_value = self._key(item)</span>
<span class="gi">+                    if item_value == value:</span>
<span class="gi">+                        yield item</span>
<span class="gi">+                        break</span>
<span class="gi">+                    elif self._validator(item_value):</span>
<span class="gi">+                        self._cache[item_value].append(item)</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for item in self._it:
<span class="w"> </span>            item_value = self._key(item)
<span class="w"> </span>            if self._validator(item_value):
<span class="w"> </span>                self._cache[item_value].append(item)
<span class="gi">+</span>
<span class="w"> </span>        yield from self._cache.keys()

<span class="w"> </span>    def __getitem__(self, value):
<span class="w"> </span>        if not self._validator(value):
<span class="w"> </span>            return iter(())
<span class="gi">+</span>
<span class="w"> </span>        return self._get_values(value)


<span class="gu">@@ -679,7 +1118,10 @@ def spy(iterable, n=1):</span>
<span class="w"> </span>        [1, 2, 3, 4, 5]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    head = take(n, it)</span>
<span class="gi">+</span>
<span class="gi">+    return head.copy(), chain(head, it)</span>


<span class="w"> </span>def interleave(*iterables):
<span class="gu">@@ -693,7 +1135,7 @@ def interleave(*iterables):</span>
<span class="w"> </span>    exhausted, see :func:`interleave_longest`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return chain.from_iterable(zip(*iterables))</span>


<span class="w"> </span>def interleave_longest(*iterables):
<span class="gu">@@ -708,7 +1150,8 @@ def interleave_longest(*iterables):</span>
<span class="w"> </span>    is large).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))</span>
<span class="gi">+    return (x for x in i if x is not _marker)</span>


<span class="w"> </span>def interleave_evenly(iterables, lengths=None):
<span class="gu">@@ -735,7 +1178,46 @@ def interleave_evenly(iterables, lengths=None):</span>

<span class="w"> </span>    Based on Bresenham&#39;s algorithm.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if lengths is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            lengths = [len(it) for it in iterables]</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &#39;Iterable lengths could not be determined automatically. &#39;</span>
<span class="gi">+                &#39;Specify them with the lengths keyword.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+    elif len(iterables) != len(lengths):</span>
<span class="gi">+        raise ValueError(&#39;Mismatching number of iterables and lengths.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    dims = len(lengths)</span>
<span class="gi">+</span>
<span class="gi">+    # sort iterables by length, descending</span>
<span class="gi">+    lengths_permute = sorted(</span>
<span class="gi">+        range(dims), key=lambda i: lengths[i], reverse=True</span>
<span class="gi">+    )</span>
<span class="gi">+    lengths_desc = [lengths[i] for i in lengths_permute]</span>
<span class="gi">+    iters_desc = [iter(iterables[i]) for i in lengths_permute]</span>
<span class="gi">+</span>
<span class="gi">+    # the longest iterable is the primary one (Bresenham: the longest</span>
<span class="gi">+    # distance along an axis)</span>
<span class="gi">+    delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]</span>
<span class="gi">+    iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]</span>
<span class="gi">+    errors = [delta_primary // dims] * len(deltas_secondary)</span>
<span class="gi">+</span>
<span class="gi">+    to_yield = sum(lengths)</span>
<span class="gi">+    while to_yield:</span>
<span class="gi">+        yield next(iter_primary)</span>
<span class="gi">+        to_yield -= 1</span>
<span class="gi">+        # update errors for each secondary iterable</span>
<span class="gi">+        errors = [e - delta for e, delta in zip(errors, deltas_secondary)]</span>
<span class="gi">+</span>
<span class="gi">+        # those iterables for which the error is negative are yielded</span>
<span class="gi">+        # (&quot;diagonal step&quot; in Bresenham)</span>
<span class="gi">+        for i, e_ in enumerate(errors):</span>
<span class="gi">+            if e_ &lt; 0:</span>
<span class="gi">+                yield next(iters_secondary[i])</span>
<span class="gi">+                to_yield -= 1</span>
<span class="gi">+                errors[i] += delta_primary</span>


<span class="w"> </span>def collapse(iterable, base_type=None, levels=None):
<span class="gu">@@ -764,7 +1246,38 @@ def collapse(iterable, base_type=None, levels=None):</span>
<span class="w"> </span>    [&#39;a&#39;, [&#39;b&#39;], &#39;c&#39;, [&#39;d&#39;]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stack = deque()</span>
<span class="gi">+    # Add our first node group, treat the iterable as a single node</span>
<span class="gi">+    stack.appendleft((0, repeat(iterable, 1)))</span>
<span class="gi">+</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        node_group = stack.popleft()</span>
<span class="gi">+        level, nodes = node_group</span>
<span class="gi">+</span>
<span class="gi">+        # Check if beyond max level</span>
<span class="gi">+        if levels is not None and level &gt; levels:</span>
<span class="gi">+            yield from nodes</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            # Check if done iterating</span>
<span class="gi">+            if isinstance(node, (str, bytes)) or (</span>
<span class="gi">+                (base_type is not None) and isinstance(node, base_type)</span>
<span class="gi">+            ):</span>
<span class="gi">+                yield node</span>
<span class="gi">+            # Otherwise try to create child nodes</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    tree = iter(node)</span>
<span class="gi">+                except TypeError:</span>
<span class="gi">+                    yield node</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Save our current location</span>
<span class="gi">+                    stack.appendleft(node_group)</span>
<span class="gi">+                    # Append the new child node</span>
<span class="gi">+                    stack.appendleft((level + 1, tree))</span>
<span class="gi">+                    # Break to process child node</span>
<span class="gi">+                    break</span>


<span class="w"> </span>def side_effect(func, iterable, chunk_size=None, before=None, after=None):
<span class="gu">@@ -811,7 +1324,21 @@ def side_effect(func, iterable, chunk_size=None, before=None, after=None):</span>
<span class="w"> </span>        True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if before is not None:</span>
<span class="gi">+            before()</span>
<span class="gi">+</span>
<span class="gi">+        if chunk_size is None:</span>
<span class="gi">+            for item in iterable:</span>
<span class="gi">+                func(item)</span>
<span class="gi">+                yield item</span>
<span class="gi">+        else:</span>
<span class="gi">+            for chunk in chunked(iterable, chunk_size):</span>
<span class="gi">+                func(chunk)</span>
<span class="gi">+                yield from chunk</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if after is not None:</span>
<span class="gi">+            after()</span>


<span class="w"> </span>def sliced(seq, n, strict=False):
<span class="gu">@@ -834,7 +1361,18 @@ def sliced(seq, n, strict=False):</span>
<span class="w"> </span>    For non-sliceable iterables, see :func:`chunked`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))</span>
<span class="gi">+    if strict:</span>
<span class="gi">+</span>
<span class="gi">+        def ret():</span>
<span class="gi">+            for _slice in iterator:</span>
<span class="gi">+                if len(_slice) != n:</span>
<span class="gi">+                    raise ValueError(&quot;seq is not divisible by n.&quot;)</span>
<span class="gi">+                yield _slice</span>
<span class="gi">+</span>
<span class="gi">+        return iter(ret())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return iterator</span>


<span class="w"> </span>def split_at(iterable, pred, maxsplit=-1, keep_separator=False):
<span class="gu">@@ -860,7 +1398,25 @@ def split_at(iterable, pred, maxsplit=-1, keep_separator=False):</span>
<span class="w"> </span>        [[&#39;a&#39;], [&#39;b&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;c&#39;], [&#39;b&#39;], [&#39;a&#39;]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if maxsplit == 0:</span>
<span class="gi">+        yield list(iterable)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    buf = []</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    for item in it:</span>
<span class="gi">+        if pred(item):</span>
<span class="gi">+            yield buf</span>
<span class="gi">+            if keep_separator:</span>
<span class="gi">+                yield [item]</span>
<span class="gi">+            if maxsplit == 1:</span>
<span class="gi">+                yield list(it)</span>
<span class="gi">+                return</span>
<span class="gi">+            buf = []</span>
<span class="gi">+            maxsplit -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            buf.append(item)</span>
<span class="gi">+    yield buf</span>


<span class="w"> </span>def split_before(iterable, pred, maxsplit=-1):
<span class="gu">@@ -879,7 +1435,23 @@ def split_before(iterable, pred, maxsplit=-1):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))
<span class="w"> </span>        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if maxsplit == 0:</span>
<span class="gi">+        yield list(iterable)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    buf = []</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    for item in it:</span>
<span class="gi">+        if pred(item) and buf:</span>
<span class="gi">+            yield buf</span>
<span class="gi">+            if maxsplit == 1:</span>
<span class="gi">+                yield [item] + list(it)</span>
<span class="gi">+                return</span>
<span class="gi">+            buf = []</span>
<span class="gi">+            maxsplit -= 1</span>
<span class="gi">+        buf.append(item)</span>
<span class="gi">+    if buf:</span>
<span class="gi">+        yield buf</span>


<span class="w"> </span>def split_after(iterable, pred, maxsplit=-1):
<span class="gu">@@ -899,7 +1471,25 @@ def split_after(iterable, pred, maxsplit=-1):</span>
<span class="w"> </span>        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if maxsplit == 0:</span>
<span class="gi">+        yield list(iterable)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    buf = []</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    for item in it:</span>
<span class="gi">+        buf.append(item)</span>
<span class="gi">+        if pred(item) and buf:</span>
<span class="gi">+            yield buf</span>
<span class="gi">+            if maxsplit == 1:</span>
<span class="gi">+                buf = list(it)</span>
<span class="gi">+                if buf:</span>
<span class="gi">+                    yield buf</span>
<span class="gi">+                return</span>
<span class="gi">+            buf = []</span>
<span class="gi">+            maxsplit -= 1</span>
<span class="gi">+    if buf:</span>
<span class="gi">+        yield buf</span>


<span class="w"> </span>def split_when(iterable, pred, maxsplit=-1):
<span class="gu">@@ -921,7 +1511,30 @@ def split_when(iterable, pred, maxsplit=-1):</span>
<span class="w"> </span>        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if maxsplit == 0:</span>
<span class="gi">+        yield list(iterable)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    try:</span>
<span class="gi">+        cur_item = next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    buf = [cur_item]</span>
<span class="gi">+    for next_item in it:</span>
<span class="gi">+        if pred(cur_item, next_item):</span>
<span class="gi">+            yield buf</span>
<span class="gi">+            if maxsplit == 1:</span>
<span class="gi">+                yield [next_item] + list(it)</span>
<span class="gi">+                return</span>
<span class="gi">+            buf = []</span>
<span class="gi">+            maxsplit -= 1</span>
<span class="gi">+</span>
<span class="gi">+        buf.append(next_item)</span>
<span class="gi">+        cur_item = next_item</span>
<span class="gi">+</span>
<span class="gi">+    yield buf</span>


<span class="w"> </span>def split_into(iterable, sizes):
<span class="gu">@@ -957,7 +1570,16 @@ def split_into(iterable, sizes):</span>
<span class="w"> </span>    (e.g. a point represented by x,y,z) but, the format is not the same for
<span class="w"> </span>    all columns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # convert the iterable argument into an iterator so its contents can</span>
<span class="gi">+    # be consumed by islice in case it is a generator</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    for size in sizes:</span>
<span class="gi">+        if size is None:</span>
<span class="gi">+            yield list(it)</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield list(islice(it, size))</span>


<span class="w"> </span>def padded(iterable, fillvalue=None, n=None, next_multiple=False):
<span class="gu">@@ -984,7 +1606,25 @@ def padded(iterable, fillvalue=None, n=None, next_multiple=False):</span>
<span class="w"> </span>        [1, 2, 3, 4, 5]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterable = iter(iterable)</span>
<span class="gi">+    iterable_with_repeat = chain(iterable, repeat(fillvalue))</span>
<span class="gi">+</span>
<span class="gi">+    if n is None:</span>
<span class="gi">+        return iterable_with_repeat</span>
<span class="gi">+    elif n &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;n must be at least 1&#39;)</span>
<span class="gi">+    elif next_multiple:</span>
<span class="gi">+</span>
<span class="gi">+        def slice_generator():</span>
<span class="gi">+            for first in iterable:</span>
<span class="gi">+                yield (first,)</span>
<span class="gi">+                yield islice(iterable_with_repeat, n - 1)</span>
<span class="gi">+</span>
<span class="gi">+        # While elements exist produce slices of size n</span>
<span class="gi">+        return chain.from_iterable(slice_generator())</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Ensure the first batch is at least size n then iterate</span>
<span class="gi">+        return chain(islice(iterable_with_repeat, n), iterable)</span>


<span class="w"> </span>def repeat_each(iterable, n=2):
<span class="gu">@@ -993,7 +1633,7 @@ def repeat_each(iterable, n=2):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(repeat_each(&#39;ABC&#39;, 3))
<span class="w"> </span>    [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;, &#39;C&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return chain.from_iterable(map(repeat, iterable, repeat(n)))</span>


<span class="w"> </span>def repeat_last(iterable, default=None):
<span class="gu">@@ -1008,7 +1648,11 @@ def repeat_last(iterable, default=None):</span>
<span class="w"> </span>        [42, 42, 42, 42, 42]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    item = _marker</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        yield item</span>
<span class="gi">+    final = default if item is _marker else item</span>
<span class="gi">+    yield from repeat(final)</span>


<span class="w"> </span>def distribute(n, iterable):
<span class="gu">@@ -1041,7 +1685,11 @@ def distribute(n, iterable):</span>
<span class="w"> </span>    original iterable, see :func:`divide`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;n must be at least 1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    children = tee(iterable, n)</span>
<span class="gi">+    return [islice(it, index, None, n) for index, it in enumerate(children)]</span>


<span class="w"> </span>def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):
<span class="gu">@@ -1065,7 +1713,11 @@ def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):</span>
<span class="w"> </span>    sequence. Specify *fillvalue* to use some other value.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    children = tee(iterable, len(offsets))</span>
<span class="gi">+</span>
<span class="gi">+    return zip_offset(</span>
<span class="gi">+        *children, offsets=offsets, longest=longest, fillvalue=fillvalue</span>
<span class="gi">+    )</span>


<span class="w"> </span>def zip_equal(*iterables):
<span class="gu">@@ -1086,7 +1738,17 @@ def zip_equal(*iterables):</span>
<span class="w"> </span>        lengths

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hexversion &gt;= 0x30A00A6:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &#39;zip_equal will be removed in a future version of &#39;</span>
<span class="gi">+                &#39;more-itertools. Use the builtin zip function with &#39;</span>
<span class="gi">+                &#39;strict=True instead.&#39;</span>
<span class="gi">+            ),</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return _zip_equal(*iterables)</span>


<span class="w"> </span>def zip_offset(*iterables, offsets, longest=False, fillvalue=None):
<span class="gu">@@ -1110,11 +1772,27 @@ def zip_offset(*iterables, offsets, longest=False, fillvalue=None):</span>
<span class="w"> </span>    sequence. Specify *fillvalue* to use some other value.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(iterables) != len(offsets):</span>
<span class="gi">+        raise ValueError(&quot;Number of iterables and offsets didn&#39;t match&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    staggered = []</span>
<span class="gi">+    for it, n in zip(iterables, offsets):</span>
<span class="gi">+        if n &lt; 0:</span>
<span class="gi">+            staggered.append(chain(repeat(fillvalue, -n), it))</span>
<span class="gi">+        elif n &gt; 0:</span>
<span class="gi">+            staggered.append(islice(it, n, None))</span>
<span class="gi">+        else:</span>
<span class="gi">+            staggered.append(it)</span>
<span class="gi">+</span>
<span class="gi">+    if longest:</span>
<span class="gi">+        return zip_longest(*staggered, fillvalue=fillvalue)</span>

<span class="gi">+    return zip(*staggered)</span>

<span class="gd">-def sort_together(iterables, key_list=(0,), key=None, reverse=False, strict</span>
<span class="gd">-    =False):</span>
<span class="gi">+</span>
<span class="gi">+def sort_together(</span>
<span class="gi">+    iterables, key_list=(0,), key=None, reverse=False, strict=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the input iterables sorted together, with *key_list* as the
<span class="w"> </span>    priority for sorting. All iterables are trimmed to the length of the
<span class="w"> </span>    shortest one.
<span class="gu">@@ -1158,7 +1836,31 @@ def sort_together(iterables, key_list=(0,), key=None, reverse=False, strict</span>
<span class="w"> </span>    different lengths.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if key is None:</span>
<span class="gi">+        # if there is no key function, the key argument to sorted is an</span>
<span class="gi">+        # itemgetter</span>
<span class="gi">+        key_argument = itemgetter(*key_list)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # if there is a key function, call it with the items at the offsets</span>
<span class="gi">+        # specified by the key function as arguments</span>
<span class="gi">+        key_list = list(key_list)</span>
<span class="gi">+        if len(key_list) == 1:</span>
<span class="gi">+            # if key_list contains a single item, pass the item at that offset</span>
<span class="gi">+            # as the only argument to the key function</span>
<span class="gi">+            key_offset = key_list[0]</span>
<span class="gi">+            key_argument = lambda zipped_items: key(zipped_items[key_offset])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # if key_list contains multiple items, use itemgetter to return a</span>
<span class="gi">+            # tuple of items, which we pass as *args to the key function</span>
<span class="gi">+            get_key_items = itemgetter(*key_list)</span>
<span class="gi">+            key_argument = lambda zipped_items: key(</span>
<span class="gi">+                *get_key_items(zipped_items)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    zipper = zip_equal if strict else zip</span>
<span class="gi">+    return list(</span>
<span class="gi">+        zipper(*sorted(zipper(*iterables), key=key_argument, reverse=reverse))</span>
<span class="gi">+    )</span>


<span class="w"> </span>def unzip(iterable):
<span class="gu">@@ -1181,7 +1883,33 @@ def unzip(iterable):</span>
<span class="w"> </span>    :func:`itertools.tee` and thus may require significant storage.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    head, iterable = spy(iter(iterable))</span>
<span class="gi">+    if not head:</span>
<span class="gi">+        # empty iterable, e.g. zip([], [], [])</span>
<span class="gi">+        return ()</span>
<span class="gi">+    # spy returns a one-length iterable as head</span>
<span class="gi">+    head = head[0]</span>
<span class="gi">+    iterables = tee(iterable, len(head))</span>
<span class="gi">+</span>
<span class="gi">+    def itemgetter(i):</span>
<span class="gi">+        def getter(obj):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return obj[i]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                # basically if we have an iterable like</span>
<span class="gi">+                # iter([(1, 2, 3), (4, 5), (6,)])</span>
<span class="gi">+                # the second unzipped iterable would fail at the third tuple</span>
<span class="gi">+                # since it would try to access tup[1]</span>
<span class="gi">+                # same with the third unzipped iterable and the second tuple</span>
<span class="gi">+                # to support these &quot;improperly zipped&quot; iterables,</span>
<span class="gi">+                # we create a custom itemgetter</span>
<span class="gi">+                # which just stops the unzipped iterables</span>
<span class="gi">+                # at first length mismatch</span>
<span class="gi">+                raise StopIteration</span>
<span class="gi">+</span>
<span class="gi">+        return getter</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(map(itemgetter(i), it) for i, it in enumerate(iterables))</span>


<span class="w"> </span>def divide(n, iterable):
<span class="gu">@@ -1213,7 +1941,26 @@ def divide(n, iterable):</span>
<span class="w"> </span>    pull the iterable into memory.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;n must be at least 1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        iterable[:0]</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        seq = tuple(iterable)</span>
<span class="gi">+    else:</span>
<span class="gi">+        seq = iterable</span>
<span class="gi">+</span>
<span class="gi">+    q, r = divmod(len(seq), n)</span>
<span class="gi">+</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    stop = 0</span>
<span class="gi">+    for i in range(1, n + 1):</span>
<span class="gi">+        start = stop</span>
<span class="gi">+        stop += q + 1 if i &lt;= r else q</span>
<span class="gi">+        ret.append(iter(seq[start:stop]))</span>
<span class="gi">+</span>
<span class="gi">+    return ret</span>


<span class="w"> </span>def always_iterable(obj, base_type=(str, bytes)):
<span class="gu">@@ -1257,7 +2004,16 @@ def always_iterable(obj, base_type=(str, bytes)):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(always_iterable(obj, base_type=None))
<span class="w"> </span>        [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if obj is None:</span>
<span class="gi">+        return iter(())</span>
<span class="gi">+</span>
<span class="gi">+    if (base_type is not None) and isinstance(obj, base_type):</span>
<span class="gi">+        return iter((obj,))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return iter(obj)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return iter((obj,))</span>


<span class="w"> </span>def adjacent(predicate, iterable, distance=1):
<span class="gu">@@ -1288,7 +2044,15 @@ def adjacent(predicate, iterable, distance=1):</span>
<span class="w"> </span>    to group ranges of items with the same `bool` value.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Allow distance=0 mainly for testing that it reproduces results with map()</span>
<span class="gi">+    if distance &lt; 0:</span>
<span class="gi">+        raise ValueError(&#39;distance must be at least 0&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    i1, i2 = tee(iterable)</span>
<span class="gi">+    padding = [False] * distance</span>
<span class="gi">+    selected = chain(padding, map(predicate, i1), padding)</span>
<span class="gi">+    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))</span>
<span class="gi">+    return zip(adjacent_to_selected, i2)</span>


<span class="w"> </span>def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):
<span class="gu">@@ -1327,7 +2091,13 @@ def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):</span>
<span class="w"> </span>    duplicate groups, you should sort the iterable by the key function.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ret = groupby(iterable, keyfunc)</span>
<span class="gi">+    if valuefunc:</span>
<span class="gi">+        ret = ((k, map(valuefunc, g)) for k, g in ret)</span>
<span class="gi">+    if reducefunc:</span>
<span class="gi">+        ret = ((k, reducefunc(g)) for k, g in ret)</span>
<span class="gi">+</span>
<span class="gi">+    return ret</span>


<span class="w"> </span>class numeric_range(abc.Sequence, abc.Hashable):
<span class="gu">@@ -1381,12 +2151,13 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>        datetime.datetime(2019, 1, 2, 0, 0)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _EMPTY_HASH = hash(range(0, 0))

<span class="w"> </span>    def __init__(self, *args):
<span class="w"> </span>        argc = len(args)
<span class="w"> </span>        if argc == 1:
<span class="gd">-            self._stop, = args</span>
<span class="gi">+            (self._stop,) = args</span>
<span class="w"> </span>            self._start = type(self._stop)(0)
<span class="w"> </span>            self._step = type(self._stop - self._start)(1)
<span class="w"> </span>        elif argc == 2:
<span class="gu">@@ -1396,12 +2167,15 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>            self._start, self._stop, self._step = args
<span class="w"> </span>        elif argc == 0:
<span class="w"> </span>            raise TypeError(
<span class="gd">-                &#39;numeric_range expected at least 1 argument, got {}&#39;.format</span>
<span class="gd">-                (argc))</span>
<span class="gi">+                &#39;numeric_range expected at least &#39;</span>
<span class="gi">+                &#39;1 argument, got {}&#39;.format(argc)</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise TypeError(
<span class="gd">-                &#39;numeric_range expected at most 3 arguments, got {}&#39;.format</span>
<span class="gd">-                (argc))</span>
<span class="gi">+                &#39;numeric_range expected at most &#39;</span>
<span class="gi">+                &#39;3 arguments, got {}&#39;.format(argc)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._zero = type(self._step)(0)
<span class="w"> </span>        if self._step == self._zero:
<span class="w"> </span>            raise ValueError(&#39;numeric_range() arg 3 must not be zero&#39;)
<span class="gu">@@ -1417,8 +2191,10 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>        if self._growing:
<span class="w"> </span>            if self._start &lt;= elem &lt; self._stop:
<span class="w"> </span>                return (elem - self._start) % self._step == self._zero
<span class="gd">-        elif self._start &gt;= elem &gt; self._stop:</span>
<span class="gd">-            return (self._start - elem) % -self._step == self._zero</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self._start &gt;= elem &gt; self._stop:</span>
<span class="gi">+                return (self._start - elem) % (-self._step) == self._zero</span>
<span class="gi">+</span>
<span class="w"> </span>        return False

<span class="w"> </span>    def __eq__(self, other):
<span class="gu">@@ -1426,11 +2202,13 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>            empty_self = not bool(self)
<span class="w"> </span>            empty_other = not bool(other)
<span class="w"> </span>            if empty_self or empty_other:
<span class="gd">-                return empty_self and empty_other</span>
<span class="gi">+                return empty_self and empty_other  # True if both empty</span>
<span class="w"> </span>            else:
<span class="gd">-                return (self._start == other._start and self._step == other</span>
<span class="gd">-                    ._step and self._get_by_index(-1) == other.</span>
<span class="gd">-                    _get_by_index(-1))</span>
<span class="gi">+                return (</span>
<span class="gi">+                    self._start == other._start</span>
<span class="gi">+                    and self._step == other._step</span>
<span class="gi">+                    and self._get_by_index(-1) == other._get_by_index(-1)</span>
<span class="gi">+                )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return False

<span class="gu">@@ -1439,23 +2217,27 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>            return self._get_by_index(key)
<span class="w"> </span>        elif isinstance(key, slice):
<span class="w"> </span>            step = self._step if key.step is None else key.step * self._step
<span class="gi">+</span>
<span class="w"> </span>            if key.start is None or key.start &lt;= -self._len:
<span class="w"> </span>                start = self._start
<span class="w"> </span>            elif key.start &gt;= self._len:
<span class="w"> </span>                start = self._stop
<span class="gd">-            else:</span>
<span class="gi">+            else:  # -self._len &lt; key.start &lt; self._len</span>
<span class="w"> </span>                start = self._get_by_index(key.start)
<span class="gi">+</span>
<span class="w"> </span>            if key.stop is None or key.stop &gt;= self._len:
<span class="w"> </span>                stop = self._stop
<span class="w"> </span>            elif key.stop &lt;= -self._len:
<span class="w"> </span>                stop = self._start
<span class="gd">-            else:</span>
<span class="gi">+            else:  # -self._len &lt; key.stop &lt; self._len</span>
<span class="w"> </span>                stop = self._get_by_index(key.stop)
<span class="gi">+</span>
<span class="w"> </span>            return numeric_range(start, stop, step)
<span class="w"> </span>        else:
<span class="w"> </span>            raise TypeError(
<span class="gd">-                &#39;numeric range indices must be integers or slices, not {}&#39;.</span>
<span class="gd">-                format(type(key).__name__))</span>
<span class="gi">+                &#39;numeric range indices must be &#39;</span>
<span class="gi">+                &#39;integers or slices, not {}&#39;.format(type(key).__name__)</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __hash__(self):
<span class="w"> </span>        if self:
<span class="gu">@@ -1464,7 +2246,7 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>            return self._EMPTY_HASH

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        values = (self._start + n * self._step for n in count())</span>
<span class="gi">+        values = (self._start + (n * self._step) for n in count())</span>
<span class="w"> </span>        if self._growing:
<span class="w"> </span>            return takewhile(partial(gt, self._stop), values)
<span class="w"> </span>        else:
<span class="gu">@@ -1473,20 +2255,66 @@ class numeric_range(abc.Sequence, abc.Hashable):</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return self._len

<span class="gi">+    @cached_property</span>
<span class="gi">+    def _len(self):</span>
<span class="gi">+        if self._growing:</span>
<span class="gi">+            start = self._start</span>
<span class="gi">+            stop = self._stop</span>
<span class="gi">+            step = self._step</span>
<span class="gi">+        else:</span>
<span class="gi">+            start = self._stop</span>
<span class="gi">+            stop = self._start</span>
<span class="gi">+            step = -self._step</span>
<span class="gi">+        distance = stop - start</span>
<span class="gi">+        if distance &lt;= self._zero:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        else:  # distance &gt; 0 and step &gt; 0: regular euclidean division</span>
<span class="gi">+            q, r = divmod(distance, step)</span>
<span class="gi">+            return int(q) + int(r != self._zero)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __reduce__(self):
<span class="w"> </span>        return numeric_range, (self._start, self._stop, self._step)

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self._step == 1:
<span class="gd">-            return &#39;numeric_range({}, {})&#39;.format(repr(self._start), repr(</span>
<span class="gd">-                self._stop))</span>
<span class="gi">+            return &quot;numeric_range({}, {})&quot;.format(</span>
<span class="gi">+                repr(self._start), repr(self._stop)</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            return &#39;numeric_range({}, {}, {})&#39;.format(repr(self._start),</span>
<span class="gd">-                repr(self._stop), repr(self._step))</span>
<span class="gi">+            return &quot;numeric_range({}, {}, {})&quot;.format(</span>
<span class="gi">+                repr(self._start), repr(self._stop), repr(self._step)</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __reversed__(self):
<span class="gd">-        return iter(numeric_range(self._get_by_index(-1), self._start -</span>
<span class="gd">-            self._step, -self._step))</span>
<span class="gi">+        return iter(</span>
<span class="gi">+            numeric_range(</span>
<span class="gi">+                self._get_by_index(-1), self._start - self._step, -self._step</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def count(self, value):</span>
<span class="gi">+        return int(value in self)</span>
<span class="gi">+</span>
<span class="gi">+    def index(self, value):</span>
<span class="gi">+        if self._growing:</span>
<span class="gi">+            if self._start &lt;= value &lt; self._stop:</span>
<span class="gi">+                q, r = divmod(value - self._start, self._step)</span>
<span class="gi">+                if r == self._zero:</span>
<span class="gi">+                    return int(q)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self._start &gt;= value &gt; self._stop:</span>
<span class="gi">+                q, r = divmod(self._start - value, -self._step)</span>
<span class="gi">+                if r == self._zero:</span>
<span class="gi">+                    return int(q)</span>
<span class="gi">+</span>
<span class="gi">+        raise ValueError(&quot;{} is not in numeric range&quot;.format(value))</span>
<span class="gi">+</span>
<span class="gi">+    def _get_by_index(self, i):</span>
<span class="gi">+        if i &lt; 0:</span>
<span class="gi">+            i += self._len</span>
<span class="gi">+        if i &lt; 0 or i &gt;= self._len:</span>
<span class="gi">+            raise IndexError(&quot;numeric range object index out of range&quot;)</span>
<span class="gi">+        return self._start + i * self._step</span>


<span class="w"> </span>def count_cycle(iterable, n=None):
<span class="gu">@@ -1498,7 +2326,11 @@ def count_cycle(iterable, n=None):</span>
<span class="w"> </span>    [(0, &#39;A&#39;), (0, &#39;B&#39;), (1, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;A&#39;), (2, &#39;B&#39;)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterable = tuple(iterable)</span>
<span class="gi">+    if not iterable:</span>
<span class="gi">+        return iter(())</span>
<span class="gi">+    counter = count() if n is None else range(n)</span>
<span class="gi">+    return ((i, item) for i in counter for item in iterable)</span>


<span class="w"> </span>def mark_ends(iterable):
<span class="gu">@@ -1521,7 +2353,21 @@ def mark_ends(iterable):</span>
<span class="w"> </span>    &gt;&gt;&gt; print(total)
<span class="w"> </span>    300
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        b = next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for i in count():</span>
<span class="gi">+            a = b</span>
<span class="gi">+            b = next(it)</span>
<span class="gi">+            yield i == 0, False, a</span>
<span class="gi">+</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        yield i == 0, True, a</span>


<span class="w"> </span>def locate(iterable, pred=bool, window_size=None):
<span class="gu">@@ -1562,7 +2408,14 @@ def locate(iterable, pred=bool, window_size=None):</span>
<span class="w"> </span>        106

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if window_size is None:</span>
<span class="gi">+        return compress(count(), map(pred, iterable))</span>
<span class="gi">+</span>
<span class="gi">+    if window_size &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;window size must be at least 1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    it = windowed(iterable, window_size, fillvalue=_marker)</span>
<span class="gi">+    return compress(count(), starmap(pred, it))</span>


<span class="w"> </span>def longest_common_prefix(iterables):
<span class="gu">@@ -1572,7 +2425,7 @@ def longest_common_prefix(iterables):</span>
<span class="w"> </span>    &#39;ab&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (c[0] for c in takewhile(all_equal, zip(*iterables)))</span>


<span class="w"> </span>def lstrip(iterable, pred):
<span class="gu">@@ -1590,7 +2443,7 @@ def lstrip(iterable, pred):</span>
<span class="w"> </span>    an wrapper for :func:`itertools.dropwhile`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return dropwhile(pred, iterable)</span>


<span class="w"> </span>def rstrip(iterable, pred):
<span class="gu">@@ -1607,7 +2460,16 @@ def rstrip(iterable, pred):</span>
<span class="w"> </span>    This function is analogous to :func:`str.rstrip`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache = []</span>
<span class="gi">+    cache_append = cache.append</span>
<span class="gi">+    cache_clear = cache.clear</span>
<span class="gi">+    for x in iterable:</span>
<span class="gi">+        if pred(x):</span>
<span class="gi">+            cache_append(x)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from cache</span>
<span class="gi">+            cache_clear()</span>
<span class="gi">+            yield x</span>


<span class="w"> </span>def strip(iterable, pred):
<span class="gu">@@ -1624,7 +2486,7 @@ def strip(iterable, pred):</span>
<span class="w"> </span>    This function is analogous to :func:`str.strip`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return rstrip(lstrip(iterable, pred), pred)</span>


<span class="w"> </span>class islice_extended:
<span class="gu">@@ -1669,9 +2531,106 @@ class islice_extended:</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        if isinstance(key, slice):
<span class="w"> </span>            return islice_extended(_islice_helper(self._iterable, key))
<span class="gi">+</span>
<span class="w"> </span>        raise TypeError(&#39;islice_extended.__getitem__ argument must be a slice&#39;)


<span class="gi">+def _islice_helper(it, s):</span>
<span class="gi">+    start = s.start</span>
<span class="gi">+    stop = s.stop</span>
<span class="gi">+    if s.step == 0:</span>
<span class="gi">+        raise ValueError(&#39;step argument must be a non-zero integer or None.&#39;)</span>
<span class="gi">+    step = s.step or 1</span>
<span class="gi">+</span>
<span class="gi">+    if step &gt; 0:</span>
<span class="gi">+        start = 0 if (start is None) else start</span>
<span class="gi">+</span>
<span class="gi">+        if start &lt; 0:</span>
<span class="gi">+            # Consume all but the last -start items</span>
<span class="gi">+            cache = deque(enumerate(it, 1), maxlen=-start)</span>
<span class="gi">+            len_iter = cache[-1][0] if cache else 0</span>
<span class="gi">+</span>
<span class="gi">+            # Adjust start to be positive</span>
<span class="gi">+            i = max(len_iter + start, 0)</span>
<span class="gi">+</span>
<span class="gi">+            # Adjust stop to be positive</span>
<span class="gi">+            if stop is None:</span>
<span class="gi">+                j = len_iter</span>
<span class="gi">+            elif stop &gt;= 0:</span>
<span class="gi">+                j = min(stop, len_iter)</span>
<span class="gi">+            else:</span>
<span class="gi">+                j = max(len_iter + stop, 0)</span>
<span class="gi">+</span>
<span class="gi">+            # Slice the cache</span>
<span class="gi">+            n = j - i</span>
<span class="gi">+            if n &lt;= 0:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            for index, item in islice(cache, 0, n, step):</span>
<span class="gi">+                yield item</span>
<span class="gi">+        elif (stop is not None) and (stop &lt; 0):</span>
<span class="gi">+            # Advance to the start position</span>
<span class="gi">+            next(islice(it, start, start), None)</span>
<span class="gi">+</span>
<span class="gi">+            # When stop is negative, we have to carry -stop items while</span>
<span class="gi">+            # iterating</span>
<span class="gi">+            cache = deque(islice(it, -stop), maxlen=-stop)</span>
<span class="gi">+</span>
<span class="gi">+            for index, item in enumerate(it):</span>
<span class="gi">+                cached_item = cache.popleft()</span>
<span class="gi">+                if index % step == 0:</span>
<span class="gi">+                    yield cached_item</span>
<span class="gi">+                cache.append(item)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # When both start and stop are positive we have the normal case</span>
<span class="gi">+            yield from islice(it, start, stop, step)</span>
<span class="gi">+    else:</span>
<span class="gi">+        start = -1 if (start is None) else start</span>
<span class="gi">+</span>
<span class="gi">+        if (stop is not None) and (stop &lt; 0):</span>
<span class="gi">+            # Consume all but the last items</span>
<span class="gi">+            n = -stop - 1</span>
<span class="gi">+            cache = deque(enumerate(it, 1), maxlen=n)</span>
<span class="gi">+            len_iter = cache[-1][0] if cache else 0</span>
<span class="gi">+</span>
<span class="gi">+            # If start and stop are both negative they are comparable and</span>
<span class="gi">+            # we can just slice. Otherwise we can adjust start to be negative</span>
<span class="gi">+            # and then slice.</span>
<span class="gi">+            if start &lt; 0:</span>
<span class="gi">+                i, j = start, stop</span>
<span class="gi">+            else:</span>
<span class="gi">+                i, j = min(start - len_iter, -1), None</span>
<span class="gi">+</span>
<span class="gi">+            for index, item in list(cache)[i:j:step]:</span>
<span class="gi">+                yield item</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Advance to the stop position</span>
<span class="gi">+            if stop is not None:</span>
<span class="gi">+                m = stop + 1</span>
<span class="gi">+                next(islice(it, m, m), None)</span>
<span class="gi">+</span>
<span class="gi">+            # stop is positive, so if start is negative they are not comparable</span>
<span class="gi">+            # and we need the rest of the items.</span>
<span class="gi">+            if start &lt; 0:</span>
<span class="gi">+                i = start</span>
<span class="gi">+                n = None</span>
<span class="gi">+            # stop is None and start is positive, so we just need items up to</span>
<span class="gi">+            # the start index.</span>
<span class="gi">+            elif stop is None:</span>
<span class="gi">+                i = None</span>
<span class="gi">+                n = start + 1</span>
<span class="gi">+            # Both stop and start are positive, so they are comparable.</span>
<span class="gi">+            else:</span>
<span class="gi">+                i = None</span>
<span class="gi">+                n = start - stop</span>
<span class="gi">+                if n &lt;= 0:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            cache = list(islice(it, n))</span>
<span class="gi">+</span>
<span class="gi">+            yield from cache[i::step]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def always_reversible(iterable):
<span class="w"> </span>    &quot;&quot;&quot;An extension of :func:`reversed` that supports all iterables, not
<span class="w"> </span>    just those which implement the ``Reversible`` or ``Sequence`` protocols.
<span class="gu">@@ -1684,7 +2643,10 @@ def always_reversible(iterable):</span>
<span class="w"> </span>    this function will cache the remaining items in the iterable and
<span class="w"> </span>    yield them in reverse order, which may require significant storage.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return reversed(iterable)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return reversed(list(iterable))</span>


<span class="w"> </span>def consecutive_groups(iterable, ordering=lambda x: x):
<span class="gu">@@ -1729,7 +2691,10 @@ def consecutive_groups(iterable, ordering=lambda x: x):</span>
<span class="w"> </span>        [[1, 2], [11, 12], [21, 22]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for k, g in groupby(</span>
<span class="gi">+        enumerate(iterable), key=lambda x: x[0] - ordering(x[1])</span>
<span class="gi">+    ):</span>
<span class="gi">+        yield map(itemgetter(1), g)</span>


<span class="w"> </span>def difference(iterable, func=sub, *, initial=None):
<span class="gu">@@ -1762,7 +2727,16 @@ def difference(iterable, func=sub, *, initial=None):</span>
<span class="w"> </span>        [1, 2, 3]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a, b = tee(iterable)</span>
<span class="gi">+    try:</span>
<span class="gi">+        first = [next(b)]</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return iter([])</span>
<span class="gi">+</span>
<span class="gi">+    if initial is not None:</span>
<span class="gi">+        first = []</span>
<span class="gi">+</span>
<span class="gi">+    return chain(first, map(func, b, a))</span>


<span class="w"> </span>class SequenceView(Sequence):
<span class="gu">@@ -1931,6 +2905,7 @@ class seekable:</span>
<span class="w"> </span>            else:
<span class="w"> </span>                self._index += 1
<span class="w"> </span>                return item
<span class="gi">+</span>
<span class="w"> </span>        item = next(self._source)
<span class="w"> </span>        self._cache.append(item)
<span class="w"> </span>        return item
<span class="gu">@@ -1942,6 +2917,33 @@ class seekable:</span>
<span class="w"> </span>            return False
<span class="w"> </span>        return True

<span class="gi">+    def peek(self, default=_marker):</span>
<span class="gi">+        try:</span>
<span class="gi">+            peeked = next(self)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            if default is _marker:</span>
<span class="gi">+                raise</span>
<span class="gi">+            return default</span>
<span class="gi">+        if self._index is None:</span>
<span class="gi">+            self._index = len(self._cache)</span>
<span class="gi">+        self._index -= 1</span>
<span class="gi">+        return peeked</span>
<span class="gi">+</span>
<span class="gi">+    def elements(self):</span>
<span class="gi">+        return SequenceView(self._cache)</span>
<span class="gi">+</span>
<span class="gi">+    def seek(self, index):</span>
<span class="gi">+        self._index = index</span>
<span class="gi">+        remainder = index - len(self._cache)</span>
<span class="gi">+        if remainder &gt; 0:</span>
<span class="gi">+            consume(self, remainder)</span>
<span class="gi">+</span>
<span class="gi">+    def relative_seek(self, count):</span>
<span class="gi">+        if self._index is None:</span>
<span class="gi">+            self._index = len(self._cache)</span>
<span class="gi">+</span>
<span class="gi">+        self.seek(max(self._index + count, 0))</span>
<span class="gi">+</span>

<span class="w"> </span>class run_length:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -1963,6 +2965,14 @@ class run_length:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def encode(iterable):</span>
<span class="gi">+        return ((k, ilen(g)) for k, g in groupby(iterable))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def decode(iterable):</span>
<span class="gi">+        return chain.from_iterable(starmap(repeat, iterable))</span>
<span class="gi">+</span>

<span class="w"> </span>def exactly_n(iterable, n, predicate=bool):
<span class="w"> </span>    &quot;&quot;&quot;Return ``True`` if exactly ``n`` items in the iterable are ``True``
<span class="gu">@@ -1979,7 +2989,7 @@ def exactly_n(iterable, n, predicate=bool):</span>
<span class="w"> </span>    so avoid calling it on infinite iterables.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(take(n + 1, filter(predicate, iterable))) == n</span>


<span class="w"> </span>def circular_shifts(iterable, steps=1):
<span class="gu">@@ -1998,7 +3008,18 @@ def circular_shifts(iterable, steps=1):</span>
<span class="w"> </span>    [(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buffer = deque(iterable)</span>
<span class="gi">+    if steps == 0:</span>
<span class="gi">+        raise ValueError(&#39;Steps should be a non-zero integer&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    buffer.rotate(steps)</span>
<span class="gi">+    steps = -steps</span>
<span class="gi">+    n = len(buffer)</span>
<span class="gi">+    n //= math.gcd(n, steps)</span>
<span class="gi">+</span>
<span class="gi">+    for __ in repeat(None, n):</span>
<span class="gi">+        buffer.rotate(steps)</span>
<span class="gi">+        yield tuple(buffer)</span>


<span class="w"> </span>def make_decorator(wrapping_func, result_index=0):
<span class="gu">@@ -2049,7 +3070,22 @@ def make_decorator(wrapping_func, result_index=0):</span>
<span class="w"> </span>        &#39;7&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # See https://sites.google.com/site/bbayles/index/decorator_factory for</span>
<span class="gi">+    # notes on how this works.</span>
<span class="gi">+    def decorator(*wrapping_args, **wrapping_kwargs):</span>
<span class="gi">+        def outer_wrapper(f):</span>
<span class="gi">+            def inner_wrapper(*args, **kwargs):</span>
<span class="gi">+                result = f(*args, **kwargs)</span>
<span class="gi">+                wrapping_args_ = list(wrapping_args)</span>
<span class="gi">+                wrapping_args_.insert(result_index, result)</span>
<span class="gi">+                return wrapping_func(*wrapping_args_, **wrapping_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            return inner_wrapper</span>
<span class="gi">+</span>
<span class="gi">+        return outer_wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):
<span class="gu">@@ -2103,7 +3139,20 @@ def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):</span>
<span class="w"> </span>    dictionary.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    valuefunc = (lambda x: x) if (valuefunc is None) else valuefunc</span>
<span class="gi">+</span>
<span class="gi">+    ret = defaultdict(list)</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        key = keyfunc(item)</span>
<span class="gi">+        value = valuefunc(item)</span>
<span class="gi">+        ret[key].append(value)</span>
<span class="gi">+</span>
<span class="gi">+    if reducefunc is not None:</span>
<span class="gi">+        for key, value_list in ret.items():</span>
<span class="gi">+            ret[key] = reducefunc(value_list)</span>
<span class="gi">+</span>
<span class="gi">+    ret.default_factory = None</span>
<span class="gi">+    return ret</span>


<span class="w"> </span>def rlocate(iterable, pred=bool, window_size=None):
<span class="gu">@@ -2139,7 +3188,14 @@ def rlocate(iterable, pred=bool, window_size=None):</span>
<span class="w"> </span>    See :func:`locate` to for other example applications.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if window_size is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            len_iter = len(iterable)</span>
<span class="gi">+            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    return reversed(list(locate(iterable, pred, window_size)))</span>


<span class="w"> </span>def replace(iterable, pred, substitutes, count=None, window_size=1):
<span class="gu">@@ -2171,7 +3227,36 @@ def replace(iterable, pred, substitutes, count=None, window_size=1):</span>
<span class="w"> </span>        [3, 4, 5, 3, 4, 5]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if window_size &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;window_size must be at least 1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Save the substitutes iterable, since it&#39;s used more than once</span>
<span class="gi">+    substitutes = tuple(substitutes)</span>
<span class="gi">+</span>
<span class="gi">+    # Add padding such that the number of windows matches the length of the</span>
<span class="gi">+    # iterable</span>
<span class="gi">+    it = chain(iterable, [_marker] * (window_size - 1))</span>
<span class="gi">+    windows = windowed(it, window_size)</span>
<span class="gi">+</span>
<span class="gi">+    n = 0</span>
<span class="gi">+    for w in windows:</span>
<span class="gi">+        # If the current window matches our predicate (and we haven&#39;t hit</span>
<span class="gi">+        # our maximum number of replacements), splice in the substitutes</span>
<span class="gi">+        # and then consume the following windows that overlap with this one.</span>
<span class="gi">+        # For example, if the iterable is (0, 1, 2, 3, 4...)</span>
<span class="gi">+        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...</span>
<span class="gi">+        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)</span>
<span class="gi">+        if pred(*w):</span>
<span class="gi">+            if (count is None) or (n &lt; count):</span>
<span class="gi">+                n += 1</span>
<span class="gi">+                yield from substitutes</span>
<span class="gi">+                consume(windows, window_size - 1)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        # If there was no match (or we&#39;ve reached the replacement limit),</span>
<span class="gi">+        # yield the first item from the window.</span>
<span class="gi">+        if w and (w[0] is not _marker):</span>
<span class="gi">+            yield w[0]</span>


<span class="w"> </span>def partitions(iterable):
<span class="gu">@@ -2188,7 +3273,10 @@ def partitions(iterable):</span>
<span class="w"> </span>    This is unrelated to :func:`partition`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sequence = list(iterable)</span>
<span class="gi">+    n = len(sequence)</span>
<span class="gi">+    for i in powerset(range(1, n)):</span>
<span class="gi">+        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]</span>


<span class="w"> </span>def set_partitions(iterable, k=None, min_size=None, max_size=None):
<span class="gu">@@ -2230,7 +3318,46 @@ def set_partitions(iterable, k=None, min_size=None, max_size=None):</span>
<span class="w"> </span>    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    L = list(iterable)</span>
<span class="gi">+    n = len(L)</span>
<span class="gi">+    if k is not None:</span>
<span class="gi">+        if k &lt; 1:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Can&#39;t partition in a negative or zero number of groups&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        elif k &gt; n:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    min_size = min_size if min_size is not None else 0</span>
<span class="gi">+    max_size = max_size if max_size is not None else n</span>
<span class="gi">+    if min_size &gt; max_size:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def set_partitions_helper(L, k):</span>
<span class="gi">+        n = len(L)</span>
<span class="gi">+        if k == 1:</span>
<span class="gi">+            yield [L]</span>
<span class="gi">+        elif n == k:</span>
<span class="gi">+            yield [[s] for s in L]</span>
<span class="gi">+        else:</span>
<span class="gi">+            e, *M = L</span>
<span class="gi">+            for p in set_partitions_helper(M, k - 1):</span>
<span class="gi">+                yield [[e], *p]</span>
<span class="gi">+            for p in set_partitions_helper(M, k):</span>
<span class="gi">+                for i in range(len(p)):</span>
<span class="gi">+                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]</span>
<span class="gi">+</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        for k in range(1, n + 1):</span>
<span class="gi">+            yield from filter(</span>
<span class="gi">+                lambda z: all(min_size &lt;= len(bk) &lt;= max_size for bk in z),</span>
<span class="gi">+                set_partitions_helper(L, k),</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from filter(</span>
<span class="gi">+            lambda z: all(min_size &lt;= len(bk) &lt;= max_size for bk in z),</span>
<span class="gi">+            set_partitions_helper(L, k),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class time_limited:
<span class="gu">@@ -2279,6 +3406,7 @@ class time_limited:</span>
<span class="w"> </span>        if monotonic() - self._start_time &gt; self.limit_seconds:
<span class="w"> </span>            self.timed_out = True
<span class="w"> </span>            raise StopIteration
<span class="gi">+</span>
<span class="w"> </span>        return item


<span class="gu">@@ -2306,7 +3434,55 @@ def only(iterable, default=None, too_long=None):</span>
<span class="w"> </span>    is only one item.  See :func:`spy` or :func:`peekable` to check
<span class="w"> </span>    iterable contents less destructively.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    first_value = next(it, default)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        second_value = next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &#39;Expected exactly one item in iterable, but got {!r}, {!r}, &#39;</span>
<span class="gi">+            &#39;and perhaps more.&#39;.format(first_value, second_value)</span>
<span class="gi">+        )</span>
<span class="gi">+        raise too_long or ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    return first_value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ichunk(iterable, n):</span>
<span class="gi">+    cache = deque()</span>
<span class="gi">+    chunk = islice(iterable, n)</span>
<span class="gi">+</span>
<span class="gi">+    def generator():</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if cache:</span>
<span class="gi">+                yield cache.popleft()</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    item = next(chunk)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    return</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield item</span>
<span class="gi">+</span>
<span class="gi">+    def materialize_next(n=1):</span>
<span class="gi">+        # if n not specified materialize everything</span>
<span class="gi">+        if n is None:</span>
<span class="gi">+            cache.extend(chunk)</span>
<span class="gi">+            return len(cache)</span>
<span class="gi">+</span>
<span class="gi">+        to_cache = n - len(cache)</span>
<span class="gi">+</span>
<span class="gi">+        # materialize up to n</span>
<span class="gi">+        if to_cache &gt; 0:</span>
<span class="gi">+            cache.extend(islice(chunk, to_cache))</span>
<span class="gi">+</span>
<span class="gi">+        # return number materialized up to n</span>
<span class="gi">+        return min(n, len(cache))</span>
<span class="gi">+</span>
<span class="gi">+    return (generator(), materialize_next)</span>


<span class="w"> </span>def ichunked(iterable, n):
<span class="gu">@@ -2330,7 +3506,19 @@ def ichunked(iterable, n):</span>
<span class="w"> </span>    [8, 9, 10, 11]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterable = iter(iterable)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # Create new chunk</span>
<span class="gi">+        chunk, materialize_next = _ichunk(iterable, n)</span>
<span class="gi">+</span>
<span class="gi">+        # Check to see whether we&#39;re at the end of the source iterable</span>
<span class="gi">+        if not materialize_next():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        yield chunk</span>
<span class="gi">+</span>
<span class="gi">+        # Fill previous chunk&#39;s cache</span>
<span class="gi">+        materialize_next(None)</span>


<span class="w"> </span>def iequals(*iterables):
<span class="gu">@@ -2350,7 +3538,7 @@ def iequals(*iterables):</span>
<span class="w"> </span>    elements of iterable are equal to each other.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(map(all_equal, zip_longest(*iterables, fillvalue=object())))</span>


<span class="w"> </span>def distinct_combinations(iterable, r):
<span class="gu">@@ -2364,7 +3552,33 @@ def distinct_combinations(iterable, r):</span>
<span class="w"> </span>    efficient.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if r &lt; 0:</span>
<span class="gi">+        raise ValueError(&#39;r must be non-negative&#39;)</span>
<span class="gi">+    elif r == 0:</span>
<span class="gi">+        yield ()</span>
<span class="gi">+        return</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]</span>
<span class="gi">+    current_combo = [None] * r</span>
<span class="gi">+    level = 0</span>
<span class="gi">+    while generators:</span>
<span class="gi">+        try:</span>
<span class="gi">+            cur_idx, p = next(generators[-1])</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            generators.pop()</span>
<span class="gi">+            level -= 1</span>
<span class="gi">+            continue</span>
<span class="gi">+        current_combo[level] = p</span>
<span class="gi">+        if level + 1 == r:</span>
<span class="gi">+            yield tuple(current_combo)</span>
<span class="gi">+        else:</span>
<span class="gi">+            generators.append(</span>
<span class="gi">+                unique_everseen(</span>
<span class="gi">+                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),</span>
<span class="gi">+                    key=itemgetter(1),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            level += 1</span>


<span class="w"> </span>def filter_except(validator, iterable, *exceptions):
<span class="gu">@@ -2382,7 +3596,13 @@ def filter_except(validator, iterable, *exceptions):</span>
<span class="w"> </span>    If an exception other than one given by *exceptions* is raised by
<span class="w"> </span>    *validator*, it is raised like normal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        try:</span>
<span class="gi">+            validator(item)</span>
<span class="gi">+        except exceptions:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield item</span>


<span class="w"> </span>def map_except(function, iterable, *exceptions):
<span class="gu">@@ -2399,7 +3619,11 @@ def map_except(function, iterable, *exceptions):</span>
<span class="w"> </span>    If an exception other than one given by *exceptions* is raised by
<span class="w"> </span>    *function*, it is raised like normal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield function(item)</span>
<span class="gi">+        except exceptions:</span>
<span class="gi">+            pass</span>


<span class="w"> </span>def map_if(iterable, pred, func, func_else=lambda x: x):
<span class="gu">@@ -2420,7 +3644,100 @@ def map_if(iterable, pred, func, func_else=lambda x: x):</span>
<span class="w"> </span>    ... lambda x: f&#39;{sqrt(x):.2f}&#39;, lambda x: None))
<span class="w"> </span>    [None, None, None, None, None, &#39;0.00&#39;, &#39;1.00&#39;, &#39;1.41&#39;, &#39;1.73&#39;, &#39;2.00&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        yield func(item) if pred(item) else func_else(item)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sample_unweighted(iterator, k, strict):</span>
<span class="gi">+    # Algorithm L in the 1994 paper by Kim-Hung Li:</span>
<span class="gi">+    # &quot;Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))&quot;.</span>
<span class="gi">+</span>
<span class="gi">+    reservoir = list(islice(iterator, k))</span>
<span class="gi">+    if strict and len(reservoir) &lt; k:</span>
<span class="gi">+        raise ValueError(&#39;Sample larger than population&#39;)</span>
<span class="gi">+    W = 1.0</span>
<span class="gi">+</span>
<span class="gi">+    with suppress(StopIteration):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            W *= exp(log(random()) / k)</span>
<span class="gi">+            skip = floor(log(random()) / log1p(-W))</span>
<span class="gi">+            element = next(islice(iterator, skip, None))</span>
<span class="gi">+            reservoir[randrange(k)] = element</span>
<span class="gi">+</span>
<span class="gi">+    shuffle(reservoir)</span>
<span class="gi">+    return reservoir</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sample_weighted(iterator, k, weights, strict):</span>
<span class="gi">+    # Implementation of &quot;A-ExpJ&quot; from the 2006 paper by Efraimidis et al. :</span>
<span class="gi">+    # &quot;Weighted random sampling with a reservoir&quot;.</span>
<span class="gi">+</span>
<span class="gi">+    # Log-transform for numerical stability for weights that are small/large</span>
<span class="gi">+    weight_keys = (log(random()) / weight for weight in weights)</span>
<span class="gi">+</span>
<span class="gi">+    # Fill up the reservoir (collection of samples) with the first `k`</span>
<span class="gi">+    # weight-keys and elements, then heapify the list.</span>
<span class="gi">+    reservoir = take(k, zip(weight_keys, iterator))</span>
<span class="gi">+    if strict and len(reservoir) &lt; k:</span>
<span class="gi">+        raise ValueError(&#39;Sample larger than population&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    heapify(reservoir)</span>
<span class="gi">+</span>
<span class="gi">+    # The number of jumps before changing the reservoir is a random variable</span>
<span class="gi">+    # with an exponential distribution. Sample it using random() and logs.</span>
<span class="gi">+    smallest_weight_key, _ = reservoir[0]</span>
<span class="gi">+    weights_to_skip = log(random()) / smallest_weight_key</span>
<span class="gi">+</span>
<span class="gi">+    for weight, element in zip(weights, iterator):</span>
<span class="gi">+        if weight &gt;= weights_to_skip:</span>
<span class="gi">+            # The notation here is consistent with the paper, but we store</span>
<span class="gi">+            # the weight-keys in log-space for better numerical stability.</span>
<span class="gi">+            smallest_weight_key, _ = reservoir[0]</span>
<span class="gi">+            t_w = exp(weight * smallest_weight_key)</span>
<span class="gi">+            r_2 = uniform(t_w, 1)  # generate U(t_w, 1)</span>
<span class="gi">+            weight_key = log(r_2) / weight</span>
<span class="gi">+            heapreplace(reservoir, (weight_key, element))</span>
<span class="gi">+            smallest_weight_key, _ = reservoir[0]</span>
<span class="gi">+            weights_to_skip = log(random()) / smallest_weight_key</span>
<span class="gi">+        else:</span>
<span class="gi">+            weights_to_skip -= weight</span>
<span class="gi">+</span>
<span class="gi">+    ret = [element for weight_key, element in reservoir]</span>
<span class="gi">+    shuffle(ret)</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sample_counted(population, k, counts, strict):</span>
<span class="gi">+    element = None</span>
<span class="gi">+    remaining = 0</span>
<span class="gi">+</span>
<span class="gi">+    def feed(i):</span>
<span class="gi">+        # Advance *i* steps ahead and consume an element</span>
<span class="gi">+        nonlocal element, remaining</span>
<span class="gi">+</span>
<span class="gi">+        while i + 1 &gt; remaining:</span>
<span class="gi">+            i = i - remaining</span>
<span class="gi">+            element = next(population)</span>
<span class="gi">+            remaining = next(counts)</span>
<span class="gi">+        remaining -= i + 1</span>
<span class="gi">+        return element</span>
<span class="gi">+</span>
<span class="gi">+    with suppress(StopIteration):</span>
<span class="gi">+        reservoir = []</span>
<span class="gi">+        for _ in range(k):</span>
<span class="gi">+            reservoir.append(feed(0))</span>
<span class="gi">+        if strict and len(reservoir) &lt; k:</span>
<span class="gi">+            raise ValueError(&#39;Sample larger than population&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        W = 1.0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            W *= exp(log(random()) / k)</span>
<span class="gi">+            skip = floor(log(random()) / log1p(-W))</span>
<span class="gi">+            element = feed(skip)</span>
<span class="gi">+            reservoir[randrange(k)] = element</span>
<span class="gi">+</span>
<span class="gi">+    shuffle(reservoir)</span>
<span class="gi">+    return reservoir</span>


<span class="w"> </span>def sample(iterable, k, weights=None, *, counts=None, strict=False):
<span class="gu">@@ -2461,7 +3778,27 @@ def sample(iterable, k, weights=None, *, counts=None, strict=False):</span>
<span class="w"> </span>    technique is used. When *weights* are provided,
<span class="w"> </span>    `Algorithm A-ExpJ &lt;https://w.wiki/ANrS&gt;`__ is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterator = iter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    if k &lt; 0:</span>
<span class="gi">+        raise ValueError(&#39;k must be non-negative&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if k == 0:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if weights is not None and counts is not None:</span>
<span class="gi">+        raise TypeError(&#39;weights and counts are mutally exclusive&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    elif weights is not None:</span>
<span class="gi">+        weights = iter(weights)</span>
<span class="gi">+        return _sample_weighted(iterator, k, weights, strict)</span>
<span class="gi">+</span>
<span class="gi">+    elif counts is not None:</span>
<span class="gi">+        counts = iter(counts)</span>
<span class="gi">+        return _sample_counted(iterator, k, counts, strict)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _sample_unweighted(iterator, k, strict)</span>


<span class="w"> </span>def is_sorted(iterable, key=None, reverse=False, strict=False):
<span class="gu">@@ -2487,7 +3824,12 @@ def is_sorted(iterable, key=None, reverse=False, strict=False):</span>
<span class="w"> </span>    :func:`sorted` function for objects with unusual comparison dynamics.
<span class="w"> </span>    If there are no out-of-order items, the iterable is exhausted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    compare = le if strict else lt</span>
<span class="gi">+    it = iterable if (key is None) else map(key, iterable)</span>
<span class="gi">+    it_1, it_2 = tee(it)</span>
<span class="gi">+    next(it_2 if reverse else it_1, None)</span>
<span class="gi">+</span>
<span class="gi">+    return not any(map(compare, it_1, it_2))</span>


<span class="w"> </span>class AbortThread(BaseException):
<span class="gu">@@ -2551,8 +3893,10 @@ class callback_iter:</span>
<span class="w"> </span>        self._aborted = False
<span class="w"> </span>        self._future = None
<span class="w"> </span>        self._wait_seconds = wait_seconds
<span class="gd">-        self._executor = __import__(&#39;concurrent.futures&#39;</span>
<span class="gd">-            ).futures.ThreadPoolExecutor(max_workers=1)</span>
<span class="gi">+        # Lazily import concurrent.future</span>
<span class="gi">+        self._executor = __import__(</span>
<span class="gi">+            &#39;concurrent.futures&#39;</span>
<span class="gi">+        ).futures.ThreadPoolExecutor(max_workers=1)</span>
<span class="w"> </span>        self._iterator = self._reader()

<span class="w"> </span>    def __enter__(self):
<span class="gu">@@ -2568,6 +3912,56 @@ class callback_iter:</span>
<span class="w"> </span>    def __next__(self):
<span class="w"> </span>        return next(self._iterator)

<span class="gi">+    @property</span>
<span class="gi">+    def done(self):</span>
<span class="gi">+        if self._future is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return self._future.done()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def result(self):</span>
<span class="gi">+        if not self.done:</span>
<span class="gi">+            raise RuntimeError(&#39;Function has not yet completed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return self._future.result()</span>
<span class="gi">+</span>
<span class="gi">+    def _reader(self):</span>
<span class="gi">+        q = Queue()</span>
<span class="gi">+</span>
<span class="gi">+        def callback(*args, **kwargs):</span>
<span class="gi">+            if self._aborted:</span>
<span class="gi">+                raise AbortThread(&#39;canceled by user&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            q.put((args, kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        self._future = self._executor.submit(</span>
<span class="gi">+            self._func, **{self._callback_kwd: callback}</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                item = q.get(timeout=self._wait_seconds)</span>
<span class="gi">+            except Empty:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                q.task_done()</span>
<span class="gi">+                yield item</span>
<span class="gi">+</span>
<span class="gi">+            if self._future.done():</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        remaining = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                item = q.get_nowait()</span>
<span class="gi">+            except Empty:</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                q.task_done()</span>
<span class="gi">+                remaining.append(item)</span>
<span class="gi">+        q.join()</span>
<span class="gi">+        yield from remaining</span>
<span class="gi">+</span>

<span class="w"> </span>def windowed_complete(iterable, n):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -2593,7 +3987,20 @@ def windowed_complete(iterable, n):</span>
<span class="w"> </span>    This function will exhaust the iterable and may require significant
<span class="w"> </span>    storage.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt; 0:</span>
<span class="gi">+        raise ValueError(&#39;n must be &gt;= 0&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    seq = tuple(iterable)</span>
<span class="gi">+    size = len(seq)</span>
<span class="gi">+</span>
<span class="gi">+    if n &gt; size:</span>
<span class="gi">+        raise ValueError(&#39;n must be &lt;= len(seq)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(size - n + 1):</span>
<span class="gi">+        beginning = seq[:i]</span>
<span class="gi">+        middle = seq[i : i + n]</span>
<span class="gi">+        end = seq[i + n :]</span>
<span class="gi">+        yield beginning, middle, end</span>


<span class="w"> </span>def all_unique(iterable, key=None):
<span class="gu">@@ -2615,7 +4022,20 @@ def all_unique(iterable, key=None):</span>
<span class="w"> </span>    encountered. Iterables with a mix of hashable and unhashable items can
<span class="w"> </span>    be used, but the function will be slower for unhashable items.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seenset = set()</span>
<span class="gi">+    seenset_add = seenset.add</span>
<span class="gi">+    seenlist = []</span>
<span class="gi">+    seenlist_add = seenlist.append</span>
<span class="gi">+    for element in map(key, iterable) if key else iterable:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if element in seenset:</span>
<span class="gi">+                return False</span>
<span class="gi">+            seenset_add(element)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            if element in seenlist:</span>
<span class="gi">+                return False</span>
<span class="gi">+            seenlist_add(element)</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def nth_product(index, *args):
<span class="gu">@@ -2630,7 +4050,23 @@ def nth_product(index, *args):</span>

<span class="w"> </span>    ``IndexError`` will be raised if the given *index* is invalid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pools = list(map(tuple, reversed(args)))</span>
<span class="gi">+    ns = list(map(len, pools))</span>
<span class="gi">+</span>
<span class="gi">+    c = reduce(mul, ns)</span>
<span class="gi">+</span>
<span class="gi">+    if index &lt; 0:</span>
<span class="gi">+        index += c</span>
<span class="gi">+</span>
<span class="gi">+    if not 0 &lt;= index &lt; c:</span>
<span class="gi">+        raise IndexError</span>
<span class="gi">+</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for pool, n in zip(pools, ns):</span>
<span class="gi">+        result.append(pool[index % n])</span>
<span class="gi">+        index //= n</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(reversed(result))</span>


<span class="w"> </span>def nth_permutation(iterable, r, index):
<span class="gu">@@ -2648,7 +4084,33 @@ def nth_permutation(iterable, r, index):</span>
<span class="w"> </span>    of *iterable*.
<span class="w"> </span>    ``IndexError`` will be raised if the given *index* is invalid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = list(iterable)</span>
<span class="gi">+    n = len(pool)</span>
<span class="gi">+</span>
<span class="gi">+    if r is None or r == n:</span>
<span class="gi">+        r, c = n, factorial(n)</span>
<span class="gi">+    elif not 0 &lt;= r &lt; n:</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+    else:</span>
<span class="gi">+        c = perm(n, r)</span>
<span class="gi">+    assert c &gt; 0  # factortial(n)&gt;0, and r&lt;n so perm(n,r) is never zero</span>
<span class="gi">+</span>
<span class="gi">+    if index &lt; 0:</span>
<span class="gi">+        index += c</span>
<span class="gi">+</span>
<span class="gi">+    if not 0 &lt;= index &lt; c:</span>
<span class="gi">+        raise IndexError</span>
<span class="gi">+</span>
<span class="gi">+    result = [0] * r</span>
<span class="gi">+    q = index * factorial(n) // c if r &lt; n else index</span>
<span class="gi">+    for d in range(1, n + 1):</span>
<span class="gi">+        q, i = divmod(q, d)</span>
<span class="gi">+        if 0 &lt;= n - d &lt; r:</span>
<span class="gi">+            result[n - d] = i</span>
<span class="gi">+        if q == 0:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(map(pool.pop, result))</span>


<span class="w"> </span>def nth_combination_with_replacement(iterable, r, index):
<span class="gu">@@ -2668,7 +4130,33 @@ def nth_combination_with_replacement(iterable, r, index):</span>
<span class="w"> </span>    of *iterable*.
<span class="w"> </span>    ``IndexError`` will be raised if the given *index* is invalid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    n = len(pool)</span>
<span class="gi">+    if (r &lt; 0) or (r &gt; n):</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+</span>
<span class="gi">+    c = comb(n + r - 1, r)</span>
<span class="gi">+</span>
<span class="gi">+    if index &lt; 0:</span>
<span class="gi">+        index += c</span>
<span class="gi">+</span>
<span class="gi">+    if (index &lt; 0) or (index &gt;= c):</span>
<span class="gi">+        raise IndexError</span>
<span class="gi">+</span>
<span class="gi">+    result = []</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while r:</span>
<span class="gi">+        r -= 1</span>
<span class="gi">+        while n &gt;= 0:</span>
<span class="gi">+            num_combs = comb(n + r - 1, r)</span>
<span class="gi">+            if index &lt; num_combs:</span>
<span class="gi">+                break</span>
<span class="gi">+            n -= 1</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            index -= num_combs</span>
<span class="gi">+        result.append(pool[i])</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(result)</span>


<span class="w"> </span>def value_chain(*args):
<span class="gu">@@ -2695,7 +4183,14 @@ def value_chain(*args):</span>
<span class="w"> </span>    Multiple levels of nesting are not flattened.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for value in args:</span>
<span class="gi">+        if isinstance(value, (str, bytes)):</span>
<span class="gi">+            yield value</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield from value</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            yield value</span>


<span class="w"> </span>def product_index(element, *args):
<span class="gu">@@ -2711,7 +4206,16 @@ def product_index(element, *args):</span>
<span class="w"> </span>    ``ValueError`` will be raised if the given *element* isn&#39;t in the product
<span class="w"> </span>    of *args*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    index = 0</span>
<span class="gi">+</span>
<span class="gi">+    for x, pool in zip_longest(element, args, fillvalue=_marker):</span>
<span class="gi">+        if x is _marker or pool is _marker:</span>
<span class="gi">+            raise ValueError(&#39;element is not a product of args&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        pool = tuple(pool)</span>
<span class="gi">+        index = index * len(pool) + pool.index(x)</span>
<span class="gi">+</span>
<span class="gi">+    return index</span>


<span class="w"> </span>def combination_index(element, iterable):
<span class="gu">@@ -2727,7 +4231,34 @@ def combination_index(element, iterable):</span>
<span class="w"> </span>    ``ValueError`` will be raised if the given *element* isn&#39;t one of the
<span class="w"> </span>    combinations of *iterable*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    element = enumerate(element)</span>
<span class="gi">+    k, y = next(element, (None, None))</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    indexes = []</span>
<span class="gi">+    pool = enumerate(iterable)</span>
<span class="gi">+    for n, x in pool:</span>
<span class="gi">+        if x == y:</span>
<span class="gi">+            indexes.append(n)</span>
<span class="gi">+            tmp, y = next(element, (None, None))</span>
<span class="gi">+            if tmp is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                k = tmp</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&#39;element is not a combination of iterable&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    n, _ = last(pool, default=(n, None))</span>
<span class="gi">+</span>
<span class="gi">+    # Python versions below 3.8 don&#39;t have math.comb</span>
<span class="gi">+    index = 1</span>
<span class="gi">+    for i, j in enumerate(reversed(indexes), start=1):</span>
<span class="gi">+        j = n - j</span>
<span class="gi">+        if i &lt;= j:</span>
<span class="gi">+            index += comb(j, i)</span>
<span class="gi">+</span>
<span class="gi">+    return comb(n + 1, k + 1) - index</span>


<span class="w"> </span>def combination_with_replacement_index(element, iterable):
<span class="gu">@@ -2745,7 +4276,46 @@ def combination_with_replacement_index(element, iterable):</span>
<span class="w"> </span>    ``ValueError`` will be raised if the given *element* isn&#39;t one of the
<span class="w"> </span>    combinations with replacement of *iterable*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    element = tuple(element)</span>
<span class="gi">+    l = len(element)</span>
<span class="gi">+    element = enumerate(element)</span>
<span class="gi">+</span>
<span class="gi">+    k, y = next(element, (None, None))</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    indexes = []</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    for n, x in enumerate(pool):</span>
<span class="gi">+        while x == y:</span>
<span class="gi">+            indexes.append(n)</span>
<span class="gi">+            tmp, y = next(element, (None, None))</span>
<span class="gi">+            if tmp is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                k = tmp</span>
<span class="gi">+        if y is None:</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &#39;element is not a combination with replacement of iterable&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    n = len(pool)</span>
<span class="gi">+    occupations = [0] * n</span>
<span class="gi">+    for p in indexes:</span>
<span class="gi">+        occupations[p] += 1</span>
<span class="gi">+</span>
<span class="gi">+    index = 0</span>
<span class="gi">+    cumulative_sum = 0</span>
<span class="gi">+    for k in range(1, n):</span>
<span class="gi">+        cumulative_sum += occupations[k - 1]</span>
<span class="gi">+        j = l + n - 1 - k - cumulative_sum</span>
<span class="gi">+        i = n - k</span>
<span class="gi">+        if i &lt;= j:</span>
<span class="gi">+            index += comb(j, i)</span>
<span class="gi">+</span>
<span class="gi">+    return index</span>


<span class="w"> </span>def permutation_index(element, iterable):
<span class="gu">@@ -2762,7 +4332,14 @@ def permutation_index(element, iterable):</span>
<span class="w"> </span>    ``ValueError`` will be raised if the given *element* isn&#39;t one of the
<span class="w"> </span>    permutations of *iterable*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    index = 0</span>
<span class="gi">+    pool = list(iterable)</span>
<span class="gi">+    for i, x in zip(range(len(pool), -1, -1), element):</span>
<span class="gi">+        r = pool.index(x)</span>
<span class="gi">+        index = index * i + r</span>
<span class="gi">+        del pool[r]</span>
<span class="gi">+</span>
<span class="gi">+    return index</span>


<span class="w"> </span>class countable:
<span class="gu">@@ -2793,6 +4370,7 @@ class countable:</span>
<span class="w"> </span>    def __next__(self):
<span class="w"> </span>        item = next(self._it)
<span class="w"> </span>        self.items_seen += 1
<span class="gi">+</span>
<span class="w"> </span>        return item


<span class="gu">@@ -2809,7 +4387,41 @@ def chunked_even(iterable, n):</span>
<span class="w"> </span>    [[1, 2, 3], [4, 5, 6], [7]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iterable = iter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize a buffer to process the chunks while keeping</span>
<span class="gi">+    # some back to fill any underfilled chunks</span>
<span class="gi">+    min_buffer = (n - 1) * (n - 2)</span>
<span class="gi">+    buffer = list(islice(iterable, min_buffer))</span>
<span class="gi">+</span>
<span class="gi">+    # Append items until we have a completed chunk</span>
<span class="gi">+    for _ in islice(map(buffer.append, iterable), n, None, n):</span>
<span class="gi">+        yield buffer[:n]</span>
<span class="gi">+        del buffer[:n]</span>
<span class="gi">+</span>
<span class="gi">+    # Check if any chunks need addition processing</span>
<span class="gi">+    if not buffer:</span>
<span class="gi">+        return</span>
<span class="gi">+    length = len(buffer)</span>
<span class="gi">+</span>
<span class="gi">+    # Chunks are either size `full_size &lt;= n` or `partial_size = full_size - 1`</span>
<span class="gi">+    q, r = divmod(length, n)</span>
<span class="gi">+    num_lists = q + (1 if r &gt; 0 else 0)</span>
<span class="gi">+    q, r = divmod(length, num_lists)</span>
<span class="gi">+    full_size = q + (1 if r &gt; 0 else 0)</span>
<span class="gi">+    partial_size = full_size - 1</span>
<span class="gi">+    num_full = length - partial_size * num_lists</span>
<span class="gi">+</span>
<span class="gi">+    # Yield chunks of full size</span>
<span class="gi">+    partial_start_idx = num_full * full_size</span>
<span class="gi">+    if full_size &gt; 0:</span>
<span class="gi">+        for i in range(0, partial_start_idx, full_size):</span>
<span class="gi">+            yield buffer[i : i + full_size]</span>
<span class="gi">+</span>
<span class="gi">+    # Yield chunks of partial size</span>
<span class="gi">+    if partial_size &gt; 0:</span>
<span class="gi">+        for i in range(partial_start_idx, length, partial_size):</span>
<span class="gi">+            yield buffer[i : i + partial_size]</span>


<span class="w"> </span>def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):
<span class="gu">@@ -2833,7 +4445,39 @@ def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):</span>
<span class="w"> </span>    ``UnequalIterablesError`` will be raised if any of the iterables have
<span class="w"> </span>    different lengths.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def is_scalar(obj):</span>
<span class="gi">+        if scalar_types and isinstance(obj, scalar_types):</span>
<span class="gi">+            return True</span>
<span class="gi">+        try:</span>
<span class="gi">+            iter(obj)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    size = len(objects)</span>
<span class="gi">+    if not size:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    new_item = [None] * size</span>
<span class="gi">+    iterables, iterable_positions = [], []</span>
<span class="gi">+    for i, obj in enumerate(objects):</span>
<span class="gi">+        if is_scalar(obj):</span>
<span class="gi">+            new_item[i] = obj</span>
<span class="gi">+        else:</span>
<span class="gi">+            iterables.append(iter(obj))</span>
<span class="gi">+            iterable_positions.append(i)</span>
<span class="gi">+</span>
<span class="gi">+    if not iterables:</span>
<span class="gi">+        yield tuple(objects)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    zipper = _zip_equal if strict else zip</span>
<span class="gi">+    for item in zipper(*iterables):</span>
<span class="gi">+        for i, new_item[i] in zip(iterable_positions, item):</span>
<span class="gi">+            pass</span>
<span class="gi">+        yield tuple(new_item)</span>


<span class="w"> </span>def unique_in_window(iterable, n, key=None):
<span class="gu">@@ -2853,7 +4497,26 @@ def unique_in_window(iterable, n, key=None):</span>
<span class="w"> </span>    The items in *iterable* must be hashable.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt;= 0:</span>
<span class="gi">+        raise ValueError(&#39;n must be greater than 0&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    window = deque(maxlen=n)</span>
<span class="gi">+    counts = defaultdict(int)</span>
<span class="gi">+    use_key = key is not None</span>
<span class="gi">+</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        if len(window) == n:</span>
<span class="gi">+            to_discard = window[0]</span>
<span class="gi">+            if counts[to_discard] == 1:</span>
<span class="gi">+                del counts[to_discard]</span>
<span class="gi">+            else:</span>
<span class="gi">+                counts[to_discard] -= 1</span>
<span class="gi">+</span>
<span class="gi">+        k = key(item) if use_key else item</span>
<span class="gi">+        if k not in counts:</span>
<span class="gi">+            yield item</span>
<span class="gi">+        counts[k] += 1</span>
<span class="gi">+        window.append(k)</span>


<span class="w"> </span>def duplicates_everseen(iterable, key=None):
<span class="gu">@@ -2868,7 +4531,22 @@ def duplicates_everseen(iterable, key=None):</span>
<span class="w"> </span>    the same performance considerations.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen_set = set()</span>
<span class="gi">+    seen_list = []</span>
<span class="gi">+    use_key = key is not None</span>
<span class="gi">+</span>
<span class="gi">+    for element in iterable:</span>
<span class="gi">+        k = key(element) if use_key else element</span>
<span class="gi">+        try:</span>
<span class="gi">+            if k not in seen_set:</span>
<span class="gi">+                seen_set.add(k)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield element</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            if k not in seen_list:</span>
<span class="gi">+                seen_list.append(k)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield element</span>


<span class="w"> </span>def duplicates_justseen(iterable, key=None):
<span class="gu">@@ -2882,7 +4560,7 @@ def duplicates_justseen(iterable, key=None):</span>
<span class="w"> </span>    This function is analogous to :func:`unique_justseen`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return flatten(g for _, g in groupby(iterable, key) for _ in g)</span>


<span class="w"> </span>def classify_unique(iterable, key=None):
<span class="gu">@@ -2906,7 +4584,25 @@ def classify_unique(iterable, key=None):</span>
<span class="w"> </span>    the same performance considerations.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen_set = set()</span>
<span class="gi">+    seen_list = []</span>
<span class="gi">+    use_key = key is not None</span>
<span class="gi">+    previous = None</span>
<span class="gi">+</span>
<span class="gi">+    for i, element in enumerate(iterable):</span>
<span class="gi">+        k = key(element) if use_key else element</span>
<span class="gi">+        is_unique_justseen = not i or previous != k</span>
<span class="gi">+        previous = k</span>
<span class="gi">+        is_unique_everseen = False</span>
<span class="gi">+        try:</span>
<span class="gi">+            if k not in seen_set:</span>
<span class="gi">+                seen_set.add(k)</span>
<span class="gi">+                is_unique_everseen = True</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            if k not in seen_list:</span>
<span class="gi">+                seen_list.append(k)</span>
<span class="gi">+                is_unique_everseen = True</span>
<span class="gi">+        yield element, is_unique_justseen, is_unique_everseen</span>


<span class="w"> </span>def minmax(iterable_or_value, *others, key=None, default=_marker):
<span class="gu">@@ -2938,11 +4634,51 @@ def minmax(iterable_or_value, *others, key=None, default=_marker):</span>
<span class="w"> </span>    Raymond Hettinger and takes care to minimize the number of comparisons
<span class="w"> </span>    performed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def constrained_batches(iterable, max_size, max_count=None, get_len=len,</span>
<span class="gd">-    strict=True):</span>
<span class="gi">+    iterable = (iterable_or_value, *others) if others else iterable_or_value</span>
<span class="gi">+</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        lo = hi = next(it)</span>
<span class="gi">+    except StopIteration as exc:</span>
<span class="gi">+        if default is _marker:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &#39;`minmax()` argument is an empty iterable. &#39;</span>
<span class="gi">+                &#39;Provide a `default` value to suppress this error.&#39;</span>
<span class="gi">+            ) from exc</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    # Different branches depending on the presence of key. This saves a lot</span>
<span class="gi">+    # of unimportant copies which would slow the &quot;key=None&quot; branch</span>
<span class="gi">+    # significantly down.</span>
<span class="gi">+    if key is None:</span>
<span class="gi">+        for x, y in zip_longest(it, it, fillvalue=lo):</span>
<span class="gi">+            if y &lt; x:</span>
<span class="gi">+                x, y = y, x</span>
<span class="gi">+            if x &lt; lo:</span>
<span class="gi">+                lo = x</span>
<span class="gi">+            if hi &lt; y:</span>
<span class="gi">+                hi = y</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        lo_key = hi_key = key(lo)</span>
<span class="gi">+</span>
<span class="gi">+        for x, y in zip_longest(it, it, fillvalue=lo):</span>
<span class="gi">+            x_key, y_key = key(x), key(y)</span>
<span class="gi">+</span>
<span class="gi">+            if y_key &lt; x_key:</span>
<span class="gi">+                x, y, x_key, y_key = y, x, y_key, x_key</span>
<span class="gi">+            if x_key &lt; lo_key:</span>
<span class="gi">+                lo, lo_key = x, x_key</span>
<span class="gi">+            if hi_key &lt; y_key:</span>
<span class="gi">+                hi, hi_key = y, y_key</span>
<span class="gi">+</span>
<span class="gi">+    return lo, hi</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constrained_batches(</span>
<span class="gi">+    iterable, max_size, max_count=None, get_len=len, strict=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Yield batches of items from *iterable* with a combined size limited by
<span class="w"> </span>    *max_size*.

<span class="gu">@@ -2963,7 +4699,31 @@ def constrained_batches(iterable, max_size, max_count=None, get_len=len,</span>
<span class="w"> </span>    If *strict* is ``True``, raise ``ValueError`` if any single item is bigger
<span class="w"> </span>    than *max_size*. Otherwise, allow single items to exceed *max_size*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if max_size &lt;= 0:</span>
<span class="gi">+        raise ValueError(&#39;maximum size must be greater than zero&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    batch = []</span>
<span class="gi">+    batch_size = 0</span>
<span class="gi">+    batch_count = 0</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        item_len = get_len(item)</span>
<span class="gi">+        if strict and item_len &gt; max_size:</span>
<span class="gi">+            raise ValueError(&#39;item size exceeds maximum size&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        reached_count = batch_count == max_count</span>
<span class="gi">+        reached_size = item_len + batch_size &gt; max_size</span>
<span class="gi">+        if batch_count and (reached_size or reached_count):</span>
<span class="gi">+            yield tuple(batch)</span>
<span class="gi">+            batch.clear()</span>
<span class="gi">+            batch_size = 0</span>
<span class="gi">+            batch_count = 0</span>
<span class="gi">+</span>
<span class="gi">+        batch.append(item)</span>
<span class="gi">+        batch_size += item_len</span>
<span class="gi">+        batch_count += 1</span>
<span class="gi">+</span>
<span class="gi">+    if batch:</span>
<span class="gi">+        yield tuple(batch)</span>


<span class="w"> </span>def gray_product(*iterables):
<span class="gu">@@ -2982,7 +4742,30 @@ def gray_product(*iterables):</span>
<span class="w"> </span>    `this section &lt;https://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz&gt;`__
<span class="w"> </span>    of Donald Knuth&#39;s *The Art of Computer Programming*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    all_iterables = tuple(tuple(x) for x in iterables)</span>
<span class="gi">+    iterable_count = len(all_iterables)</span>
<span class="gi">+    for iterable in all_iterables:</span>
<span class="gi">+        if len(iterable) &lt; 2:</span>
<span class="gi">+            raise ValueError(&quot;each iterable must have two or more items&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # This is based on &quot;Algorithm H&quot; from section 7.2.1.1, page 20.</span>
<span class="gi">+    # a holds the indexes of the source iterables for the n-tuple to be yielded</span>
<span class="gi">+    # f is the array of &quot;focus pointers&quot;</span>
<span class="gi">+    # o is the array of &quot;directions&quot;</span>
<span class="gi">+    a = [0] * iterable_count</span>
<span class="gi">+    f = list(range(iterable_count + 1))</span>
<span class="gi">+    o = [1] * iterable_count</span>
<span class="gi">+    while True:</span>
<span class="gi">+        yield tuple(all_iterables[i][a[i]] for i in range(iterable_count))</span>
<span class="gi">+        j = f[0]</span>
<span class="gi">+        f[0] = 0</span>
<span class="gi">+        if j == iterable_count:</span>
<span class="gi">+            break</span>
<span class="gi">+        a[j] = a[j] + o[j]</span>
<span class="gi">+        if a[j] == 0 or a[j] == len(all_iterables[j]) - 1:</span>
<span class="gi">+            o[j] = -o[j]</span>
<span class="gi">+            f[j] = f[j + 1]</span>
<span class="gi">+            f[j + 1] = j + 1</span>


<span class="w"> </span>def partial_product(*iterables):
<span class="gu">@@ -2996,7 +4779,18 @@ def partial_product(*iterables):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(partial_product(&#39;AB&#39;, &#39;C&#39;, &#39;DEF&#39;))
<span class="w"> </span>        [(&#39;A&#39;, &#39;C&#39;, &#39;D&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;D&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;E&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;F&#39;)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    iterators = list(map(iter, iterables))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        prod = [next(it) for it in iterators]</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+    yield tuple(prod)</span>
<span class="gi">+</span>
<span class="gi">+    for i, it in enumerate(iterators):</span>
<span class="gi">+        for prod[i] in it:</span>
<span class="gi">+            yield tuple(prod)</span>


<span class="w"> </span>def takewhile_inclusive(predicate, iterable):
<span class="gu">@@ -3007,7 +4801,10 @@ def takewhile_inclusive(predicate, iterable):</span>

<span class="w"> </span>    :func:`takewhile` would return ``[1, 4]``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for x in iterable:</span>
<span class="gi">+        yield x</span>
<span class="gi">+        if not predicate(x):</span>
<span class="gi">+            break</span>


<span class="w"> </span>def outer_product(func, xs, ys, *args, **kwargs):
<span class="gu">@@ -3036,7 +4833,11 @@ def outer_product(func, xs, ys, *args, **kwargs):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(outer_product(min, animals, animals, key=len))
<span class="w"> </span>    [(&#39;cat&#39;, &#39;cat&#39;, &#39;cat&#39;), (&#39;cat&#39;, &#39;wolf&#39;, &#39;wolf&#39;), (&#39;cat&#39;, &#39;wolf&#39;, &#39;mouse&#39;)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ys = tuple(ys)</span>
<span class="gi">+    return batched(</span>
<span class="gi">+        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),</span>
<span class="gi">+        n=len(ys),</span>
<span class="gi">+    )</span>


<span class="w"> </span>def iter_suppress(iterable, *exceptions):
<span class="gu">@@ -3056,7 +4857,10 @@ def iter_suppress(iterable, *exceptions):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(chain(it_1, it_2))
<span class="w"> </span>    [1, 2, 3, 4, 2, 3, 4]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield from iterable</span>
<span class="gi">+    except exceptions:</span>
<span class="gi">+        return</span>


<span class="w"> </span>def filter_map(func, iterable):
<span class="gu">@@ -3067,7 +4871,10 @@ def filter_map(func, iterable):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(filter_map(lambda s: int(s) if s.isnumeric() else None, elems))
<span class="w"> </span>    [1, 2, 3]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for x in iterable:</span>
<span class="gi">+        y = func(x)</span>
<span class="gi">+        if y is not None:</span>
<span class="gi">+            yield y</span>


<span class="w"> </span>def powerset_of_sets(iterable):
<span class="gu">@@ -3081,7 +4888,9 @@ def powerset_of_sets(iterable):</span>
<span class="w"> </span>    :func:`powerset_of_sets` takes care to minimize the number
<span class="w"> </span>    of hash operations performed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sets = tuple(map(set, dict.fromkeys(map(frozenset, zip(iterable)))))</span>
<span class="gi">+    for r in range(len(sets) + 1):</span>
<span class="gi">+        yield from starmap(set().union, combinations(sets, r))</span>


<span class="w"> </span>def join_mappings(**field_to_map):
<span class="gu">@@ -3093,14 +4902,25 @@ def join_mappings(**field_to_map):</span>
<span class="w"> </span>    &gt;&gt;&gt; join_mappings(score=user_scores, time=user_times)
<span class="w"> </span>    {&#39;elliot&#39;: {&#39;score&#39;: 50, &#39;time&#39;: 30}, &#39;claris&#39;: {&#39;score&#39;: 60, &#39;time&#39;: 40}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ret = defaultdict(dict)</span>
<span class="gi">+</span>
<span class="gi">+    for field_name, mapping in field_to_map.items():</span>
<span class="gi">+        for key, value in mapping.items():</span>
<span class="gi">+            ret[key][field_name] = value</span>
<span class="gi">+</span>
<span class="gi">+    return dict(ret)</span>


<span class="w"> </span>def _complex_sumprod(v1, v2):
<span class="w"> </span>    &quot;&quot;&quot;High precision sumprod() for complex numbers.
<span class="w"> </span>    Used by :func:`dft` and :func:`idft`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    r1 = chain((p.real for p in v1), (-p.imag for p in v1))</span>
<span class="gi">+    r2 = chain((q.real for q in v2), (q.imag for q in v2))</span>
<span class="gi">+    i1 = chain((p.real for p in v1), (p.imag for p in v1))</span>
<span class="gi">+    i2 = chain((q.imag for q in v2), (q.real for q in v2))</span>
<span class="gi">+    return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))</span>


<span class="w"> </span>def dft(xarr):
<span class="gu">@@ -3115,7 +4935,11 @@ def dft(xarr):</span>

<span class="w"> </span>    See :func:`idft` for the inverse Discrete Fourier Transform.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    N = len(xarr)</span>
<span class="gi">+    roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]</span>
<span class="gi">+    for k in range(N):</span>
<span class="gi">+        coeffs = [roots_of_unity[k * n % N] for n in range(N)]</span>
<span class="gi">+        yield _complex_sumprod(xarr, coeffs)</span>


<span class="w"> </span>def idft(Xarr):
<span class="gu">@@ -3131,7 +4955,11 @@ def idft(Xarr):</span>

<span class="w"> </span>    See :func:`dft` for the Discrete Fourier Transform.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    N = len(Xarr)</span>
<span class="gi">+    roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]</span>
<span class="gi">+    for k in range(N):</span>
<span class="gi">+        coeffs = [roots_of_unity[k * n % N] for n in range(N)]</span>
<span class="gi">+        yield _complex_sumprod(Xarr, coeffs) / N</span>


<span class="w"> </span>def doublestarmap(func, iterable):
<span class="gu">@@ -3148,4 +4976,5 @@ def doublestarmap(func, iterable):</span>
<span class="w"> </span>    ``TypeError`` will be raised if *func*&#39;s signature doesn&#39;t match the
<span class="w"> </span>    mapping contained in *iterable* or if *iterable* does not contain mappings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for item in iterable:</span>
<span class="gi">+        yield func(**item)</span>
<span class="gh">diff --git a/more_itertools/recipes.py b/more_itertools/recipes.py</span>
<span class="gh">index 9c47a54..a21a1f5 100644</span>
<span class="gd">--- a/more_itertools/recipes.py</span>
<span class="gi">+++ b/more_itertools/recipes.py</span>
<span class="gu">@@ -7,32 +7,91 @@ Some backward-compatible usability improvements have been made.</span>
<span class="w"> </span>.. [1] http://docs.python.org/library/itertools.html#recipes

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import operator
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from collections.abc import Sized
<span class="w"> </span>from functools import partial, reduce
<span class="gd">-from itertools import chain, combinations, compress, count, cycle, groupby, islice, product, repeat, starmap, tee, zip_longest</span>
<span class="gi">+from itertools import (</span>
<span class="gi">+    chain,</span>
<span class="gi">+    combinations,</span>
<span class="gi">+    compress,</span>
<span class="gi">+    count,</span>
<span class="gi">+    cycle,</span>
<span class="gi">+    groupby,</span>
<span class="gi">+    islice,</span>
<span class="gi">+    product,</span>
<span class="gi">+    repeat,</span>
<span class="gi">+    starmap,</span>
<span class="gi">+    tee,</span>
<span class="gi">+    zip_longest,</span>
<span class="gi">+)</span>
<span class="w"> </span>from random import randrange, sample, choice
<span class="w"> </span>from sys import hexversion
<span class="gd">-__all__ = [&#39;all_equal&#39;, &#39;batched&#39;, &#39;before_and_after&#39;, &#39;consume&#39;,</span>
<span class="gd">-    &#39;convolve&#39;, &#39;dotproduct&#39;, &#39;first_true&#39;, &#39;factor&#39;, &#39;flatten&#39;, &#39;grouper&#39;,</span>
<span class="gd">-    &#39;iter_except&#39;, &#39;iter_index&#39;, &#39;matmul&#39;, &#39;ncycles&#39;, &#39;nth&#39;,</span>
<span class="gd">-    &#39;nth_combination&#39;, &#39;padnone&#39;, &#39;pad_none&#39;, &#39;pairwise&#39;, &#39;partition&#39;,</span>
<span class="gd">-    &#39;polynomial_eval&#39;, &#39;polynomial_from_roots&#39;, &#39;polynomial_derivative&#39;,</span>
<span class="gd">-    &#39;powerset&#39;, &#39;prepend&#39;, &#39;quantify&#39;, &#39;reshape&#39;,</span>
<span class="gd">-    &#39;random_combination_with_replacement&#39;, &#39;random_combination&#39;,</span>
<span class="gd">-    &#39;random_permutation&#39;, &#39;random_product&#39;, &#39;repeatfunc&#39;, &#39;roundrobin&#39;,</span>
<span class="gd">-    &#39;sieve&#39;, &#39;sliding_window&#39;, &#39;subslices&#39;, &#39;sum_of_squares&#39;, &#39;tabulate&#39;,</span>
<span class="gd">-    &#39;tail&#39;, &#39;take&#39;, &#39;totient&#39;, &#39;transpose&#39;, &#39;triplewise&#39;, &#39;unique&#39;,</span>
<span class="gd">-    &#39;unique_everseen&#39;, &#39;unique_justseen&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;all_equal&#39;,</span>
<span class="gi">+    &#39;batched&#39;,</span>
<span class="gi">+    &#39;before_and_after&#39;,</span>
<span class="gi">+    &#39;consume&#39;,</span>
<span class="gi">+    &#39;convolve&#39;,</span>
<span class="gi">+    &#39;dotproduct&#39;,</span>
<span class="gi">+    &#39;first_true&#39;,</span>
<span class="gi">+    &#39;factor&#39;,</span>
<span class="gi">+    &#39;flatten&#39;,</span>
<span class="gi">+    &#39;grouper&#39;,</span>
<span class="gi">+    &#39;iter_except&#39;,</span>
<span class="gi">+    &#39;iter_index&#39;,</span>
<span class="gi">+    &#39;matmul&#39;,</span>
<span class="gi">+    &#39;ncycles&#39;,</span>
<span class="gi">+    &#39;nth&#39;,</span>
<span class="gi">+    &#39;nth_combination&#39;,</span>
<span class="gi">+    &#39;padnone&#39;,</span>
<span class="gi">+    &#39;pad_none&#39;,</span>
<span class="gi">+    &#39;pairwise&#39;,</span>
<span class="gi">+    &#39;partition&#39;,</span>
<span class="gi">+    &#39;polynomial_eval&#39;,</span>
<span class="gi">+    &#39;polynomial_from_roots&#39;,</span>
<span class="gi">+    &#39;polynomial_derivative&#39;,</span>
<span class="gi">+    &#39;powerset&#39;,</span>
<span class="gi">+    &#39;prepend&#39;,</span>
<span class="gi">+    &#39;quantify&#39;,</span>
<span class="gi">+    &#39;reshape&#39;,</span>
<span class="gi">+    &#39;random_combination_with_replacement&#39;,</span>
<span class="gi">+    &#39;random_combination&#39;,</span>
<span class="gi">+    &#39;random_permutation&#39;,</span>
<span class="gi">+    &#39;random_product&#39;,</span>
<span class="gi">+    &#39;repeatfunc&#39;,</span>
<span class="gi">+    &#39;roundrobin&#39;,</span>
<span class="gi">+    &#39;sieve&#39;,</span>
<span class="gi">+    &#39;sliding_window&#39;,</span>
<span class="gi">+    &#39;subslices&#39;,</span>
<span class="gi">+    &#39;sum_of_squares&#39;,</span>
<span class="gi">+    &#39;tabulate&#39;,</span>
<span class="gi">+    &#39;tail&#39;,</span>
<span class="gi">+    &#39;take&#39;,</span>
<span class="gi">+    &#39;totient&#39;,</span>
<span class="gi">+    &#39;transpose&#39;,</span>
<span class="gi">+    &#39;triplewise&#39;,</span>
<span class="gi">+    &#39;unique&#39;,</span>
<span class="gi">+    &#39;unique_everseen&#39;,</span>
<span class="gi">+    &#39;unique_justseen&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>_marker = object()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# zip with strict is available for Python 3.10+</span>
<span class="w"> </span>try:
<span class="w"> </span>    zip(strict=True)
<span class="w"> </span>except TypeError:
<span class="w"> </span>    _zip_strict = zip
<span class="w"> </span>else:
<span class="w"> </span>    _zip_strict = partial(zip, strict=True)
<span class="gi">+</span>
<span class="gi">+# math.sumprod is available for Python 3.12+</span>
<span class="w"> </span>_sumprod = getattr(math, &#39;sumprod&#39;, lambda x, y: dotproduct(x, y))


<span class="gu">@@ -49,7 +108,7 @@ def take(n, iterable):</span>
<span class="w"> </span>        [0, 1, 2]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(islice(iterable, n))</span>


<span class="w"> </span>def tabulate(function, start=0):
<span class="gu">@@ -67,7 +126,7 @@ def tabulate(function, start=0):</span>
<span class="w"> </span>        [9, 4, 1, 0]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return map(function, count(start))</span>


<span class="w"> </span>def tail(n, iterable):
<span class="gu">@@ -78,7 +137,14 @@ def tail(n, iterable):</span>
<span class="w"> </span>    [&#39;E&#39;, &#39;F&#39;, &#39;G&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If the given iterable has a length, then we can use islice to get its</span>
<span class="gi">+    # final elements. Note that if the iterable is not actually Iterable,</span>
<span class="gi">+    # either islice or deque will throw a TypeError. This is why we don&#39;t</span>
<span class="gi">+    # check if it is Iterable.</span>
<span class="gi">+    if isinstance(iterable, Sized):</span>
<span class="gi">+        yield from islice(iterable, max(0, len(iterable) - n), None)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from iter(deque(iterable, maxlen=n))</span>


<span class="w"> </span>def consume(iterator, n=None):
<span class="gu">@@ -112,7 +178,13 @@ def consume(iterator, n=None):</span>
<span class="w"> </span>        StopIteration

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Use functions that consume iterators at C speed.</span>
<span class="gi">+    if n is None:</span>
<span class="gi">+        # feed the entire iterator into a zero-length deque</span>
<span class="gi">+        deque(iterator, maxlen=0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # advance to the empty slice starting at position n</span>
<span class="gi">+        next(islice(iterator, n, n), None)</span>


<span class="w"> </span>def nth(iterable, n, default=None):
<span class="gu">@@ -125,7 +197,7 @@ def nth(iterable, n, default=None):</span>
<span class="w"> </span>    &#39;zebra&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return next(islice(iterable, n, None), default)</span>


<span class="w"> </span>def all_equal(iterable, key=None):
<span class="gu">@@ -146,7 +218,7 @@ def all_equal(iterable, key=None):</span>
<span class="w"> </span>        True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(list(islice(groupby(iterable, key), 2))) &lt;= 1</span>


<span class="w"> </span>def quantify(iterable, pred=bool):
<span class="gu">@@ -156,7 +228,7 @@ def quantify(iterable, pred=bool):</span>
<span class="w"> </span>    2

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(map(pred, iterable))</span>


<span class="w"> </span>def pad_none(iterable):
<span class="gu">@@ -170,7 +242,7 @@ def pad_none(iterable):</span>
<span class="w"> </span>    See also :func:`padded`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return chain(iterable, repeat(None))</span>


<span class="w"> </span>padnone = pad_none
<span class="gu">@@ -183,7 +255,7 @@ def ncycles(iterable, n):</span>
<span class="w"> </span>    [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return chain.from_iterable(repeat(tuple(iterable), n))</span>


<span class="w"> </span>def dotproduct(vec1, vec2):
<span class="gu">@@ -193,7 +265,7 @@ def dotproduct(vec1, vec2):</span>
<span class="w"> </span>    400

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(map(operator.mul, vec1, vec2))</span>


<span class="w"> </span>def flatten(listOfLists):
<span class="gu">@@ -205,7 +277,7 @@ def flatten(listOfLists):</span>
<span class="w"> </span>    See also :func:`collapse`, which can flatten multiple levels of nesting.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return chain.from_iterable(listOfLists)</span>


<span class="w"> </span>def repeatfunc(func, times=None, *args):
<span class="gu">@@ -230,7 +302,9 @@ def repeatfunc(func, times=None, *args):</span>
<span class="w"> </span>        [2, 4, 8, 1, 8, 4]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if times is None:</span>
<span class="gi">+        return starmap(func, repeat(args))</span>
<span class="gi">+    return starmap(func, repeat(args, times))</span>


<span class="w"> </span>def _pairwise(iterable):
<span class="gu">@@ -242,7 +316,9 @@ def _pairwise(iterable):</span>
<span class="w"> </span>    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a, b = tee(iterable)</span>
<span class="gi">+    next(b, None)</span>
<span class="gi">+    return zip(a, b)</span>


<span class="w"> </span>try:
<span class="gu">@@ -250,19 +326,48 @@ try:</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pairwise = _pairwise
<span class="w"> </span>else:
<span class="gi">+</span>
<span class="gi">+    def pairwise(iterable):</span>
<span class="gi">+        return itertools_pairwise(iterable)</span>
<span class="gi">+</span>
<span class="w"> </span>    pairwise.__doc__ = _pairwise.__doc__


<span class="w"> </span>class UnequalIterablesError(ValueError):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, details=None):
<span class="w"> </span>        msg = &#39;Iterables have different lengths&#39;
<span class="w"> </span>        if details is not None:
<span class="gd">-            msg += &#39;: index 0 has length {}; index {} has length {}&#39;.format(*</span>
<span class="gd">-                details)</span>
<span class="gi">+            msg += (&#39;: index 0 has length {}; index {} has length {}&#39;).format(</span>
<span class="gi">+                *details</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(msg)


<span class="gi">+def _zip_equal_generator(iterables):</span>
<span class="gi">+    for combo in zip_longest(*iterables, fillvalue=_marker):</span>
<span class="gi">+        for val in combo:</span>
<span class="gi">+            if val is _marker:</span>
<span class="gi">+                raise UnequalIterablesError()</span>
<span class="gi">+        yield combo</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _zip_equal(*iterables):</span>
<span class="gi">+    # Check whether the iterables are all the same size.</span>
<span class="gi">+    try:</span>
<span class="gi">+        first_size = len(iterables[0])</span>
<span class="gi">+        for i, it in enumerate(iterables[1:], 1):</span>
<span class="gi">+            size = len(it)</span>
<span class="gi">+            if size != first_size:</span>
<span class="gi">+                raise UnequalIterablesError(details=(first_size, i, size))</span>
<span class="gi">+        # All sizes are equal, we can use the built-in zip.</span>
<span class="gi">+        return zip(*iterables)</span>
<span class="gi">+    # If any one of the iterables didn&#39;t have a length, start reading</span>
<span class="gi">+    # them until one runs out.</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return _zip_equal_generator(iterables)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def grouper(iterable, n, incomplete=&#39;fill&#39;, fillvalue=None):
<span class="w"> </span>    &quot;&quot;&quot;Group elements from *iterable* into fixed-length groups of length *n*.

<span class="gu">@@ -292,7 +397,15 @@ def grouper(iterable, n, incomplete=&#39;fill&#39;, fillvalue=None):</span>
<span class="w"> </span>    UnequalIterablesError

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args = [iter(iterable)] * n</span>
<span class="gi">+    if incomplete == &#39;fill&#39;:</span>
<span class="gi">+        return zip_longest(*args, fillvalue=fillvalue)</span>
<span class="gi">+    if incomplete == &#39;strict&#39;:</span>
<span class="gi">+        return _zip_equal(*args)</span>
<span class="gi">+    if incomplete == &#39;ignore&#39;:</span>
<span class="gi">+        return zip(*args)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&#39;Expected fill, strict, or ignore&#39;)</span>


<span class="w"> </span>def roundrobin(*iterables):
<span class="gu">@@ -306,7 +419,11 @@ def roundrobin(*iterables):</span>
<span class="w"> </span>    iterables is small).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Algorithm credited to George Sakkis</span>
<span class="gi">+    iterators = map(iter, iterables)</span>
<span class="gi">+    for num_active in range(len(iterables), 0, -1):</span>
<span class="gi">+        iterators = cycle(islice(iterators, num_active))</span>
<span class="gi">+        yield from map(next, iterators)</span>


<span class="w"> </span>def partition(pred, iterable):
<span class="gu">@@ -329,7 +446,12 @@ def partition(pred, iterable):</span>
<span class="w"> </span>        ([0, False, &#39;&#39;], [1, True, &#39; &#39;])

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pred is None:</span>
<span class="gi">+        pred = bool</span>
<span class="gi">+</span>
<span class="gi">+    t1, t2, p = tee(iterable, 3)</span>
<span class="gi">+    p1, p2 = tee(map(pred, p))</span>
<span class="gi">+    return (compress(t1, map(operator.not_, p1)), compress(t2, p2))</span>


<span class="w"> </span>def powerset(iterable):
<span class="gu">@@ -349,7 +471,8 @@ def powerset(iterable):</span>
<span class="w"> </span>    For a variant that efficiently yields actual :class:`set` instances, see
<span class="w"> </span>    :func:`powerset_of_sets`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s = list(iterable)</span>
<span class="gi">+    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))</span>


<span class="w"> </span>def unique_everseen(iterable, key=None):
<span class="gu">@@ -379,7 +502,22 @@ def unique_everseen(iterable, key=None):</span>
<span class="w"> </span>    ``key=lambda x: frozenset(x.items())`` can be used.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seenset = set()</span>
<span class="gi">+    seenset_add = seenset.add</span>
<span class="gi">+    seenlist = []</span>
<span class="gi">+    seenlist_add = seenlist.append</span>
<span class="gi">+    use_key = key is not None</span>
<span class="gi">+</span>
<span class="gi">+    for element in iterable:</span>
<span class="gi">+        k = key(element) if use_key else element</span>
<span class="gi">+        try:</span>
<span class="gi">+            if k not in seenset:</span>
<span class="gi">+                seenset_add(k)</span>
<span class="gi">+                yield element</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            if k not in seenlist:</span>
<span class="gi">+                seenlist_add(k)</span>
<span class="gi">+                yield element</span>


<span class="w"> </span>def unique_justseen(iterable, key=None):
<span class="gu">@@ -391,7 +529,10 @@ def unique_justseen(iterable, key=None):</span>
<span class="w"> </span>    [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;D&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if key is None:</span>
<span class="gi">+        return map(operator.itemgetter(0), groupby(iterable))</span>
<span class="gi">+</span>
<span class="gi">+    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))</span>


<span class="w"> </span>def unique(iterable, key=None, reverse=False):
<span class="gu">@@ -410,7 +551,7 @@ def unique(iterable, key=None, reverse=False):</span>
<span class="w"> </span>    The elements in *iterable* need not be hashable, but they must be
<span class="w"> </span>    comparable for sorting to work.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return unique_justseen(sorted(iterable, key=key, reverse=reverse), key=key)</span>


<span class="w"> </span>def iter_except(func, exception, first=None):
<span class="gu">@@ -435,7 +576,13 @@ def iter_except(func, exception, first=None):</span>
<span class="w"> </span>        []

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if first is not None:</span>
<span class="gi">+            yield first()</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            yield func()</span>
<span class="gi">+    except exception:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>def first_true(iterable, default=None, pred=None):
<span class="gu">@@ -455,7 +602,7 @@ def first_true(iterable, default=None, pred=None):</span>
<span class="w"> </span>        &#39;missing&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return next(filter(pred, iterable), default)</span>


<span class="w"> </span>def random_product(*args, repeat=1):
<span class="gu">@@ -474,7 +621,8 @@ def random_product(*args, repeat=1):</span>
<span class="w"> </span>    ``itertools.product(*args, **kwarg)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pools = [tuple(pool) for pool in args] * repeat</span>
<span class="gi">+    return tuple(choice(pool) for pool in pools)</span>


<span class="w"> </span>def random_permutation(iterable, r=None):
<span class="gu">@@ -490,7 +638,9 @@ def random_permutation(iterable, r=None):</span>
<span class="w"> </span>    ``itertools.permutations(iterable, r)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    r = len(pool) if r is None else r</span>
<span class="gi">+    return tuple(sample(pool, r))</span>


<span class="w"> </span>def random_combination(iterable, r):
<span class="gu">@@ -503,7 +653,10 @@ def random_combination(iterable, r):</span>
<span class="w"> </span>    ``itertools.combinations(iterable, r)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    n = len(pool)</span>
<span class="gi">+    indices = sorted(sample(range(n), r))</span>
<span class="gi">+    return tuple(pool[i] for i in indices)</span>


<span class="w"> </span>def random_combination_with_replacement(iterable, r):
<span class="gu">@@ -517,7 +670,10 @@ def random_combination_with_replacement(iterable, r):</span>
<span class="w"> </span>    ``itertools.combinations_with_replacement(iterable, r)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    n = len(pool)</span>
<span class="gi">+    indices = sorted(randrange(n) for i in range(r))</span>
<span class="gi">+    return tuple(pool[i] for i in indices)</span>


<span class="w"> </span>def nth_combination(iterable, r, index):
<span class="gu">@@ -535,7 +691,31 @@ def nth_combination(iterable, r, index):</span>
<span class="w"> </span>    of *iterable*.
<span class="w"> </span>    ``IndexError`` will be raised if the given *index* is invalid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pool = tuple(iterable)</span>
<span class="gi">+    n = len(pool)</span>
<span class="gi">+    if (r &lt; 0) or (r &gt; n):</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+</span>
<span class="gi">+    c = 1</span>
<span class="gi">+    k = min(r, n - r)</span>
<span class="gi">+    for i in range(1, k + 1):</span>
<span class="gi">+        c = c * (n - k + i) // i</span>
<span class="gi">+</span>
<span class="gi">+    if index &lt; 0:</span>
<span class="gi">+        index += c</span>
<span class="gi">+</span>
<span class="gi">+    if (index &lt; 0) or (index &gt;= c):</span>
<span class="gi">+        raise IndexError</span>
<span class="gi">+</span>
<span class="gi">+    result = []</span>
<span class="gi">+    while r:</span>
<span class="gi">+        c, n, r = c * r // n, n - 1, r - 1</span>
<span class="gi">+        while index &gt;= c:</span>
<span class="gi">+            index -= c</span>
<span class="gi">+            c, n = c * (n - r) // n, n - 1</span>
<span class="gi">+        result.append(pool[-1 - n])</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(result)</span>


<span class="w"> </span>def prepend(value, iterator):
<span class="gu">@@ -550,7 +730,7 @@ def prepend(value, iterator):</span>
<span class="w"> </span>    or :func:`value_chain`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return chain([value], iterator)</span>


<span class="w"> </span>def convolve(signal, kernel):
<span class="gu">@@ -565,7 +745,14 @@ def convolve(signal, kernel):</span>
<span class="w"> </span>    is immediately consumed and stored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This implementation intentionally doesn&#39;t match the one in the itertools</span>
<span class="gi">+    # documentation.</span>
<span class="gi">+    kernel = tuple(kernel)[::-1]</span>
<span class="gi">+    n = len(kernel)</span>
<span class="gi">+    window = deque([0], maxlen=n) * n</span>
<span class="gi">+    for x in chain(signal, repeat(0, n - 1)):</span>
<span class="gi">+        window.append(x)</span>
<span class="gi">+        yield _sumprod(kernel, window)</span>


<span class="w"> </span>def before_and_after(predicate, it):
<span class="gu">@@ -582,7 +769,23 @@ def before_and_after(predicate, it):</span>
<span class="w"> </span>    Note that the first iterator must be fully consumed before the second
<span class="w"> </span>    iterator can generate valid results.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    it = iter(it)</span>
<span class="gi">+    transition = []</span>
<span class="gi">+</span>
<span class="gi">+    def true_iterator():</span>
<span class="gi">+        for elem in it:</span>
<span class="gi">+            if predicate(elem):</span>
<span class="gi">+                yield elem</span>
<span class="gi">+            else:</span>
<span class="gi">+                transition.append(elem)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    # Note: this is different from itertools recipes to allow nesting</span>
<span class="gi">+    # before_and_after remainders into before_and_after again. See tests</span>
<span class="gi">+    # for an example.</span>
<span class="gi">+    remainder_iterator = chain(transition, it)</span>
<span class="gi">+</span>
<span class="gi">+    return true_iterator(), remainder_iterator</span>


<span class="w"> </span>def triplewise(iterable):
<span class="gu">@@ -592,7 +795,30 @@ def triplewise(iterable):</span>
<span class="w"> </span>    [(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;D&#39;), (&#39;C&#39;, &#39;D&#39;, &#39;E&#39;)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This deviates from the itertools documentation reciple - see</span>
<span class="gi">+    # https://github.com/more-itertools/more-itertools/issues/889</span>
<span class="gi">+    t1, t2, t3 = tee(iterable, 3)</span>
<span class="gi">+    next(t3, None)</span>
<span class="gi">+    next(t3, None)</span>
<span class="gi">+    next(t2, None)</span>
<span class="gi">+    return zip(t1, t2, t3)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sliding_window_islice(iterable, n):</span>
<span class="gi">+    # Fast path for small, non-zero values of n.</span>
<span class="gi">+    iterators = tee(iterable, n)</span>
<span class="gi">+    for i, iterator in enumerate(iterators):</span>
<span class="gi">+        next(islice(iterator, i, i), None)</span>
<span class="gi">+    return zip(*iterators)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sliding_window_deque(iterable, n):</span>
<span class="gi">+    # Normal path for other values of n.</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    window = deque(islice(it, n - 1), maxlen=n)</span>
<span class="gi">+    for x in it:</span>
<span class="gi">+        window.append(x)</span>
<span class="gi">+        yield tuple(window)</span>


<span class="w"> </span>def sliding_window(iterable, n):
<span class="gu">@@ -608,7 +834,16 @@ def sliding_window(iterable, n):</span>

<span class="w"> </span>    For a variant with more features, see :func:`windowed`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &gt; 20:</span>
<span class="gi">+        return _sliding_window_deque(iterable, n)</span>
<span class="gi">+    elif n &gt; 2:</span>
<span class="gi">+        return _sliding_window_islice(iterable, n)</span>
<span class="gi">+    elif n == 2:</span>
<span class="gi">+        return pairwise(iterable)</span>
<span class="gi">+    elif n == 1:</span>
<span class="gi">+        return zip(iterable)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&#39;n should be at least one, not {n}&#39;)</span>


<span class="w"> </span>def subslices(iterable):
<span class="gu">@@ -620,7 +855,9 @@ def subslices(iterable):</span>
<span class="w"> </span>    This is similar to :func:`substrings`, but emits items in a different
<span class="w"> </span>    order.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seq = list(iterable)</span>
<span class="gi">+    slices = starmap(slice, combinations(range(len(seq) + 1), 2))</span>
<span class="gi">+    return map(operator.getitem, repeat(seq), slices)</span>


<span class="w"> </span>def polynomial_from_roots(roots):
<span class="gu">@@ -630,7 +867,8 @@ def polynomial_from_roots(roots):</span>
<span class="w"> </span>    &gt;&gt;&gt; polynomial_from_roots(roots)  # x^3 - 4 * x^2 - 17 * x + 60
<span class="w"> </span>    [1, -4, -17, 60]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    factors = zip(repeat(1), map(operator.neg, roots))</span>
<span class="gi">+    return list(reduce(convolve, factors, [1]))</span>


<span class="w"> </span>def iter_index(iterable, value, start=0, stop=None):
<span class="gu">@@ -658,7 +896,22 @@ def iter_index(iterable, value, start=0, stop=None):</span>
<span class="w"> </span>    associated with particular values.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seq_index = getattr(iterable, &#39;index&#39;, None)</span>
<span class="gi">+    if seq_index is None:</span>
<span class="gi">+        # Slow path for general iterables</span>
<span class="gi">+        it = islice(iterable, start, stop)</span>
<span class="gi">+        for i, element in enumerate(it, start):</span>
<span class="gi">+            if element is value or element == value:</span>
<span class="gi">+                yield i</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Fast path for sequences</span>
<span class="gi">+        stop = len(iterable) if stop is None else stop</span>
<span class="gi">+        i = start - 1</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                yield (i := seq_index(value, i + 1, stop))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>


<span class="w"> </span>def sieve(n):
<span class="gu">@@ -667,7 +920,16 @@ def sieve(n):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(sieve(30))
<span class="w"> </span>    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &gt; 2:</span>
<span class="gi">+        yield 2</span>
<span class="gi">+    start = 3</span>
<span class="gi">+    data = bytearray((0, 1)) * (n // 2)</span>
<span class="gi">+    limit = math.isqrt(n) + 1</span>
<span class="gi">+    for p in iter_index(data, 1, start, limit):</span>
<span class="gi">+        yield from iter_index(data, 1, start, p * p)</span>
<span class="gi">+        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))</span>
<span class="gi">+        start = p * p</span>
<span class="gi">+    yield from iter_index(data, 1, start)</span>


<span class="w"> </span>def _batched(iterable, n, *, strict=False):
<span class="gu">@@ -681,13 +943,24 @@ def _batched(iterable, n, *, strict=False):</span>

<span class="w"> </span>    On Python 3.13 and above, this is an alias for :func:`itertools.batched`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise ValueError(&#39;n must be at least one&#39;)</span>
<span class="gi">+    it = iter(iterable)</span>
<span class="gi">+    while batch := tuple(islice(it, n)):</span>
<span class="gi">+        if strict and len(batch) != n:</span>
<span class="gi">+            raise ValueError(&#39;batched(): incomplete batch&#39;)</span>
<span class="gi">+        yield batch</span>


<span class="gd">-if hexversion &gt;= 51183778:</span>
<span class="gi">+if hexversion &gt;= 0x30D00A2:</span>
<span class="w"> </span>    from itertools import batched as itertools_batched
<span class="gi">+</span>
<span class="gi">+    def batched(iterable, n, *, strict=False):</span>
<span class="gi">+        return itertools_batched(iterable, n, strict=strict)</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    batched = _batched
<span class="gi">+</span>
<span class="w"> </span>    batched.__doc__ = _batched.__doc__


<span class="gu">@@ -700,7 +973,7 @@ def transpose(it):</span>
<span class="w"> </span>    The caller should ensure that the dimensions of the input are compatible.
<span class="w"> </span>    If the input is empty, no output will be produced.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _zip_strict(*it)</span>


<span class="w"> </span>def reshape(matrix, cols):
<span class="gu">@@ -711,7 +984,7 @@ def reshape(matrix, cols):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(reshape(matrix, cols))
<span class="w"> </span>    [(0, 1, 2), (3, 4, 5)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return batched(chain.from_iterable(matrix), cols)</span>


<span class="w"> </span>def matmul(m1, m2):
<span class="gu">@@ -723,7 +996,8 @@ def matmul(m1, m2):</span>
<span class="w"> </span>    The caller should ensure that the dimensions of the input matrices are
<span class="w"> </span>    compatible with each other.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(m2[0])</span>
<span class="gi">+    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)</span>


<span class="w"> </span>def factor(n):
<span class="gu">@@ -732,7 +1006,14 @@ def factor(n):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(factor(360))
<span class="w"> </span>    [2, 2, 2, 3, 3, 5]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for prime in sieve(math.isqrt(n) + 1):</span>
<span class="gi">+        while not n % prime:</span>
<span class="gi">+            yield prime</span>
<span class="gi">+            n //= prime</span>
<span class="gi">+            if n == 1:</span>
<span class="gi">+                return</span>
<span class="gi">+    if n &gt; 1:</span>
<span class="gi">+        yield n</span>


<span class="w"> </span>def polynomial_eval(coefficients, x):
<span class="gu">@@ -745,7 +1026,11 @@ def polynomial_eval(coefficients, x):</span>
<span class="w"> </span>    &gt;&gt;&gt; polynomial_eval(coefficients, x)
<span class="w"> </span>    8.125
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(coefficients)</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        return x * 0  # coerce zero to the type of x</span>
<span class="gi">+    powers = map(pow, repeat(x), reversed(range(n)))</span>
<span class="gi">+    return _sumprod(coefficients, powers)</span>


<span class="w"> </span>def sum_of_squares(it):
<span class="gu">@@ -754,7 +1039,7 @@ def sum_of_squares(it):</span>
<span class="w"> </span>    &gt;&gt;&gt; sum_of_squares([10, 20, 30])
<span class="w"> </span>    1400
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _sumprod(*tee(it))</span>


<span class="w"> </span>def polynomial_derivative(coefficients):
<span class="gu">@@ -767,7 +1052,9 @@ def polynomial_derivative(coefficients):</span>
<span class="w"> </span>    &gt;&gt;&gt; derivative_coefficients
<span class="w"> </span>    [3, -8, -17]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(coefficients)</span>
<span class="gi">+    powers = reversed(range(1, n))</span>
<span class="gi">+    return list(map(operator.mul, coefficients, powers))</span>


<span class="w"> </span>def totient(n):
<span class="gu">@@ -778,4 +1065,6 @@ def totient(n):</span>
<span class="w"> </span>    &gt;&gt;&gt; totient(12)
<span class="w"> </span>    4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for prime in set(factor(n)):</span>
<span class="gi">+        n -= n // prime</span>
<span class="gi">+    return n</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>