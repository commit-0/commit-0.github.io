
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands tlslite ng - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-tlslite-ng" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands tlslite ng
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-unit_tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test unit_tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-tlslite-ng"><strong>OpenHands</strong>: tlslite-ng</h1>
<h2 id="failed-to-run-pytests-for-test-unit_tests">Failed to run pytests for test <code>unit_tests</code></h2>
<div class="highlight"><pre><span></span><code>Unknown failure.
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/tlslite/handshakehashes.py b/tlslite/handshakehashes.py</span>
<span class="gh">index 137b20b..e4b3fcc 100644</span>
<span class="gd">--- a/tlslite/handshakehashes.py</span>
<span class="gi">+++ b/tlslite/handshakehashes.py</span>
<span class="gu">@@ -27,7 +27,13 @@ class HandshakeHashes(object):</span>

<span class="w"> </span>        :param bytearray data: serialized TLS handshake message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._handshakeMD5.update(compat26Str(data))</span>
<span class="gi">+        self._handshakeSHA.update(compat26Str(data))</span>
<span class="gi">+        self._handshakeSHA224.update(compat26Str(data))</span>
<span class="gi">+        self._handshakeSHA256.update(compat26Str(data))</span>
<span class="gi">+        self._handshakeSHA384.update(compat26Str(data))</span>
<span class="gi">+        self._handshakeSHA512.update(compat26Str(data))</span>
<span class="gi">+        self._handshake_buffer += data</span>

<span class="w"> </span>    def digest(self, digest=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -37,7 +43,22 @@ class HandshakeHashes(object):</span>

<span class="w"> </span>        :param str digest: name of digest to return
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if digest is None:</span>
<span class="gi">+            return self._handshakeMD5.digest() + self._handshakeSHA.digest()</span>
<span class="gi">+        elif digest == &#39;md5&#39;:</span>
<span class="gi">+            return self._handshakeMD5.digest()</span>
<span class="gi">+        elif digest == &#39;sha1&#39;:</span>
<span class="gi">+            return self._handshakeSHA.digest()</span>
<span class="gi">+        elif digest == &#39;sha224&#39;:</span>
<span class="gi">+            return self._handshakeSHA224.digest()</span>
<span class="gi">+        elif digest == &#39;sha256&#39;:</span>
<span class="gi">+            return self._handshakeSHA256.digest()</span>
<span class="gi">+        elif digest == &#39;sha384&#39;:</span>
<span class="gi">+            return self._handshakeSHA384.digest()</span>
<span class="gi">+        elif digest == &#39;sha512&#39;:</span>
<span class="gi">+            return self._handshakeSHA512.digest()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unknown digest type&quot;)</span>

<span class="w"> </span>    def digestSSL(self, masterSecret, label):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -48,7 +69,11 @@ class HandshakeHashes(object):</span>
<span class="w"> </span>        :param bytearray masterSecret: value of the master secret
<span class="w"> </span>        :param bytearray label: label to include in the calculation
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inner1 = label + masterSecret + bytearray([0x36] * 48)</span>
<span class="gi">+        inner2 = label + masterSecret + bytearray([0x5c] * 48)</span>
<span class="gi">+        md5_inner = MD5(inner1 + self._handshakeMD5.digest())</span>
<span class="gi">+        sha_inner = SHA1(inner2 + self._handshakeSHA.digest())</span>
<span class="gi">+        return md5_inner + sha_inner</span>

<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,4 +84,12 @@ class HandshakeHashes(object):</span>

<span class="w"> </span>        :rtype: HandshakeHashes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        new = HandshakeHashes()</span>
<span class="gi">+        new._handshakeMD5 = self._handshakeMD5.copy()</span>
<span class="gi">+        new._handshakeSHA = self._handshakeSHA.copy()</span>
<span class="gi">+        new._handshakeSHA224 = self._handshakeSHA224.copy()</span>
<span class="gi">+        new._handshakeSHA256 = self._handshakeSHA256.copy()</span>
<span class="gi">+        new._handshakeSHA384 = self._handshakeSHA384.copy()</span>
<span class="gi">+        new._handshakeSHA512 = self._handshakeSHA512.copy()</span>
<span class="gi">+        new._handshake_buffer = self._handshake_buffer[:]</span>
<span class="gi">+        return new</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/handshakesettings.py b/tlslite/handshakesettings.py</span>
<span class="gh">index 2f8e245..5877645 100644</span>
<span class="gd">--- a/tlslite/handshakesettings.py</span>
<span class="gi">+++ b/tlslite/handshakesettings.py</span>
<span class="gu">@@ -316,11 +316,37 @@ class HandshakeSettings(object):</span>

<span class="w"> </span>    def _init_key_settings(self):
<span class="w"> </span>        &quot;&quot;&quot;Create default variables for key-related settings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.minKeySize = 1023</span>
<span class="gi">+        self.maxKeySize = 8193</span>
<span class="gi">+        self.rsaSigHashes = list(RSA_SIGNATURE_HASHES)</span>
<span class="gi">+        self.dsaSigHashes = list(DSA_SIGNATURE_HASHES)</span>
<span class="gi">+        self.ecdsaSigHashes = list(ECDSA_SIGNATURE_HASHES)</span>
<span class="gi">+        self.more_sig_schemes = list(SIGNATURE_SCHEMES)</span>
<span class="gi">+        self.rsa_schemes = list(RSA_SCHEMES)</span>
<span class="gi">+        self.eccCurves = list(CURVE_NAMES)</span>
<span class="gi">+        self.dhGroups = list(ALL_DH_GROUP_NAMES)</span>
<span class="gi">+        self.defaultCurve = &quot;secp256r1&quot;</span>
<span class="gi">+        self.keyShares = [&quot;secp256r1&quot;, &quot;x25519&quot;]</span>
<span class="gi">+        self.certificateTypes = list(CERTIFICATE_TYPES)</span>

<span class="w"> </span>    def _init_misc_extensions(self):
<span class="w"> </span>        &quot;&quot;&quot;Default variables for assorted extensions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.useExtendedMasterSecret = True</span>
<span class="gi">+        self.requireExtendedMasterSecret = False</span>
<span class="gi">+        self.useEncryptThenMAC = True</span>
<span class="gi">+        self.useExperimentalTackExtension = False</span>
<span class="gi">+        self.sendFallbackSCSV = False</span>
<span class="gi">+        self.use_heartbeat_extension = True</span>
<span class="gi">+        self.heartbeat_response_callback = None</span>
<span class="gi">+        self.record_size_limit = None</span>
<span class="gi">+        self.padding_cb = None</span>
<span class="gi">+        self.pskConfigs = []</span>
<span class="gi">+        self.psk_modes = list(PSK_MODES)</span>
<span class="gi">+        self.max_early_data = 0</span>
<span class="gi">+        self.ticketKeys = []</span>
<span class="gi">+        self.ticketCipher = &quot;aes256gcm&quot;</span>
<span class="gi">+        self.ticketLifetime = 24 * 60 * 60  # 1 day</span>
<span class="gi">+        self.ticket_count = 1</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Initialise default values for settings.&quot;&quot;&quot;
<span class="gu">@@ -337,86 +363,327 @@ class HandshakeSettings(object):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckKeySizes(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if key size limits are sane&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.minKeySize &lt; 512:</span>
<span class="gi">+            raise ValueError(&quot;minKeySize too small&quot;)</span>
<span class="gi">+        if other.minKeySize &gt; 16384:</span>
<span class="gi">+            raise ValueError(&quot;minKeySize too large&quot;)</span>
<span class="gi">+        if other.maxKeySize &lt; 512:</span>
<span class="gi">+            raise ValueError(&quot;maxKeySize too small&quot;)</span>
<span class="gi">+        if other.maxKeySize &gt; 16384:</span>
<span class="gi">+            raise ValueError(&quot;maxKeySize too large&quot;)</span>
<span class="gi">+        if other.maxKeySize &lt; other.minKeySize:</span>
<span class="gi">+            raise ValueError(&quot;maxKeySize smaller than minKeySize&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _not_matching(values, sieve):
<span class="w"> </span>        &quot;&quot;&quot;Return list of items from values that are not in sieve.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [val for val in values if val not in sieve]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckCipherSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if specified cipher settings are known.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.cipherNames,</span>
<span class="gi">+                                                     ALL_CIPHER_NAMES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown cipher name: {0}&quot;.format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.macNames,</span>
<span class="gi">+                                                     ALL_MAC_NAMES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown MAC name: {0}&quot;.format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(</span>
<span class="gi">+            other.cipherImplementations, CIPHER_IMPLEMENTATIONS)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown cipher implementation: {0}&quot;</span>
<span class="gi">+                           .format(not_matching))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckECDHSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check ECDHE settings if they are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.eccCurves,</span>
<span class="gi">+                                                     ALL_CURVE_NAMES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown ECC curve name: {0}&quot;.format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        if other.defaultCurve not in ALL_CURVE_NAMES:</span>
<span class="gi">+            raise ValueError(&quot;Unknown default ECC curve name: {0}&quot;</span>
<span class="gi">+                           .format(other.defaultCurve))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckDHSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if (EC)DHE settings are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.dhGroups,</span>
<span class="gi">+                                                     ALL_DH_GROUP_NAMES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown DH group name: {0}&quot;.format(not_matching))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckPrimitivesNames(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if specified cryptographic primitive names are known&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.rsaSigHashes,</span>
<span class="gi">+                                                     ALL_RSA_SIGNATURE_HASHES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown RSA signature hash: {0}&quot;</span>
<span class="gi">+                           .format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.dsaSigHashes,</span>
<span class="gi">+                                                     DSA_SIGNATURE_HASHES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown DSA signature hash: {0}&quot;</span>
<span class="gi">+                           .format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.ecdsaSigHashes,</span>
<span class="gi">+                                                     ECDSA_SIGNATURE_HASHES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown ECDSA signature hash: {0}&quot;</span>
<span class="gi">+                           .format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.more_sig_schemes,</span>
<span class="gi">+                                                     SIGNATURE_SCHEMES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown signature scheme: {0}&quot;</span>
<span class="gi">+                           .format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching(other.rsa_schemes,</span>
<span class="gi">+                                                     RSA_SCHEMES)</span>
<span class="gi">+        if not_matching:</span>
<span class="gi">+            raise ValueError(&quot;Unknown RSA scheme: {0}&quot;</span>
<span class="gi">+                           .format(not_matching))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckProtocolVersions(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if set protocol version are sane&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.minVersion &gt; other.maxVersion:</span>
<span class="gi">+            raise ValueError(&quot;Versions set incorrectly&quot;)</span>
<span class="gi">+        if other.minVersion not in KNOWN_VERSIONS:</span>
<span class="gi">+            raise ValueError(&quot;Unknown minimum protocol version&quot;)</span>
<span class="gi">+        if other.maxVersion not in KNOWN_VERSIONS:</span>
<span class="gi">+            raise ValueError(&quot;Unknown maximum protocol version&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckEMSExtension(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if settings for EMS are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.requireExtendedMasterSecret and \</span>
<span class="gi">+                not other.useExtendedMasterSecret:</span>
<span class="gi">+            raise ValueError(&quot;Require Extended Master Secret but don&#39;t use it&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckExtensions(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if set extension settings are sane&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.record_size_limit is not None:</span>
<span class="gi">+            if not 64 &lt;= other.record_size_limit &lt;= 2**14+1:</span>
<span class="gi">+                raise ValueError(&quot;Record size limit must be between 64 and 16385&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _not_allowed_len(values, sieve):
<span class="w"> </span>        &quot;&quot;&quot;Return True if length of any item in values is not in sieve.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(len(i) not in sieve for i in values)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckPsks(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if the set PSKs are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.psk_modes:</span>
<span class="gi">+            not_matching = HandshakeSettings._not_matching(other.psk_modes,</span>
<span class="gi">+                                                         PSK_MODES)</span>
<span class="gi">+            if not_matching:</span>
<span class="gi">+                raise ValueError(&quot;Unknown PSK mode: {0}&quot;.format(not_matching))</span>
<span class="gi">+</span>
<span class="gi">+        if not all(isinstance(i, (bytes, bytearray)) for i in other.pskConfigs):</span>
<span class="gi">+            raise ValueError(&quot;PSK identity must be a bytes-like object&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckTicketSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if the session ticket settings are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.ticketCipher not in TICKET_CIPHERS:</span>
<span class="gi">+            raise ValueError(&quot;Unknown ticket cipher&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.ticketLifetime &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Ticket lifetime must be a positive integer&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.ticket_count &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Ticket count must be a positive integer&quot;)</span>

<span class="w"> </span>    def _copy_cipher_settings(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Copy values related to cipher selection.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other.cipherNames = self.cipherNames</span>
<span class="gi">+        other.macNames = self.macNames</span>
<span class="gi">+        other.keyExchangeNames = self.keyExchangeNames</span>
<span class="gi">+        other.cipherImplementations = self.cipherImplementations</span>
<span class="gi">+        other.minVersion = self.minVersion</span>
<span class="gi">+        other.maxVersion = self.maxVersion</span>
<span class="gi">+        other.versions = self.versions</span>

<span class="w"> </span>    def _copy_extension_settings(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Copy values of settings related to extensions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other.useExtendedMasterSecret = self.useExtendedMasterSecret</span>
<span class="gi">+        other.requireExtendedMasterSecret = self.requireExtendedMasterSecret</span>
<span class="gi">+        other.useEncryptThenMAC = self.useEncryptThenMAC</span>
<span class="gi">+        other.useExperimentalTackExtension = self.useExperimentalTackExtension</span>
<span class="gi">+        other.sendFallbackSCSV = self.sendFallbackSCSV</span>
<span class="gi">+        other.use_heartbeat_extension = self.use_heartbeat_extension</span>
<span class="gi">+        other.heartbeat_response_callback = self.heartbeat_response_callback</span>
<span class="gi">+        other.record_size_limit = self.record_size_limit</span>
<span class="gi">+        other.padding_cb = self.padding_cb</span>
<span class="gi">+        other.pskConfigs = self.pskConfigs</span>
<span class="gi">+        other.psk_modes = self.psk_modes</span>
<span class="gi">+        other.max_early_data = self.max_early_data</span>
<span class="gi">+        other.ticketKeys = self.ticketKeys</span>
<span class="gi">+        other.ticketCipher = self.ticketCipher</span>
<span class="gi">+        other.ticketLifetime = self.ticketLifetime</span>
<span class="gi">+        other.ticket_count = self.ticket_count</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _remove_all_matches(values, needle):
<span class="w"> </span>        &quot;&quot;&quot;Remove all instances of needle from values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while needle in values:</span>
<span class="gi">+            values.remove(needle)</span>
<span class="gi">+</span>
<span class="gi">+    def getCertificateTypes(self):</span>
<span class="gi">+        &quot;&quot;&quot;Get list of certificate types as IDs.&quot;&quot;&quot;</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        if &quot;x509&quot; in self.certificateTypes:</span>
<span class="gi">+            ret.append(CertificateType.x509)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def validate(self):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Validate the settings, filter out unsupported ciphersuites and return</span>
<span class="gi">+        a copy of object.</span>
<span class="gi">+</span>
<span class="gi">+        This method checks if the settings are consistent and if they can be</span>
<span class="gi">+        used for a connection. It checks if all selected algorithms are</span>
<span class="gi">+        supported.</span>
<span class="gi">+</span>
<span class="gi">+        :rtype: HandshakeSettings</span>
<span class="gi">+        :returns: a copy of self with all settings validated</span>
<span class="gi">+        :raises ValueError: when settings are invalid, inconsistent or unsupported</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        other = HandshakeSettings()</span>
<span class="gi">+</span>
<span class="gi">+        # Copy values</span>
<span class="gi">+        other.minKeySize = self.minKeySize</span>
<span class="gi">+        other.maxKeySize = self.maxKeySize</span>
<span class="gi">+        other.cipherNames = self.cipherNames</span>
<span class="gi">+        other.macNames = self.macNames</span>
<span class="gi">+        other.keyExchangeNames = self.keyExchangeNames</span>
<span class="gi">+        other.cipherImplementations = self.cipherImplementations</span>
<span class="gi">+        other.rsaSigHashes = self.rsaSigHashes</span>
<span class="gi">+        other.dsaSigHashes = self.dsaSigHashes</span>
<span class="gi">+        other.ecdsaSigHashes = self.ecdsaSigHashes</span>
<span class="gi">+        other.more_sig_schemes = self.more_sig_schemes</span>
<span class="gi">+        other.rsa_schemes = self.rsa_schemes</span>
<span class="gi">+        other.eccCurves = self.eccCurves</span>
<span class="gi">+        other.dhGroups = self.dhGroups</span>
<span class="gi">+        other.defaultCurve = self.defaultCurve</span>
<span class="gi">+        other.keyShares = self.keyShares</span>
<span class="gi">+        other.certificateTypes = self.certificateTypes</span>
<span class="gi">+        other.minVersion = self.minVersion</span>
<span class="gi">+        other.maxVersion = self.maxVersion</span>
<span class="gi">+        other.versions = self.versions</span>
<span class="gi">+        other.useExtendedMasterSecret = self.useExtendedMasterSecret</span>
<span class="gi">+        other.requireExtendedMasterSecret = self.requireExtendedMasterSecret</span>
<span class="gi">+        other.useEncryptThenMAC = self.useEncryptThenMAC</span>
<span class="gi">+        other.useExperimentalTackExtension = self.useExperimentalTackExtension</span>
<span class="gi">+        other.sendFallbackSCSV = self.sendFallbackSCSV</span>
<span class="gi">+        other.use_heartbeat_extension = self.use_heartbeat_extension</span>
<span class="gi">+        other.heartbeat_response_callback = self.heartbeat_response_callback</span>
<span class="gi">+        other.record_size_limit = self.record_size_limit</span>
<span class="gi">+        other.padding_cb = self.padding_cb</span>
<span class="gi">+        other.pskConfigs = self.pskConfigs</span>
<span class="gi">+        other.psk_modes = self.psk_modes</span>
<span class="gi">+        other.max_early_data = self.max_early_data</span>
<span class="gi">+        other.ticketKeys = self.ticketKeys</span>
<span class="gi">+        other.ticketCipher = self.ticketCipher</span>
<span class="gi">+        other.ticketLifetime = self.ticketLifetime</span>
<span class="gi">+        other.ticket_count = self.ticket_count</span>
<span class="gi">+</span>
<span class="gi">+        # Perform sanity checks</span>
<span class="gi">+        self._sanityCheckKeySizes(other)</span>
<span class="gi">+        self._sanityCheckCipherSettings(other)</span>
<span class="gi">+        self._sanityCheckECDHSettings(other)</span>
<span class="gi">+        self._sanityCheckDHSettings(other)</span>
<span class="gi">+        self._sanityCheckPrimitivesNames(other)</span>
<span class="gi">+        self._sanityCheckProtocolVersions(other)</span>
<span class="gi">+        self._sanityCheckEMSExtension(other)</span>
<span class="gi">+        self._sanityCheckExtensions(other)</span>
<span class="gi">+        self._sanityCheckPsks(other)</span>
<span class="gi">+        self._sanityCheckTicketSettings(other)</span>
<span class="gi">+</span>
<span class="gi">+        return other</span>

<span class="w"> </span>    def _sanity_check_ciphers(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Remove unsupported ciphers in current configuration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not other.cipherNames:</span>
<span class="gi">+            raise ValueError(&quot;No cipher names specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not other.macNames:</span>
<span class="gi">+            raise ValueError(&quot;No MAC names specified&quot;)</span>

<span class="gi">+        if not other.keyExchangeNames:</span>
<span class="gi">+            raise ValueError(&quot;No key exchange algorithms specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not other.cipherImplementations:</span>
<span class="gi">+            raise ValueError(&quot;No cipher implementations specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove ciphers that are not supported</span>
<span class="gi">+        for cipher in other.cipherNames[:]:</span>
<span class="gi">+            if cipher not in ALL_CIPHER_NAMES:</span>
<span class="gi">+                other.cipherNames.remove(cipher)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove MACs that are not supported</span>
<span class="gi">+        for mac in other.macNames[:]:</span>
<span class="gi">+            if mac not in ALL_MAC_NAMES:</span>
<span class="gi">+                other.macNames.remove(mac)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove key exchange algorithms that are not supported</span>
<span class="gi">+        for kex in other.keyExchangeNames[:]:</span>
<span class="gi">+            if kex not in KEY_EXCHANGE_NAMES:</span>
<span class="gi">+                other.keyExchangeNames.remove(kex)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove cipher implementations that are not supported</span>
<span class="gi">+        for impl in other.cipherImplementations[:]:</span>
<span class="gi">+            if impl not in CIPHER_IMPLEMENTATIONS:</span>
<span class="gi">+                other.cipherImplementations.remove(impl)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if any ciphers remain</span>
<span class="gi">+        if not other.cipherNames:</span>
<span class="gi">+            raise ValueError(&quot;No supported cipher names&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if any MACs remain</span>
<span class="gi">+        if not other.macNames:</span>
<span class="gi">+            raise ValueError(&quot;No supported MAC names&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if any key exchange algorithms remain</span>
<span class="gi">+        if not other.keyExchangeNames:</span>
<span class="gi">+            raise ValueError(&quot;No supported key exchange algorithms&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if any cipher implementations remain</span>
<span class="gi">+        if not other.cipherImplementations:</span>
<span class="gi">+            raise ValueError(&quot;No supported cipher implementations&quot;)</span>
<span class="w"> </span>    def _sanity_check_implementations(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Remove all backends that are not loaded.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            self._remove_all_matches(other.cipherImplementations, &quot;openssl&quot;)</span>
<span class="gi">+        if not cryptomath.pycryptoLoaded:</span>
<span class="gi">+            self._remove_all_matches(other.cipherImplementations, &quot;pycrypto&quot;)</span>

<span class="gi">+        if not other.cipherImplementations:</span>
<span class="gi">+            raise ValueError(&quot;No supported cipher implementations&quot;)</span>
<span class="w"> </span>    def _copy_key_settings(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Copy key-related settings.&quot;&quot;&quot;
<span class="gi">+        other.minKeySize = self.minKeySize</span>
<span class="gi">+        other.maxKeySize = self.maxKeySize</span>
<span class="gi">+        other.rsaSigHashes = self.rsaSigHashes</span>
<span class="gi">+        other.dsaSigHashes = self.dsaSigHashes</span>
<span class="gi">+        other.ecdsaSigHashes = self.ecdsaSigHashes</span>
<span class="gi">+        other.more_sig_schemes = self.more_sig_schemes</span>
<span class="gi">+        other.rsa_schemes = self.rsa_schemes</span>
<span class="gi">+        other.eccCurves = self.eccCurves</span>
<span class="gi">+        other.dhGroups = self.dhGroups</span>
<span class="gi">+        other.defaultCurve = self.defaultCurve</span>
<span class="gi">+        other.keyShares = self.keyShares</span>
<span class="gi">+        other.certificateTypes = self.certificateTypes</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def validate(self):
<span class="gh">diff --git a/tlslite/mathtls.py b/tlslite/mathtls.py</span>
<span class="gh">index 8e2820a..4692332 100644</span>
<span class="gd">--- a/tlslite/mathtls.py</span>
<span class="gi">+++ b/tlslite/mathtls.py</span>
<span class="gu">@@ -1,10 +1,43 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Miscellaneous helper functions.&quot;&quot;&quot;
<span class="gi">+import struct</span>
<span class="w"> </span>from .utils.compat import *
<span class="w"> </span>from .utils.cryptomath import *
<span class="w"> </span>from .constants import CipherSuite
<span class="w"> </span>from .utils import tlshashlib as hashlib
<span class="w"> </span>from .utils import tlshmac as hmac
<span class="w"> </span>from .utils.deprecations import deprecated_method
<span class="gi">+</span>
<span class="gi">+def createMAC_SSL(mac_key, seq_num, content_type, data, version):</span>
<span class="gi">+    &quot;&quot;&quot;Create a SSL/early TLS MAC.&quot;&quot;&quot;</span>
<span class="gi">+    mac = hmac.HMAC(mac_key, digestmod=hashlib.md5)</span>
<span class="gi">+    mac.update(bytearray(struct.pack(&quot;&gt;Q&quot;, seq_num)))</span>
<span class="gi">+    mac.update(bytearray([content_type]))</span>
<span class="gi">+    mac.update(bytearray(struct.pack(&quot;&gt;H&quot;, len(data))))</span>
<span class="gi">+    mac.update(data)</span>
<span class="gi">+    return mac.digest()</span>
<span class="gi">+</span>
<span class="gi">+def createHMAC(mac_key, seq_num, content_type, data, version, algorithm):</span>
<span class="gi">+    &quot;&quot;&quot;Create a TLS 1.2 HMAC.&quot;&quot;&quot;</span>
<span class="gi">+    mac = hmac.HMAC(mac_key, digestmod=getattr(hashlib, algorithm))</span>
<span class="gi">+    mac.update(bytearray(struct.pack(&quot;&gt;Q&quot;, seq_num)))</span>
<span class="gi">+    mac.update(bytearray([content_type]))</span>
<span class="gi">+    mac.update(bytearray(struct.pack(&quot;&gt;H&quot;, version[0])))</span>
<span class="gi">+    mac.update(bytearray(struct.pack(&quot;&gt;H&quot;, version[1])))</span>
<span class="gi">+    mac.update(bytearray(struct.pack(&quot;&gt;H&quot;, len(data))))</span>
<span class="gi">+    mac.update(data)</span>
<span class="gi">+    return mac.digest()</span>
<span class="gi">+</span>
<span class="gi">+def makeX(salt, username, password):</span>
<span class="gi">+    &quot;&quot;&quot;Create an X value for SRP.&quot;&quot;&quot;</span>
<span class="gi">+    return bytesToNumber(secureHash(salt + username + password, &quot;sha1&quot;))</span>
<span class="gi">+</span>
<span class="gi">+def makeU(N, A, B):</span>
<span class="gi">+    &quot;&quot;&quot;Create a U value for SRP.&quot;&quot;&quot;</span>
<span class="gi">+    return bytesToNumber(secureHash(numberToByteArray(A) + numberToByteArray(B), &quot;sha1&quot;))</span>
<span class="gi">+</span>
<span class="gi">+def makeK(N, g):</span>
<span class="gi">+    &quot;&quot;&quot;Create a K value for SRP.&quot;&quot;&quot;</span>
<span class="gi">+    return bytesToNumber(secureHash(numberToByteArray(N) + numberToByteArray(g), &quot;sha1&quot;))</span>
<span class="w"> </span>FFDHE_PARAMETERS = {}
<span class="w"> </span>&#39;\nListing of all well known FFDH parameters.\n\nPlease note that this dictionary includes all groups that are well-known\n(i.e. named), irrespective if their use is recommended or not.\n\nYou should use RFC7919_GROUPS for well-known secure groups.\n&#39;
<span class="w"> </span>RFC2409_GROUP1 = (2, int(remove_whitespace(&#39;\n         FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n         29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n         EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\n         E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF&#39;), 16))
<span class="gh">diff --git a/tlslite/messages.py b/tlslite/messages.py</span>
<span class="gh">index 7f0b0cd..3ea54f0 100644</span>
<span class="gd">--- a/tlslite/messages.py</span>
<span class="gi">+++ b/tlslite/messages.py</span>
<span class="gu">@@ -238,7 +238,12 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        .. deprecated:: 0.5
<span class="w"> </span>            use extensions field to get the extension for inspection
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, ClientCertTypeExtension):</span>
<span class="gi">+                return ext.cert_types</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @certificate_types.setter
<span class="w"> </span>    def certificate_types(self, val):
<span class="gu">@@ -253,7 +258,16 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :param val: list of supported certificate types by client encoded as
<span class="w"> </span>            single byte integers
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, ClientCertTypeExtension):</span>
<span class="gi">+                ext.cert_types = val</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        ext = ClientCertTypeExtension().create(val)</span>
<span class="gi">+        self.extensions.append(ext)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def srp_username(self):
<span class="gu">@@ -263,7 +277,12 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        .. deprecated:: 0.5
<span class="w"> </span>            use extensions field to get the extension for inspection
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, SRPExtension):</span>
<span class="gi">+                return ext.srp_username</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @srp_username.setter
<span class="w"> </span>    def srp_username(self, name):
<span class="gu">@@ -273,7 +292,16 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :type name: bytearray
<span class="w"> </span>        :param name: UTF-8 encoded username
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, SRPExtension):</span>
<span class="gi">+                ext.srp_username = name</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        ext = SRPExtension().create(name)</span>
<span class="gi">+        self.extensions.append(ext)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def tack(self):
<span class="gu">@@ -285,7 +313,12 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, TACKExtension):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @tack.setter
<span class="w"> </span>    def tack(self, present):
<span class="gu">@@ -296,7 +329,18 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :param present: True will create extension while False will remove
<span class="w"> </span>            extension from client hello
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, TACKExtension):</span>
<span class="gi">+                if not present:</span>
<span class="gi">+                    self.extensions.remove(ext)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if present:</span>
<span class="gi">+            ext = TACKExtension().create()</span>
<span class="gi">+            self.extensions.append(ext)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def supports_npn(self):
<span class="gu">@@ -308,7 +352,12 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, NPNExtension):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @supports_npn.setter
<span class="w"> </span>    def supports_npn(self, present):
<span class="gu">@@ -319,7 +368,18 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :param present: selects whatever to create or remove the extension
<span class="w"> </span>            from list of supported ones
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, NPNExtension):</span>
<span class="gi">+                if not present:</span>
<span class="gi">+                    self.extensions.remove(ext)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if present:</span>
<span class="gi">+            ext = NPNExtension().create([])</span>
<span class="gi">+            self.extensions.append(ext)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def server_name(self):
<span class="gu">@@ -331,7 +391,13 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, SNIExtension):</span>
<span class="gi">+                if ext.host_names:</span>
<span class="gi">+                    return ext.host_names[0]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @server_name.setter
<span class="w"> </span>    def server_name(self, hostname):
<span class="gu">@@ -341,7 +407,16 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :type hostname: bytearray
<span class="w"> </span>        :param hostname: name of the host_name to set
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, SNIExtension):</span>
<span class="gi">+                ext.host_names = [hostname]</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        ext = SNIExtension().create([hostname])</span>
<span class="gi">+        self.extensions.append(ext)</span>

<span class="w"> </span>    def create(self, version, random, session_id, cipher_suites, certificate_types=None, srpUsername=None, tack=False, supports_npn=None, serverName=None, extensions=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -386,19 +461,90 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :type extensions: list of :py:class:`~.extensions.TLSExtension`
<span class="w"> </span>        :param extensions: list of extensions to advertise
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.client_version = version</span>
<span class="gi">+        self.random = random</span>
<span class="gi">+        self.session_id = session_id</span>
<span class="gi">+        self.cipher_suites = cipher_suites</span>
<span class="gi">+        self.compression_methods = [0]  # only null compression</span>
<span class="gi">+        self.extensions = extensions</span>
<span class="gi">+</span>
<span class="gi">+        if certificate_types is not None:</span>
<span class="gi">+            self.certificate_types = certificate_types</span>
<span class="gi">+        if srpUsername is not None:</span>
<span class="gi">+            self.srp_username = srpUsername</span>
<span class="gi">+        if tack:</span>
<span class="gi">+            self.tack = tack</span>
<span class="gi">+        if supports_npn is not None:</span>
<span class="gi">+            self.supports_npn = supports_npn</span>
<span class="gi">+        if serverName is not None:</span>
<span class="gi">+            self.server_name = serverName</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ssl2:</span>
<span class="gi">+            self.client_version = (p.get(1), p.get(1))</span>
<span class="gi">+            cipher_suites_length = p.get(2)</span>
<span class="gi">+            session_id_length = p.get(2)</span>
<span class="gi">+            challenge_length = p.get(2)</span>
<span class="gi">+            self.cipher_suites = []</span>
<span class="gi">+            for i in range(cipher_suites_length // 3):</span>
<span class="gi">+                self.cipher_suites.append(p.get(3))</span>
<span class="gi">+            self.session_id = p.getFixBytes(session_id_length)</span>
<span class="gi">+            self.random = p.getFixBytes(challenge_length)</span>
<span class="gi">+            self.compression_methods = [0]  # SSL2 has no compression</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        self.client_version = (p.get(1), p.get(1))</span>
<span class="gi">+        self.random = p.getFixBytes(32)</span>
<span class="gi">+        session_id_length = p.get(1)</span>
<span class="gi">+        self.session_id = p.getFixBytes(session_id_length)</span>
<span class="gi">+        cipher_suites_length = p.get(2)</span>
<span class="gi">+        self.cipher_suites = []</span>
<span class="gi">+        for i in range(cipher_suites_length // 2):</span>
<span class="gi">+            self.cipher_suites.append(p.get(2))</span>
<span class="gi">+        compression_methods_length = p.get(1)</span>
<span class="gi">+        self.compression_methods = []</span>
<span class="gi">+        for i in range(compression_methods_length):</span>
<span class="gi">+            self.compression_methods.append(p.get(1))</span>
<span class="gi">+</span>
<span class="gi">+        if p.getRemainingLength() &gt; 0:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+            extensions_length = p.get(2)</span>
<span class="gi">+            while p.getRemainingLength() &gt; 0:</span>
<span class="gi">+                ext = TLSExtension().parse(p)</span>
<span class="gi">+                self.extensions.append(ext)</span>

<span class="w"> </span>    def _writeSSL2(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise SSLv2 object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.client_version[0], 1)</span>
<span class="gi">+        w.add(self.client_version[1], 1)</span>
<span class="gi">+        w.add(len(self.cipher_suites) * 3, 2)</span>
<span class="gi">+        w.add(len(self.session_id), 2)</span>
<span class="gi">+        w.add(len(self.random), 2)</span>
<span class="gi">+        for cipher_suite in self.cipher_suites:</span>
<span class="gi">+            w.addFixSeq(bytearray([0x00, cipher_suite &gt;&gt; 8, cipher_suite &amp; 0xFF]), 3)</span>
<span class="gi">+        w.addFixSeq(self.session_id, len(self.session_id))</span>
<span class="gi">+        w.addFixSeq(self.random, len(self.random))</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def _write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise SSLv3 or TLS object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.client_version[0], 1)</span>
<span class="gi">+        w.add(self.client_version[1], 1)</span>
<span class="gi">+        w.addFixSeq(self.random, 32)</span>
<span class="gi">+        w.addVarSeq(self.session_id, 1, 1)</span>
<span class="gi">+        w.addVarSeq(Writer.array_to_bytes(self.cipher_suites, 2), 2, 2)</span>
<span class="gi">+        w.addVarSeq(Writer.array_to_bytes(self.compression_methods, 1), 1, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if self.extensions is not None:</span>
<span class="gi">+            w2 = Writer()</span>
<span class="gi">+            for ext in self.extensions:</span>
<span class="gi">+                w2.bytes += ext.write()</span>
<span class="gi">+            w.add(len(w2.bytes), 2)</span>
<span class="gi">+            w.bytes += w2.bytes</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def psk_truncate(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a truncated encoding of message without binders.
<span class="gu">@@ -411,11 +557,30 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.extensions:</span>
<span class="gi">+            return self.write()</span>
<span class="gi">+</span>
<span class="gi">+        psk_ext = None</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            if isinstance(ext, PreSharedKeyExtension):</span>
<span class="gi">+                psk_ext = ext</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if not psk_ext:</span>
<span class="gi">+            return self.write()</span>
<span class="gi">+</span>
<span class="gi">+        # remove the binders from the extension</span>
<span class="gi">+        old_binders = psk_ext.binders</span>
<span class="gi">+        psk_ext.binders = None</span>
<span class="gi">+        ret = self.write()</span>
<span class="gi">+        psk_ext.binders = old_binders</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ssl2:</span>
<span class="gi">+            return self._writeSSL2()</span>
<span class="gi">+        return self._write()</span>

<span class="w"> </span>class HelloRequest(HandshakeMsg):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gh">diff --git a/tlslite/utils/compat.py b/tlslite/utils/compat.py</span>
<span class="gh">index 4c66fab..728509b 100644</span>
<span class="gd">--- a/tlslite/utils/compat.py</span>
<span class="gi">+++ b/tlslite/utils/compat.py</span>
<span class="gu">@@ -8,95 +8,142 @@ import binascii</span>
<span class="w"> </span>import traceback
<span class="w"> </span>import time
<span class="w"> </span>import ecdsa
<span class="gi">+from binascii import a2b_hex, b2a_hex, a2b_base64, b2a_base64</span>
<span class="gi">+</span>
<span class="gi">+def compat26Str(x):</span>
<span class="gi">+    &quot;&quot;&quot;Convert bytes or str to str&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(x, str):</span>
<span class="gi">+        return x</span>
<span class="gi">+    elif isinstance(x, bytes):</span>
<span class="gi">+        return x.decode(&#39;ascii&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(x)</span>
<span class="gi">+</span>
<span class="gi">+def compatLong(x):</span>
<span class="gi">+    &quot;&quot;&quot;Convert number to long&quot;&quot;&quot;</span>
<span class="gi">+    if sys.version_info &gt;= (3, 0):</span>
<span class="gi">+        return int(x)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return long(x)</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 0):
<span class="w"> </span>    if sys.version_info &lt; (3, 4):

<span class="w"> </span>        def compatHMAC(x):
<span class="w"> </span>            &quot;&quot;&quot;Convert bytes-like input to format acceptable for HMAC.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(x, str):</span>
<span class="gi">+                return x.encode(&#39;ascii&#39;)</span>
<span class="gi">+            return x</span>
<span class="w"> </span>    else:

<span class="w"> </span>        def compatHMAC(x):
<span class="w"> </span>            &quot;&quot;&quot;Convert bytes-like input to format acceptable for HMAC.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(x, str):</span>
<span class="gi">+                return x.encode(&#39;ascii&#39;)</span>
<span class="gi">+            return x</span>

<span class="w"> </span>    def compatAscii2Bytes(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert ASCII string to bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(val, str):</span>
<span class="gi">+            return val.encode(&#39;ascii&#39;)</span>
<span class="gi">+        return val</span>

<span class="w"> </span>    def compat_b2a(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert an ASCII bytes string to string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(val, bytes):</span>
<span class="gi">+            return val.decode(&#39;ascii&#39;)</span>
<span class="gi">+        return val</span>
<span class="w"> </span>    int_types = tuple([int])

<span class="w"> </span>    def formatExceptionTrace(e):
<span class="w"> </span>        &quot;&quot;&quot;Return exception information formatted as string&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return str(traceback.format_exception(type(e), e, e.__traceback__))</span>

<span class="w"> </span>    def time_stamp():
<span class="w"> </span>        &quot;&quot;&quot;Returns system time as a float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return time.time()</span>

<span class="w"> </span>    def remove_whitespace(text):
<span class="w"> </span>        &quot;&quot;&quot;Removes all whitespace from passed in string&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return re.sub(r&#39;\s+&#39;, &#39;&#39;, text)</span>
<span class="w"> </span>    bytes_to_int = int.from_bytes

<span class="w"> </span>    def bit_length(val):
<span class="w"> </span>        &quot;&quot;&quot;Return number of bits necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return val.bit_length()</span>

<span class="w"> </span>    def int_to_bytes(val, length=None, byteorder=&#39;big&#39;):
<span class="w"> </span>        &quot;&quot;&quot;Return number converted to bytes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            length = byte_length(val)</span>
<span class="gi">+        return val.to_bytes(length, byteorder=byteorder)</span>
<span class="w"> </span>else:
<span class="w"> </span>    if sys.version_info &lt; (2, 7) or sys.version_info &lt; (2, 7, 4) or platform.system() == &#39;Java&#39;:

<span class="w"> </span>        def remove_whitespace(text):
<span class="w"> </span>            &quot;&quot;&quot;Removes all whitespace from passed in string&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return re.sub(r&#39;\s+&#39;, &#39;&#39;, text)</span>

<span class="w"> </span>        def bit_length(val):
<span class="w"> </span>            &quot;&quot;&quot;Return number of bits necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if val == 0:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            return len(bin(val)[2:])</span>
<span class="w"> </span>    else:

<span class="w"> </span>        def remove_whitespace(text):
<span class="w"> </span>            &quot;&quot;&quot;Removes all whitespace from passed in string&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return re.sub(r&#39;\s+&#39;, &#39;&#39;, text)</span>

<span class="w"> </span>        def bit_length(val):
<span class="w"> </span>            &quot;&quot;&quot;Return number of bits necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return val.bit_length()</span>

<span class="w"> </span>    def compatAscii2Bytes(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert ASCII string to bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(val, str):</span>
<span class="gi">+            return val.encode(&#39;ascii&#39;)</span>
<span class="gi">+        return val</span>

<span class="w"> </span>    def compat_b2a(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert an ASCII bytes string to string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(val, bytes):</span>
<span class="gi">+            return val.decode(&#39;ascii&#39;)</span>
<span class="gi">+        return val</span>
<span class="w"> </span>    int_types = (int, long)

<span class="w"> </span>    def formatExceptionTrace(e):
<span class="w"> </span>        &quot;&quot;&quot;Return exception information formatted as string&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return str(traceback.format_exc())</span>

<span class="w"> </span>    def time_stamp():
<span class="w"> </span>        &quot;&quot;&quot;Returns system time as a float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return time.time()</span>

<span class="w"> </span>    def bytes_to_int(val, byteorder):
<span class="w"> </span>        &quot;&quot;&quot;Convert bytes to an int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if byteorder == &#39;big&#39;:</span>
<span class="gi">+            return int(b2a_hex(val), 16)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return int(b2a_hex(val[::-1]), 16)</span>

<span class="w"> </span>    def int_to_bytes(val, length=None, byteorder=&#39;big&#39;):
<span class="w"> </span>        &quot;&quot;&quot;Return number converted to bytes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            length = byte_length(val)</span>
<span class="gi">+        hex_str = &#39;%x&#39; % val</span>
<span class="gi">+        if len(hex_str) % 2:</span>
<span class="gi">+            hex_str = &#39;0&#39; + hex_str</span>
<span class="gi">+        result = a2b_hex(hex_str)</span>
<span class="gi">+        if len(result) &lt; length:</span>
<span class="gi">+            result = b&#39;\x00&#39; * (length - len(result)) + result</span>
<span class="gi">+        if byteorder == &#39;little&#39;:</span>
<span class="gi">+            result = result[::-1]</span>
<span class="gi">+        return result</span>

<span class="w"> </span>def byte_length(val):
<span class="w"> </span>    &quot;&quot;&quot;Return number of bytes necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    length = val.bit_length()</span>
<span class="gi">+    return (length + 7) // 8</span>
<span class="w"> </span>try:
<span class="w"> </span>    getattr(ecdsa, &#39;NIST192p&#39;)
<span class="w"> </span>except AttributeError:
<span class="gh">diff --git a/tlslite/utils/cryptomath.py b/tlslite/utils/cryptomath.py</span>
<span class="gh">index abcdbce..37e88d9 100644</span>
<span class="gd">--- a/tlslite/utils/cryptomath.py</span>
<span class="gi">+++ b/tlslite/utils/cryptomath.py</span>
<span class="gu">@@ -56,19 +56,75 @@ prngName = &#39;os.urandom&#39;</span>

<span class="w"> </span>def MD5(b):
<span class="w"> </span>    &quot;&quot;&quot;Return a MD5 digest of data&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hashlib.md5(compat26Str(b)).digest()</span>

<span class="w"> </span>def SHA1(b):
<span class="w"> </span>    &quot;&quot;&quot;Return a SHA1 digest of data&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hashlib.sha1(compat26Str(b)).digest()</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_MD5(k, b):</span>
<span class="gi">+    &quot;&quot;&quot;Return HMAC using MD5&quot;&quot;&quot;</span>
<span class="gi">+    return secureHMAC(k, b, &quot;md5&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_SHA1(k, b):</span>
<span class="gi">+    &quot;&quot;&quot;Return HMAC using SHA1&quot;&quot;&quot;</span>
<span class="gi">+    return secureHMAC(k, b, &quot;sha1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_SHA256(k, b):</span>
<span class="gi">+    &quot;&quot;&quot;Return HMAC using SHA256&quot;&quot;&quot;</span>
<span class="gi">+    return secureHMAC(k, b, &quot;sha256&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_SHA384(k, b):</span>
<span class="gi">+    &quot;&quot;&quot;Return HMAC using SHA384&quot;&quot;&quot;</span>
<span class="gi">+    return secureHMAC(k, b, &quot;sha384&quot;)</span>

<span class="w"> </span>def secureHash(data, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;Return a digest of `data` using `algorithm`&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hashInstance = hashlib.new(algorithm)</span>
<span class="gi">+    hashInstance.update(compat26Str(data))</span>
<span class="gi">+    return hashInstance.digest()</span>

<span class="w"> </span>def secureHMAC(k, b, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;Return a HMAC using `b` and `k` using `algorithm`&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    k = compatHMAC(k)</span>
<span class="gi">+    b = compatHMAC(b)</span>
<span class="gi">+    return hmac.new(k, b, getattr(hashlib, algorithm)).digest()</span>
<span class="gi">+</span>
<span class="gi">+def getRandomBytes(howMany):</span>
<span class="gi">+    &quot;&quot;&quot;Return a specified number of random bytes.&quot;&quot;&quot;</span>
<span class="gi">+    return os.urandom(howMany)</span>
<span class="gi">+</span>
<span class="gi">+def getRandomNumber(low, high):</span>
<span class="gi">+    &quot;&quot;&quot;Return a random number in the range [low, high].&quot;&quot;&quot;</span>
<span class="gi">+    if low &gt;= high:</span>
<span class="gi">+        raise ValueError(&quot;Low must be lower than high&quot;)</span>
<span class="gi">+    howManyBits = len(bin(high - low)[2:])</span>
<span class="gi">+    howManyBytes = (howManyBits + 7) // 8</span>
<span class="gi">+    while True:</span>
<span class="gi">+        bytes = getRandomBytes(howManyBytes)</span>
<span class="gi">+        n = bytesToNumber(bytes)</span>
<span class="gi">+        if n &gt;= low and n &lt;= high:</span>
<span class="gi">+            return n</span>
<span class="gi">+</span>
<span class="gi">+def HKDF_expand(secret, info, length, algorithm):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    HKDF-Expand function from RFC 5869.</span>
<span class="gi">+</span>
<span class="gi">+    :param bytearray secret: the key from which to derive the keying material</span>
<span class="gi">+    :param bytearray info: context specific information</span>
<span class="gi">+    :param int length: number of bytes to produce</span>
<span class="gi">+    :param str algorithm: name of the secure hash algorithm used as the</span>
<span class="gi">+        basis of the HKDF</span>
<span class="gi">+    :rtype: bytearray</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    hash_size = getattr(hashlib, algorithm)().digest_size</span>
<span class="gi">+    N = (length + hash_size - 1) // hash_size</span>
<span class="gi">+    T = bytearray()</span>
<span class="gi">+    output = bytearray()</span>
<span class="gi">+    for i in range(N):</span>
<span class="gi">+        T = secureHMAC(secret, T + info + bytearray([i + 1]), algorithm)</span>
<span class="gi">+        output += T</span>
<span class="gi">+    return output[:length]</span>

<span class="w"> </span>def HKDF_expand_label(secret, label, hashValue, length, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -83,7 +139,11 @@ def HKDF_expand_label(secret, label, hashValue, length, algorithm):</span>
<span class="w"> </span>        basis of the HKDF
<span class="w"> </span>    :rtype: bytearray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hkdf_label = Writer()</span>
<span class="gi">+    hkdf_label.add(length, 2)</span>
<span class="gi">+    hkdf_label.addVarSeq(b&quot;tls13 &quot; + label, 1, 1)</span>
<span class="gi">+    hkdf_label.addVarSeq(hashValue, 1, 1)</span>
<span class="gi">+    return HKDF_expand(secret, hkdf_label.bytes(), length, algorithm)</span>

<span class="w"> </span>def derive_secret(secret, label, handshake_hashes, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -99,7 +159,13 @@ def derive_secret(secret, label, handshake_hashes, algorithm):</span>
<span class="w"> </span>        be generated
<span class="w"> </span>    :rtype: bytearray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if handshake_hashes is None:</span>
<span class="gi">+        hash_value = secureHash(b&quot;&quot;, algorithm)</span>
<span class="gi">+    else:</span>
<span class="gi">+        hash_value = handshake_hashes.digest(algorithm)</span>
<span class="gi">+    return HKDF_expand_label(secret, label, hash_value,</span>
<span class="gi">+                           getattr(hashlib, algorithm).digest_size,</span>
<span class="gi">+                           algorithm)</span>

<span class="w"> </span>def bytesToNumber(b, endian=&#39;big&#39;):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -107,7 +173,7 @@ def bytesToNumber(b, endian=&#39;big&#39;):</span>

<span class="w"> </span>    By default assumes big-endian encoding of the number.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bytes_to_int(b, endian)</span>

<span class="w"> </span>def numberToByteArray(n, howManyBytes=None, endian=&#39;big&#39;):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -117,30 +183,106 @@ def numberToByteArray(n, howManyBytes=None, endian=&#39;big&#39;):</span>
<span class="w"> </span>    not be larger.  The returned bytearray will contain a big- or little-endian
<span class="w"> </span>    encoding of the input integer (n). Big endian encoding is used by default.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bytearray(int_to_bytes(n, howManyBytes, endian))</span>

<span class="w"> </span>def mpiToNumber(mpi):
<span class="w"> </span>    &quot;&quot;&quot;Convert a MPI (OpenSSL bignum string) to an integer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    byte_array = bytearray(mpi)</span>
<span class="gi">+    byte_len = (byte_array[0] * 256 + byte_array[1] + 7) // 8</span>
<span class="gi">+    return bytesToNumber(byte_array[2:2 + byte_len])</span>
<span class="gi">+</span>
<span class="gi">+def numberToMPI(n):</span>
<span class="gi">+    &quot;&quot;&quot;Convert an integer to a MPI (OpenSSL bignum string).&quot;&quot;&quot;</span>
<span class="gi">+    b = numberToByteArray(n)</span>
<span class="gi">+    ext = 0</span>
<span class="gi">+    if len(b) == 0:</span>
<span class="gi">+        b = bytearray([0])</span>
<span class="gi">+    if b[0] &amp; 0x80:</span>
<span class="gi">+        ext = 1</span>
<span class="gi">+    length = len(b) + ext</span>
<span class="gi">+    b2 = bytearray(2 + length)</span>
<span class="gi">+    b2[0] = (length &gt;&gt; 8) &amp; 0xFF</span>
<span class="gi">+    b2[1] = length &amp; 0xFF</span>
<span class="gi">+    for i in range(len(b)):</span>
<span class="gi">+        b2[2+ext+i] = b[i]</span>
<span class="gi">+    return bytes(b2)</span>
<span class="w"> </span>numBits = bit_length
<span class="w"> </span>numBytes = byte_length
<span class="w"> </span>if GMPY2_LOADED:

<span class="w"> </span>    def invMod(a, b):
<span class="w"> </span>        &quot;&quot;&quot;Return inverse of a mod b, zero if none.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return int(powmod(mpz(a), -1, mpz(b)))</span>
<span class="gi">+        except (ValueError, ZeroDivisionError):</span>
<span class="gi">+            return 0</span>
<span class="w"> </span>else:

<span class="w"> </span>    def invMod(a, b):
<span class="w"> </span>        &quot;&quot;&quot;Return inverse of a mod b, zero if none.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = 0</span>
<span class="gi">+        t = 1</span>
<span class="gi">+        r = b</span>
<span class="gi">+        old_s = 1</span>
<span class="gi">+        old_t = 0</span>
<span class="gi">+        old_r = a</span>
<span class="gi">+        while r != 0:</span>
<span class="gi">+            quotient = old_r // r</span>
<span class="gi">+            old_r, r = r, old_r - quotient * r</span>
<span class="gi">+            old_s, s = s, old_s - quotient * s</span>
<span class="gi">+            old_t, t = t, old_t - quotient * t</span>
<span class="gi">+        if old_r != 1:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        while old_s &lt; 0:</span>
<span class="gi">+            old_s += b</span>
<span class="gi">+        return old_s</span>
<span class="w"> </span>if gmpyLoaded or GMPY2_LOADED:
<span class="gi">+    powMod = powmod</span>
<span class="w"> </span>else:
<span class="w"> </span>    powMod = pow

<span class="w"> </span>def divceil(divident, divisor):
<span class="w"> </span>    &quot;&quot;&quot;Integer division with rounding up&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (divident + divisor - 1) // divisor</span>
<span class="gi">+</span>
<span class="gi">+def isPrime(n, iterations=8):</span>
<span class="gi">+    &quot;&quot;&quot;Returns True if n is prime with high probability&quot;&quot;&quot;</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if n == 2:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if n &amp; 1 == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Write n-1 as d * 2^s by factoring powers of 2 from n-1</span>
<span class="gi">+    s = 0</span>
<span class="gi">+    d = n - 1</span>
<span class="gi">+    while d &amp; 1 == 0:</span>
<span class="gi">+        s += 1</span>
<span class="gi">+        d &gt;&gt;= 1</span>
<span class="gi">+</span>
<span class="gi">+    # Try to divide n by a few small primes</span>
<span class="gi">+    for i in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]:</span>
<span class="gi">+        if n % i == 0:</span>
<span class="gi">+            return n == i</span>
<span class="gi">+</span>
<span class="gi">+    # Do iterations of Miller-Rabin testing</span>
<span class="gi">+    for i in range(iterations):</span>
<span class="gi">+        a = bytes_to_int(os.urandom(numBytes(n)))</span>
<span class="gi">+        if a == 0 or a &gt;= n:</span>
<span class="gi">+            a = 1</span>
<span class="gi">+        a = powMod(a, d, n)</span>
<span class="gi">+        if a == 1:</span>
<span class="gi">+            continue</span>
<span class="gi">+        for r in range(s):</span>
<span class="gi">+            if a == n - 1:</span>
<span class="gi">+                break</span>
<span class="gi">+            a = powMod(a, 2, n)</span>
<span class="gi">+            if a == 1:</span>
<span class="gi">+                return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>

<span class="w"> </span>def getRandomPrime(bits, display=False):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -149,7 +291,14 @@ def getRandomPrime(bits, display=False):</span>
<span class="w"> </span>    the number will be &#39;bits&#39; bits long (i.e. generated number will be
<span class="w"> </span>    larger than `(2^(bits-1) * 3 ) / 2` but smaller than 2^bits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        n = bytes_to_int(os.urandom(bits // 8 + 1))</span>
<span class="gi">+        n |= 2 ** (bits - 1)  # Set high bit</span>
<span class="gi">+        n &amp;= ~(1 &lt;&lt; (bits - 1)) - 1  # Clear low bits</span>
<span class="gi">+        if display:</span>
<span class="gi">+            print(&quot;.&quot;, end=&#39; &#39;)</span>
<span class="gi">+        if isPrime(n, iterations=30):</span>
<span class="gi">+            return n</span>

<span class="w"> </span>def getRandomSafePrime(bits, display=False):
<span class="w"> </span>    &quot;&quot;&quot;Generate a random safe prime.
<span class="gu">@@ -157,4 +306,8 @@ def getRandomSafePrime(bits, display=False):</span>
<span class="w"> </span>    Will generate a prime `bits` bits long (see getRandomPrime) such that
<span class="w"> </span>    the (p-1)/2 will also be prime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    while True:</span>
<span class="gi">+        q = getRandomPrime(bits - 1, display)</span>
<span class="gi">+        p = 2 * q + 1</span>
<span class="gi">+        if isPrime(p, iterations=30):</span>
<span class="gi">+            return p</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/deprecations.py b/tlslite/utils/deprecations.py</span>
<span class="gh">index 787ea1d..cb9830e 100644</span>
<span class="gd">--- a/tlslite/utils/deprecations.py</span>
<span class="gi">+++ b/tlslite/utils/deprecations.py</span>
<span class="gu">@@ -15,7 +15,15 @@ def deprecated_class_name(old_name, warn=&quot;Class name &#39;{old_name}&#39; is deprecated,</span>
<span class="w"> </span>       keyword name and the &#39;new_name&#39; for the current one.
<span class="w"> </span>       Example: &quot;Old name: {old_nam}, use &#39;{new_name}&#39; instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(cls):</span>
<span class="gi">+        new_name = cls.__name__</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            warnings.warn(warn.format(old_name=old_name, new_name=new_name),</span>
<span class="gi">+                        DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            return cls(*args, **kwargs)</span>
<span class="gi">+        globals()[old_name] = wrapper</span>
<span class="gi">+        return cls</span>
<span class="gi">+    return decorator</span>

<span class="w"> </span>def deprecated_params(names, warn=&quot;Param name &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):
<span class="w"> </span>    &quot;&quot;&quot;Decorator to translate obsolete names and warn about their use.
<span class="gu">@@ -28,7 +36,17 @@ def deprecated_params(names, warn=&quot;Param name &#39;{old_name}&#39; is deprecated, please</span>
<span class="w"> </span>        deprecated keyword name and &#39;new_name&#39; for the current one.
<span class="w"> </span>        Example: &quot;Old name: {old_name}, use {new_name} instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            for new_name, old_name in names.items():</span>
<span class="gi">+                if old_name in kwargs:</span>
<span class="gi">+                    warnings.warn(warn.format(old_name=old_name, new_name=new_name),</span>
<span class="gi">+                                DeprecationWarning, stacklevel=2)</span>
<span class="gi">+                    kwargs[new_name] = kwargs.pop(old_name)</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>

<span class="w"> </span>def deprecated_instance_attrs(names, warn=&quot;Attribute &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):
<span class="w"> </span>    &quot;&quot;&quot;Decorator to deprecate class instance attributes.
<span class="gu">@@ -45,7 +63,34 @@ def deprecated_instance_attrs(names, warn=&quot;Attribute &#39;{old_name}&#39; is deprecated,</span>
<span class="w"> </span>        deprecated keyword name and &#39;new_name&#39; for the current one.
<span class="w"> </span>        Example: &quot;Old name: {old_name}, use {new_name} instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(cls):</span>
<span class="gi">+        old_getattr = cls.__getattr__ if hasattr(cls, &#39;__getattr__&#39;) else None</span>
<span class="gi">+        old_setattr = cls.__setattr__ if hasattr(cls, &#39;__setattr__&#39;) else None</span>
<span class="gi">+</span>
<span class="gi">+        def __getattr__(self, name):</span>
<span class="gi">+            for new_name, old_name in names.items():</span>
<span class="gi">+                if name == old_name:</span>
<span class="gi">+                    warnings.warn(warn.format(old_name=old_name, new_name=new_name),</span>
<span class="gi">+                                DeprecationWarning, stacklevel=2)</span>
<span class="gi">+                    return getattr(self, new_name)</span>
<span class="gi">+            if old_getattr:</span>
<span class="gi">+                return old_getattr(self, name)</span>
<span class="gi">+            raise AttributeError(name)</span>
<span class="gi">+</span>
<span class="gi">+        def __setattr__(self, name, value):</span>
<span class="gi">+            for new_name, old_name in names.items():</span>
<span class="gi">+                if name == old_name:</span>
<span class="gi">+                    warnings.warn(warn.format(old_name=old_name, new_name=new_name),</span>
<span class="gi">+                                DeprecationWarning, stacklevel=2)</span>
<span class="gi">+                    return setattr(self, new_name, value)</span>
<span class="gi">+            if old_setattr:</span>
<span class="gi">+                return old_setattr(self, name, value)</span>
<span class="gi">+            return object.__setattr__(self, name, value)</span>
<span class="gi">+</span>
<span class="gi">+        cls.__getattr__ = __getattr__</span>
<span class="gi">+        cls.__setattr__ = __setattr__</span>
<span class="gi">+        return cls</span>
<span class="gi">+    return decorator</span>

<span class="w"> </span>def deprecated_attrs(names, warn=&quot;Attribute &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):
<span class="w"> </span>    &quot;&quot;&quot;Decorator to deprecate all specified attributes in class.
<span class="gu">@@ -62,11 +107,28 @@ def deprecated_attrs(names, warn=&quot;Attribute &#39;{old_name}&#39; is deprecated, please u</span>
<span class="w"> </span>        deprecated keyword name and &#39;new_name&#39; for the current one.
<span class="w"> </span>        Example: &quot;Old name: {old_name}, use {new_name} instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    class DeprecatedAttrMetaclass(type):</span>
<span class="gi">+        def __new__(cls, name, bases, attrs):</span>
<span class="gi">+            for new_name, old_name in names.items():</span>
<span class="gi">+                if old_name in attrs:</span>
<span class="gi">+                    warnings.warn(warn.format(old_name=old_name, new_name=new_name),</span>
<span class="gi">+                                DeprecationWarning, stacklevel=2)</span>
<span class="gi">+                    attrs[new_name] = attrs.pop(old_name)</span>
<span class="gi">+            return super(DeprecatedAttrMetaclass, cls).__new__(cls, name, bases, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(cls):</span>
<span class="gi">+        return DeprecatedAttrMetaclass(cls.__name__, cls.__bases__, dict(cls.__dict__))</span>
<span class="gi">+    return decorator</span>

<span class="w"> </span>def deprecated_method(message):
<span class="w"> </span>    &quot;&quot;&quot;Decorator for deprecating methods.

<span class="w"> </span>    :param ste message: The message you want to display.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            warnings.warn(message, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/keyfactory.py b/tlslite/utils/keyfactory.py</span>
<span class="gh">index 47b2fba..e815d44 100644</span>
<span class="gd">--- a/tlslite/utils/keyfactory.py</span>
<span class="gi">+++ b/tlslite/utils/keyfactory.py</span>
<span class="gu">@@ -20,7 +20,12 @@ def generateRSAKey(bits, implementations=[&#39;openssl&#39;, &#39;python&#39;]):</span>
<span class="w"> </span>    :rtype: ~tlslite.utils.rsakey.RSAKey
<span class="w"> </span>    :returns: A new RSA private key.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for implementation in implementations:</span>
<span class="gi">+        if implementation == &#39;openssl&#39; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return OpenSSL_RSAKey.generate(bits)</span>
<span class="gi">+        elif implementation == &#39;python&#39;:</span>
<span class="gi">+            return Python_RSAKey.generate(bits)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementations&quot;)</span>

<span class="w"> </span>def parsePEMKey(s, private=False, public=False, passwordCallback=None, implementations=[&#39;openssl&#39;, &#39;python&#39;]):
<span class="w"> </span>    &quot;&quot;&quot;Parse a PEM-format key.
<span class="gu">@@ -78,7 +83,26 @@ def parsePEMKey(s, private=False, public=False, passwordCallback=None, implement</span>

<span class="w"> </span>    :raises SyntaxError: If the key is not properly formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for implementation in implementations:</span>
<span class="gi">+        if implementation == &#39;openssl&#39; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            key = OpenSSL_RSAKey.parse(s, passwordCallback)</span>
<span class="gi">+            break</span>
<span class="gi">+        elif implementation == &#39;python&#39;:</span>
<span class="gi">+            key = Python_RSAKey.parse(s)</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if private and not key.hasPrivateKey():</span>
<span class="gi">+        raise SyntaxError(&quot;Not a private key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if public:</span>
<span class="gi">+        return _createPublicKey(key)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if private:</span>
<span class="gi">+            return _createPrivateKey(key)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return key</span>

<span class="w"> </span>def parseAsPublicKey(s):
<span class="w"> </span>    &quot;&quot;&quot;Parse a PEM-formatted public key.
<span class="gu">@@ -91,7 +115,7 @@ def parseAsPublicKey(s):</span>

<span class="w"> </span>    :raises SyntaxError: If the key is not properly formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return parsePEMKey(s, public=True)</span>

<span class="w"> </span>def parsePrivateKey(s):
<span class="w"> </span>    &quot;&quot;&quot;Parse a PEM-formatted private key.
<span class="gu">@@ -104,20 +128,31 @@ def parsePrivateKey(s):</span>

<span class="w"> </span>    :raises SyntaxError: If the key is not properly formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return parsePEMKey(s, private=True)</span>

<span class="w"> </span>def _createPublicKey(key):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new public key.  Discard any private component,
<span class="w"> </span>    and return the most efficient key possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(key, RSAKey):</span>
<span class="gi">+        raise ValueError(&quot;Unsupported key type&quot;)</span>
<span class="gi">+    return key.publicKey()</span>

<span class="w"> </span>def _createPrivateKey(key):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new private key.  Return the most efficient key possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(key, RSAKey):</span>
<span class="gi">+        raise ValueError(&quot;Unsupported key type&quot;)</span>
<span class="gi">+    return key</span>
<span class="gi">+</span>
<span class="gi">+def _createPublicRSAKey(n, e):</span>
<span class="gi">+    &quot;&quot;&quot;Create a new public RSA key from modulus and exponent.&quot;&quot;&quot;</span>
<span class="gi">+    key = Python_RSAKey()</span>
<span class="gi">+    key.n = n</span>
<span class="gi">+    key.e = e</span>
<span class="gi">+    return _createPublicKey(key)</span>

<span class="w"> </span>def _create_public_ecdsa_key(point_x, point_y, curve_name, implementations=(&#39;python&#39;,)):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -139,14 +174,18 @@ def _create_public_ecdsa_key(point_x, point_y, curve_name, implementations=(&#39;pyt</span>
<span class="w"> </span>        concrete implementation of the verifying key (only &#39;python&#39; is
<span class="w"> </span>        supported currently)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;python&#39; not in implementations:</span>
<span class="gi">+        raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+    return Python_ECDSAKey(point_x, point_y, curve_name)</span>

<span class="w"> </span>def _create_public_eddsa_key(public_key, implementations=(&#39;python&#39;,)):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert the python-ecdsa public key into concrete implementation of
<span class="w"> </span>    verifier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;python&#39; not in implementations:</span>
<span class="gi">+        raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+    return Python_EdDSAKey(public_key)</span>

<span class="w"> </span>def _create_public_dsa_key(p, q, g, y, implementations=(&#39;python&#39;,)):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -167,4 +206,6 @@ def _create_public_dsa_key(p, q, g, y, implementations=(&#39;python&#39;,)):</span>
<span class="w"> </span>        concrete implementation of the verifying key (only &#39;python&#39; is
<span class="w"> </span>        supported currently)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if &#39;python&#39; not in implementations:</span>
<span class="gi">+        raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+    return Python_DSAKey(p, q, g, y)</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/openssl_aesccm.py b/tlslite/utils/openssl_aesccm.py</span>
<span class="gh">index 8c708cb..ed36242 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_aesccm.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_aesccm.py</span>
<span class="gu">@@ -3,10 +3,9 @@ from tlslite.utils.cryptomath import m2cryptoLoaded</span>
<span class="w"> </span>from tlslite.utils.aesccm import AESCCM
<span class="w"> </span>from tlslite.utils import openssl_aes
<span class="w"> </span>if m2cryptoLoaded:
<span class="gi">+    class OPENSSL_AESCCM(AESCCM):</span>

<span class="gd">-class OPENSSL_AESCCM(AESCCM):</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, key, implementation, rawAesEncrypt, tagLength):</span>
<span class="gd">-        super(OPENSSL_AESCCM, self).__init__(key, implementation, rawAesEncrypt, tagLength)</span>
<span class="gd">-        self._ctr = openssl_aes.new(key, 6, bytearray(b&#39;\x00&#39; * 16))</span>
<span class="gd">-        self._cbc = openssl_aes.new(key, 2, bytearray(b&#39;\x00&#39; * 16))</span>
\ No newline at end of file
<span class="gi">+        def __init__(self, key, implementation, rawAesEncrypt, tagLength):</span>
<span class="gi">+            super(OPENSSL_AESCCM, self).__init__(key, implementation, rawAesEncrypt, tagLength)</span>
<span class="gi">+            self._ctr = openssl_aes.new(key, 6, bytearray(b&#39;\x00&#39; * 16))</span>
<span class="gi">+            self._cbc = openssl_aes.new(key, 2, bytearray(b&#39;\x00&#39; * 16))</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/openssl_aesgcm.py b/tlslite/utils/openssl_aesgcm.py</span>
<span class="gh">index 5283cf6..4f61aa2 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_aesgcm.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_aesgcm.py</span>
<span class="gu">@@ -4,9 +4,8 @@ from tlslite.utils.aesgcm import AESGCM</span>
<span class="w"> </span>from tlslite.utils import openssl_aes
<span class="w"> </span>from tlslite.utils.rijndael import Rijndael
<span class="w"> </span>if m2cryptoLoaded:
<span class="gi">+    class OPENSSL_AESGCM(AESGCM):</span>

<span class="gd">-class OPENSSL_AESGCM(AESGCM):</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, key, implementation, rawAesEncrypt):</span>
<span class="gd">-        super(OPENSSL_AESGCM, self).__init__(key, implementation, rawAesEncrypt)</span>
<span class="gd">-        self._ctr = openssl_aes.new(key, 6, bytearray(b&#39;\x00&#39; * 16))</span>
\ No newline at end of file
<span class="gi">+        def __init__(self, key, implementation, rawAesEncrypt):</span>
<span class="gi">+            super(OPENSSL_AESGCM, self).__init__(key, implementation, rawAesEncrypt)</span>
<span class="gi">+            self._ctr = openssl_aes.new(key, 6, bytearray(b&#39;\x00&#39; * 16))</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/pem.py b/tlslite/utils/pem.py</span>
<span class="gh">index 79ec0cd..b0aff2b 100644</span>
<span class="gd">--- a/tlslite/utils/pem.py</span>
<span class="gi">+++ b/tlslite/utils/pem.py</span>
<span class="gu">@@ -16,7 +16,23 @@ def dePem(s, name):</span>
<span class="w"> </span>    The first such PEM block in the input will be found, and its
<span class="w"> </span>    payload will be base64 decoded and returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    start = &quot;-----BEGIN &quot; + name + &quot;-----&quot;</span>
<span class="gi">+    end = &quot;-----END &quot; + name + &quot;-----&quot;</span>
<span class="gi">+    s = str(s)</span>
<span class="gi">+</span>
<span class="gi">+    # Find first PEM block</span>
<span class="gi">+    start_index = s.find(start)</span>
<span class="gi">+    if start_index == -1:</span>
<span class="gi">+        raise SyntaxError(&quot;Missing PEM prefix&quot;)</span>
<span class="gi">+    end_index = s.find(end, start_index + len(start))</span>
<span class="gi">+    if end_index == -1:</span>
<span class="gi">+        raise SyntaxError(&quot;Missing PEM postfix&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Get payload</span>
<span class="gi">+    s = s[start_index + len(start):end_index]</span>
<span class="gi">+    s = &#39;&#39;.join(s.splitlines())</span>
<span class="gi">+    s = s.strip()</span>
<span class="gi">+    return bytearray(binascii.a2b_base64(s))</span>

<span class="w"> </span>def dePemList(s, name):
<span class="w"> </span>    &quot;&quot;&quot;Decode a sequence of PEM blocks into a list of bytearrays.
<span class="gu">@@ -42,7 +58,24 @@ def dePemList(s, name):</span>
<span class="w"> </span>    All such PEM blocks will be found, decoded, and return in an ordered list
<span class="w"> </span>    of bytearrays, which may have zero elements if not PEM blocks are found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bList = []</span>
<span class="gi">+    start = &quot;-----BEGIN &quot; + name + &quot;-----&quot;</span>
<span class="gi">+    end = &quot;-----END &quot; + name + &quot;-----&quot;</span>
<span class="gi">+    s = str(s)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        start_index = s.find(start)</span>
<span class="gi">+        if start_index == -1:</span>
<span class="gi">+            break</span>
<span class="gi">+        end_index = s.find(end, start_index + len(start))</span>
<span class="gi">+        if end_index == -1:</span>
<span class="gi">+            break</span>
<span class="gi">+        # Get the payload</span>
<span class="gi">+        payload = s[start_index + len(start):end_index]</span>
<span class="gi">+        payload = &#39;&#39;.join(payload.splitlines())</span>
<span class="gi">+        payload = payload.strip()</span>
<span class="gi">+        bList.append(bytearray(binascii.a2b_base64(payload)))</span>
<span class="gi">+        s = s[end_index + len(end):]</span>
<span class="gi">+    return bList</span>

<span class="w"> </span>def pem(b, name):
<span class="w"> </span>    &quot;&quot;&quot;Encode a payload bytearray into a PEM string.
<span class="gu">@@ -56,4 +89,33 @@ def pem(b, name):</span>
<span class="w"> </span>        KoZIhvcNAQEFBQADAwA5kw==
<span class="w"> </span>        -----END CERTIFICATE-----
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    s = binascii.b2a_base64(b).decode()</span>
<span class="gi">+    s = s.rstrip()  # remove newline from b2a_base64</span>
<span class="gi">+    s = &quot;-----BEGIN &quot; + name + &quot;-----\n&quot; + \</span>
<span class="gi">+        s + &quot;\n&quot; + \</span>
<span class="gi">+        &quot;-----END &quot; + name + &quot;-----\n&quot;</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+def pemSniff(s, name):</span>
<span class="gi">+    &quot;&quot;&quot;Check if string appears to be a PEM-encoded payload with the specified name.</span>
<span class="gi">+</span>
<span class="gi">+    :type s: str</span>
<span class="gi">+    :param s: The string to check.</span>
<span class="gi">+</span>
<span class="gi">+    :type name: str</span>
<span class="gi">+    :param name: The expected name of the PEM payload.</span>
<span class="gi">+</span>
<span class="gi">+    :rtype: bool</span>
<span class="gi">+    :returns: True if the string appears to be a PEM-encoded payload with the</span>
<span class="gi">+        specified name, False otherwise.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    start = &quot;-----BEGIN &quot; + name + &quot;-----&quot;</span>
<span class="gi">+    end = &quot;-----END &quot; + name + &quot;-----&quot;</span>
<span class="gi">+    s = str(s)</span>
<span class="gi">+    start_index = s.find(start)</span>
<span class="gi">+    if start_index == -1:</span>
<span class="gi">+        return False</span>
<span class="gi">+    end_index = s.find(end, start_index + len(start))</span>
<span class="gi">+    if end_index == -1:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/python_rsakey.py b/tlslite/utils/python_rsakey.py</span>
<span class="gh">index 5571d84..6269124 100644</span>
<span class="gd">--- a/tlslite/utils/python_rsakey.py</span>
<span class="gi">+++ b/tlslite/utils/python_rsakey.py</span>
<span class="gu">@@ -55,11 +55,11 @@ class Python_RSAKey(RSAKey):</span>
<span class="w"> </span>        Does the key has the associated private key (True) or is it only
<span class="w"> </span>        the public part (False).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.d != 0</span>

<span class="w"> </span>    def acceptsPassword(self):
<span class="w"> </span>        &quot;&quot;&quot;Does it support encrypted key files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate(bits, key_type=&#39;rsa&#39;):
<span class="gu">@@ -67,10 +67,62 @@ class Python_RSAKey(RSAKey):</span>

<span class="w"> </span>        key_type can be &quot;rsa&quot; for a universal rsaEncryption key or
<span class="w"> </span>        &quot;rsa-pss&quot; for a key that can be used only for RSASSA-PSS.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = Python_RSAKey(key_type=key_type)</span>
<span class="gi">+        p = getRandomPrime(bits // 2, False)</span>
<span class="gi">+        q = getRandomPrime(bits // 2, False)</span>
<span class="gi">+        n = p * q</span>
<span class="gi">+        t = lcm(p - 1, q - 1)</span>
<span class="gi">+        e = 65537</span>
<span class="gi">+        d = invMod(e, t)</span>
<span class="gi">+        key.n = n</span>
<span class="gi">+        key.e = e</span>
<span class="gi">+        key.d = d</span>
<span class="gi">+        key.p = p</span>
<span class="gi">+        key.q = q</span>
<span class="gi">+        key.dP = d % (p - 1)</span>
<span class="gi">+        key.dQ = d % (q - 1)</span>
<span class="gi">+        key.qInv = invMod(q, p)</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse(s):</span>
<span class="gi">+        &quot;&quot;&quot;Parse a string containing a PEM-encoded key.&quot;&quot;&quot;</span>
<span class="gi">+        return Python_RSAKey.parsePEM(s)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    @deprecated_params({&#39;data&#39;: &#39;s&#39;, &#39;password_callback&#39;: &#39;passwordCallback&#39;})
<span class="w"> </span>    def parsePEM(data, password_callback=None):
<span class="w"> </span>        &quot;&quot;&quot;Parse a string containing a PEM-encoded &lt;privateKey&gt;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        if password_callback:</span>
<span class="gi">+            raise ValueError(&quot;This implementation does not support encrypted keys&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Try to parse as private key first</span>
<span class="gi">+        try:</span>
<span class="gi">+            der = dePem(data, &quot;RSA PRIVATE KEY&quot;)</span>
<span class="gi">+            key = Python_RSAKey()</span>
<span class="gi">+            p = Parser(der)</span>
<span class="gi">+            p.get(1)  # skip version</span>
<span class="gi">+            key.n = p.getInt(1)</span>
<span class="gi">+            key.e = p.getInt(1)</span>
<span class="gi">+            key.d = p.getInt(1)</span>
<span class="gi">+            key.p = p.getInt(1)</span>
<span class="gi">+            key.q = p.getInt(1)</span>
<span class="gi">+            key.dP = p.getInt(1)</span>
<span class="gi">+            key.dQ = p.getInt(1)</span>
<span class="gi">+            key.qInv = p.getInt(1)</span>
<span class="gi">+            return key</span>
<span class="gi">+        except SyntaxError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Try to parse as public key</span>
<span class="gi">+        try:</span>
<span class="gi">+            der = dePem(data, &quot;RSA PUBLIC KEY&quot;)</span>
<span class="gi">+            key = Python_RSAKey()</span>
<span class="gi">+            p = Parser(der)</span>
<span class="gi">+            key.n = p.getInt(1)</span>
<span class="gi">+            key.e = p.getInt(1)</span>
<span class="gi">+            return key</span>
<span class="gi">+        except SyntaxError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        raise SyntaxError(&quot;Not a valid PEM file&quot;)</span>
\ No newline at end of file
<span class="gh">diff --git a/unit_tests/test_tlslite_integration_tlsasynciodispatchermixin.py b/unit_tests/test_tlslite_integration_tlsasynciodispatchermixin.py</span>
<span class="gh">index 7c7d3eb..2839882 100644</span>
<span class="gd">--- a/unit_tests/test_tlslite_integration_tlsasynciodispatchermixin.py</span>
<span class="gi">+++ b/unit_tests/test_tlslite_integration_tlsasynciodispatchermixin.py</span>
<span class="gu">@@ -6,9 +6,9 @@ import sys</span>
<span class="w"> </span># which is not available in Python 2- asyncio is used
<span class="w"> </span># in the implementation of TLSAsyncioDispatcherMixIn
<span class="w"> </span>try:
<span class="gi">+    import asyncio</span>
<span class="w"> </span>    from tlslite.integration.tlsasynciodispatchermixin \
<span class="w"> </span>        import TLSAsyncioDispatcherMixIn
<span class="gd">-    import asyncio</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pass
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>