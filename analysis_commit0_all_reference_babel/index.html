
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference babel - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-babel" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference babel
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-babel"><strong>Reference (Gold)</strong>: babel</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">5663</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1042</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">6705</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">6705</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/babel/core.py b/babel/core.py</span>
<span class="gh">index 44904d4..207c13b 100644</span>
<span class="gd">--- a/babel/core.py</span>
<span class="gi">+++ b/babel/core.py</span>
<span class="gu">@@ -7,29 +7,57 @@</span>
<span class="w"> </span>    :copyright: (c) 2013-2023 by the Babel Team.
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import pickle
<span class="w"> </span>from collections.abc import Iterable, Mapping
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from babel import localedata
<span class="w"> </span>from babel.plural import PluralRule
<span class="gd">-__all__ = [&#39;UnknownLocaleError&#39;, &#39;Locale&#39;, &#39;default_locale&#39;,</span>
<span class="gd">-    &#39;negotiate_locale&#39;, &#39;parse_locale&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&#39;UnknownLocaleError&#39;, &#39;Locale&#39;, &#39;default_locale&#39;, &#39;negotiate_locale&#39;,</span>
<span class="gi">+           &#39;parse_locale&#39;]</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal, TypeAlias
<span class="gd">-    _GLOBAL_KEY: TypeAlias = Literal[&#39;all_currencies&#39;, &#39;currency_fractions&#39;,</span>
<span class="gd">-        &#39;language_aliases&#39;, &#39;likely_subtags&#39;, &#39;meta_zones&#39;,</span>
<span class="gd">-        &#39;parent_exceptions&#39;, &#39;script_aliases&#39;, &#39;territory_aliases&#39;,</span>
<span class="gd">-        &#39;territory_currencies&#39;, &#39;territory_languages&#39;, &#39;territory_zones&#39;,</span>
<span class="gd">-        &#39;variant_aliases&#39;, &#39;windows_zone_mapping&#39;, &#39;zone_aliases&#39;,</span>
<span class="gd">-        &#39;zone_territories&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    _GLOBAL_KEY: TypeAlias = Literal[</span>
<span class="gi">+        &quot;all_currencies&quot;,</span>
<span class="gi">+        &quot;currency_fractions&quot;,</span>
<span class="gi">+        &quot;language_aliases&quot;,</span>
<span class="gi">+        &quot;likely_subtags&quot;,</span>
<span class="gi">+        &quot;meta_zones&quot;,</span>
<span class="gi">+        &quot;parent_exceptions&quot;,</span>
<span class="gi">+        &quot;script_aliases&quot;,</span>
<span class="gi">+        &quot;territory_aliases&quot;,</span>
<span class="gi">+        &quot;territory_currencies&quot;,</span>
<span class="gi">+        &quot;territory_languages&quot;,</span>
<span class="gi">+        &quot;territory_zones&quot;,</span>
<span class="gi">+        &quot;variant_aliases&quot;,</span>
<span class="gi">+        &quot;windows_zone_mapping&quot;,</span>
<span class="gi">+        &quot;zone_aliases&quot;,</span>
<span class="gi">+        &quot;zone_territories&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>    _global_data: Mapping[_GLOBAL_KEY, Mapping[str, Any]] | None
<span class="gi">+</span>
<span class="w"> </span>_global_data = None
<span class="w"> </span>_default_plural_rule = PluralRule({})


<span class="gd">-def get_global(key: _GLOBAL_KEY) -&gt;Mapping[str, Any]:</span>
<span class="gi">+def _raise_no_data_error():</span>
<span class="gi">+    raise RuntimeError(&#39;The babel data files are not available. &#39;</span>
<span class="gi">+                       &#39;This usually happens because you are using &#39;</span>
<span class="gi">+                       &#39;a source checkout from Babel and you did &#39;</span>
<span class="gi">+                       &#39;not build the data files.  Just make sure &#39;</span>
<span class="gi">+                       &#39;to run &quot;python setup.py import_cldr&quot; before &#39;</span>
<span class="gi">+                       &#39;installing the library.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_global(key: _GLOBAL_KEY) -&gt; Mapping[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the dictionary for the given key in the global data.

<span class="w"> </span>    The global data is stored in the ``babel/global.dat`` file and contains
<span class="gu">@@ -63,18 +91,28 @@ def get_global(key: _GLOBAL_KEY) -&gt;Mapping[str, Any]:</span>

<span class="w"> </span>    :param key: the data key
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-LOCALE_ALIASES = {&#39;ar&#39;: &#39;ar_SY&#39;, &#39;bg&#39;: &#39;bg_BG&#39;, &#39;bs&#39;: &#39;bs_BA&#39;, &#39;ca&#39;:</span>
<span class="gd">-    &#39;ca_ES&#39;, &#39;cs&#39;: &#39;cs_CZ&#39;, &#39;da&#39;: &#39;da_DK&#39;, &#39;de&#39;: &#39;de_DE&#39;, &#39;el&#39;: &#39;el_GR&#39;,</span>
<span class="gd">-    &#39;en&#39;: &#39;en_US&#39;, &#39;es&#39;: &#39;es_ES&#39;, &#39;et&#39;: &#39;et_EE&#39;, &#39;fa&#39;: &#39;fa_IR&#39;, &#39;fi&#39;:</span>
<span class="gd">-    &#39;fi_FI&#39;, &#39;fr&#39;: &#39;fr_FR&#39;, &#39;gl&#39;: &#39;gl_ES&#39;, &#39;he&#39;: &#39;he_IL&#39;, &#39;hu&#39;: &#39;hu_HU&#39;,</span>
<span class="gd">-    &#39;id&#39;: &#39;id_ID&#39;, &#39;is&#39;: &#39;is_IS&#39;, &#39;it&#39;: &#39;it_IT&#39;, &#39;ja&#39;: &#39;ja_JP&#39;, &#39;km&#39;:</span>
<span class="gd">-    &#39;km_KH&#39;, &#39;ko&#39;: &#39;ko_KR&#39;, &#39;lt&#39;: &#39;lt_LT&#39;, &#39;lv&#39;: &#39;lv_LV&#39;, &#39;mk&#39;: &#39;mk_MK&#39;,</span>
<span class="gd">-    &#39;nl&#39;: &#39;nl_NL&#39;, &#39;nn&#39;: &#39;nn_NO&#39;, &#39;no&#39;: &#39;nb_NO&#39;, &#39;pl&#39;: &#39;pl_PL&#39;, &#39;pt&#39;:</span>
<span class="gd">-    &#39;pt_PT&#39;, &#39;ro&#39;: &#39;ro_RO&#39;, &#39;ru&#39;: &#39;ru_RU&#39;, &#39;sk&#39;: &#39;sk_SK&#39;, &#39;sl&#39;: &#39;sl_SI&#39;,</span>
<span class="gd">-    &#39;sv&#39;: &#39;sv_SE&#39;, &#39;th&#39;: &#39;th_TH&#39;, &#39;tr&#39;: &#39;tr_TR&#39;, &#39;uk&#39;: &#39;uk_UA&#39;}</span>
<span class="gi">+    global _global_data</span>
<span class="gi">+    if _global_data is None:</span>
<span class="gi">+        dirname = os.path.join(os.path.dirname(__file__))</span>
<span class="gi">+        filename = os.path.join(dirname, &#39;global.dat&#39;)</span>
<span class="gi">+        if not os.path.isfile(filename):</span>
<span class="gi">+            _raise_no_data_error()</span>
<span class="gi">+        with open(filename, &#39;rb&#39;) as fileobj:</span>
<span class="gi">+            _global_data = pickle.load(fileobj)</span>
<span class="gi">+            assert _global_data is not None</span>
<span class="gi">+    return _global_data.get(key, {})</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+LOCALE_ALIASES = {</span>
<span class="gi">+    &#39;ar&#39;: &#39;ar_SY&#39;, &#39;bg&#39;: &#39;bg_BG&#39;, &#39;bs&#39;: &#39;bs_BA&#39;, &#39;ca&#39;: &#39;ca_ES&#39;, &#39;cs&#39;: &#39;cs_CZ&#39;,</span>
<span class="gi">+    &#39;da&#39;: &#39;da_DK&#39;, &#39;de&#39;: &#39;de_DE&#39;, &#39;el&#39;: &#39;el_GR&#39;, &#39;en&#39;: &#39;en_US&#39;, &#39;es&#39;: &#39;es_ES&#39;,</span>
<span class="gi">+    &#39;et&#39;: &#39;et_EE&#39;, &#39;fa&#39;: &#39;fa_IR&#39;, &#39;fi&#39;: &#39;fi_FI&#39;, &#39;fr&#39;: &#39;fr_FR&#39;, &#39;gl&#39;: &#39;gl_ES&#39;,</span>
<span class="gi">+    &#39;he&#39;: &#39;he_IL&#39;, &#39;hu&#39;: &#39;hu_HU&#39;, &#39;id&#39;: &#39;id_ID&#39;, &#39;is&#39;: &#39;is_IS&#39;, &#39;it&#39;: &#39;it_IT&#39;,</span>
<span class="gi">+    &#39;ja&#39;: &#39;ja_JP&#39;, &#39;km&#39;: &#39;km_KH&#39;, &#39;ko&#39;: &#39;ko_KR&#39;, &#39;lt&#39;: &#39;lt_LT&#39;, &#39;lv&#39;: &#39;lv_LV&#39;,</span>
<span class="gi">+    &#39;mk&#39;: &#39;mk_MK&#39;, &#39;nl&#39;: &#39;nl_NL&#39;, &#39;nn&#39;: &#39;nn_NO&#39;, &#39;no&#39;: &#39;nb_NO&#39;, &#39;pl&#39;: &#39;pl_PL&#39;,</span>
<span class="gi">+    &#39;pt&#39;: &#39;pt_PT&#39;, &#39;ro&#39;: &#39;ro_RO&#39;, &#39;ru&#39;: &#39;ru_RU&#39;, &#39;sk&#39;: &#39;sk_SK&#39;, &#39;sl&#39;: &#39;sl_SI&#39;,</span>
<span class="gi">+    &#39;sv&#39;: &#39;sv_SE&#39;, &#39;th&#39;: &#39;th_TH&#39;, &#39;tr&#39;: &#39;tr_TR&#39;, &#39;uk&#39;: &#39;uk_UA&#39;,</span>
<span class="gi">+}</span>


<span class="w"> </span>class UnknownLocaleError(Exception):
<span class="gu">@@ -82,12 +120,14 @@ class UnknownLocaleError(Exception):</span>
<span class="w"> </span>    is available.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, identifier: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, identifier: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the exception.

<span class="w"> </span>        :param identifier: the identifier string of the unsupported locale
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        Exception.__init__(self, f&#39;unknown locale {identifier!r}&#39;)</span>
<span class="gi">+        Exception.__init__(self, f&quot;unknown locale {identifier!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #: The identifier of the locale that could not be found.</span>
<span class="w"> </span>        self.identifier = identifier


<span class="gu">@@ -123,9 +163,14 @@ class Locale:</span>
<span class="w"> </span>    For more information see :rfc:`3066`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, language: str, territory: (str | None)=None, script:</span>
<span class="gd">-        (str | None)=None, variant: (str | None)=None, modifier: (str |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        language: str,</span>
<span class="gi">+        territory: str | None = None,</span>
<span class="gi">+        script: str | None = None,</span>
<span class="gi">+        variant: str | None = None,</span>
<span class="gi">+        modifier: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the locale object from the given identifier components.

<span class="w"> </span>        &gt;&gt;&gt; locale = Locale(&#39;en&#39;, &#39;US&#39;)
<span class="gu">@@ -142,20 +187,25 @@ class Locale:</span>
<span class="w"> </span>        :raise `UnknownLocaleError`: if no locale data is available for the
<span class="w"> </span>                                     requested locale
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        #: the language code</span>
<span class="w"> </span>        self.language = language
<span class="gi">+        #: the territory (country or region) code</span>
<span class="w"> </span>        self.territory = territory
<span class="gi">+        #: the script code</span>
<span class="w"> </span>        self.script = script
<span class="gi">+        #: the variant code</span>
<span class="w"> </span>        self.variant = variant
<span class="gi">+        #: the modifier</span>
<span class="w"> </span>        self.modifier = modifier
<span class="w"> </span>        self.__data: localedata.LocaleDataDict | None = None
<span class="gi">+</span>
<span class="w"> </span>        identifier = str(self)
<span class="w"> </span>        identifier_without_modifier = identifier.partition(&#39;@&#39;)[0]
<span class="w"> </span>        if not localedata.exists(identifier_without_modifier):
<span class="w"> </span>            raise UnknownLocaleError(identifier)

<span class="w"> </span>    @classmethod
<span class="gd">-    def default(cls, category: (str | None)=None, aliases: Mapping[str, str</span>
<span class="gd">-        ]=LOCALE_ALIASES) -&gt;Locale:</span>
<span class="gi">+    def default(cls, category: str | None = None, aliases: Mapping[str, str] = LOCALE_ALIASES) -&gt; Locale:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the system default locale for the specified category.

<span class="w"> </span>        &gt;&gt;&gt; for name in [&#39;LANGUAGE&#39;, &#39;LC_ALL&#39;, &#39;LC_CTYPE&#39;, &#39;LC_MESSAGES&#39;]:
<span class="gu">@@ -174,12 +224,19 @@ class Locale:</span>
<span class="w"> </span>        :param category: one of the ``LC_XXX`` environment variable names
<span class="w"> </span>        :param aliases: a dictionary of aliases for locale identifiers
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # XXX: use likely subtag expansion here instead of the</span>
<span class="gi">+        # aliases dictionary.</span>
<span class="gi">+        locale_string = default_locale(category, aliases=aliases)</span>
<span class="gi">+        return cls.parse(locale_string)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def negotiate(cls, preferred: Iterable[str], available: Iterable[str],</span>
<span class="gd">-        sep: str=&#39;_&#39;, aliases: Mapping[str, str]=LOCALE_ALIASES) -&gt;(Locale |</span>
<span class="gd">-        None):</span>
<span class="gi">+    def negotiate(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        preferred: Iterable[str],</span>
<span class="gi">+        available: Iterable[str],</span>
<span class="gi">+        sep: str = &#39;_&#39;,</span>
<span class="gi">+        aliases: Mapping[str, str] = LOCALE_ALIASES,</span>
<span class="gi">+    ) -&gt; Locale | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the best match between available and requested locale strings.

<span class="w"> </span>        &gt;&gt;&gt; Locale.negotiate([&#39;de_DE&#39;, &#39;en_US&#39;], [&#39;de_DE&#39;, &#39;de_AT&#39;])
<span class="gu">@@ -199,11 +256,19 @@ class Locale:</span>
<span class="w"> </span>        :param available: the list of locale identifiers available
<span class="w"> </span>        :param aliases: a dictionary of aliases for locale identifiers
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        identifier = negotiate_locale(preferred, available, sep=sep,</span>
<span class="gi">+                                      aliases=aliases)</span>
<span class="gi">+        if identifier:</span>
<span class="gi">+            return Locale.parse(identifier, sep=sep)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def parse(cls, identifier: (str | Locale | None), sep: str=&#39;_&#39;,</span>
<span class="gd">-        resolve_likely_subtags: bool=True) -&gt;Locale:</span>
<span class="gi">+    def parse(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        identifier: str | Locale | None,</span>
<span class="gi">+        sep: str = &#39;_&#39;,</span>
<span class="gi">+        resolve_likely_subtags: bool = True,</span>
<span class="gi">+    ) -&gt; Locale:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a `Locale` instance for the given locale identifier.

<span class="w"> </span>        &gt;&gt;&gt; l = Locale.parse(&#39;de-DE&#39;, sep=&#39;-&#39;)
<span class="gu">@@ -257,39 +322,124 @@ class Locale:</span>
<span class="w"> </span>                                     requested locale
<span class="w"> </span>        :raise `TypeError`: if the identifier is not a string or a `Locale`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+        if isinstance(identifier, Locale):</span>
<span class="gi">+            return identifier</span>
<span class="gi">+        elif not isinstance(identifier, str):</span>
<span class="gi">+            raise TypeError(f&quot;Unexpected value for identifier: {identifier!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        parts = parse_locale(identifier, sep=sep)</span>
<span class="gi">+        input_id = get_locale_identifier(parts)</span>
<span class="gi">+</span>
<span class="gi">+        def _try_load(parts):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls(*parts)</span>
<span class="gi">+            except UnknownLocaleError:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        def _try_load_reducing(parts):</span>
<span class="gi">+            # Success on first hit, return it.</span>
<span class="gi">+            locale = _try_load(parts)</span>
<span class="gi">+            if locale is not None:</span>
<span class="gi">+                return locale</span>
<span class="gi">+</span>
<span class="gi">+            # Now try without script and variant</span>
<span class="gi">+            locale = _try_load(parts[:2])</span>
<span class="gi">+            if locale is not None:</span>
<span class="gi">+                return locale</span>
<span class="gi">+</span>
<span class="gi">+        locale = _try_load(parts)</span>
<span class="gi">+        if locale is not None:</span>
<span class="gi">+            return locale</span>
<span class="gi">+        if not resolve_likely_subtags:</span>
<span class="gi">+            raise UnknownLocaleError(input_id)</span>
<span class="gi">+</span>
<span class="gi">+        # From here onwards is some very bad likely subtag resolving.  This</span>
<span class="gi">+        # whole logic is not entirely correct but good enough (tm) for the</span>
<span class="gi">+        # time being.  This has been added so that zh_TW does not cause</span>
<span class="gi">+        # errors for people when they upgrade.  Later we should properly</span>
<span class="gi">+        # implement ICU like fuzzy locale objects and provide a way to</span>
<span class="gi">+        # maximize and minimize locale tags.</span>
<span class="gi">+</span>
<span class="gi">+        if len(parts) == 5:</span>
<span class="gi">+            language, territory, script, variant, modifier = parts</span>
<span class="gi">+        else:</span>
<span class="gi">+            language, territory, script, variant = parts</span>
<span class="gi">+            modifier = None</span>
<span class="gi">+        language = get_global(&#39;language_aliases&#39;).get(language, language)</span>
<span class="gi">+        territory = get_global(&#39;territory_aliases&#39;).get(territory or &#39;&#39;, (territory,))[0]</span>
<span class="gi">+        script = get_global(&#39;script_aliases&#39;).get(script or &#39;&#39;, script)</span>
<span class="gi">+        variant = get_global(&#39;variant_aliases&#39;).get(variant or &#39;&#39;, variant)</span>
<span class="gi">+</span>
<span class="gi">+        if territory == &#39;ZZ&#39;:</span>
<span class="gi">+            territory = None</span>
<span class="gi">+        if script == &#39;Zzzz&#39;:</span>
<span class="gi">+            script = None</span>
<span class="gi">+</span>
<span class="gi">+        parts = language, territory, script, variant, modifier</span>
<span class="gi">+</span>
<span class="gi">+        # First match: try the whole identifier</span>
<span class="gi">+        new_id = get_locale_identifier(parts)</span>
<span class="gi">+        likely_subtag = get_global(&#39;likely_subtags&#39;).get(new_id)</span>
<span class="gi">+        if likely_subtag is not None:</span>
<span class="gi">+            locale = _try_load_reducing(parse_locale(likely_subtag))</span>
<span class="gi">+            if locale is not None:</span>
<span class="gi">+                return locale</span>
<span class="gi">+</span>
<span class="gi">+        # If we did not find anything so far, try again with a</span>
<span class="gi">+        # simplified identifier that is just the language</span>
<span class="gi">+        likely_subtag = get_global(&#39;likely_subtags&#39;).get(language)</span>
<span class="gi">+        if likely_subtag is not None:</span>
<span class="gi">+            parts2 = parse_locale(likely_subtag)</span>
<span class="gi">+            if len(parts2) == 5:</span>
<span class="gi">+                language2, _, script2, variant2, modifier2 = parts2</span>
<span class="gi">+            else:</span>
<span class="gi">+                language2, _, script2, variant2 = parts2</span>
<span class="gi">+                modifier2 = None</span>
<span class="gi">+            locale = _try_load_reducing((language2, territory, script2, variant2, modifier2))</span>
<span class="gi">+            if locale is not None:</span>
<span class="gi">+                return locale</span>
<span class="gi">+</span>
<span class="gi">+        raise UnknownLocaleError(input_id)</span>
<span class="gi">+</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        for key in (&#39;language&#39;, &#39;territory&#39;, &#39;script&#39;, &#39;variant&#39;, &#39;modifier&#39;):
<span class="w"> </span>            if not hasattr(other, key):
<span class="w"> </span>                return False
<span class="gd">-        return self.language == getattr(other, &#39;language&#39;</span>
<span class="gd">-            ) and self.territory == getattr(other, &#39;territory&#39;</span>
<span class="gd">-            ) and self.script == getattr(other, &#39;script&#39;</span>
<span class="gd">-            ) and self.variant == getattr(other, &#39;variant&#39;</span>
<span class="gd">-            ) and self.modifier == getattr(other, &#39;modifier&#39;)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.language == getattr(other, &#39;language&#39;) and  # noqa: B009</span>
<span class="gi">+            self.territory == getattr(other, &#39;territory&#39;) and  # noqa: B009</span>
<span class="gi">+            self.script == getattr(other, &#39;script&#39;) and  # noqa: B009</span>
<span class="gi">+            self.variant == getattr(other, &#39;variant&#39;) and  # noqa: B009</span>
<span class="gi">+            self.modifier == getattr(other, &#39;modifier&#39;)  # noqa: B009</span>
<span class="gi">+        )</span>

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return not self.__eq__(other)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.language, self.territory, self.script, self.</span>
<span class="gd">-            variant, self.modifier))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.language, self.territory, self.script,</span>
<span class="gi">+                     self.variant, self.modifier))</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        parameters = [&#39;&#39;]
<span class="w"> </span>        for key in (&#39;territory&#39;, &#39;script&#39;, &#39;variant&#39;, &#39;modifier&#39;):
<span class="w"> </span>            value = getattr(self, key)
<span class="w"> </span>            if value is not None:
<span class="gd">-                parameters.append(f&#39;{key}={value!r}&#39;)</span>
<span class="gi">+                parameters.append(f&quot;{key}={value!r}&quot;)</span>
<span class="w"> </span>        return f&quot;Locale({self.language!r}{&#39;, &#39;.join(parameters)})&quot;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return get_locale_identifier((self.language, self.territory, self.</span>
<span class="gd">-            script, self.variant, self.modifier))</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return get_locale_identifier((self.language, self.territory,</span>
<span class="gi">+                                      self.script, self.variant,</span>
<span class="gi">+                                      self.modifier))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _data(self) -&gt; localedata.LocaleDataDict:</span>
<span class="gi">+        if self.__data is None:</span>
<span class="gi">+            self.__data = localedata.LocaleDataDict(localedata.load(str(self)))</span>
<span class="gi">+        return self.__data</span>

<span class="gd">-    def get_display_name(self, locale: (Locale | str | None)=None) -&gt;(str |</span>
<span class="gd">-        None):</span>
<span class="gi">+    def get_display_name(self, locale: Locale | str | None = None) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the display name of the locale using the given locale.

<span class="w"> </span>        The display name will include the language, territory, script, and
<span class="gu">@@ -305,9 +455,27 @@ class Locale:</span>

<span class="w"> </span>        :param locale: the locale to use
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    display_name = property(get_display_name, doc=</span>
<span class="gd">-        &quot;&quot;&quot;        The localized display name of the locale.</span>
<span class="gi">+        if locale is None:</span>
<span class="gi">+            locale = self</span>
<span class="gi">+        locale = Locale.parse(locale)</span>
<span class="gi">+        retval = locale.languages.get(self.language)</span>
<span class="gi">+        if retval and (self.territory or self.script or self.variant):</span>
<span class="gi">+            details = []</span>
<span class="gi">+            if self.script:</span>
<span class="gi">+                details.append(locale.scripts.get(self.script))</span>
<span class="gi">+            if self.territory:</span>
<span class="gi">+                details.append(locale.territories.get(self.territory))</span>
<span class="gi">+            if self.variant:</span>
<span class="gi">+                details.append(locale.variants.get(self.variant))</span>
<span class="gi">+            if self.modifier:</span>
<span class="gi">+                details.append(self.modifier)</span>
<span class="gi">+            detail_string = &#39;, &#39;.join(atom for atom in details if atom)</span>
<span class="gi">+            if detail_string:</span>
<span class="gi">+                retval += f&quot; ({detail_string})&quot;</span>
<span class="gi">+        return retval</span>
<span class="gi">+</span>
<span class="gi">+    display_name = property(get_display_name, doc=&quot;&quot;&quot;\</span>
<span class="gi">+        The localized display name of the locale.</span>

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;).display_name
<span class="w"> </span>        u&#39;English&#39;
<span class="gu">@@ -317,11 +485,9 @@ class Locale:</span>
<span class="w"> </span>        u&#39;svenska&#39;

<span class="w"> </span>        :type: `unicode`
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+        &quot;&quot;&quot;)</span>

<span class="gd">-    def get_language_name(self, locale: (Locale | str | None)=None) -&gt;(str |</span>
<span class="gd">-        None):</span>
<span class="gi">+    def get_language_name(self, locale: Locale | str | None = None) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the language of this locale in the given locale.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;zh&#39;, &#39;CN&#39;, script=&#39;Hans&#39;).get_language_name(&#39;de&#39;)
<span class="gu">@@ -331,41 +497,48 @@ class Locale:</span>

<span class="w"> </span>        :param locale: the locale to use
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    language_name = property(get_language_name, doc=</span>
<span class="gd">-        &quot;&quot;&quot;        The localized language name of the locale.</span>
<span class="gi">+        if locale is None:</span>
<span class="gi">+            locale = self</span>
<span class="gi">+        locale = Locale.parse(locale)</span>
<span class="gi">+        return locale.languages.get(self.language)</span>
<span class="gi">+</span>
<span class="gi">+    language_name = property(get_language_name, doc=&quot;&quot;&quot;\</span>
<span class="gi">+        The localized language name of the locale.</span>

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).language_name
<span class="w"> </span>        u&#39;English&#39;
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+    &quot;&quot;&quot;)</span>

<span class="gd">-    def get_territory_name(self, locale: (Locale | str | None)=None) -&gt;(str |</span>
<span class="gd">-        None):</span>
<span class="gi">+    def get_territory_name(self, locale: Locale | str | None = None) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the territory name in the given locale.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    territory_name = property(get_territory_name, doc=</span>
<span class="gd">-        &quot;&quot;&quot;        The localized territory name of the locale if available.</span>
<span class="gi">+        if locale is None:</span>
<span class="gi">+            locale = self</span>
<span class="gi">+        locale = Locale.parse(locale)</span>
<span class="gi">+        return locale.territories.get(self.territory or &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    territory_name = property(get_territory_name, doc=&quot;&quot;&quot;\</span>
<span class="gi">+        The localized territory name of the locale if available.</span>

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).territory_name
<span class="w"> </span>        u&#39;Deutschland&#39;
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+    &quot;&quot;&quot;)</span>

<span class="gd">-    def get_script_name(self, locale: (Locale | str | None)=None) -&gt;(str | None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def get_script_name(self, locale: Locale | str | None = None) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the script name in the given locale.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    script_name = property(get_script_name, doc=</span>
<span class="gd">-        &quot;&quot;&quot;        The localized script name of the locale if available.</span>
<span class="gi">+        if locale is None:</span>
<span class="gi">+            locale = self</span>
<span class="gi">+        locale = Locale.parse(locale)</span>
<span class="gi">+        return locale.scripts.get(self.script or &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    script_name = property(get_script_name, doc=&quot;&quot;&quot;\</span>
<span class="gi">+        The localized script name of the locale if available.</span>

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;sr&#39;, &#39;ME&#39;, script=&#39;Latn&#39;).script_name
<span class="w"> </span>        u&#39;latinica&#39;
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+    &quot;&quot;&quot;)</span>

<span class="w"> </span>    @property
<span class="gd">-    def english_name(self) -&gt;(str | None):</span>
<span class="gi">+    def english_name(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The english display name of the locale.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;).english_name
<span class="gu">@@ -374,10 +547,12 @@ class Locale:</span>
<span class="w"> </span>        u&#39;German (Germany)&#39;

<span class="w"> </span>        :type: `unicode`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_display_name(Locale(&#39;en&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # { General Locale Display Names</span>

<span class="w"> </span>    @property
<span class="gd">-    def languages(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def languages(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mapping of language codes to translated language names.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).languages[&#39;ja&#39;]
<span class="gu">@@ -386,10 +561,10 @@ class Locale:</span>
<span class="w"> </span>        See `ISO 639 &lt;http://www.loc.gov/standards/iso639-2/&gt;`_ for
<span class="w"> </span>        more information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;languages&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def scripts(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def scripts(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mapping of script codes to translated script names.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).scripts[&#39;Hira&#39;]
<span class="gu">@@ -398,10 +573,10 @@ class Locale:</span>
<span class="w"> </span>        See `ISO 15924 &lt;http://www.evertype.com/standards/iso15924/&gt;`_
<span class="w"> </span>        for more information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;scripts&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def territories(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def territories(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mapping of script codes to translated script names.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;es&#39;, &#39;CO&#39;).territories[&#39;DE&#39;]
<span class="gu">@@ -410,19 +585,21 @@ class Locale:</span>
<span class="w"> </span>        See `ISO 3166 &lt;http://www.iso.org/iso/en/prods-services/iso3166ma/&gt;`_
<span class="w"> </span>        for more information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;territories&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def variants(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def variants(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mapping of script codes to translated script names.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).variants[&#39;1901&#39;]
<span class="w"> </span>        u&#39;Alte deutsche Rechtschreibung&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;variants&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # { Number Formatting</span>

<span class="w"> </span>    @property
<span class="gd">-    def currencies(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def currencies(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mapping of currency codes to translated currency names.  This
<span class="w"> </span>        only returns the generic form of the currency name, not the count
<span class="w"> </span>        specific one.  If an actual number is requested use the
<span class="gu">@@ -433,10 +610,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).currencies[&#39;COP&#39;]
<span class="w"> </span>        u&#39;Kolumbianischer Peso&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;currency_names&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def currency_symbols(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def currency_symbols(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mapping of currency codes to symbols.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).currency_symbols[&#39;USD&#39;]
<span class="gu">@@ -444,10 +621,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;es&#39;, &#39;CO&#39;).currency_symbols[&#39;USD&#39;]
<span class="w"> </span>        u&#39;US$&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;currency_symbols&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def number_symbols(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def number_symbols(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Symbols used in number formatting by number system.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -460,10 +637,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;fa&#39;, &#39;IR&#39;).number_symbols[&quot;latn&quot;][&#39;decimal&#39;]
<span class="w"> </span>        u&#39;.&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;number_symbols&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def other_numbering_systems(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def other_numbering_systems(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mapping of other numbering systems available for the locale.
<span class="w"> </span>        See: https://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems
<span class="gu">@@ -474,18 +651,18 @@ class Locale:</span>
<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="w"> </span>                  Babel versions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;numbering_systems&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def default_numbering_system(self) -&gt;str:</span>
<span class="gi">+    def default_numbering_system(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The default numbering system used by the locale.
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;el&#39;, &#39;GR&#39;).default_numbering_system
<span class="w"> </span>        u&#39;latn&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;default_numbering_system&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def decimal_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def decimal_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for decimal number formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -494,10 +671,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).decimal_formats[None]
<span class="w"> </span>        &lt;NumberPattern u&#39;#,##0.###&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;decimal_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def compact_decimal_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def compact_decimal_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for compact decimal number formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -506,10 +683,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).compact_decimal_formats[&quot;short&quot;][&quot;one&quot;][&quot;1000&quot;]
<span class="w"> </span>        &lt;NumberPattern u&#39;0K&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;compact_decimal_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def currency_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def currency_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for currency number formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -520,10 +697,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).currency_formats[&#39;accounting&#39;]
<span class="w"> </span>        &lt;NumberPattern u&#39;\\xa4#,##0.00;(\\xa4#,##0.00)&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;currency_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def compact_currency_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def compact_currency_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for compact currency number formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -532,10 +709,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).compact_currency_formats[&quot;short&quot;][&quot;one&quot;][&quot;1000&quot;]
<span class="w"> </span>        &lt;NumberPattern u&#39;0K&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;compact_currency_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def percent_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def percent_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for percent number formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -544,10 +721,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).percent_formats[None]
<span class="w"> </span>        &lt;NumberPattern u&#39;#,##0%&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;percent_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def scientific_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def scientific_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for scientific number formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -556,60 +733,65 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).scientific_formats[None]
<span class="w"> </span>        &lt;NumberPattern u&#39;#E0&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;scientific_formats&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # { Calendar Information and Date Formatting</span>

<span class="w"> </span>    @property
<span class="gd">-    def periods(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def periods(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for day periods (AM/PM).

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).periods[&#39;am&#39;]
<span class="w"> </span>        u&#39;AM&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._data[&#39;day_periods&#39;][&#39;stand-alone&#39;][&#39;wide&#39;]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return localedata.LocaleDataDict({})  # pragma: no cover</span>

<span class="w"> </span>    @property
<span class="gd">-    def day_periods(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def day_periods(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for various day periods (not necessarily only AM/PM).

<span class="w"> </span>        These are not meant to be used without the relevant `day_period_rules`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;day_periods&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def day_period_rules(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def day_period_rules(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Day period rules for the locale.  Used by `get_period_id`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data.get(&#39;day_period_rules&#39;, localedata.LocaleDataDict({}))</span>

<span class="w"> </span>    @property
<span class="gd">-    def days(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def days(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for weekdays.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).days[&#39;format&#39;][&#39;wide&#39;][3]
<span class="w"> </span>        u&#39;Donnerstag&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;days&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def months(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def months(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for months.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).months[&#39;format&#39;][&#39;wide&#39;][10]
<span class="w"> </span>        u&#39;Oktober&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;months&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def quarters(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def quarters(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for quarters.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).quarters[&#39;format&#39;][&#39;wide&#39;][1]
<span class="w"> </span>        u&#39;1. Quartal&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;quarters&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def eras(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def eras(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for eras.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -620,10 +802,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).eras[&#39;abbreviated&#39;][0]
<span class="w"> </span>        u&#39;BC&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;eras&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def time_zones(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def time_zones(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for time zones.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -632,12 +814,12 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).time_zones[&#39;Europe/London&#39;][&#39;long&#39;][&#39;daylight&#39;]
<span class="w"> </span>        u&#39;British Summer Time&#39;
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).time_zones[&#39;America/St_Johns&#39;][&#39;city&#39;]
<span class="gd">-        u&#39;St. Johns&#39;</span>
<span class="gi">+        u&#39;St. John\u2019s&#39;</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;time_zones&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def meta_zones(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def meta_zones(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale display names for meta time zones.

<span class="w"> </span>        Meta time zones are basically groups of different Olson time zones that
<span class="gu">@@ -651,10 +833,10 @@ class Locale:</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;meta_zones&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def zone_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def zone_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Patterns related to the formatting of time zones.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -667,10 +849,10 @@ class Locale:</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;zone_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def first_week_day(self) -&gt;int:</span>
<span class="gi">+    def first_week_day(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The first day of a week, with 0 being Monday.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).first_week_day
<span class="gu">@@ -678,38 +860,38 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).first_week_day
<span class="w"> </span>        6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;week_data&#39;][&#39;first_day&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def weekend_start(self) -&gt;int:</span>
<span class="gi">+    def weekend_start(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The day the weekend starts, with 0 being Monday.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).weekend_start
<span class="w"> </span>        5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;week_data&#39;][&#39;weekend_start&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def weekend_end(self) -&gt;int:</span>
<span class="gi">+    def weekend_end(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The day the weekend ends, with 0 being Monday.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).weekend_end
<span class="w"> </span>        6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;week_data&#39;][&#39;weekend_end&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def min_week_days(self) -&gt;int:</span>
<span class="gi">+    def min_week_days(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The minimum number of days in a week so that the week is counted as
<span class="w"> </span>        the first week of a year or month.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).min_week_days
<span class="w"> </span>        4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;week_data&#39;][&#39;min_days&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def date_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def date_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for date formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -720,24 +902,24 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;fr&#39;, &#39;FR&#39;).date_formats[&#39;long&#39;]
<span class="w"> </span>        &lt;DateTimePattern u&#39;d MMMM y&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;date_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def time_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def time_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for time formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="w"> </span>                  Babel versions.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;, &#39;US&#39;).time_formats[&#39;short&#39;]
<span class="gd">-        &lt;DateTimePattern u&#39;h:mma&#39;&gt;</span>
<span class="gi">+        &lt;DateTimePattern u&#39;h:mm\u202fa&#39;&gt;</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;fr&#39;, &#39;FR&#39;).time_formats[&#39;long&#39;]
<span class="w"> </span>        &lt;DateTimePattern u&#39;HH:mm:ss z&#39;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;time_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def datetime_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def datetime_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for datetime formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -748,10 +930,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;th&#39;).datetime_formats[&#39;medium&#39;]
<span class="w"> </span>        u&#39;{1} {0}&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;datetime_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def datetime_skeletons(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def datetime_skeletons(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for formatting parts of a datetime.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;).datetime_skeletons[&#39;MEd&#39;]
<span class="gu">@@ -761,10 +943,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;fr&#39;).datetime_skeletons[&#39;H&#39;]
<span class="w"> </span>        &lt;DateTimePattern u&quot;HH &#39;h&#39;&quot;&gt;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;datetime_skeletons&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def interval_formats(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def interval_formats(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Locale patterns for interval formatting.

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -774,7 +956,7 @@ class Locale:</span>
<span class="w"> </span>        smallest changing component:

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;fi_FI&#39;).interval_formats[&#39;MEd&#39;][&#39;d&#39;]
<span class="gd">-        [u&#39;E d.&#39;, u&#39;E d.M.&#39;]</span>
<span class="gi">+        [u&#39;E d.\u2009\u2013\u2009&#39;, u&#39;E d.M.&#39;]</span>

<span class="w"> </span>        .. seealso::

<span class="gu">@@ -783,10 +965,10 @@ class Locale:</span>

<span class="w"> </span>        :rtype: dict[str, dict[str, list[str]]]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;interval_formats&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def plural_form(self) -&gt;PluralRule:</span>
<span class="gi">+    def plural_form(self) -&gt; PluralRule:</span>
<span class="w"> </span>        &quot;&quot;&quot;Plural rules for the locale.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;).plural_form(1)
<span class="gu">@@ -798,10 +980,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;ru&#39;).plural_form(100)
<span class="w"> </span>        &#39;many&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data.get(&#39;plural_form&#39;, _default_plural_rule)</span>

<span class="w"> </span>    @property
<span class="gd">-    def list_patterns(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def list_patterns(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Patterns for generating lists

<span class="w"> </span>        .. note:: The format of the value returned may change between
<span class="gu">@@ -814,10 +996,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en_GB&#39;).list_patterns[&#39;standard&#39;][&#39;end&#39;]
<span class="w"> </span>        u&#39;{0} and {1}&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;list_patterns&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def ordinal_form(self) -&gt;PluralRule:</span>
<span class="gi">+    def ordinal_form(self) -&gt; PluralRule:</span>
<span class="w"> </span>        &quot;&quot;&quot;Plural rules for the locale.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;en&#39;).ordinal_form(1)
<span class="gu">@@ -831,10 +1013,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;ru&#39;).ordinal_form(100)
<span class="w"> </span>        &#39;other&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data.get(&#39;ordinal_form&#39;, _default_plural_rule)</span>

<span class="w"> </span>    @property
<span class="gd">-    def measurement_systems(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def measurement_systems(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Localized names for various measurement systems.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;fr&#39;, &#39;FR&#39;).measurement_systems[&#39;US&#39;]
<span class="gu">@@ -843,10 +1025,10 @@ class Locale:</span>
<span class="w"> </span>        u&#39;US&#39;

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;measurement_systems&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def character_order(self) -&gt;str:</span>
<span class="gi">+    def character_order(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The text direction for the language.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).character_order
<span class="gu">@@ -854,10 +1036,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;ar&#39;, &#39;SA&#39;).character_order
<span class="w"> </span>        &#39;right-to-left&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;character_order&#39;]</span>

<span class="w"> </span>    @property
<span class="gd">-    def text_direction(self) -&gt;str:</span>
<span class="gi">+    def text_direction(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The text direction for the language in CSS short-hand form.

<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;de&#39;, &#39;DE&#39;).text_direction
<span class="gu">@@ -865,10 +1047,10 @@ class Locale:</span>
<span class="w"> </span>        &gt;&gt;&gt; Locale(&#39;ar&#39;, &#39;SA&#39;).text_direction
<span class="w"> </span>        &#39;rtl&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;&#39;.join(word[0] for word in self.character_order.split(&#39;-&#39;))</span>

<span class="w"> </span>    @property
<span class="gd">-    def unit_display_names(self) -&gt;localedata.LocaleDataDict:</span>
<span class="gi">+    def unit_display_names(self) -&gt; localedata.LocaleDataDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display names for units of measurement.

<span class="w"> </span>        .. seealso::
<span class="gu">@@ -879,11 +1061,10 @@ class Locale:</span>
<span class="w"> </span>                  Babel versions.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._data[&#39;unit_display_names&#39;]</span>


<span class="gd">-def default_locale(category: (str | None)=None, aliases: Mapping[str, str]=</span>
<span class="gd">-    LOCALE_ALIASES) -&gt;(str | None):</span>
<span class="gi">+def default_locale(category: str | None = None, aliases: Mapping[str, str] = LOCALE_ALIASES) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the system default locale for a given category, based on
<span class="w"> </span>    environment variables.

<span class="gu">@@ -910,11 +1091,26 @@ def default_locale(category: (str | None)=None, aliases: Mapping[str, str]=</span>
<span class="w"> </span>    :param category: one of the ``LC_XXX`` environment variable names
<span class="w"> </span>    :param aliases: a dictionary of aliases for locale identifiers
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def negotiate_locale(preferred: Iterable[str], available: Iterable[str],</span>
<span class="gd">-    sep: str=&#39;_&#39;, aliases: Mapping[str, str]=LOCALE_ALIASES) -&gt;(str | None):</span>
<span class="gi">+    varnames = (category, &#39;LANGUAGE&#39;, &#39;LC_ALL&#39;, &#39;LC_CTYPE&#39;, &#39;LANG&#39;)</span>
<span class="gi">+    for name in filter(None, varnames):</span>
<span class="gi">+        locale = os.getenv(name)</span>
<span class="gi">+        if locale:</span>
<span class="gi">+            if name == &#39;LANGUAGE&#39; and &#39;:&#39; in locale:</span>
<span class="gi">+                # the LANGUAGE variable may contain a colon-separated list of</span>
<span class="gi">+                # language codes; we just pick the language on the list</span>
<span class="gi">+                locale = locale.split(&#39;:&#39;)[0]</span>
<span class="gi">+            if locale.split(&#39;.&#39;)[0] in (&#39;C&#39;, &#39;POSIX&#39;):</span>
<span class="gi">+                locale = &#39;en_US_POSIX&#39;</span>
<span class="gi">+            elif aliases and locale in aliases:</span>
<span class="gi">+                locale = aliases[locale]</span>
<span class="gi">+            try:</span>
<span class="gi">+                return get_locale_identifier(parse_locale(locale))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def negotiate_locale(preferred: Iterable[str], available: Iterable[str], sep: str = &#39;_&#39;, aliases: Mapping[str, str] = LOCALE_ALIASES) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the best match between available and requested locale strings.

<span class="w"> </span>    &gt;&gt;&gt; negotiate_locale([&#39;de_DE&#39;, &#39;en_US&#39;], [&#39;de_DE&#39;, &#39;de_AT&#39;])
<span class="gu">@@ -960,12 +1156,27 @@ def negotiate_locale(preferred: Iterable[str], available: Iterable[str],</span>
<span class="w"> </span>                strings
<span class="w"> </span>    :param aliases: a dictionary of aliases for locale identifiers
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_locale(identifier: str, sep: str=&#39;_&#39;) -&gt;(tuple[str, str | None, </span>
<span class="gd">-    str | None, str | None] | tuple[str, str | None, str | None, str | None,</span>
<span class="gd">-    str | None]):</span>
<span class="gi">+    available = [a.lower() for a in available if a]</span>
<span class="gi">+    for locale in preferred:</span>
<span class="gi">+        ll = locale.lower()</span>
<span class="gi">+        if ll in available:</span>
<span class="gi">+            return locale</span>
<span class="gi">+        if aliases:</span>
<span class="gi">+            alias = aliases.get(ll)</span>
<span class="gi">+            if alias:</span>
<span class="gi">+                alias = alias.replace(&#39;_&#39;, sep)</span>
<span class="gi">+                if alias.lower() in available:</span>
<span class="gi">+                    return alias</span>
<span class="gi">+        parts = locale.split(sep)</span>
<span class="gi">+        if len(parts) &gt; 1 and parts[0].lower() in available:</span>
<span class="gi">+            return parts[0]</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_locale(</span>
<span class="gi">+    identifier: str,</span>
<span class="gi">+    sep: str = &#39;_&#39;,</span>
<span class="gi">+) -&gt; tuple[str, str | None, str | None, str | None] | tuple[str, str | None, str | None, str | None, str | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a locale identifier into a tuple of the form ``(language,
<span class="w"> </span>    territory, script, variant, modifier)``.

<span class="gu">@@ -1020,13 +1231,50 @@ def parse_locale(identifier: str, sep: str=&#39;_&#39;) -&gt;(tuple[str, str | None,</span>
<span class="w"> </span>    :raise `ValueError`: if the string does not appear to be a valid locale
<span class="w"> </span>                         identifier
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_locale_identifier(tup: (tuple[str] | tuple[str, str | None] | tuple</span>
<span class="gd">-    [str, str | None, str | None] | tuple[str, str | None, str | None, str |</span>
<span class="gd">-    None] | tuple[str, str | None, str | None, str | None, str | None]),</span>
<span class="gd">-    sep: str=&#39;_&#39;) -&gt;str:</span>
<span class="gi">+    identifier, _, modifier = identifier.partition(&#39;@&#39;)</span>
<span class="gi">+    if &#39;.&#39; in identifier:</span>
<span class="gi">+        # this is probably the charset/encoding, which we don&#39;t care about</span>
<span class="gi">+        identifier = identifier.split(&#39;.&#39;, 1)[0]</span>
<span class="gi">+</span>
<span class="gi">+    parts = identifier.split(sep)</span>
<span class="gi">+    lang = parts.pop(0).lower()</span>
<span class="gi">+    if not lang.isalpha():</span>
<span class="gi">+        raise ValueError(f&quot;expected only letters, got {lang!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    script = territory = variant = None</span>
<span class="gi">+    if parts and len(parts[0]) == 4 and parts[0].isalpha():</span>
<span class="gi">+        script = parts.pop(0).title()</span>
<span class="gi">+</span>
<span class="gi">+    if parts:</span>
<span class="gi">+        if len(parts[0]) == 2 and parts[0].isalpha():</span>
<span class="gi">+            territory = parts.pop(0).upper()</span>
<span class="gi">+        elif len(parts[0]) == 3 and parts[0].isdigit():</span>
<span class="gi">+            territory = parts.pop(0)</span>
<span class="gi">+</span>
<span class="gi">+    if parts and (</span>
<span class="gi">+        len(parts[0]) == 4 and parts[0][0].isdigit() or</span>
<span class="gi">+        len(parts[0]) &gt;= 5 and parts[0][0].isalpha()</span>
<span class="gi">+    ):</span>
<span class="gi">+        variant = parts.pop().upper()</span>
<span class="gi">+</span>
<span class="gi">+    if parts:</span>
<span class="gi">+        raise ValueError(f&quot;{identifier!r} is not a valid locale identifier&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO(3.0): always return a 5-tuple</span>
<span class="gi">+    if modifier:</span>
<span class="gi">+        return lang, territory, script, variant, modifier</span>
<span class="gi">+    else:</span>
<span class="gi">+        return lang, territory, script, variant</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_locale_identifier(</span>
<span class="gi">+    tup: tuple[str]</span>
<span class="gi">+    | tuple[str, str | None]</span>
<span class="gi">+    | tuple[str, str | None, str | None]</span>
<span class="gi">+    | tuple[str, str | None, str | None, str | None]</span>
<span class="gi">+    | tuple[str, str | None, str | None, str | None, str | None],</span>
<span class="gi">+    sep: str = &quot;_&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;The reverse of :func:`parse_locale`.  It creates a locale identifier out
<span class="w"> </span>    of a ``(language, territory, script, variant, modifier)`` tuple.  Items can be set to
<span class="w"> </span>    ``None`` and trailing ``None``\\s can also be left out of the tuple.
<span class="gu">@@ -1042,4 +1290,7 @@ def get_locale_identifier(tup: (tuple[str] | tuple[str, str | None] | tuple</span>
<span class="w"> </span>    :param tup: the tuple as returned by :func:`parse_locale`.
<span class="w"> </span>    :param sep: the separator for the identifier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tup = tuple(tup[:5])  # type: ignore  # length should be no more than 5</span>
<span class="gi">+    lang, territory, script, variant, modifier = tup + (None,) * (5 - len(tup))</span>
<span class="gi">+    ret = sep.join(filter(None, (lang, script, territory, variant)))</span>
<span class="gi">+    return f&#39;{ret}@{modifier}&#39; if modifier else ret</span>
<span class="gh">diff --git a/babel/dates.py b/babel/dates.py</span>
<span class="gh">index 894d925..40d9509 100644</span>
<span class="gd">--- a/babel/dates.py</span>
<span class="gi">+++ b/babel/dates.py</span>
<span class="gu">@@ -14,37 +14,67 @@</span>
<span class="w"> </span>    :copyright: (c) 2013-2023 by the Babel Team.
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import warnings
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from typing import TYPE_CHECKING, SupportsInt
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import pytz
<span class="w"> </span>except ModuleNotFoundError:
<span class="w"> </span>    pytz = None
<span class="w"> </span>    import zoneinfo
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>from babel import localtime
<span class="w"> </span>from babel.core import Locale, default_locale, get_global
<span class="w"> </span>from babel.localedata import LocaleDataDict
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal, TypeAlias
<span class="w"> </span>    _Instant: TypeAlias = datetime.date | datetime.time | float | None
<span class="gd">-    _PredefinedTimeFormat: TypeAlias = Literal[&#39;full&#39;, &#39;long&#39;, &#39;medium&#39;,</span>
<span class="gd">-        &#39;short&#39;]</span>
<span class="gi">+    _PredefinedTimeFormat: TypeAlias = Literal[&#39;full&#39;, &#39;long&#39;, &#39;medium&#39;, &#39;short&#39;]</span>
<span class="w"> </span>    _Context: TypeAlias = Literal[&#39;format&#39;, &#39;stand-alone&#39;]
<span class="gd">-    _DtOrTzinfo: TypeAlias = (datetime.datetime | datetime.tzinfo | str |</span>
<span class="gd">-        int | datetime.time | None)</span>
<span class="gd">-NO_INHERITANCE_MARKER = &#39;&#39;</span>
<span class="gi">+    _DtOrTzinfo: TypeAlias = datetime.datetime | datetime.tzinfo | str | int | datetime.time | None</span>
<span class="gi">+</span>
<span class="gi">+# &quot;If a given short metazone form is known NOT to be understood in a given</span>
<span class="gi">+#  locale and the parent locale has this value such that it would normally</span>
<span class="gi">+#  be inherited, the inheritance of this value can be explicitly disabled by</span>
<span class="gi">+#  use of the &#39;no inheritance marker&#39; as the value, which is 3 simultaneous [sic]</span>
<span class="gi">+#  empty set characters ( U+2205 ).&quot;</span>
<span class="gi">+#  - https://www.unicode.org/reports/tr35/tr35-dates.html#Metazone_Names</span>
<span class="gi">+</span>
<span class="gi">+NO_INHERITANCE_MARKER = &#39;\u2205\u2205\u2205&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>UTC = datetime.timezone.utc
<span class="w"> </span>LOCALTZ = localtime.LOCALTZ
<span class="gi">+</span>
<span class="w"> </span>LC_TIME = default_locale(&#39;LC_TIME&#39;)


<span class="gd">-def _get_dt_and_tzinfo(dt_or_tzinfo: _DtOrTzinfo) -&gt;tuple[datetime.datetime |</span>
<span class="gd">-    None, datetime.tzinfo]:</span>
<span class="gi">+def _localize(tz: datetime.tzinfo, dt: datetime.datetime) -&gt; datetime.datetime:</span>
<span class="gi">+    # Support localizing with both pytz and zoneinfo tzinfos</span>
<span class="gi">+    # nothing to do</span>
<span class="gi">+    if dt.tzinfo is tz:</span>
<span class="gi">+        return dt</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(tz, &#39;localize&#39;):  # pytz</span>
<span class="gi">+        return tz.localize(dt)</span>
<span class="gi">+</span>
<span class="gi">+    if dt.tzinfo is None:</span>
<span class="gi">+        # convert naive to localized</span>
<span class="gi">+        return dt.replace(tzinfo=tz)</span>
<span class="gi">+</span>
<span class="gi">+    # convert timezones</span>
<span class="gi">+    return dt.astimezone(tz)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_dt_and_tzinfo(dt_or_tzinfo: _DtOrTzinfo) -&gt; tuple[datetime.datetime | None, datetime.tzinfo]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a `dt_or_tzinfo` value into a datetime and a tzinfo.

<span class="gu">@@ -52,19 +82,40 @@ def _get_dt_and_tzinfo(dt_or_tzinfo: _DtOrTzinfo) -&gt;tuple[datetime.datetime |</span>

<span class="w"> </span>    :rtype: tuple[datetime, tzinfo]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_tz_name(dt_or_tzinfo: _DtOrTzinfo) -&gt;str:</span>
<span class="gi">+    if dt_or_tzinfo is None:</span>
<span class="gi">+        dt = datetime.datetime.now()</span>
<span class="gi">+        tzinfo = LOCALTZ</span>
<span class="gi">+    elif isinstance(dt_or_tzinfo, str):</span>
<span class="gi">+        dt = None</span>
<span class="gi">+        tzinfo = get_timezone(dt_or_tzinfo)</span>
<span class="gi">+    elif isinstance(dt_or_tzinfo, int):</span>
<span class="gi">+        dt = None</span>
<span class="gi">+        tzinfo = UTC</span>
<span class="gi">+    elif isinstance(dt_or_tzinfo, (datetime.datetime, datetime.time)):</span>
<span class="gi">+        dt = _get_datetime(dt_or_tzinfo)</span>
<span class="gi">+        tzinfo = dt.tzinfo if dt.tzinfo is not None else UTC</span>
<span class="gi">+    else:</span>
<span class="gi">+        dt = None</span>
<span class="gi">+        tzinfo = dt_or_tzinfo</span>
<span class="gi">+    return dt, tzinfo</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_tz_name(dt_or_tzinfo: _DtOrTzinfo) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the timezone name out of a time, datetime, or tzinfo object.

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dt, tzinfo = _get_dt_and_tzinfo(dt_or_tzinfo)</span>
<span class="gi">+    if hasattr(tzinfo, &#39;zone&#39;):  # pytz object</span>
<span class="gi">+        return tzinfo.zone</span>
<span class="gi">+    elif hasattr(tzinfo, &#39;key&#39;) and tzinfo.key is not None:  # ZoneInfo object</span>
<span class="gi">+        return tzinfo.key</span>
<span class="gi">+    else:</span>
<span class="gi">+        return tzinfo.tzname(dt or datetime.datetime.now(UTC))</span>


<span class="gd">-def _get_datetime(instant: _Instant) -&gt;datetime.datetime:</span>
<span class="gi">+def _get_datetime(instant: _Instant) -&gt; datetime.datetime:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get a datetime out of an &quot;instant&quot; (date, time, datetime, number).

<span class="gu">@@ -95,11 +146,19 @@ def _get_datetime(instant: _Instant) -&gt;datetime.datetime:</span>
<span class="w"> </span>    :return: a datetime
<span class="w"> </span>    :rtype: datetime
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _ensure_datetime_tzinfo(dt: datetime.datetime, tzinfo: (datetime.tzinfo |</span>
<span class="gd">-    None)=None) -&gt;datetime.datetime:</span>
<span class="gi">+    if instant is None:</span>
<span class="gi">+        return datetime.datetime.now(UTC).replace(tzinfo=None)</span>
<span class="gi">+    elif isinstance(instant, (int, float)):</span>
<span class="gi">+        return datetime.datetime.fromtimestamp(instant, UTC).replace(tzinfo=None)</span>
<span class="gi">+    elif isinstance(instant, datetime.time):</span>
<span class="gi">+        return datetime.datetime.combine(datetime.date.today(), instant)</span>
<span class="gi">+    elif isinstance(instant, datetime.date) and not isinstance(instant, datetime.datetime):</span>
<span class="gi">+        return datetime.datetime.combine(instant, datetime.time())</span>
<span class="gi">+    # TODO (3.x): Add an assertion/type check for this fallthrough branch:</span>
<span class="gi">+    return instant</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ensure_datetime_tzinfo(dt: datetime.datetime, tzinfo: datetime.tzinfo | None = None) -&gt; datetime.datetime:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Ensure the datetime passed has an attached tzinfo.

<span class="gu">@@ -120,11 +179,19 @@ def _ensure_datetime_tzinfo(dt: datetime.datetime, tzinfo: (datetime.tzinfo |</span>
<span class="w"> </span>    :return: datetime with tzinfo
<span class="w"> </span>    :rtype: datetime
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_time(time: (datetime.time | datetime.datetime | None), tzinfo: (</span>
<span class="gd">-    datetime.tzinfo | None)=None) -&gt;datetime.time:</span>
<span class="gi">+    if dt.tzinfo is None:</span>
<span class="gi">+        dt = dt.replace(tzinfo=UTC)</span>
<span class="gi">+    if tzinfo is not None:</span>
<span class="gi">+        dt = dt.astimezone(get_timezone(tzinfo))</span>
<span class="gi">+        if hasattr(tzinfo, &#39;normalize&#39;):  # pytz</span>
<span class="gi">+            dt = tzinfo.normalize(dt)</span>
<span class="gi">+    return dt</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_time(</span>
<span class="gi">+    time: datetime.time | datetime.datetime | None,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None = None,</span>
<span class="gi">+) -&gt; datetime.time:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get a timezoned time from a given instant.

<span class="gu">@@ -133,10 +200,26 @@ def _get_time(time: (datetime.time | datetime.datetime | None), tzinfo: (</span>
<span class="w"> </span>    :param time: time, datetime or None
<span class="w"> </span>    :rtype: time
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_timezone(zone: (str | datetime.tzinfo | None)=None) -&gt;datetime.tzinfo:</span>
<span class="gi">+    if time is None:</span>
<span class="gi">+        time = datetime.datetime.now(UTC)</span>
<span class="gi">+    elif isinstance(time, (int, float)):</span>
<span class="gi">+        time = datetime.datetime.fromtimestamp(time, UTC)</span>
<span class="gi">+</span>
<span class="gi">+    if time.tzinfo is None:</span>
<span class="gi">+        time = time.replace(tzinfo=UTC)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(time, datetime.datetime):</span>
<span class="gi">+        if tzinfo is not None:</span>
<span class="gi">+            time = time.astimezone(tzinfo)</span>
<span class="gi">+            if hasattr(tzinfo, &#39;normalize&#39;):  # pytz</span>
<span class="gi">+                time = tzinfo.normalize(time)</span>
<span class="gi">+        time = time.timetz()</span>
<span class="gi">+    elif tzinfo is not None:</span>
<span class="gi">+        time = time.replace(tzinfo=tzinfo)</span>
<span class="gi">+    return time</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_timezone(zone: str | datetime.tzinfo | None = None) -&gt; datetime.tzinfo:</span>
<span class="w"> </span>    &quot;&quot;&quot;Looks up a timezone by name and returns it.  The timezone object
<span class="w"> </span>    returned comes from ``pytz`` or ``zoneinfo``, whichever is available.
<span class="w"> </span>    It corresponds to the `tzinfo` interface and can be used with all of
<span class="gu">@@ -148,12 +231,28 @@ def get_timezone(zone: (str | datetime.tzinfo | None)=None) -&gt;datetime.tzinfo:</span>
<span class="w"> </span>    :param zone: the name of the timezone to look up.  If a timezone object
<span class="w"> </span>                 itself is passed in, it&#39;s returned unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_period_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=&#39;wide&#39;,</span>
<span class="gd">-    context: _Context=&#39;stand-alone&#39;, locale: (Locale | str | None)=LC_TIME</span>
<span class="gd">-    ) -&gt;LocaleDataDict:</span>
<span class="gi">+    if zone is None:</span>
<span class="gi">+        return LOCALTZ</span>
<span class="gi">+    if not isinstance(zone, str):</span>
<span class="gi">+        return zone</span>
<span class="gi">+</span>
<span class="gi">+    if pytz:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return pytz.timezone(zone)</span>
<span class="gi">+        except pytz.UnknownTimeZoneError as e:</span>
<span class="gi">+            exc = e</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert zoneinfo</span>
<span class="gi">+        try:</span>
<span class="gi">+            return zoneinfo.ZoneInfo(zone)</span>
<span class="gi">+        except zoneinfo.ZoneInfoNotFoundError as e:</span>
<span class="gi">+            exc = e</span>
<span class="gi">+</span>
<span class="gi">+    raise LookupError(f&quot;Unknown timezone {zone}&quot;) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_period_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;] = &#39;wide&#39;,</span>
<span class="gi">+                     context: _Context = &#39;stand-alone&#39;, locale: Locale | str | None = LC_TIME) -&gt; LocaleDataDict:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the names for day periods (AM/PM) used by the locale.

<span class="w"> </span>    &gt;&gt;&gt; get_period_names(locale=&#39;en_US&#39;)[&#39;am&#39;]
<span class="gu">@@ -163,12 +262,11 @@ def get_period_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=&#39;wide&#39;,</span>
<span class="w"> </span>    :param context: the context, either &quot;format&quot; or &quot;stand-alone&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).day_periods[context][width]</span>


<span class="gd">-def get_day_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;short&#39;, &#39;wide&#39;]=</span>
<span class="gd">-    &#39;wide&#39;, context: _Context=&#39;format&#39;, locale: (Locale | str | None)=LC_TIME</span>
<span class="gd">-    ) -&gt;LocaleDataDict:</span>
<span class="gi">+def get_day_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;short&#39;, &#39;wide&#39;] = &#39;wide&#39;,</span>
<span class="gi">+                  context: _Context = &#39;format&#39;, locale: Locale | str | None = LC_TIME) -&gt; LocaleDataDict:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the day names used by the locale for the specified format.

<span class="w"> </span>    &gt;&gt;&gt; get_day_names(&#39;wide&#39;, locale=&#39;en_US&#39;)[1]
<span class="gu">@@ -184,12 +282,11 @@ def get_day_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;short&#39;, &#39;wide&#39;]=</span>
<span class="w"> </span>    :param context: the context, either &quot;format&quot; or &quot;stand-alone&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).days[context][width]</span>


<span class="gd">-def get_month_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=&#39;wide&#39;,</span>
<span class="gd">-    context: _Context=&#39;format&#39;, locale: (Locale | str | None)=LC_TIME</span>
<span class="gd">-    ) -&gt;LocaleDataDict:</span>
<span class="gi">+def get_month_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;] = &#39;wide&#39;,</span>
<span class="gi">+                    context: _Context = &#39;format&#39;, locale: Locale | str | None = LC_TIME) -&gt; LocaleDataDict:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the month names used by the locale for the specified format.

<span class="w"> </span>    &gt;&gt;&gt; get_month_names(&#39;wide&#39;, locale=&#39;en_US&#39;)[1]
<span class="gu">@@ -203,12 +300,11 @@ def get_month_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=&#39;wide&#39;,</span>
<span class="w"> </span>    :param context: the context, either &quot;format&quot; or &quot;stand-alone&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).months[context][width]</span>


<span class="gd">-def get_quarter_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=</span>
<span class="gd">-    &#39;wide&#39;, context: _Context=&#39;format&#39;, locale: (Locale | str | None)=LC_TIME</span>
<span class="gd">-    ) -&gt;LocaleDataDict:</span>
<span class="gi">+def get_quarter_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;] = &#39;wide&#39;,</span>
<span class="gi">+                      context: _Context = &#39;format&#39;, locale: Locale | str | None = LC_TIME) -&gt; LocaleDataDict:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the quarter names used by the locale for the specified format.

<span class="w"> </span>    &gt;&gt;&gt; get_quarter_names(&#39;wide&#39;, locale=&#39;en_US&#39;)[1]
<span class="gu">@@ -222,11 +318,11 @@ def get_quarter_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=</span>
<span class="w"> </span>    :param context: the context, either &quot;format&quot; or &quot;stand-alone&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).quarters[context][width]</span>


<span class="gd">-def get_era_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=&#39;wide&#39;,</span>
<span class="gd">-    locale: (Locale | str | None)=LC_TIME) -&gt;LocaleDataDict:</span>
<span class="gi">+def get_era_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;] = &#39;wide&#39;,</span>
<span class="gi">+                  locale: Locale | str | None = LC_TIME) -&gt; LocaleDataDict:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the era names used by the locale for the specified format.

<span class="w"> </span>    &gt;&gt;&gt; get_era_names(&#39;wide&#39;, locale=&#39;en_US&#39;)[1]
<span class="gu">@@ -237,11 +333,10 @@ def get_era_names(width: Literal[&#39;abbreviated&#39;, &#39;narrow&#39;, &#39;wide&#39;]=&#39;wide&#39;,</span>
<span class="w"> </span>    :param width: the width to use, either &quot;wide&quot;, &quot;abbreviated&quot;, or &quot;narrow&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).eras[width]</span>


<span class="gd">-def get_date_format(format: _PredefinedTimeFormat=&#39;medium&#39;, locale: (Locale |</span>
<span class="gd">-    str | None)=LC_TIME) -&gt;DateTimePattern:</span>
<span class="gi">+def get_date_format(format: _PredefinedTimeFormat = &#39;medium&#39;, locale: Locale | str | None = LC_TIME) -&gt; DateTimePattern:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the date formatting patterns used by the locale for the specified
<span class="w"> </span>    format.

<span class="gu">@@ -254,11 +349,10 @@ def get_date_format(format: _PredefinedTimeFormat=&#39;medium&#39;, locale: (Locale |</span>
<span class="w"> </span>                   &quot;short&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).date_formats[format]</span>


<span class="gd">-def get_datetime_format(format: _PredefinedTimeFormat=&#39;medium&#39;, locale: (</span>
<span class="gd">-    Locale | str | None)=LC_TIME) -&gt;DateTimePattern:</span>
<span class="gi">+def get_datetime_format(format: _PredefinedTimeFormat = &#39;medium&#39;, locale: Locale | str | None = LC_TIME) -&gt; DateTimePattern:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the datetime formatting patterns used by the locale for the
<span class="w"> </span>    specified format.

<span class="gu">@@ -269,16 +363,18 @@ def get_datetime_format(format: _PredefinedTimeFormat=&#39;medium&#39;, locale: (</span>
<span class="w"> </span>                   &quot;short&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    patterns = Locale.parse(locale).datetime_formats</span>
<span class="gi">+    if format not in patterns:</span>
<span class="gi">+        format = None</span>
<span class="gi">+    return patterns[format]</span>


<span class="gd">-def get_time_format(format: _PredefinedTimeFormat=&#39;medium&#39;, locale: (Locale |</span>
<span class="gd">-    str | None)=LC_TIME) -&gt;DateTimePattern:</span>
<span class="gi">+def get_time_format(format: _PredefinedTimeFormat = &#39;medium&#39;, locale: Locale | str | None = LC_TIME) -&gt; DateTimePattern:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the time formatting patterns used by the locale for the specified
<span class="w"> </span>    format.

<span class="w"> </span>    &gt;&gt;&gt; get_time_format(locale=&#39;en_US&#39;)
<span class="gd">-    &lt;DateTimePattern u&#39;h:mm:ssa&#39;&gt;</span>
<span class="gi">+    &lt;DateTimePattern u&#39;h:mm:ss\u202fa&#39;&gt;</span>
<span class="w"> </span>    &gt;&gt;&gt; get_time_format(&#39;full&#39;, locale=&#39;de_DE&#39;)
<span class="w"> </span>    &lt;DateTimePattern u&#39;HH:mm:ss zzzz&#39;&gt;

<span class="gu">@@ -286,12 +382,15 @@ def get_time_format(format: _PredefinedTimeFormat=&#39;medium&#39;, locale: (Locale |</span>
<span class="w"> </span>                   &quot;short&quot;
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).time_formats[format]</span>


<span class="gd">-def get_timezone_gmt(datetime: _Instant=None, width: Literal[&#39;long&#39;,</span>
<span class="gd">-    &#39;short&#39;, &#39;iso8601&#39;, &#39;iso8601_short&#39;]=&#39;long&#39;, locale: (Locale | str |</span>
<span class="gd">-    None)=LC_TIME, return_z: bool=False) -&gt;str:</span>
<span class="gi">+def get_timezone_gmt(</span>
<span class="gi">+    datetime: _Instant = None,</span>
<span class="gi">+    width: Literal[&#39;long&#39;, &#39;short&#39;, &#39;iso8601&#39;, &#39;iso8601_short&#39;] = &#39;long&#39;,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+    return_z: bool = False,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the timezone associated with the given `datetime` object formatted
<span class="w"> </span>    as string indicating the offset from GMT.

<span class="gu">@@ -327,11 +426,30 @@ def get_timezone_gmt(datetime: _Instant=None, width: Literal[&#39;long&#39;,</span>
<span class="w"> </span>    :param return_z: True or False; Function returns indicator &quot;Z&quot;
<span class="w"> </span>                     when local time offset is 0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_timezone_location(dt_or_tzinfo: _DtOrTzinfo=None, locale: (Locale |</span>
<span class="gd">-    str | None)=LC_TIME, return_city: bool=False) -&gt;str:</span>
<span class="gi">+    datetime = _ensure_datetime_tzinfo(_get_datetime(datetime))</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    offset = datetime.tzinfo.utcoffset(datetime)</span>
<span class="gi">+    seconds = offset.days * 24 * 60 * 60 + offset.seconds</span>
<span class="gi">+    hours, seconds = divmod(seconds, 3600)</span>
<span class="gi">+    if return_z and hours == 0 and seconds == 0:</span>
<span class="gi">+        return &#39;Z&#39;</span>
<span class="gi">+    elif seconds == 0 and width == &#39;iso8601_short&#39;:</span>
<span class="gi">+        return &#39;%+03d&#39; % hours</span>
<span class="gi">+    elif width == &#39;short&#39; or width == &#39;iso8601_short&#39;:</span>
<span class="gi">+        pattern = &#39;%+03d%02d&#39;</span>
<span class="gi">+    elif width == &#39;iso8601&#39;:</span>
<span class="gi">+        pattern = &#39;%+03d:%02d&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        pattern = locale.zone_formats[&#39;gmt&#39;] % &#39;%+03d:%02d&#39;</span>
<span class="gi">+    return pattern % (hours, seconds // 60)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_timezone_location(</span>
<span class="gi">+    dt_or_tzinfo: _DtOrTzinfo = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+    return_city: bool = False,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a representation of the given timezone using &quot;location format&quot;.

<span class="w"> </span>    The result depends on both the local display name of the country and the
<span class="gu">@@ -366,14 +484,56 @@ def get_timezone_location(dt_or_tzinfo: _DtOrTzinfo=None, locale: (Locale |</span>
<span class="w"> </span>    :return: the localized timezone name using location format

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_timezone_name(dt_or_tzinfo: _DtOrTzinfo=None, width: Literal[&#39;long&#39;,</span>
<span class="gd">-    &#39;short&#39;]=&#39;long&#39;, uncommon: bool=False, locale: (Locale | str | None)=</span>
<span class="gd">-    LC_TIME, zone_variant: (Literal[&#39;generic&#39;, &#39;daylight&#39;, &#39;standard&#39;] |</span>
<span class="gd">-    None)=None, return_zone: bool=False) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Return the localized display name for the given timezone. The timezone</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    zone = _get_tz_name(dt_or_tzinfo)</span>
<span class="gi">+</span>
<span class="gi">+    # Get the canonical time-zone code</span>
<span class="gi">+    zone = get_global(&#39;zone_aliases&#39;).get(zone, zone)</span>
<span class="gi">+</span>
<span class="gi">+    info = locale.time_zones.get(zone, {})</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise, if there is only one timezone for the country, return the</span>
<span class="gi">+    # localized country name</span>
<span class="gi">+    region_format = locale.zone_formats[&#39;region&#39;]</span>
<span class="gi">+    territory = get_global(&#39;zone_territories&#39;).get(zone)</span>
<span class="gi">+    if territory not in locale.territories:</span>
<span class="gi">+        territory = &#39;ZZ&#39;  # invalid/unknown</span>
<span class="gi">+    territory_name = locale.territories[territory]</span>
<span class="gi">+    if not return_city and territory and len(get_global(&#39;territory_zones&#39;).get(territory, [])) == 1:</span>
<span class="gi">+        return region_format % territory_name</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise, include the city in the output</span>
<span class="gi">+    fallback_format = locale.zone_formats[&#39;fallback&#39;]</span>
<span class="gi">+    if &#39;city&#39; in info:</span>
<span class="gi">+        city_name = info[&#39;city&#39;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        metazone = get_global(&#39;meta_zones&#39;).get(zone)</span>
<span class="gi">+        metazone_info = locale.meta_zones.get(metazone, {})</span>
<span class="gi">+        if &#39;city&#39; in metazone_info:</span>
<span class="gi">+            city_name = metazone_info[&#39;city&#39;]</span>
<span class="gi">+        elif &#39;/&#39; in zone:</span>
<span class="gi">+            city_name = zone.split(&#39;/&#39;, 1)[1].replace(&#39;_&#39;, &#39; &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            city_name = zone.replace(&#39;_&#39;, &#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if return_city:</span>
<span class="gi">+        return city_name</span>
<span class="gi">+    return region_format % (fallback_format % {</span>
<span class="gi">+        &#39;0&#39;: city_name,</span>
<span class="gi">+        &#39;1&#39;: territory_name,</span>
<span class="gi">+    })</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_timezone_name(</span>
<span class="gi">+    dt_or_tzinfo: _DtOrTzinfo = None,</span>
<span class="gi">+    width: Literal[&#39;long&#39;, &#39;short&#39;] = &#39;long&#39;,</span>
<span class="gi">+    uncommon: bool = False,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+    zone_variant: Literal[&#39;generic&#39;, &#39;daylight&#39;, &#39;standard&#39;] | None = None,</span>
<span class="gi">+    return_zone: bool = False,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Return the localized display name for the given timezone. The timezone</span>
<span class="w"> </span>    may be specified using a ``datetime`` or `tzinfo` object.

<span class="w"> </span>    &gt;&gt;&gt; from datetime import time
<span class="gu">@@ -402,9 +562,9 @@ def get_timezone_name(dt_or_tzinfo: _DtOrTzinfo=None, width: Literal[&#39;long&#39;,</span>

<span class="w"> </span>    &gt;&gt;&gt; tz = get_timezone(&#39;Europe/Berlin&#39;)
<span class="w"> </span>    &gt;&gt;&gt; get_timezone_name(tz, locale=&#39;de_DE&#39;)
<span class="gd">-    u&#39;Mitteleurop\\xe4ische Zeit&#39;</span>
<span class="gi">+    u&#39;Mitteleurop\xe4ische Zeit&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; get_timezone_name(tz, locale=&#39;pt_BR&#39;)
<span class="gd">-    u&#39;Hor\\xe1rio da Europa Central&#39;</span>
<span class="gi">+    u&#39;Hor\xe1rio da Europa Central&#39;</span>

<span class="w"> </span>    On the other hand, if the country uses multiple timezones, the city is also
<span class="w"> </span>    included in the representation:
<span class="gu">@@ -443,12 +603,55 @@ def get_timezone_name(dt_or_tzinfo: _DtOrTzinfo=None, width: Literal[&#39;long&#39;,</span>
<span class="w"> </span>    :param return_zone: True or False. If true then function
<span class="w"> </span>                        returns long time zone ID
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dt, tzinfo = _get_dt_and_tzinfo(dt_or_tzinfo)</span>
<span class="gi">+    locale = Locale.parse(locale)</span>

<span class="gi">+    zone = _get_tz_name(dt_or_tzinfo)</span>

<span class="gd">-def format_date(date: (datetime.date | None)=None, format: (</span>
<span class="gd">-    _PredefinedTimeFormat | str)=&#39;medium&#39;, locale: (Locale | str | None)=</span>
<span class="gd">-    LC_TIME) -&gt;str:</span>
<span class="gi">+    if zone_variant is None:</span>
<span class="gi">+        if dt is None:</span>
<span class="gi">+            zone_variant = &#39;generic&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            dst = tzinfo.dst(dt)</span>
<span class="gi">+            zone_variant = &quot;daylight&quot; if dst else &quot;standard&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        if zone_variant not in (&#39;generic&#39;, &#39;standard&#39;, &#39;daylight&#39;):</span>
<span class="gi">+            raise ValueError(&#39;Invalid zone variation&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Get the canonical time-zone code</span>
<span class="gi">+    zone = get_global(&#39;zone_aliases&#39;).get(zone, zone)</span>
<span class="gi">+    if return_zone:</span>
<span class="gi">+        return zone</span>
<span class="gi">+    info = locale.time_zones.get(zone, {})</span>
<span class="gi">+    # Try explicitly translated zone names first</span>
<span class="gi">+    if width in info and zone_variant in info[width]:</span>
<span class="gi">+        return info[width][zone_variant]</span>
<span class="gi">+</span>
<span class="gi">+    metazone = get_global(&#39;meta_zones&#39;).get(zone)</span>
<span class="gi">+    if metazone:</span>
<span class="gi">+        metazone_info = locale.meta_zones.get(metazone, {})</span>
<span class="gi">+        if width in metazone_info:</span>
<span class="gi">+            name = metazone_info[width].get(zone_variant)</span>
<span class="gi">+            if width == &#39;short&#39; and name == NO_INHERITANCE_MARKER:</span>
<span class="gi">+                # If the short form is marked no-inheritance,</span>
<span class="gi">+                # try to fall back to the long name instead.</span>
<span class="gi">+                name = metazone_info.get(&#39;long&#39;, {}).get(zone_variant)</span>
<span class="gi">+            if name:</span>
<span class="gi">+                return name</span>
<span class="gi">+</span>
<span class="gi">+    # If we have a concrete datetime, we assume that the result can&#39;t be</span>
<span class="gi">+    # independent of daylight savings time, so we return the GMT offset</span>
<span class="gi">+    if dt is not None:</span>
<span class="gi">+        return get_timezone_gmt(dt, width=width, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+    return get_timezone_location(dt_or_tzinfo, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_date(</span>
<span class="gi">+    date: datetime.date | None = None,</span>
<span class="gi">+    format: _PredefinedTimeFormat | str = &#39;medium&#39;,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a date formatted according to the given pattern.

<span class="w"> </span>    &gt;&gt;&gt; from datetime import date
<span class="gu">@@ -470,18 +673,30 @@ def format_date(date: (datetime.date | None)=None, format: (</span>
<span class="w"> </span>                   date/time pattern
<span class="w"> </span>    :param locale: a `Locale` object or a locale identifier
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_datetime(datetime: _Instant=None, format: (_PredefinedTimeFormat |</span>
<span class="gd">-    str)=&#39;medium&#39;, tzinfo: (datetime.tzinfo | None)=None, locale: (Locale |</span>
<span class="gd">-    str | None)=LC_TIME) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Return a date formatted according to the given pattern.</span>
<span class="gi">+    if date is None:</span>
<span class="gi">+        date = datetime.date.today()</span>
<span class="gi">+    elif isinstance(date, datetime.datetime):</span>
<span class="gi">+        date = date.date()</span>
<span class="gi">+</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if format in (&#39;full&#39;, &#39;long&#39;, &#39;medium&#39;, &#39;short&#39;):</span>
<span class="gi">+        format = get_date_format(format, locale=locale)</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+    return pattern.apply(date, locale)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_datetime(</span>
<span class="gi">+    datetime: _Instant = None,</span>
<span class="gi">+    format: _PredefinedTimeFormat | str = &#39;medium&#39;,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Return a date formatted according to the given pattern.</span>

<span class="w"> </span>    &gt;&gt;&gt; from datetime import datetime
<span class="w"> </span>    &gt;&gt;&gt; dt = datetime(2007, 4, 1, 15, 30)
<span class="w"> </span>    &gt;&gt;&gt; format_datetime(dt, locale=&#39;en_US&#39;)
<span class="gd">-    u&#39;Apr 1, 2007, 3:30:00\\u202fPM&#39;</span>
<span class="gi">+    u&#39;Apr 1, 2007, 3:30:00\u202fPM&#39;</span>

<span class="w"> </span>    For any pattern requiring the display of the timezone:

<span class="gu">@@ -499,18 +714,30 @@ def format_datetime(datetime: _Instant=None, format: (_PredefinedTimeFormat |</span>
<span class="w"> </span>    :param tzinfo: the timezone to apply to the time for display
<span class="w"> </span>    :param locale: a `Locale` object or a locale identifier
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_time(time: (datetime.time | datetime.datetime | float | None)=</span>
<span class="gd">-    None, format: (_PredefinedTimeFormat | str)=&#39;medium&#39;, tzinfo: (datetime</span>
<span class="gd">-    .tzinfo | None)=None, locale: (Locale | str | None)=LC_TIME) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Return a time formatted according to the given pattern.</span>
<span class="gi">+    datetime = _ensure_datetime_tzinfo(_get_datetime(datetime), tzinfo)</span>
<span class="gi">+</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if format in (&#39;full&#39;, &#39;long&#39;, &#39;medium&#39;, &#39;short&#39;):</span>
<span class="gi">+        return get_datetime_format(format, locale=locale) \</span>
<span class="gi">+            .replace(&quot;&#39;&quot;, &quot;&quot;) \</span>
<span class="gi">+            .replace(&#39;{0}&#39;, format_time(datetime, format, tzinfo=None,</span>
<span class="gi">+                                        locale=locale)) \</span>
<span class="gi">+            .replace(&#39;{1}&#39;, format_date(datetime, format, locale=locale))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return parse_pattern(format).apply(datetime, locale)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_time(</span>
<span class="gi">+    time: datetime.time | datetime.datetime | float | None = None,</span>
<span class="gi">+    format: _PredefinedTimeFormat | str = &#39;medium&#39;,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None = None, locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Return a time formatted according to the given pattern.</span>

<span class="w"> </span>    &gt;&gt;&gt; from datetime import datetime, time
<span class="w"> </span>    &gt;&gt;&gt; t = time(15, 30)
<span class="w"> </span>    &gt;&gt;&gt; format_time(t, locale=&#39;en_US&#39;)
<span class="gd">-    u&#39;3:30:00\\u202fPM&#39;</span>
<span class="gi">+    u&#39;3:30:00\u202fPM&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; format_time(t, format=&#39;short&#39;, locale=&#39;de_DE&#39;)
<span class="w"> </span>    u&#39;15:30&#39;

<span class="gu">@@ -548,10 +775,10 @@ def format_time(time: (datetime.time | datetime.datetime | float | None)=</span>
<span class="w"> </span>    &gt;&gt;&gt; t = time(15, 30)
<span class="w"> </span>    &gt;&gt;&gt; format_time(t, format=&#39;full&#39;, tzinfo=get_timezone(&#39;Europe/Paris&#39;),
<span class="w"> </span>    ...             locale=&#39;fr_FR&#39;)  # doctest: +SKIP
<span class="gd">-    u&#39;15:30:00 heure normale d\\u2019Europe centrale&#39;</span>
<span class="gi">+    u&#39;15:30:00 heure normale d\u2019Europe centrale&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; format_time(t, format=&#39;full&#39;, tzinfo=get_timezone(&#39;US/Eastern&#39;),
<span class="w"> </span>    ...             locale=&#39;en_US&#39;)  # doctest: +SKIP
<span class="gd">-    u&#39;3:30:00\\u202fPM Eastern Standard Time&#39;</span>
<span class="gi">+    u&#39;3:30:00\u202fPM Eastern Standard Time&#39;</span>

<span class="w"> </span>    :param time: the ``time`` or ``datetime`` object; if `None`, the current
<span class="w"> </span>                 time in UTC is used
<span class="gu">@@ -560,13 +787,27 @@ def format_time(time: (datetime.time | datetime.datetime | float | None)=</span>
<span class="w"> </span>    :param tzinfo: the time-zone to apply to the time for display
<span class="w"> </span>    :param locale: a `Locale` object or a locale identifier
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    # get reference date for if we need to find the right timezone variant</span>
<span class="gi">+    # in the pattern</span>
<span class="gi">+    ref_date = time.date() if isinstance(time, datetime.datetime) else None</span>
<span class="gi">+</span>
<span class="gi">+    time = _get_time(time, tzinfo)</span>
<span class="gi">+</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if format in (&#39;full&#39;, &#39;long&#39;, &#39;medium&#39;, &#39;short&#39;):</span>
<span class="gi">+        format = get_time_format(format, locale=locale)</span>
<span class="gi">+    return parse_pattern(format).apply(time, locale, reference_date=ref_date)</span>

<span class="gd">-def format_skeleton(skeleton: str, datetime: _Instant=None, tzinfo: (</span>
<span class="gd">-    datetime.tzinfo | None)=None, fuzzy: bool=True, locale: (Locale | str |</span>
<span class="gd">-    None)=LC_TIME) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Return a time and/or date formatted according to the given pattern.</span>
<span class="gi">+</span>
<span class="gi">+def format_skeleton(</span>
<span class="gi">+    skeleton: str,</span>
<span class="gi">+    datetime: _Instant = None,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None = None,</span>
<span class="gi">+    fuzzy: bool = True,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Return a time and/or date formatted according to the given pattern.</span>

<span class="w"> </span>    The skeletons are defined in the CLDR data and provide more flexibility
<span class="w"> </span>    than the simple short/long/medium formats, but are a bit harder to use.
<span class="gu">@@ -597,19 +838,32 @@ def format_skeleton(skeleton: str, datetime: _Instant=None, tzinfo: (</span>
<span class="w"> </span>                  close enough to it.
<span class="w"> </span>    :param locale: a `Locale` object or a locale identifier
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-TIMEDELTA_UNITS: tuple[tuple[str, int], ...] = ((&#39;year&#39;, 3600 * 24 * 365),</span>
<span class="gd">-    (&#39;month&#39;, 3600 * 24 * 30), (&#39;week&#39;, 3600 * 24 * 7), (&#39;day&#39;, 3600 * 24),</span>
<span class="gd">-    (&#39;hour&#39;, 3600), (&#39;minute&#39;, 60), (&#39;second&#39;, 1))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_timedelta(delta: (datetime.timedelta | int), granularity:</span>
<span class="gd">-    Literal[&#39;year&#39;, &#39;month&#39;, &#39;week&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;]=</span>
<span class="gd">-    &#39;second&#39;, threshold: float=0.85, add_direction: bool=False, format:</span>
<span class="gd">-    Literal[&#39;narrow&#39;, &#39;short&#39;, &#39;medium&#39;, &#39;long&#39;]=&#39;long&#39;, locale: (Locale |</span>
<span class="gd">-    str | None)=LC_TIME) -&gt;str:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if fuzzy and skeleton not in locale.datetime_skeletons:</span>
<span class="gi">+        skeleton = match_skeleton(skeleton, locale.datetime_skeletons)</span>
<span class="gi">+    format = locale.datetime_skeletons[skeleton]</span>
<span class="gi">+    return format_datetime(datetime, format, tzinfo, locale)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+TIMEDELTA_UNITS: tuple[tuple[str, int], ...] = (</span>
<span class="gi">+    (&#39;year&#39;, 3600 * 24 * 365),</span>
<span class="gi">+    (&#39;month&#39;, 3600 * 24 * 30),</span>
<span class="gi">+    (&#39;week&#39;, 3600 * 24 * 7),</span>
<span class="gi">+    (&#39;day&#39;, 3600 * 24),</span>
<span class="gi">+    (&#39;hour&#39;, 3600),</span>
<span class="gi">+    (&#39;minute&#39;, 60),</span>
<span class="gi">+    (&#39;second&#39;, 1),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_timedelta(</span>
<span class="gi">+    delta: datetime.timedelta | int,</span>
<span class="gi">+    granularity: Literal[&#39;year&#39;, &#39;month&#39;, &#39;week&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;] = &#39;second&#39;,</span>
<span class="gi">+    threshold: float = .85,</span>
<span class="gi">+    add_direction: bool = False,</span>
<span class="gi">+    format: Literal[&#39;narrow&#39;, &#39;short&#39;, &#39;medium&#39;, &#39;long&#39;] = &#39;long&#39;,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a time delta according to the rules of the given locale.

<span class="w"> </span>    &gt;&gt;&gt; from datetime import timedelta
<span class="gu">@@ -665,27 +919,104 @@ def format_timedelta(delta: (datetime.timedelta | int), granularity:</span>
<span class="w"> </span>                   maintain compatibility)
<span class="w"> </span>    :param locale: a `Locale` object or a locale identifier
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_interval(start: _Instant, end: _Instant, skeleton: (str | None)=</span>
<span class="gd">-    None, tzinfo: (datetime.tzinfo | None)=None, fuzzy: bool=True, locale:</span>
<span class="gd">-    (Locale | str | None)=LC_TIME) -&gt;str:</span>
<span class="gi">+    if format not in (&#39;narrow&#39;, &#39;short&#39;, &#39;medium&#39;, &#39;long&#39;):</span>
<span class="gi">+        raise TypeError(&#39;Format must be one of &quot;narrow&quot;, &quot;short&quot; or &quot;long&quot;&#39;)</span>
<span class="gi">+    if format == &#39;medium&#39;:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;&quot;medium&quot; value for format param of format_timedelta&#39;</span>
<span class="gi">+            &#39; is deprecated. Use &quot;long&quot; instead&#39;,</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        format = &#39;long&#39;</span>
<span class="gi">+    if isinstance(delta, datetime.timedelta):</span>
<span class="gi">+        seconds = int((delta.days * 86400) + delta.seconds)</span>
<span class="gi">+    else:</span>
<span class="gi">+        seconds = delta</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_patterns(a_unit):</span>
<span class="gi">+        if add_direction:</span>
<span class="gi">+            unit_rel_patterns = locale._data[&#39;date_fields&#39;][a_unit]</span>
<span class="gi">+            if seconds &gt;= 0:</span>
<span class="gi">+                yield unit_rel_patterns[&#39;future&#39;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield unit_rel_patterns[&#39;past&#39;]</span>
<span class="gi">+        a_unit = f&quot;duration-{a_unit}&quot;</span>
<span class="gi">+        yield locale._data[&#39;unit_patterns&#39;].get(a_unit, {}).get(format)</span>
<span class="gi">+</span>
<span class="gi">+    for unit, secs_per_unit in TIMEDELTA_UNITS:</span>
<span class="gi">+        value = abs(seconds) / secs_per_unit</span>
<span class="gi">+        if value &gt;= threshold or unit == granularity:</span>
<span class="gi">+            if unit == granularity and value &gt; 0:</span>
<span class="gi">+                value = max(1, value)</span>
<span class="gi">+            value = int(round(value))</span>
<span class="gi">+            plural_form = locale.plural_form(value)</span>
<span class="gi">+            pattern = None</span>
<span class="gi">+            for patterns in _iter_patterns(unit):</span>
<span class="gi">+                if patterns is not None:</span>
<span class="gi">+                    pattern = patterns.get(plural_form) or patterns.get(&#39;other&#39;)</span>
<span class="gi">+                    break</span>
<span class="gi">+            # This really should not happen</span>
<span class="gi">+            if pattern is None:</span>
<span class="gi">+                return &#39;&#39;</span>
<span class="gi">+            return pattern.replace(&#39;{0}&#39;, str(value))</span>
<span class="gi">+</span>
<span class="gi">+    return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_fallback_interval(</span>
<span class="gi">+    start: _Instant,</span>
<span class="gi">+    end: _Instant,</span>
<span class="gi">+    skeleton: str | None,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    if skeleton in locale.datetime_skeletons:  # Use the given skeleton</span>
<span class="gi">+        format = lambda dt: format_skeleton(skeleton, dt, tzinfo, locale=locale)</span>
<span class="gi">+    elif all((isinstance(d, datetime.date) and not isinstance(d, datetime.datetime)) for d in (start, end)):  # Both are just dates</span>
<span class="gi">+        format = lambda dt: format_date(dt, locale=locale)</span>
<span class="gi">+    elif all((isinstance(d, datetime.time) and not isinstance(d, datetime.date)) for d in (start, end)):  # Both are times</span>
<span class="gi">+        format = lambda dt: format_time(dt, tzinfo=tzinfo, locale=locale)</span>
<span class="gi">+    else:</span>
<span class="gi">+        format = lambda dt: format_datetime(dt, tzinfo=tzinfo, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+    formatted_start = format(start)</span>
<span class="gi">+    formatted_end = format(end)</span>
<span class="gi">+</span>
<span class="gi">+    if formatted_start == formatted_end:</span>
<span class="gi">+        return format(start)</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        locale.interval_formats.get(None, &quot;{0}-{1}&quot;).</span>
<span class="gi">+        replace(&quot;{0}&quot;, formatted_start).</span>
<span class="gi">+        replace(&quot;{1}&quot;, formatted_end)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_interval(</span>
<span class="gi">+    start: _Instant,</span>
<span class="gi">+    end: _Instant,</span>
<span class="gi">+    skeleton: str | None = None,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None = None,</span>
<span class="gi">+    fuzzy: bool = True,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Format an interval between two instants according to the locale&#39;s rules.

<span class="w"> </span>    &gt;&gt;&gt; from datetime import date, time
<span class="w"> </span>    &gt;&gt;&gt; format_interval(date(2016, 1, 15), date(2016, 1, 17), &quot;yMd&quot;, locale=&quot;fi&quot;)
<span class="gd">-    u&#39;15.17.1.2016&#39;</span>
<span class="gi">+    u&#39;15.\u201317.1.2016&#39;</span>

<span class="w"> </span>    &gt;&gt;&gt; format_interval(time(12, 12), time(16, 16), &quot;Hm&quot;, locale=&quot;en_GB&quot;)
<span class="gd">-    &#39;12:1216:16&#39;</span>
<span class="gi">+    &#39;12:12\u201316:16&#39;</span>

<span class="w"> </span>    &gt;&gt;&gt; format_interval(time(5, 12), time(16, 16), &quot;hm&quot;, locale=&quot;en_US&quot;)
<span class="gd">-    &#39;5:12AM4:16PM&#39;</span>
<span class="gi">+    &#39;5:12\u202fAM\u2009\u20094:16\u202fPM&#39;</span>

<span class="w"> </span>    &gt;&gt;&gt; format_interval(time(16, 18), time(16, 24), &quot;Hm&quot;, locale=&quot;it&quot;)
<span class="gd">-    &#39;16:1816:24&#39;</span>
<span class="gi">+    &#39;16:18\u201316:24&#39;</span>

<span class="w"> </span>    If the start instant equals the end instant, the interval is formatted like the instant.

<span class="gu">@@ -695,13 +1026,13 @@ def format_interval(start: _Instant, end: _Instant, skeleton: (str | None)=</span>
<span class="w"> </span>    Unknown skeletons fall back to &quot;default&quot; formatting.

<span class="w"> </span>    &gt;&gt;&gt; format_interval(date(2015, 1, 1), date(2017, 1, 1), &quot;wzq&quot;, locale=&quot;ja&quot;)
<span class="gd">-    &#39;2015/01/012017/01/01&#39;</span>
<span class="gi">+    &#39;2015/01/01\uff5e2017/01/01&#39;</span>

<span class="w"> </span>    &gt;&gt;&gt; format_interval(time(16, 18), time(16, 24), &quot;xxx&quot;, locale=&quot;ja&quot;)
<span class="gd">-    &#39;16:18:0016:24:00&#39;</span>
<span class="gi">+    &#39;16:18:00\uff5e16:24:00&#39;</span>

<span class="w"> </span>    &gt;&gt;&gt; format_interval(date(2016, 1, 15), date(2016, 1, 17), &quot;xxx&quot;, locale=&quot;de&quot;)
<span class="gd">-    &#39;15.01.201617.01.2016&#39;</span>
<span class="gi">+    &#39;15.01.2016\u2009\u200917.01.2016&#39;</span>

<span class="w"> </span>    :param start: First instant (datetime/date/time)
<span class="w"> </span>    :param end: Second instant (datetime/date/time)
<span class="gu">@@ -712,12 +1043,68 @@ def format_interval(start: _Instant, end: _Instant, skeleton: (str | None)=</span>
<span class="w"> </span>    :param locale: A locale object or identifier.
<span class="w"> </span>    :return: Formatted interval
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    # NB: The quote comments below are from the algorithm description in</span>
<span class="gi">+    #     https://www.unicode.org/reports/tr35/tr35-dates.html#intervalFormats</span>
<span class="gi">+</span>
<span class="gi">+    # &gt; Look for the intervalFormatItem element that matches the &quot;skeleton&quot;,</span>
<span class="gi">+    # &gt; starting in the current locale and then following the locale fallback</span>
<span class="gi">+    # &gt; chain up to, but not including root.</span>
<span class="gi">+</span>
<span class="gi">+    interval_formats = locale.interval_formats</span>
<span class="gi">+</span>
<span class="gi">+    if skeleton not in interval_formats or not skeleton:</span>
<span class="gi">+        # &gt; If no match was found from the previous step, check what the closest</span>
<span class="gi">+        # &gt; match is in the fallback locale chain, as in availableFormats. That</span>
<span class="gi">+        # &gt; is, this allows for adjusting the string value field&#39;s width,</span>
<span class="gi">+        # &gt; including adjusting between &quot;MMM&quot; and &quot;MMMM&quot;, and using different</span>
<span class="gi">+        # &gt; variants of the same field, such as &#39;v&#39; and &#39;z&#39;.</span>
<span class="gi">+        if skeleton and fuzzy:</span>
<span class="gi">+            skeleton = match_skeleton(skeleton, interval_formats)</span>
<span class="gi">+        else:</span>
<span class="gi">+            skeleton = None</span>
<span class="gi">+        if not skeleton:  # Still no match whatsoever?</span>
<span class="gi">+            # &gt; Otherwise, format the start and end datetime using the fallback pattern.</span>
<span class="gi">+            return _format_fallback_interval(start, end, skeleton, tzinfo, locale)</span>
<span class="gi">+</span>
<span class="gi">+    skel_formats = interval_formats[skeleton]</span>
<span class="gi">+</span>
<span class="gi">+    if start == end:</span>
<span class="gi">+        return format_skeleton(skeleton, start, tzinfo, fuzzy=fuzzy, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+    start = _ensure_datetime_tzinfo(_get_datetime(start), tzinfo=tzinfo)</span>
<span class="gi">+    end = _ensure_datetime_tzinfo(_get_datetime(end), tzinfo=tzinfo)</span>

<span class="gi">+    start_fmt = DateTimeFormat(start, locale=locale)</span>
<span class="gi">+    end_fmt = DateTimeFormat(end, locale=locale)</span>

<span class="gd">-def get_period_id(time: _Instant, tzinfo: (datetime.tzinfo | None)=None,</span>
<span class="gd">-    type: (Literal[&#39;selection&#39;] | None)=None, locale: (Locale | str | None)</span>
<span class="gd">-    =LC_TIME) -&gt;str:</span>
<span class="gi">+    # &gt; If a match is found from previous steps, compute the calendar field</span>
<span class="gi">+    # &gt; with the greatest difference between start and end datetime. If there</span>
<span class="gi">+    # &gt; is no difference among any of the fields in the pattern, format as a</span>
<span class="gi">+    # &gt; single date using availableFormats, and return.</span>
<span class="gi">+</span>
<span class="gi">+    for field in PATTERN_CHAR_ORDER:  # These are in largest-to-smallest order</span>
<span class="gi">+        if field in skel_formats and start_fmt.extract(field) != end_fmt.extract(field):</span>
<span class="gi">+            # &gt; If there is a match, use the pieces of the corresponding pattern to</span>
<span class="gi">+            # &gt; format the start and end datetime, as above.</span>
<span class="gi">+            return &quot;&quot;.join(</span>
<span class="gi">+                parse_pattern(pattern).apply(instant, locale)</span>
<span class="gi">+                for pattern, instant</span>
<span class="gi">+                in zip(skel_formats[field], (start, end))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # &gt; Otherwise, format the start and end datetime using the fallback pattern.</span>
<span class="gi">+</span>
<span class="gi">+    return _format_fallback_interval(start, end, skeleton, tzinfo, locale)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_period_id(</span>
<span class="gi">+    time: _Instant,</span>
<span class="gi">+    tzinfo: datetime.tzinfo | None = None,</span>
<span class="gi">+    type: Literal[&#39;selection&#39;] | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the day period ID for a given time.

<span class="gu">@@ -741,15 +1128,62 @@ def get_period_id(time: _Instant, tzinfo: (datetime.tzinfo | None)=None,</span>
<span class="w"> </span>    :param locale: the `Locale` object, or a locale string
<span class="w"> </span>    :return: period ID. Something is always returned -- even if it&#39;s just &quot;am&quot; or &quot;pm&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    time = _get_time(time, tzinfo)</span>
<span class="gi">+    seconds_past_midnight = int(time.hour * 60 * 60 + time.minute * 60 + time.second)</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    # The LDML rules state that the rules may not overlap, so iterating in arbitrary</span>
<span class="gi">+    # order should be alright, though `at` periods should be preferred.</span>
<span class="gi">+    rulesets = locale.day_period_rules.get(type, {}).items()</span>
<span class="gi">+</span>
<span class="gi">+    for rule_id, rules in rulesets:</span>
<span class="gi">+        for rule in rules:</span>
<span class="gi">+            if &quot;at&quot; in rule and rule[&quot;at&quot;] == seconds_past_midnight:</span>
<span class="gi">+                return rule_id</span>
<span class="gi">+</span>
<span class="gi">+    for rule_id, rules in rulesets:</span>
<span class="gi">+        for rule in rules:</span>
<span class="gi">+            if &quot;from&quot; in rule and &quot;before&quot; in rule:</span>
<span class="gi">+                if rule[&quot;from&quot;] &lt; rule[&quot;before&quot;]:</span>
<span class="gi">+                    if rule[&quot;from&quot;] &lt;= seconds_past_midnight &lt; rule[&quot;before&quot;]:</span>
<span class="gi">+                        return rule_id</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # e.g. from=&quot;21:00&quot; before=&quot;06:00&quot;</span>
<span class="gi">+                    if rule[&quot;from&quot;] &lt;= seconds_past_midnight &lt; 86400 or \</span>
<span class="gi">+                            0 &lt;= seconds_past_midnight &lt; rule[&quot;before&quot;]:</span>
<span class="gi">+                        return rule_id</span>
<span class="gi">+</span>
<span class="gi">+            start_ok = end_ok = False</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;from&quot; in rule and seconds_past_midnight &gt;= rule[&quot;from&quot;]:</span>
<span class="gi">+                start_ok = True</span>
<span class="gi">+            if &quot;to&quot; in rule and seconds_past_midnight &lt;= rule[&quot;to&quot;]:</span>
<span class="gi">+                # This rule type does not exist in the present CLDR data;</span>
<span class="gi">+                # excuse the lack of test coverage.</span>
<span class="gi">+                end_ok = True</span>
<span class="gi">+            if &quot;before&quot; in rule and seconds_past_midnight &lt; rule[&quot;before&quot;]:</span>
<span class="gi">+                end_ok = True</span>
<span class="gi">+            if &quot;after&quot; in rule:</span>
<span class="gi">+                raise NotImplementedError(&quot;&#39;after&#39; is deprecated as of CLDR 29.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if start_ok and end_ok:</span>
<span class="gi">+                return rule_id</span>
<span class="gi">+</span>
<span class="gi">+    if seconds_past_midnight &lt; 43200:</span>
<span class="gi">+        return &quot;am&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;pm&quot;</span>


<span class="w"> </span>class ParseError(ValueError):
<span class="w"> </span>    pass


<span class="gd">-def parse_date(string: str, locale: (Locale | str | None)=LC_TIME, format:</span>
<span class="gd">-    _PredefinedTimeFormat=&#39;medium&#39;) -&gt;datetime.date:</span>
<span class="gi">+def parse_date(</span>
<span class="gi">+    string: str,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+    format: _PredefinedTimeFormat = &#39;medium&#39;,</span>
<span class="gi">+) -&gt; datetime.date:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a date from a string.

<span class="w"> </span>    This function first tries to interpret the string as ISO-8601
<span class="gu">@@ -769,11 +1203,47 @@ def parse_date(string: str, locale: (Locale | str | None)=LC_TIME, format:</span>
<span class="w"> </span>    :param locale: a `Locale` object or a locale identifier
<span class="w"> </span>    :param format: the format to use (see ``get_date_format``)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_time(string: str, locale: (Locale | str | None)=LC_TIME, format:</span>
<span class="gd">-    _PredefinedTimeFormat=&#39;medium&#39;) -&gt;datetime.time:</span>
<span class="gi">+    numbers = re.findall(r&#39;(\d+)&#39;, string)</span>
<span class="gi">+    if not numbers:</span>
<span class="gi">+        raise ParseError(&quot;No numbers were found in input&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # we try ISO-8601 format first, meaning similar to formats</span>
<span class="gi">+    # extended YYYY-MM-DD or basic YYYYMMDD</span>
<span class="gi">+    iso_alike = re.match(r&#39;^(\d{4})-?([01]\d)-?([0-3]\d)$&#39;,</span>
<span class="gi">+                         string, flags=re.ASCII)  # allow only ASCII digits</span>
<span class="gi">+    if iso_alike:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return datetime.date(*map(int, iso_alike.groups()))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass  # a locale format might fit better, so let&#39;s continue</span>
<span class="gi">+</span>
<span class="gi">+    format_str = get_date_format(format=format, locale=locale).pattern.lower()</span>
<span class="gi">+    year_idx = format_str.index(&#39;y&#39;)</span>
<span class="gi">+    month_idx = format_str.index(&#39;m&#39;)</span>
<span class="gi">+    if month_idx &lt; 0:</span>
<span class="gi">+        month_idx = format_str.index(&#39;l&#39;)</span>
<span class="gi">+    day_idx = format_str.index(&#39;d&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    indexes = sorted([(year_idx, &#39;Y&#39;), (month_idx, &#39;M&#39;), (day_idx, &#39;D&#39;)])</span>
<span class="gi">+    indexes = {item[1]: idx for idx, item in enumerate(indexes)}</span>
<span class="gi">+</span>
<span class="gi">+    # FIXME: this currently only supports numbers, but should also support month</span>
<span class="gi">+    #        names, both in the requested locale, and english</span>
<span class="gi">+</span>
<span class="gi">+    year = numbers[indexes[&#39;Y&#39;]]</span>
<span class="gi">+    year = 2000 + int(year) if len(year) == 2 else int(year)</span>
<span class="gi">+    month = int(numbers[indexes[&#39;M&#39;]])</span>
<span class="gi">+    day = int(numbers[indexes[&#39;D&#39;]])</span>
<span class="gi">+    if month &gt; 12:</span>
<span class="gi">+        month, day = day, month</span>
<span class="gi">+    return datetime.date(year, month, day)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_time(</span>
<span class="gi">+    string: str,</span>
<span class="gi">+    locale: Locale | str | None = LC_TIME,</span>
<span class="gi">+    format: _PredefinedTimeFormat = &#39;medium&#39;,</span>
<span class="gi">+) -&gt; datetime.time:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a time from a string.

<span class="w"> </span>    This function uses the time format for the locale as a hint to determine
<span class="gu">@@ -788,7 +1258,37 @@ def parse_time(string: str, locale: (Locale | str | None)=LC_TIME, format:</span>
<span class="w"> </span>    :return: the parsed time
<span class="w"> </span>    :rtype: `time`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    numbers = re.findall(r&#39;(\d+)&#39;, string)</span>
<span class="gi">+    if not numbers:</span>
<span class="gi">+        raise ParseError(&quot;No numbers were found in input&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: try ISO format first?</span>
<span class="gi">+    format_str = get_time_format(format=format, locale=locale).pattern.lower()</span>
<span class="gi">+    hour_idx = format_str.index(&#39;h&#39;)</span>
<span class="gi">+    if hour_idx &lt; 0:</span>
<span class="gi">+        hour_idx = format_str.index(&#39;k&#39;)</span>
<span class="gi">+    min_idx = format_str.index(&#39;m&#39;)</span>
<span class="gi">+    sec_idx = format_str.index(&#39;s&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    indexes = sorted([(hour_idx, &#39;H&#39;), (min_idx, &#39;M&#39;), (sec_idx, &#39;S&#39;)])</span>
<span class="gi">+    indexes = {item[1]: idx for idx, item in enumerate(indexes)}</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: support time zones</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the format specifies a period to be used;</span>
<span class="gi">+    # if it does, look for &#39;pm&#39; to figure out an offset.</span>
<span class="gi">+    hour_offset = 0</span>
<span class="gi">+    if &#39;a&#39; in format_str and &#39;pm&#39; in string.lower():</span>
<span class="gi">+        hour_offset = 12</span>
<span class="gi">+</span>
<span class="gi">+    # Parse up to three numbers from the string.</span>
<span class="gi">+    minute = second = 0</span>
<span class="gi">+    hour = int(numbers[indexes[&#39;H&#39;]]) + hour_offset</span>
<span class="gi">+    if len(numbers) &gt; 1:</span>
<span class="gi">+        minute = int(numbers[indexes[&#39;M&#39;]])</span>
<span class="gi">+        if len(numbers) &gt; 2:</span>
<span class="gi">+            second = int(numbers[indexes[&#39;S&#39;]])</span>
<span class="gi">+    return datetime.time(hour, minute, second)</span>


<span class="w"> </span>class DateTimePattern:
<span class="gu">@@ -797,33 +1297,43 @@ class DateTimePattern:</span>
<span class="w"> </span>        self.pattern = pattern
<span class="w"> </span>        self.format = format

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.pattern!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.pattern!r}&gt;&quot;</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        pat = self.pattern
<span class="w"> </span>        return pat

<span class="gd">-    def __mod__(self, other: DateTimeFormat) -&gt;str:</span>
<span class="gi">+    def __mod__(self, other: DateTimeFormat) -&gt; str:</span>
<span class="w"> </span>        if not isinstance(other, DateTimeFormat):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.format % other

<span class="gi">+    def apply(</span>
<span class="gi">+        self,</span>
<span class="gi">+        datetime: datetime.date | datetime.time,</span>
<span class="gi">+        locale: Locale | str | None,</span>
<span class="gi">+        reference_date: datetime.date | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        return self % DateTimeFormat(datetime, locale, reference_date)</span>
<span class="gi">+</span>

<span class="w"> </span>class DateTimeFormat:

<span class="gd">-    def __init__(self, value: (datetime.date | datetime.time), locale: (</span>
<span class="gd">-        Locale | str), reference_date: (datetime.date | None)=None) -&gt;None:</span>
<span class="gd">-        assert isinstance(value, (datetime.date, datetime.datetime,</span>
<span class="gd">-            datetime.time))</span>
<span class="gd">-        if isinstance(value, (datetime.datetime, datetime.time)</span>
<span class="gd">-            ) and value.tzinfo is None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: datetime.date | datetime.time,</span>
<span class="gi">+        locale: Locale | str,</span>
<span class="gi">+        reference_date: datetime.date | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert isinstance(value, (datetime.date, datetime.datetime, datetime.time))</span>
<span class="gi">+        if isinstance(value, (datetime.datetime, datetime.time)) and value.tzinfo is None:</span>
<span class="w"> </span>            value = value.replace(tzinfo=UTC)
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.locale = Locale.parse(locale)
<span class="w"> </span>        self.reference_date = reference_date

<span class="gd">-    def __getitem__(self, name: str) -&gt;str:</span>
<span class="gi">+    def __getitem__(self, name: str) -&gt; str:</span>
<span class="w"> </span>        char = name[0]
<span class="w"> </span>        num = len(name)
<span class="w"> </span>        if char == &#39;G&#39;:
<span class="gu">@@ -871,9 +1381,73 @@ class DateTimeFormat:</span>
<span class="w"> </span>        elif char in (&#39;z&#39;, &#39;Z&#39;, &#39;v&#39;, &#39;V&#39;, &#39;x&#39;, &#39;X&#39;, &#39;O&#39;):
<span class="w"> </span>            return self.format_timezone(char, num)
<span class="w"> </span>        else:
<span class="gd">-            raise KeyError(f&#39;Unsupported date/time field {char!r}&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def format_weekday(self, char: str=&#39;E&#39;, num: int=4) -&gt;str:</span>
<span class="gi">+            raise KeyError(f&quot;Unsupported date/time field {char!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def extract(self, char: str) -&gt; int:</span>
<span class="gi">+        char = str(char)[0]</span>
<span class="gi">+        if char == &#39;y&#39;:</span>
<span class="gi">+            return self.value.year</span>
<span class="gi">+        elif char == &#39;M&#39;:</span>
<span class="gi">+            return self.value.month</span>
<span class="gi">+        elif char == &#39;d&#39;:</span>
<span class="gi">+            return self.value.day</span>
<span class="gi">+        elif char == &#39;H&#39;:</span>
<span class="gi">+            return self.value.hour</span>
<span class="gi">+        elif char == &#39;h&#39;:</span>
<span class="gi">+            return self.value.hour % 12 or 12</span>
<span class="gi">+        elif char == &#39;m&#39;:</span>
<span class="gi">+            return self.value.minute</span>
<span class="gi">+        elif char == &#39;a&#39;:</span>
<span class="gi">+            return int(self.value.hour &gt;= 12)  # 0 for am, 1 for pm</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;Not implemented: extracting {char!r} from {self.value!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def format_era(self, char: str, num: int) -&gt; str:</span>
<span class="gi">+        width = {3: &#39;abbreviated&#39;, 4: &#39;wide&#39;, 5: &#39;narrow&#39;}[max(3, num)]</span>
<span class="gi">+        era = int(self.value.year &gt;= 0)</span>
<span class="gi">+        return get_era_names(width, self.locale)[era]</span>
<span class="gi">+</span>
<span class="gi">+    def format_year(self, char: str, num: int) -&gt; str:</span>
<span class="gi">+        value = self.value.year</span>
<span class="gi">+        if char.isupper():</span>
<span class="gi">+            value = self.value.isocalendar()[0]</span>
<span class="gi">+        year = self.format(value, num)</span>
<span class="gi">+        if num == 2:</span>
<span class="gi">+            year = year[-2:]</span>
<span class="gi">+        return year</span>
<span class="gi">+</span>
<span class="gi">+    def format_quarter(self, char: str, num: int) -&gt; str:</span>
<span class="gi">+        quarter = (self.value.month - 1) // 3 + 1</span>
<span class="gi">+        if num &lt;= 2:</span>
<span class="gi">+            return &#39;%0*d&#39; % (num, quarter)</span>
<span class="gi">+        width = {3: &#39;abbreviated&#39;, 4: &#39;wide&#39;, 5: &#39;narrow&#39;}[num]</span>
<span class="gi">+        context = {&#39;Q&#39;: &#39;format&#39;, &#39;q&#39;: &#39;stand-alone&#39;}[char]</span>
<span class="gi">+        return get_quarter_names(width, context, self.locale)[quarter]</span>
<span class="gi">+</span>
<span class="gi">+    def format_month(self, char: str, num: int) -&gt; str:</span>
<span class="gi">+        if num &lt;= 2:</span>
<span class="gi">+            return &#39;%0*d&#39; % (num, self.value.month)</span>
<span class="gi">+        width = {3: &#39;abbreviated&#39;, 4: &#39;wide&#39;, 5: &#39;narrow&#39;}[num]</span>
<span class="gi">+        context = {&#39;M&#39;: &#39;format&#39;, &#39;L&#39;: &#39;stand-alone&#39;}[char]</span>
<span class="gi">+        return get_month_names(width, context, self.locale)[self.value.month]</span>
<span class="gi">+</span>
<span class="gi">+    def format_week(self, char: str, num: int) -&gt; str:</span>
<span class="gi">+        if char.islower():  # week of year</span>
<span class="gi">+            day_of_year = self.get_day_of_year()</span>
<span class="gi">+            week = self.get_week_number(day_of_year)</span>
<span class="gi">+            if week == 0:</span>
<span class="gi">+                date = self.value - datetime.timedelta(days=day_of_year)</span>
<span class="gi">+                week = self.get_week_number(self.get_day_of_year(date),</span>
<span class="gi">+                                            date.weekday())</span>
<span class="gi">+            return self.format(week, num)</span>
<span class="gi">+        else:  # week of month</span>
<span class="gi">+            week = self.get_week_number(self.value.day)</span>
<span class="gi">+            if week == 0:</span>
<span class="gi">+                date = self.value - datetime.timedelta(days=self.value.day)</span>
<span class="gi">+                week = self.get_week_number(date.day, date.weekday())</span>
<span class="gi">+            return str(week)</span>
<span class="gi">+</span>
<span class="gi">+    def format_weekday(self, char: str = &#39;E&#39;, num: int = 4) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return weekday from parsed datetime according to format pattern.

<span class="gu">@@ -901,9 +1475,23 @@ class DateTimeFormat:</span>
<span class="w"> </span>        :param num: count of format character

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def format_period(self, char: str, num: int) -&gt;str:</span>
<span class="gi">+        if num &lt; 3:</span>
<span class="gi">+            if char.islower():</span>
<span class="gi">+                value = 7 - self.locale.first_week_day + self.value.weekday()</span>
<span class="gi">+                return self.format(value % 7 + 1, num)</span>
<span class="gi">+            num = 3</span>
<span class="gi">+        weekday = self.value.weekday()</span>
<span class="gi">+        width = {3: &#39;abbreviated&#39;, 4: &#39;wide&#39;, 5: &#39;narrow&#39;, 6: &#39;short&#39;}[num]</span>
<span class="gi">+        context = &quot;stand-alone&quot; if char == &quot;c&quot; else &quot;format&quot;</span>
<span class="gi">+        return get_day_names(width, context, self.locale)[weekday]</span>
<span class="gi">+</span>
<span class="gi">+    def format_day_of_year(self, num: int) -&gt; str:</span>
<span class="gi">+        return self.format(self.get_day_of_year(), num)</span>
<span class="gi">+</span>
<span class="gi">+    def format_day_of_week_in_month(self) -&gt; str:</span>
<span class="gi">+        return str((self.value.day - 1) // 7 + 1)</span>
<span class="gi">+</span>
<span class="gi">+    def format_period(self, char: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return period from parsed datetime according to format pattern.

<span class="gu">@@ -932,17 +1520,94 @@ class DateTimeFormat:</span>
<span class="w"> </span>        :param num: count of format character

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def format_frac_seconds(self, num: int) -&gt;str:</span>
<span class="gi">+        widths = [{3: &#39;abbreviated&#39;, 4: &#39;wide&#39;, 5: &#39;narrow&#39;}[max(3, num)],</span>
<span class="gi">+                  &#39;wide&#39;, &#39;narrow&#39;, &#39;abbreviated&#39;]</span>
<span class="gi">+        if char == &#39;a&#39;:</span>
<span class="gi">+            period = &#39;pm&#39; if self.value.hour &gt;= 12 else &#39;am&#39;</span>
<span class="gi">+            context = &#39;format&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            period = get_period_id(self.value, locale=self.locale)</span>
<span class="gi">+            context = &#39;format&#39; if char == &#39;B&#39; else &#39;stand-alone&#39;</span>
<span class="gi">+        for width in widths:</span>
<span class="gi">+            period_names = get_period_names(context=context, width=width, locale=self.locale)</span>
<span class="gi">+            if period in period_names:</span>
<span class="gi">+                return period_names[period]</span>
<span class="gi">+        raise ValueError(f&quot;Could not format period {period} in {self.locale}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def format_frac_seconds(self, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot; Return fractional seconds.

<span class="gd">-        Rounds the time&#39;s microseconds to the precision given by the number         of digits passed in.</span>
<span class="gi">+        Rounds the time&#39;s microseconds to the precision given by the number \</span>
<span class="gi">+        of digits passed in.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_week_number(self, day_of_period: int, day_of_week: (int | None)</span>
<span class="gd">-        =None) -&gt;int:</span>
<span class="gi">+        value = self.value.microsecond / 1000000</span>
<span class="gi">+        return self.format(round(value, num) * 10**num, num)</span>
<span class="gi">+</span>
<span class="gi">+    def format_milliseconds_in_day(self, num):</span>
<span class="gi">+        msecs = self.value.microsecond // 1000 + self.value.second * 1000 + \</span>
<span class="gi">+            self.value.minute * 60000 + self.value.hour * 3600000</span>
<span class="gi">+        return self.format(msecs, num)</span>
<span class="gi">+</span>
<span class="gi">+    def format_timezone(self, char: str, num: int) -&gt; str:</span>
<span class="gi">+        width = {3: &#39;short&#39;, 4: &#39;long&#39;, 5: &#39;iso8601&#39;}[max(3, num)]</span>
<span class="gi">+</span>
<span class="gi">+        # It could be that we only receive a time to format, but also have a</span>
<span class="gi">+        # reference date which is important to distinguish between timezone</span>
<span class="gi">+        # variants (summer/standard time)</span>
<span class="gi">+        value = self.value</span>
<span class="gi">+        if self.reference_date:</span>
<span class="gi">+            value = datetime.datetime.combine(self.reference_date, self.value)</span>
<span class="gi">+</span>
<span class="gi">+        if char == &#39;z&#39;:</span>
<span class="gi">+            return get_timezone_name(value, width, locale=self.locale)</span>
<span class="gi">+        elif char == &#39;Z&#39;:</span>
<span class="gi">+            if num == 5:</span>
<span class="gi">+                return get_timezone_gmt(value, width, locale=self.locale, return_z=True)</span>
<span class="gi">+            return get_timezone_gmt(value, width, locale=self.locale)</span>
<span class="gi">+        elif char == &#39;O&#39;:</span>
<span class="gi">+            if num == 4:</span>
<span class="gi">+                return get_timezone_gmt(value, width, locale=self.locale)</span>
<span class="gi">+        # TODO: To add support for O:1</span>
<span class="gi">+        elif char == &#39;v&#39;:</span>
<span class="gi">+            return get_timezone_name(value.tzinfo, width,</span>
<span class="gi">+                                     locale=self.locale)</span>
<span class="gi">+        elif char == &#39;V&#39;:</span>
<span class="gi">+            if num == 1:</span>
<span class="gi">+                return get_timezone_name(value.tzinfo, width,</span>
<span class="gi">+                                         uncommon=True, locale=self.locale)</span>
<span class="gi">+            elif num == 2:</span>
<span class="gi">+                return get_timezone_name(value.tzinfo, locale=self.locale, return_zone=True)</span>
<span class="gi">+            elif num == 3:</span>
<span class="gi">+                return get_timezone_location(value.tzinfo, locale=self.locale, return_city=True)</span>
<span class="gi">+            return get_timezone_location(value.tzinfo, locale=self.locale)</span>
<span class="gi">+        # Included additional elif condition to add support for &#39;Xx&#39; in timezone format</span>
<span class="gi">+        elif char == &#39;X&#39;:</span>
<span class="gi">+            if num == 1:</span>
<span class="gi">+                return get_timezone_gmt(value, width=&#39;iso8601_short&#39;, locale=self.locale,</span>
<span class="gi">+                                        return_z=True)</span>
<span class="gi">+            elif num in (2, 4):</span>
<span class="gi">+                return get_timezone_gmt(value, width=&#39;short&#39;, locale=self.locale,</span>
<span class="gi">+                                        return_z=True)</span>
<span class="gi">+            elif num in (3, 5):</span>
<span class="gi">+                return get_timezone_gmt(value, width=&#39;iso8601&#39;, locale=self.locale,</span>
<span class="gi">+                                        return_z=True)</span>
<span class="gi">+        elif char == &#39;x&#39;:</span>
<span class="gi">+            if num == 1:</span>
<span class="gi">+                return get_timezone_gmt(value, width=&#39;iso8601_short&#39;, locale=self.locale)</span>
<span class="gi">+            elif num in (2, 4):</span>
<span class="gi">+                return get_timezone_gmt(value, width=&#39;short&#39;, locale=self.locale)</span>
<span class="gi">+            elif num in (3, 5):</span>
<span class="gi">+                return get_timezone_gmt(value, width=&#39;iso8601&#39;, locale=self.locale)</span>
<span class="gi">+</span>
<span class="gi">+    def format(self, value: SupportsInt, length: int) -&gt; str:</span>
<span class="gi">+        return &#39;%0*d&#39; % (length, value)</span>
<span class="gi">+</span>
<span class="gi">+    def get_day_of_year(self, date: datetime.date | None = None) -&gt; int:</span>
<span class="gi">+        if date is None:</span>
<span class="gi">+            date = self.value</span>
<span class="gi">+        return (date - date.replace(month=1, day=1)).days + 1</span>
<span class="gi">+</span>
<span class="gi">+    def get_week_number(self, day_of_period: int, day_of_week: int | None = None) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the number of the week of a day within a period. This may be
<span class="w"> </span>        the week number in a year or the week number in a month.

<span class="gu">@@ -961,22 +1626,53 @@ class DateTimeFormat:</span>
<span class="w"> </span>        :param day_of_week: the week day; if omitted, the week day of the
<span class="w"> </span>                            current date is assumed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-PATTERN_CHARS: dict[str, list[int] | None] = {&#39;G&#39;: [1, 2, 3, 4, 5], &#39;y&#39;:</span>
<span class="gd">-    None, &#39;Y&#39;: None, &#39;u&#39;: None, &#39;Q&#39;: [1, 2, 3, 4, 5], &#39;q&#39;: [1, 2, 3, 4, 5],</span>
<span class="gd">-    &#39;M&#39;: [1, 2, 3, 4, 5], &#39;L&#39;: [1, 2, 3, 4, 5], &#39;w&#39;: [1, 2], &#39;W&#39;: [1], &#39;d&#39;:</span>
<span class="gd">-    [1, 2], &#39;D&#39;: [1, 2, 3], &#39;F&#39;: [1], &#39;g&#39;: None, &#39;E&#39;: [1, 2, 3, 4, 5, 6],</span>
<span class="gd">-    &#39;e&#39;: [1, 2, 3, 4, 5, 6], &#39;c&#39;: [1, 3, 4, 5, 6], &#39;a&#39;: [1, 2, 3, 4, 5],</span>
<span class="gd">-    &#39;b&#39;: [1, 2, 3, 4, 5], &#39;B&#39;: [1, 2, 3, 4, 5], &#39;h&#39;: [1, 2], &#39;H&#39;: [1, 2],</span>
<span class="gd">-    &#39;K&#39;: [1, 2], &#39;k&#39;: [1, 2], &#39;m&#39;: [1, 2], &#39;s&#39;: [1, 2], &#39;S&#39;: None, &#39;A&#39;:</span>
<span class="gd">-    None, &#39;z&#39;: [1, 2, 3, 4], &#39;Z&#39;: [1, 2, 3, 4, 5], &#39;O&#39;: [1, 4], &#39;v&#39;: [1, 4],</span>
<span class="gd">-    &#39;V&#39;: [1, 2, 3, 4], &#39;x&#39;: [1, 2, 3, 4, 5], &#39;X&#39;: [1, 2, 3, 4, 5]}</span>
<span class="gd">-PATTERN_CHAR_ORDER = &#39;GyYuUQqMLlwWdDFgEecabBChHKkjJmsSAzZOvVXx&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_pattern(pattern: (str | DateTimePattern)) -&gt;DateTimePattern:</span>
<span class="gi">+        if day_of_week is None:</span>
<span class="gi">+            day_of_week = self.value.weekday()</span>
<span class="gi">+        first_day = (day_of_week - self.locale.first_week_day -</span>
<span class="gi">+                     day_of_period + 1) % 7</span>
<span class="gi">+        if first_day &lt; 0:</span>
<span class="gi">+            first_day += 7</span>
<span class="gi">+        week_number = (day_of_period + first_day - 1) // 7</span>
<span class="gi">+</span>
<span class="gi">+        if 7 - first_day &gt;= self.locale.min_week_days:</span>
<span class="gi">+            week_number += 1</span>
<span class="gi">+</span>
<span class="gi">+        if self.locale.first_week_day == 0:</span>
<span class="gi">+            # Correct the weeknumber in case of iso-calendar usage (first_week_day=0).</span>
<span class="gi">+            # If the weeknumber exceeds the maximum number of weeks for the given year</span>
<span class="gi">+            # we must count from zero.For example the above calculation gives week 53</span>
<span class="gi">+            # for 2018-12-31. By iso-calender definition 2018 has a max of 52</span>
<span class="gi">+            # weeks, thus the weeknumber must be 53-52=1.</span>
<span class="gi">+            max_weeks = datetime.date(year=self.value.year, day=28, month=12).isocalendar()[1]</span>
<span class="gi">+            if week_number &gt; max_weeks:</span>
<span class="gi">+                week_number -= max_weeks</span>
<span class="gi">+</span>
<span class="gi">+        return week_number</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+PATTERN_CHARS: dict[str, list[int] | None] = {</span>
<span class="gi">+    &#39;G&#39;: [1, 2, 3, 4, 5],                                               # era</span>
<span class="gi">+    &#39;y&#39;: None, &#39;Y&#39;: None, &#39;u&#39;: None,                                    # year</span>
<span class="gi">+    &#39;Q&#39;: [1, 2, 3, 4, 5], &#39;q&#39;: [1, 2, 3, 4, 5],                         # quarter</span>
<span class="gi">+    &#39;M&#39;: [1, 2, 3, 4, 5], &#39;L&#39;: [1, 2, 3, 4, 5],                         # month</span>
<span class="gi">+    &#39;w&#39;: [1, 2], &#39;W&#39;: [1],                                              # week</span>
<span class="gi">+    &#39;d&#39;: [1, 2], &#39;D&#39;: [1, 2, 3], &#39;F&#39;: [1], &#39;g&#39;: None,                   # day</span>
<span class="gi">+    &#39;E&#39;: [1, 2, 3, 4, 5, 6], &#39;e&#39;: [1, 2, 3, 4, 5, 6], &#39;c&#39;: [1, 3, 4, 5, 6],  # week day</span>
<span class="gi">+    &#39;a&#39;: [1, 2, 3, 4, 5], &#39;b&#39;: [1, 2, 3, 4, 5], &#39;B&#39;: [1, 2, 3, 4, 5],   # period</span>
<span class="gi">+    &#39;h&#39;: [1, 2], &#39;H&#39;: [1, 2], &#39;K&#39;: [1, 2], &#39;k&#39;: [1, 2],                 # hour</span>
<span class="gi">+    &#39;m&#39;: [1, 2],                                                        # minute</span>
<span class="gi">+    &#39;s&#39;: [1, 2], &#39;S&#39;: None, &#39;A&#39;: None,                                  # second</span>
<span class="gi">+    &#39;z&#39;: [1, 2, 3, 4], &#39;Z&#39;: [1, 2, 3, 4, 5], &#39;O&#39;: [1, 4], &#39;v&#39;: [1, 4],  # zone</span>
<span class="gi">+    &#39;V&#39;: [1, 2, 3, 4], &#39;x&#39;: [1, 2, 3, 4, 5], &#39;X&#39;: [1, 2, 3, 4, 5],      # zone</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+#: The pattern characters declared in the Date Field Symbol Table</span>
<span class="gi">+#: (https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table)</span>
<span class="gi">+#: in order of decreasing magnitude.</span>
<span class="gi">+PATTERN_CHAR_ORDER = &quot;GyYuUQqMLlwWdDFgEecabBChHKkjJmsSAzZOvVXx&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_pattern(pattern: str | DateTimePattern) -&gt; DateTimePattern:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse date, time, and datetime format patterns.

<span class="w"> </span>    &gt;&gt;&gt; parse_pattern(&quot;MMMMd&quot;).format
<span class="gu">@@ -997,10 +1693,30 @@ def parse_pattern(pattern: (str | DateTimePattern)) -&gt;DateTimePattern:</span>

<span class="w"> </span>    :param pattern: the formatting pattern to parse
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(pattern, DateTimePattern):</span>
<span class="gi">+        return pattern</span>
<span class="gi">+    return _cached_parse_pattern(pattern)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@lru_cache(maxsize=1024)</span>
<span class="gi">+def _cached_parse_pattern(pattern: str) -&gt; DateTimePattern:</span>
<span class="gi">+    result = []</span>
<span class="gi">+</span>
<span class="gi">+    for tok_type, tok_value in tokenize_pattern(pattern):</span>
<span class="gi">+        if tok_type == &quot;chars&quot;:</span>
<span class="gi">+            result.append(tok_value.replace(&#39;%&#39;, &#39;%%&#39;))</span>
<span class="gi">+        elif tok_type == &quot;field&quot;:</span>
<span class="gi">+            fieldchar, fieldnum = tok_value</span>
<span class="gi">+            limit = PATTERN_CHARS[fieldchar]</span>
<span class="gi">+            if limit and fieldnum not in limit:</span>
<span class="gi">+                raise ValueError(f&quot;Invalid length for field: {fieldchar * fieldnum!r}&quot;)</span>
<span class="gi">+            result.append(&#39;%%(%s)s&#39; % (fieldchar * fieldnum))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;Unknown token type: {tok_type}&quot;)</span>
<span class="gi">+    return DateTimePattern(pattern, &#39;&#39;.join(result))</span>


<span class="gd">-def tokenize_pattern(pattern: str) -&gt;list[tuple[str, str | tuple[str, int]]]:</span>
<span class="gi">+def tokenize_pattern(pattern: str) -&gt; list[tuple[str, str | tuple[str, int]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Tokenize date format patterns.

<span class="gu">@@ -1016,11 +1732,60 @@ def tokenize_pattern(pattern: str) -&gt;list[tuple[str, str | tuple[str, int]]]:</span>
<span class="w"> </span>    :type pattern: str
<span class="w"> </span>    :rtype: list[tuple]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    quotebuf = None</span>
<span class="gi">+    charbuf = []</span>
<span class="gi">+    fieldchar = [&#39;&#39;]</span>
<span class="gi">+    fieldnum = [0]</span>
<span class="gi">+</span>
<span class="gi">+    def append_chars():</span>
<span class="gi">+        result.append((&#39;chars&#39;, &#39;&#39;.join(charbuf).replace(&#39;\0&#39;, &quot;&#39;&quot;)))</span>
<span class="gi">+        del charbuf[:]</span>
<span class="gi">+</span>
<span class="gi">+    def append_field():</span>
<span class="gi">+        result.append((&#39;field&#39;, (fieldchar[0], fieldnum[0])))</span>
<span class="gi">+        fieldchar[0] = &#39;&#39;</span>
<span class="gi">+        fieldnum[0] = 0</span>
<span class="gi">+</span>
<span class="gi">+    for char in pattern.replace(&quot;&#39;&#39;&quot;, &#39;\0&#39;):</span>
<span class="gi">+        if quotebuf is None:</span>
<span class="gi">+            if char == &quot;&#39;&quot;:  # quote started</span>
<span class="gi">+                if fieldchar[0]:</span>
<span class="gi">+                    append_field()</span>
<span class="gi">+                elif charbuf:</span>
<span class="gi">+                    append_chars()</span>
<span class="gi">+                quotebuf = []</span>
<span class="gi">+            elif char in PATTERN_CHARS:</span>
<span class="gi">+                if charbuf:</span>
<span class="gi">+                    append_chars()</span>
<span class="gi">+                if char == fieldchar[0]:</span>
<span class="gi">+                    fieldnum[0] += 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if fieldchar[0]:</span>
<span class="gi">+                        append_field()</span>
<span class="gi">+                    fieldchar[0] = char</span>
<span class="gi">+                    fieldnum[0] = 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                if fieldchar[0]:</span>
<span class="gi">+                    append_field()</span>
<span class="gi">+                charbuf.append(char)</span>
<span class="gi">+</span>
<span class="gi">+        elif quotebuf is not None:</span>
<span class="gi">+            if char == &quot;&#39;&quot;:  # end of quote</span>
<span class="gi">+                charbuf.extend(quotebuf)</span>
<span class="gi">+                quotebuf = None</span>
<span class="gi">+            else:  # inside quote</span>
<span class="gi">+                quotebuf.append(char)</span>

<span class="gi">+    if fieldchar[0]:</span>
<span class="gi">+        append_field()</span>
<span class="gi">+    elif charbuf:</span>
<span class="gi">+        append_chars()</span>

<span class="gd">-def untokenize_pattern(tokens: Iterable[tuple[str, str | tuple[str, int]]]</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def untokenize_pattern(tokens: Iterable[tuple[str, str | tuple[str, int]]]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn a date format pattern token stream back into a string.

<span class="gu">@@ -1029,37 +1794,57 @@ def untokenize_pattern(tokens: Iterable[tuple[str, str | tuple[str, int]]]</span>
<span class="w"> </span>    :type tokens: Iterable[tuple]
<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = []</span>
<span class="gi">+    for tok_type, tok_value in tokens:</span>
<span class="gi">+        if tok_type == &quot;field&quot;:</span>
<span class="gi">+            output.append(tok_value[0] * tok_value[1])</span>
<span class="gi">+        elif tok_type == &quot;chars&quot;:</span>
<span class="gi">+            if not any(ch in PATTERN_CHARS for ch in tok_value):  # No need to quote</span>
<span class="gi">+                output.append(tok_value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                output.append(&quot;&#39;%s&#39;&quot; % tok_value.replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;))</span>
<span class="gi">+    return &quot;&quot;.join(output)</span>


<span class="gd">-def split_interval_pattern(pattern: str) -&gt;list[str]:</span>
<span class="gi">+def split_interval_pattern(pattern: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Split an interval-describing datetime pattern into multiple pieces.

<span class="w"> </span>    &gt; The pattern is then designed to be broken up into two pieces by determining the first repeating field.
<span class="w"> </span>    - https://www.unicode.org/reports/tr35/tr35-dates.html#intervalFormats

<span class="gd">-    &gt;&gt;&gt; split_interval_pattern(u&#39;E d.M.  E d.M.&#39;)</span>
<span class="gd">-    [u&#39;E d.M.  &#39;, &#39;E d.M.&#39;]</span>
<span class="gi">+    &gt;&gt;&gt; split_interval_pattern(u&#39;E d.M. \u2013 E d.M.&#39;)</span>
<span class="gi">+    [u&#39;E d.M. \u2013 &#39;, &#39;E d.M.&#39;]</span>
<span class="w"> </span>    &gt;&gt;&gt; split_interval_pattern(&quot;Y &#39;text&#39; Y &#39;more text&#39;&quot;)
<span class="w"> </span>    [&quot;Y &#39;text &#39;&quot;, &quot;Y &#39;more text&#39;&quot;]
<span class="gd">-    &gt;&gt;&gt; split_interval_pattern(u&quot;E, MMM d  E&quot;)</span>
<span class="gd">-    [u&#39;E, MMM d  &#39;, u&#39;E&#39;]</span>
<span class="gi">+    &gt;&gt;&gt; split_interval_pattern(u&quot;E, MMM d \u2013 E&quot;)</span>
<span class="gi">+    [u&#39;E, MMM d \u2013 &#39;, u&#39;E&#39;]</span>
<span class="w"> </span>    &gt;&gt;&gt; split_interval_pattern(&quot;MMM d&quot;)
<span class="w"> </span>    [&#39;MMM d&#39;]
<span class="w"> </span>    &gt;&gt;&gt; split_interval_pattern(&quot;y G&quot;)
<span class="w"> </span>    [&#39;y G&#39;]
<span class="gd">-    &gt;&gt;&gt; split_interval_pattern(u&quot;MMM d  d&quot;)</span>
<span class="gd">-    [u&#39;MMM d  &#39;, u&#39;d&#39;]</span>
<span class="gi">+    &gt;&gt;&gt; split_interval_pattern(u&quot;MMM d \u2013 d&quot;)</span>
<span class="gi">+    [u&#39;MMM d \u2013 &#39;, u&#39;d&#39;]</span>

<span class="w"> </span>    :param pattern: Interval pattern string
<span class="w"> </span>    :return: list of &quot;subpatterns&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    seen_fields = set()</span>
<span class="gi">+    parts = [[]]</span>
<span class="gi">+</span>
<span class="gi">+    for tok_type, tok_value in tokenize_pattern(pattern):</span>
<span class="gi">+        if tok_type == &quot;field&quot;:</span>
<span class="gi">+            if tok_value[0] in seen_fields:  # Repeated field</span>
<span class="gi">+                parts.append([])</span>
<span class="gi">+                seen_fields.clear()</span>
<span class="gi">+            seen_fields.add(tok_value[0])</span>
<span class="gi">+        parts[-1].append((tok_type, tok_value))</span>
<span class="gi">+</span>
<span class="gi">+    return [untokenize_pattern(tokens) for tokens in parts]</span>


<span class="gd">-def match_skeleton(skeleton: str, options: Iterable[str],</span>
<span class="gd">-    allow_different_fields: bool=False) -&gt;(str | None):</span>
<span class="gi">+def match_skeleton(skeleton: str, options: Iterable[str], allow_different_fields: bool = False) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find the closest match for the given datetime skeleton among the options given.

<span class="gu">@@ -1083,4 +1868,47 @@ def match_skeleton(skeleton: str, options: Iterable[str],</span>
<span class="w"> </span>    :return: The closest skeleton match, or if no match was found, None.
<span class="w"> </span>    :rtype: str|None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: maybe implement pattern expansion?</span>
<span class="gi">+</span>
<span class="gi">+    # Based on the implementation in</span>
<span class="gi">+    # http://source.icu-project.org/repos/icu/icu4j/trunk/main/classes/core/src/com/ibm/icu/text/DateIntervalInfo.java</span>
<span class="gi">+</span>
<span class="gi">+    # Filter out falsy values and sort for stability; when `interval_formats` is passed in, there may be a None key.</span>
<span class="gi">+    options = sorted(option for option in options if option)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;z&#39; in skeleton and not any(&#39;z&#39; in option for option in options):</span>
<span class="gi">+        skeleton = skeleton.replace(&#39;z&#39;, &#39;v&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    get_input_field_width = dict(t[1] for t in tokenize_pattern(skeleton) if t[0] == &quot;field&quot;).get</span>
<span class="gi">+    best_skeleton = None</span>
<span class="gi">+    best_distance = None</span>
<span class="gi">+    for option in options:</span>
<span class="gi">+        get_opt_field_width = dict(t[1] for t in tokenize_pattern(option) if t[0] == &quot;field&quot;).get</span>
<span class="gi">+        distance = 0</span>
<span class="gi">+        for field in PATTERN_CHARS:</span>
<span class="gi">+            input_width = get_input_field_width(field, 0)</span>
<span class="gi">+            opt_width = get_opt_field_width(field, 0)</span>
<span class="gi">+            if input_width == opt_width:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if opt_width == 0 or input_width == 0:</span>
<span class="gi">+                if not allow_different_fields:  # This one is not okay</span>
<span class="gi">+                    option = None</span>
<span class="gi">+                    break</span>
<span class="gi">+                distance += 0x1000  # Magic weight constant for &quot;entirely different fields&quot;</span>
<span class="gi">+            elif field == &#39;M&#39; and ((input_width &gt; 2 and opt_width &lt;= 2) or (input_width &lt;= 2 and opt_width &gt; 2)):</span>
<span class="gi">+                distance += 0x100  # Magic weight for &quot;text turns into a number&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                distance += abs(input_width - opt_width)</span>
<span class="gi">+</span>
<span class="gi">+        if not option:  # We lost the option along the way (probably due to &quot;allow_different_fields&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if not best_skeleton or distance &lt; best_distance:</span>
<span class="gi">+            best_skeleton = option</span>
<span class="gi">+            best_distance = distance</span>
<span class="gi">+</span>
<span class="gi">+        if distance == 0:  # Found a perfect match!</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return best_skeleton</span>
<span class="gh">diff --git a/babel/languages.py b/babel/languages.py</span>
<span class="gh">index 11dd1ae..564f555 100644</span>
<span class="gd">--- a/babel/languages.py</span>
<span class="gi">+++ b/babel/languages.py</span>
<span class="gu">@@ -1,9 +1,9 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from babel.core import get_global


<span class="gd">-def get_official_languages(territory: str, regional: bool=False, de_facto:</span>
<span class="gd">-    bool=False) -&gt;tuple[str, ...]:</span>
<span class="gi">+def get_official_languages(territory: str, regional: bool = False, de_facto: bool = False) -&gt; tuple[str, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the official language(s) for the given territory.

<span class="gu">@@ -25,11 +25,25 @@ def get_official_languages(territory: str, regional: bool=False, de_facto:</span>
<span class="w"> </span>    :return: Tuple of language codes
<span class="w"> </span>    :rtype: tuple[str]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    territory = str(territory).upper()</span>
<span class="gi">+    allowed_stati = {&quot;official&quot;}</span>
<span class="gi">+    if regional:</span>
<span class="gi">+        allowed_stati.add(&quot;official_regional&quot;)</span>
<span class="gi">+    if de_facto:</span>
<span class="gi">+        allowed_stati.add(&quot;de_facto_official&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    languages = get_global(&quot;territory_languages&quot;).get(territory, {})</span>
<span class="gi">+    pairs = [</span>
<span class="gi">+        (info[&#39;population_percent&#39;], language)</span>
<span class="gi">+        for language, info in languages.items()</span>
<span class="gi">+        if info.get(&#39;official_status&#39;) in allowed_stati</span>
<span class="gi">+    ]</span>
<span class="gi">+    pairs.sort(reverse=True)</span>
<span class="gi">+    return tuple(lang for _, lang in pairs)</span>


<span class="gd">-def get_territory_language_info(territory: str) -&gt;dict[str, dict[str, float |</span>
<span class="gd">-    str | None]]:</span>
<span class="gi">+def get_territory_language_info(territory: str) -&gt; dict[str, dict[str, float | str | None]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get a dictionary of language information for a territory.

<span class="gu">@@ -54,4 +68,5 @@ def get_territory_language_info(territory: str) -&gt;dict[str, dict[str, float |</span>
<span class="w"> </span>    :return: Language information dictionary
<span class="w"> </span>    :rtype: dict[str, dict]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    territory = str(territory).upper()</span>
<span class="gi">+    return get_global(&quot;territory_languages&quot;).get(territory, {}).copy()</span>
<span class="gh">diff --git a/babel/lists.py b/babel/lists.py</span>
<span class="gh">index cb84e96..a8471fd 100644</span>
<span class="gd">--- a/babel/lists.py</span>
<span class="gi">+++ b/babel/lists.py</span>
<span class="gu">@@ -14,24 +14,28 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from babel.core import Locale, default_locale
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_LOCALE = default_locale()


<span class="gd">-def format_list(lst: Sequence[str], style: Literal[&#39;standard&#39;,</span>
<span class="gd">-    &#39;standard-short&#39;, &#39;or&#39;, &#39;or-short&#39;, &#39;unit&#39;, &#39;unit-short&#39;, &#39;unit-narrow&#39;</span>
<span class="gd">-    ]=&#39;standard&#39;, locale: (Locale | str | None)=DEFAULT_LOCALE) -&gt;str:</span>
<span class="gi">+def format_list(lst: Sequence[str],</span>
<span class="gi">+                style: Literal[&#39;standard&#39;, &#39;standard-short&#39;, &#39;or&#39;, &#39;or-short&#39;, &#39;unit&#39;, &#39;unit-short&#39;, &#39;unit-narrow&#39;] = &#39;standard&#39;,</span>
<span class="gi">+                locale: Locale | str | None = DEFAULT_LOCALE) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Format the items in `lst` as a list.

<span class="w"> </span>    &gt;&gt;&gt; format_list([&#39;apples&#39;, &#39;oranges&#39;, &#39;pears&#39;], locale=&#39;en&#39;)
<span class="w"> </span>    u&#39;apples, oranges, and pears&#39;
<span class="w"> </span>    &gt;&gt;&gt; format_list([&#39;apples&#39;, &#39;oranges&#39;, &#39;pears&#39;], locale=&#39;zh&#39;)
<span class="gd">-    u&#39;applesorangespears&#39;</span>
<span class="gi">+    u&#39;apples\u3001oranges\u548cpears&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; format_list([&#39;omena&#39;, &#39;peruna&#39;, &#39;aplari&#39;], style=&#39;or&#39;, locale=&#39;fi&#39;)
<span class="w"> </span>    u&#39;omena, peruna tai aplari&#39;

<span class="gu">@@ -66,4 +70,25 @@ def format_list(lst: Sequence[str], style: Literal[&#39;standard&#39;,</span>
<span class="w"> </span>    :param style: the style to format the list with. See above for description.
<span class="w"> </span>    :param locale: the locale
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if not lst:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    if len(lst) == 1:</span>
<span class="gi">+        return lst[0]</span>
<span class="gi">+</span>
<span class="gi">+    if style not in locale.list_patterns:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            f&#39;Locale {locale} does not support list formatting style {style!r} &#39;</span>
<span class="gi">+            f&#39;(supported are {sorted(locale.list_patterns)})&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    patterns = locale.list_patterns[style]</span>
<span class="gi">+</span>
<span class="gi">+    if len(lst) == 2:</span>
<span class="gi">+        return patterns[&#39;2&#39;].format(*lst)</span>
<span class="gi">+</span>
<span class="gi">+    result = patterns[&#39;start&#39;].format(lst[0], lst[1])</span>
<span class="gi">+    for elem in lst[2:-1]:</span>
<span class="gi">+        result = patterns[&#39;middle&#39;].format(result, elem)</span>
<span class="gi">+    result = patterns[&#39;end&#39;].format(result, lst[-1])</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/babel/localedata.py b/babel/localedata.py</span>
<span class="gh">index c54dad6..f1e8a12 100644</span>
<span class="gd">--- a/babel/localedata.py</span>
<span class="gi">+++ b/babel/localedata.py</span>
<span class="gu">@@ -10,7 +10,9 @@</span>
<span class="w"> </span>    :copyright: (c) 2013-2023 by the Babel Team.
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import pickle
<span class="w"> </span>import re
<span class="gu">@@ -21,41 +23,60 @@ from collections.abc import Iterator, Mapping, MutableMapping</span>
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>_cache: dict[str, Any] = {}
<span class="w"> </span>_cache_lock = threading.RLock()
<span class="w"> </span>_dirname = os.path.join(os.path.dirname(__file__), &#39;locale-data&#39;)
<span class="gd">-_windows_reserved_name_re = re.compile(&#39;^(con|prn|aux|nul|com[0-9]|lpt[0-9])$&#39;,</span>
<span class="gd">-    re.I)</span>
<span class="gi">+_windows_reserved_name_re = re.compile(&quot;^(con|prn|aux|nul|com[0-9]|lpt[0-9])$&quot;, re.I)</span>


<span class="gd">-def normalize_locale(name: str) -&gt;(str | None):</span>
<span class="gi">+def normalize_locale(name: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Normalize a locale ID by stripping spaces and apply proper casing.

<span class="w"> </span>    Returns the normalized locale ID string or `None` if the ID is not
<span class="w"> </span>    recognized.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not name or not isinstance(name, str):</span>
<span class="gi">+        return None</span>
<span class="gi">+    name = name.strip().lower()</span>
<span class="gi">+    for locale_id in chain.from_iterable([_cache, locale_identifiers()]):</span>
<span class="gi">+        if name == locale_id.lower():</span>
<span class="gi">+            return locale_id</span>


<span class="gd">-def resolve_locale_filename(name: (os.PathLike[str] | str)) -&gt;str:</span>
<span class="gi">+def resolve_locale_filename(name: os.PathLike[str] | str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Resolve a locale identifier to a `.dat` path on disk.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    # Clean up any possible relative paths.</span>
<span class="gi">+    name = os.path.basename(name)</span>
<span class="gi">+</span>
<span class="gi">+    # Ensure we&#39;re not left with one of the Windows reserved names.</span>
<span class="gi">+    if sys.platform == &quot;win32&quot; and _windows_reserved_name_re.match(os.path.splitext(name)[0]):</span>
<span class="gi">+        raise ValueError(f&quot;Name {name} is invalid on Windows&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Build the path.</span>
<span class="gi">+    return os.path.join(_dirname, f&quot;{name}.dat&quot;)</span>

<span class="gd">-def exists(name: str) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def exists(name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether locale data is available for the given locale.

<span class="w"> </span>    Returns `True` if it exists, `False` otherwise.

<span class="w"> </span>    :param name: the locale identifier string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not name or not isinstance(name, str):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if name in _cache:</span>
<span class="gi">+        return True</span>
<span class="gi">+    file_found = os.path.exists(resolve_locale_filename(name))</span>
<span class="gi">+    return True if file_found else bool(normalize_locale(name))</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="gd">-def locale_identifiers() -&gt;list[str]:</span>
<span class="gi">+def locale_identifiers() -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a list of all locale identifiers for which locale data is
<span class="w"> </span>    available.

<span class="gu">@@ -66,11 +87,15 @@ def locale_identifiers() -&gt;list[str]:</span>

<span class="w"> </span>    :return: a list of locale identifiers (strings)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        stem</span>
<span class="gi">+        for stem, extension in</span>
<span class="gi">+        (os.path.splitext(filename) for filename in os.listdir(_dirname))</span>
<span class="gi">+        if extension == &#39;.dat&#39; and stem != &#39;root&#39;</span>
<span class="gi">+    ]</span>


<span class="gd">-def load(name: (os.PathLike[str] | str), merge_inherited: bool=True) -&gt;dict[</span>
<span class="gd">-    str, Any]:</span>
<span class="gi">+def load(name: os.PathLike[str] | str, merge_inherited: bool = True) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load the locale data for the given locale.

<span class="w"> </span>    The locale data is a dictionary that contains much of the data defined by
<span class="gu">@@ -95,10 +120,34 @@ def load(name: (os.PathLike[str] | str), merge_inherited: bool=True) -&gt;dict[</span>
<span class="w"> </span>    :raise `IOError`: if no locale data file is found for the given locale
<span class="w"> </span>                      identifier, or one of the locales it inherits from
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def merge(dict1: MutableMapping[Any, Any], dict2: Mapping[Any, Any]) -&gt;None:</span>
<span class="gi">+    name = os.path.basename(name)</span>
<span class="gi">+    _cache_lock.acquire()</span>
<span class="gi">+    try:</span>
<span class="gi">+        data = _cache.get(name)</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            # Load inherited data</span>
<span class="gi">+            if name == &#39;root&#39; or not merge_inherited:</span>
<span class="gi">+                data = {}</span>
<span class="gi">+            else:</span>
<span class="gi">+                from babel.core import get_global</span>
<span class="gi">+                parent = get_global(&#39;parent_exceptions&#39;).get(name)</span>
<span class="gi">+                if not parent:</span>
<span class="gi">+                    parts = name.split(&#39;_&#39;)</span>
<span class="gi">+                    parent = &quot;root&quot; if len(parts) == 1 else &quot;_&quot;.join(parts[:-1])</span>
<span class="gi">+                data = load(parent).copy()</span>
<span class="gi">+            filename = resolve_locale_filename(name)</span>
<span class="gi">+            with open(filename, &#39;rb&#39;) as fileobj:</span>
<span class="gi">+                if name != &#39;root&#39; and merge_inherited:</span>
<span class="gi">+                    merge(data, pickle.load(fileobj))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data = pickle.load(fileobj)</span>
<span class="gi">+            _cache[name] = data</span>
<span class="gi">+        return data</span>
<span class="gi">+    finally:</span>
<span class="gi">+        _cache_lock.release()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge(dict1: MutableMapping[Any, Any], dict2: Mapping[Any, Any]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Merge the data from `dict2` into the `dict1` dictionary, making copies
<span class="w"> </span>    of nested dictionaries.

<span class="gu">@@ -110,7 +159,25 @@ def merge(dict1: MutableMapping[Any, Any], dict2: Mapping[Any, Any]) -&gt;None:</span>
<span class="w"> </span>    :param dict1: the dictionary to merge into
<span class="w"> </span>    :param dict2: the dictionary containing the data that should be merged
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for key, val2 in dict2.items():</span>
<span class="gi">+        if val2 is not None:</span>
<span class="gi">+            val1 = dict1.get(key)</span>
<span class="gi">+            if isinstance(val2, dict):</span>
<span class="gi">+                if val1 is None:</span>
<span class="gi">+                    val1 = {}</span>
<span class="gi">+                if isinstance(val1, Alias):</span>
<span class="gi">+                    val1 = (val1, val2)</span>
<span class="gi">+                elif isinstance(val1, tuple):</span>
<span class="gi">+                    alias, others = val1</span>
<span class="gi">+                    others = others.copy()</span>
<span class="gi">+                    merge(others, val2)</span>
<span class="gi">+                    val1 = (alias, others)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    val1 = val1.copy()</span>
<span class="gi">+                    merge(val1, val2)</span>
<span class="gi">+            else:</span>
<span class="gi">+                val1 = val2</span>
<span class="gi">+            dict1[key] = val1</span>


<span class="w"> </span>class Alias:
<span class="gu">@@ -120,14 +187,13 @@ class Alias:</span>
<span class="w"> </span>    as specified by the `keys`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, keys: tuple[str, ...]) -&gt;None:</span>
<span class="gi">+    def __init__(self, keys: tuple[str, ...]) -&gt; None:</span>
<span class="w"> </span>        self.keys = tuple(keys)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.keys!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.keys!r}&gt;&quot;</span>

<span class="gd">-    def resolve(self, data: Mapping[str | int | None, Any]) -&gt;Mapping[str |</span>
<span class="gd">-        int | None, Any]:</span>
<span class="gi">+    def resolve(self, data: Mapping[str | int | None, Any]) -&gt; Mapping[str | int | None, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolve the alias based on the given data.

<span class="w"> </span>        This is done recursively, so if one alias resolves to a second alias,
<span class="gu">@@ -136,7 +202,15 @@ class Alias:</span>
<span class="w"> </span>        :param data: the locale data
<span class="w"> </span>        :type data: `dict`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = data</span>
<span class="gi">+        for key in self.keys:</span>
<span class="gi">+            data = data[key]</span>
<span class="gi">+        if isinstance(data, Alias):</span>
<span class="gi">+            data = data.resolve(base)</span>
<span class="gi">+        elif isinstance(data, tuple):</span>
<span class="gi">+            alias, others = data</span>
<span class="gi">+            data = alias.resolve(base)</span>
<span class="gi">+        return data</span>


<span class="w"> </span>class LocaleDataDict(abc.MutableMapping):
<span class="gu">@@ -144,35 +218,37 @@ class LocaleDataDict(abc.MutableMapping):</span>
<span class="w"> </span>    values.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, data: MutableMapping[str | int | None, Any], base: (</span>
<span class="gd">-        Mapping[str | int | None, Any] | None)=None):</span>
<span class="gi">+    def __init__(self, data: MutableMapping[str | int | None, Any], base: Mapping[str | int | None, Any] | None = None):</span>
<span class="w"> </span>        self._data = data
<span class="w"> </span>        if base is None:
<span class="w"> </span>            base = data
<span class="w"> </span>        self.base = base

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._data)

<span class="gd">-    def __iter__(self) -&gt;Iterator[str | int | None]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[str | int | None]:</span>
<span class="w"> </span>        return iter(self._data)

<span class="gd">-    def __getitem__(self, key: (str | int | None)) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: str | int | None) -&gt; Any:</span>
<span class="w"> </span>        orig = val = self._data[key]
<span class="gd">-        if isinstance(val, Alias):</span>
<span class="gi">+        if isinstance(val, Alias):  # resolve an alias</span>
<span class="w"> </span>            val = val.resolve(self.base)
<span class="gd">-        if isinstance(val, tuple):</span>
<span class="gi">+        if isinstance(val, tuple):  # Merge a partial dict with an alias</span>
<span class="w"> </span>            alias, others = val
<span class="w"> </span>            val = alias.resolve(self.base).copy()
<span class="w"> </span>            merge(val, others)
<span class="gd">-        if isinstance(val, dict):</span>
<span class="gi">+        if isinstance(val, dict):  # Return a nested alias-resolving dict</span>
<span class="w"> </span>            val = LocaleDataDict(val, base=self.base)
<span class="w"> </span>        if val is not orig:
<span class="w"> </span>            self._data[key] = val
<span class="w"> </span>        return val

<span class="gd">-    def __setitem__(self, key: (str | int | None), value: Any) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: str | int | None, value: Any) -&gt; None:</span>
<span class="w"> </span>        self._data[key] = value

<span class="gd">-    def __delitem__(self, key: (str | int | None)) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key: str | int | None) -&gt; None:</span>
<span class="w"> </span>        del self._data[key]
<span class="gi">+</span>
<span class="gi">+    def copy(self) -&gt; LocaleDataDict:</span>
<span class="gi">+        return LocaleDataDict(self._data.copy(), base=self.base)</span>
<span class="gh">diff --git a/babel/localtime/_fallback.py b/babel/localtime/_fallback.py</span>
<span class="gh">index b8b4fdf..14979a5 100644</span>
<span class="gd">--- a/babel/localtime/_fallback.py</span>
<span class="gi">+++ b/babel/localtime/_fallback.py</span>
<span class="gu">@@ -7,14 +7,38 @@</span>
<span class="w"> </span>    :copyright: (c) 2013-2023 by the Babel Team.
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>STDOFFSET = datetime.timedelta(seconds=-time.timezone)
<span class="gd">-DSTOFFSET = datetime.timedelta(seconds=-time.altzone</span>
<span class="gd">-    ) if time.daylight else STDOFFSET</span>
<span class="gi">+DSTOFFSET = datetime.timedelta(seconds=-time.altzone) if time.daylight else STDOFFSET</span>
<span class="gi">+</span>
<span class="w"> </span>DSTDIFF = DSTOFFSET - STDOFFSET
<span class="w"> </span>ZERO = datetime.timedelta(0)


<span class="w"> </span>class _FallbackLocalTimezone(datetime.tzinfo):
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def utcoffset(self, dt: datetime.datetime) -&gt; datetime.timedelta:</span>
<span class="gi">+        if self._isdst(dt):</span>
<span class="gi">+            return DSTOFFSET</span>
<span class="gi">+        else:</span>
<span class="gi">+            return STDOFFSET</span>
<span class="gi">+</span>
<span class="gi">+    def dst(self, dt: datetime.datetime) -&gt; datetime.timedelta:</span>
<span class="gi">+        if self._isdst(dt):</span>
<span class="gi">+            return DSTDIFF</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ZERO</span>
<span class="gi">+</span>
<span class="gi">+    def tzname(self, dt: datetime.datetime) -&gt; str:</span>
<span class="gi">+        return time.tzname[self._isdst(dt)]</span>
<span class="gi">+</span>
<span class="gi">+    def _isdst(self, dt: datetime.datetime) -&gt; bool:</span>
<span class="gi">+        tt = (dt.year, dt.month, dt.day,</span>
<span class="gi">+              dt.hour, dt.minute, dt.second,</span>
<span class="gi">+              dt.weekday(), 0, -1)</span>
<span class="gi">+        stamp = time.mktime(tt)</span>
<span class="gi">+        tt = time.localtime(stamp)</span>
<span class="gi">+        return tt.tm_isdst &gt; 0</span>
<span class="gh">diff --git a/babel/localtime/_helpers.py b/babel/localtime/_helpers.py</span>
<span class="gh">index 821636c..f27b315 100644</span>
<span class="gd">--- a/babel/localtime/_helpers.py</span>
<span class="gi">+++ b/babel/localtime/_helpers.py</span>
<span class="gu">@@ -11,4 +11,33 @@ def _get_tzinfo(tzenv: str):</span>
<span class="w"> </span>    :param tzenv: timezone in the form of Continent/City
<span class="w"> </span>    :return: tzinfo object or None if not found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pytz:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return pytz.timezone(tzenv)</span>
<span class="gi">+        except pytz.UnknownTimeZoneError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return zoneinfo.ZoneInfo(tzenv)</span>
<span class="gi">+        except zoneinfo.ZoneInfoNotFoundError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_tzinfo_or_raise(tzenv: str):</span>
<span class="gi">+    tzinfo = _get_tzinfo(tzenv)</span>
<span class="gi">+    if tzinfo is None:</span>
<span class="gi">+        raise LookupError(</span>
<span class="gi">+            f&quot;Can not find timezone {tzenv}. \n&quot;</span>
<span class="gi">+            &quot;Timezone names are generally in the form `Continent/City`.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    return tzinfo</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_tzinfo_from_file(tzfilename: str):</span>
<span class="gi">+    with open(tzfilename, &#39;rb&#39;) as tzfile:</span>
<span class="gi">+        if pytz:</span>
<span class="gi">+            return pytz.tzfile.build_tzinfo(&#39;local&#39;, tzfile)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return zoneinfo.ZoneInfo.from_file(tzfile)</span>
<span class="gh">diff --git a/babel/localtime/_unix.py b/babel/localtime/_unix.py</span>
<span class="gh">index dd709a3..eb81beb 100644</span>
<span class="gd">--- a/babel/localtime/_unix.py</span>
<span class="gi">+++ b/babel/localtime/_unix.py</span>
<span class="gu">@@ -1,10 +1,27 @@</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gd">-from babel.localtime._helpers import _get_tzinfo, _get_tzinfo_from_file, _get_tzinfo_or_raise</span>

<span class="gi">+from babel.localtime._helpers import (</span>
<span class="gi">+    _get_tzinfo,</span>
<span class="gi">+    _get_tzinfo_from_file,</span>
<span class="gi">+    _get_tzinfo_or_raise,</span>
<span class="gi">+)</span>

<span class="gd">-def _get_localzone(_root: str=&#39;/&#39;) -&gt;datetime.tzinfo:</span>
<span class="gi">+</span>
<span class="gi">+def _tz_from_env(tzenv: str) -&gt; datetime.tzinfo:</span>
<span class="gi">+    if tzenv[0] == &#39;:&#39;:</span>
<span class="gi">+        tzenv = tzenv[1:]</span>
<span class="gi">+</span>
<span class="gi">+    # TZ specifies a file</span>
<span class="gi">+    if os.path.exists(tzenv):</span>
<span class="gi">+        return _get_tzinfo_from_file(tzenv)</span>
<span class="gi">+</span>
<span class="gi">+    # TZ specifies a zoneinfo zone.</span>
<span class="gi">+    return _get_tzinfo_or_raise(tzenv)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_localzone(_root: str = &#39;/&#39;) -&gt; datetime.tzinfo:</span>
<span class="w"> </span>    &quot;&quot;&quot;Tries to find the local timezone configuration.
<span class="w"> </span>    This method prefers finding the timezone name and passing that to
<span class="w"> </span>    zoneinfo or pytz, over passing in the localtime file, as in the later
<span class="gu">@@ -13,4 +30,69 @@ def _get_localzone(_root: str=&#39;/&#39;) -&gt;datetime.tzinfo:</span>
<span class="w"> </span>    beneath the _root directory. This is primarily used by the tests.
<span class="w"> </span>    In normal usage you call the function without parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    tzenv = os.environ.get(&#39;TZ&#39;)</span>
<span class="gi">+    if tzenv:</span>
<span class="gi">+        return _tz_from_env(tzenv)</span>
<span class="gi">+</span>
<span class="gi">+    # This is actually a pretty reliable way to test for the local time</span>
<span class="gi">+    # zone on operating systems like OS X.  On OS X especially this is the</span>
<span class="gi">+    # only one that actually works.</span>
<span class="gi">+    try:</span>
<span class="gi">+        link_dst = os.readlink(&#39;/etc/localtime&#39;)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        pos = link_dst.find(&#39;/zoneinfo/&#39;)</span>
<span class="gi">+        if pos &gt;= 0:</span>
<span class="gi">+            zone_name = link_dst[pos + 10:]</span>
<span class="gi">+            tzinfo = _get_tzinfo(zone_name)</span>
<span class="gi">+            if tzinfo is not None:</span>
<span class="gi">+                return tzinfo</span>
<span class="gi">+</span>
<span class="gi">+    # Now look for distribution specific configuration files</span>
<span class="gi">+    # that contain the timezone name.</span>
<span class="gi">+    tzpath = os.path.join(_root, &#39;etc/timezone&#39;)</span>
<span class="gi">+    if os.path.exists(tzpath):</span>
<span class="gi">+        with open(tzpath, &#39;rb&#39;) as tzfile:</span>
<span class="gi">+            data = tzfile.read()</span>
<span class="gi">+</span>
<span class="gi">+            # Issue #3 in tzlocal was that /etc/timezone was a zoneinfo file.</span>
<span class="gi">+            # That&#39;s a misconfiguration, but we need to handle it gracefully:</span>
<span class="gi">+            if data[:5] != b&#39;TZif2&#39;:</span>
<span class="gi">+                etctz = data.strip().decode()</span>
<span class="gi">+                # Get rid of host definitions and comments:</span>
<span class="gi">+                if &#39; &#39; in etctz:</span>
<span class="gi">+                    etctz, dummy = etctz.split(&#39; &#39;, 1)</span>
<span class="gi">+                if &#39;#&#39; in etctz:</span>
<span class="gi">+                    etctz, dummy = etctz.split(&#39;#&#39;, 1)</span>
<span class="gi">+</span>
<span class="gi">+                return _get_tzinfo_or_raise(etctz.replace(&#39; &#39;, &#39;_&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # CentOS has a ZONE setting in /etc/sysconfig/clock,</span>
<span class="gi">+    # OpenSUSE has a TIMEZONE setting in /etc/sysconfig/clock and</span>
<span class="gi">+    # Gentoo has a TIMEZONE setting in /etc/conf.d/clock</span>
<span class="gi">+    # We look through these files for a timezone:</span>
<span class="gi">+    timezone_re = re.compile(r&#39;\s*(TIME)?ZONE\s*=\s*&quot;(?P&lt;etctz&gt;.+)&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    for filename in (&#39;etc/sysconfig/clock&#39;, &#39;etc/conf.d/clock&#39;):</span>
<span class="gi">+        tzpath = os.path.join(_root, filename)</span>
<span class="gi">+        if not os.path.exists(tzpath):</span>
<span class="gi">+            continue</span>
<span class="gi">+        with open(tzpath) as tzfile:</span>
<span class="gi">+            for line in tzfile:</span>
<span class="gi">+                match = timezone_re.match(line)</span>
<span class="gi">+                if match is not None:</span>
<span class="gi">+                    # We found a timezone</span>
<span class="gi">+                    etctz = match.group(&quot;etctz&quot;)</span>
<span class="gi">+                    return _get_tzinfo_or_raise(etctz.replace(&#39; &#39;, &#39;_&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # No explicit setting existed. Use localtime</span>
<span class="gi">+    for filename in (&#39;etc/localtime&#39;, &#39;usr/local/etc/localtime&#39;):</span>
<span class="gi">+        tzpath = os.path.join(_root, filename)</span>
<span class="gi">+</span>
<span class="gi">+        if not os.path.exists(tzpath):</span>
<span class="gi">+            continue</span>
<span class="gi">+        return _get_tzinfo_from_file(tzpath)</span>
<span class="gi">+</span>
<span class="gi">+    raise LookupError(&#39;Can not find any timezone configuration&#39;)</span>
<span class="gh">diff --git a/babel/localtime/_win32.py b/babel/localtime/_win32.py</span>
<span class="gh">index 323c08d..1a52567 100644</span>
<span class="gd">--- a/babel/localtime/_win32.py</span>
<span class="gi">+++ b/babel/localtime/_win32.py</span>
<span class="gu">@@ -1,19 +1,98 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import winreg
<span class="w"> </span>except ImportError:
<span class="w"> </span>    winreg = None
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>from typing import Any, Dict, cast
<span class="gi">+</span>
<span class="w"> </span>from babel.core import get_global
<span class="w"> </span>from babel.localtime._helpers import _get_tzinfo_or_raise
<span class="gi">+</span>
<span class="gi">+# When building the cldr data on windows this module gets imported.</span>
<span class="gi">+# Because at that point there is no global.dat yet this call will</span>
<span class="gi">+# fail.  We want to catch it down in that case then and just assume</span>
<span class="gi">+# the mapping was empty.</span>
<span class="w"> </span>try:
<span class="gd">-    tz_names: dict[str, str] = cast(Dict[str, str], get_global(</span>
<span class="gd">-        &#39;windows_zone_mapping&#39;))</span>
<span class="gi">+    tz_names: dict[str, str] = cast(Dict[str, str], get_global(&#39;windows_zone_mapping&#39;))</span>
<span class="w"> </span>except RuntimeError:
<span class="w"> </span>    tz_names = {}


<span class="gd">-def valuestodict(key) -&gt;dict[str, Any]:</span>
<span class="gi">+def valuestodict(key) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a registry key&#39;s values to a dictionary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dict = {}</span>
<span class="gi">+    size = winreg.QueryInfoKey(key)[1]</span>
<span class="gi">+    for i in range(size):</span>
<span class="gi">+        data = winreg.EnumValue(key, i)</span>
<span class="gi">+        dict[data[0]] = data[1]</span>
<span class="gi">+    return dict</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_localzone_name() -&gt; str:</span>
<span class="gi">+    # Windows is special. It has unique time zone names (in several</span>
<span class="gi">+    # meanings of the word) available, but unfortunately, they can be</span>
<span class="gi">+    # translated to the language of the operating system, so we need to</span>
<span class="gi">+    # do a backwards lookup, by going through all time zones and see which</span>
<span class="gi">+    # one matches.</span>
<span class="gi">+    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)</span>
<span class="gi">+</span>
<span class="gi">+    TZLOCALKEYNAME = r&#39;SYSTEM\CurrentControlSet\Control\TimeZoneInformation&#39;</span>
<span class="gi">+    localtz = winreg.OpenKey(handle, TZLOCALKEYNAME)</span>
<span class="gi">+    keyvalues = valuestodict(localtz)</span>
<span class="gi">+    localtz.Close()</span>
<span class="gi">+    if &#39;TimeZoneKeyName&#39; in keyvalues:</span>
<span class="gi">+        # Windows 7 (and Vista?)</span>
<span class="gi">+</span>
<span class="gi">+        # For some reason this returns a string with loads of NUL bytes at</span>
<span class="gi">+        # least on some systems. I don&#39;t know if this is a bug somewhere, I</span>
<span class="gi">+        # just work around it.</span>
<span class="gi">+        tzkeyname = keyvalues[&#39;TimeZoneKeyName&#39;].split(&#39;\x00&#39;, 1)[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Windows 2000 or XP</span>
<span class="gi">+</span>
<span class="gi">+        # This is the localized name:</span>
<span class="gi">+        tzwin = keyvalues[&#39;StandardName&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        # Open the list of timezones to look up the real name:</span>
<span class="gi">+        TZKEYNAME = r&#39;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones&#39;</span>
<span class="gi">+        tzkey = winreg.OpenKey(handle, TZKEYNAME)</span>
<span class="gi">+</span>
<span class="gi">+        # Now, match this value to Time Zone information</span>
<span class="gi">+        tzkeyname = None</span>
<span class="gi">+        for i in range(winreg.QueryInfoKey(tzkey)[0]):</span>
<span class="gi">+            subkey = winreg.EnumKey(tzkey, i)</span>
<span class="gi">+            sub = winreg.OpenKey(tzkey, subkey)</span>
<span class="gi">+            data = valuestodict(sub)</span>
<span class="gi">+            sub.Close()</span>
<span class="gi">+            if data.get(&#39;Std&#39;, None) == tzwin:</span>
<span class="gi">+                tzkeyname = subkey</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        tzkey.Close()</span>
<span class="gi">+        handle.Close()</span>
<span class="gi">+</span>
<span class="gi">+    if tzkeyname is None:</span>
<span class="gi">+        raise LookupError(&#39;Can not find Windows timezone configuration&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    timezone = tz_names.get(tzkeyname)</span>
<span class="gi">+    if timezone is None:</span>
<span class="gi">+        # Nope, that didn&#39;t work. Try adding &#39;Standard Time&#39;,</span>
<span class="gi">+        # it seems to work a lot of times:</span>
<span class="gi">+        timezone = tz_names.get(f&quot;{tzkeyname} Standard Time&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Return what we have.</span>
<span class="gi">+    if timezone is None:</span>
<span class="gi">+        raise LookupError(f&quot;Can not find timezone {tzkeyname}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return timezone</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_localzone() -&gt; datetime.tzinfo:</span>
<span class="gi">+    if winreg is None:</span>
<span class="gi">+        raise LookupError(</span>
<span class="gi">+            &#39;Runtime support not available&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return _get_tzinfo_or_raise(get_localzone_name())</span>
<span class="gh">diff --git a/babel/messages/catalog.py b/babel/messages/catalog.py</span>
<span class="gh">index 27256d3..41adfae 100644</span>
<span class="gd">--- a/babel/messages/catalog.py</span>
<span class="gi">+++ b/babel/messages/catalog.py</span>
<span class="gu">@@ -8,6 +8,7 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import re
<span class="w"> </span>from collections import OrderedDict
<span class="gu">@@ -17,16 +18,19 @@ from difflib import SequenceMatcher</span>
<span class="w"> </span>from email import message_from_string
<span class="w"> </span>from heapq import nlargest
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from babel import __version__ as VERSION
<span class="w"> </span>from babel.core import Locale, UnknownLocaleError
<span class="w"> </span>from babel.dates import format_datetime
<span class="w"> </span>from babel.messages.plurals import get_plural
<span class="w"> </span>from babel.util import LOCALTZ, FixedOffsetTimezone, _cmp, distinct
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    _MessageID: TypeAlias = str | tuple[str, ...] | list[str]
<span class="gd">-__all__ = [&#39;Message&#39;, &#39;Catalog&#39;, &#39;TranslationError&#39;]</span>

<span class="gi">+__all__ = [&#39;Message&#39;, &#39;Catalog&#39;, &#39;TranslationError&#39;]</span>

<span class="w"> </span>def get_close_matches(word, possibilities, n=3, cutoff=0.6):
<span class="w"> </span>    &quot;&quot;&quot;A modified version of ``difflib.get_close_matches``.
<span class="gu">@@ -34,31 +38,83 @@ def get_close_matches(word, possibilities, n=3, cutoff=0.6):</span>
<span class="w"> </span>    It just passes ``autojunk=False`` to the ``SequenceMatcher``, to work
<span class="w"> </span>    around https://github.com/python/cpython/issues/90825.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-PYTHON_FORMAT = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    \\%</span>
<span class="gd">-        (?:\\(([\\w]*)\\))?</span>
<span class="gi">+    if not n &gt; 0:  # pragma: no cover</span>
<span class="gi">+        raise ValueError(f&quot;n must be &gt; 0: {n!r}&quot;)</span>
<span class="gi">+    if not 0.0 &lt;= cutoff &lt;= 1.0:  # pragma: no cover</span>
<span class="gi">+        raise ValueError(f&quot;cutoff must be in [0.0, 1.0]: {cutoff!r}&quot;)</span>
<span class="gi">+    result = []</span>
<span class="gi">+    s = SequenceMatcher(autojunk=False) # only line changed from difflib.py</span>
<span class="gi">+    s.set_seq2(word)</span>
<span class="gi">+    for x in possibilities:</span>
<span class="gi">+        s.set_seq1(x)</span>
<span class="gi">+        if s.real_quick_ratio() &gt;= cutoff and \</span>
<span class="gi">+           s.quick_ratio() &gt;= cutoff and \</span>
<span class="gi">+           s.ratio() &gt;= cutoff:</span>
<span class="gi">+            result.append((s.ratio(), x))</span>
<span class="gi">+</span>
<span class="gi">+    # Move the best scorers to head of list</span>
<span class="gi">+    result = nlargest(n, result)</span>
<span class="gi">+    # Strip scores for the best n matches</span>
<span class="gi">+    return [x for score, x in result]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+PYTHON_FORMAT = re.compile(r&#39;&#39;&#39;</span>
<span class="gi">+    \%</span>
<span class="gi">+        (?:\(([\w]*)\))?</span>
<span class="w"> </span>        (
<span class="gd">-            [-#0\\ +]?(?:\\*|[\\d]+)?</span>
<span class="gd">-            (?:\\.(?:\\*|[\\d]+))?</span>
<span class="gi">+            [-#0\ +]?(?:\*|[\d]+)?</span>
<span class="gi">+            (?:\.(?:\*|[\d]+))?</span>
<span class="w"> </span>            [hlL]?
<span class="w"> </span>        )
<span class="w"> </span>        ([diouxXeEfFgGcrs%])
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gi">+&#39;&#39;&#39;, re.VERBOSE)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_datetime_header(value: str) -&gt; datetime.datetime:</span>
<span class="gi">+    match = re.match(r&#39;^(?P&lt;datetime&gt;.*?)(?P&lt;tzoffset&gt;[+-]\d{4})?$&#39;, value)</span>
<span class="gi">+</span>
<span class="gi">+    dt = datetime.datetime.strptime(match.group(&#39;datetime&#39;), &#39;%Y-%m-%d %H:%M&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Separate the offset into a sign component, hours, and # minutes</span>
<span class="gi">+    tzoffset = match.group(&#39;tzoffset&#39;)</span>
<span class="gi">+    if tzoffset is not None:</span>
<span class="gi">+        plus_minus_s, rest = tzoffset[0], tzoffset[1:]</span>
<span class="gi">+        hours_offset_s, mins_offset_s = rest[:2], rest[2:]</span>
<span class="gi">+</span>
<span class="gi">+        # Make them all integers</span>
<span class="gi">+        plus_minus = int(f&quot;{plus_minus_s}1&quot;)</span>
<span class="gi">+        hours_offset = int(hours_offset_s)</span>
<span class="gi">+        mins_offset = int(mins_offset_s)</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate net offset</span>
<span class="gi">+        net_mins_offset = hours_offset * 60</span>
<span class="gi">+        net_mins_offset += mins_offset</span>
<span class="gi">+        net_mins_offset *= plus_minus</span>
<span class="gi">+</span>
<span class="gi">+        # Create an offset object</span>
<span class="gi">+        tzoffset = FixedOffsetTimezone(net_mins_offset)</span>
<span class="gi">+</span>
<span class="gi">+        # Store the offset in a datetime object</span>
<span class="gi">+        dt = dt.replace(tzinfo=tzoffset)</span>
<span class="gi">+</span>
<span class="gi">+    return dt</span>


<span class="w"> </span>class Message:
<span class="w"> </span>    &quot;&quot;&quot;Representation of a single message in a catalog.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, id: _MessageID, string: (_MessageID | None)=&#39;&#39;,</span>
<span class="gd">-        locations: Iterable[tuple[str, int]]=(), flags: Iterable[str]=(),</span>
<span class="gd">-        auto_comments: Iterable[str]=(), user_comments: Iterable[str]=(),</span>
<span class="gd">-        previous_id: _MessageID=(), lineno: (int | None)=None, context: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        id: _MessageID,</span>
<span class="gi">+        string: _MessageID | None = &#39;&#39;,</span>
<span class="gi">+        locations: Iterable[tuple[str, int]] = (),</span>
<span class="gi">+        flags: Iterable[str] = (),</span>
<span class="gi">+        auto_comments: Iterable[str] = (),</span>
<span class="gi">+        user_comments: Iterable[str] = (),</span>
<span class="gi">+        previous_id: _MessageID = (),</span>
<span class="gi">+        lineno: int | None = None,</span>
<span class="gi">+        context: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the message object.

<span class="w"> </span>        :param id: the message ID, or a ``(singular, plural)`` tuple for
<span class="gu">@@ -77,7 +133,7 @@ class Message:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.id = id
<span class="w"> </span>        if not string and self.pluralizable:
<span class="gd">-            string = &#39;&#39;, &#39;&#39;</span>
<span class="gi">+            string = (&#39;&#39;, &#39;&#39;)</span>
<span class="w"> </span>        self.string = string
<span class="w"> </span>        self.locations = list(distinct(locations))
<span class="w"> </span>        self.flags = set(flags)
<span class="gu">@@ -94,45 +150,49 @@ class Message:</span>
<span class="w"> </span>        self.lineno = lineno
<span class="w"> </span>        self.context = context

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;{type(self).__name__} {self.id!r} (flags: {list(self.flags)!r})&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.id!r} (flags: {list(self.flags)!r})&gt;&quot;</span>

<span class="gd">-    def __cmp__(self, other: object) -&gt;int:</span>
<span class="gi">+    def __cmp__(self, other: object) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compare Messages, taking into account plural ids&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>        def values_to_compare(obj):
<span class="w"> </span>            if isinstance(obj, Message) and obj.pluralizable:
<span class="w"> </span>                return obj.id[0], obj.context or &#39;&#39;
<span class="w"> </span>            return obj.id, obj.context or &#39;&#39;
<span class="w"> </span>        return _cmp(values_to_compare(self), values_to_compare(other))

<span class="gd">-    def __gt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &gt; 0

<span class="gd">-    def __lt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &lt; 0

<span class="gd">-    def __ge__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &gt;= 0

<span class="gd">-    def __le__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &lt;= 0

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) == 0

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) != 0

<span class="gd">-    def is_identical(self, other: Message) -&gt;bool:</span>
<span class="gi">+    def is_identical(self, other: Message) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks whether messages are identical, taking into account all
<span class="w"> </span>        properties.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(other, Message)</span>
<span class="gi">+        return self.__dict__ == other.__dict__</span>
<span class="gi">+</span>
<span class="gi">+    def clone(self) -&gt; Message:</span>
<span class="gi">+        return Message(*map(copy, (self.id, self.string, self.locations,</span>
<span class="gi">+                                   self.flags, self.auto_comments,</span>
<span class="gi">+                                   self.user_comments, self.previous_id,</span>
<span class="gi">+                                   self.lineno, self.context)))</span>

<span class="gd">-    def check(self, catalog: (Catalog | None)=None) -&gt;list[TranslationError]:</span>
<span class="gi">+    def check(self, catalog: Catalog | None = None) -&gt; list[TranslationError]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Run various validation checks on the message.  Some validations
<span class="w"> </span>        are only performed if the catalog is provided.  This method returns
<span class="w"> </span>        a sequence of `TranslationError` objects.
<span class="gu">@@ -142,10 +202,17 @@ class Message:</span>
<span class="w"> </span>        :see: `Catalog.check` for a way to perform checks for all messages
<span class="w"> </span>              in a catalog.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from babel.messages.checkers import checkers</span>
<span class="gi">+        errors: list[TranslationError] = []</span>
<span class="gi">+        for checker in checkers:</span>
<span class="gi">+            try:</span>
<span class="gi">+                checker(catalog, self)</span>
<span class="gi">+            except TranslationError as e:</span>
<span class="gi">+                errors.append(e)</span>
<span class="gi">+        return errors</span>

<span class="w"> </span>    @property
<span class="gd">-    def fuzzy(self) -&gt;bool:</span>
<span class="gi">+    def fuzzy(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether the translation is fuzzy.

<span class="w"> </span>        &gt;&gt;&gt; Message(&#39;foo&#39;).fuzzy
<span class="gu">@@ -157,10 +224,10 @@ class Message:</span>
<span class="w"> </span>        &lt;Message &#39;foo&#39; (flags: [&#39;fuzzy&#39;])&gt;

<span class="w"> </span>        :type:  `bool`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;fuzzy&#39; in self.flags</span>

<span class="w"> </span>    @property
<span class="gd">-    def pluralizable(self) -&gt;bool:</span>
<span class="gi">+    def pluralizable(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether the message is plurizable.

<span class="w"> </span>        &gt;&gt;&gt; Message(&#39;foo&#39;).pluralizable
<span class="gu">@@ -169,10 +236,10 @@ class Message:</span>
<span class="w"> </span>        True

<span class="w"> </span>        :type:  `bool`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return isinstance(self.id, (list, tuple))</span>

<span class="w"> </span>    @property
<span class="gd">-    def python_format(self) -&gt;bool:</span>
<span class="gi">+    def python_format(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether the message contains Python-style parameters.

<span class="w"> </span>        &gt;&gt;&gt; Message(&#39;foo %(name)s bar&#39;).python_format
<span class="gu">@@ -181,7 +248,10 @@ class Message:</span>
<span class="w"> </span>        True

<span class="w"> </span>        :type:  `bool`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ids = self.id</span>
<span class="gi">+        if not isinstance(ids, (list, tuple)):</span>
<span class="gi">+            ids = [ids]</span>
<span class="gi">+        return any(PYTHON_FORMAT.search(id) for id in ids)</span>


<span class="w"> </span>class TranslationError(Exception):
<span class="gu">@@ -189,24 +259,41 @@ class TranslationError(Exception):</span>
<span class="w"> </span>    translations are encountered.&quot;&quot;&quot;


<span class="gd">-DEFAULT_HEADER = &quot;&quot;&quot;# Translations template for PROJECT.</span>
<span class="gi">+DEFAULT_HEADER = &quot;&quot;&quot;\</span>
<span class="gi">+# Translations template for PROJECT.</span>
<span class="w"> </span># Copyright (C) YEAR ORGANIZATION
<span class="w"> </span># This file is distributed under the same license as the PROJECT project.
<span class="w"> </span># FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.
<span class="w"> </span>#&quot;&quot;&quot;


<span class="gi">+def parse_separated_header(value: str) -&gt; dict[str, str]:</span>
<span class="gi">+    # Adapted from https://peps.python.org/pep-0594/#cgi</span>
<span class="gi">+    from email.message import Message</span>
<span class="gi">+    m = Message()</span>
<span class="gi">+    m[&#39;content-type&#39;] = value</span>
<span class="gi">+    return dict(m.get_params())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Catalog:
<span class="w"> </span>    &quot;&quot;&quot;Representation of a message catalog.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, locale: (str | Locale | None)=None, domain: (str |</span>
<span class="gd">-        None)=None, header_comment: (str | None)=DEFAULT_HEADER, project: (</span>
<span class="gd">-        str | None)=None, version: (str | None)=None, copyright_holder: (</span>
<span class="gd">-        str | None)=None, msgid_bugs_address: (str | None)=None,</span>
<span class="gd">-        creation_date: (datetime.datetime | str | None)=None, revision_date:</span>
<span class="gd">-        (datetime.datetime | datetime.time | float | str | None)=None,</span>
<span class="gd">-        last_translator: (str | None)=None, language_team: (str | None)=</span>
<span class="gd">-        None, charset: (str | None)=None, fuzzy: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        locale: str | Locale | None = None,</span>
<span class="gi">+        domain: str | None = None,</span>
<span class="gi">+        header_comment: str | None = DEFAULT_HEADER,</span>
<span class="gi">+        project: str | None = None,</span>
<span class="gi">+        version: str | None = None,</span>
<span class="gi">+        copyright_holder: str | None = None,</span>
<span class="gi">+        msgid_bugs_address: str | None = None,</span>
<span class="gi">+        creation_date: datetime.datetime | str | None = None,</span>
<span class="gi">+        revision_date: datetime.datetime | datetime.time | float | str | None = None,</span>
<span class="gi">+        last_translator: str | None = None,</span>
<span class="gi">+        language_team: str | None = None,</span>
<span class="gi">+        charset: str | None = None,</span>
<span class="gi">+        fuzzy: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the catalog object.

<span class="w"> </span>        :param locale: the locale identifier or `Locale` object, or `None`
<span class="gu">@@ -230,39 +317,86 @@ class Catalog:</span>
<span class="w"> </span>        self.domain = domain
<span class="w"> </span>        self.locale = locale
<span class="w"> </span>        self._header_comment = header_comment
<span class="gd">-        self._messages: OrderedDict[str | tuple[str, str], Message</span>
<span class="gd">-            ] = OrderedDict()</span>
<span class="gi">+        self._messages: OrderedDict[str | tuple[str, str], Message] = OrderedDict()</span>
<span class="gi">+</span>
<span class="w"> </span>        self.project = project or &#39;PROJECT&#39;
<span class="w"> </span>        self.version = version or &#39;VERSION&#39;
<span class="w"> </span>        self.copyright_holder = copyright_holder or &#39;ORGANIZATION&#39;
<span class="w"> </span>        self.msgid_bugs_address = msgid_bugs_address or &#39;EMAIL@ADDRESS&#39;
<span class="gi">+</span>
<span class="w"> </span>        self.last_translator = last_translator or &#39;FULL NAME &lt;EMAIL@ADDRESS&gt;&#39;
<span class="w"> </span>        &quot;&quot;&quot;Name and email address of the last translator.&quot;&quot;&quot;
<span class="w"> </span>        self.language_team = language_team or &#39;LANGUAGE &lt;LL@li.org&gt;&#39;
<span class="w"> </span>        &quot;&quot;&quot;Name and email address of the language team.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.charset = charset or &#39;utf-8&#39;
<span class="gi">+</span>
<span class="w"> </span>        if creation_date is None:
<span class="w"> </span>            creation_date = datetime.datetime.now(LOCALTZ)
<span class="gd">-        elif isinstance(creation_date, datetime.datetime</span>
<span class="gd">-            ) and not creation_date.tzinfo:</span>
<span class="gi">+        elif isinstance(creation_date, datetime.datetime) and not creation_date.tzinfo:</span>
<span class="w"> </span>            creation_date = creation_date.replace(tzinfo=LOCALTZ)
<span class="w"> </span>        self.creation_date = creation_date
<span class="w"> </span>        if revision_date is None:
<span class="w"> </span>            revision_date = &#39;YEAR-MO-DA HO:MI+ZONE&#39;
<span class="gd">-        elif isinstance(revision_date, datetime.datetime</span>
<span class="gd">-            ) and not revision_date.tzinfo:</span>
<span class="gi">+        elif isinstance(revision_date, datetime.datetime) and not revision_date.tzinfo:</span>
<span class="w"> </span>            revision_date = revision_date.replace(tzinfo=LOCALTZ)
<span class="w"> </span>        self.revision_date = revision_date
<span class="w"> </span>        self.fuzzy = fuzzy
<span class="gd">-        self.obsolete: OrderedDict[str | tuple[str, str], Message</span>
<span class="gd">-            ] = OrderedDict()</span>
<span class="gi">+</span>
<span class="gi">+        # Dictionary of obsolete messages</span>
<span class="gi">+        self.obsolete: OrderedDict[str | tuple[str, str], Message] = OrderedDict()</span>
<span class="w"> </span>        self._num_plurals = None
<span class="w"> </span>        self._plural_expr = None
<span class="gi">+</span>
<span class="gi">+    def _set_locale(self, locale: Locale | str | None) -&gt; None:</span>
<span class="gi">+        if locale is None:</span>
<span class="gi">+            self._locale_identifier = None</span>
<span class="gi">+            self._locale = None</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(locale, Locale):</span>
<span class="gi">+            self._locale_identifier = str(locale)</span>
<span class="gi">+            self._locale = locale</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(locale, str):</span>
<span class="gi">+            self._locale_identifier = str(locale)</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._locale = Locale.parse(locale)</span>
<span class="gi">+            except UnknownLocaleError:</span>
<span class="gi">+                self._locale = None</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        raise TypeError(f&quot;`locale` must be a Locale, a locale identifier string, or None; got {locale!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locale(self) -&gt; Locale | None:</span>
<span class="gi">+        return self._locale</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locale_identifier(self) -&gt; str | None:</span>
<span class="gi">+        return self._locale_identifier</span>
<span class="gi">+</span>
<span class="w"> </span>    locale = property(_get_locale, _set_locale)
<span class="w"> </span>    locale_identifier = property(_get_locale_identifier)
<span class="gd">-    header_comment = property(_get_header_comment, _set_header_comment, doc</span>
<span class="gd">-        =</span>
<span class="gd">-        &quot;&quot;&quot;    The header comment for the catalog.</span>
<span class="gi">+</span>
<span class="gi">+    def _get_header_comment(self) -&gt; str:</span>
<span class="gi">+        comment = self._header_comment</span>
<span class="gi">+        year = datetime.datetime.now(LOCALTZ).strftime(&#39;%Y&#39;)</span>
<span class="gi">+        if hasattr(self.revision_date, &#39;strftime&#39;):</span>
<span class="gi">+            year = self.revision_date.strftime(&#39;%Y&#39;)</span>
<span class="gi">+        comment = comment.replace(&#39;PROJECT&#39;, self.project) \</span>
<span class="gi">+                         .replace(&#39;VERSION&#39;, self.version) \</span>
<span class="gi">+                         .replace(&#39;YEAR&#39;, year) \</span>
<span class="gi">+                         .replace(&#39;ORGANIZATION&#39;, self.copyright_holder)</span>
<span class="gi">+        locale_name = (self.locale.english_name if self.locale else self.locale_identifier)</span>
<span class="gi">+        if locale_name:</span>
<span class="gi">+            comment = comment.replace(&quot;Translations template&quot;, f&quot;{locale_name} translations&quot;)</span>
<span class="gi">+        return comment</span>
<span class="gi">+</span>
<span class="gi">+    def _set_header_comment(self, string: str | None) -&gt; None:</span>
<span class="gi">+        self._header_comment = string</span>
<span class="gi">+</span>
<span class="gi">+    header_comment = property(_get_header_comment, _set_header_comment, doc=&quot;&quot;&quot;\</span>
<span class="gi">+    The header comment for the catalog.</span>

<span class="w"> </span>    &gt;&gt;&gt; catalog = Catalog(project=&#39;Foobar&#39;, version=&#39;1.0&#39;,
<span class="w"> </span>    ...                   copyright_holder=&#39;Foo Company&#39;)
<span class="gu">@@ -292,10 +426,79 @@ class Catalog:</span>
<span class="w"> </span>    #

<span class="w"> </span>    :type: `unicode`
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gd">-    mime_headers = property(_get_mime_headers, _set_mime_headers, doc=</span>
<span class="gd">-        &quot;&quot;&quot;    The MIME headers of the catalog, used for the special ``msgid &quot;&quot;`` entry.</span>
<span class="gi">+    &quot;&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_mime_headers(self) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+        headers: list[tuple[str, str]] = []</span>
<span class="gi">+        headers.append((&quot;Project-Id-Version&quot;, f&quot;{self.project} {self.version}&quot;))</span>
<span class="gi">+        headers.append((&#39;Report-Msgid-Bugs-To&#39;, self.msgid_bugs_address))</span>
<span class="gi">+        headers.append((&#39;POT-Creation-Date&#39;,</span>
<span class="gi">+                        format_datetime(self.creation_date, &#39;yyyy-MM-dd HH:mmZ&#39;,</span>
<span class="gi">+                                        locale=&#39;en&#39;)))</span>
<span class="gi">+        if isinstance(self.revision_date, (datetime.datetime, datetime.time, int, float)):</span>
<span class="gi">+            headers.append((&#39;PO-Revision-Date&#39;,</span>
<span class="gi">+                            format_datetime(self.revision_date,</span>
<span class="gi">+                                            &#39;yyyy-MM-dd HH:mmZ&#39;, locale=&#39;en&#39;)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            headers.append((&#39;PO-Revision-Date&#39;, self.revision_date))</span>
<span class="gi">+        headers.append((&#39;Last-Translator&#39;, self.last_translator))</span>
<span class="gi">+        if self.locale_identifier:</span>
<span class="gi">+            headers.append((&#39;Language&#39;, str(self.locale_identifier)))</span>
<span class="gi">+        if self.locale_identifier and (&#39;LANGUAGE&#39; in self.language_team):</span>
<span class="gi">+            headers.append((&#39;Language-Team&#39;,</span>
<span class="gi">+                            self.language_team.replace(&#39;LANGUAGE&#39;,</span>
<span class="gi">+                                                       str(self.locale_identifier))))</span>
<span class="gi">+        else:</span>
<span class="gi">+            headers.append((&#39;Language-Team&#39;, self.language_team))</span>
<span class="gi">+        if self.locale is not None:</span>
<span class="gi">+            headers.append((&#39;Plural-Forms&#39;, self.plural_forms))</span>
<span class="gi">+        headers.append((&#39;MIME-Version&#39;, &#39;1.0&#39;))</span>
<span class="gi">+        headers.append((&quot;Content-Type&quot;, f&quot;text/plain; charset={self.charset}&quot;))</span>
<span class="gi">+        headers.append((&#39;Content-Transfer-Encoding&#39;, &#39;8bit&#39;))</span>
<span class="gi">+        headers.append((&quot;Generated-By&quot;, f&quot;Babel {VERSION}\n&quot;))</span>
<span class="gi">+        return headers</span>
<span class="gi">+</span>
<span class="gi">+    def _force_text(self, s: str | bytes, encoding: str = &#39;utf-8&#39;, errors: str = &#39;strict&#39;) -&gt; str:</span>
<span class="gi">+        if isinstance(s, str):</span>
<span class="gi">+            return s</span>
<span class="gi">+        if isinstance(s, bytes):</span>
<span class="gi">+            return s.decode(encoding, errors)</span>
<span class="gi">+        return str(s)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_mime_headers(self, headers: Iterable[tuple[str, str]]) -&gt; None:</span>
<span class="gi">+        for name, value in headers:</span>
<span class="gi">+            name = self._force_text(name.lower(), encoding=self.charset)</span>
<span class="gi">+            value = self._force_text(value, encoding=self.charset)</span>
<span class="gi">+            if name == &#39;project-id-version&#39;:</span>
<span class="gi">+                parts = value.split(&#39; &#39;)</span>
<span class="gi">+                self.project = &#39; &#39;.join(parts[:-1])</span>
<span class="gi">+                self.version = parts[-1]</span>
<span class="gi">+            elif name == &#39;report-msgid-bugs-to&#39;:</span>
<span class="gi">+                self.msgid_bugs_address = value</span>
<span class="gi">+            elif name == &#39;last-translator&#39;:</span>
<span class="gi">+                self.last_translator = value</span>
<span class="gi">+            elif name == &#39;language&#39;:</span>
<span class="gi">+                value = value.replace(&#39;-&#39;, &#39;_&#39;)</span>
<span class="gi">+                self._set_locale(value)</span>
<span class="gi">+            elif name == &#39;language-team&#39;:</span>
<span class="gi">+                self.language_team = value</span>
<span class="gi">+            elif name == &#39;content-type&#39;:</span>
<span class="gi">+                params = parse_separated_header(value)</span>
<span class="gi">+                if &#39;charset&#39; in params:</span>
<span class="gi">+                    self.charset = params[&#39;charset&#39;].lower()</span>
<span class="gi">+            elif name == &#39;plural-forms&#39;:</span>
<span class="gi">+                params = parse_separated_header(f&quot; ;{value}&quot;)</span>
<span class="gi">+                self._num_plurals = int(params.get(&#39;nplurals&#39;, 2))</span>
<span class="gi">+                self._plural_expr = params.get(&#39;plural&#39;, &#39;(n != 1)&#39;)</span>
<span class="gi">+            elif name == &#39;pot-creation-date&#39;:</span>
<span class="gi">+                self.creation_date = _parse_datetime_header(value)</span>
<span class="gi">+            elif name == &#39;po-revision-date&#39;:</span>
<span class="gi">+                # Keep the value if it&#39;s not the default one</span>
<span class="gi">+                if &#39;YEAR&#39; not in value:</span>
<span class="gi">+                    self.revision_date = _parse_datetime_header(value)</span>
<span class="gi">+</span>
<span class="gi">+    mime_headers = property(_get_mime_headers, _set_mime_headers, doc=&quot;&quot;&quot;\</span>
<span class="gi">+    The MIME headers of the catalog, used for the special ``msgid &quot;&quot;`` entry.</span>

<span class="w"> </span>    The behavior of this property changes slightly depending on whether a locale
<span class="w"> </span>    is set or not, the latter indicating that the catalog is actually a template
<span class="gu">@@ -344,11 +547,10 @@ class Catalog:</span>
<span class="w"> </span>    Generated-By: Babel ...

<span class="w"> </span>    :type: `list`
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+    &quot;&quot;&quot;)</span>

<span class="w"> </span>    @property
<span class="gd">-    def num_plurals(self) -&gt;int:</span>
<span class="gi">+    def num_plurals(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The number of plurals used by the catalog or locale.

<span class="w"> </span>        &gt;&gt;&gt; Catalog(locale=&#39;en&#39;).num_plurals
<span class="gu">@@ -357,10 +559,15 @@ class Catalog:</span>
<span class="w"> </span>        5

<span class="w"> </span>        :type: `int`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._num_plurals is None:</span>
<span class="gi">+            num = 2</span>
<span class="gi">+            if self.locale:</span>
<span class="gi">+                num = get_plural(self.locale)[0]</span>
<span class="gi">+            self._num_plurals = num</span>
<span class="gi">+        return self._num_plurals</span>

<span class="w"> </span>    @property
<span class="gd">-    def plural_expr(self) -&gt;str:</span>
<span class="gi">+    def plural_expr(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The plural expression used by the catalog or locale.

<span class="w"> </span>        &gt;&gt;&gt; Catalog(locale=&#39;en&#39;).plural_expr
<span class="gu">@@ -371,10 +578,15 @@ class Catalog:</span>
<span class="w"> </span>        &#39;(n != 1)&#39;

<span class="w"> </span>        :type: `str`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._plural_expr is None:</span>
<span class="gi">+            expr = &#39;(n != 1)&#39;</span>
<span class="gi">+            if self.locale:</span>
<span class="gi">+                expr = get_plural(self.locale)[1]</span>
<span class="gi">+            self._plural_expr = expr</span>
<span class="gi">+        return self._plural_expr</span>

<span class="w"> </span>    @property
<span class="gd">-    def plural_forms(self) -&gt;str:</span>
<span class="gi">+    def plural_forms(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the plural forms declaration for the locale.

<span class="w"> </span>        &gt;&gt;&gt; Catalog(locale=&#39;en&#39;).plural_forms
<span class="gu">@@ -383,26 +595,26 @@ class Catalog:</span>
<span class="w"> </span>        &#39;nplurals=2; plural=(n &gt; 1);&#39;

<span class="w"> </span>        :type: `str`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;nplurals={self.num_plurals}; plural={self.plural_expr};&quot;</span>

<span class="gd">-    def __contains__(self, id: _MessageID) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, id: _MessageID) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether the catalog has a message with the specified ID.&quot;&quot;&quot;
<span class="w"> </span>        return self._key_for(id) in self._messages

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The number of messages in the catalog.

<span class="w"> </span>        This does not include the special ``msgid &quot;&quot;`` entry.&quot;&quot;&quot;
<span class="w"> </span>        return len(self._messages)

<span class="gd">-    def __iter__(self) -&gt;Iterator[Message]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Message]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterates through all the entries in the catalog, in the order they
<span class="w"> </span>        were added, yielding a `Message` object for every entry.

<span class="w"> </span>        :rtype: ``iterator``&quot;&quot;&quot;
<span class="w"> </span>        buf = []
<span class="w"> </span>        for name, value in self.mime_headers:
<span class="gd">-            buf.append(f&#39;{name}: {value}&#39;)</span>
<span class="gi">+            buf.append(f&quot;{name}: {value}&quot;)</span>
<span class="w"> </span>        flags = set()
<span class="w"> </span>        if self.fuzzy:
<span class="w"> </span>            flags |= {&#39;fuzzy&#39;}
<span class="gu">@@ -410,24 +622,24 @@ class Catalog:</span>
<span class="w"> </span>        for key in self._messages:
<span class="w"> </span>            yield self._messages[key]

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        locale = &#39;&#39;
<span class="w"> </span>        if self.locale:
<span class="gd">-            locale = f&#39; {self.locale}&#39;</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.domain!r}{locale}&gt;&#39;</span>
<span class="gi">+            locale = f&quot; {self.locale}&quot;</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.domain!r}{locale}&gt;&quot;</span>

<span class="gd">-    def __delitem__(self, id: _MessageID) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, id: _MessageID) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete the message with the specified ID.&quot;&quot;&quot;
<span class="w"> </span>        self.delete(id)

<span class="gd">-    def __getitem__(self, id: _MessageID) -&gt;Message:</span>
<span class="gi">+    def __getitem__(self, id: _MessageID) -&gt; Message:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the message with the specified ID.

<span class="w"> </span>        :param id: the message ID
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self.get(id)

<span class="gd">-    def __setitem__(self, id: _MessageID, message: Message) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, id: _MessageID, message: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add or update the message with the specified ID.

<span class="w"> </span>        &gt;&gt;&gt; catalog = Catalog()
<span class="gu">@@ -454,32 +666,40 @@ class Catalog:</span>
<span class="w"> </span>        current = self._messages.get(key)
<span class="w"> </span>        if current:
<span class="w"> </span>            if message.pluralizable and not current.pluralizable:
<span class="gi">+                # The new message adds pluralization</span>
<span class="w"> </span>                current.id = message.id
<span class="w"> </span>                current.string = message.string
<span class="gd">-            current.locations = list(distinct(current.locations + message.</span>
<span class="gd">-                locations))</span>
<span class="gi">+            current.locations = list(distinct(current.locations +</span>
<span class="gi">+                                              message.locations))</span>
<span class="w"> </span>            current.auto_comments = list(distinct(current.auto_comments +
<span class="gd">-                message.auto_comments))</span>
<span class="gi">+                                                  message.auto_comments))</span>
<span class="w"> </span>            current.user_comments = list(distinct(current.user_comments +
<span class="gd">-                message.user_comments))</span>
<span class="gi">+                                                  message.user_comments))</span>
<span class="w"> </span>            current.flags |= message.flags
<span class="w"> </span>            message = current
<span class="w"> </span>        elif id == &#39;&#39;:
<span class="gi">+            # special treatment for the header message</span>
<span class="w"> </span>            self.mime_headers = message_from_string(message.string).items()
<span class="gd">-            self.header_comment = &#39;\n&#39;.join([f&#39;# {c}&#39;.rstrip() for c in</span>
<span class="gd">-                message.user_comments])</span>
<span class="gi">+            self.header_comment = &quot;\n&quot;.join([f&quot;# {c}&quot;.rstrip() for c in message.user_comments])</span>
<span class="w"> </span>            self.fuzzy = message.fuzzy
<span class="w"> </span>        else:
<span class="w"> </span>            if isinstance(id, (list, tuple)):
<span class="gd">-                assert isinstance(message.string, (list, tuple)</span>
<span class="gd">-                    ), f&#39;Expected sequence but got {type(message.string)}&#39;</span>
<span class="gi">+                assert isinstance(message.string, (list, tuple)), \</span>
<span class="gi">+                    f&quot;Expected sequence but got {type(message.string)}&quot;</span>
<span class="w"> </span>            self._messages[key] = message

<span class="gd">-    def add(self, id: _MessageID, string: (_MessageID | None)=None,</span>
<span class="gd">-        locations: Iterable[tuple[str, int]]=(), flags: Iterable[str]=(),</span>
<span class="gd">-        auto_comments: Iterable[str]=(), user_comments: Iterable[str]=(),</span>
<span class="gd">-        previous_id: _MessageID=(), lineno: (int | None)=None, context: (</span>
<span class="gd">-        str | None)=None) -&gt;Message:</span>
<span class="gi">+    def add(</span>
<span class="gi">+        self,</span>
<span class="gi">+        id: _MessageID,</span>
<span class="gi">+        string: _MessageID | None = None,</span>
<span class="gi">+        locations: Iterable[tuple[str, int]] = (),</span>
<span class="gi">+        flags: Iterable[str] = (),</span>
<span class="gi">+        auto_comments: Iterable[str] = (),</span>
<span class="gi">+        user_comments: Iterable[str] = (),</span>
<span class="gi">+        previous_id: _MessageID = (),</span>
<span class="gi">+        lineno: int | None = None,</span>
<span class="gi">+        context: str | None = None,</span>
<span class="gi">+    ) -&gt; Message:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add or update the message with the specified ID.

<span class="w"> </span>        &gt;&gt;&gt; catalog = Catalog()
<span class="gu">@@ -505,9 +725,13 @@ class Catalog:</span>
<span class="w"> </span>                       PO file, if any
<span class="w"> </span>        :param context: the message context
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = Message(id, string, list(locations), flags, auto_comments,</span>
<span class="gi">+                          user_comments, previous_id, lineno=lineno,</span>
<span class="gi">+                          context=context)</span>
<span class="gi">+        self[id] = message</span>
<span class="gi">+        return message</span>

<span class="gd">-    def check(self) -&gt;Iterable[tuple[Message, list[TranslationError]]]:</span>
<span class="gi">+    def check(self) -&gt; Iterable[tuple[Message, list[TranslationError]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Run various validation checks on the translations in the catalog.

<span class="w"> </span>        For every message which fails validation, this method yield a
<span class="gu">@@ -516,28 +740,37 @@ class Catalog:</span>

<span class="w"> </span>        :rtype: ``generator`` of ``(message, errors)``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for message in self._messages.values():</span>
<span class="gi">+            errors = message.check(catalog=self)</span>
<span class="gi">+            if errors:</span>
<span class="gi">+                yield message, errors</span>

<span class="gd">-    def get(self, id: _MessageID, context: (str | None)=None) -&gt;(Message | None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def get(self, id: _MessageID, context: str | None = None) -&gt; Message | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the message with the specified ID and context.

<span class="w"> </span>        :param id: the message ID
<span class="w"> </span>        :param context: the message context, or ``None`` for no context
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._messages.get(self._key_for(id, context))</span>

<span class="gd">-    def delete(self, id: _MessageID, context: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def delete(self, id: _MessageID, context: str | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete the message with the specified ID and context.

<span class="w"> </span>        :param id: the message ID
<span class="w"> </span>        :param context: the message context, or ``None`` for no context
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def update(self, template: Catalog, no_fuzzy_matching: bool=False,</span>
<span class="gd">-        update_header_comment: bool=False, keep_user_comments: bool=True,</span>
<span class="gd">-        update_creation_date: bool=True) -&gt;None:</span>
<span class="gi">+        key = self._key_for(id, context)</span>
<span class="gi">+        if key in self._messages:</span>
<span class="gi">+            del self._messages[key]</span>
<span class="gi">+</span>
<span class="gi">+    def update(</span>
<span class="gi">+        self,</span>
<span class="gi">+        template: Catalog,</span>
<span class="gi">+        no_fuzzy_matching: bool = False,</span>
<span class="gi">+        update_header_comment: bool = False,</span>
<span class="gi">+        keep_user_comments: bool = True,</span>
<span class="gi">+        update_creation_date: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the catalog based on the given template catalog.

<span class="w"> </span>        &gt;&gt;&gt; from babel.messages import Catalog
<span class="gu">@@ -590,22 +823,126 @@ class Catalog:</span>
<span class="w"> </span>        :param template: the reference catalog, usually read from a POT file
<span class="w"> </span>        :param no_fuzzy_matching: whether to use fuzzy matching of message IDs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _to_fuzzy_match_key(self, key: (tuple[str, str] | str)) -&gt;str:</span>
<span class="gi">+        messages = self._messages</span>
<span class="gi">+        remaining = messages.copy()</span>
<span class="gi">+        self._messages = OrderedDict()</span>
<span class="gi">+</span>
<span class="gi">+        # Prepare for fuzzy matching</span>
<span class="gi">+        fuzzy_candidates = {}</span>
<span class="gi">+        if not no_fuzzy_matching:</span>
<span class="gi">+            for msgid in messages:</span>
<span class="gi">+                if msgid and messages[msgid].string:</span>
<span class="gi">+                    key = self._key_for(msgid)</span>
<span class="gi">+                    ctxt = messages[msgid].context</span>
<span class="gi">+                    fuzzy_candidates[self._to_fuzzy_match_key(key)] = (key, ctxt)</span>
<span class="gi">+        fuzzy_matches = set()</span>
<span class="gi">+</span>
<span class="gi">+        def _merge(message: Message, oldkey: tuple[str, str] | str, newkey: tuple[str, str] | str) -&gt; None:</span>
<span class="gi">+            message = message.clone()</span>
<span class="gi">+            fuzzy = False</span>
<span class="gi">+            if oldkey != newkey:</span>
<span class="gi">+                fuzzy = True</span>
<span class="gi">+                fuzzy_matches.add(oldkey)</span>
<span class="gi">+                oldmsg = messages.get(oldkey)</span>
<span class="gi">+                assert oldmsg is not None</span>
<span class="gi">+                if isinstance(oldmsg.id, str):</span>
<span class="gi">+                    message.previous_id = [oldmsg.id]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    message.previous_id = list(oldmsg.id)</span>
<span class="gi">+            else:</span>
<span class="gi">+                oldmsg = remaining.pop(oldkey, None)</span>
<span class="gi">+                assert oldmsg is not None</span>
<span class="gi">+            message.string = oldmsg.string</span>
<span class="gi">+</span>
<span class="gi">+            if keep_user_comments:</span>
<span class="gi">+                message.user_comments = list(distinct(oldmsg.user_comments))</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(message.id, (list, tuple)):</span>
<span class="gi">+                if not isinstance(message.string, (list, tuple)):</span>
<span class="gi">+                    fuzzy = True</span>
<span class="gi">+                    message.string = tuple(</span>
<span class="gi">+                        [message.string] + ([&#39;&#39;] * (len(message.id) - 1)),</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif len(message.string) != self.num_plurals:</span>
<span class="gi">+                    fuzzy = True</span>
<span class="gi">+                    message.string = tuple(message.string[:len(oldmsg.string)])</span>
<span class="gi">+            elif isinstance(message.string, (list, tuple)):</span>
<span class="gi">+                fuzzy = True</span>
<span class="gi">+                message.string = message.string[0]</span>
<span class="gi">+            message.flags |= oldmsg.flags</span>
<span class="gi">+            if fuzzy:</span>
<span class="gi">+                message.flags |= {&#39;fuzzy&#39;}</span>
<span class="gi">+            self[message.id] = message</span>
<span class="gi">+</span>
<span class="gi">+        for message in template:</span>
<span class="gi">+            if message.id:</span>
<span class="gi">+                key = self._key_for(message.id, message.context)</span>
<span class="gi">+                if key in messages:</span>
<span class="gi">+                    _merge(message, key, key)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not no_fuzzy_matching:</span>
<span class="gi">+                        # do some fuzzy matching with difflib</span>
<span class="gi">+                        matches = get_close_matches(</span>
<span class="gi">+                            self._to_fuzzy_match_key(key),</span>
<span class="gi">+                            fuzzy_candidates.keys(),</span>
<span class="gi">+                            1,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if matches:</span>
<span class="gi">+                            modified_key = matches[0]</span>
<span class="gi">+                            newkey, newctxt = fuzzy_candidates[modified_key]</span>
<span class="gi">+                            if newctxt is not None:</span>
<span class="gi">+                                newkey = newkey, newctxt</span>
<span class="gi">+                            _merge(message, newkey, key)</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                    self[message.id] = message</span>
<span class="gi">+</span>
<span class="gi">+        for msgid in remaining:</span>
<span class="gi">+            if no_fuzzy_matching or msgid not in fuzzy_matches:</span>
<span class="gi">+                self.obsolete[msgid] = remaining[msgid]</span>
<span class="gi">+</span>
<span class="gi">+        if update_header_comment:</span>
<span class="gi">+            # Allow the updated catalog&#39;s header to be rewritten based on the</span>
<span class="gi">+            # template&#39;s header</span>
<span class="gi">+            self.header_comment = template.header_comment</span>
<span class="gi">+</span>
<span class="gi">+        # Make updated catalog&#39;s POT-Creation-Date equal to the template</span>
<span class="gi">+        # used to update the catalog</span>
<span class="gi">+        if update_creation_date:</span>
<span class="gi">+            self.creation_date = template.creation_date</span>
<span class="gi">+</span>
<span class="gi">+    def _to_fuzzy_match_key(self, key: tuple[str, str] | str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a message key to a string suitable for fuzzy matching.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(key, tuple):</span>
<span class="gi">+            matchkey = key[0]  # just the msgid, no context</span>
<span class="gi">+        else:</span>
<span class="gi">+            matchkey = key</span>
<span class="gi">+        return matchkey.lower().strip()</span>

<span class="gd">-    def _key_for(self, id: _MessageID, context: (str | None)=None) -&gt;(tuple</span>
<span class="gd">-        [str, str] | str):</span>
<span class="gi">+    def _key_for(self, id: _MessageID, context: str | None = None) -&gt; tuple[str, str] | str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The key for a message is just the singular ID even for pluralizable
<span class="w"> </span>        messages, but is a ``(msgid, msgctxt)`` tuple for context-specific
<span class="w"> </span>        messages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def is_identical(self, other: Catalog) -&gt;bool:</span>
<span class="gi">+        key = id</span>
<span class="gi">+        if isinstance(key, (list, tuple)):</span>
<span class="gi">+            key = id[0]</span>
<span class="gi">+        if context is not None:</span>
<span class="gi">+            key = (key, context)</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    def is_identical(self, other: Catalog) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if catalogs are identical, taking into account messages and
<span class="w"> </span>        headers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(other, Catalog)</span>
<span class="gi">+        for key in self._messages.keys() | other._messages.keys():</span>
<span class="gi">+            message_1 = self.get(key)</span>
<span class="gi">+            message_2 = other.get(key)</span>
<span class="gi">+            if (</span>
<span class="gi">+                message_1 is None</span>
<span class="gi">+                or message_2 is None</span>
<span class="gi">+                or not message_1.is_identical(message_2)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+        return dict(self.mime_headers) == dict(other.mime_headers)</span>
<span class="gh">diff --git a/babel/messages/checkers.py b/babel/messages/checkers.py</span>
<span class="gh">index 0161061..e5448e0 100644</span>
<span class="gd">--- a/babel/messages/checkers.py</span>
<span class="gi">+++ b/babel/messages/checkers.py</span>
<span class="gu">@@ -10,23 +10,56 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Callable
<span class="gi">+</span>
<span class="w"> </span>from babel.messages.catalog import PYTHON_FORMAT, Catalog, Message, TranslationError
<span class="gd">-_string_format_compatibilities = [{&#39;i&#39;, &#39;d&#39;, &#39;u&#39;}, {&#39;x&#39;, &#39;X&#39;}, {&#39;f&#39;, &#39;F&#39;,</span>
<span class="gd">-    &#39;g&#39;, &#39;G&#39;}]</span>

<span class="gi">+#: list of format chars that are compatible to each other</span>
<span class="gi">+_string_format_compatibilities = [</span>
<span class="gi">+    {&#39;i&#39;, &#39;d&#39;, &#39;u&#39;},</span>
<span class="gi">+    {&#39;x&#39;, &#39;X&#39;},</span>
<span class="gi">+    {&#39;f&#39;, &#39;F&#39;, &#39;g&#39;, &#39;G&#39;},</span>
<span class="gi">+]</span>

<span class="gd">-def num_plurals(catalog: (Catalog | None), message: Message) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def num_plurals(catalog: Catalog | None, message: Message) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify the number of plurals in the translation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not message.pluralizable:</span>
<span class="gi">+        if not isinstance(message.string, str):</span>
<span class="gi">+            raise TranslationError(&quot;Found plural forms for non-pluralizable &quot;</span>
<span class="gi">+                                   &quot;message&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # skip further tests if no catalog is provided.</span>
<span class="gi">+    elif catalog is None:</span>
<span class="gi">+        return</span>

<span class="gi">+    msgstrs = message.string</span>
<span class="gi">+    if not isinstance(msgstrs, (list, tuple)):</span>
<span class="gi">+        msgstrs = (msgstrs,)</span>
<span class="gi">+    if len(msgstrs) != catalog.num_plurals:</span>
<span class="gi">+        raise TranslationError(&quot;Wrong number of plural forms (expected %d)&quot; %</span>
<span class="gi">+                               catalog.num_plurals)</span>

<span class="gd">-def python_format(catalog: (Catalog | None), message: Message) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def python_format(catalog: Catalog | None, message: Message) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify the format string placeholders in the translation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;python-format&#39; not in message.flags:</span>
<span class="gi">+        return</span>
<span class="gi">+    msgids = message.id</span>
<span class="gi">+    if not isinstance(msgids, (list, tuple)):</span>
<span class="gi">+        msgids = (msgids,)</span>
<span class="gi">+    msgstrs = message.string</span>
<span class="gi">+    if not isinstance(msgstrs, (list, tuple)):</span>
<span class="gi">+        msgstrs = (msgstrs,)</span>
<span class="gi">+</span>
<span class="gi">+    for msgid, msgstr in zip(msgids, msgstrs):</span>
<span class="gi">+        if msgstr:</span>
<span class="gi">+            _validate_format(msgid, msgstr)</span>


<span class="gd">-def _validate_format(format: str, alternative: str) -&gt;None:</span>
<span class="gi">+def _validate_format(format: str, alternative: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Test format string `alternative` against `format`.  `format` can be the
<span class="w"> </span>    msgid of a message and `alternative` one of the `msgstr`\\s.  The two
<span class="w"> </span>    arguments are not interchangeable as `alternative` may contain less
<span class="gu">@@ -57,7 +90,84 @@ def _validate_format(format: str, alternative: str) -&gt;None:</span>
<span class="w"> </span>                        against format
<span class="w"> </span>    :raises TranslationError: on formatting errors
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _parse(string: str) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+        result: list[tuple[str, str]] = []</span>
<span class="gi">+        for match in PYTHON_FORMAT.finditer(string):</span>
<span class="gi">+            name, format, typechar = match.groups()</span>
<span class="gi">+            if typechar == &#39;%&#39; and name is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            result.append((name, str(typechar)))</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _compatible(a: str, b: str) -&gt; bool:</span>
<span class="gi">+        if a == b:</span>
<span class="gi">+            return True</span>
<span class="gi">+        for set in _string_format_compatibilities:</span>
<span class="gi">+            if a in set and b in set:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _check_positional(results: list[tuple[str, str]]) -&gt; bool:</span>
<span class="gi">+        positional = None</span>
<span class="gi">+        for name, _char in results:</span>
<span class="gi">+            if positional is None:</span>
<span class="gi">+                positional = name is None</span>
<span class="gi">+            else:</span>
<span class="gi">+                if (name is None) != positional:</span>
<span class="gi">+                    raise TranslationError(&#39;format string mixes positional &#39;</span>
<span class="gi">+                                           &#39;and named placeholders&#39;)</span>
<span class="gi">+        return bool(positional)</span>
<span class="gi">+</span>
<span class="gi">+    a, b = map(_parse, (format, alternative))</span>
<span class="gi">+</span>
<span class="gi">+    # now check if both strings are positional or named</span>
<span class="gi">+    a_positional, b_positional = map(_check_positional, (a, b))</span>
<span class="gi">+    if a_positional and not b_positional and not b:</span>
<span class="gi">+        raise TranslationError(&#39;placeholders are incompatible&#39;)</span>
<span class="gi">+    elif a_positional != b_positional:</span>
<span class="gi">+        raise TranslationError(&#39;the format strings are of different kinds&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # if we are operating on positional strings both must have the</span>
<span class="gi">+    # same number of format chars and those must be compatible</span>
<span class="gi">+    if a_positional:</span>
<span class="gi">+        if len(a) != len(b):</span>
<span class="gi">+            raise TranslationError(&#39;positional format placeholders are &#39;</span>
<span class="gi">+                                   &#39;unbalanced&#39;)</span>
<span class="gi">+        for idx, ((_, first), (_, second)) in enumerate(zip(a, b)):</span>
<span class="gi">+            if not _compatible(first, second):</span>
<span class="gi">+                raise TranslationError(&#39;incompatible format for placeholder &#39;</span>
<span class="gi">+                                       &#39;%d: %r and %r are not compatible&#39; %</span>
<span class="gi">+                                       (idx + 1, first, second))</span>
<span class="gi">+</span>
<span class="gi">+    # otherwise the second string must not have names the first one</span>
<span class="gi">+    # doesn&#39;t have and the types of those included must be compatible</span>
<span class="gi">+    else:</span>
<span class="gi">+        type_map = dict(a)</span>
<span class="gi">+        for name, typechar in b:</span>
<span class="gi">+            if name not in type_map:</span>
<span class="gi">+                raise TranslationError(f&#39;unknown named placeholder {name!r}&#39;)</span>
<span class="gi">+            elif not _compatible(typechar, type_map[name]):</span>
<span class="gi">+                raise TranslationError(</span>
<span class="gi">+                    f&#39;incompatible format for placeholder {name!r}: &#39;</span>
<span class="gi">+                    f&#39;{typechar!r} and {type_map[name]!r} are not compatible&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_checkers() -&gt; list[Callable[[Catalog | None, Message], object]]:</span>
<span class="gi">+    checkers: list[Callable[[Catalog | None, Message], object]] = []</span>
<span class="gi">+    try:</span>
<span class="gi">+        from pkg_resources import working_set</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        for entry_point in working_set.iter_entry_points(&#39;babel.checkers&#39;):</span>
<span class="gi">+            checkers.append(entry_point.load())</span>
<span class="gi">+    if len(checkers) == 0:</span>
<span class="gi">+        # if pkg_resources is not available or no usable egg-info was found</span>
<span class="gi">+        # (see #230), just resort to hard-coded checkers</span>
<span class="gi">+        return [num_plurals, python_format]</span>
<span class="gi">+    return checkers</span>


<span class="w"> </span>checkers: list[Callable[[Catalog | None, Message], object]] = _find_checkers()
<span class="gh">diff --git a/babel/messages/extract.py b/babel/messages/extract.py</span>
<span class="gh">index 8af8da4..b13f1a9 100644</span>
<span class="gd">--- a/babel/messages/extract.py</span>
<span class="gi">+++ b/babel/messages/extract.py</span>
<span class="gu">@@ -16,72 +16,115 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import io
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>import tokenize
<span class="gd">-from collections.abc import Callable, Collection, Generator, Iterable, Mapping, MutableSequence</span>
<span class="gi">+from collections.abc import (</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Collection,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    MutableSequence,</span>
<span class="gi">+)</span>
<span class="w"> </span>from os.path import relpath
<span class="w"> </span>from textwrap import dedent
<span class="w"> </span>from tokenize import COMMENT, NAME, OP, STRING, generate_tokens
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from babel.util import parse_encoding, parse_future_flags, pathmatch
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import IO, Protocol
<span class="gi">+</span>
<span class="w"> </span>    from _typeshed import SupportsItems, SupportsRead, SupportsReadline
<span class="w"> </span>    from typing_extensions import Final, TypeAlias, TypedDict

<span class="gd">-</span>
<span class="gd">-    class _PyOptions(TypedDict, total=(False)):</span>
<span class="gi">+    class _PyOptions(TypedDict, total=False):</span>
<span class="w"> </span>        encoding: str

<span class="gd">-</span>
<span class="gd">-    class _JSOptions(TypedDict, total=(False)):</span>
<span class="gi">+    class _JSOptions(TypedDict, total=False):</span>
<span class="w"> </span>        encoding: str
<span class="w"> </span>        jsx: bool
<span class="w"> </span>        template_string: bool
<span class="w"> </span>        parse_template_string: bool

<span class="gd">-</span>
<span class="w"> </span>    class _FileObj(SupportsRead[bytes], SupportsReadline[bytes], Protocol):
<span class="gd">-        pass</span>
<span class="gd">-    _SimpleKeyword: TypeAlias = tuple[int | tuple[int, int] | tuple[int,</span>
<span class="gd">-        str], ...] | None</span>
<span class="gi">+        def seek(self, __offset: int, __whence: int = ...) -&gt; int: ...</span>
<span class="gi">+        def tell(self) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    _SimpleKeyword: TypeAlias = tuple[int | tuple[int, int] | tuple[int, str], ...] | None</span>
<span class="w"> </span>    _Keyword: TypeAlias = dict[int | None, _SimpleKeyword] | _SimpleKeyword
<span class="gd">-    _FileExtractionResult: TypeAlias = tuple[str, int, str | tuple[str, ...</span>
<span class="gd">-        ], list[str], str | None]</span>
<span class="gd">-    _ExtractionResult: TypeAlias = tuple[int, str | tuple[str, ...], list[</span>
<span class="gd">-        str], str | None]</span>
<span class="gd">-    _CallableExtractionMethod: TypeAlias = Callable[[_FileObj | IO[bytes],</span>
<span class="gd">-        Mapping[str, _Keyword], Collection[str], Mapping[str, Any]],</span>
<span class="gd">-        Iterable[_ExtractionResult]]</span>
<span class="gi">+</span>
<span class="gi">+    # 5-tuple of (filename, lineno, messages, comments, context)</span>
<span class="gi">+    _FileExtractionResult: TypeAlias = tuple[str, int, str | tuple[str, ...], list[str], str | None]</span>
<span class="gi">+</span>
<span class="gi">+    # 4-tuple of (lineno, message, comments, context)</span>
<span class="gi">+    _ExtractionResult: TypeAlias = tuple[int, str | tuple[str, ...], list[str], str | None]</span>
<span class="gi">+</span>
<span class="gi">+    # Required arguments: fileobj, keywords, comment_tags, options</span>
<span class="gi">+    # Return value: Iterable of (lineno, message, comments, context)</span>
<span class="gi">+    _CallableExtractionMethod: TypeAlias = Callable[</span>
<span class="gi">+        [_FileObj | IO[bytes], Mapping[str, _Keyword], Collection[str], Mapping[str, Any]],</span>
<span class="gi">+        Iterable[_ExtractionResult],</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>    _ExtractionMethod: TypeAlias = _CallableExtractionMethod | str
<span class="gi">+</span>
<span class="w"> </span>GROUP_NAME: Final[str] = &#39;babel.extractors&#39;
<span class="gd">-DEFAULT_KEYWORDS: dict[str, _Keyword] = {&#39;_&#39;: None, &#39;gettext&#39;: None,</span>
<span class="gd">-    &#39;ngettext&#39;: (1, 2), &#39;ugettext&#39;: None, &#39;ungettext&#39;: (1, 2), &#39;dgettext&#39;:</span>
<span class="gd">-    (2,), &#39;dngettext&#39;: (2, 3), &#39;N_&#39;: None, &#39;pgettext&#39;: ((1, &#39;c&#39;), 2),</span>
<span class="gd">-    &#39;npgettext&#39;: ((1, &#39;c&#39;), 2, 3)}</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_KEYWORDS: dict[str, _Keyword] = {</span>
<span class="gi">+    &#39;_&#39;: None,</span>
<span class="gi">+    &#39;gettext&#39;: None,</span>
<span class="gi">+    &#39;ngettext&#39;: (1, 2),</span>
<span class="gi">+    &#39;ugettext&#39;: None,</span>
<span class="gi">+    &#39;ungettext&#39;: (1, 2),</span>
<span class="gi">+    &#39;dgettext&#39;: (2,),</span>
<span class="gi">+    &#39;dngettext&#39;: (2, 3),</span>
<span class="gi">+    &#39;N_&#39;: None,</span>
<span class="gi">+    &#39;pgettext&#39;: ((1, &#39;c&#39;), 2),</span>
<span class="gi">+    &#39;npgettext&#39;: ((1, &#39;c&#39;), 2, 3),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_MAPPING: list[tuple[str, str]] = [(&#39;**.py&#39;, &#39;python&#39;)]
<span class="gd">-FSTRING_START = getattr(tokenize, &#39;FSTRING_START&#39;, None)</span>
<span class="gd">-FSTRING_MIDDLE = getattr(tokenize, &#39;FSTRING_MIDDLE&#39;, None)</span>
<span class="gd">-FSTRING_END = getattr(tokenize, &#39;FSTRING_END&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+# New tokens in Python 3.12, or None on older versions</span>
<span class="gi">+FSTRING_START = getattr(tokenize, &quot;FSTRING_START&quot;, None)</span>
<span class="gi">+FSTRING_MIDDLE = getattr(tokenize, &quot;FSTRING_MIDDLE&quot;, None)</span>
<span class="gi">+FSTRING_END = getattr(tokenize, &quot;FSTRING_END&quot;, None)</span>


<span class="w"> </span>def _strip_comment_tags(comments: MutableSequence[str], tags: Iterable[str]):
<span class="w"> </span>    &quot;&quot;&quot;Helper function for `extract` that strips comment tags from strings
<span class="w"> </span>    in a list of comment lines.  This functions operates in-place.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract_from_dir(dirname: (str | os.PathLike[str] | None)=None,</span>
<span class="gd">-    method_map: Iterable[tuple[str, str]]=DEFAULT_MAPPING, options_map: (</span>
<span class="gd">-    SupportsItems[str, dict[str, Any]] | None)=None, keywords: Mapping[str,</span>
<span class="gd">-    _Keyword]=DEFAULT_KEYWORDS, comment_tags: Collection[str]=(), callback:</span>
<span class="gd">-    (Callable[[str, str, dict[str, Any]], object] | None)=None,</span>
<span class="gd">-    strip_comment_tags: bool=False, directory_filter: (Callable[[str], bool</span>
<span class="gd">-    ] | None)=None) -&gt;Generator[_FileExtractionResult, None, None]:</span>
<span class="gi">+    def _strip(line: str):</span>
<span class="gi">+        for tag in tags:</span>
<span class="gi">+            if line.startswith(tag):</span>
<span class="gi">+                return line[len(tag):].strip()</span>
<span class="gi">+        return line</span>
<span class="gi">+    comments[:] = map(_strip, comments)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_directory_filter(dirpath: str | os.PathLike[str]) -&gt; bool:</span>
<span class="gi">+    subdir = os.path.basename(dirpath)</span>
<span class="gi">+    # Legacy default behavior: ignore dot and underscore directories</span>
<span class="gi">+    return not (subdir.startswith(&#39;.&#39;) or subdir.startswith(&#39;_&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_from_dir(</span>
<span class="gi">+    dirname: str | os.PathLike[str] | None = None,</span>
<span class="gi">+    method_map: Iterable[tuple[str, str]] = DEFAULT_MAPPING,</span>
<span class="gi">+    options_map: SupportsItems[str, dict[str, Any]] | None = None,</span>
<span class="gi">+    keywords: Mapping[str, _Keyword] = DEFAULT_KEYWORDS,</span>
<span class="gi">+    comment_tags: Collection[str] = (),</span>
<span class="gi">+    callback: Callable[[str, str, dict[str, Any]], object] | None = None,</span>
<span class="gi">+    strip_comment_tags: bool = False,</span>
<span class="gi">+    directory_filter: Callable[[str], bool] | None = None,</span>
<span class="gi">+) -&gt; Generator[_FileExtractionResult, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract messages from any source files found in the given directory.

<span class="w"> </span>    This function generates tuples of the form ``(filename, lineno, message,
<span class="gu">@@ -151,15 +194,46 @@ def extract_from_dir(dirname: (str | os.PathLike[str] | None)=None,</span>
<span class="w"> </span>                             should return True if the directory is valid.
<span class="w"> </span>    :see: `pathmatch`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def check_and_call_extract_file(filepath: (str | os.PathLike[str]),</span>
<span class="gd">-    method_map: Iterable[tuple[str, str]], options_map: SupportsItems[str,</span>
<span class="gd">-    dict[str, Any]], callback: (Callable[[str, str, dict[str, Any]], object</span>
<span class="gd">-    ] | None), keywords: Mapping[str, _Keyword], comment_tags: Collection[</span>
<span class="gd">-    str], strip_comment_tags: bool, dirpath: (str | os.PathLike[str] | None</span>
<span class="gd">-    )=None) -&gt;Generator[_FileExtractionResult, None, None]:</span>
<span class="gi">+    if dirname is None:</span>
<span class="gi">+        dirname = os.getcwd()</span>
<span class="gi">+    if options_map is None:</span>
<span class="gi">+        options_map = {}</span>
<span class="gi">+    if directory_filter is None:</span>
<span class="gi">+        directory_filter = default_directory_filter</span>
<span class="gi">+</span>
<span class="gi">+    absname = os.path.abspath(dirname)</span>
<span class="gi">+    for root, dirnames, filenames in os.walk(absname):</span>
<span class="gi">+        dirnames[:] = [</span>
<span class="gi">+            subdir for subdir in dirnames</span>
<span class="gi">+            if directory_filter(os.path.join(root, subdir))</span>
<span class="gi">+        ]</span>
<span class="gi">+        dirnames.sort()</span>
<span class="gi">+        filenames.sort()</span>
<span class="gi">+        for filename in filenames:</span>
<span class="gi">+            filepath = os.path.join(root, filename).replace(os.sep, &#39;/&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            yield from check_and_call_extract_file(</span>
<span class="gi">+                filepath,</span>
<span class="gi">+                method_map,</span>
<span class="gi">+                options_map,</span>
<span class="gi">+                callback,</span>
<span class="gi">+                keywords,</span>
<span class="gi">+                comment_tags,</span>
<span class="gi">+                strip_comment_tags,</span>
<span class="gi">+                dirpath=absname,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def check_and_call_extract_file(</span>
<span class="gi">+    filepath: str | os.PathLike[str],</span>
<span class="gi">+    method_map: Iterable[tuple[str, str]],</span>
<span class="gi">+    options_map: SupportsItems[str, dict[str, Any]],</span>
<span class="gi">+    callback: Callable[[str, str, dict[str, Any]], object] | None,</span>
<span class="gi">+    keywords: Mapping[str, _Keyword],</span>
<span class="gi">+    comment_tags: Collection[str],</span>
<span class="gi">+    strip_comment_tags: bool,</span>
<span class="gi">+    dirpath: str | os.PathLike[str] | None = None,</span>
<span class="gi">+) -&gt; Generator[_FileExtractionResult, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if the given file matches an extraction method mapping, and if so, calls extract_from_file.

<span class="w"> </span>    Note that the extraction method mappings are based relative to dirpath.
<span class="gu">@@ -189,13 +263,39 @@ def check_and_call_extract_file(filepath: (str | os.PathLike[str]),</span>
<span class="w"> </span>    :return: iterable of 5-tuples (filename, lineno, messages, comments, context)
<span class="w"> </span>    :rtype: Iterable[tuple[str, int, str|tuple[str], list[str], str|None]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract_from_file(method: _ExtractionMethod, filename: (str | os.</span>
<span class="gd">-    PathLike[str]), keywords: Mapping[str, _Keyword]=DEFAULT_KEYWORDS,</span>
<span class="gd">-    comment_tags: Collection[str]=(), options: (Mapping[str, Any] | None)=</span>
<span class="gd">-    None, strip_comment_tags: bool=False) -&gt;list[_ExtractionResult]:</span>
<span class="gi">+    # filename is the relative path from dirpath to the actual file</span>
<span class="gi">+    filename = relpath(filepath, dirpath)</span>
<span class="gi">+</span>
<span class="gi">+    for pattern, method in method_map:</span>
<span class="gi">+        if not pathmatch(pattern, filename):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        options = {}</span>
<span class="gi">+        for opattern, odict in options_map.items():</span>
<span class="gi">+            if pathmatch(opattern, filename):</span>
<span class="gi">+                options = odict</span>
<span class="gi">+        if callback:</span>
<span class="gi">+            callback(filename, method, options)</span>
<span class="gi">+        for message_tuple in extract_from_file(</span>
<span class="gi">+            method, filepath,</span>
<span class="gi">+            keywords=keywords,</span>
<span class="gi">+            comment_tags=comment_tags,</span>
<span class="gi">+            options=options,</span>
<span class="gi">+            strip_comment_tags=strip_comment_tags,</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield (filename, *message_tuple)</span>
<span class="gi">+</span>
<span class="gi">+        break</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_from_file(</span>
<span class="gi">+    method: _ExtractionMethod,</span>
<span class="gi">+    filename: str | os.PathLike[str],</span>
<span class="gi">+    keywords: Mapping[str, _Keyword] = DEFAULT_KEYWORDS,</span>
<span class="gi">+    comment_tags: Collection[str] = (),</span>
<span class="gi">+    options: Mapping[str, Any] | None = None,</span>
<span class="gi">+    strip_comment_tags: bool = False,</span>
<span class="gi">+) -&gt; list[_ExtractionResult]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract messages from a specific file.

<span class="w"> </span>    This function returns a list of tuples of the form ``(lineno, message, comments, context)``.
<span class="gu">@@ -214,13 +314,63 @@ def extract_from_file(method: _ExtractionMethod, filename: (str | os.</span>
<span class="w"> </span>    :returns: list of tuples of the form ``(lineno, message, comments, context)``
<span class="w"> </span>    :rtype: list[tuple[int, str|tuple[str], list[str], str|None]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract(method: _ExtractionMethod, fileobj: _FileObj, keywords: Mapping</span>
<span class="gd">-    [str, _Keyword]=DEFAULT_KEYWORDS, comment_tags: Collection[str]=(),</span>
<span class="gd">-    options: (Mapping[str, Any] | None)=None, strip_comment_tags: bool=False</span>
<span class="gd">-    ) -&gt;Generator[_ExtractionResult, None, None]:</span>
<span class="gi">+    if method == &#39;ignore&#39;:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as fileobj:</span>
<span class="gi">+        return list(extract(method, fileobj, keywords, comment_tags,</span>
<span class="gi">+                            options, strip_comment_tags))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _match_messages_against_spec(lineno: int, messages: list[str|None], comments: list[str],</span>
<span class="gi">+                                 fileobj: _FileObj, spec: tuple[int|tuple[int, str], ...]):</span>
<span class="gi">+    translatable = []</span>
<span class="gi">+    context = None</span>
<span class="gi">+</span>
<span class="gi">+    # last_index is 1 based like the keyword spec</span>
<span class="gi">+    last_index = len(messages)</span>
<span class="gi">+    for index in spec:</span>
<span class="gi">+        if isinstance(index, tuple): # (n, &#39;c&#39;)</span>
<span class="gi">+            context = messages[index[0] - 1]</span>
<span class="gi">+            continue</span>
<span class="gi">+        if last_index &lt; index:</span>
<span class="gi">+            # Not enough arguments</span>
<span class="gi">+            return</span>
<span class="gi">+        message = messages[index - 1]</span>
<span class="gi">+        if message is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        translatable.append(message)</span>
<span class="gi">+</span>
<span class="gi">+    # keyword spec indexes are 1 based, therefore &#39;-1&#39;</span>
<span class="gi">+    if isinstance(spec[0], tuple):</span>
<span class="gi">+        # context-aware *gettext method</span>
<span class="gi">+        first_msg_index = spec[1] - 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        first_msg_index = spec[0] - 1</span>
<span class="gi">+    # An empty string msgid isn&#39;t valid, emit a warning</span>
<span class="gi">+    if not messages[first_msg_index]:</span>
<span class="gi">+        filename = (getattr(fileobj, &quot;name&quot;, None) or &quot;(unknown)&quot;)</span>
<span class="gi">+        sys.stderr.write(</span>
<span class="gi">+            f&quot;{filename}:{lineno}: warning: Empty msgid.  It is reserved by GNU gettext: gettext(\&quot;\&quot;) &quot;</span>
<span class="gi">+            f&quot;returns the header entry with meta information, not the empty string.\n&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    translatable = tuple(translatable)</span>
<span class="gi">+    if len(translatable) == 1:</span>
<span class="gi">+        translatable = translatable[0]</span>
<span class="gi">+</span>
<span class="gi">+    return lineno, translatable, comments, context</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract(</span>
<span class="gi">+    method: _ExtractionMethod,</span>
<span class="gi">+    fileobj: _FileObj,</span>
<span class="gi">+    keywords: Mapping[str, _Keyword] = DEFAULT_KEYWORDS,</span>
<span class="gi">+    comment_tags: Collection[str] = (),</span>
<span class="gi">+    options: Mapping[str, Any] | None = None,</span>
<span class="gi">+    strip_comment_tags: bool = False,</span>
<span class="gi">+) -&gt; Generator[_ExtractionResult, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract messages from the given file-like object using the specified
<span class="w"> </span>    extraction method.

<span class="gu">@@ -260,21 +410,88 @@ def extract(method: _ExtractionMethod, fileobj: _FileObj, keywords: Mapping</span>
<span class="w"> </span>    :returns: iterable of tuples of the form ``(lineno, message, comments, context)``
<span class="w"> </span>    :rtype: Iterable[tuple[int, str|tuple[str], list[str], str|None]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract_nothing(fileobj: _FileObj, keywords: Mapping[str, _Keyword],</span>
<span class="gd">-    comment_tags: Collection[str], options: Mapping[str, Any]) -&gt;list[</span>
<span class="gd">-    _ExtractionResult]:</span>
<span class="gi">+    func = None</span>
<span class="gi">+    if callable(method):</span>
<span class="gi">+        func = method</span>
<span class="gi">+    elif &#39;:&#39; in method or &#39;.&#39; in method:</span>
<span class="gi">+        if &#39;:&#39; not in method:</span>
<span class="gi">+            lastdot = method.rfind(&#39;.&#39;)</span>
<span class="gi">+            module, attrname = method[:lastdot], method[lastdot + 1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            module, attrname = method.split(&#39;:&#39;, 1)</span>
<span class="gi">+        func = getattr(__import__(module, {}, {}, [attrname]), attrname)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            from pkg_resources import working_set</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            for entry_point in working_set.iter_entry_points(GROUP_NAME,</span>
<span class="gi">+                                                             method):</span>
<span class="gi">+                func = entry_point.load(require=True)</span>
<span class="gi">+                break</span>
<span class="gi">+        if func is None:</span>
<span class="gi">+            # if pkg_resources is not available or no usable egg-info was found</span>
<span class="gi">+            # (see #230), we resort to looking up the builtin extractors</span>
<span class="gi">+            # directly</span>
<span class="gi">+            builtin = {</span>
<span class="gi">+                &#39;ignore&#39;: extract_nothing,</span>
<span class="gi">+                &#39;python&#39;: extract_python,</span>
<span class="gi">+                &#39;javascript&#39;: extract_javascript,</span>
<span class="gi">+            }</span>
<span class="gi">+            func = builtin.get(method)</span>
<span class="gi">+</span>
<span class="gi">+    if func is None:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown extraction method {method!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    results = func(fileobj, keywords.keys(), comment_tags,</span>
<span class="gi">+                   options=options or {})</span>
<span class="gi">+</span>
<span class="gi">+    for lineno, funcname, messages, comments in results:</span>
<span class="gi">+        if not isinstance(messages, (list, tuple)):</span>
<span class="gi">+            messages = [messages]</span>
<span class="gi">+        if not messages:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        specs = keywords[funcname] or None if funcname else None</span>
<span class="gi">+        # {None: x} may be collapsed into x for backwards compatibility.</span>
<span class="gi">+        if not isinstance(specs, dict):</span>
<span class="gi">+            specs = {None: specs}</span>
<span class="gi">+</span>
<span class="gi">+        if strip_comment_tags:</span>
<span class="gi">+            _strip_comment_tags(comments, comment_tags)</span>
<span class="gi">+</span>
<span class="gi">+        # None matches all arities.</span>
<span class="gi">+        for arity in (None, len(messages)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                spec = specs[arity]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if spec is None:</span>
<span class="gi">+                spec = (1,)</span>
<span class="gi">+            result = _match_messages_against_spec(lineno, messages, comments, fileobj, spec)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_nothing(</span>
<span class="gi">+    fileobj: _FileObj,</span>
<span class="gi">+    keywords: Mapping[str, _Keyword],</span>
<span class="gi">+    comment_tags: Collection[str],</span>
<span class="gi">+    options: Mapping[str, Any],</span>
<span class="gi">+) -&gt; list[_ExtractionResult]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pseudo extractor that does not actually extract anything, but simply
<span class="w"> </span>    returns an empty list.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return []</span>


<span class="gd">-def extract_python(fileobj: IO[bytes], keywords: Mapping[str, _Keyword],</span>
<span class="gd">-    comment_tags: Collection[str], options: _PyOptions) -&gt;Generator[</span>
<span class="gd">-    _ExtractionResult, None, None]:</span>
<span class="gi">+def extract_python(</span>
<span class="gi">+    fileobj: IO[bytes],</span>
<span class="gi">+    keywords: Mapping[str, _Keyword],</span>
<span class="gi">+    comment_tags: Collection[str],</span>
<span class="gi">+    options: _PyOptions,</span>
<span class="gi">+) -&gt; Generator[_ExtractionResult, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract messages from Python source code.

<span class="w"> </span>    It returns an iterator yielding tuples in the following form ``(lineno,
<span class="gu">@@ -289,12 +506,158 @@ def extract_python(fileobj: IO[bytes], keywords: Mapping[str, _Keyword],</span>
<span class="w"> </span>    :param options: a dictionary of additional options (optional)
<span class="w"> </span>    :rtype: ``iterator``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract_javascript(fileobj: _FileObj, keywords: Mapping[str, _Keyword],</span>
<span class="gd">-    comment_tags: Collection[str], options: _JSOptions, lineno: int=1</span>
<span class="gd">-    ) -&gt;Generator[_ExtractionResult, None, None]:</span>
<span class="gi">+    funcname = lineno = message_lineno = None</span>
<span class="gi">+    call_stack = -1</span>
<span class="gi">+    buf = []</span>
<span class="gi">+    messages = []</span>
<span class="gi">+    translator_comments = []</span>
<span class="gi">+    in_def = in_translator_comments = False</span>
<span class="gi">+    comment_tag = None</span>
<span class="gi">+</span>
<span class="gi">+    encoding = parse_encoding(fileobj) or options.get(&#39;encoding&#39;, &#39;UTF-8&#39;)</span>
<span class="gi">+    future_flags = parse_future_flags(fileobj, encoding)</span>
<span class="gi">+    next_line = lambda: fileobj.readline().decode(encoding)</span>
<span class="gi">+</span>
<span class="gi">+    tokens = generate_tokens(next_line)</span>
<span class="gi">+</span>
<span class="gi">+    # Current prefix of a Python 3.12 (PEP 701) f-string, or None if we&#39;re not</span>
<span class="gi">+    # currently parsing one.</span>
<span class="gi">+    current_fstring_start = None</span>
<span class="gi">+</span>
<span class="gi">+    for tok, value, (lineno, _), _, _ in tokens:</span>
<span class="gi">+        if call_stack == -1 and tok == NAME and value in (&#39;def&#39;, &#39;class&#39;):</span>
<span class="gi">+            in_def = True</span>
<span class="gi">+        elif tok == OP and value == &#39;(&#39;:</span>
<span class="gi">+            if in_def:</span>
<span class="gi">+                # Avoid false positives for declarations such as:</span>
<span class="gi">+                # def gettext(arg=&#39;message&#39;):</span>
<span class="gi">+                in_def = False</span>
<span class="gi">+                continue</span>
<span class="gi">+            if funcname:</span>
<span class="gi">+                message_lineno = lineno</span>
<span class="gi">+                call_stack += 1</span>
<span class="gi">+        elif in_def and tok == OP and value == &#39;:&#39;:</span>
<span class="gi">+            # End of a class definition without parens</span>
<span class="gi">+            in_def = False</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif call_stack == -1 and tok == COMMENT:</span>
<span class="gi">+            # Strip the comment token from the line</span>
<span class="gi">+            value = value[1:].strip()</span>
<span class="gi">+            if in_translator_comments and \</span>
<span class="gi">+                    translator_comments[-1][0] == lineno - 1:</span>
<span class="gi">+                # We&#39;re already inside a translator comment, continue appending</span>
<span class="gi">+                translator_comments.append((lineno, value))</span>
<span class="gi">+                continue</span>
<span class="gi">+            # If execution reaches this point, let&#39;s see if comment line</span>
<span class="gi">+            # starts with one of the comment tags</span>
<span class="gi">+            for comment_tag in comment_tags:</span>
<span class="gi">+                if value.startswith(comment_tag):</span>
<span class="gi">+                    in_translator_comments = True</span>
<span class="gi">+                    translator_comments.append((lineno, value))</span>
<span class="gi">+                    break</span>
<span class="gi">+        elif funcname and call_stack == 0:</span>
<span class="gi">+            nested = (tok == NAME and value in keywords)</span>
<span class="gi">+            if (tok == OP and value == &#39;)&#39;) or nested:</span>
<span class="gi">+                if buf:</span>
<span class="gi">+                    messages.append(&#39;&#39;.join(buf))</span>
<span class="gi">+                    del buf[:]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    messages.append(None)</span>
<span class="gi">+</span>
<span class="gi">+                messages = tuple(messages) if len(messages) &gt; 1 else messages[0]</span>
<span class="gi">+                # Comments don&#39;t apply unless they immediately</span>
<span class="gi">+                # precede the message</span>
<span class="gi">+                if translator_comments and \</span>
<span class="gi">+                        translator_comments[-1][0] &lt; message_lineno - 1:</span>
<span class="gi">+                    translator_comments = []</span>
<span class="gi">+</span>
<span class="gi">+                yield (message_lineno, funcname, messages,</span>
<span class="gi">+                       [comment[1] for comment in translator_comments])</span>
<span class="gi">+</span>
<span class="gi">+                funcname = lineno = message_lineno = None</span>
<span class="gi">+                call_stack = -1</span>
<span class="gi">+                messages = []</span>
<span class="gi">+                translator_comments = []</span>
<span class="gi">+                in_translator_comments = False</span>
<span class="gi">+                if nested:</span>
<span class="gi">+                    funcname = value</span>
<span class="gi">+            elif tok == STRING:</span>
<span class="gi">+                val = _parse_python_string(value, encoding, future_flags)</span>
<span class="gi">+                if val is not None:</span>
<span class="gi">+                    buf.append(val)</span>
<span class="gi">+</span>
<span class="gi">+            # Python 3.12+, see https://peps.python.org/pep-0701/#new-tokens</span>
<span class="gi">+            elif tok == FSTRING_START:</span>
<span class="gi">+                current_fstring_start = value</span>
<span class="gi">+            elif tok == FSTRING_MIDDLE:</span>
<span class="gi">+                if current_fstring_start is not None:</span>
<span class="gi">+                    current_fstring_start += value</span>
<span class="gi">+            elif tok == FSTRING_END:</span>
<span class="gi">+                if current_fstring_start is not None:</span>
<span class="gi">+                    fstring = current_fstring_start + value</span>
<span class="gi">+                    val = _parse_python_string(fstring, encoding, future_flags)</span>
<span class="gi">+                    if val is not None:</span>
<span class="gi">+                        buf.append(val)</span>
<span class="gi">+</span>
<span class="gi">+            elif tok == OP and value == &#39;,&#39;:</span>
<span class="gi">+                if buf:</span>
<span class="gi">+                    messages.append(&#39;&#39;.join(buf))</span>
<span class="gi">+                    del buf[:]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    messages.append(None)</span>
<span class="gi">+                if translator_comments:</span>
<span class="gi">+                    # We have translator comments, and since we&#39;re on a</span>
<span class="gi">+                    # comma(,) user is allowed to break into a new line</span>
<span class="gi">+                    # Let&#39;s increase the last comment&#39;s lineno in order</span>
<span class="gi">+                    # for the comment to still be a valid one</span>
<span class="gi">+                    old_lineno, old_comment = translator_comments.pop()</span>
<span class="gi">+                    translator_comments.append((old_lineno + 1, old_comment))</span>
<span class="gi">+        elif call_stack &gt; 0 and tok == OP and value == &#39;)&#39;:</span>
<span class="gi">+            call_stack -= 1</span>
<span class="gi">+        elif funcname and call_stack == -1:</span>
<span class="gi">+            funcname = None</span>
<span class="gi">+        elif tok == NAME and value in keywords:</span>
<span class="gi">+            funcname = value</span>
<span class="gi">+</span>
<span class="gi">+        if (current_fstring_start is not None</span>
<span class="gi">+            and tok not in {FSTRING_START, FSTRING_MIDDLE}</span>
<span class="gi">+        ):</span>
<span class="gi">+            # In Python 3.12, tokens other than FSTRING_* mean the</span>
<span class="gi">+            # f-string is dynamic, so we don&#39;t wan&#39;t to extract it.</span>
<span class="gi">+            # And if it&#39;s FSTRING_END, we&#39;ve already handled it above.</span>
<span class="gi">+            # Let&#39;s forget that we&#39;re in an f-string.</span>
<span class="gi">+            current_fstring_start = None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_python_string(value: str, encoding: str, future_flags: int) -&gt; str | None:</span>
<span class="gi">+    # Unwrap quotes in a safe manner, maintaining the string&#39;s encoding</span>
<span class="gi">+    # https://sourceforge.net/tracker/?func=detail&amp;atid=355470&amp;aid=617979&amp;group_id=5470</span>
<span class="gi">+    code = compile(</span>
<span class="gi">+        f&#39;# coding={str(encoding)}\n{value}&#39;,</span>
<span class="gi">+        &#39;&lt;string&gt;&#39;,</span>
<span class="gi">+        &#39;eval&#39;,</span>
<span class="gi">+        ast.PyCF_ONLY_AST | future_flags,</span>
<span class="gi">+    )</span>
<span class="gi">+    if isinstance(code, ast.Expression):</span>
<span class="gi">+        body = code.body</span>
<span class="gi">+        if isinstance(body, ast.Str):</span>
<span class="gi">+            return body.s</span>
<span class="gi">+        if isinstance(body, ast.JoinedStr):  # f-string</span>
<span class="gi">+            if all(isinstance(node, ast.Str) for node in body.values):</span>
<span class="gi">+                return &#39;&#39;.join(node.s for node in body.values)</span>
<span class="gi">+            if all(isinstance(node, ast.Constant) for node in body.values):</span>
<span class="gi">+                return &#39;&#39;.join(str(node.value) for node in body.values)</span>
<span class="gi">+            # TODO: we could raise an error or warning when not all nodes are constants</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_javascript(</span>
<span class="gi">+    fileobj: _FileObj,</span>
<span class="gi">+    keywords: Mapping[str, _Keyword],</span>
<span class="gi">+    comment_tags: Collection[str],</span>
<span class="gi">+    options: _JSOptions,</span>
<span class="gi">+    lineno: int = 1,</span>
<span class="gi">+) -&gt; Generator[_ExtractionResult, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract messages from JavaScript source code.

<span class="w"> </span>    :param fileobj: the seekable, file-like object the messages should be
<span class="gu">@@ -312,12 +675,137 @@ def extract_javascript(fileobj: _FileObj, keywords: Mapping[str, _Keyword],</span>
<span class="w"> </span>                                                 template strings.
<span class="w"> </span>    :param lineno: line number offset (for parsing embedded fragments)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_template_string(template_string: str, keywords: Mapping[str,</span>
<span class="gd">-    _Keyword], comment_tags: Collection[str], options: _JSOptions, lineno:</span>
<span class="gd">-    int=1) -&gt;Generator[_ExtractionResult, None, None]:</span>
<span class="gi">+    from babel.messages.jslexer import Token, tokenize, unquote_string</span>
<span class="gi">+    funcname = message_lineno = None</span>
<span class="gi">+    messages = []</span>
<span class="gi">+    last_argument = None</span>
<span class="gi">+    translator_comments = []</span>
<span class="gi">+    concatenate_next = False</span>
<span class="gi">+    encoding = options.get(&#39;encoding&#39;, &#39;utf-8&#39;)</span>
<span class="gi">+    last_token = None</span>
<span class="gi">+    call_stack = -1</span>
<span class="gi">+    dotted = any(&#39;.&#39; in kw for kw in keywords)</span>
<span class="gi">+    for token in tokenize(</span>
<span class="gi">+        fileobj.read().decode(encoding),</span>
<span class="gi">+        jsx=options.get(&quot;jsx&quot;, True),</span>
<span class="gi">+        template_string=options.get(&quot;template_string&quot;, True),</span>
<span class="gi">+        dotted=dotted,</span>
<span class="gi">+        lineno=lineno,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if (  # Turn keyword`foo` expressions into keyword(&quot;foo&quot;) calls:</span>
<span class="gi">+            funcname and  # have a keyword...</span>
<span class="gi">+            (last_token and last_token.type == &#39;name&#39;) and  # we&#39;ve seen nothing after the keyword...</span>
<span class="gi">+            token.type == &#39;template_string&#39;  # this is a template string</span>
<span class="gi">+        ):</span>
<span class="gi">+            message_lineno = token.lineno</span>
<span class="gi">+            messages = [unquote_string(token.value)]</span>
<span class="gi">+            call_stack = 0</span>
<span class="gi">+            token = Token(&#39;operator&#39;, &#39;)&#39;, token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        if options.get(&#39;parse_template_string&#39;) and not funcname and token.type == &#39;template_string&#39;:</span>
<span class="gi">+            yield from parse_template_string(token.value, keywords, comment_tags, options, token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        elif token.type == &#39;operator&#39; and token.value == &#39;(&#39;:</span>
<span class="gi">+            if funcname:</span>
<span class="gi">+                message_lineno = token.lineno</span>
<span class="gi">+                call_stack += 1</span>
<span class="gi">+</span>
<span class="gi">+        elif call_stack == -1 and token.type == &#39;linecomment&#39;:</span>
<span class="gi">+            value = token.value[2:].strip()</span>
<span class="gi">+            if translator_comments and \</span>
<span class="gi">+               translator_comments[-1][0] == token.lineno - 1:</span>
<span class="gi">+                translator_comments.append((token.lineno, value))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            for comment_tag in comment_tags:</span>
<span class="gi">+                if value.startswith(comment_tag):</span>
<span class="gi">+                    translator_comments.append((token.lineno, value.strip()))</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        elif token.type == &#39;multilinecomment&#39;:</span>
<span class="gi">+            # only one multi-line comment may precede a translation</span>
<span class="gi">+            translator_comments = []</span>
<span class="gi">+            value = token.value[2:-2].strip()</span>
<span class="gi">+            for comment_tag in comment_tags:</span>
<span class="gi">+                if value.startswith(comment_tag):</span>
<span class="gi">+                    lines = value.splitlines()</span>
<span class="gi">+                    if lines:</span>
<span class="gi">+                        lines[0] = lines[0].strip()</span>
<span class="gi">+                        lines[1:] = dedent(&#39;\n&#39;.join(lines[1:])).splitlines()</span>
<span class="gi">+                        for offset, line in enumerate(lines):</span>
<span class="gi">+                            translator_comments.append((token.lineno + offset,</span>
<span class="gi">+                                                        line))</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        elif funcname and call_stack == 0:</span>
<span class="gi">+            if token.type == &#39;operator&#39; and token.value == &#39;)&#39;:</span>
<span class="gi">+                if last_argument is not None:</span>
<span class="gi">+                    messages.append(last_argument)</span>
<span class="gi">+                if len(messages) &gt; 1:</span>
<span class="gi">+                    messages = tuple(messages)</span>
<span class="gi">+                elif messages:</span>
<span class="gi">+                    messages = messages[0]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    messages = None</span>
<span class="gi">+</span>
<span class="gi">+                # Comments don&#39;t apply unless they immediately precede the</span>
<span class="gi">+                # message</span>
<span class="gi">+                if translator_comments and \</span>
<span class="gi">+                   translator_comments[-1][0] &lt; message_lineno - 1:</span>
<span class="gi">+                    translator_comments = []</span>
<span class="gi">+</span>
<span class="gi">+                if messages is not None:</span>
<span class="gi">+                    yield (message_lineno, funcname, messages,</span>
<span class="gi">+                           [comment[1] for comment in translator_comments])</span>
<span class="gi">+</span>
<span class="gi">+                funcname = message_lineno = last_argument = None</span>
<span class="gi">+                concatenate_next = False</span>
<span class="gi">+                translator_comments = []</span>
<span class="gi">+                messages = []</span>
<span class="gi">+                call_stack = -1</span>
<span class="gi">+</span>
<span class="gi">+            elif token.type in (&#39;string&#39;, &#39;template_string&#39;):</span>
<span class="gi">+                new_value = unquote_string(token.value)</span>
<span class="gi">+                if concatenate_next:</span>
<span class="gi">+                    last_argument = (last_argument or &#39;&#39;) + new_value</span>
<span class="gi">+                    concatenate_next = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    last_argument = new_value</span>
<span class="gi">+</span>
<span class="gi">+            elif token.type == &#39;operator&#39;:</span>
<span class="gi">+                if token.value == &#39;,&#39;:</span>
<span class="gi">+                    if last_argument is not None:</span>
<span class="gi">+                        messages.append(last_argument)</span>
<span class="gi">+                        last_argument = None</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        messages.append(None)</span>
<span class="gi">+                    concatenate_next = False</span>
<span class="gi">+                elif token.value == &#39;+&#39;:</span>
<span class="gi">+                    concatenate_next = True</span>
<span class="gi">+</span>
<span class="gi">+        elif call_stack &gt; 0 and token.type == &#39;operator&#39; \</span>
<span class="gi">+                and token.value == &#39;)&#39;:</span>
<span class="gi">+            call_stack -= 1</span>
<span class="gi">+</span>
<span class="gi">+        elif funcname and call_stack == -1:</span>
<span class="gi">+            funcname = None</span>
<span class="gi">+</span>
<span class="gi">+        elif call_stack == -1 and token.type == &#39;name&#39; and \</span>
<span class="gi">+            token.value in keywords and \</span>
<span class="gi">+            (last_token is None or last_token.type != &#39;name&#39; or</span>
<span class="gi">+             last_token.value != &#39;function&#39;):</span>
<span class="gi">+            funcname = token.value</span>
<span class="gi">+</span>
<span class="gi">+        last_token = token</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_template_string(</span>
<span class="gi">+    template_string: str,</span>
<span class="gi">+    keywords: Mapping[str, _Keyword],</span>
<span class="gi">+    comment_tags: Collection[str],</span>
<span class="gi">+    options: _JSOptions,</span>
<span class="gi">+    lineno: int = 1,</span>
<span class="gi">+) -&gt; Generator[_ExtractionResult, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse JavaScript template string.

<span class="w"> </span>    :param template_string: the template string to be parsed
<span class="gu">@@ -328,4 +816,27 @@ def parse_template_string(template_string: str, keywords: Mapping[str,</span>
<span class="w"> </span>    :param options: a dictionary of additional options (optional)
<span class="w"> </span>    :param lineno: starting line number (optional)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from babel.messages.jslexer import line_re</span>
<span class="gi">+    prev_character = None</span>
<span class="gi">+    level = 0</span>
<span class="gi">+    inside_str = False</span>
<span class="gi">+    expression_contents = &#39;&#39;</span>
<span class="gi">+    for character in template_string[1:-1]:</span>
<span class="gi">+        if not inside_str and character in (&#39;&quot;&#39;, &quot;&#39;&quot;, &#39;`&#39;):</span>
<span class="gi">+            inside_str = character</span>
<span class="gi">+        elif inside_str == character and prev_character != r&#39;\\&#39;:</span>
<span class="gi">+            inside_str = False</span>
<span class="gi">+        if level:</span>
<span class="gi">+            expression_contents += character</span>
<span class="gi">+        if not inside_str:</span>
<span class="gi">+            if character == &#39;{&#39; and prev_character == &#39;$&#39;:</span>
<span class="gi">+                level += 1</span>
<span class="gi">+            elif level and character == &#39;}&#39;:</span>
<span class="gi">+                level -= 1</span>
<span class="gi">+                if level == 0 and expression_contents:</span>
<span class="gi">+                    expression_contents = expression_contents[0:-1]</span>
<span class="gi">+                    fake_file_obj = io.BytesIO(expression_contents.encode())</span>
<span class="gi">+                    yield from extract_javascript(fake_file_obj, keywords, comment_tags, options, lineno)</span>
<span class="gi">+                    lineno += len(line_re.findall(expression_contents))</span>
<span class="gi">+                    expression_contents = &#39;&#39;</span>
<span class="gi">+        prev_character = character</span>
<span class="gh">diff --git a/babel/messages/frontend.py b/babel/messages/frontend.py</span>
<span class="gh">index 8d98f9d..34f9e89 100644</span>
<span class="gd">--- a/babel/messages/frontend.py</span>
<span class="gi">+++ b/babel/messages/frontend.py</span>
<span class="gu">@@ -7,7 +7,9 @@</span>
<span class="w"> </span>    :copyright: (c) 2013-2023 by the Babel Team.
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import fnmatch
<span class="w"> </span>import logging
<span class="gu">@@ -21,14 +23,21 @@ from collections import OrderedDict</span>
<span class="w"> </span>from configparser import RawConfigParser
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from typing import Iterable
<span class="gi">+</span>
<span class="w"> </span>from babel import Locale, localedata
<span class="w"> </span>from babel import __version__ as VERSION
<span class="w"> </span>from babel.core import UnknownLocaleError
<span class="w"> </span>from babel.messages.catalog import DEFAULT_HEADER, Catalog
<span class="gd">-from babel.messages.extract import DEFAULT_KEYWORDS, DEFAULT_MAPPING, check_and_call_extract_file, extract_from_dir</span>
<span class="gi">+from babel.messages.extract import (</span>
<span class="gi">+    DEFAULT_KEYWORDS,</span>
<span class="gi">+    DEFAULT_MAPPING,</span>
<span class="gi">+    check_and_call_extract_file,</span>
<span class="gi">+    extract_from_dir,</span>
<span class="gi">+)</span>
<span class="w"> </span>from babel.messages.mofile import write_mo
<span class="w"> </span>from babel.messages.pofile import read_po, write_po
<span class="w"> </span>from babel.util import LOCALTZ
<span class="gi">+</span>
<span class="w"> </span>log = logging.getLogger(&#39;babel&#39;)


<span class="gu">@@ -70,18 +79,54 @@ def listify_value(arg, split=None):</span>
<span class="w"> </span>    :param split: The argument to pass to `str.split()`.
<span class="w"> </span>    :return:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    out = []</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(arg, (list, tuple)):</span>
<span class="gi">+        arg = [arg]</span>
<span class="gi">+</span>
<span class="gi">+    for val in arg:</span>
<span class="gi">+        if val is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(val, (list, tuple)):</span>
<span class="gi">+            out.extend(listify_value(val, split=split))</span>
<span class="gi">+            continue</span>
<span class="gi">+        out.extend(s.strip() for s in str(val).split(split))</span>
<span class="gi">+    assert all(isinstance(val, str) for val in out)</span>
<span class="gi">+    return out</span>


<span class="w"> </span>class CommandMixin:
<span class="gi">+    # This class is a small shim between Distutils commands and</span>
<span class="gi">+    # optparse option parsing in the frontend command line.</span>
<span class="gi">+</span>
<span class="gi">+    #: Option name to be input as `args` on the script command line.</span>
<span class="w"> </span>    as_args = None
<span class="gi">+</span>
<span class="gi">+    #: Options which allow multiple values.</span>
<span class="gi">+    #: This is used by the `optparse` transmogrification code.</span>
<span class="w"> </span>    multiple_value_options = ()
<span class="gi">+</span>
<span class="gi">+    #: Options which are booleans.</span>
<span class="gi">+    #: This is used by the `optparse` transmogrification code.</span>
<span class="gi">+    # (This is actually used by distutils code too, but is never</span>
<span class="gi">+    # declared in the base class.)</span>
<span class="w"> </span>    boolean_options = ()
<span class="gi">+</span>
<span class="gi">+    #: Option aliases, to retain standalone command compatibility.</span>
<span class="gi">+    #: Distutils does not support option aliases, but optparse does.</span>
<span class="gi">+    #: This maps the distutils argument name to an iterable of aliases</span>
<span class="gi">+    #: that are usable with optparse.</span>
<span class="w"> </span>    option_aliases = {}
<span class="gi">+</span>
<span class="gi">+    #: Choices for options that needed to be restricted to specific</span>
<span class="gi">+    #: list of choices.</span>
<span class="w"> </span>    option_choices = {}
<span class="gi">+</span>
<span class="gi">+    #: Log object. To allow replacement in the script command line runner.</span>
<span class="w"> </span>    log = log

<span class="w"> </span>    def __init__(self, dist=None):
<span class="gi">+        # A less strict version of distutils&#39; `__init__`.</span>
<span class="w"> </span>        self.distribution = dist
<span class="w"> </span>        self.initialize_options()
<span class="w"> </span>        self._dry_run = None
<span class="gu">@@ -90,113 +135,702 @@ class CommandMixin:</span>
<span class="w"> </span>        self.help = 0
<span class="w"> </span>        self.finalized = 0

<span class="gi">+    def initialize_options(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def ensure_finalized(self):</span>
<span class="gi">+        if not self.finalized:</span>
<span class="gi">+            self.finalize_options()</span>
<span class="gi">+        self.finalized = 1</span>
<span class="gi">+</span>
<span class="gi">+    def finalize_options(self):</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            f&quot;abstract method -- subclass {self.__class__} must override&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class CompileCatalog(CommandMixin):
<span class="w"> </span>    description = &#39;compile message catalogs to binary MO files&#39;
<span class="gd">-    user_options = [(&#39;domain=&#39;, &#39;D&#39;,</span>
<span class="gd">-        &quot;domains of PO files (space separated list, default &#39;messages&#39;)&quot;),</span>
<span class="gi">+    user_options = [</span>
<span class="gi">+        (&#39;domain=&#39;, &#39;D&#39;,</span>
<span class="gi">+         &quot;domains of PO files (space separated list, default &#39;messages&#39;)&quot;),</span>
<span class="w"> </span>        (&#39;directory=&#39;, &#39;d&#39;,
<span class="gd">-        &#39;path to base directory containing the catalogs&#39;), (&#39;input-file=&#39;,</span>
<span class="gd">-        &#39;i&#39;, &#39;name of the input file&#39;), (&#39;output-file=&#39;, &#39;o&#39;,</span>
<span class="gd">-        &quot;name of the output file (default &#39;&lt;output_dir&gt;/&lt;locale&gt;/LC_MESSAGES/&lt;domain&gt;.mo&#39;)&quot;</span>
<span class="gd">-        ), (&#39;locale=&#39;, &#39;l&#39;, &#39;locale of the catalog to compile&#39;), (</span>
<span class="gd">-        &#39;use-fuzzy&#39;, &#39;f&#39;, &#39;also include fuzzy translations&#39;), (&#39;statistics&#39;,</span>
<span class="gd">-        None, &#39;print statistics about translations&#39;)]</span>
<span class="gi">+         &#39;path to base directory containing the catalogs&#39;),</span>
<span class="gi">+        (&#39;input-file=&#39;, &#39;i&#39;,</span>
<span class="gi">+         &#39;name of the input file&#39;),</span>
<span class="gi">+        (&#39;output-file=&#39;, &#39;o&#39;,</span>
<span class="gi">+         &quot;name of the output file (default &quot;</span>
<span class="gi">+         &quot;&#39;&lt;output_dir&gt;/&lt;locale&gt;/LC_MESSAGES/&lt;domain&gt;.mo&#39;)&quot;),</span>
<span class="gi">+        (&#39;locale=&#39;, &#39;l&#39;,</span>
<span class="gi">+         &#39;locale of the catalog to compile&#39;),</span>
<span class="gi">+        (&#39;use-fuzzy&#39;, &#39;f&#39;,</span>
<span class="gi">+         &#39;also include fuzzy translations&#39;),</span>
<span class="gi">+        (&#39;statistics&#39;, None,</span>
<span class="gi">+         &#39;print statistics about translations&#39;),</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    boolean_options = [&#39;use-fuzzy&#39;, &#39;statistics&#39;]

<span class="gi">+    def initialize_options(self):</span>
<span class="gi">+        self.domain = &#39;messages&#39;</span>
<span class="gi">+        self.directory = None</span>
<span class="gi">+        self.input_file = None</span>
<span class="gi">+        self.output_file = None</span>
<span class="gi">+        self.locale = None</span>
<span class="gi">+        self.use_fuzzy = False</span>
<span class="gi">+        self.statistics = False</span>
<span class="gi">+</span>
<span class="gi">+    def finalize_options(self):</span>
<span class="gi">+        self.domain = listify_value(self.domain)</span>
<span class="gi">+        if not self.input_file and not self.directory:</span>
<span class="gi">+            raise OptionError(&#39;you must specify either the input file or the base directory&#39;)</span>
<span class="gi">+        if not self.output_file and not self.directory:</span>
<span class="gi">+            raise OptionError(&#39;you must specify either the output file or the base directory&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        n_errors = 0</span>
<span class="gi">+        for domain in self.domain:</span>
<span class="gi">+            for errors in self._run_domain(domain).values():</span>
<span class="gi">+                n_errors += len(errors)</span>
<span class="gi">+        if n_errors:</span>
<span class="gi">+            self.log.error(&#39;%d errors encountered.&#39;, n_errors)</span>
<span class="gi">+        return (1 if n_errors else 0)</span>
<span class="gi">+</span>
<span class="gi">+    def _run_domain(self, domain):</span>
<span class="gi">+        po_files = []</span>
<span class="gi">+        mo_files = []</span>
<span class="gi">+</span>
<span class="gi">+        if not self.input_file:</span>
<span class="gi">+            if self.locale:</span>
<span class="gi">+                po_files.append((self.locale,</span>
<span class="gi">+                                 os.path.join(self.directory, self.locale,</span>
<span class="gi">+                                              &#39;LC_MESSAGES&#39;,</span>
<span class="gi">+                                              f&quot;{domain}.po&quot;)))</span>
<span class="gi">+                mo_files.append(os.path.join(self.directory, self.locale,</span>
<span class="gi">+                                             &#39;LC_MESSAGES&#39;,</span>
<span class="gi">+                                             f&quot;{domain}.mo&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                for locale in os.listdir(self.directory):</span>
<span class="gi">+                    po_file = os.path.join(self.directory, locale,</span>
<span class="gi">+                                           &#39;LC_MESSAGES&#39;, f&quot;{domain}.po&quot;)</span>
<span class="gi">+                    if os.path.exists(po_file):</span>
<span class="gi">+                        po_files.append((locale, po_file))</span>
<span class="gi">+                        mo_files.append(os.path.join(self.directory, locale,</span>
<span class="gi">+                                                     &#39;LC_MESSAGES&#39;,</span>
<span class="gi">+                                                     f&quot;{domain}.mo&quot;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            po_files.append((self.locale, self.input_file))</span>
<span class="gi">+            if self.output_file:</span>
<span class="gi">+                mo_files.append(self.output_file)</span>
<span class="gi">+            else:</span>
<span class="gi">+                mo_files.append(os.path.join(self.directory, self.locale,</span>
<span class="gi">+                                             &#39;LC_MESSAGES&#39;,</span>
<span class="gi">+                                             f&quot;{domain}.mo&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if not po_files:</span>
<span class="gi">+            raise OptionError(&#39;no message catalogs found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        catalogs_and_errors = {}</span>
<span class="gi">+</span>
<span class="gi">+        for idx, (locale, po_file) in enumerate(po_files):</span>
<span class="gi">+            mo_file = mo_files[idx]</span>
<span class="gi">+            with open(po_file, &#39;rb&#39;) as infile:</span>
<span class="gi">+                catalog = read_po(infile, locale)</span>
<span class="gi">+</span>
<span class="gi">+            if self.statistics:</span>
<span class="gi">+                translated = 0</span>
<span class="gi">+                for message in list(catalog)[1:]:</span>
<span class="gi">+                    if message.string:</span>
<span class="gi">+                        translated += 1</span>
<span class="gi">+                percentage = 0</span>
<span class="gi">+                if len(catalog):</span>
<span class="gi">+                    percentage = translated * 100 // len(catalog)</span>
<span class="gi">+                self.log.info(</span>
<span class="gi">+                    &#39;%d of %d messages (%d%%) translated in %s&#39;,</span>
<span class="gi">+                    translated, len(catalog), percentage, po_file,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if catalog.fuzzy and not self.use_fuzzy:</span>
<span class="gi">+                self.log.info(&#39;catalog %s is marked as fuzzy, skipping&#39;, po_file)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            catalogs_and_errors[catalog] = catalog_errors = list(catalog.check())</span>
<span class="gi">+            for message, errors in catalog_errors:</span>
<span class="gi">+                for error in errors:</span>
<span class="gi">+                    self.log.error(</span>
<span class="gi">+                        &#39;error: %s:%d: %s&#39;, po_file, message.lineno, error,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            self.log.info(&#39;compiling catalog %s to %s&#39;, po_file, mo_file)</span>
<span class="gi">+</span>
<span class="gi">+            with open(mo_file, &#39;wb&#39;) as outfile:</span>
<span class="gi">+                write_mo(outfile, catalog, use_fuzzy=self.use_fuzzy)</span>
<span class="gi">+</span>
<span class="gi">+        return catalogs_and_errors</span>
<span class="gi">+</span>

<span class="w"> </span>def _make_directory_filter(ignore_patterns):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Build a directory_filter function based on a list of ignore patterns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def cli_directory_filter(dirname):</span>
<span class="gi">+        basename = os.path.basename(dirname)</span>
<span class="gi">+        return not any(</span>
<span class="gi">+            fnmatch.fnmatch(basename, ignore_pattern)</span>
<span class="gi">+            for ignore_pattern</span>
<span class="gi">+            in ignore_patterns</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return cli_directory_filter</span>


<span class="w"> </span>class ExtractMessages(CommandMixin):
<span class="w"> </span>    description = &#39;extract localizable strings from the project code&#39;
<span class="gd">-    user_options = [(&#39;charset=&#39;, None,</span>
<span class="gd">-        &#39;charset to use in the output file (default &quot;utf-8&quot;)&#39;), (</span>
<span class="gd">-        &#39;keywords=&#39;, &#39;k&#39;,</span>
<span class="gd">-        &#39;space-separated list of keywords to look for in addition to the defaults (may be repeated multiple times)&#39;</span>
<span class="gd">-        ), (&#39;no-default-keywords&#39;, None,</span>
<span class="gd">-        &#39;do not include the default keywords&#39;), (&#39;mapping-file=&#39;, &#39;F&#39;,</span>
<span class="gd">-        &#39;path to the mapping configuration file&#39;), (&#39;no-location&#39;, None,</span>
<span class="gd">-        &#39;do not include location comments with filename and line number&#39;),</span>
<span class="gi">+    user_options = [</span>
<span class="gi">+        (&#39;charset=&#39;, None,</span>
<span class="gi">+         &#39;charset to use in the output file (default &quot;utf-8&quot;)&#39;),</span>
<span class="gi">+        (&#39;keywords=&#39;, &#39;k&#39;,</span>
<span class="gi">+         &#39;space-separated list of keywords to look for in addition to the &#39;</span>
<span class="gi">+         &#39;defaults (may be repeated multiple times)&#39;),</span>
<span class="gi">+        (&#39;no-default-keywords&#39;, None,</span>
<span class="gi">+         &#39;do not include the default keywords&#39;),</span>
<span class="gi">+        (&#39;mapping-file=&#39;, &#39;F&#39;,</span>
<span class="gi">+         &#39;path to the mapping configuration file&#39;),</span>
<span class="gi">+        (&#39;no-location&#39;, None,</span>
<span class="gi">+         &#39;do not include location comments with filename and line number&#39;),</span>
<span class="w"> </span>        (&#39;add-location=&#39;, None,
<span class="gd">-        &#39;location lines format. If it is not given or &quot;full&quot;, it generates the lines with both file name and line number. If it is &quot;file&quot;, the line number part is omitted. If it is &quot;never&quot;, it completely suppresses the lines (same as --no-location).&#39;</span>
<span class="gd">-        ), (&#39;omit-header&#39;, None, &#39;do not include msgid &quot;&quot; entry in header&#39;),</span>
<span class="gd">-        (&#39;output-file=&#39;, &#39;o&#39;, &#39;name of the output file&#39;), (&#39;width=&#39;, &#39;w&#39;,</span>
<span class="gd">-        &#39;set output line width (default 76)&#39;), (&#39;no-wrap&#39;, None,</span>
<span class="gd">-        &#39;do not break long message lines, longer than the output line width, into several lines&#39;</span>
<span class="gd">-        ), (&#39;sort-output&#39;, None, &#39;generate sorted output (default False)&#39;),</span>
<span class="gi">+         &#39;location lines format. If it is not given or &quot;full&quot;, it generates &#39;</span>
<span class="gi">+         &#39;the lines with both file name and line number. If it is &quot;file&quot;, &#39;</span>
<span class="gi">+         &#39;the line number part is omitted. If it is &quot;never&quot;, it completely &#39;</span>
<span class="gi">+         &#39;suppresses the lines (same as --no-location).&#39;),</span>
<span class="gi">+        (&#39;omit-header&#39;, None,</span>
<span class="gi">+         &#39;do not include msgid &quot;&quot; entry in header&#39;),</span>
<span class="gi">+        (&#39;output-file=&#39;, &#39;o&#39;,</span>
<span class="gi">+         &#39;name of the output file&#39;),</span>
<span class="gi">+        (&#39;width=&#39;, &#39;w&#39;,</span>
<span class="gi">+         &#39;set output line width (default 76)&#39;),</span>
<span class="gi">+        (&#39;no-wrap&#39;, None,</span>
<span class="gi">+         &#39;do not break long message lines, longer than the output line width, &#39;</span>
<span class="gi">+         &#39;into several lines&#39;),</span>
<span class="gi">+        (&#39;sort-output&#39;, None,</span>
<span class="gi">+         &#39;generate sorted output (default False)&#39;),</span>
<span class="w"> </span>        (&#39;sort-by-file&#39;, None,
<span class="gd">-        &#39;sort output by file location (default False)&#39;), (</span>
<span class="gd">-        &#39;msgid-bugs-address=&#39;, None, &#39;set report address for msgid&#39;), (</span>
<span class="gd">-        &#39;copyright-holder=&#39;, None, &#39;set copyright holder in output&#39;), (</span>
<span class="gd">-        &#39;project=&#39;, None, &#39;set project name in output&#39;), (&#39;version=&#39;, None,</span>
<span class="gd">-        &#39;set project version in output&#39;), (&#39;add-comments=&#39;, &#39;c&#39;,</span>
<span class="gd">-        &#39;place comment block with TAG (or those preceding keyword lines) in output file. Separate multiple TAGs with commas(,)&#39;</span>
<span class="gd">-        ), (&#39;strip-comments&#39;, &#39;s&#39;,</span>
<span class="gd">-        &#39;strip the comment TAGs from the comments.&#39;), (&#39;input-paths=&#39;, None,</span>
<span class="gd">-        &#39;files or directories that should be scanned for messages. Separate multiple files or directories with commas(,)&#39;</span>
<span class="gd">-        ), (&#39;input-dirs=&#39;, None,</span>
<span class="gd">-        &#39;alias for input-paths (does allow files as well as directories).&#39;),</span>
<span class="gi">+         &#39;sort output by file location (default False)&#39;),</span>
<span class="gi">+        (&#39;msgid-bugs-address=&#39;, None,</span>
<span class="gi">+         &#39;set report address for msgid&#39;),</span>
<span class="gi">+        (&#39;copyright-holder=&#39;, None,</span>
<span class="gi">+         &#39;set copyright holder in output&#39;),</span>
<span class="gi">+        (&#39;project=&#39;, None,</span>
<span class="gi">+         &#39;set project name in output&#39;),</span>
<span class="gi">+        (&#39;version=&#39;, None,</span>
<span class="gi">+         &#39;set project version in output&#39;),</span>
<span class="gi">+        (&#39;add-comments=&#39;, &#39;c&#39;,</span>
<span class="gi">+         &#39;place comment block with TAG (or those preceding keyword lines) in &#39;</span>
<span class="gi">+         &#39;output file. Separate multiple TAGs with commas(,)&#39;),  # TODO: Support repetition of this argument</span>
<span class="gi">+        (&#39;strip-comments&#39;, &#39;s&#39;,</span>
<span class="gi">+         &#39;strip the comment TAGs from the comments.&#39;),</span>
<span class="gi">+        (&#39;input-paths=&#39;, None,</span>
<span class="gi">+         &#39;files or directories that should be scanned for messages. Separate multiple &#39;</span>
<span class="gi">+         &#39;files or directories with commas(,)&#39;),  # TODO: Support repetition of this argument</span>
<span class="gi">+        (&#39;input-dirs=&#39;, None,  # TODO (3.x): Remove me.</span>
<span class="gi">+         &#39;alias for input-paths (does allow files as well as directories).&#39;),</span>
<span class="w"> </span>        (&#39;ignore-dirs=&#39;, None,
<span class="gd">-        &#39;Patterns for directories to ignore when scanning for messages. Separate multiple patterns with spaces (default &quot;.* ._&quot;)&#39;</span>
<span class="gd">-        ), (&#39;header-comment=&#39;, None, &#39;header comment for the catalog&#39;), (</span>
<span class="gd">-        &#39;last-translator=&#39;, None,</span>
<span class="gd">-        &#39;set the name and email of the last translator in output&#39;)]</span>
<span class="gd">-    boolean_options = [&#39;no-default-keywords&#39;, &#39;no-location&#39;, &#39;omit-header&#39;,</span>
<span class="gd">-        &#39;no-wrap&#39;, &#39;sort-output&#39;, &#39;sort-by-file&#39;, &#39;strip-comments&#39;]</span>
<span class="gi">+         &#39;Patterns for directories to ignore when scanning for messages. &#39;</span>
<span class="gi">+         &#39;Separate multiple patterns with spaces (default &quot;.* ._&quot;)&#39;),</span>
<span class="gi">+        (&#39;header-comment=&#39;, None,</span>
<span class="gi">+         &#39;header comment for the catalog&#39;),</span>
<span class="gi">+        (&#39;last-translator=&#39;, None,</span>
<span class="gi">+         &#39;set the name and email of the last translator in output&#39;),</span>
<span class="gi">+    ]</span>
<span class="gi">+    boolean_options = [</span>
<span class="gi">+        &#39;no-default-keywords&#39;, &#39;no-location&#39;, &#39;omit-header&#39;, &#39;no-wrap&#39;,</span>
<span class="gi">+        &#39;sort-output&#39;, &#39;sort-by-file&#39;, &#39;strip-comments&#39;,</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    as_args = &#39;input-paths&#39;
<span class="gd">-    multiple_value_options = &#39;add-comments&#39;, &#39;keywords&#39;, &#39;ignore-dirs&#39;</span>
<span class="gd">-    option_aliases = {&#39;keywords&#39;: (&#39;--keyword&#39;,), &#39;mapping-file&#39;: (</span>
<span class="gd">-        &#39;--mapping&#39;,), &#39;output-file&#39;: (&#39;--output&#39;,), &#39;strip-comments&#39;: (</span>
<span class="gd">-        &#39;--strip-comment-tags&#39;,), &#39;last-translator&#39;: (&#39;--last-translator&#39;,)}</span>
<span class="gd">-    option_choices = {&#39;add-location&#39;: (&#39;full&#39;, &#39;file&#39;, &#39;never&#39;)}</span>
<span class="gi">+    multiple_value_options = (</span>
<span class="gi">+        &#39;add-comments&#39;,</span>
<span class="gi">+        &#39;keywords&#39;,</span>
<span class="gi">+        &#39;ignore-dirs&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+    option_aliases = {</span>
<span class="gi">+        &#39;keywords&#39;: (&#39;--keyword&#39;,),</span>
<span class="gi">+        &#39;mapping-file&#39;: (&#39;--mapping&#39;,),</span>
<span class="gi">+        &#39;output-file&#39;: (&#39;--output&#39;,),</span>
<span class="gi">+        &#39;strip-comments&#39;: (&#39;--strip-comment-tags&#39;,),</span>
<span class="gi">+        &#39;last-translator&#39;: (&#39;--last-translator&#39;,),</span>
<span class="gi">+    }</span>
<span class="gi">+    option_choices = {</span>
<span class="gi">+        &#39;add-location&#39;: (&#39;full&#39;, &#39;file&#39;, &#39;never&#39;),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def initialize_options(self):</span>
<span class="gi">+        self.charset = &#39;utf-8&#39;</span>
<span class="gi">+        self.keywords = None</span>
<span class="gi">+        self.no_default_keywords = False</span>
<span class="gi">+        self.mapping_file = None</span>
<span class="gi">+        self.no_location = False</span>
<span class="gi">+        self.add_location = None</span>
<span class="gi">+        self.omit_header = False</span>
<span class="gi">+        self.output_file = None</span>
<span class="gi">+        self.input_dirs = None</span>
<span class="gi">+        self.input_paths = None</span>
<span class="gi">+        self.width = None</span>
<span class="gi">+        self.no_wrap = False</span>
<span class="gi">+        self.sort_output = False</span>
<span class="gi">+        self.sort_by_file = False</span>
<span class="gi">+        self.msgid_bugs_address = None</span>
<span class="gi">+        self.copyright_holder = None</span>
<span class="gi">+        self.project = None</span>
<span class="gi">+        self.version = None</span>
<span class="gi">+        self.add_comments = None</span>
<span class="gi">+        self.strip_comments = False</span>
<span class="gi">+        self.include_lineno = True</span>
<span class="gi">+        self.ignore_dirs = None</span>
<span class="gi">+        self.header_comment = None</span>
<span class="gi">+        self.last_translator = None</span>
<span class="gi">+</span>
<span class="gi">+    def finalize_options(self):</span>
<span class="gi">+        if self.input_dirs:</span>
<span class="gi">+            if not self.input_paths:</span>
<span class="gi">+                self.input_paths = self.input_dirs</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise OptionError(</span>
<span class="gi">+                    &#39;input-dirs and input-paths are mutually exclusive&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        keywords = {} if self.no_default_keywords else DEFAULT_KEYWORDS.copy()</span>
<span class="gi">+</span>
<span class="gi">+        keywords.update(parse_keywords(listify_value(self.keywords)))</span>
<span class="gi">+</span>
<span class="gi">+        self.keywords = keywords</span>
<span class="gi">+</span>
<span class="gi">+        if not self.keywords:</span>
<span class="gi">+            raise OptionError(</span>
<span class="gi">+                &#39;you must specify new keywords if you disable the default ones&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not self.output_file:</span>
<span class="gi">+            raise OptionError(&#39;no output file specified&#39;)</span>
<span class="gi">+        if self.no_wrap and self.width:</span>
<span class="gi">+            raise OptionError(</span>
<span class="gi">+                &quot;&#39;--no-wrap&#39; and &#39;--width&#39; are mutually exclusive&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+        if not self.no_wrap and not self.width:</span>
<span class="gi">+            self.width = 76</span>
<span class="gi">+        elif self.width is not None:</span>
<span class="gi">+            self.width = int(self.width)</span>
<span class="gi">+</span>
<span class="gi">+        if self.sort_output and self.sort_by_file:</span>
<span class="gi">+            raise OptionError(</span>
<span class="gi">+                &quot;&#39;--sort-output&#39; and &#39;--sort-by-file&#39; are mutually exclusive&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.input_paths:</span>
<span class="gi">+            if isinstance(self.input_paths, str):</span>
<span class="gi">+                self.input_paths = re.split(r&#39;,\s*&#39;, self.input_paths)</span>
<span class="gi">+        elif self.distribution is not None:</span>
<span class="gi">+            self.input_paths = dict.fromkeys([</span>
<span class="gi">+                k.split(&#39;.&#39;, 1)[0]</span>
<span class="gi">+                for k in (self.distribution.packages or ())</span>
<span class="gi">+            ]).keys()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.input_paths = []</span>
<span class="gi">+</span>
<span class="gi">+        if not self.input_paths:</span>
<span class="gi">+            raise OptionError(&quot;no input files or directories specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for path in self.input_paths:</span>
<span class="gi">+            if not os.path.exists(path):</span>
<span class="gi">+                raise OptionError(f&quot;Input path: {path} does not exist&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.add_comments = listify_value(self.add_comments or (), &quot;,&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.distribution:</span>
<span class="gi">+            if not self.project:</span>
<span class="gi">+                self.project = self.distribution.get_name()</span>
<span class="gi">+            if not self.version:</span>
<span class="gi">+                self.version = self.distribution.get_version()</span>
<span class="gi">+</span>
<span class="gi">+        if self.add_location == &#39;never&#39;:</span>
<span class="gi">+            self.no_location = True</span>
<span class="gi">+        elif self.add_location == &#39;file&#39;:</span>
<span class="gi">+            self.include_lineno = False</span>
<span class="gi">+</span>
<span class="gi">+        ignore_dirs = listify_value(self.ignore_dirs)</span>
<span class="gi">+        if ignore_dirs:</span>
<span class="gi">+            self.directory_filter = _make_directory_filter(self.ignore_dirs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.directory_filter = None</span>
<span class="gi">+</span>
<span class="gi">+    def _build_callback(self, path: str):</span>
<span class="gi">+        def callback(filename: str, method: str, options: dict):</span>
<span class="gi">+            if method == &#39;ignore&#39;:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # If we explicitly provide a full filepath, just use that.</span>
<span class="gi">+            # Otherwise, path will be the directory path and filename</span>
<span class="gi">+            # is the relative path from that dir to the file.</span>
<span class="gi">+            # So we can join those to get the full filepath.</span>
<span class="gi">+            if os.path.isfile(path):</span>
<span class="gi">+                filepath = path</span>
<span class="gi">+            else:</span>
<span class="gi">+                filepath = os.path.normpath(os.path.join(path, filename))</span>
<span class="gi">+</span>
<span class="gi">+            optstr = &#39;&#39;</span>
<span class="gi">+            if options:</span>
<span class="gi">+                opt_values = &quot;, &quot;.join(f&#39;{k}=&quot;{v}&quot;&#39; for k, v in options.items())</span>
<span class="gi">+                optstr = f&quot; ({opt_values})&quot;</span>
<span class="gi">+            self.log.info(&#39;extracting messages from %s%s&#39;, filepath, optstr)</span>
<span class="gi">+</span>
<span class="gi">+        return callback</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        mappings = self._get_mappings()</span>
<span class="gi">+        with open(self.output_file, &#39;wb&#39;) as outfile:</span>
<span class="gi">+            catalog = Catalog(project=self.project,</span>
<span class="gi">+                              version=self.version,</span>
<span class="gi">+                              msgid_bugs_address=self.msgid_bugs_address,</span>
<span class="gi">+                              copyright_holder=self.copyright_holder,</span>
<span class="gi">+                              charset=self.charset,</span>
<span class="gi">+                              header_comment=(self.header_comment or DEFAULT_HEADER),</span>
<span class="gi">+                              last_translator=self.last_translator)</span>
<span class="gi">+</span>
<span class="gi">+            for path, method_map, options_map in mappings:</span>
<span class="gi">+                callback = self._build_callback(path)</span>
<span class="gi">+                if os.path.isfile(path):</span>
<span class="gi">+                    current_dir = os.getcwd()</span>
<span class="gi">+                    extracted = check_and_call_extract_file(</span>
<span class="gi">+                        path, method_map, options_map,</span>
<span class="gi">+                        callback, self.keywords, self.add_comments,</span>
<span class="gi">+                        self.strip_comments, current_dir,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    extracted = extract_from_dir(</span>
<span class="gi">+                        path, method_map, options_map,</span>
<span class="gi">+                        keywords=self.keywords,</span>
<span class="gi">+                        comment_tags=self.add_comments,</span>
<span class="gi">+                        callback=callback,</span>
<span class="gi">+                        strip_comment_tags=self.strip_comments,</span>
<span class="gi">+                        directory_filter=self.directory_filter,</span>
<span class="gi">+                    )</span>
<span class="gi">+                for filename, lineno, message, comments, context in extracted:</span>
<span class="gi">+                    if os.path.isfile(path):</span>
<span class="gi">+                        filepath = filename  # already normalized</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        filepath = os.path.normpath(os.path.join(path, filename))</span>
<span class="gi">+</span>
<span class="gi">+                    catalog.add(message, None, [(filepath, lineno)],</span>
<span class="gi">+                                auto_comments=comments, context=context)</span>
<span class="gi">+</span>
<span class="gi">+            self.log.info(&#39;writing PO template file to %s&#39;, self.output_file)</span>
<span class="gi">+            write_po(outfile, catalog, width=self.width,</span>
<span class="gi">+                     no_location=self.no_location,</span>
<span class="gi">+                     omit_header=self.omit_header,</span>
<span class="gi">+                     sort_output=self.sort_output,</span>
<span class="gi">+                     sort_by_file=self.sort_by_file,</span>
<span class="gi">+                     include_lineno=self.include_lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_mappings(self):</span>
<span class="gi">+        mappings = []</span>
<span class="gi">+</span>
<span class="gi">+        if self.mapping_file:</span>
<span class="gi">+            with open(self.mapping_file) as fileobj:</span>
<span class="gi">+                method_map, options_map = parse_mapping(fileobj)</span>
<span class="gi">+            for path in self.input_paths:</span>
<span class="gi">+                mappings.append((path, method_map, options_map))</span>
<span class="gi">+</span>
<span class="gi">+        elif getattr(self.distribution, &#39;message_extractors&#39;, None):</span>
<span class="gi">+            message_extractors = self.distribution.message_extractors</span>
<span class="gi">+            for path, mapping in message_extractors.items():</span>
<span class="gi">+                if isinstance(mapping, str):</span>
<span class="gi">+                    method_map, options_map = parse_mapping(StringIO(mapping))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    method_map, options_map = [], {}</span>
<span class="gi">+                    for pattern, method, options in mapping:</span>
<span class="gi">+                        method_map.append((pattern, method))</span>
<span class="gi">+                        options_map[pattern] = options or {}</span>
<span class="gi">+                mappings.append((path, method_map, options_map))</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            for path in self.input_paths:</span>
<span class="gi">+                mappings.append((path, DEFAULT_MAPPING, {}))</span>
<span class="gi">+</span>
<span class="gi">+        return mappings</span>


<span class="w"> </span>class InitCatalog(CommandMixin):
<span class="w"> </span>    description = &#39;create a new catalog based on a POT file&#39;
<span class="gd">-    user_options = [(&#39;domain=&#39;, &#39;D&#39;,</span>
<span class="gd">-        &quot;domain of PO file (default &#39;messages&#39;)&quot;), (&#39;input-file=&#39;, &#39;i&#39;,</span>
<span class="gd">-        &#39;name of the input file&#39;), (&#39;output-dir=&#39;, &#39;d&#39;,</span>
<span class="gd">-        &#39;path to output directory&#39;), (&#39;output-file=&#39;, &#39;o&#39;,</span>
<span class="gd">-        &quot;name of the output file (default &#39;&lt;output_dir&gt;/&lt;locale&gt;/LC_MESSAGES/&lt;domain&gt;.po&#39;)&quot;</span>
<span class="gd">-        ), (&#39;locale=&#39;, &#39;l&#39;, &#39;locale for the new localized catalog&#39;), (</span>
<span class="gd">-        &#39;width=&#39;, &#39;w&#39;, &#39;set output line width (default 76)&#39;), (&#39;no-wrap&#39;,</span>
<span class="gd">-        None,</span>
<span class="gd">-        &#39;do not break long message lines, longer than the output line width, into several lines&#39;</span>
<span class="gd">-        )]</span>
<span class="gi">+    user_options = [</span>
<span class="gi">+        (&#39;domain=&#39;, &#39;D&#39;,</span>
<span class="gi">+         &quot;domain of PO file (default &#39;messages&#39;)&quot;),</span>
<span class="gi">+        (&#39;input-file=&#39;, &#39;i&#39;,</span>
<span class="gi">+         &#39;name of the input file&#39;),</span>
<span class="gi">+        (&#39;output-dir=&#39;, &#39;d&#39;,</span>
<span class="gi">+         &#39;path to output directory&#39;),</span>
<span class="gi">+        (&#39;output-file=&#39;, &#39;o&#39;,</span>
<span class="gi">+         &quot;name of the output file (default &quot;</span>
<span class="gi">+         &quot;&#39;&lt;output_dir&gt;/&lt;locale&gt;/LC_MESSAGES/&lt;domain&gt;.po&#39;)&quot;),</span>
<span class="gi">+        (&#39;locale=&#39;, &#39;l&#39;,</span>
<span class="gi">+         &#39;locale for the new localized catalog&#39;),</span>
<span class="gi">+        (&#39;width=&#39;, &#39;w&#39;,</span>
<span class="gi">+         &#39;set output line width (default 76)&#39;),</span>
<span class="gi">+        (&#39;no-wrap&#39;, None,</span>
<span class="gi">+         &#39;do not break long message lines, longer than the output line width, &#39;</span>
<span class="gi">+         &#39;into several lines&#39;),</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    boolean_options = [&#39;no-wrap&#39;]

<span class="gi">+    def initialize_options(self):</span>
<span class="gi">+        self.output_dir = None</span>
<span class="gi">+        self.output_file = None</span>
<span class="gi">+        self.input_file = None</span>
<span class="gi">+        self.locale = None</span>
<span class="gi">+        self.domain = &#39;messages&#39;</span>
<span class="gi">+        self.no_wrap = False</span>
<span class="gi">+        self.width = None</span>
<span class="gi">+</span>
<span class="gi">+    def finalize_options(self):</span>
<span class="gi">+        if not self.input_file:</span>
<span class="gi">+            raise OptionError(&#39;you must specify the input file&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.locale:</span>
<span class="gi">+            raise OptionError(&#39;you must provide a locale for the new catalog&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._locale = Locale.parse(self.locale)</span>
<span class="gi">+        except UnknownLocaleError as e:</span>
<span class="gi">+            raise OptionError(e) from e</span>
<span class="gi">+</span>
<span class="gi">+        if not self.output_file and not self.output_dir:</span>
<span class="gi">+            raise OptionError(&#39;you must specify the output directory&#39;)</span>
<span class="gi">+        if not self.output_file:</span>
<span class="gi">+            self.output_file = os.path.join(self.output_dir, self.locale,</span>
<span class="gi">+                                            &#39;LC_MESSAGES&#39;, f&quot;{self.domain}.po&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not os.path.exists(os.path.dirname(self.output_file)):</span>
<span class="gi">+            os.makedirs(os.path.dirname(self.output_file))</span>
<span class="gi">+        if self.no_wrap and self.width:</span>
<span class="gi">+            raise OptionError(&quot;&#39;--no-wrap&#39; and &#39;--width&#39; are mutually exclusive&quot;)</span>
<span class="gi">+        if not self.no_wrap and not self.width:</span>
<span class="gi">+            self.width = 76</span>
<span class="gi">+        elif self.width is not None:</span>
<span class="gi">+            self.width = int(self.width)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        self.log.info(</span>
<span class="gi">+            &#39;creating catalog %s based on %s&#39;, self.output_file, self.input_file,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        with open(self.input_file, &#39;rb&#39;) as infile:</span>
<span class="gi">+            # Although reading from the catalog template, read_po must be fed</span>
<span class="gi">+            # the locale in order to correctly calculate plurals</span>
<span class="gi">+            catalog = read_po(infile, locale=self.locale)</span>
<span class="gi">+</span>
<span class="gi">+        catalog.locale = self._locale</span>
<span class="gi">+        catalog.revision_date = datetime.datetime.now(LOCALTZ)</span>
<span class="gi">+        catalog.fuzzy = False</span>
<span class="gi">+</span>
<span class="gi">+        with open(self.output_file, &#39;wb&#39;) as outfile:</span>
<span class="gi">+            write_po(outfile, catalog, width=self.width)</span>
<span class="gi">+</span>

<span class="w"> </span>class UpdateCatalog(CommandMixin):
<span class="w"> </span>    description = &#39;update message catalogs from a POT file&#39;
<span class="gd">-    user_options = [(&#39;domain=&#39;, &#39;D&#39;,</span>
<span class="gd">-        &quot;domain of PO file (default &#39;messages&#39;)&quot;), (&#39;input-file=&#39;, &#39;i&#39;,</span>
<span class="gd">-        &#39;name of the input file&#39;), (&#39;output-dir=&#39;, &#39;d&#39;,</span>
<span class="gd">-        &#39;path to base directory containing the catalogs&#39;), (&#39;output-file=&#39;,</span>
<span class="gd">-        &#39;o&#39;,</span>
<span class="gd">-        &quot;name of the output file (default &#39;&lt;output_dir&gt;/&lt;locale&gt;/LC_MESSAGES/&lt;domain&gt;.po&#39;)&quot;</span>
<span class="gd">-        ), (&#39;omit-header&#39;, None, &#39;do not include msgid  entry in header&#39;),</span>
<span class="gd">-        (&#39;locale=&#39;, &#39;l&#39;, &#39;locale of the catalog to compile&#39;), (&#39;width=&#39;,</span>
<span class="gd">-        &#39;w&#39;, &#39;set output line width (default 76)&#39;), (&#39;no-wrap&#39;, None,</span>
<span class="gd">-        &#39;do not break long message lines, longer than the output line width, into several lines&#39;</span>
<span class="gd">-        ), (&#39;ignore-obsolete=&#39;, None,</span>
<span class="gd">-        &#39;whether to omit obsolete messages from the output&#39;), (</span>
<span class="gd">-        &#39;init-missing=&#39;, None,</span>
<span class="gd">-        &#39;if any output files are missing, initialize them first&#39;), (</span>
<span class="gd">-        &#39;no-fuzzy-matching&#39;, &#39;N&#39;, &#39;do not use fuzzy matching&#39;), (</span>
<span class="gd">-        &#39;update-header-comment&#39;, None, &#39;update target header comment&#39;), (</span>
<span class="gd">-        &#39;previous&#39;, None, &#39;keep previous msgids of translated messages&#39;), (</span>
<span class="gd">-        &#39;check=&#39;, None,</span>
<span class="gd">-        &quot;don&#39;t update the catalog, just return the status. Return code 0 means nothing would change. Return code 1 means that the catalog would be updated&quot;</span>
<span class="gd">-        ), (&#39;ignore-pot-creation-date=&#39;, None,</span>
<span class="gd">-        &#39;ignore changes to POT-Creation-Date when updating or checking&#39;)]</span>
<span class="gd">-    boolean_options = [&#39;omit-header&#39;, &#39;no-wrap&#39;, &#39;ignore-obsolete&#39;,</span>
<span class="gd">-        &#39;init-missing&#39;, &#39;no-fuzzy-matching&#39;, &#39;previous&#39;,</span>
<span class="gd">-        &#39;update-header-comment&#39;, &#39;check&#39;, &#39;ignore-pot-creation-date&#39;]</span>
<span class="gi">+    user_options = [</span>
<span class="gi">+        (&#39;domain=&#39;, &#39;D&#39;,</span>
<span class="gi">+         &quot;domain of PO file (default &#39;messages&#39;)&quot;),</span>
<span class="gi">+        (&#39;input-file=&#39;, &#39;i&#39;,</span>
<span class="gi">+         &#39;name of the input file&#39;),</span>
<span class="gi">+        (&#39;output-dir=&#39;, &#39;d&#39;,</span>
<span class="gi">+         &#39;path to base directory containing the catalogs&#39;),</span>
<span class="gi">+        (&#39;output-file=&#39;, &#39;o&#39;,</span>
<span class="gi">+         &quot;name of the output file (default &quot;</span>
<span class="gi">+         &quot;&#39;&lt;output_dir&gt;/&lt;locale&gt;/LC_MESSAGES/&lt;domain&gt;.po&#39;)&quot;),</span>
<span class="gi">+        (&#39;omit-header&#39;, None,</span>
<span class="gi">+         &quot;do not include msgid &quot;&quot; entry in header&quot;),</span>
<span class="gi">+        (&#39;locale=&#39;, &#39;l&#39;,</span>
<span class="gi">+         &#39;locale of the catalog to compile&#39;),</span>
<span class="gi">+        (&#39;width=&#39;, &#39;w&#39;,</span>
<span class="gi">+         &#39;set output line width (default 76)&#39;),</span>
<span class="gi">+        (&#39;no-wrap&#39;, None,</span>
<span class="gi">+         &#39;do not break long message lines, longer than the output line width, &#39;</span>
<span class="gi">+         &#39;into several lines&#39;),</span>
<span class="gi">+        (&#39;ignore-obsolete=&#39;, None,</span>
<span class="gi">+         &#39;whether to omit obsolete messages from the output&#39;),</span>
<span class="gi">+        (&#39;init-missing=&#39;, None,</span>
<span class="gi">+         &#39;if any output files are missing, initialize them first&#39;),</span>
<span class="gi">+        (&#39;no-fuzzy-matching&#39;, &#39;N&#39;,</span>
<span class="gi">+         &#39;do not use fuzzy matching&#39;),</span>
<span class="gi">+        (&#39;update-header-comment&#39;, None,</span>
<span class="gi">+         &#39;update target header comment&#39;),</span>
<span class="gi">+        (&#39;previous&#39;, None,</span>
<span class="gi">+         &#39;keep previous msgids of translated messages&#39;),</span>
<span class="gi">+        (&#39;check=&#39;, None,</span>
<span class="gi">+         &#39;don\&#39;t update the catalog, just return the status. Return code 0 &#39;</span>
<span class="gi">+         &#39;means nothing would change. Return code 1 means that the catalog &#39;</span>
<span class="gi">+         &#39;would be updated&#39;),</span>
<span class="gi">+        (&#39;ignore-pot-creation-date=&#39;, None,</span>
<span class="gi">+         &#39;ignore changes to POT-Creation-Date when updating or checking&#39;),</span>
<span class="gi">+    ]</span>
<span class="gi">+    boolean_options = [</span>
<span class="gi">+        &#39;omit-header&#39;, &#39;no-wrap&#39;, &#39;ignore-obsolete&#39;, &#39;init-missing&#39;,</span>
<span class="gi">+        &#39;no-fuzzy-matching&#39;, &#39;previous&#39;, &#39;update-header-comment&#39;,</span>
<span class="gi">+        &#39;check&#39;, &#39;ignore-pot-creation-date&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def initialize_options(self):</span>
<span class="gi">+        self.domain = &#39;messages&#39;</span>
<span class="gi">+        self.input_file = None</span>
<span class="gi">+        self.output_dir = None</span>
<span class="gi">+        self.output_file = None</span>
<span class="gi">+        self.omit_header = False</span>
<span class="gi">+        self.locale = None</span>
<span class="gi">+        self.width = None</span>
<span class="gi">+        self.no_wrap = False</span>
<span class="gi">+        self.ignore_obsolete = False</span>
<span class="gi">+        self.init_missing = False</span>
<span class="gi">+        self.no_fuzzy_matching = False</span>
<span class="gi">+        self.update_header_comment = False</span>
<span class="gi">+        self.previous = False</span>
<span class="gi">+        self.check = False</span>
<span class="gi">+        self.ignore_pot_creation_date = False</span>
<span class="gi">+</span>
<span class="gi">+    def finalize_options(self):</span>
<span class="gi">+        if not self.input_file:</span>
<span class="gi">+            raise OptionError(&#39;you must specify the input file&#39;)</span>
<span class="gi">+        if not self.output_file and not self.output_dir:</span>
<span class="gi">+            raise OptionError(&#39;you must specify the output file or directory&#39;)</span>
<span class="gi">+        if self.output_file and not self.locale:</span>
<span class="gi">+            raise OptionError(&#39;you must specify the locale&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.init_missing:</span>
<span class="gi">+            if not self.locale:</span>
<span class="gi">+                raise OptionError(</span>
<span class="gi">+                    &#39;you must specify the locale for &#39;</span>
<span class="gi">+                    &#39;the init-missing option to work&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._locale = Locale.parse(self.locale)</span>
<span class="gi">+            except UnknownLocaleError as e:</span>
<span class="gi">+                raise OptionError(e) from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._locale = None</span>
<span class="gi">+</span>
<span class="gi">+        if self.no_wrap and self.width:</span>
<span class="gi">+            raise OptionError(&quot;&#39;--no-wrap&#39; and &#39;--width&#39; are mutually exclusive&quot;)</span>
<span class="gi">+        if not self.no_wrap and not self.width:</span>
<span class="gi">+            self.width = 76</span>
<span class="gi">+        elif self.width is not None:</span>
<span class="gi">+            self.width = int(self.width)</span>
<span class="gi">+        if self.no_fuzzy_matching and self.previous:</span>
<span class="gi">+            self.previous = False</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        check_status = {}</span>
<span class="gi">+        po_files = []</span>
<span class="gi">+        if not self.output_file:</span>
<span class="gi">+            if self.locale:</span>
<span class="gi">+                po_files.append((self.locale,</span>
<span class="gi">+                                 os.path.join(self.output_dir, self.locale,</span>
<span class="gi">+                                              &#39;LC_MESSAGES&#39;,</span>
<span class="gi">+                                              f&quot;{self.domain}.po&quot;)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                for locale in os.listdir(self.output_dir):</span>
<span class="gi">+                    po_file = os.path.join(self.output_dir, locale,</span>
<span class="gi">+                                           &#39;LC_MESSAGES&#39;,</span>
<span class="gi">+                                           f&quot;{self.domain}.po&quot;)</span>
<span class="gi">+                    if os.path.exists(po_file):</span>
<span class="gi">+                        po_files.append((locale, po_file))</span>
<span class="gi">+        else:</span>
<span class="gi">+            po_files.append((self.locale, self.output_file))</span>
<span class="gi">+</span>
<span class="gi">+        if not po_files:</span>
<span class="gi">+            raise OptionError(&#39;no message catalogs found&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        domain = self.domain</span>
<span class="gi">+        if not domain:</span>
<span class="gi">+            domain = os.path.splitext(os.path.basename(self.input_file))[0]</span>
<span class="gi">+</span>
<span class="gi">+        with open(self.input_file, &#39;rb&#39;) as infile:</span>
<span class="gi">+            template = read_po(infile)</span>
<span class="gi">+</span>
<span class="gi">+        for locale, filename in po_files:</span>
<span class="gi">+            if self.init_missing and not os.path.exists(filename):</span>
<span class="gi">+                if self.check:</span>
<span class="gi">+                    check_status[filename] = False</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.log.info(</span>
<span class="gi">+                    &#39;creating catalog %s based on %s&#39;, filename, self.input_file,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                with open(self.input_file, &#39;rb&#39;) as infile:</span>
<span class="gi">+                    # Although reading from the catalog template, read_po must</span>
<span class="gi">+                    # be fed the locale in order to correctly calculate plurals</span>
<span class="gi">+                    catalog = read_po(infile, locale=self.locale)</span>
<span class="gi">+</span>
<span class="gi">+                catalog.locale = self._locale</span>
<span class="gi">+                catalog.revision_date = datetime.datetime.now(LOCALTZ)</span>
<span class="gi">+                catalog.fuzzy = False</span>
<span class="gi">+</span>
<span class="gi">+                with open(filename, &#39;wb&#39;) as outfile:</span>
<span class="gi">+                    write_po(outfile, catalog)</span>
<span class="gi">+</span>
<span class="gi">+            self.log.info(&#39;updating catalog %s based on %s&#39;, filename, self.input_file)</span>
<span class="gi">+            with open(filename, &#39;rb&#39;) as infile:</span>
<span class="gi">+                catalog = read_po(infile, locale=locale, domain=domain)</span>
<span class="gi">+</span>
<span class="gi">+            catalog.update(</span>
<span class="gi">+                template, self.no_fuzzy_matching,</span>
<span class="gi">+                update_header_comment=self.update_header_comment,</span>
<span class="gi">+                update_creation_date=not self.ignore_pot_creation_date,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            tmpname = os.path.join(os.path.dirname(filename),</span>
<span class="gi">+                                   tempfile.gettempprefix() +</span>
<span class="gi">+                                   os.path.basename(filename))</span>
<span class="gi">+            try:</span>
<span class="gi">+                with open(tmpname, &#39;wb&#39;) as tmpfile:</span>
<span class="gi">+                    write_po(tmpfile, catalog,</span>
<span class="gi">+                             omit_header=self.omit_header,</span>
<span class="gi">+                             ignore_obsolete=self.ignore_obsolete,</span>
<span class="gi">+                             include_previous=self.previous, width=self.width)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                os.remove(tmpname)</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            if self.check:</span>
<span class="gi">+                with open(filename, &quot;rb&quot;) as origfile:</span>
<span class="gi">+                    original_catalog = read_po(origfile)</span>
<span class="gi">+                with open(tmpname, &quot;rb&quot;) as newfile:</span>
<span class="gi">+                    updated_catalog = read_po(newfile)</span>
<span class="gi">+                updated_catalog.revision_date = original_catalog.revision_date</span>
<span class="gi">+                check_status[filename] = updated_catalog.is_identical(original_catalog)</span>
<span class="gi">+                os.remove(tmpname)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                os.rename(tmpname, filename)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # We&#39;re probably on Windows, which doesn&#39;t support atomic</span>
<span class="gi">+                # renames, at least not through Python</span>
<span class="gi">+                # If the error is in fact due to a permissions problem, that</span>
<span class="gi">+                # same error is going to be raised from one of the following</span>
<span class="gi">+                # operations</span>
<span class="gi">+                os.remove(filename)</span>
<span class="gi">+                shutil.copy(tmpname, filename)</span>
<span class="gi">+                os.remove(tmpname)</span>
<span class="gi">+</span>
<span class="gi">+        if self.check:</span>
<span class="gi">+            for filename, up_to_date in check_status.items():</span>
<span class="gi">+                if up_to_date:</span>
<span class="gi">+                    self.log.info(&#39;Catalog %s is up to date.&#39;, filename)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.log.warning(&#39;Catalog %s is out of date.&#39;, filename)</span>
<span class="gi">+            if not all(check_status.values()):</span>
<span class="gi">+                raise BaseError(&quot;Some catalogs are out of date.&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.log.info(&quot;All the catalogs are up-to-date.&quot;)</span>
<span class="gi">+            return</span>


<span class="w"> </span>class CommandLineInterface:
<span class="gu">@@ -205,30 +839,144 @@ class CommandLineInterface:</span>
<span class="w"> </span>    This class provides a simple command-line interface to the message
<span class="w"> </span>    extraction and PO file generation functionality.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    usage = &#39;%%prog %s [options] %s&#39;
<span class="w"> </span>    version = f&#39;%prog {VERSION}&#39;
<span class="gd">-    commands = {&#39;compile&#39;: &#39;compile message catalogs to MO files&#39;,</span>
<span class="gd">-        &#39;extract&#39;:</span>
<span class="gd">-        &#39;extract messages from source files and generate a POT file&#39;,</span>
<span class="gd">-        &#39;init&#39;: &#39;create new message catalogs from a POT file&#39;, &#39;update&#39;:</span>
<span class="gd">-        &#39;update existing message catalogs from a POT file&#39;}</span>
<span class="gd">-    command_classes = {&#39;compile&#39;: CompileCatalog, &#39;extract&#39;:</span>
<span class="gd">-        ExtractMessages, &#39;init&#39;: InitCatalog, &#39;update&#39;: UpdateCatalog}</span>
<span class="gd">-    log = None</span>
<span class="gi">+    commands = {</span>
<span class="gi">+        &#39;compile&#39;: &#39;compile message catalogs to MO files&#39;,</span>
<span class="gi">+        &#39;extract&#39;: &#39;extract messages from source files and generate a POT file&#39;,</span>
<span class="gi">+        &#39;init&#39;: &#39;create new message catalogs from a POT file&#39;,</span>
<span class="gi">+        &#39;update&#39;: &#39;update existing message catalogs from a POT file&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    command_classes = {</span>
<span class="gi">+        &#39;compile&#39;: CompileCatalog,</span>
<span class="gi">+        &#39;extract&#39;: ExtractMessages,</span>
<span class="gi">+        &#39;init&#39;: InitCatalog,</span>
<span class="gi">+        &#39;update&#39;: UpdateCatalog,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    log = None  # Replaced on instance level</span>

<span class="w"> </span>    def run(self, argv=None):
<span class="w"> </span>        &quot;&quot;&quot;Main entry point of the command-line interface.

<span class="w"> </span>        :param argv: list of arguments passed on the command-line
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if argv is None:</span>
<span class="gi">+            argv = sys.argv</span>
<span class="gi">+</span>
<span class="gi">+        self.parser = optparse.OptionParser(usage=self.usage % (&#39;command&#39;, &#39;[args]&#39;),</span>
<span class="gi">+                                            version=self.version)</span>
<span class="gi">+        self.parser.disable_interspersed_args()</span>
<span class="gi">+        self.parser.print_help = self._help</span>
<span class="gi">+        self.parser.add_option(&#39;--list-locales&#39;, dest=&#39;list_locales&#39;,</span>
<span class="gi">+                               action=&#39;store_true&#39;,</span>
<span class="gi">+                               help=&quot;print all known locales and exit&quot;)</span>
<span class="gi">+        self.parser.add_option(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;store_const&#39;,</span>
<span class="gi">+                               dest=&#39;loglevel&#39;, const=logging.DEBUG,</span>
<span class="gi">+                               help=&#39;print as much as possible&#39;)</span>
<span class="gi">+        self.parser.add_option(&#39;-q&#39;, &#39;--quiet&#39;, action=&#39;store_const&#39;,</span>
<span class="gi">+                               dest=&#39;loglevel&#39;, const=logging.ERROR,</span>
<span class="gi">+                               help=&#39;print as little as possible&#39;)</span>
<span class="gi">+        self.parser.set_defaults(list_locales=False, loglevel=logging.INFO)</span>
<span class="gi">+</span>
<span class="gi">+        options, args = self.parser.parse_args(argv[1:])</span>
<span class="gi">+</span>
<span class="gi">+        self._configure_logging(options.loglevel)</span>
<span class="gi">+        if options.list_locales:</span>
<span class="gi">+            identifiers = localedata.locale_identifiers()</span>
<span class="gi">+            id_width = max(len(identifier) for identifier in identifiers) + 1</span>
<span class="gi">+            for identifier in sorted(identifiers):</span>
<span class="gi">+                locale = Locale.parse(identifier)</span>
<span class="gi">+                print(f&quot;{identifier:&lt;{id_width}} {locale.english_name}&quot;)</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            self.parser.error(&#39;no valid command or option passed. &#39;</span>
<span class="gi">+                              &#39;Try the -h/--help option for more information.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        cmdname = args[0]</span>
<span class="gi">+        if cmdname not in self.commands:</span>
<span class="gi">+            self.parser.error(f&#39;unknown command &quot;{cmdname}&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        cmdinst = self._configure_command(cmdname, args[1:])</span>
<span class="gi">+        return cmdinst.run()</span>
<span class="gi">+</span>
<span class="gi">+    def _configure_logging(self, loglevel):</span>
<span class="gi">+        self.log = log</span>
<span class="gi">+        self.log.setLevel(loglevel)</span>
<span class="gi">+        # Don&#39;t add a new handler for every instance initialization (#227), this</span>
<span class="gi">+        # would cause duplicated output when the CommandLineInterface as an</span>
<span class="gi">+        # normal Python class.</span>
<span class="gi">+        if self.log.handlers:</span>
<span class="gi">+            handler = self.log.handlers[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            handler = logging.StreamHandler()</span>
<span class="gi">+            self.log.addHandler(handler)</span>
<span class="gi">+        handler.setLevel(loglevel)</span>
<span class="gi">+        formatter = logging.Formatter(&#39;%(message)s&#39;)</span>
<span class="gi">+        handler.setFormatter(formatter)</span>
<span class="gi">+</span>
<span class="gi">+    def _help(self):</span>
<span class="gi">+        print(self.parser.format_help())</span>
<span class="gi">+        print(&quot;commands:&quot;)</span>
<span class="gi">+        cmd_width = max(8, max(len(command) for command in self.commands) + 1)</span>
<span class="gi">+        for name, description in sorted(self.commands.items()):</span>
<span class="gi">+            print(f&quot;  {name:&lt;{cmd_width}} {description}&quot;)</span>

<span class="w"> </span>    def _configure_command(self, cmdname, argv):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :type cmdname: str
<span class="w"> </span>        :type argv: list[str]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cmdclass = self.command_classes[cmdname]</span>
<span class="gi">+        cmdinst = cmdclass()</span>
<span class="gi">+        if self.log:</span>
<span class="gi">+            cmdinst.log = self.log  # Use our logger, not distutils&#39;.</span>
<span class="gi">+        assert isinstance(cmdinst, CommandMixin)</span>
<span class="gi">+        cmdinst.initialize_options()</span>
<span class="gi">+</span>
<span class="gi">+        parser = optparse.OptionParser(</span>
<span class="gi">+            usage=self.usage % (cmdname, &#39;&#39;),</span>
<span class="gi">+            description=self.commands[cmdname],</span>
<span class="gi">+        )</span>
<span class="gi">+        as_args = getattr(cmdclass, &quot;as_args&quot;, ())</span>
<span class="gi">+        for long, short, help in cmdclass.user_options:</span>
<span class="gi">+            name = long.strip(&quot;=&quot;)</span>
<span class="gi">+            default = getattr(cmdinst, name.replace(&quot;-&quot;, &quot;_&quot;))</span>
<span class="gi">+            strs = [f&quot;--{name}&quot;]</span>
<span class="gi">+            if short:</span>
<span class="gi">+                strs.append(f&quot;-{short}&quot;)</span>
<span class="gi">+            strs.extend(cmdclass.option_aliases.get(name, ()))</span>
<span class="gi">+            choices = cmdclass.option_choices.get(name, None)</span>
<span class="gi">+            if name == as_args:</span>
<span class="gi">+                parser.usage += f&quot;&lt;{name}&gt;&quot;</span>
<span class="gi">+            elif name in cmdclass.boolean_options:</span>
<span class="gi">+                parser.add_option(*strs, action=&quot;store_true&quot;, help=help)</span>
<span class="gi">+            elif name in cmdclass.multiple_value_options:</span>
<span class="gi">+                parser.add_option(*strs, action=&quot;append&quot;, help=help, choices=choices)</span>
<span class="gi">+            else:</span>
<span class="gi">+                parser.add_option(*strs, help=help, default=default, choices=choices)</span>
<span class="gi">+        options, args = parser.parse_args(argv)</span>
<span class="gi">+</span>
<span class="gi">+        if as_args:</span>
<span class="gi">+            setattr(options, as_args.replace(&#39;-&#39;, &#39;_&#39;), args)</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in vars(options).items():</span>
<span class="gi">+            setattr(cmdinst, key, value)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            cmdinst.ensure_finalized()</span>
<span class="gi">+        except OptionError as err:</span>
<span class="gi">+            parser.error(str(err))</span>
<span class="gi">+</span>
<span class="gi">+        return cmdinst</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main():</span>
<span class="gi">+    return CommandLineInterface().run(sys.argv)</span>


<span class="w"> </span>def parse_mapping(fileobj, filename=None):
<span class="gu">@@ -280,10 +1028,45 @@ def parse_mapping(fileobj, filename=None):</span>
<span class="w"> </span>                    text to parse
<span class="w"> </span>    :see: `extract_from_directory`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    extractors = {}</span>
<span class="gi">+    method_map = []</span>
<span class="gi">+    options_map = {}</span>
<span class="gi">+</span>
<span class="gi">+    parser = RawConfigParser()</span>
<span class="gi">+    parser._sections = OrderedDict(parser._sections)  # We need ordered sections</span>
<span class="gi">+    parser.read_file(fileobj, filename)</span>
<span class="gi">+</span>
<span class="gi">+    for section in parser.sections():</span>
<span class="gi">+        if section == &#39;extractors&#39;:</span>
<span class="gi">+            extractors = dict(parser.items(section))</span>
<span class="gi">+        else:</span>
<span class="gi">+            method, pattern = (part.strip() for part in section.split(&#39;:&#39;, 1))</span>
<span class="gi">+            method_map.append((pattern, method))</span>
<span class="gi">+            options_map[pattern] = dict(parser.items(section))</span>
<span class="gi">+</span>
<span class="gi">+    if extractors:</span>
<span class="gi">+        for idx, (pattern, method) in enumerate(method_map):</span>
<span class="gi">+            if method in extractors:</span>
<span class="gi">+                method = extractors[method]</span>
<span class="gi">+            method_map[idx] = (pattern, method)</span>
<span class="gi">+</span>
<span class="gi">+    return method_map, options_map</span>


<span class="gd">-def parse_keywords(strings: Iterable[str]=()):</span>
<span class="gi">+def _parse_spec(s: str) -&gt; tuple[int | None, tuple[int | tuple[int, str], ...]]:</span>
<span class="gi">+    inds = []</span>
<span class="gi">+    number = None</span>
<span class="gi">+    for x in s.split(&#39;,&#39;):</span>
<span class="gi">+        if x[-1] == &#39;t&#39;:</span>
<span class="gi">+            number = int(x[:-1])</span>
<span class="gi">+        elif x[-1] == &#39;c&#39;:</span>
<span class="gi">+            inds.append((int(x[:-1]), &#39;c&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            inds.append(int(x))</span>
<span class="gi">+    return number, tuple(inds)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_keywords(strings: Iterable[str] = ()):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse keywords specifications from the given list of strings.

<span class="w"> </span>    &gt;&gt;&gt; import pprint
<span class="gu">@@ -312,15 +1095,34 @@ def parse_keywords(strings: Iterable[str]=()):</span>
<span class="w"> </span>    messages. A ``None`` specification is equivalent to ``(1,)``, extracting the first
<span class="w"> </span>    argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keywords = {}</span>
<span class="gi">+    for string in strings:</span>
<span class="gi">+        if &#39;:&#39; in string:</span>
<span class="gi">+            funcname, spec_str = string.split(&#39;:&#39;)</span>
<span class="gi">+            number, spec = _parse_spec(spec_str)</span>
<span class="gi">+        else:</span>
<span class="gi">+            funcname = string</span>
<span class="gi">+            number = None</span>
<span class="gi">+            spec = None</span>
<span class="gi">+        keywords.setdefault(funcname, {})[number] = spec</span>
<span class="gi">+</span>
<span class="gi">+    # For best backwards compatibility, collapse {None: x} into x.</span>
<span class="gi">+    for k, v in keywords.items():</span>
<span class="gi">+        if set(v) == {None}:</span>
<span class="gi">+            keywords[k] = v[None]</span>
<span class="gi">+</span>
<span class="gi">+    return keywords</span>


<span class="w"> </span>def __getattr__(name: str):
<span class="gd">-    if name in {&#39;check_message_extractors&#39;, &#39;compile_catalog&#39;,</span>
<span class="gd">-        &#39;extract_messages&#39;, &#39;init_catalog&#39;, &#39;update_catalog&#39;}:</span>
<span class="gi">+    # Re-exports for backwards compatibility;</span>
<span class="gi">+    # `setuptools_frontend` is the canonical import location.</span>
<span class="gi">+    if name in {&#39;check_message_extractors&#39;, &#39;compile_catalog&#39;, &#39;extract_messages&#39;, &#39;init_catalog&#39;, &#39;update_catalog&#39;}:</span>
<span class="w"> </span>        from babel.messages import setuptools_frontend
<span class="gi">+</span>
<span class="w"> </span>        return getattr(setuptools_frontend, name)
<span class="gd">-    raise AttributeError(f&#39;module {__name__!r} has no attribute {name!r}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    raise AttributeError(f&quot;module {__name__!r} has no attribute {name!r}&quot;)</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/babel/messages/jslexer.py b/babel/messages/jslexer.py</span>
<span class="gh">index a00f87d..6456bd0 100644</span>
<span class="gd">--- a/babel/messages/jslexer.py</span>
<span class="gi">+++ b/babel/messages/jslexer.py</span>
<span class="gu">@@ -9,24 +9,28 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Generator
<span class="w"> </span>from typing import NamedTuple
<span class="gd">-operators: list[str] = sorted([&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;%&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;,</span>
<span class="gd">-    &#39;&lt;=&#39;, &#39;&gt;=&#39;, &#39;=&#39;, &#39;+=&#39;, &#39;-=&#39;, &#39;*=&#39;, &#39;%=&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&gt;&gt;&gt;&#39;, &#39;&lt;&lt;=&#39;,</span>
<span class="gd">-    &#39;&gt;&gt;=&#39;, &#39;&gt;&gt;&gt;=&#39;, &#39;&amp;&#39;, &#39;&amp;=&#39;, &#39;|&#39;, &#39;|=&#39;, &#39;&amp;&amp;&#39;, &#39;||&#39;, &#39;^&#39;, &#39;^=&#39;, &#39;(&#39;, &#39;)&#39;,</span>
<span class="gd">-    &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;!&#39;, &#39;--&#39;, &#39;++&#39;, &#39;~&#39;, &#39;,&#39;, &#39;;&#39;, &#39;.&#39;, &#39;:&#39;], key=len,</span>
<span class="gd">-    reverse=True)</span>
<span class="gd">-escapes: dict[str, str] = {&#39;b&#39;: &#39;\x08&#39;, &#39;f&#39;: &#39;\x0c&#39;, &#39;n&#39;: &#39;\n&#39;, &#39;r&#39;: &#39;\r&#39;,</span>
<span class="gd">-    &#39;t&#39;: &#39;\t&#39;}</span>
<span class="gd">-name_re = re.compile(&#39;[\\w$_][\\w\\d$_]*&#39;, re.UNICODE)</span>
<span class="gd">-dotted_name_re = re.compile(&#39;[\\w$_][\\w\\d$_.]*[\\w\\d$_.]&#39;, re.UNICODE)</span>
<span class="gd">-division_re = re.compile(&#39;/=?&#39;)</span>
<span class="gd">-regex_re = re.compile(&#39;/(?:[^/\\\\]*(?:\\\\.[^/\\\\]*)*)/[a-zA-Z]*&#39;, re.DOTALL)</span>
<span class="gd">-line_re = re.compile(&#39;(\\r\\n|\\n|\\r)&#39;)</span>
<span class="gd">-line_join_re = re.compile(&#39;\\\\&#39; + line_re.pattern)</span>
<span class="gd">-uni_escape_re = re.compile(&#39;[a-fA-F0-9]{1,4}&#39;)</span>
<span class="gd">-hex_escape_re = re.compile(&#39;[a-fA-F0-9]{1,2}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+operators: list[str] = sorted([</span>
<span class="gi">+    &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;%&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;, &#39;=&#39;,</span>
<span class="gi">+    &#39;+=&#39;, &#39;-=&#39;, &#39;*=&#39;, &#39;%=&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&gt;&gt;&gt;&#39;, &#39;&lt;&lt;=&#39;, &#39;&gt;&gt;=&#39;,</span>
<span class="gi">+    &#39;&gt;&gt;&gt;=&#39;, &#39;&amp;&#39;, &#39;&amp;=&#39;, &#39;|&#39;, &#39;|=&#39;, &#39;&amp;&amp;&#39;, &#39;||&#39;, &#39;^&#39;, &#39;^=&#39;, &#39;(&#39;, &#39;)&#39;,</span>
<span class="gi">+    &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;!&#39;, &#39;--&#39;, &#39;++&#39;, &#39;~&#39;, &#39;,&#39;, &#39;;&#39;, &#39;.&#39;, &#39;:&#39;,</span>
<span class="gi">+], key=len, reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+escapes: dict[str, str] = {&#39;b&#39;: &#39;\b&#39;, &#39;f&#39;: &#39;\f&#39;, &#39;n&#39;: &#39;\n&#39;, &#39;r&#39;: &#39;\r&#39;, &#39;t&#39;: &#39;\t&#39;}</span>
<span class="gi">+</span>
<span class="gi">+name_re = re.compile(r&#39;[\w$_][\w\d$_]*&#39;, re.UNICODE)</span>
<span class="gi">+dotted_name_re = re.compile(r&#39;[\w$_][\w\d$_.]*[\w\d$_.]&#39;, re.UNICODE)</span>
<span class="gi">+division_re = re.compile(r&#39;/=?&#39;)</span>
<span class="gi">+regex_re = re.compile(r&#39;/(?:[^/\\]*(?:\\.[^/\\]*)*)/[a-zA-Z]*&#39;, re.DOTALL)</span>
<span class="gi">+line_re = re.compile(r&#39;(\r\n|\n|\r)&#39;)</span>
<span class="gi">+line_join_re = re.compile(r&#39;\\&#39; + line_re.pattern)</span>
<span class="gi">+uni_escape_re = re.compile(r&#39;[a-fA-F0-9]{1,4}&#39;)</span>
<span class="gi">+hex_escape_re = re.compile(r&#39;[a-fA-F0-9]{1,2}&#39;)</span>


<span class="w"> </span>class Token(NamedTuple):
<span class="gu">@@ -35,54 +39,126 @@ class Token(NamedTuple):</span>
<span class="w"> </span>    lineno: int


<span class="gd">-_rules: list[tuple[str | None, re.Pattern[str]]] = [(None, re.compile(</span>
<span class="gd">-    &#39;\\s+&#39;, re.UNICODE)), (None, re.compile(&#39;&lt;!--.*&#39;)), (&#39;linecomment&#39;, re.</span>
<span class="gd">-    compile(&#39;//.*&#39;)), (&#39;multilinecomment&#39;, re.compile(&#39;/\\*.*?\\*/&#39;, re.</span>
<span class="gd">-    UNICODE | re.DOTALL)), (&#39;dotted_name&#39;, dotted_name_re), (&#39;name&#39;,</span>
<span class="gd">-    name_re), (&#39;number&#39;, re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;(</span>
<span class="gd">-        (?:0|[1-9]\\d*)</span>
<span class="gd">-        (\\.\\d+)?</span>
<span class="gd">-        ([eE][-+]?\\d+)? |</span>
<span class="gi">+_rules: list[tuple[str | None, re.Pattern[str]]] = [</span>
<span class="gi">+    (None, re.compile(r&#39;\s+&#39;, re.UNICODE)),</span>
<span class="gi">+    (None, re.compile(r&#39;&lt;!--.*&#39;)),</span>
<span class="gi">+    (&#39;linecomment&#39;, re.compile(r&#39;//.*&#39;)),</span>
<span class="gi">+    (&#39;multilinecomment&#39;, re.compile(r&#39;/\*.*?\*/&#39;, re.UNICODE | re.DOTALL)),</span>
<span class="gi">+    (&#39;dotted_name&#39;, dotted_name_re),</span>
<span class="gi">+    (&#39;name&#39;, name_re),</span>
<span class="gi">+    (&#39;number&#39;, re.compile(r&#39;&#39;&#39;(</span>
<span class="gi">+        (?:0|[1-9]\d*)</span>
<span class="gi">+        (\.\d+)?</span>
<span class="gi">+        ([eE][-+]?\d+)? |</span>
<span class="w"> </span>        (0x[a-fA-F0-9]+)
<span class="gd">-    )&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)), (&#39;jsx_tag&#39;, re.compile(&#39;(?:&lt;/?[^&gt;\\s]+|/&gt;)&#39;, re.I)), (</span>
<span class="gd">-    &#39;operator&#39;, re.compile(&#39;(%s)&#39; % &#39;|&#39;.join(map(re.escape, operators)))),</span>
<span class="gd">-    (&#39;template_string&#39;, re.compile(&#39;`(?:[^`\\\\]*(?:\\\\.[^`\\\\]*)*)`&#39;, re</span>
<span class="gd">-    .UNICODE)), (&#39;string&#39;, re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;(</span>
<span class="gd">-        &#39;(?:[^&#39;\\\\]*(?:\\\\.[^&#39;\\\\]*)*)&#39;  |</span>
<span class="gd">-        &quot;(?:[^&quot;\\\\]*(?:\\\\.[^&quot;\\\\]*)*)&quot;</span>
<span class="gd">-    )&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE | re.DOTALL))]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_rules(jsx: bool, dotted: bool, template_string: bool) -&gt;list[tuple[</span>
<span class="gd">-    str | None, re.Pattern[str]]]:</span>
<span class="gi">+    )&#39;&#39;&#39;, re.VERBOSE)),</span>
<span class="gi">+    (&#39;jsx_tag&#39;, re.compile(r&#39;(?:&lt;/?[^&gt;\s]+|/&gt;)&#39;, re.I)),  # May be mangled in `get_rules`</span>
<span class="gi">+    (&#39;operator&#39;, re.compile(r&#39;(%s)&#39; % &#39;|&#39;.join(map(re.escape, operators)))),</span>
<span class="gi">+    (&#39;template_string&#39;, re.compile(r&#39;&#39;&#39;`(?:[^`\\]*(?:\\.[^`\\]*)*)`&#39;&#39;&#39;, re.UNICODE)),</span>
<span class="gi">+    (&#39;string&#39;, re.compile(r&#39;&#39;&#39;(</span>
<span class="gi">+        &#39;(?:[^&#39;\\]*(?:\\.[^&#39;\\]*)*)&#39;  |</span>
<span class="gi">+        &quot;(?:[^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;</span>
<span class="gi">+    )&#39;&#39;&#39;, re.VERBOSE | re.DOTALL)),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_rules(jsx: bool, dotted: bool, template_string: bool) -&gt; list[tuple[str | None, re.Pattern[str]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get a tokenization rule list given the passed syntax options.

<span class="w"> </span>    Internal to this module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def indicates_division(token: Token) -&gt;bool:</span>
<span class="gi">+    rules = []</span>
<span class="gi">+    for token_type, rule in _rules:</span>
<span class="gi">+        if not jsx and token_type and &#39;jsx&#39; in token_type:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if not template_string and token_type == &#39;template_string&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if token_type == &#39;dotted_name&#39;:</span>
<span class="gi">+            if not dotted:</span>
<span class="gi">+                continue</span>
<span class="gi">+            token_type = &#39;name&#39;</span>
<span class="gi">+        rules.append((token_type, rule))</span>
<span class="gi">+    return rules</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def indicates_division(token: Token) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;A helper function that helps the tokenizer to decide if the current
<span class="w"> </span>    token may be followed by a division operator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if token.type == &#39;operator&#39;:</span>
<span class="gi">+        return token.value in (&#39;)&#39;, &#39;]&#39;, &#39;}&#39;, &#39;++&#39;, &#39;--&#39;)</span>
<span class="gi">+    return token.type in (&#39;name&#39;, &#39;number&#39;, &#39;string&#39;, &#39;regexp&#39;)</span>


<span class="gd">-def unquote_string(string: str) -&gt;str:</span>
<span class="gi">+def unquote_string(string: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unquote a string with JavaScript rules.  The string has to start with
<span class="w"> </span>    string delimiters (``&#39;``, ``&quot;`` or the back-tick/grave accent (for template strings).)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def tokenize(source: str, jsx: bool=True, dotted: bool=True,</span>
<span class="gd">-    template_string: bool=True, lineno: int=1) -&gt;Generator[Token, None, None]:</span>
<span class="gi">+    assert string and string[0] == string[-1] and string[0] in &#39;&quot;\&#39;`&#39;, \</span>
<span class="gi">+        &#39;string provided is not properly delimited&#39;</span>
<span class="gi">+    string = line_join_re.sub(&#39;\\1&#39;, string[1:-1])</span>
<span class="gi">+    result: list[str] = []</span>
<span class="gi">+    add = result.append</span>
<span class="gi">+    pos = 0</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # scan for the next escape</span>
<span class="gi">+        escape_pos = string.find(&#39;\\&#39;, pos)</span>
<span class="gi">+        if escape_pos &lt; 0:</span>
<span class="gi">+            break</span>
<span class="gi">+        add(string[pos:escape_pos])</span>
<span class="gi">+</span>
<span class="gi">+        # check which character is escaped</span>
<span class="gi">+        next_char = string[escape_pos + 1]</span>
<span class="gi">+        if next_char in escapes:</span>
<span class="gi">+            add(escapes[next_char])</span>
<span class="gi">+</span>
<span class="gi">+        # unicode escapes.  trie to consume up to four characters of</span>
<span class="gi">+        # hexadecimal characters and try to interpret them as unicode</span>
<span class="gi">+        # character point.  If there is no such character point, put</span>
<span class="gi">+        # all the consumed characters into the string.</span>
<span class="gi">+        elif next_char in &#39;uU&#39;:</span>
<span class="gi">+            escaped = uni_escape_re.match(string, escape_pos + 2)</span>
<span class="gi">+            if escaped is not None:</span>
<span class="gi">+                escaped_value = escaped.group()</span>
<span class="gi">+                if len(escaped_value) == 4:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        add(chr(int(escaped_value, 16)))</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        pos = escape_pos + 6</span>
<span class="gi">+                        continue</span>
<span class="gi">+                add(next_char + escaped_value)</span>
<span class="gi">+                pos = escaped.end()</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                add(next_char)</span>
<span class="gi">+</span>
<span class="gi">+        # hex escapes. conversion from 2-digits hex to char is infallible</span>
<span class="gi">+        elif next_char in &#39;xX&#39;:</span>
<span class="gi">+            escaped = hex_escape_re.match(string, escape_pos + 2)</span>
<span class="gi">+            if escaped is not None:</span>
<span class="gi">+                escaped_value = escaped.group()</span>
<span class="gi">+                add(chr(int(escaped_value, 16)))</span>
<span class="gi">+                pos = escape_pos + 2 + len(escaped_value)</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                add(next_char)</span>
<span class="gi">+</span>
<span class="gi">+        # bogus escape.  Just remove the backslash.</span>
<span class="gi">+        else:</span>
<span class="gi">+            add(next_char)</span>
<span class="gi">+        pos = escape_pos + 2</span>
<span class="gi">+</span>
<span class="gi">+    if pos &lt; len(string):</span>
<span class="gi">+        add(string[pos:])</span>
<span class="gi">+</span>
<span class="gi">+    return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tokenize(source: str, jsx: bool = True, dotted: bool = True, template_string: bool = True, lineno: int = 1) -&gt; Generator[Token, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Tokenize JavaScript/JSX source.  Returns a generator of tokens.

<span class="gu">@@ -91,4 +167,37 @@ def tokenize(source: str, jsx: bool=True, dotted: bool=True,</span>
<span class="w"> </span>    :param template_string: Support ES6 template strings
<span class="w"> </span>    :param lineno: starting line number (optional)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    may_divide = False</span>
<span class="gi">+    pos = 0</span>
<span class="gi">+    end = len(source)</span>
<span class="gi">+    rules = get_rules(jsx=jsx, dotted=dotted, template_string=template_string)</span>
<span class="gi">+</span>
<span class="gi">+    while pos &lt; end:</span>
<span class="gi">+        # handle regular rules first</span>
<span class="gi">+        for token_type, rule in rules:  # noqa: B007</span>
<span class="gi">+            match = rule.match(source, pos)</span>
<span class="gi">+            if match is not None:</span>
<span class="gi">+                break</span>
<span class="gi">+        # if we don&#39;t have a match we don&#39;t give up yet, but check for</span>
<span class="gi">+        # division operators or regular expression literals, based on</span>
<span class="gi">+        # the status of `may_divide` which is determined by the last</span>
<span class="gi">+        # processed non-whitespace token using `indicates_division`.</span>
<span class="gi">+        else:</span>
<span class="gi">+            if may_divide:</span>
<span class="gi">+                match = division_re.match(source, pos)</span>
<span class="gi">+                token_type = &#39;operator&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                match = regex_re.match(source, pos)</span>
<span class="gi">+                token_type = &#39;regexp&#39;</span>
<span class="gi">+            if match is None:</span>
<span class="gi">+                # woops. invalid syntax. jump one char ahead and try again.</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        token_value = match.group()</span>
<span class="gi">+        if token_type is not None:</span>
<span class="gi">+            token = Token(token_type, token_value, lineno)</span>
<span class="gi">+            may_divide = indicates_division(token)</span>
<span class="gi">+            yield token</span>
<span class="gi">+        lineno += len(line_re.findall(token_value))</span>
<span class="gi">+        pos = match.end()</span>
<span class="gh">diff --git a/babel/messages/mofile.py b/babel/messages/mofile.py</span>
<span class="gh">index 2924f4e..ca02e68 100644</span>
<span class="gd">--- a/babel/messages/mofile.py</span>
<span class="gi">+++ b/babel/messages/mofile.py</span>
<span class="gu">@@ -8,17 +8,21 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import array
<span class="w"> </span>import struct
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from babel.messages.catalog import Catalog, Message
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from _typeshed import SupportsRead, SupportsWrite
<span class="gd">-LE_MAGIC: int = 2500072158</span>
<span class="gd">-BE_MAGIC: int = 3725722773</span>

<span class="gi">+LE_MAGIC: int = 0x950412de</span>
<span class="gi">+BE_MAGIC: int = 0xde120495</span>

<span class="gd">-def read_mo(fileobj: SupportsRead[bytes]) -&gt;Catalog:</span>
<span class="gi">+</span>
<span class="gi">+def read_mo(fileobj: SupportsRead[bytes]) -&gt; Catalog:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a binary MO file from the given file-like object and return a
<span class="w"> </span>    corresponding `Catalog` object.

<span class="gu">@@ -28,11 +32,81 @@ def read_mo(fileobj: SupportsRead[bytes]) -&gt;Catalog:</span>
<span class="w"> </span>           ``GNUTranslations._parse`` method of the ``gettext`` module in the
<span class="w"> </span>           standard library.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    catalog = Catalog()</span>
<span class="gi">+    headers = {}</span>
<span class="gi">+</span>
<span class="gi">+    filename = getattr(fileobj, &#39;name&#39;, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    buf = fileobj.read()</span>
<span class="gi">+    buflen = len(buf)</span>
<span class="gi">+    unpack = struct.unpack</span>
<span class="gi">+</span>
<span class="gi">+    # Parse the .mo file header, which consists of 5 little endian 32</span>
<span class="gi">+    # bit words.</span>
<span class="gi">+    magic = unpack(&#39;&lt;I&#39;, buf[:4])[0]  # Are we big endian or little endian?</span>
<span class="gi">+    if magic == LE_MAGIC:</span>
<span class="gi">+        version, msgcount, origidx, transidx = unpack(&#39;&lt;4I&#39;, buf[4:20])</span>
<span class="gi">+        ii = &#39;&lt;II&#39;</span>
<span class="gi">+    elif magic == BE_MAGIC:</span>
<span class="gi">+        version, msgcount, origidx, transidx = unpack(&#39;&gt;4I&#39;, buf[4:20])</span>
<span class="gi">+        ii = &#39;&gt;II&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise OSError(0, &#39;Bad magic number&#39;, filename)</span>
<span class="gi">+</span>
<span class="gi">+    # Now put all messages from the .mo file buffer into the catalog</span>
<span class="gi">+    # dictionary</span>
<span class="gi">+    for _i in range(msgcount):</span>
<span class="gi">+        mlen, moff = unpack(ii, buf[origidx:origidx + 8])</span>
<span class="gi">+        mend = moff + mlen</span>
<span class="gi">+        tlen, toff = unpack(ii, buf[transidx:transidx + 8])</span>
<span class="gi">+        tend = toff + tlen</span>
<span class="gi">+        if mend &lt; buflen and tend &lt; buflen:</span>
<span class="gi">+            msg = buf[moff:mend]</span>
<span class="gi">+            tmsg = buf[toff:tend]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise OSError(0, &#39;File is corrupt&#39;, filename)</span>
<span class="gi">+</span>
<span class="gi">+        # See if we&#39;re looking at GNU .mo conventions for metadata</span>
<span class="gi">+        if mlen == 0:</span>
<span class="gi">+            # Catalog description</span>
<span class="gi">+            lastkey = key = None</span>
<span class="gi">+            for item in tmsg.splitlines():</span>
<span class="gi">+                item = item.strip()</span>
<span class="gi">+                if not item:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if b&#39;:&#39; in item:</span>
<span class="gi">+                    key, value = item.split(b&#39;:&#39;, 1)</span>
<span class="gi">+                    lastkey = key = key.strip().lower()</span>
<span class="gi">+                    headers[key] = value.strip()</span>
<span class="gi">+                elif lastkey:</span>
<span class="gi">+                    headers[lastkey] += b&#39;\n&#39; + item</span>

<span class="gi">+        if b&#39;\x04&#39; in msg:  # context</span>
<span class="gi">+            ctxt, msg = msg.split(b&#39;\x04&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ctxt = None</span>

<span class="gd">-def write_mo(fileobj: SupportsWrite[bytes], catalog: Catalog, use_fuzzy:</span>
<span class="gd">-    bool=False) -&gt;None:</span>
<span class="gi">+        if b&#39;\x00&#39; in msg:  # plural forms</span>
<span class="gi">+            msg = msg.split(b&#39;\x00&#39;)</span>
<span class="gi">+            tmsg = tmsg.split(b&#39;\x00&#39;)</span>
<span class="gi">+            if catalog.charset:</span>
<span class="gi">+                msg = [x.decode(catalog.charset) for x in msg]</span>
<span class="gi">+                tmsg = [x.decode(catalog.charset) for x in tmsg]</span>
<span class="gi">+        else:</span>
<span class="gi">+            if catalog.charset:</span>
<span class="gi">+                msg = msg.decode(catalog.charset)</span>
<span class="gi">+                tmsg = tmsg.decode(catalog.charset)</span>
<span class="gi">+        catalog[msg] = Message(msg, tmsg, context=ctxt)</span>
<span class="gi">+</span>
<span class="gi">+        # advance to next entry in the seek tables</span>
<span class="gi">+        origidx += 8</span>
<span class="gi">+        transidx += 8</span>
<span class="gi">+</span>
<span class="gi">+    catalog.mime_headers = headers.items()</span>
<span class="gi">+    return catalog</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_mo(fileobj: SupportsWrite[bytes], catalog: Catalog, use_fuzzy: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a catalog to the specified file-like object using the GNU MO file
<span class="w"> </span>    format.

<span class="gu">@@ -80,4 +154,59 @@ def write_mo(fileobj: SupportsWrite[bytes], catalog: Catalog, use_fuzzy:</span>
<span class="w"> </span>    :param use_fuzzy: whether translations marked as &quot;fuzzy&quot; should be included
<span class="w"> </span>                      in the output
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    messages = list(catalog)</span>
<span class="gi">+    messages[1:] = [m for m in messages[1:]</span>
<span class="gi">+                    if m.string and (use_fuzzy or not m.fuzzy)]</span>
<span class="gi">+    messages.sort()</span>
<span class="gi">+</span>
<span class="gi">+    ids = strs = b&#39;&#39;</span>
<span class="gi">+    offsets = []</span>
<span class="gi">+</span>
<span class="gi">+    for message in messages:</span>
<span class="gi">+        # For each string, we need size and file offset.  Each string is NUL</span>
<span class="gi">+        # terminated; the NUL does not count into the size.</span>
<span class="gi">+        if message.pluralizable:</span>
<span class="gi">+            msgid = b&#39;\x00&#39;.join([</span>
<span class="gi">+                msgid.encode(catalog.charset) for msgid in message.id</span>
<span class="gi">+            ])</span>
<span class="gi">+            msgstrs = []</span>
<span class="gi">+            for idx, string in enumerate(message.string):</span>
<span class="gi">+                if not string:</span>
<span class="gi">+                    msgstrs.append(message.id[min(int(idx), 1)])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    msgstrs.append(string)</span>
<span class="gi">+            msgstr = b&#39;\x00&#39;.join([</span>
<span class="gi">+                msgstr.encode(catalog.charset) for msgstr in msgstrs</span>
<span class="gi">+            ])</span>
<span class="gi">+        else:</span>
<span class="gi">+            msgid = message.id.encode(catalog.charset)</span>
<span class="gi">+            msgstr = message.string.encode(catalog.charset)</span>
<span class="gi">+        if message.context:</span>
<span class="gi">+            msgid = b&#39;\x04&#39;.join([message.context.encode(catalog.charset),</span>
<span class="gi">+                                  msgid])</span>
<span class="gi">+        offsets.append((len(ids), len(msgid), len(strs), len(msgstr)))</span>
<span class="gi">+        ids += msgid + b&#39;\x00&#39;</span>
<span class="gi">+        strs += msgstr + b&#39;\x00&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # The header is 7 32-bit unsigned integers.  We don&#39;t use hash tables, so</span>
<span class="gi">+    # the keys start right after the index tables.</span>
<span class="gi">+    keystart = 7 * 4 + 16 * len(messages)</span>
<span class="gi">+    valuestart = keystart + len(ids)</span>
<span class="gi">+</span>
<span class="gi">+    # The string table first has the list of keys, then the list of values.</span>
<span class="gi">+    # Each entry has first the size of the string, then the file offset.</span>
<span class="gi">+    koffsets = []</span>
<span class="gi">+    voffsets = []</span>
<span class="gi">+    for o1, l1, o2, l2 in offsets:</span>
<span class="gi">+        koffsets += [l1, o1 + keystart]</span>
<span class="gi">+        voffsets += [l2, o2 + valuestart]</span>
<span class="gi">+    offsets = koffsets + voffsets</span>
<span class="gi">+</span>
<span class="gi">+    fileobj.write(struct.pack(&#39;Iiiiiii&#39;,</span>
<span class="gi">+                              LE_MAGIC,                   # magic</span>
<span class="gi">+                              0,                          # version</span>
<span class="gi">+                              len(messages),              # number of entries</span>
<span class="gi">+                              7 * 4,                      # start of key index</span>
<span class="gi">+                              7 * 4 + len(messages) * 8,  # start of value index</span>
<span class="gi">+                              0, 0,                       # size and offset of hash table</span>
<span class="gi">+                              ) + array.array.tobytes(array.array(&quot;i&quot;, offsets)) + ids + strs)</span>
<span class="gh">diff --git a/babel/messages/plurals.py b/babel/messages/plurals.py</span>
<span class="gh">index 1097d43..fa3f03e 100644</span>
<span class="gd">--- a/babel/messages/plurals.py</span>
<span class="gi">+++ b/babel/messages/plurals.py</span>
<span class="gu">@@ -8,73 +8,219 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>from babel.core import Locale, default_locale
<span class="gi">+</span>
<span class="gi">+# XXX: remove this file, duplication with babel.plural</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>LC_CTYPE: str | None = default_locale(&#39;LC_CTYPE&#39;)
<span class="gd">-PLURALS: dict[str, tuple[int, str]] = {&#39;af&#39;: (2, &#39;(n != 1)&#39;), &#39;ar&#39;: (6,</span>
<span class="gd">-    &#39;(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100&gt;=3 &amp;&amp; n%100&lt;=10 ? 3 : n%100&gt;=0 &amp;&amp; n%100&lt;=2 ? 4 : 5)&#39;</span>
<span class="gd">-    ), &#39;be&#39;: (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;bg&#39;: (2, &#39;(n != 1)&#39;), &#39;bn&#39;: (2, &#39;(n != 1)&#39;), &#39;bo&#39;: (1, &#39;0&#39;), &#39;br&#39;:</span>
<span class="gd">-    (6,</span>
<span class="gd">-    &#39;(n==1 ? 0 : n%10==1 &amp;&amp; n%100!=11 &amp;&amp; n%100!=71 &amp;&amp; n%100!=91 ? 1 : n%10==2 &amp;&amp; n%100!=12 &amp;&amp; n%100!=72 &amp;&amp; n%100!=92 ? 2 : (n%10==3 || n%10==4 || n%10==9) &amp;&amp; n%100!=13 &amp;&amp; n%100!=14 &amp;&amp; n%100!=19 &amp;&amp; n%100!=73 &amp;&amp; n%100!=74 &amp;&amp; n%100!=79 &amp;&amp; n%100!=93 &amp;&amp; n%100!=94 &amp;&amp; n%100!=99 ? 3 : n%1000000==0 ? 4 : 5)&#39;</span>
<span class="gd">-    ), &#39;bs&#39;: (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;ca&#39;: (2, &#39;(n != 1)&#39;), &#39;cs&#39;: (3,</span>
<span class="gd">-    &#39;((n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2)&#39;), &#39;cv&#39;: (1, &#39;0&#39;), &#39;cy&#39;: (5,</span>
<span class="gd">-    &#39;(n==1 ? 1 : n==2 ? 2 : n==3 ? 3 : n==6 ? 4 : 0)&#39;), &#39;da&#39;: (2,</span>
<span class="gd">-    &#39;(n != 1)&#39;), &#39;de&#39;: (2, &#39;(n != 1)&#39;), &#39;dz&#39;: (1, &#39;0&#39;), &#39;el&#39;: (2,</span>
<span class="gd">-    &#39;(n != 1)&#39;), &#39;en&#39;: (2, &#39;(n != 1)&#39;), &#39;eo&#39;: (2, &#39;(n != 1)&#39;), &#39;es&#39;: (2,</span>
<span class="gd">-    &#39;(n != 1)&#39;), &#39;et&#39;: (2, &#39;(n != 1)&#39;), &#39;eu&#39;: (2, &#39;(n != 1)&#39;), &#39;fa&#39;: (1,</span>
<span class="gd">-    &#39;0&#39;), &#39;fi&#39;: (2, &#39;(n != 1)&#39;), &#39;fr&#39;: (2, &#39;(n &gt; 1)&#39;), &#39;fur&#39;: (2, &#39;(n &gt; 1)&#39;</span>
<span class="gd">-    ), &#39;ga&#39;: (5,</span>
<span class="gd">-    &#39;(n==1 ? 0 : n==2 ? 1 : n&gt;=3 &amp;&amp; n&lt;=6 ? 2 : n&gt;=7 &amp;&amp; n&lt;=10 ? 3 : 4)&#39;),</span>
<span class="gd">-    &#39;gl&#39;: (2, &#39;(n != 1)&#39;), &#39;ha&#39;: (2, &#39;(n != 1)&#39;), &#39;he&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gd">-    &#39;hi&#39;: (2, &#39;(n != 1)&#39;), &#39;hr&#39;: (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;hu&#39;: (1, &#39;0&#39;), &#39;hy&#39;: (1, &#39;0&#39;), &#39;is&#39;: (2,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : 1)&#39;), &#39;it&#39;: (2, &#39;(n != 1)&#39;), &#39;ja&#39;: (1, &#39;0&#39;</span>
<span class="gd">-    ), &#39;ka&#39;: (1, &#39;0&#39;), &#39;kg&#39;: (2, &#39;(n != 1)&#39;), &#39;km&#39;: (1, &#39;0&#39;), &#39;ko&#39;: (1, &#39;0&#39;</span>
<span class="gd">-    ), &#39;ku&#39;: (2, &#39;(n != 1)&#39;), &#39;lo&#39;: (1, &#39;0&#39;), &#39;lt&#39;: (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;lv&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2)&#39;), &#39;mt&#39;: (4,</span>
<span class="gd">-    &#39;(n==1 ? 0 : n==0 || ( n%100&gt;=1 &amp;&amp; n%100&lt;=10) ? 1 : (n%100&gt;10 &amp;&amp; n%100&lt;20 ) ? 2 : 3)&#39;</span>
<span class="gd">-    ), &#39;nb&#39;: (2, &#39;(n != 1)&#39;), &#39;nl&#39;: (2, &#39;(n != 1)&#39;), &#39;nn&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gd">-    &#39;no&#39;: (2, &#39;(n != 1)&#39;), &#39;pa&#39;: (2, &#39;(n != 1)&#39;), &#39;pl&#39;: (3,</span>
<span class="gd">-    &#39;(n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gd">-    &#39;pt&#39;: (2, &#39;(n != 1)&#39;), &#39;pt_BR&#39;: (2, &#39;(n &gt; 1)&#39;), &#39;ro&#39;: (3,</span>
<span class="gd">-    &#39;(n==1 ? 0 : (n==0 || (n%100 &gt; 0 &amp;&amp; n%100 &lt; 20)) ? 1 : 2)&#39;), &#39;ru&#39;: (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;sk&#39;: (3, &#39;((n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2)&#39;), &#39;sl&#39;: (4,</span>
<span class="gd">-    &#39;(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3)&#39;), &#39;sr&#39;:</span>
<span class="gd">-    (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;st&#39;: (2, &#39;(n != 1)&#39;), &#39;sv&#39;: (2, &#39;(n != 1)&#39;), &#39;th&#39;: (1, &#39;0&#39;), &#39;tr&#39;:</span>
<span class="gd">-    (1, &#39;0&#39;), &#39;uk&#39;: (3,</span>
<span class="gd">-    &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;</span>
<span class="gd">-    ), &#39;ve&#39;: (2, &#39;(n != 1)&#39;), &#39;vi&#39;: (1, &#39;0&#39;), &#39;xh&#39;: (2, &#39;(n != 1)&#39;), &#39;zh&#39;:</span>
<span class="gd">-    (1, &#39;0&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+PLURALS: dict[str, tuple[int, str]] = {</span>
<span class="gi">+    # Afar</span>
<span class="gi">+    # &#39;aa&#39;: (),</span>
<span class="gi">+    # Abkhazian</span>
<span class="gi">+    # &#39;ab&#39;: (),</span>
<span class="gi">+    # Avestan</span>
<span class="gi">+    # &#39;ae&#39;: (),</span>
<span class="gi">+    # Afrikaans - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;af&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Akan</span>
<span class="gi">+    # &#39;ak&#39;: (),</span>
<span class="gi">+    # Amharic</span>
<span class="gi">+    # &#39;am&#39;: (),</span>
<span class="gi">+    # Aragonese</span>
<span class="gi">+    # &#39;an&#39;: (),</span>
<span class="gi">+    # Arabic - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ar&#39;: (6, &#39;(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100&gt;=3 &amp;&amp; n%100&lt;=10 ? 3 : n%100&gt;=0 &amp;&amp; n%100&lt;=2 ? 4 : 5)&#39;),</span>
<span class="gi">+    # Assamese</span>
<span class="gi">+    # &#39;as&#39;: (),</span>
<span class="gi">+    # Avaric</span>
<span class="gi">+    # &#39;av&#39;: (),</span>
<span class="gi">+    # Aymara</span>
<span class="gi">+    # &#39;ay&#39;: (),</span>
<span class="gi">+    # Azerbaijani</span>
<span class="gi">+    # &#39;az&#39;: (),</span>
<span class="gi">+    # Bashkir</span>
<span class="gi">+    # &#39;ba&#39;: (),</span>
<span class="gi">+    # Belarusian</span>
<span class="gi">+    &#39;be&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Bulgarian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;bg&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Bihari</span>
<span class="gi">+    # &#39;bh&#39;: (),</span>
<span class="gi">+    # Bislama</span>
<span class="gi">+    # &#39;bi&#39;: (),</span>
<span class="gi">+    # Bambara</span>
<span class="gi">+    # &#39;bm&#39;: (),</span>
<span class="gi">+    # Bengali - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;bn&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Tibetan - as discussed in private with Andrew West</span>
<span class="gi">+    &#39;bo&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Breton</span>
<span class="gi">+    &#39;br&#39;: (</span>
<span class="gi">+        6,</span>
<span class="gi">+        &#39;(n==1 ? 0 : n%10==1 &amp;&amp; n%100!=11 &amp;&amp; n%100!=71 &amp;&amp; n%100!=91 ? 1 : n%10==2 &amp;&amp; n%100!=12 &amp;&amp; n%100!=72 &amp;&amp; &#39;</span>
<span class="gi">+        &#39;n%100!=92 ? 2 : (n%10==3 || n%10==4 || n%10==9) &amp;&amp; n%100!=13 &amp;&amp; n%100!=14 &amp;&amp; n%100!=19 &amp;&amp; n%100!=73 &amp;&amp; &#39;</span>
<span class="gi">+        &#39;n%100!=74 &amp;&amp; n%100!=79 &amp;&amp; n%100!=93 &amp;&amp; n%100!=94 &amp;&amp; n%100!=99 ? 3 : n%1000000==0 ? 4 : 5)&#39;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    # Bosnian</span>
<span class="gi">+    &#39;bs&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Catalan - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ca&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Chechen</span>
<span class="gi">+    # &#39;ce&#39;: (),</span>
<span class="gi">+    # Chamorro</span>
<span class="gi">+    # &#39;ch&#39;: (),</span>
<span class="gi">+    # Corsican</span>
<span class="gi">+    # &#39;co&#39;: (),</span>
<span class="gi">+    # Cree</span>
<span class="gi">+    # &#39;cr&#39;: (),</span>
<span class="gi">+    # Czech</span>
<span class="gi">+    &#39;cs&#39;: (3, &#39;((n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Church Slavic</span>
<span class="gi">+    # &#39;cu&#39;: (),</span>
<span class="gi">+    # Chuvash</span>
<span class="gi">+    &#39;cv&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Welsh</span>
<span class="gi">+    &#39;cy&#39;: (5, &#39;(n==1 ? 1 : n==2 ? 2 : n==3 ? 3 : n==6 ? 4 : 0)&#39;),</span>
<span class="gi">+    # Danish</span>
<span class="gi">+    &#39;da&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # German</span>
<span class="gi">+    &#39;de&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Divehi</span>
<span class="gi">+    # &#39;dv&#39;: (),</span>
<span class="gi">+    # Dzongkha</span>
<span class="gi">+    &#39;dz&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Greek</span>
<span class="gi">+    &#39;el&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # English</span>
<span class="gi">+    &#39;en&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Esperanto</span>
<span class="gi">+    &#39;eo&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Spanish</span>
<span class="gi">+    &#39;es&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Estonian</span>
<span class="gi">+    &#39;et&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Basque - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;eu&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Persian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;fa&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Finnish</span>
<span class="gi">+    &#39;fi&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # French</span>
<span class="gi">+    &#39;fr&#39;: (2, &#39;(n &gt; 1)&#39;),</span>
<span class="gi">+    # Friulian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;fur&#39;: (2, &#39;(n &gt; 1)&#39;),</span>
<span class="gi">+    # Irish</span>
<span class="gi">+    &#39;ga&#39;: (5, &#39;(n==1 ? 0 : n==2 ? 1 : n&gt;=3 &amp;&amp; n&lt;=6 ? 2 : n&gt;=7 &amp;&amp; n&lt;=10 ? 3 : 4)&#39;),</span>
<span class="gi">+    # Galician - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;gl&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Hausa - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ha&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Hebrew</span>
<span class="gi">+    &#39;he&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Hindi - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;hi&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Croatian</span>
<span class="gi">+    &#39;hr&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Hungarian</span>
<span class="gi">+    &#39;hu&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Armenian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;hy&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Icelandic - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;is&#39;: (2, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : 1)&#39;),</span>
<span class="gi">+    # Italian</span>
<span class="gi">+    &#39;it&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Japanese</span>
<span class="gi">+    &#39;ja&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Georgian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ka&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Kongo - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;kg&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Khmer - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;km&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Korean</span>
<span class="gi">+    &#39;ko&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Kurdish - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ku&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Lao - Another member of the Tai language family, like Thai.</span>
<span class="gi">+    &#39;lo&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Lithuanian</span>
<span class="gi">+    &#39;lt&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Latvian</span>
<span class="gi">+    &#39;lv&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2)&#39;),</span>
<span class="gi">+    # Maltese - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;mt&#39;: (4, &#39;(n==1 ? 0 : n==0 || ( n%100&gt;=1 &amp;&amp; n%100&lt;=10) ? 1 : (n%100&gt;10 &amp;&amp; n%100&lt;20 ) ? 2 : 3)&#39;),</span>
<span class="gi">+    # Norwegian Bokml</span>
<span class="gi">+    &#39;nb&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Dutch</span>
<span class="gi">+    &#39;nl&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Norwegian Nynorsk</span>
<span class="gi">+    &#39;nn&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Norwegian</span>
<span class="gi">+    &#39;no&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Punjabi - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;pa&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Polish</span>
<span class="gi">+    &#39;pl&#39;: (3, &#39;(n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Portuguese</span>
<span class="gi">+    &#39;pt&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Brazilian</span>
<span class="gi">+    &#39;pt_BR&#39;: (2, &#39;(n &gt; 1)&#39;),</span>
<span class="gi">+    # Romanian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ro&#39;: (3, &#39;(n==1 ? 0 : (n==0 || (n%100 &gt; 0 &amp;&amp; n%100 &lt; 20)) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Russian</span>
<span class="gi">+    &#39;ru&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Slovak</span>
<span class="gi">+    &#39;sk&#39;: (3, &#39;((n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Slovenian</span>
<span class="gi">+    &#39;sl&#39;: (4, &#39;(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3)&#39;),</span>
<span class="gi">+    # Serbian - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;sr&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Southern Sotho - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;st&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Swedish</span>
<span class="gi">+    &#39;sv&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Thai</span>
<span class="gi">+    &#39;th&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Turkish</span>
<span class="gi">+    &#39;tr&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Ukrainian</span>
<span class="gi">+    &#39;uk&#39;: (3, &#39;(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2)&#39;),</span>
<span class="gi">+    # Venda - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;ve&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Vietnamese - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;vi&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+    # Xhosa - From Pootle&#39;s PO&#39;s</span>
<span class="gi">+    &#39;xh&#39;: (2, &#39;(n != 1)&#39;),</span>
<span class="gi">+    # Chinese - From Pootle&#39;s PO&#39;s (modified)</span>
<span class="gi">+    &#39;zh&#39;: (1, &#39;0&#39;),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_PLURAL: tuple[int, str] = (2, &#39;(n != 1)&#39;)


<span class="w"> </span>class _PluralTuple(tuple):
<span class="w"> </span>    &quot;&quot;&quot;A tuple with plural information.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    num_plurals = property(itemgetter(0), doc=</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+    num_plurals = property(itemgetter(0), doc=&quot;&quot;&quot;</span>
<span class="w"> </span>    The number of plurals used by the locale.&quot;&quot;&quot;)
<span class="gd">-    plural_expr = property(itemgetter(1), doc=</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+    plural_expr = property(itemgetter(1), doc=&quot;&quot;&quot;</span>
<span class="w"> </span>    The plural expression used by the locale.&quot;&quot;&quot;)
<span class="gd">-    plural_forms = property(lambda x: &#39;nplurals={}; plural={};&#39;.format(*x),</span>
<span class="gd">-        doc=&quot;&quot;&quot;</span>
<span class="gi">+    plural_forms = property(lambda x: &#39;nplurals={}; plural={};&#39;.format(*x), doc=&quot;&quot;&quot;</span>
<span class="w"> </span>    The plural expression used by the catalog or locale.&quot;&quot;&quot;)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.plural_forms


<span class="gd">-def get_plural(locale: (str | None)=LC_CTYPE) -&gt;_PluralTuple:</span>
<span class="gi">+def get_plural(locale: str | None = LC_CTYPE) -&gt; _PluralTuple:</span>
<span class="w"> </span>    &quot;&quot;&quot;A tuple with the information catalogs need to perform proper
<span class="w"> </span>    pluralization.  The first item of the tuple is the number of plural
<span class="w"> </span>    forms, the second the plural expression.
<span class="gu">@@ -100,4 +246,12 @@ def get_plural(locale: (str | None)=LC_CTYPE) -&gt;_PluralTuple:</span>
<span class="w"> </span>    &gt;&gt;&gt; str(tup)
<span class="w"> </span>    &#39;nplurals=1; plural=0;&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    try:</span>
<span class="gi">+        tup = PLURALS[str(locale)]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            tup = PLURALS[locale.language]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            tup = DEFAULT_PLURAL</span>
<span class="gi">+    return _PluralTuple(tup)</span>
<span class="gh">diff --git a/babel/messages/pofile.py b/babel/messages/pofile.py</span>
<span class="gh">index bbc0cb7..b64a508 100644</span>
<span class="gd">--- a/babel/messages/pofile.py</span>
<span class="gi">+++ b/babel/messages/pofile.py</span>
<span class="gu">@@ -9,61 +9,81 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from babel.core import Locale
<span class="w"> </span>from babel.messages.catalog import Catalog, Message
<span class="w"> </span>from babel.util import _cmp, wraptext
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import IO, AnyStr
<span class="gi">+</span>
<span class="w"> </span>    from _typeshed import SupportsWrite
<span class="w"> </span>    from typing_extensions import Literal


<span class="gd">-def unescape(string: str) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Reverse `escape` the given string.</span>
<span class="gi">+def unescape(string: str) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Reverse `escape` the given string.</span>

<span class="gd">-    &gt;&gt;&gt; print(unescape(&#39;&quot;Say:\\\\n  \\\\&quot;hello, world!\\\\&quot;\\\\n&quot;&#39;))</span>
<span class="gi">+    &gt;&gt;&gt; print(unescape(&#39;&quot;Say:\\n  \\&quot;hello, world!\\&quot;\\n&quot;&#39;))</span>
<span class="w"> </span>    Say:
<span class="w"> </span>      &quot;hello, world!&quot;
<span class="w"> </span>    &lt;BLANKLINE&gt;

<span class="w"> </span>    :param string: the string to unescape
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def denormalize(string: str) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Reverse the normalization done by the `normalize` function.</span>
<span class="gi">+    def replace_escapes(match):</span>
<span class="gi">+        m = match.group(1)</span>
<span class="gi">+        if m == &#39;n&#39;:</span>
<span class="gi">+            return &#39;\n&#39;</span>
<span class="gi">+        elif m == &#39;t&#39;:</span>
<span class="gi">+            return &#39;\t&#39;</span>
<span class="gi">+        elif m == &#39;r&#39;:</span>
<span class="gi">+            return &#39;\r&#39;</span>
<span class="gi">+        # m is \ or &quot;</span>
<span class="gi">+        return m</span>
<span class="gi">+    return re.compile(r&#39;\\([\\trn&quot;])&#39;).sub(replace_escapes, string[1:-1])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def denormalize(string: str) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Reverse the normalization done by the `normalize` function.</span>

<span class="w"> </span>    &gt;&gt;&gt; print(denormalize(r&#39;&#39;&#39;&quot;&quot;
<span class="gd">-    ... &quot;Say:\\n&quot;</span>
<span class="gd">-    ... &quot;  \\&quot;hello, world!\\&quot;\\n&quot;&#39;&#39;&#39;))</span>
<span class="gi">+    ... &quot;Say:\n&quot;</span>
<span class="gi">+    ... &quot;  \&quot;hello, world!\&quot;\n&quot;&#39;&#39;&#39;))</span>
<span class="w"> </span>    Say:
<span class="w"> </span>      &quot;hello, world!&quot;
<span class="w"> </span>    &lt;BLANKLINE&gt;

<span class="w"> </span>    &gt;&gt;&gt; print(denormalize(r&#39;&#39;&#39;&quot;&quot;
<span class="gd">-    ... &quot;Say:\\n&quot;</span>
<span class="gd">-    ... &quot;  \\&quot;Lorem ipsum dolor sit &quot;</span>
<span class="gi">+    ... &quot;Say:\n&quot;</span>
<span class="gi">+    ... &quot;  \&quot;Lorem ipsum dolor sit &quot;</span>
<span class="w"> </span>    ... &quot;amet, consectetur adipisicing&quot;
<span class="gd">-    ... &quot; elit, \\&quot;\\n&quot;&#39;&#39;&#39;))</span>
<span class="gi">+    ... &quot; elit, \&quot;\n&quot;&#39;&#39;&#39;))</span>
<span class="w"> </span>    Say:
<span class="w"> </span>      &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, &quot;
<span class="w"> </span>    &lt;BLANKLINE&gt;

<span class="w"> </span>    :param string: the string to denormalize
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;\n&#39; in string:</span>
<span class="gi">+        escaped_lines = string.splitlines()</span>
<span class="gi">+        if string.startswith(&#39;&quot;&quot;&#39;):</span>
<span class="gi">+            escaped_lines = escaped_lines[1:]</span>
<span class="gi">+        lines = map(unescape, escaped_lines)</span>
<span class="gi">+        return &#39;&#39;.join(lines)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return unescape(string)</span>


<span class="w"> </span>class PoFileError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Exception thrown by PoParser when an invalid po file is encountered.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, catalog: Catalog, line: str, lineno: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, catalog: Catalog, line: str, lineno: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(f&#39;{message} on {lineno}&#39;)
<span class="w"> </span>        self.catalog = catalog
<span class="w"> </span>        self.line = line
<span class="gu">@@ -72,38 +92,45 @@ class PoFileError(Exception):</span>

<span class="w"> </span>class _NormalizedString:

<span class="gd">-    def __init__(self, *args: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: str) -&gt; None:</span>
<span class="w"> </span>        self._strs: list[str] = []
<span class="w"> </span>        for arg in args:
<span class="w"> </span>            self.append(arg)

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def append(self, s: str) -&gt; None:</span>
<span class="gi">+        self._strs.append(s.strip())</span>
<span class="gi">+</span>
<span class="gi">+    def denormalize(self) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join(map(unescape, self._strs))</span>
<span class="gi">+</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        return bool(self._strs)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return os.linesep.join(self._strs)

<span class="gd">-    def __cmp__(self, other: object) -&gt;int:</span>
<span class="gi">+    def __cmp__(self, other: object) -&gt; int:</span>
<span class="w"> </span>        if not other:
<span class="w"> </span>            return 1
<span class="gi">+</span>
<span class="w"> </span>        return _cmp(str(self), str(other))

<span class="gd">-    def __gt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &gt; 0

<span class="gd">-    def __lt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &lt; 0

<span class="gd">-    def __ge__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &gt;= 0

<span class="gd">-    def __le__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) &lt;= 0

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) == 0

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.__cmp__(other) != 0


<span class="gu">@@ -113,10 +140,15 @@ class PoFileParser:</span>

<span class="w"> </span>    See `read_po` for simple cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _keywords = [&#39;msgid&#39;, &#39;msgstr&#39;, &#39;msgctxt&#39;, &#39;msgid_plural&#39;]</span>

<span class="gd">-    def __init__(self, catalog: Catalog, ignore_obsolete: bool=False,</span>
<span class="gd">-        abort_invalid: bool=False) -&gt;None:</span>
<span class="gi">+    _keywords = [</span>
<span class="gi">+        &#39;msgid&#39;,</span>
<span class="gi">+        &#39;msgstr&#39;,</span>
<span class="gi">+        &#39;msgctxt&#39;,</span>
<span class="gi">+        &#39;msgid_plural&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, catalog: Catalog, ignore_obsolete: bool = False, abort_invalid: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.catalog = catalog
<span class="w"> </span>        self.ignore_obsolete = ignore_obsolete
<span class="w"> </span>        self.counter = 0
<span class="gu">@@ -124,24 +156,186 @@ class PoFileParser:</span>
<span class="w"> </span>        self.abort_invalid = abort_invalid
<span class="w"> </span>        self._reset_message_state()

<span class="gd">-    def _add_message(self) -&gt;None:</span>
<span class="gi">+    def _reset_message_state(self) -&gt; None:</span>
<span class="gi">+        self.messages = []</span>
<span class="gi">+        self.translations = []</span>
<span class="gi">+        self.locations = []</span>
<span class="gi">+        self.flags = []</span>
<span class="gi">+        self.user_comments = []</span>
<span class="gi">+        self.auto_comments = []</span>
<span class="gi">+        self.context = None</span>
<span class="gi">+        self.obsolete = False</span>
<span class="gi">+        self.in_msgid = False</span>
<span class="gi">+        self.in_msgstr = False</span>
<span class="gi">+        self.in_msgctxt = False</span>
<span class="gi">+</span>
<span class="gi">+    def _add_message(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a message to the catalog based on the current parser state and
<span class="w"> </span>        clear the state ready to process the next message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.translations.sort()</span>
<span class="gi">+        if len(self.messages) &gt; 1:</span>
<span class="gi">+            msgid = tuple(m.denormalize() for m in self.messages)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msgid = self.messages[0].denormalize()</span>
<span class="gi">+        if isinstance(msgid, (list, tuple)):</span>
<span class="gi">+            string = [&#39;&#39; for _ in range(self.catalog.num_plurals)]</span>
<span class="gi">+            for idx, translation in self.translations:</span>
<span class="gi">+                if idx &gt;= self.catalog.num_plurals:</span>
<span class="gi">+                    self._invalid_pofile(&quot;&quot;, self.offset, &quot;msg has more translations than num_plurals of catalog&quot;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                string[idx] = translation.denormalize()</span>
<span class="gi">+            string = tuple(string)</span>
<span class="gi">+        else:</span>
<span class="gi">+            string = self.translations[0][1].denormalize()</span>
<span class="gi">+        msgctxt = self.context.denormalize() if self.context else None</span>
<span class="gi">+        message = Message(msgid, string, list(self.locations), set(self.flags),</span>
<span class="gi">+                          self.auto_comments, self.user_comments, lineno=self.offset + 1,</span>
<span class="gi">+                          context=msgctxt)</span>
<span class="gi">+        if self.obsolete:</span>
<span class="gi">+            if not self.ignore_obsolete:</span>
<span class="gi">+                self.catalog.obsolete[msgid] = message</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.catalog[msgid] = message</span>
<span class="gi">+        self.counter += 1</span>
<span class="gi">+        self._reset_message_state()</span>

<span class="gd">-    def parse(self, fileobj: IO[AnyStr]) -&gt;None:</span>
<span class="gi">+    def _finish_current_message(self) -&gt; None:</span>
<span class="gi">+        if self.messages:</span>
<span class="gi">+            self._add_message()</span>
<span class="gi">+</span>
<span class="gi">+    def _process_message_line(self, lineno, line, obsolete=False) -&gt; None:</span>
<span class="gi">+        if line.startswith(&#39;&quot;&#39;):</span>
<span class="gi">+            self._process_string_continuation_line(line, lineno)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._process_keyword_line(lineno, line, obsolete)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_keyword_line(self, lineno, line, obsolete=False) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        for keyword in self._keywords:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if line.startswith(keyword) and line[len(keyword)] in [&#39; &#39;, &#39;[&#39;]:</span>
<span class="gi">+                    arg = line[len(keyword):]</span>
<span class="gi">+                    break</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                self._invalid_pofile(line, lineno, &quot;Keyword must be followed by a string&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._invalid_pofile(line, lineno, &quot;Start of line didn&#39;t match any expected keyword.&quot;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if keyword in [&#39;msgid&#39;, &#39;msgctxt&#39;]:</span>
<span class="gi">+            self._finish_current_message()</span>
<span class="gi">+</span>
<span class="gi">+        self.obsolete = obsolete</span>
<span class="gi">+</span>
<span class="gi">+        # The line that has the msgid is stored as the offset of the msg</span>
<span class="gi">+        # should this be the msgctxt if it has one?</span>
<span class="gi">+        if keyword == &#39;msgid&#39;:</span>
<span class="gi">+            self.offset = lineno</span>
<span class="gi">+</span>
<span class="gi">+        if keyword in [&#39;msgid&#39;, &#39;msgid_plural&#39;]:</span>
<span class="gi">+            self.in_msgctxt = False</span>
<span class="gi">+            self.in_msgid = True</span>
<span class="gi">+            self.messages.append(_NormalizedString(arg))</span>
<span class="gi">+</span>
<span class="gi">+        elif keyword == &#39;msgstr&#39;:</span>
<span class="gi">+            self.in_msgid = False</span>
<span class="gi">+            self.in_msgstr = True</span>
<span class="gi">+            if arg.startswith(&#39;[&#39;):</span>
<span class="gi">+                idx, msg = arg[1:].split(&#39;]&#39;, 1)</span>
<span class="gi">+                self.translations.append([int(idx), _NormalizedString(msg)])</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.translations.append([0, _NormalizedString(arg)])</span>
<span class="gi">+</span>
<span class="gi">+        elif keyword == &#39;msgctxt&#39;:</span>
<span class="gi">+            self.in_msgctxt = True</span>
<span class="gi">+            self.context = _NormalizedString(arg)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_string_continuation_line(self, line, lineno) -&gt; None:</span>
<span class="gi">+        if self.in_msgid:</span>
<span class="gi">+            s = self.messages[-1]</span>
<span class="gi">+        elif self.in_msgstr:</span>
<span class="gi">+            s = self.translations[-1][1]</span>
<span class="gi">+        elif self.in_msgctxt:</span>
<span class="gi">+            s = self.context</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._invalid_pofile(line, lineno, &quot;Got line starting with \&quot; but not in msgid, msgstr or msgctxt&quot;)</span>
<span class="gi">+            return</span>
<span class="gi">+        s.append(line)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_comment(self, line) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        self._finish_current_message()</span>
<span class="gi">+</span>
<span class="gi">+        if line[1:].startswith(&#39;:&#39;):</span>
<span class="gi">+            for location in line[2:].lstrip().split():</span>
<span class="gi">+                pos = location.rfind(&#39;:&#39;)</span>
<span class="gi">+                if pos &gt;= 0:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        lineno = int(location[pos + 1:])</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    self.locations.append((location[:pos], lineno))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.locations.append((location, None))</span>
<span class="gi">+        elif line[1:].startswith(&#39;,&#39;):</span>
<span class="gi">+            for flag in line[2:].lstrip().split(&#39;,&#39;):</span>
<span class="gi">+                self.flags.append(flag.strip())</span>
<span class="gi">+        elif line[1:].startswith(&#39;.&#39;):</span>
<span class="gi">+            # These are called auto-comments</span>
<span class="gi">+            comment = line[2:].strip()</span>
<span class="gi">+            if comment:  # Just check that we&#39;re not adding empty comments</span>
<span class="gi">+                self.auto_comments.append(comment)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # These are called user comments</span>
<span class="gi">+            self.user_comments.append(line[1:].strip())</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, fileobj: IO[AnyStr]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reads from the file-like object `fileobj` and adds any po file
<span class="w"> </span>        units found in it to the `Catalog` supplied to the constructor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>

<span class="gd">-def read_po(fileobj: IO[AnyStr], locale: (str | Locale | None)=None, domain:</span>
<span class="gd">-    (str | None)=None, ignore_obsolete: bool=False, charset: (str | None)=</span>
<span class="gd">-    None, abort_invalid: bool=False) -&gt;Catalog:</span>
<span class="gi">+        for lineno, line in enumerate(fileobj):</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            if not isinstance(line, str):</span>
<span class="gi">+                line = line.decode(self.catalog.charset)</span>
<span class="gi">+            if not line:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if line.startswith(&#39;#&#39;):</span>
<span class="gi">+                if line[1:].startswith(&#39;~&#39;):</span>
<span class="gi">+                    self._process_message_line(lineno, line[2:].lstrip(), obsolete=True)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._process_comment(line)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._process_message_line(lineno, line)</span>
<span class="gi">+</span>
<span class="gi">+        self._finish_current_message()</span>
<span class="gi">+</span>
<span class="gi">+        # No actual messages found, but there was some info in comments, from which</span>
<span class="gi">+        # we&#39;ll construct an empty header message</span>
<span class="gi">+        if not self.counter and (self.flags or self.user_comments or self.auto_comments):</span>
<span class="gi">+            self.messages.append(_NormalizedString(&#39;&quot;&quot;&#39;))</span>
<span class="gi">+            self.translations.append([0, _NormalizedString(&#39;&quot;&quot;&#39;)])</span>
<span class="gi">+            self._add_message()</span>
<span class="gi">+</span>
<span class="gi">+    def _invalid_pofile(self, line, lineno, msg) -&gt; None:</span>
<span class="gi">+        assert isinstance(line, str)</span>
<span class="gi">+        if self.abort_invalid:</span>
<span class="gi">+            raise PoFileError(msg, self.catalog, line, lineno)</span>
<span class="gi">+        print(&quot;WARNING:&quot;, msg)</span>
<span class="gi">+        print(f&quot;WARNING: Problem on line {lineno + 1}: {line!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read_po(</span>
<span class="gi">+    fileobj: IO[AnyStr],</span>
<span class="gi">+    locale: str | Locale | None = None,</span>
<span class="gi">+    domain: str | None = None,</span>
<span class="gi">+    ignore_obsolete: bool = False,</span>
<span class="gi">+    charset: str | None = None,</span>
<span class="gi">+    abort_invalid: bool = False,</span>
<span class="gi">+) -&gt; Catalog:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read messages from a ``gettext`` PO (portable object) file from the given
<span class="w"> </span>    file-like object and return a `Catalog`.

<span class="gu">@@ -188,60 +382,111 @@ def read_po(fileobj: IO[AnyStr], locale: (str | Locale | None)=None, domain:</span>
<span class="w"> </span>    :param charset: the character set of the catalog.
<span class="w"> </span>    :param abort_invalid: abort read if po file is invalid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    catalog = Catalog(locale=locale, domain=domain, charset=charset)</span>
<span class="gi">+    parser = PoFileParser(catalog, ignore_obsolete, abort_invalid=abort_invalid)</span>
<span class="gi">+    parser.parse(fileobj)</span>
<span class="gi">+    return catalog</span>


<span class="gd">-WORD_SEP = re.compile(</span>
<span class="gd">-    &#39;(\\s+|[^\\s\\w]*\\w+[a-zA-Z]-(?=\\w+[a-zA-Z])|(?&lt;=[\\w\\!\\&quot;\\\&#39;\\&amp;\\.\\,\\?])-{2,}(?=\\w))&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+WORD_SEP = re.compile(&#39;(&#39;</span>
<span class="gi">+                      r&#39;\s+|&#39;                                 # any whitespace</span>
<span class="gi">+                      r&#39;[^\s\w]*\w+[a-zA-Z]-(?=\w+[a-zA-Z])|&#39;  # hyphenated words</span>
<span class="gi">+                      r&#39;(?&lt;=[\w\!\&quot;\&#39;\&amp;\.\,\?])-{2,}(?=\w)&#39;   # em-dash</span>
<span class="gi">+                      &#39;)&#39;)</span>


<span class="gd">-def escape(string: str) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Escape the given string so that it can be included in double-quoted</span>
<span class="gi">+def escape(string: str) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Escape the given string so that it can be included in double-quoted</span>
<span class="w"> </span>    strings in ``PO`` files.

<span class="w"> </span>    &gt;&gt;&gt; escape(&#39;&#39;&#39;Say:
<span class="w"> </span>    ...   &quot;hello, world!&quot;
<span class="w"> </span>    ... &#39;&#39;&#39;)
<span class="gd">-    &#39;&quot;Say:\\\\n  \\\\&quot;hello, world!\\\\&quot;\\\\n&quot;&#39;</span>
<span class="gi">+    &#39;&quot;Say:\\n  \\&quot;hello, world!\\&quot;\\n&quot;&#39;</span>

<span class="w"> </span>    :param string: the string to escape
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;&quot;%s&quot;&#39; % string.replace(&#39;\\&#39;, &#39;\\\\&#39;) \</span>
<span class="gi">+                          .replace(&#39;\t&#39;, &#39;\\t&#39;) \</span>
<span class="gi">+                          .replace(&#39;\r&#39;, &#39;\\r&#39;) \</span>
<span class="gi">+                          .replace(&#39;\n&#39;, &#39;\\n&#39;) \</span>
<span class="gi">+                          .replace(&#39;\&quot;&#39;, &#39;\\&quot;&#39;)</span>


<span class="gd">-def normalize(string: str, prefix: str=&#39;&#39;, width: int=76) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Convert a string into a format that is appropriate for .po files.</span>
<span class="gi">+def normalize(string: str, prefix: str = &#39;&#39;, width: int = 76) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Convert a string into a format that is appropriate for .po files.</span>

<span class="w"> </span>    &gt;&gt;&gt; print(normalize(&#39;&#39;&#39;Say:
<span class="w"> </span>    ...   &quot;hello, world!&quot;
<span class="w"> </span>    ... &#39;&#39;&#39;, width=None))
<span class="w"> </span>    &quot;&quot;
<span class="gd">-    &quot;Say:\\n&quot;</span>
<span class="gd">-    &quot;  \\&quot;hello, world!\\&quot;\\n&quot;</span>
<span class="gi">+    &quot;Say:\n&quot;</span>
<span class="gi">+    &quot;  \&quot;hello, world!\&quot;\n&quot;</span>

<span class="w"> </span>    &gt;&gt;&gt; print(normalize(&#39;&#39;&#39;Say:
<span class="w"> </span>    ...   &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, &quot;
<span class="w"> </span>    ... &#39;&#39;&#39;, width=32))
<span class="w"> </span>    &quot;&quot;
<span class="gd">-    &quot;Say:\\n&quot;</span>
<span class="gd">-    &quot;  \\&quot;Lorem ipsum dolor sit &quot;</span>
<span class="gi">+    &quot;Say:\n&quot;</span>
<span class="gi">+    &quot;  \&quot;Lorem ipsum dolor sit &quot;</span>
<span class="w"> </span>    &quot;amet, consectetur adipisicing&quot;
<span class="gd">-    &quot; elit, \\&quot;\\n&quot;</span>
<span class="gi">+    &quot; elit, \&quot;\n&quot;</span>

<span class="w"> </span>    :param string: the string to normalize
<span class="w"> </span>    :param prefix: a string that should be prepended to every line
<span class="w"> </span>    :param width: the maximum line width; use `None`, 0, or a negative number
<span class="w"> </span>                  to completely disable line wrapping
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_po(fileobj: SupportsWrite[bytes], catalog: Catalog, width: int=76,</span>
<span class="gd">-    no_location: bool=False, omit_header: bool=False, sort_output: bool=</span>
<span class="gd">-    False, sort_by_file: bool=False, ignore_obsolete: bool=False,</span>
<span class="gd">-    include_previous: bool=False, include_lineno: bool=True) -&gt;None:</span>
<span class="gd">-    &quot;&quot;&quot;Write a ``gettext`` PO (portable object) template file for a given</span>
<span class="gi">+    if width and width &gt; 0:</span>
<span class="gi">+        prefixlen = len(prefix)</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        for line in string.splitlines(True):</span>
<span class="gi">+            if len(escape(line)) + prefixlen &gt; width:</span>
<span class="gi">+                chunks = WORD_SEP.split(line)</span>
<span class="gi">+                chunks.reverse()</span>
<span class="gi">+                while chunks:</span>
<span class="gi">+                    buf = []</span>
<span class="gi">+                    size = 2</span>
<span class="gi">+                    while chunks:</span>
<span class="gi">+                        length = len(escape(chunks[-1])) - 2 + prefixlen</span>
<span class="gi">+                        if size + length &lt; width:</span>
<span class="gi">+                            buf.append(chunks.pop())</span>
<span class="gi">+                            size += length</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            if not buf:</span>
<span class="gi">+                                # handle long chunks by putting them on a</span>
<span class="gi">+                                # separate line</span>
<span class="gi">+                                buf.append(chunks.pop())</span>
<span class="gi">+                            break</span>
<span class="gi">+                    lines.append(&#39;&#39;.join(buf))</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(line)</span>
<span class="gi">+    else:</span>
<span class="gi">+        lines = string.splitlines(True)</span>
<span class="gi">+</span>
<span class="gi">+    if len(lines) &lt;= 1:</span>
<span class="gi">+        return escape(string)</span>
<span class="gi">+</span>
<span class="gi">+    # Remove empty trailing line</span>
<span class="gi">+    if lines and not lines[-1]:</span>
<span class="gi">+        del lines[-1]</span>
<span class="gi">+        lines[-1] += &#39;\n&#39;</span>
<span class="gi">+    return &#39;&quot;&quot;\n&#39; + &#39;\n&#39;.join([(prefix + escape(line)) for line in lines])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_po(</span>
<span class="gi">+    fileobj: SupportsWrite[bytes],</span>
<span class="gi">+    catalog: Catalog,</span>
<span class="gi">+    width: int = 76,</span>
<span class="gi">+    no_location: bool = False,</span>
<span class="gi">+    omit_header: bool = False,</span>
<span class="gi">+    sort_output: bool = False,</span>
<span class="gi">+    sort_by_file: bool = False,</span>
<span class="gi">+    ignore_obsolete: bool = False,</span>
<span class="gi">+    include_previous: bool = False,</span>
<span class="gi">+    include_lineno: bool = True,</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    r&quot;&quot;&quot;Write a ``gettext`` PO (portable object) template file for a given</span>
<span class="w"> </span>    message catalog to the provided file-like object.

<span class="w"> </span>    &gt;&gt;&gt; catalog = Catalog()
<span class="gu">@@ -284,11 +529,112 @@ def write_po(fileobj: SupportsWrite[bytes], catalog: Catalog, width: int=76,</span>
<span class="w"> </span>                             updating the catalog
<span class="w"> </span>    :param include_lineno: include line number in the location comment
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _sort_messages(messages: Iterable[Message], sort_by: Literal[&#39;message&#39;,</span>
<span class="gd">-    &#39;location&#39;]) -&gt;list[Message]:</span>
<span class="gi">+    def _normalize(key, prefix=&#39;&#39;):</span>
<span class="gi">+        return normalize(key, prefix=prefix, width=width)</span>
<span class="gi">+</span>
<span class="gi">+    def _write(text):</span>
<span class="gi">+        if isinstance(text, str):</span>
<span class="gi">+            text = text.encode(catalog.charset, &#39;backslashreplace&#39;)</span>
<span class="gi">+        fileobj.write(text)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_comment(comment, prefix=&#39;&#39;):</span>
<span class="gi">+        # xgettext always wraps comments even if --no-wrap is passed;</span>
<span class="gi">+        # provide the same behaviour</span>
<span class="gi">+        _width = width if width and width &gt; 0 else 76</span>
<span class="gi">+        for line in wraptext(comment, _width):</span>
<span class="gi">+            _write(f&quot;#{prefix} {line.strip()}\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_message(message, prefix=&#39;&#39;):</span>
<span class="gi">+        if isinstance(message.id, (list, tuple)):</span>
<span class="gi">+            if message.context:</span>
<span class="gi">+                _write(f&quot;{prefix}msgctxt {_normalize(message.context, prefix)}\n&quot;)</span>
<span class="gi">+            _write(f&quot;{prefix}msgid {_normalize(message.id[0], prefix)}\n&quot;)</span>
<span class="gi">+            _write(f&quot;{prefix}msgid_plural {_normalize(message.id[1], prefix)}\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            for idx in range(catalog.num_plurals):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    string = message.string[idx]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    string = &#39;&#39;</span>
<span class="gi">+                _write(f&quot;{prefix}msgstr[{idx:d}] {_normalize(string, prefix)}\n&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if message.context:</span>
<span class="gi">+                _write(f&quot;{prefix}msgctxt {_normalize(message.context, prefix)}\n&quot;)</span>
<span class="gi">+            _write(f&quot;{prefix}msgid {_normalize(message.id, prefix)}\n&quot;)</span>
<span class="gi">+            _write(f&quot;{prefix}msgstr {_normalize(message.string or &#39;&#39;, prefix)}\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    sort_by = None</span>
<span class="gi">+    if sort_output:</span>
<span class="gi">+        sort_by = &quot;message&quot;</span>
<span class="gi">+    elif sort_by_file:</span>
<span class="gi">+        sort_by = &quot;location&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for message in _sort_messages(catalog, sort_by=sort_by):</span>
<span class="gi">+        if not message.id:  # This is the header &quot;message&quot;</span>
<span class="gi">+            if omit_header:</span>
<span class="gi">+                continue</span>
<span class="gi">+            comment_header = catalog.header_comment</span>
<span class="gi">+            if width and width &gt; 0:</span>
<span class="gi">+                lines = []</span>
<span class="gi">+                for line in comment_header.splitlines():</span>
<span class="gi">+                    lines += wraptext(line, width=width,</span>
<span class="gi">+                                      subsequent_indent=&#39;# &#39;)</span>
<span class="gi">+                comment_header = &#39;\n&#39;.join(lines)</span>
<span class="gi">+            _write(f&quot;{comment_header}\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for comment in message.user_comments:</span>
<span class="gi">+            _write_comment(comment)</span>
<span class="gi">+        for comment in message.auto_comments:</span>
<span class="gi">+            _write_comment(comment, prefix=&#39;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if not no_location:</span>
<span class="gi">+            locs = []</span>
<span class="gi">+</span>
<span class="gi">+            # sort locations by filename and lineno.</span>
<span class="gi">+            # if there&#39;s no &lt;int&gt; as lineno, use `-1`.</span>
<span class="gi">+            # if no sorting possible, leave unsorted.</span>
<span class="gi">+            # (see issue #606)</span>
<span class="gi">+            try:</span>
<span class="gi">+                locations = sorted(message.locations,</span>
<span class="gi">+                                   key=lambda x: (x[0], isinstance(x[1], int) and x[1] or -1))</span>
<span class="gi">+            except TypeError:  # e.g. &quot;TypeError: unorderable types: NoneType() &lt; int()&quot;</span>
<span class="gi">+                locations = message.locations</span>
<span class="gi">+</span>
<span class="gi">+            for filename, lineno in locations:</span>
<span class="gi">+                location = filename.replace(os.sep, &#39;/&#39;)</span>
<span class="gi">+                if lineno and include_lineno:</span>
<span class="gi">+                    location = f&quot;{location}:{lineno:d}&quot;</span>
<span class="gi">+                if location not in locs:</span>
<span class="gi">+                    locs.append(location)</span>
<span class="gi">+            _write_comment(&#39; &#39;.join(locs), prefix=&#39;:&#39;)</span>
<span class="gi">+        if message.flags:</span>
<span class="gi">+            _write(f&quot;#{&#39;, &#39;.join([&#39;&#39;, *sorted(message.flags)])}\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if message.previous_id and include_previous:</span>
<span class="gi">+            _write_comment(</span>
<span class="gi">+                f&#39;msgid {_normalize(message.previous_id[0])}&#39;,</span>
<span class="gi">+                prefix=&#39;|&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+            if len(message.previous_id) &gt; 1:</span>
<span class="gi">+                _write_comment(&#39;msgid_plural %s&#39; % _normalize(</span>
<span class="gi">+                    message.previous_id[1],</span>
<span class="gi">+                ), prefix=&#39;|&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        _write_message(message)</span>
<span class="gi">+        _write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if not ignore_obsolete:</span>
<span class="gi">+        for message in _sort_messages(</span>
<span class="gi">+            catalog.obsolete.values(),</span>
<span class="gi">+            sort_by=sort_by,</span>
<span class="gi">+        ):</span>
<span class="gi">+            for comment in message.user_comments:</span>
<span class="gi">+                _write_comment(comment)</span>
<span class="gi">+            _write_message(message, prefix=&#39;#~ &#39;)</span>
<span class="gi">+            _write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sort_messages(messages: Iterable[Message], sort_by: Literal[&quot;message&quot;, &quot;location&quot;]) -&gt; list[Message]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Sort the given message iterable by the given criteria.

<span class="gu">@@ -298,4 +644,9 @@ def _sort_messages(messages: Iterable[Message], sort_by: Literal[&#39;message&#39;,</span>
<span class="w"> </span>    :param sort_by: Sort by which criteria? Options are `message` and `location`.
<span class="w"> </span>    :return: list[Message]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    messages = list(messages)</span>
<span class="gi">+    if sort_by == &quot;message&quot;:</span>
<span class="gi">+        messages.sort()</span>
<span class="gi">+    elif sort_by == &quot;location&quot;:</span>
<span class="gi">+        messages.sort(key=lambda m: m.locations)</span>
<span class="gi">+    return messages</span>
<span class="gh">diff --git a/babel/messages/setuptools_frontend.py b/babel/messages/setuptools_frontend.py</span>
<span class="gh">index 626c6dd..67b9f24 100644</span>
<span class="gd">--- a/babel/messages/setuptools_frontend.py</span>
<span class="gi">+++ b/babel/messages/setuptools_frontend.py</span>
<span class="gu">@@ -1,11 +1,16 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from babel.messages import frontend
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gi">+    # See: https://setuptools.pypa.io/en/latest/deprecated/distutils-legacy.html</span>
<span class="w"> </span>    from setuptools import Command
<span class="gi">+</span>
<span class="w"> </span>    try:
<span class="w"> </span>        from setuptools.errors import BaseError, OptionError, SetupError
<span class="gd">-    except ImportError:</span>
<span class="gi">+    except ImportError:  # Error aliases only added in setuptools 59 (2021-11).</span>
<span class="w"> </span>        OptionError = SetupError = BaseError = Exception
<span class="gi">+</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    from distutils.cmd import Command
<span class="w"> </span>    from distutils.errors import DistutilsSetupError as SetupError
<span class="gu">@@ -20,7 +25,11 @@ def check_message_extractors(dist, name, value):</span>
<span class="w"> </span>    :param value: the value of the keyword argument
<span class="w"> </span>    :raise `DistutilsSetupError`: if the value is not valid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert name == &quot;message_extractors&quot;</span>
<span class="gi">+    if not isinstance(value, dict):</span>
<span class="gi">+        raise SetupError(</span>
<span class="gi">+            &#39;the value of the &quot;message_extractors&quot; parameter must be a dictionary&#39;,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class compile_catalog(frontend.CompileCatalog, Command):
<span class="gu">@@ -91,6 +100,9 @@ class update_catalog(frontend.UpdateCatalog, Command):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gd">-COMMANDS = {&#39;compile_catalog&#39;: compile_catalog, &#39;extract_messages&#39;:</span>
<span class="gd">-    extract_messages, &#39;init_catalog&#39;: init_catalog, &#39;update_catalog&#39;:</span>
<span class="gd">-    update_catalog}</span>
<span class="gi">+COMMANDS = {</span>
<span class="gi">+    &quot;compile_catalog&quot;: compile_catalog,</span>
<span class="gi">+    &quot;extract_messages&quot;: extract_messages,</span>
<span class="gi">+    &quot;init_catalog&quot;: init_catalog,</span>
<span class="gi">+    &quot;update_catalog&quot;: update_catalog,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/babel/numbers.py b/babel/numbers.py</span>
<span class="gh">index d54ba55..2240c65 100644</span>
<span class="gd">--- a/babel/numbers.py</span>
<span class="gi">+++ b/babel/numbers.py</span>
<span class="gu">@@ -14,16 +14,23 @@</span>
<span class="w"> </span>    :copyright: (c) 2013-2023 by the Babel Team.
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+# TODO:</span>
<span class="gi">+#  Padding and rounding increments in pattern:</span>
<span class="gi">+#  - https://www.unicode.org/reports/tr35/ (Appendix G.6)</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import decimal
<span class="w"> </span>import re
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast, overload
<span class="gi">+</span>
<span class="w"> </span>from babel.core import Locale, default_locale, get_global
<span class="w"> </span>from babel.localedata import LocaleDataDict
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal
<span class="gi">+</span>
<span class="w"> </span>LC_NUMERIC = default_locale(&#39;LC_NUMERIC&#39;)


<span class="gu">@@ -31,15 +38,17 @@ class UnknownCurrencyError(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;Exception thrown when a currency is requested for which no data is available.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, identifier: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, identifier: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the exception.
<span class="w"> </span>        :param identifier: the identifier string of the unsupported currency
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        Exception.__init__(self, f&#39;Unknown currency {identifier!r}.&#39;)</span>
<span class="gi">+        Exception.__init__(self, f&quot;Unknown currency {identifier!r}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #: The identifier of the locale that could not be found.</span>
<span class="w"> </span>        self.identifier = identifier


<span class="gd">-def list_currencies(locale: (Locale | str | None)=None) -&gt;set[str]:</span>
<span class="gi">+def list_currencies(locale: Locale | str | None = None) -&gt; set[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot; Return a `set` of normalized currency codes.

<span class="w"> </span>    .. versionadded:: 2.5.0
<span class="gu">@@ -49,11 +58,13 @@ def list_currencies(locale: (Locale | str | None)=None) -&gt;set[str]:</span>
<span class="w"> </span>                   provided, returns the list of all currencies from all
<span class="w"> </span>                   locales.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get locale-scoped currencies.</span>
<span class="gi">+    if locale:</span>
<span class="gi">+        return set(Locale.parse(locale).currencies)</span>
<span class="gi">+    return set(get_global(&#39;all_currencies&#39;))</span>


<span class="gd">-def validate_currency(currency: str, locale: (Locale | str | None)=None</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+def validate_currency(currency: str, locale: Locale | str | None = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot; Check the currency code is recognized by Babel.

<span class="w"> </span>    Accepts a ``locale`` parameter for fined-grained validation, working as
<span class="gu">@@ -61,19 +72,25 @@ def validate_currency(currency: str, locale: (Locale | str | None)=None</span>

<span class="w"> </span>    Raises a `UnknownCurrencyError` exception if the currency is unknown to Babel.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if currency not in list_currencies(locale):</span>
<span class="gi">+        raise UnknownCurrencyError(currency)</span>


<span class="gd">-def is_currency(currency: str, locale: (Locale | str | None)=None) -&gt;bool:</span>
<span class="gi">+def is_currency(currency: str, locale: Locale | str | None = None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot; Returns `True` only if a currency is recognized by Babel.

<span class="w"> </span>    This method always return a Boolean and never raise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not currency or not isinstance(currency, str):</span>
<span class="gi">+        return False</span>
<span class="gi">+    try:</span>
<span class="gi">+        validate_currency(currency, locale)</span>
<span class="gi">+    except UnknownCurrencyError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="gd">-def normalize_currency(currency: str, locale: (Locale | str | None)=None) -&gt;(</span>
<span class="gd">-    str | None):</span>
<span class="gi">+def normalize_currency(currency: str, locale: Locale | str | None = None) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the normalized identifier of any currency code.

<span class="w"> </span>    Accepts a ``locale`` parameter for fined-grained validation, working as
<span class="gu">@@ -81,11 +98,18 @@ def normalize_currency(currency: str, locale: (Locale | str | None)=None) -&gt;(</span>

<span class="w"> </span>    Returns None if the currency is unknown to Babel.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_currency_name(currency: str, count: (float | decimal.Decimal | None</span>
<span class="gd">-    )=None, locale: (Locale | str | None)=LC_NUMERIC) -&gt;str:</span>
<span class="gi">+    if isinstance(currency, str):</span>
<span class="gi">+        currency = currency.upper()</span>
<span class="gi">+    if not is_currency(currency, locale):</span>
<span class="gi">+        return None</span>
<span class="gi">+    return currency</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_currency_name(</span>
<span class="gi">+    currency: str,</span>
<span class="gi">+    count: float | decimal.Decimal | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the name used by the locale for the specified currency.

<span class="w"> </span>    &gt;&gt;&gt; get_currency_name(&#39;USD&#39;, locale=&#39;en_US&#39;)
<span class="gu">@@ -98,11 +122,23 @@ def get_currency_name(currency: str, count: (float | decimal.Decimal | None</span>
<span class="w"> </span>                  will be pluralized to that number if possible.
<span class="w"> </span>    :param locale: the `Locale` object or locale identifier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_currency_symbol(currency: str, locale: (Locale | str | None)=LC_NUMERIC</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+    loc = Locale.parse(locale)</span>
<span class="gi">+    if count is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            plural_form = loc.plural_form(count)</span>
<span class="gi">+        except (OverflowError, ValueError):</span>
<span class="gi">+            plural_form = &#39;other&#39;</span>
<span class="gi">+        plural_names = loc._data[&#39;currency_names_plural&#39;]</span>
<span class="gi">+        if currency in plural_names:</span>
<span class="gi">+            currency_plural_names = plural_names[currency]</span>
<span class="gi">+            if plural_form in currency_plural_names:</span>
<span class="gi">+                return currency_plural_names[plural_form]</span>
<span class="gi">+            if &#39;other&#39; in currency_plural_names:</span>
<span class="gi">+                return currency_plural_names[&#39;other&#39;]</span>
<span class="gi">+    return loc.currencies.get(currency, currency)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_currency_symbol(currency: str, locale: Locale | str | None = LC_NUMERIC) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the symbol used by the locale for the specified currency.

<span class="w"> </span>    &gt;&gt;&gt; get_currency_symbol(&#39;USD&#39;, locale=&#39;en_US&#39;)
<span class="gu">@@ -111,10 +147,10 @@ def get_currency_symbol(currency: str, locale: (Locale | str | None)=LC_NUMERIC</span>
<span class="w"> </span>    :param currency: the currency code.
<span class="w"> </span>    :param locale: the `Locale` object or locale identifier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.parse(locale).currency_symbols.get(currency, currency)</span>


<span class="gd">-def get_currency_precision(currency: str) -&gt;int:</span>
<span class="gi">+def get_currency_precision(currency: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return currency&#39;s precision.

<span class="w"> </span>    Precision is the number of decimals found after the decimal point in the
<span class="gu">@@ -124,11 +160,15 @@ def get_currency_precision(currency: str) -&gt;int:</span>

<span class="w"> </span>    :param currency: the currency code.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    precisions = get_global(&#39;currency_fractions&#39;)</span>
<span class="gi">+    return precisions.get(currency, precisions[&#39;DEFAULT&#39;])[0]</span>


<span class="gd">-def get_currency_unit_pattern(currency: str, count: (float | decimal.</span>
<span class="gd">-    Decimal | None)=None, locale: (Locale | str | None)=LC_NUMERIC) -&gt;str:</span>
<span class="gi">+def get_currency_unit_pattern(</span>
<span class="gi">+    currency: str,</span>
<span class="gi">+    count: float | decimal.Decimal | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the unit pattern used for long display of a currency value
<span class="w"> </span>    for a given locale.
<span class="gu">@@ -146,13 +186,50 @@ def get_currency_unit_pattern(currency: str, count: (float | decimal.</span>
<span class="w"> </span>                  pattern for that number will be returned.
<span class="w"> </span>    :param locale: the `Locale` object or locale identifier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_territory_currencies(territory: str, start_date: (datetime.date |</span>
<span class="gd">-    None)=None, end_date: (datetime.date | None)=None, tender: bool=True,</span>
<span class="gd">-    non_tender: bool=False, include_details: bool=False) -&gt;(list[str] |</span>
<span class="gd">-    list[dict[str, Any]]):</span>
<span class="gi">+    loc = Locale.parse(locale)</span>
<span class="gi">+    if count is not None:</span>
<span class="gi">+        plural_form = loc.plural_form(count)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return loc._data[&#39;currency_unit_patterns&#39;][plural_form]</span>
<span class="gi">+        except LookupError:</span>
<span class="gi">+            # Fall back to &#39;other&#39;</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    return loc._data[&#39;currency_unit_patterns&#39;][&#39;other&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def get_territory_currencies(</span>
<span class="gi">+    territory: str,</span>
<span class="gi">+    start_date: datetime.date | None = ...,</span>
<span class="gi">+    end_date: datetime.date | None = ...,</span>
<span class="gi">+    tender: bool = ...,</span>
<span class="gi">+    non_tender: bool = ...,</span>
<span class="gi">+    include_details: Literal[False] = ...,</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="gi">+    ...  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def get_territory_currencies(</span>
<span class="gi">+    territory: str,</span>
<span class="gi">+    start_date: datetime.date | None = ...,</span>
<span class="gi">+    end_date: datetime.date | None = ...,</span>
<span class="gi">+    tender: bool = ...,</span>
<span class="gi">+    non_tender: bool = ...,</span>
<span class="gi">+    include_details: Literal[True] = ...,</span>
<span class="gi">+) -&gt; list[dict[str, Any]]:</span>
<span class="gi">+    ...  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_territory_currencies(</span>
<span class="gi">+    territory: str,</span>
<span class="gi">+    start_date: datetime.date | None = None,</span>
<span class="gi">+    end_date: datetime.date | None = None,</span>
<span class="gi">+    tender: bool = True,</span>
<span class="gi">+    non_tender: bool = False,</span>
<span class="gi">+    include_details: bool = False,</span>
<span class="gi">+) -&gt; list[str] | list[dict[str, Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the list of currencies for the given territory that are valid for
<span class="w"> </span>    the given date range.  In addition to that the currency database
<span class="w"> </span>    distinguishes between tender and non-tender currencies.  By default only
<span class="gu">@@ -202,7 +279,62 @@ def get_territory_currencies(territory: str, start_date: (datetime.date |</span>
<span class="w"> </span>                            dictionary will have the keys ``&#39;currency&#39;``,
<span class="w"> </span>                            ``&#39;from&#39;``, ``&#39;to&#39;``, and ``&#39;tender&#39;``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    currencies = get_global(&#39;territory_currencies&#39;)</span>
<span class="gi">+    if start_date is None:</span>
<span class="gi">+        start_date = datetime.date.today()</span>
<span class="gi">+    elif isinstance(start_date, datetime.datetime):</span>
<span class="gi">+        start_date = start_date.date()</span>
<span class="gi">+    if end_date is None:</span>
<span class="gi">+        end_date = start_date</span>
<span class="gi">+    elif isinstance(end_date, datetime.datetime):</span>
<span class="gi">+        end_date = end_date.date()</span>
<span class="gi">+</span>
<span class="gi">+    curs = currencies.get(territory.upper(), ())</span>
<span class="gi">+    # TODO: validate that the territory exists</span>
<span class="gi">+</span>
<span class="gi">+    def _is_active(start, end):</span>
<span class="gi">+        return (start is None or start &lt;= end_date) and \</span>
<span class="gi">+               (end is None or end &gt;= start_date)</span>
<span class="gi">+</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for currency_code, start, end, is_tender in curs:</span>
<span class="gi">+        if start:</span>
<span class="gi">+            start = datetime.date(*start)</span>
<span class="gi">+        if end:</span>
<span class="gi">+            end = datetime.date(*end)</span>
<span class="gi">+        if ((is_tender and tender) or</span>
<span class="gi">+                (not is_tender and non_tender)) and _is_active(start, end):</span>
<span class="gi">+            if include_details:</span>
<span class="gi">+                result.append({</span>
<span class="gi">+                    &#39;currency&#39;: currency_code,</span>
<span class="gi">+                    &#39;from&#39;: start,</span>
<span class="gi">+                    &#39;to&#39;: end,</span>
<span class="gi">+                    &#39;tender&#39;: is_tender,</span>
<span class="gi">+                })</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(currency_code)</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_numbering_system(locale: Locale, numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;) -&gt; str:</span>
<span class="gi">+    if numbering_system == &quot;default&quot;:</span>
<span class="gi">+        return locale.default_numbering_system</span>
<span class="gi">+    else:</span>
<span class="gi">+        return numbering_system</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_number_symbols(</span>
<span class="gi">+    locale: Locale | str | None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; LocaleDataDict:</span>
<span class="gi">+    parsed_locale = Locale.parse(locale)</span>
<span class="gi">+    numbering_system = _get_numbering_system(parsed_locale, numbering_system)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return parsed_locale.number_symbols[numbering_system]</span>
<span class="gi">+    except KeyError as error:</span>
<span class="gi">+        raise UnsupportedNumberingSystemError(f&quot;Unknown numbering system {numbering_system} for Locale {parsed_locale}.&quot;) from error</span>


<span class="w"> </span>class UnsupportedNumberingSystemError(Exception):
<span class="gu">@@ -210,8 +342,11 @@ class UnsupportedNumberingSystemError(Exception):</span>
<span class="w"> </span>    pass


<span class="gd">-def get_decimal_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def get_decimal_symbol(</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the symbol used by the locale to separate decimal fractions.

<span class="w"> </span>    &gt;&gt;&gt; get_decimal_symbol(&#39;en_US&#39;)
<span class="gu">@@ -226,49 +361,58 @@ def get_decimal_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_number_symbols(locale, numbering_system=numbering_system).get(&#39;decimal&#39;, &#39;.&#39;)</span>


<span class="gd">-def get_plus_sign_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def get_plus_sign_symbol(</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the plus sign symbol used by the current locale.

<span class="w"> </span>    &gt;&gt;&gt; get_plus_sign_symbol(&#39;en_US&#39;)
<span class="w"> </span>    u&#39;+&#39;
<span class="w"> </span>    &gt;&gt;&gt; get_plus_sign_symbol(&#39;ar_EG&#39;, numbering_system=&#39;default&#39;)
<span class="gd">-    u&#39;+&#39;</span>
<span class="gi">+    u&#39;\u061c+&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; get_plus_sign_symbol(&#39;ar_EG&#39;, numbering_system=&#39;latn&#39;)
<span class="gd">-    u&#39;+&#39;</span>
<span class="gi">+    u&#39;\u200e+&#39;</span>

<span class="w"> </span>    :param locale: the `Locale` object or locale identifier
<span class="w"> </span>    :param numbering_system: The numbering system used for fetching the symbol. Defaults to &quot;latn&quot;.
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_number_symbols(locale, numbering_system=numbering_system).get(&#39;plusSign&#39;, &#39;+&#39;)</span>


<span class="gd">-def get_minus_sign_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def get_minus_sign_symbol(</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the plus sign symbol used by the current locale.

<span class="w"> </span>    &gt;&gt;&gt; get_minus_sign_symbol(&#39;en_US&#39;)
<span class="w"> </span>    u&#39;-&#39;
<span class="w"> </span>    &gt;&gt;&gt; get_minus_sign_symbol(&#39;ar_EG&#39;, numbering_system=&#39;default&#39;)
<span class="gd">-    u&#39;-&#39;</span>
<span class="gi">+    u&#39;\u061c-&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; get_minus_sign_symbol(&#39;ar_EG&#39;, numbering_system=&#39;latn&#39;)
<span class="gd">-    u&#39;-&#39;</span>
<span class="gi">+    u&#39;\u200e-&#39;</span>

<span class="w"> </span>    :param locale: the `Locale` object or locale identifier
<span class="w"> </span>    :param numbering_system: The numbering system used for fetching the symbol. Defaults to &quot;latn&quot;.
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_number_symbols(locale, numbering_system=numbering_system).get(&#39;minusSign&#39;, &#39;-&#39;)</span>


<span class="gd">-def get_exponential_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def get_exponential_symbol(</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the symbol used by the locale to separate mantissa and exponent.

<span class="w"> </span>    &gt;&gt;&gt; get_exponential_symbol(&#39;en_US&#39;)
<span class="gu">@@ -283,11 +427,14 @@ def get_exponential_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_number_symbols(locale, numbering_system=numbering_system).get(&#39;exponential&#39;, &#39;E&#39;)</span>


<span class="gd">-def get_group_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def get_group_symbol(</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the symbol used by the locale to separate groups of thousands.

<span class="w"> </span>    &gt;&gt;&gt; get_group_symbol(&#39;en_US&#39;)
<span class="gu">@@ -302,11 +449,14 @@ def get_group_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_number_symbols(locale, numbering_system=numbering_system).get(&#39;group&#39;, &#39;,&#39;)</span>


<span class="gd">-def get_infinity_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def get_infinity_symbol(</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the symbol used by the locale to represent infinity.

<span class="w"> </span>    &gt;&gt;&gt; get_infinity_symbol(&#39;en_US&#39;)
<span class="gu">@@ -321,11 +471,10 @@ def get_infinity_symbol(locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_number_symbols(locale, numbering_system=numbering_system).get(&#39;infinity&#39;, &#39;&#39;)</span>


<span class="gd">-def format_number(number: (float | decimal.Decimal | str), locale: (Locale |</span>
<span class="gd">-    str | None)=LC_NUMERIC) -&gt;str:</span>
<span class="gi">+def format_number(number: float | decimal.Decimal | str, locale: Locale | str | None = LC_NUMERIC) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the given number formatted for a specific locale.

<span class="w"> </span>    &gt;&gt;&gt; format_number(1099, locale=&#39;en_US&#39;)  # doctest: +SKIP
<span class="gu">@@ -342,26 +491,39 @@ def format_number(number: (float | decimal.Decimal | str), locale: (Locale |</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(&#39;Use babel.numbers.format_decimal() instead.&#39;, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+    return format_decimal(number, locale=locale)</span>


<span class="gd">-def get_decimal_precision(number: decimal.Decimal) -&gt;int:</span>
<span class="gi">+def get_decimal_precision(number: decimal.Decimal) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return maximum precision of a decimal instance&#39;s fractional part.

<span class="w"> </span>    Precision is extracted from the fractional part only.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Copied from: https://github.com/mahmoud/boltons/pull/59</span>
<span class="gi">+    assert isinstance(number, decimal.Decimal)</span>
<span class="gi">+    decimal_tuple = number.normalize().as_tuple()</span>
<span class="gi">+    # Note: DecimalTuple.exponent can be &#39;n&#39; (qNaN), &#39;N&#39; (sNaN), or &#39;F&#39; (Infinity)</span>
<span class="gi">+    if not isinstance(decimal_tuple.exponent, int) or decimal_tuple.exponent &gt;= 0:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    return abs(decimal_tuple.exponent)</span>


<span class="gd">-def get_decimal_quantum(precision: (int | decimal.Decimal)) -&gt;decimal.Decimal:</span>
<span class="gi">+def get_decimal_quantum(precision: int | decimal.Decimal) -&gt; decimal.Decimal:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return minimal quantum of a number, as defined by precision.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_decimal(number: (float | decimal.Decimal | str), format: (str |</span>
<span class="gd">-    NumberPattern | None)=None, locale: (Locale | str | None)=LC_NUMERIC,</span>
<span class="gd">-    decimal_quantization: bool=True, group_separator: bool=True, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+    assert isinstance(precision, (int, decimal.Decimal))</span>
<span class="gi">+    return decimal.Decimal(10) ** (-precision)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_decimal(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    format: str | NumberPattern | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    decimal_quantization: bool = True,</span>
<span class="gi">+    group_separator: bool = True,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the given decimal number formatted for a specific locale.

<span class="w"> </span>    &gt;&gt;&gt; format_decimal(1.2345, locale=&#39;en_US&#39;)
<span class="gu">@@ -409,13 +571,22 @@ def format_decimal(number: (float | decimal.Decimal | str), format: (str |</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_compact_decimal(number: (float | decimal.Decimal | str), *,</span>
<span class="gd">-    format_type: Literal[&#39;short&#39;, &#39;long&#39;]=&#39;short&#39;, locale: (Locale | str |</span>
<span class="gd">-    None)=LC_NUMERIC, fraction_digits: int=0, numbering_system: (Literal[</span>
<span class="gd">-    &#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if format is None:</span>
<span class="gi">+        format = locale.decimal_formats[format]</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+    return pattern.apply(</span>
<span class="gi">+        number, locale, decimal_quantization=decimal_quantization, group_separator=group_separator, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_compact_decimal(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    format_type: Literal[&quot;short&quot;, &quot;long&quot;] = &quot;short&quot;,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    fraction_digits: int = 0,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the given decimal number formatted for a specific locale in compact form.

<span class="w"> </span>    &gt;&gt;&gt; format_compact_decimal(12345, format_type=&quot;short&quot;, locale=&#39;en_US&#39;)
<span class="gu">@@ -431,7 +602,7 @@ def format_compact_decimal(number: (float | decimal.Decimal | str), *,</span>
<span class="w"> </span>    &gt;&gt;&gt; format_compact_decimal(21000000, format_type=&quot;long&quot;, locale=&quot;mk&quot;)
<span class="w"> </span>    u&#39;21 &#39;
<span class="w"> </span>    &gt;&gt;&gt; format_compact_decimal(12345, format_type=&quot;short&quot;, locale=&#39;ar_EG&#39;, fraction_digits=2, numbering_system=&#39;default&#39;)
<span class="gd">-    u&#39;1234&#39;</span>
<span class="gi">+    u&#39;1234\xa0&#39;</span>

<span class="w"> </span>    :param number: the number to format
<span class="w"> </span>    :param format_type: Compact format to use (&quot;short&quot; or &quot;long&quot;)
<span class="gu">@@ -441,29 +612,72 @@ def format_compact_decimal(number: (float | decimal.Decimal | str), *,</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_compact_format(number: (float | decimal.Decimal | str),</span>
<span class="gd">-    compact_format: LocaleDataDict, locale: Locale, fraction_digits: int</span>
<span class="gd">-    ) -&gt;tuple[decimal.Decimal, NumberPattern | None]:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    compact_format = locale.compact_decimal_formats[format_type]</span>
<span class="gi">+    number, format = _get_compact_format(number, compact_format, locale, fraction_digits)</span>
<span class="gi">+    # Did not find a format, fall back.</span>
<span class="gi">+    if format is None:</span>
<span class="gi">+        format = locale.decimal_formats[None]</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+    return pattern.apply(number, locale, decimal_quantization=False, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_compact_format(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    compact_format: LocaleDataDict,</span>
<span class="gi">+    locale: Locale,</span>
<span class="gi">+    fraction_digits: int,</span>
<span class="gi">+) -&gt; tuple[decimal.Decimal, NumberPattern | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the number after dividing by the unit and the format pattern to use.
<span class="w"> </span>    The algorithm is described here:
<span class="w"> </span>    https://www.unicode.org/reports/tr35/tr35-45/tr35-numbers.html#Compact_Number_Formats.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(number, decimal.Decimal):</span>
<span class="gi">+        number = decimal.Decimal(str(number))</span>
<span class="gi">+    if number.is_nan() or number.is_infinite():</span>
<span class="gi">+        return number, None</span>
<span class="gi">+    format = None</span>
<span class="gi">+    for magnitude in sorted([int(m) for m in compact_format[&quot;other&quot;]], reverse=True):</span>
<span class="gi">+        if abs(number) &gt;= magnitude:</span>
<span class="gi">+            # check the pattern using &quot;other&quot; as the amount</span>
<span class="gi">+            format = compact_format[&quot;other&quot;][str(magnitude)]</span>
<span class="gi">+            pattern = parse_pattern(format).pattern</span>
<span class="gi">+            # if the pattern is &quot;0&quot;, we do not divide the number</span>
<span class="gi">+            if pattern == &quot;0&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            # otherwise, we need to divide the number by the magnitude but remove zeros</span>
<span class="gi">+            # equal to the number of 0&#39;s in the pattern minus 1</span>
<span class="gi">+            number = cast(decimal.Decimal, number / (magnitude // (10 ** (pattern.count(&quot;0&quot;) - 1))))</span>
<span class="gi">+            # round to the number of fraction digits requested</span>
<span class="gi">+            rounded = round(number, fraction_digits)</span>
<span class="gi">+            # if the remaining number is singular, use the singular format</span>
<span class="gi">+            plural_form = locale.plural_form(abs(number))</span>
<span class="gi">+            if plural_form not in compact_format:</span>
<span class="gi">+                plural_form = &quot;other&quot;</span>
<span class="gi">+            if number == 1 and &quot;1&quot; in compact_format:</span>
<span class="gi">+                plural_form = &quot;1&quot;</span>
<span class="gi">+            format = compact_format[plural_form][str(magnitude)]</span>
<span class="gi">+            number = rounded</span>
<span class="gi">+            break</span>
<span class="gi">+    return number, format</span>


<span class="w"> </span>class UnknownCurrencyFormatError(KeyError):
<span class="w"> </span>    &quot;&quot;&quot;Exception raised when an unknown currency format is requested.&quot;&quot;&quot;


<span class="gd">-def format_currency(number: (float | decimal.Decimal | str), currency: str,</span>
<span class="gd">-    format: (str | NumberPattern | None)=None, locale: (Locale | str | None</span>
<span class="gd">-    )=LC_NUMERIC, currency_digits: bool=True, format_type: Literal[&#39;name&#39;,</span>
<span class="gd">-    &#39;standard&#39;, &#39;accounting&#39;]=&#39;standard&#39;, decimal_quantization: bool=True,</span>
<span class="gd">-    group_separator: bool=True, *, numbering_system: (Literal[&#39;default&#39;] |</span>
<span class="gd">-    str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+def format_currency(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    currency: str,</span>
<span class="gi">+    format: str | NumberPattern | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    currency_digits: bool = True,</span>
<span class="gi">+    format_type: Literal[&quot;name&quot;, &quot;standard&quot;, &quot;accounting&quot;] = &quot;standard&quot;,</span>
<span class="gi">+    decimal_quantization: bool = True,</span>
<span class="gi">+    group_separator: bool = True,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return formatted currency value.

<span class="w"> </span>    &gt;&gt;&gt; format_currency(1099.98, &#39;USD&#39;, locale=&#39;en_US&#39;)
<span class="gu">@@ -473,16 +687,16 @@ def format_currency(number: (float | decimal.Decimal | str), currency: str,</span>
<span class="w"> </span>    &gt;&gt;&gt; format_currency(1099.98, &#39;EUR&#39;, locale=&#39;de_DE&#39;)
<span class="w"> </span>    u&#39;1.099,98\\xa0\\u20ac&#39;
<span class="w"> </span>    &gt;&gt;&gt; format_currency(1099.98, &#39;EGP&#39;, locale=&#39;ar_EG&#39;, numbering_system=&#39;default&#39;)
<span class="gd">-    u&#39;109998..&#39;</span>
<span class="gi">+    u&#39;\u200f109998\xa0..\u200f&#39;</span>

<span class="w"> </span>    The format can also be specified explicitly.  The currency is
<span class="w"> </span>    placed with the &#39;&#39; sign.  As the sign gets repeated the format
<span class="w"> </span>    expands ( being the symbol,  is the currency abbreviation and
<span class="w"> </span>     is the full name of the currency):

<span class="gd">-    &gt;&gt;&gt; format_currency(1099.98, &#39;EUR&#39;, u&#39; #,##0.00&#39;, locale=&#39;en_US&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; format_currency(1099.98, &#39;EUR&#39;, u&#39;\xa4\xa4 #,##0.00&#39;, locale=&#39;en_US&#39;)</span>
<span class="w"> </span>    u&#39;EUR 1,099.98&#39;
<span class="gd">-    &gt;&gt;&gt; format_currency(1099.98, &#39;EUR&#39;, u&#39;#,##0.00 &#39;, locale=&#39;en_US&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; format_currency(1099.98, &#39;EUR&#39;, u&#39;#,##0.00 \xa4\xa4\xa4&#39;, locale=&#39;en_US&#39;)</span>
<span class="w"> </span>    u&#39;1,099.98 euros&#39;

<span class="w"> </span>    Currencies usually have a specific number of decimal digits. This function
<span class="gu">@@ -555,13 +769,76 @@ def format_currency(number: (float | decimal.Decimal | str), currency: str,</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_compact_currency(number: (float | decimal.Decimal | str),</span>
<span class="gd">-    currency: str, *, format_type: Literal[&#39;short&#39;]=&#39;short&#39;, locale: (</span>
<span class="gd">-    Locale | str | None)=LC_NUMERIC, fraction_digits: int=0,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+    if format_type == &#39;name&#39;:</span>
<span class="gi">+        return _format_currency_long_name(number, currency, format=format,</span>
<span class="gi">+                                          locale=locale, currency_digits=currency_digits,</span>
<span class="gi">+                                          decimal_quantization=decimal_quantization, group_separator=group_separator,</span>
<span class="gi">+                                          numbering_system=numbering_system)</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if format:</span>
<span class="gi">+        pattern = parse_pattern(format)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            pattern = locale.currency_formats[format_type]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise UnknownCurrencyFormatError(f&quot;{format_type!r} is not a known currency format type&quot;) from None</span>
<span class="gi">+</span>
<span class="gi">+    return pattern.apply(</span>
<span class="gi">+        number, locale, currency=currency, currency_digits=currency_digits,</span>
<span class="gi">+        decimal_quantization=decimal_quantization, group_separator=group_separator, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_currency_long_name(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    currency: str,</span>
<span class="gi">+    format: str | NumberPattern | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    currency_digits: bool = True,</span>
<span class="gi">+    format_type: Literal[&quot;name&quot;, &quot;standard&quot;, &quot;accounting&quot;] = &quot;standard&quot;,</span>
<span class="gi">+    decimal_quantization: bool = True,</span>
<span class="gi">+    group_separator: bool = True,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    # Algorithm described here:</span>
<span class="gi">+    # https://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    # Step 1.</span>
<span class="gi">+    # There are no examples of items with explicit count (0 or 1) in current</span>
<span class="gi">+    # locale data. So there is no point implementing that.</span>
<span class="gi">+    # Step 2.</span>
<span class="gi">+</span>
<span class="gi">+    # Correct number to numeric type, important for looking up plural rules:</span>
<span class="gi">+    number_n = float(number) if isinstance(number, str) else number</span>
<span class="gi">+</span>
<span class="gi">+    # Step 3.</span>
<span class="gi">+    unit_pattern = get_currency_unit_pattern(currency, count=number_n, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+    # Step 4.</span>
<span class="gi">+    display_name = get_currency_name(currency, count=number_n, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+    # Step 5.</span>
<span class="gi">+    if not format:</span>
<span class="gi">+        format = locale.decimal_formats[None]</span>
<span class="gi">+</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+</span>
<span class="gi">+    number_part = pattern.apply(</span>
<span class="gi">+        number, locale, currency=currency, currency_digits=currency_digits,</span>
<span class="gi">+        decimal_quantization=decimal_quantization, group_separator=group_separator, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+    return unit_pattern.format(number_part, display_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_compact_currency(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    currency: str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    format_type: Literal[&quot;short&quot;] = &quot;short&quot;,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    fraction_digits: int = 0,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format a number as a currency value in compact form.

<span class="w"> </span>    &gt;&gt;&gt; format_compact_currency(12345, &#39;USD&#39;, locale=&#39;en_US&#39;)
<span class="gu">@@ -569,7 +846,7 @@ def format_compact_currency(number: (float | decimal.Decimal | str),</span>
<span class="w"> </span>    &gt;&gt;&gt; format_compact_currency(123456789, &#39;USD&#39;, locale=&#39;en_US&#39;, fraction_digits=2)
<span class="w"> </span>    u&#39;$123.46M&#39;
<span class="w"> </span>    &gt;&gt;&gt; format_compact_currency(123456789, &#39;EUR&#39;, locale=&#39;de_DE&#39;, fraction_digits=1)
<span class="gd">-    &#39;123,5Mio.&#39;</span>
<span class="gi">+    &#39;123,5\xa0Mio.\xa0&#39;</span>

<span class="w"> </span>    :param number: the number to format
<span class="w"> </span>    :param currency: the currency code
<span class="gu">@@ -580,13 +857,40 @@ def format_compact_currency(number: (float | decimal.Decimal | str),</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_percent(number: (float | decimal.Decimal | str), format: (str |</span>
<span class="gd">-    NumberPattern | None)=None, locale: (Locale | str | None)=LC_NUMERIC,</span>
<span class="gd">-    decimal_quantization: bool=True, group_separator: bool=True, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    try:</span>
<span class="gi">+        compact_format = locale.compact_currency_formats[format_type]</span>
<span class="gi">+    except KeyError as error:</span>
<span class="gi">+        raise UnknownCurrencyFormatError(f&quot;{format_type!r} is not a known compact currency format type&quot;) from error</span>
<span class="gi">+    number, format = _get_compact_format(number, compact_format, locale, fraction_digits)</span>
<span class="gi">+    # Did not find a format, fall back.</span>
<span class="gi">+    if format is None or &quot;&quot; not in str(format):</span>
<span class="gi">+        # find first format that has a currency symbol</span>
<span class="gi">+        for magnitude in compact_format[&#39;other&#39;]:</span>
<span class="gi">+            format = compact_format[&#39;other&#39;][magnitude].pattern</span>
<span class="gi">+            if &#39;&#39; not in format:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # remove characters that are not the currency symbol, 0&#39;s or spaces</span>
<span class="gi">+            format = re.sub(r&#39;[^0\s\]&#39;, &#39;&#39;, format)</span>
<span class="gi">+            # compress adjacent spaces into one</span>
<span class="gi">+            format = re.sub(r&#39;(\s)\s+&#39;, r&#39;\1&#39;, format).strip()</span>
<span class="gi">+            break</span>
<span class="gi">+    if format is None:</span>
<span class="gi">+        raise ValueError(&#39;No compact currency format found for the given number and locale.&#39;)</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+    return pattern.apply(number, locale, currency=currency, currency_digits=False, decimal_quantization=False,</span>
<span class="gi">+                         numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_percent(</span>
<span class="gi">+    number: float | decimal.Decimal | str,</span>
<span class="gi">+    format: str | NumberPattern | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    decimal_quantization: bool = True,</span>
<span class="gi">+    group_separator: bool = True,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return formatted percent value for a specific locale.

<span class="w"> </span>    &gt;&gt;&gt; format_percent(0.34, locale=&#39;en_US&#39;)
<span class="gu">@@ -600,8 +904,8 @@ def format_percent(number: (float | decimal.Decimal | str), format: (str |</span>

<span class="w"> </span>    The format pattern can also be specified explicitly:

<span class="gd">-    &gt;&gt;&gt; format_percent(25.1234, u&#39;#,##0&#39;, locale=&#39;en_US&#39;)</span>
<span class="gd">-    u&#39;25,123&#39;</span>
<span class="gi">+    &gt;&gt;&gt; format_percent(25.1234, u&#39;#,##0\u2030&#39;, locale=&#39;en_US&#39;)</span>
<span class="gi">+    u&#39;25,123\u2030&#39;</span>

<span class="w"> </span>    By default the locale is allowed to truncate and round a high-precision
<span class="w"> </span>    number by forcing its format pattern onto the decimal part. You can bypass
<span class="gu">@@ -629,13 +933,24 @@ def format_percent(number: (float | decimal.Decimal | str), format: (str |</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_scientific(number: (float | decimal.Decimal | str), format: (str |</span>
<span class="gd">-    NumberPattern | None)=None, locale: (Locale | str | None)=LC_NUMERIC,</span>
<span class="gd">-    decimal_quantization: bool=True, *, numbering_system: (Literal[</span>
<span class="gd">-    &#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if not format:</span>
<span class="gi">+        format = locale.percent_formats[None]</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+    return pattern.apply(</span>
<span class="gi">+        number, locale, decimal_quantization=decimal_quantization, group_separator=group_separator,</span>
<span class="gi">+        numbering_system=numbering_system,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_scientific(</span>
<span class="gi">+        number: float | decimal.Decimal | str,</span>
<span class="gi">+        format: str | NumberPattern | None = None,</span>
<span class="gi">+        locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+        decimal_quantization: bool = True,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return value formatted in scientific notation for a specific locale.

<span class="w"> </span>    &gt;&gt;&gt; format_scientific(10000, locale=&#39;en_US&#39;)
<span class="gu">@@ -666,20 +981,29 @@ def format_scientific(number: (float | decimal.Decimal | str), format: (str |</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    if not format:</span>
<span class="gi">+        format = locale.scientific_formats[None]</span>
<span class="gi">+    pattern = parse_pattern(format)</span>
<span class="gi">+    return pattern.apply(</span>
<span class="gi">+        number, locale, decimal_quantization=decimal_quantization, numbering_system=numbering_system)</span>


<span class="w"> </span>class NumberFormatError(ValueError):
<span class="w"> </span>    &quot;&quot;&quot;Exception raised when a string cannot be parsed into a number.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, suggestions: (list[str] | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, suggestions: list[str] | None = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)
<span class="gi">+        #: a list of properly formatted numbers derived from the invalid input</span>
<span class="w"> </span>        self.suggestions = suggestions


<span class="gd">-def parse_number(string: str, locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;int:</span>
<span class="gi">+def parse_number(</span>
<span class="gi">+    string: str,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse localized number string into an integer.

<span class="w"> </span>    &gt;&gt;&gt; parse_number(&#39;1,099&#39;, locale=&#39;en_US&#39;)
<span class="gu">@@ -702,12 +1026,19 @@ def parse_number(string: str, locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="w"> </span>    :raise `NumberFormatError`: if the string can not be converted to a number
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_decimal(string: str, locale: (Locale | str | None)=LC_NUMERIC,</span>
<span class="gd">-    strict: bool=False, *, numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;</span>
<span class="gd">-    ) -&gt;decimal.Decimal:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(string.replace(get_group_symbol(locale, numbering_system=numbering_system), &#39;&#39;))</span>
<span class="gi">+    except ValueError as ve:</span>
<span class="gi">+        raise NumberFormatError(f&quot;{string!r} is not a valid number&quot;) from ve</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_decimal(</span>
<span class="gi">+    string: str,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    strict: bool = False,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; decimal.Decimal:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse localized decimal string into a decimal.

<span class="w"> </span>    &gt;&gt;&gt; parse_decimal(&#39;1,099.98&#39;, locale=&#39;en_US&#39;)
<span class="gu">@@ -749,11 +1080,58 @@ def parse_decimal(string: str, locale: (Locale | str | None)=LC_NUMERIC,</span>
<span class="w"> </span>                              decimal number
<span class="w"> </span>    :raise UnsupportedNumberingSystemError: if the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _remove_trailing_zeros_after_decimal(string: str, decimal_symbol: str</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    group_symbol = get_group_symbol(locale, numbering_system=numbering_system)</span>
<span class="gi">+    decimal_symbol = get_decimal_symbol(locale, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+    if not strict and (</span>
<span class="gi">+        group_symbol == &#39;\xa0&#39; and  # if the grouping symbol is U+00A0 NO-BREAK SPACE,</span>
<span class="gi">+        group_symbol not in string and  # and the string to be parsed does not contain it,</span>
<span class="gi">+        &#39; &#39; in string  # but it does contain a space instead,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # ... it&#39;s reasonable to assume it is taking the place of the grouping symbol.</span>
<span class="gi">+        string = string.replace(&#39; &#39;, group_symbol)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        parsed = decimal.Decimal(string.replace(group_symbol, &#39;&#39;)</span>
<span class="gi">+                                       .replace(decimal_symbol, &#39;.&#39;))</span>
<span class="gi">+    except decimal.InvalidOperation as exc:</span>
<span class="gi">+        raise NumberFormatError(f&quot;{string!r} is not a valid decimal number&quot;) from exc</span>
<span class="gi">+    if strict and group_symbol in string:</span>
<span class="gi">+        proper = format_decimal(parsed, locale=locale, decimal_quantization=False, numbering_system=numbering_system)</span>
<span class="gi">+        if string != proper and proper != _remove_trailing_zeros_after_decimal(string, decimal_symbol):</span>
<span class="gi">+            try:</span>
<span class="gi">+                parsed_alt = decimal.Decimal(string.replace(decimal_symbol, &#39;&#39;)</span>
<span class="gi">+                                                   .replace(group_symbol, &#39;.&#39;))</span>
<span class="gi">+            except decimal.InvalidOperation as exc:</span>
<span class="gi">+                raise NumberFormatError(</span>
<span class="gi">+                    f&quot;{string!r} is not a properly formatted decimal number. &quot;</span>
<span class="gi">+                    f&quot;Did you mean {proper!r}?&quot;,</span>
<span class="gi">+                    suggestions=[proper],</span>
<span class="gi">+                ) from exc</span>
<span class="gi">+            else:</span>
<span class="gi">+                proper_alt = format_decimal(</span>
<span class="gi">+                    parsed_alt,</span>
<span class="gi">+                    locale=locale,</span>
<span class="gi">+                    decimal_quantization=False,</span>
<span class="gi">+                    numbering_system=numbering_system,</span>
<span class="gi">+                )</span>
<span class="gi">+                if proper_alt == proper:</span>
<span class="gi">+                    raise NumberFormatError(</span>
<span class="gi">+                        f&quot;{string!r} is not a properly formatted decimal number. &quot;</span>
<span class="gi">+                        f&quot;Did you mean {proper!r}?&quot;,</span>
<span class="gi">+                        suggestions=[proper],</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise NumberFormatError(</span>
<span class="gi">+                        f&quot;{string!r} is not a properly formatted decimal number. &quot;</span>
<span class="gi">+                        f&quot;Did you mean {proper!r}? Or maybe {proper_alt!r}?&quot;,</span>
<span class="gi">+                        suggestions=[proper, proper_alt],</span>
<span class="gi">+                    )</span>
<span class="gi">+    return parsed</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_trailing_zeros_after_decimal(string: str, decimal_symbol: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Remove trailing zeros from the decimal part of a numeric string.

<span class="gu">@@ -777,18 +1155,28 @@ def _remove_trailing_zeros_after_decimal(string: str, decimal_symbol: str</span>
<span class="w"> </span>    &gt;&gt;&gt; _remove_trailing_zeros_after_decimal(&quot;100&quot;, &quot;.&quot;)
<span class="w"> </span>    &#39;100&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    integer_part, _, decimal_part = string.partition(decimal_symbol)</span>
<span class="gi">+</span>
<span class="gi">+    if decimal_part:</span>
<span class="gi">+        decimal_part = decimal_part.rstrip(&quot;0&quot;)</span>
<span class="gi">+        if decimal_part:</span>
<span class="gi">+            return integer_part + decimal_symbol + decimal_part</span>
<span class="gi">+        return integer_part</span>
<span class="gi">+</span>
<span class="gi">+    return string</span>


<span class="gd">-PREFIX_END = &#39;[^0-9@#.,]&#39;</span>
<span class="gd">-NUMBER_TOKEN = &#39;[0-9@#.,E+]&#39;</span>
<span class="gd">-PREFIX_PATTERN = &quot;(?P&lt;prefix&gt;(?:&#39;[^&#39;]*&#39;|%s)*)&quot; % PREFIX_END</span>
<span class="gd">-NUMBER_PATTERN = &#39;(?P&lt;number&gt;%s*)&#39; % NUMBER_TOKEN</span>
<span class="gd">-SUFFIX_PATTERN = &#39;(?P&lt;suffix&gt;.*)&#39;</span>
<span class="gd">-number_re = re.compile(f&#39;{PREFIX_PATTERN}{NUMBER_PATTERN}{SUFFIX_PATTERN}&#39;)</span>
<span class="gi">+PREFIX_END = r&#39;[^0-9@#.,]&#39;</span>
<span class="gi">+NUMBER_TOKEN = r&#39;[0-9@#.,E+]&#39;</span>

<span class="gi">+PREFIX_PATTERN = r&quot;(?P&lt;prefix&gt;(?:&#39;[^&#39;]*&#39;|%s)*)&quot; % PREFIX_END</span>
<span class="gi">+NUMBER_PATTERN = r&quot;(?P&lt;number&gt;%s*)&quot; % NUMBER_TOKEN</span>
<span class="gi">+SUFFIX_PATTERN = r&quot;(?P&lt;suffix&gt;.*)&quot;</span>

<span class="gd">-def parse_grouping(p: str) -&gt;tuple[int, int]:</span>
<span class="gi">+number_re = re.compile(f&quot;{PREFIX_PATTERN}{NUMBER_PATTERN}{SUFFIX_PATTERN}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_grouping(p: str) -&gt; tuple[int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse primary and secondary digit grouping

<span class="w"> </span>    &gt;&gt;&gt; parse_grouping(&#39;##&#39;)
<span class="gu">@@ -798,20 +1186,98 @@ def parse_grouping(p: str) -&gt;tuple[int, int]:</span>
<span class="w"> </span>    &gt;&gt;&gt; parse_grouping(&#39;#,####,###&#39;)
<span class="w"> </span>    (3, 4)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_pattern(pattern: (NumberPattern | str)) -&gt;NumberPattern:</span>
<span class="gi">+    width = len(p)</span>
<span class="gi">+    g1 = p.rfind(&#39;,&#39;)</span>
<span class="gi">+    if g1 == -1:</span>
<span class="gi">+        return 1000, 1000</span>
<span class="gi">+    g1 = width - g1 - 1</span>
<span class="gi">+    g2 = p[:-g1 - 1].rfind(&#39;,&#39;)</span>
<span class="gi">+    if g2 == -1:</span>
<span class="gi">+        return g1, g1</span>
<span class="gi">+    g2 = width - g1 - g2 - 2</span>
<span class="gi">+    return g1, g2</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_pattern(pattern: NumberPattern | str) -&gt; NumberPattern:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse number format patterns&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(pattern, NumberPattern):</span>
<span class="gi">+        return pattern</span>
<span class="gi">+</span>
<span class="gi">+    def _match_number(pattern):</span>
<span class="gi">+        rv = number_re.search(pattern)</span>
<span class="gi">+        if rv is None:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid number pattern {pattern!r}&quot;)</span>
<span class="gi">+        return rv.groups()</span>
<span class="gi">+</span>
<span class="gi">+    pos_pattern = pattern</span>
<span class="gi">+</span>
<span class="gi">+    # Do we have a negative subpattern?</span>
<span class="gi">+    if &#39;;&#39; in pattern:</span>
<span class="gi">+        pos_pattern, neg_pattern = pattern.split(&#39;;&#39;, 1)</span>
<span class="gi">+        pos_prefix, number, pos_suffix = _match_number(pos_pattern)</span>
<span class="gi">+        neg_prefix, _, neg_suffix = _match_number(neg_pattern)</span>
<span class="gi">+    else:</span>
<span class="gi">+        pos_prefix, number, pos_suffix = _match_number(pos_pattern)</span>
<span class="gi">+        neg_prefix = f&quot;-{pos_prefix}&quot;</span>
<span class="gi">+        neg_suffix = pos_suffix</span>
<span class="gi">+    if &#39;E&#39; in number:</span>
<span class="gi">+        number, exp = number.split(&#39;E&#39;, 1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        exp = None</span>
<span class="gi">+    if &#39;@&#39; in number and &#39;.&#39; in number and &#39;0&#39; in number:</span>
<span class="gi">+        raise ValueError(&#39;Significant digit patterns can not contain &quot;@&quot; or &quot;0&quot;&#39;)</span>
<span class="gi">+    if &#39;.&#39; in number:</span>
<span class="gi">+        integer, fraction = number.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        integer = number</span>
<span class="gi">+        fraction = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def parse_precision(p):</span>
<span class="gi">+        &quot;&quot;&quot;Calculate the min and max allowed digits&quot;&quot;&quot;</span>
<span class="gi">+        min = max = 0</span>
<span class="gi">+        for c in p:</span>
<span class="gi">+            if c in &#39;@0&#39;:</span>
<span class="gi">+                min += 1</span>
<span class="gi">+                max += 1</span>
<span class="gi">+            elif c == &#39;#&#39;:</span>
<span class="gi">+                max += 1</span>
<span class="gi">+            elif c == &#39;,&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        return min, max</span>
<span class="gi">+</span>
<span class="gi">+    int_prec = parse_precision(integer)</span>
<span class="gi">+    frac_prec = parse_precision(fraction)</span>
<span class="gi">+    if exp:</span>
<span class="gi">+        exp_plus = exp.startswith(&#39;+&#39;)</span>
<span class="gi">+        exp = exp.lstrip(&#39;+&#39;)</span>
<span class="gi">+        exp_prec = parse_precision(exp)</span>
<span class="gi">+    else:</span>
<span class="gi">+        exp_plus = None</span>
<span class="gi">+        exp_prec = None</span>
<span class="gi">+    grouping = parse_grouping(integer)</span>
<span class="gi">+    return NumberPattern(pattern, (pos_prefix, neg_prefix),</span>
<span class="gi">+                         (pos_suffix, neg_suffix), grouping,</span>
<span class="gi">+                         int_prec, frac_prec,</span>
<span class="gi">+                         exp_prec, exp_plus, number)</span>


<span class="w"> </span>class NumberPattern:

<span class="gd">-    def __init__(self, pattern: str, prefix: tuple[str, str], suffix: tuple</span>
<span class="gd">-        [str, str], grouping: tuple[int, int], int_prec: tuple[int, int],</span>
<span class="gd">-        frac_prec: tuple[int, int], exp_prec: (tuple[int, int] | None),</span>
<span class="gd">-        exp_plus: (bool | None), number_pattern: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pattern: str,</span>
<span class="gi">+        prefix: tuple[str, str],</span>
<span class="gi">+        suffix: tuple[str, str],</span>
<span class="gi">+        grouping: tuple[int, int],</span>
<span class="gi">+        int_prec: tuple[int, int],</span>
<span class="gi">+        frac_prec: tuple[int, int],</span>
<span class="gi">+        exp_prec: tuple[int, int] | None,</span>
<span class="gi">+        exp_plus: bool | None,</span>
<span class="gi">+        number_pattern: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Metadata of the decomposed parsed pattern.</span>
<span class="w"> </span>        self.pattern = pattern
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.suffix = suffix
<span class="gu">@@ -823,30 +1289,68 @@ class NumberPattern:</span>
<span class="w"> </span>        self.exp_plus = exp_plus
<span class="w"> </span>        self.scale = self.compute_scale()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.pattern!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.pattern!r}&gt;&quot;</span>

<span class="gd">-    def compute_scale(self) -&gt;Literal[0, 2, 3]:</span>
<span class="gi">+    def compute_scale(self) -&gt; Literal[0, 2, 3]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the scaling factor to apply to the number before rendering.

<span class="w"> </span>        Auto-set to a factor of 2 or 3 if presence of a ``%`` or ```` sign is
<span class="w"> </span>        detected in the prefix or suffix of the pattern. Default is to not mess
<span class="w"> </span>        with the scale at all and keep it to 0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def scientific_notation_elements(self, value: decimal.Decimal, locale:</span>
<span class="gd">-        (Locale | str | None), *, numbering_system: (Literal[&#39;default&#39;] |</span>
<span class="gd">-        str)=&#39;latn&#39;) -&gt;tuple[decimal.Decimal, int, str]:</span>
<span class="gi">+        scale = 0</span>
<span class="gi">+        if &#39;%&#39; in &#39;&#39;.join(self.prefix + self.suffix):</span>
<span class="gi">+            scale = 2</span>
<span class="gi">+        elif &#39;&#39; in &#39;&#39;.join(self.prefix + self.suffix):</span>
<span class="gi">+            scale = 3</span>
<span class="gi">+        return scale</span>
<span class="gi">+</span>
<span class="gi">+    def scientific_notation_elements(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: decimal.Decimal,</span>
<span class="gi">+        locale: Locale | str | None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+    ) -&gt; tuple[decimal.Decimal, int, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot; Returns normalized scientific notation components of a value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def apply(self, value: (float | decimal.Decimal | str), locale: (Locale |</span>
<span class="gd">-        str | None), currency: (str | None)=None, currency_digits: bool=</span>
<span class="gd">-        True, decimal_quantization: bool=True, force_frac: (tuple[int, int] |</span>
<span class="gd">-        None)=None, group_separator: bool=True, *, numbering_system: (</span>
<span class="gd">-        Literal[&#39;default&#39;] | str)=&#39;latn&#39;):</span>
<span class="gi">+        # Normalize value to only have one lead digit.</span>
<span class="gi">+        exp = value.adjusted()</span>
<span class="gi">+        value = value * get_decimal_quantum(exp)</span>
<span class="gi">+        assert value.adjusted() == 0</span>
<span class="gi">+</span>
<span class="gi">+        # Shift exponent and value by the minimum number of leading digits</span>
<span class="gi">+        # imposed by the rendering pattern. And always make that number</span>
<span class="gi">+        # greater or equal to 1.</span>
<span class="gi">+        lead_shift = max([1, min(self.int_prec)]) - 1</span>
<span class="gi">+        exp = exp - lead_shift</span>
<span class="gi">+        value = value * get_decimal_quantum(-lead_shift)</span>
<span class="gi">+</span>
<span class="gi">+        # Get exponent sign symbol.</span>
<span class="gi">+        exp_sign = &#39;&#39;</span>
<span class="gi">+        if exp &lt; 0:</span>
<span class="gi">+            exp_sign = get_minus_sign_symbol(locale, numbering_system=numbering_system)</span>
<span class="gi">+        elif self.exp_plus:</span>
<span class="gi">+            exp_sign = get_plus_sign_symbol(locale, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+        # Normalize exponent value now that we have the sign.</span>
<span class="gi">+        exp = abs(exp)</span>
<span class="gi">+</span>
<span class="gi">+        return value, exp, exp_sign</span>
<span class="gi">+</span>
<span class="gi">+    def apply(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: float | decimal.Decimal | str,</span>
<span class="gi">+        locale: Locale | str | None,</span>
<span class="gi">+        currency: str | None = None,</span>
<span class="gi">+        currency_digits: bool = True,</span>
<span class="gi">+        decimal_quantization: bool = True,</span>
<span class="gi">+        force_frac: tuple[int, int] | None = None,</span>
<span class="gi">+        group_separator: bool = True,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Renders into a string a number following the defined pattern.

<span class="w"> </span>        Forced decimal quantization is active by default so we&#39;ll produce a
<span class="gu">@@ -875,4 +1379,176 @@ class NumberPattern:</span>
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :raise UnsupportedNumberingSystemError: If the numbering system is not supported by the locale.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(value, decimal.Decimal):</span>
<span class="gi">+            value = decimal.Decimal(str(value))</span>
<span class="gi">+</span>
<span class="gi">+        value = value.scaleb(self.scale)</span>
<span class="gi">+</span>
<span class="gi">+        # Separate the absolute value from its sign.</span>
<span class="gi">+        is_negative = int(value.is_signed())</span>
<span class="gi">+        value = abs(value).normalize()</span>
<span class="gi">+</span>
<span class="gi">+        # Prepare scientific notation metadata.</span>
<span class="gi">+        if self.exp_prec:</span>
<span class="gi">+            value, exp, exp_sign = self.scientific_notation_elements(value, locale, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust the precision of the fractional part and force it to the</span>
<span class="gi">+        # currency&#39;s if necessary.</span>
<span class="gi">+        if force_frac:</span>
<span class="gi">+            # TODO (3.x?): Remove this parameter</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &#39;The force_frac parameter to NumberPattern.apply() is deprecated.&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+            frac_prec = force_frac</span>
<span class="gi">+        elif currency and currency_digits:</span>
<span class="gi">+            frac_prec = (get_currency_precision(currency), ) * 2</span>
<span class="gi">+        else:</span>
<span class="gi">+            frac_prec = self.frac_prec</span>
<span class="gi">+</span>
<span class="gi">+        # Bump decimal precision to the natural precision of the number if it</span>
<span class="gi">+        # exceeds the one we&#39;re about to use. This adaptative precision is only</span>
<span class="gi">+        # triggered if the decimal quantization is disabled or if a scientific</span>
<span class="gi">+        # notation pattern has a missing mandatory fractional part (as in the</span>
<span class="gi">+        # default &#39;#E0&#39; pattern). This special case has been extensively</span>
<span class="gi">+        # discussed at https://github.com/python-babel/babel/pull/494#issuecomment-307649969 .</span>
<span class="gi">+        if not decimal_quantization or (self.exp_prec and frac_prec == (0, 0)):</span>
<span class="gi">+            frac_prec = (frac_prec[0], max([frac_prec[1], get_decimal_precision(value)]))</span>
<span class="gi">+</span>
<span class="gi">+        # Render scientific notation.</span>
<span class="gi">+        if self.exp_prec:</span>
<span class="gi">+            number = &#39;&#39;.join([</span>
<span class="gi">+                self._quantize_value(value, locale, frac_prec, group_separator, numbering_system=numbering_system),</span>
<span class="gi">+                get_exponential_symbol(locale, numbering_system=numbering_system),</span>
<span class="gi">+                exp_sign,  # type: ignore  # exp_sign is always defined here</span>
<span class="gi">+                self._format_int(str(exp), self.exp_prec[0], self.exp_prec[1], locale, numbering_system=numbering_system),  # type: ignore  # exp is always defined here</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="gi">+        # Is it a significant digits pattern?</span>
<span class="gi">+        elif &#39;@&#39; in self.pattern:</span>
<span class="gi">+            text = self._format_significant(value,</span>
<span class="gi">+                                            self.int_prec[0],</span>
<span class="gi">+                                            self.int_prec[1])</span>
<span class="gi">+            a, sep, b = text.partition(&quot;.&quot;)</span>
<span class="gi">+            number = self._format_int(a, 0, 1000, locale, numbering_system=numbering_system)</span>
<span class="gi">+            if sep:</span>
<span class="gi">+                number += get_decimal_symbol(locale, numbering_system=numbering_system) + b</span>
<span class="gi">+</span>
<span class="gi">+        # A normal number pattern.</span>
<span class="gi">+        else:</span>
<span class="gi">+            number = self._quantize_value(value, locale, frac_prec, group_separator, numbering_system=numbering_system)</span>
<span class="gi">+</span>
<span class="gi">+        retval = &#39;&#39;.join([</span>
<span class="gi">+            self.prefix[is_negative],</span>
<span class="gi">+            number if self.number_pattern != &#39;&#39; else &#39;&#39;,</span>
<span class="gi">+            self.suffix[is_negative]])</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;&#39; in retval and currency is not None:</span>
<span class="gi">+            retval = retval.replace(&#39;&#39;, get_currency_name(currency, value, locale))</span>
<span class="gi">+            retval = retval.replace(&#39;&#39;, currency.upper())</span>
<span class="gi">+            retval = retval.replace(&#39;&#39;, get_currency_symbol(currency, locale))</span>
<span class="gi">+</span>
<span class="gi">+        # remove single quotes around text, except for doubled single quotes</span>
<span class="gi">+        # which are replaced with a single quote</span>
<span class="gi">+        retval = re.sub(r&quot;&#39;([^&#39;]*)&#39;&quot;, lambda m: m.group(1) or &quot;&#39;&quot;, retval)</span>
<span class="gi">+</span>
<span class="gi">+        return retval</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # This is one tricky piece of code.  The idea is to rely as much as possible</span>
<span class="gi">+    # on the decimal module to minimize the amount of code.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Conceptually, the implementation of this method can be summarized in the</span>
<span class="gi">+    # following steps:</span>
<span class="gi">+    #</span>
<span class="gi">+    #   - Move or shift the decimal point (i.e. the exponent) so the maximum</span>
<span class="gi">+    #     amount of significant digits fall into the integer part (i.e. to the</span>
<span class="gi">+    #     left of the decimal point)</span>
<span class="gi">+    #</span>
<span class="gi">+    #   - Round the number to the nearest integer, discarding all the fractional</span>
<span class="gi">+    #     part which contained extra digits to be eliminated</span>
<span class="gi">+    #</span>
<span class="gi">+    #   - Convert the rounded integer to a string, that will contain the final</span>
<span class="gi">+    #     sequence of significant digits already trimmed to the maximum</span>
<span class="gi">+    #</span>
<span class="gi">+    #   - Restore the original position of the decimal point, potentially</span>
<span class="gi">+    #     padding with zeroes on either side</span>
<span class="gi">+    #</span>
<span class="gi">+    def _format_significant(self, value: decimal.Decimal, minimum: int, maximum: int) -&gt; str:</span>
<span class="gi">+        exp = value.adjusted()</span>
<span class="gi">+        scale = maximum - 1 - exp</span>
<span class="gi">+        digits = str(value.scaleb(scale).quantize(decimal.Decimal(1)))</span>
<span class="gi">+        if scale &lt;= 0:</span>
<span class="gi">+            result = digits + &#39;0&#39; * -scale</span>
<span class="gi">+        else:</span>
<span class="gi">+            intpart = digits[:-scale]</span>
<span class="gi">+            i = len(intpart)</span>
<span class="gi">+            j = i + max(minimum - i, 0)</span>
<span class="gi">+            result = &quot;{intpart}.{pad:0&lt;{fill}}{fracpart}{fracextra}&quot;.format(</span>
<span class="gi">+                intpart=intpart or &#39;0&#39;,</span>
<span class="gi">+                pad=&#39;&#39;,</span>
<span class="gi">+                fill=-min(exp + 1, 0),</span>
<span class="gi">+                fracpart=digits[i:j],</span>
<span class="gi">+                fracextra=digits[j:].rstrip(&#39;0&#39;),</span>
<span class="gi">+            ).rstrip(&#39;.&#39;)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _format_int(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: str,</span>
<span class="gi">+        min: int,</span>
<span class="gi">+        max: int,</span>
<span class="gi">+        locale: Locale | str | None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        width = len(value)</span>
<span class="gi">+        if width &lt; min:</span>
<span class="gi">+            value = &#39;0&#39; * (min - width) + value</span>
<span class="gi">+        gsize = self.grouping[0]</span>
<span class="gi">+        ret = &#39;&#39;</span>
<span class="gi">+        symbol = get_group_symbol(locale, numbering_system=numbering_system)</span>
<span class="gi">+        while len(value) &gt; gsize:</span>
<span class="gi">+            ret = symbol + value[-gsize:] + ret</span>
<span class="gi">+            value = value[:-gsize]</span>
<span class="gi">+            gsize = self.grouping[1]</span>
<span class="gi">+        return value + ret</span>
<span class="gi">+</span>
<span class="gi">+    def _quantize_value(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: decimal.Decimal,</span>
<span class="gi">+        locale: Locale | str | None,</span>
<span class="gi">+        frac_prec: tuple[int, int],</span>
<span class="gi">+        group_separator: bool,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        # If the number is +/-Infinity, we can&#39;t quantize it</span>
<span class="gi">+        if value.is_infinite():</span>
<span class="gi">+            return get_infinity_symbol(locale, numbering_system=numbering_system)</span>
<span class="gi">+        quantum = get_decimal_quantum(frac_prec[1])</span>
<span class="gi">+        rounded = value.quantize(quantum)</span>
<span class="gi">+        a, sep, b = f&quot;{rounded:f}&quot;.partition(&quot;.&quot;)</span>
<span class="gi">+        integer_part = a</span>
<span class="gi">+        if group_separator:</span>
<span class="gi">+            integer_part = self._format_int(a, self.int_prec[0], self.int_prec[1], locale, numbering_system=numbering_system)</span>
<span class="gi">+        number = integer_part + self._format_frac(b or &#39;0&#39;, locale=locale, force_frac=frac_prec, numbering_system=numbering_system)</span>
<span class="gi">+        return number</span>
<span class="gi">+</span>
<span class="gi">+    def _format_frac(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: str,</span>
<span class="gi">+        locale: Locale | str | None,</span>
<span class="gi">+        force_frac: tuple[int, int] | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        min, max = force_frac or self.frac_prec</span>
<span class="gi">+        if len(value) &lt; min:</span>
<span class="gi">+            value += (&#39;0&#39; * (min - len(value)))</span>
<span class="gi">+        if max == 0 or (min == 0 and int(value) == 0):</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        while len(value) &gt; min and value[-1] == &#39;0&#39;:</span>
<span class="gi">+            value = value[:-1]</span>
<span class="gi">+        return get_decimal_symbol(locale, numbering_system=numbering_system) + value</span>
<span class="gh">diff --git a/babel/plural.py b/babel/plural.py</span>
<span class="gh">index 8675fdf..01df16c 100644</span>
<span class="gd">--- a/babel/plural.py</span>
<span class="gi">+++ b/babel/plural.py</span>
<span class="gu">@@ -8,18 +8,20 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import decimal
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Iterable, Mapping
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal
<span class="gd">-_plural_tags = &#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;few&#39;, &#39;many&#39;, &#39;other&#39;</span>
<span class="gi">+</span>
<span class="gi">+_plural_tags = (&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;few&#39;, &#39;many&#39;, &#39;other&#39;)</span>
<span class="w"> </span>_fallback_tag = &#39;other&#39;


<span class="gd">-def extract_operands(source: (float | decimal.Decimal)) -&gt;tuple[decimal.</span>
<span class="gd">-    Decimal | int, int, int, int, int, int, Literal[0], Literal[0]]:</span>
<span class="gi">+def extract_operands(source: float | decimal.Decimal) -&gt; tuple[decimal.Decimal | int, int, int, int, int, int, Literal[0], Literal[0]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract operands from a decimal, a float or an int, according to `CLDR rules`_.

<span class="w"> </span>    The result is an 8-tuple (n, i, v, w, f, t, c, e), where those symbols are as follows:
<span class="gu">@@ -44,7 +46,38 @@ def extract_operands(source: (float | decimal.Decimal)) -&gt;tuple[decimal.</span>
<span class="w"> </span>    :return: A n-i-v-w-f-t-c-e tuple
<span class="w"> </span>    :rtype: tuple[decimal.Decimal, int, int, int, int, int, int, int]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = abs(source)</span>
<span class="gi">+    i = int(n)</span>
<span class="gi">+    if isinstance(n, float):</span>
<span class="gi">+        if i == n:</span>
<span class="gi">+            n = i</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Cast the `float` to a number via the string representation.</span>
<span class="gi">+            # This is required for Python 2.6 anyway (it will straight out fail to</span>
<span class="gi">+            # do the conversion otherwise), and it&#39;s highly unlikely that the user</span>
<span class="gi">+            # actually wants the lossless conversion behavior (quoting the Python</span>
<span class="gi">+            # documentation):</span>
<span class="gi">+            # &gt; If value is a float, the binary floating point value is losslessly</span>
<span class="gi">+            # &gt; converted to its exact decimal equivalent.</span>
<span class="gi">+            # &gt; This conversion can often require 53 or more digits of precision.</span>
<span class="gi">+            # Should the user want that behavior, they can simply pass in a pre-</span>
<span class="gi">+            # converted `Decimal` instance of desired accuracy.</span>
<span class="gi">+            n = decimal.Decimal(str(n))</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(n, decimal.Decimal):</span>
<span class="gi">+        dec_tuple = n.as_tuple()</span>
<span class="gi">+        exp = dec_tuple.exponent</span>
<span class="gi">+        fraction_digits = dec_tuple.digits[exp:] if exp &lt; 0 else ()</span>
<span class="gi">+        trailing = &#39;&#39;.join(str(d) for d in fraction_digits)</span>
<span class="gi">+        no_trailing = trailing.rstrip(&#39;0&#39;)</span>
<span class="gi">+        v = len(trailing)</span>
<span class="gi">+        w = len(no_trailing)</span>
<span class="gi">+        f = int(trailing or 0)</span>
<span class="gi">+        t = int(no_trailing or 0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        v = w = f = t = 0</span>
<span class="gi">+    c = e = 0  # TODO: c and e are not supported</span>
<span class="gi">+    return n, i, v, w, f, t, c, e</span>


<span class="w"> </span>class PluralRule:
<span class="gu">@@ -67,10 +100,10 @@ class PluralRule:</span>

<span class="w"> </span>    .. _`CLDR rules`: https://www.unicode.org/reports/tr35/tr35-33/tr35-numbers.html#Language_Plural_Rules
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;abstract&#39;, &#39;_func&#39;</span>

<span class="gd">-    def __init__(self, rules: (Mapping[str, str] | Iterable[tuple[str, str]])</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    __slots__ = (&#39;abstract&#39;, &#39;_func&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, rules: Mapping[str, str] | Iterable[tuple[str, str]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the rule instance.

<span class="w"> </span>        :param rules: a list of ``(tag, expr)``) tuples with the rules
<span class="gu">@@ -84,63 +117,63 @@ class PluralRule:</span>
<span class="w"> </span>        self.abstract: list[tuple[str, Any]] = []
<span class="w"> </span>        for key, expr in sorted(rules):
<span class="w"> </span>            if key not in _plural_tags:
<span class="gd">-                raise ValueError(f&#39;unknown tag {key!r}&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;unknown tag {key!r}&quot;)</span>
<span class="w"> </span>            elif key in found:
<span class="gd">-                raise ValueError(f&#39;tag {key!r} defined twice&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;tag {key!r} defined twice&quot;)</span>
<span class="w"> </span>            found.add(key)
<span class="w"> </span>            ast = _Parser(expr).ast
<span class="w"> </span>            if ast:
<span class="w"> </span>                self.abstract.append((key, ast))

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        rules = self.rules
<span class="gd">-        args = &#39;, &#39;.join([f&#39;{tag}: {rules[tag]}&#39; for tag in _plural_tags if</span>
<span class="gd">-            tag in rules])</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {args!r}&gt;&#39;</span>
<span class="gi">+        args = &quot;, &quot;.join([f&quot;{tag}: {rules[tag]}&quot; for tag in _plural_tags if tag in rules])</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {args!r}&gt;&quot;</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def parse(cls, rules: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="gd">-        PluralRule)) -&gt;PluralRule:</span>
<span class="gi">+    def parse(cls, rules: Mapping[str, str] | Iterable[tuple[str, str]] | PluralRule) -&gt; PluralRule:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a `PluralRule` instance for the given rules.  If the rules
<span class="w"> </span>        are a `PluralRule` object, that object is returned.

<span class="w"> </span>        :param rules: the rules as list or dict, or a `PluralRule` object
<span class="w"> </span>        :raise RuleError: if the expression is malformed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(rules, PluralRule):</span>
<span class="gi">+            return rules</span>
<span class="gi">+        return cls(rules)</span>

<span class="w"> </span>    @property
<span class="gd">-    def rules(self) -&gt;Mapping[str, str]:</span>
<span class="gi">+    def rules(self) -&gt; Mapping[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The `PluralRule` as a dict of unicode plural rules.

<span class="w"> </span>        &gt;&gt;&gt; rule = PluralRule({&#39;one&#39;: &#39;n is 1&#39;})
<span class="w"> </span>        &gt;&gt;&gt; rule.rules
<span class="w"> </span>        {&#39;one&#39;: &#39;n is 1&#39;}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        _compile = _UnicodeCompiler().compile</span>
<span class="gi">+        return {tag: _compile(ast) for tag, ast in self.abstract}</span>

<span class="w"> </span>    @property
<span class="gd">-    def tags(self) -&gt;frozenset[str]:</span>
<span class="gi">+    def tags(self) -&gt; frozenset[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A set of explicitly defined tags in this rule.  The implicit default
<span class="w"> </span>        ``&#39;other&#39;`` rules is not part of this set unless there is an explicit
<span class="w"> </span>        rule for it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return frozenset(i[0] for i in self.abstract)</span>

<span class="gd">-    def __getstate__(self) -&gt;list[tuple[str, Any]]:</span>
<span class="gi">+    def __getstate__(self) -&gt; list[tuple[str, Any]]:</span>
<span class="w"> </span>        return self.abstract

<span class="gd">-    def __setstate__(self, abstract: list[tuple[str, Any]]) -&gt;None:</span>
<span class="gi">+    def __setstate__(self, abstract: list[tuple[str, Any]]) -&gt; None:</span>
<span class="w"> </span>        self.abstract = abstract

<span class="gd">-    def __call__(self, n: (float | decimal.Decimal)) -&gt;str:</span>
<span class="gi">+    def __call__(self, n: float | decimal.Decimal) -&gt; str:</span>
<span class="w"> </span>        if not hasattr(self, &#39;_func&#39;):
<span class="w"> </span>            self._func = to_python(self)
<span class="w"> </span>        return self._func(n)


<span class="gd">-def to_javascript(rule: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="gd">-    PluralRule)) -&gt;str:</span>
<span class="gi">+def to_javascript(rule: Mapping[str, str] | Iterable[tuple[str, str]] | PluralRule) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a list/dict of rules or a `PluralRule` object into a JavaScript
<span class="w"> </span>    function.  This function depends on no external library:

<span class="gu">@@ -155,11 +188,15 @@ def to_javascript(rule: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="w"> </span>    :param rule: the rules as list or dict, or a `PluralRule` object
<span class="w"> </span>    :raise RuleError: if the expression is malformed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    to_js = _JavaScriptCompiler().compile</span>
<span class="gi">+    result = [&#39;(function(n) { return &#39;]</span>
<span class="gi">+    for tag, ast in PluralRule.parse(rule).abstract:</span>
<span class="gi">+        result.append(f&quot;{to_js(ast)} ? {tag!r} : &quot;)</span>
<span class="gi">+    result.append(&#39;%r; })&#39; % _fallback_tag)</span>
<span class="gi">+    return &#39;&#39;.join(result)</span>


<span class="gd">-def to_python(rule: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="gd">-    PluralRule)) -&gt;Callable[[float | decimal.Decimal], str]:</span>
<span class="gi">+def to_python(rule: Mapping[str, str] | Iterable[tuple[str, str]] | PluralRule) -&gt; Callable[[float | decimal.Decimal], str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a list/dict of rules or a `PluralRule` object into a regular
<span class="w"> </span>    Python function.  This is useful in situations where you need a real
<span class="w"> </span>    function and don&#39;t are about the actual rule object:
<span class="gu">@@ -178,11 +215,28 @@ def to_python(rule: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="w"> </span>    :param rule: the rules as list or dict, or a `PluralRule` object
<span class="w"> </span>    :raise RuleError: if the expression is malformed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def to_gettext(rule: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="gd">-    PluralRule)) -&gt;str:</span>
<span class="gi">+    namespace = {</span>
<span class="gi">+        &#39;IN&#39;: in_range_list,</span>
<span class="gi">+        &#39;WITHIN&#39;: within_range_list,</span>
<span class="gi">+        &#39;MOD&#39;: cldr_modulo,</span>
<span class="gi">+        &#39;extract_operands&#39;: extract_operands,</span>
<span class="gi">+    }</span>
<span class="gi">+    to_python_func = _PythonCompiler().compile</span>
<span class="gi">+    result = [</span>
<span class="gi">+        &#39;def evaluate(n):&#39;,</span>
<span class="gi">+        &#39; n, i, v, w, f, t, c, e = extract_operands(n)&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    for tag, ast in PluralRule.parse(rule).abstract:</span>
<span class="gi">+        # the str() call is to coerce the tag to the native string.  It&#39;s</span>
<span class="gi">+        # a limited ascii restricted set of tags anyways so that is fine.</span>
<span class="gi">+        result.append(f&quot; if ({to_python_func(ast)}): return {str(tag)!r}&quot;)</span>
<span class="gi">+    result.append(f&quot; return {_fallback_tag!r}&quot;)</span>
<span class="gi">+    code = compile(&#39;\n&#39;.join(result), &#39;&lt;rule&gt;&#39;, &#39;exec&#39;)</span>
<span class="gi">+    eval(code, namespace)</span>
<span class="gi">+    return namespace[&#39;evaluate&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_gettext(rule: Mapping[str, str] | Iterable[tuple[str, str]] | PluralRule) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;The plural rule as gettext expression.  The gettext expression is
<span class="w"> </span>    technically limited to integers and returns indices rather than tags.

<span class="gu">@@ -192,11 +246,20 @@ def to_gettext(rule: (Mapping[str, str] | Iterable[tuple[str, str]] |</span>
<span class="w"> </span>    :param rule: the rules as list or dict, or a `PluralRule` object
<span class="w"> </span>    :raise RuleError: if the expression is malformed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rule = PluralRule.parse(rule)</span>
<span class="gi">+</span>
<span class="gi">+    used_tags = rule.tags | {_fallback_tag}</span>
<span class="gi">+    _compile = _GettextCompiler().compile</span>
<span class="gi">+    _get_index = [tag for tag in _plural_tags if tag in used_tags].index</span>

<span class="gi">+    result = [f&quot;nplurals={len(used_tags)}; plural=(&quot;]</span>
<span class="gi">+    for tag, ast in rule.abstract:</span>
<span class="gi">+        result.append(f&quot;{_compile(ast)} ? {_get_index(tag)} : &quot;)</span>
<span class="gi">+    result.append(f&quot;{_get_index(_fallback_tag)});&quot;)</span>
<span class="gi">+    return &#39;&#39;.join(result)</span>

<span class="gd">-def in_range_list(num: (float | decimal.Decimal), range_list: Iterable[</span>
<span class="gd">-    Iterable[float | decimal.Decimal]]) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def in_range_list(num: float | decimal.Decimal, range_list: Iterable[Iterable[float | decimal.Decimal]]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Integer range list test.  This is the callback for the &quot;in&quot; operator
<span class="w"> </span>    of the UTS #35 pluralization rule language:

<span class="gu">@@ -213,11 +276,10 @@ def in_range_list(num: (float | decimal.Decimal), range_list: Iterable[</span>
<span class="w"> </span>    &gt;&gt;&gt; in_range_list(10, [(1, 4), (6, 8)])
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return num == int(num) and within_range_list(num, range_list)</span>


<span class="gd">-def within_range_list(num: (float | decimal.Decimal), range_list: Iterable[</span>
<span class="gd">-    Iterable[float | decimal.Decimal]]) -&gt;bool:</span>
<span class="gi">+def within_range_list(num: float | decimal.Decimal, range_list: Iterable[Iterable[float | decimal.Decimal]]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Float range test.  This is the callback for the &quot;within&quot; operator
<span class="w"> </span>    of the UTS #35 pluralization rule language:

<span class="gu">@@ -234,10 +296,10 @@ def within_range_list(num: (float | decimal.Decimal), range_list: Iterable[</span>
<span class="w"> </span>    &gt;&gt;&gt; within_range_list(10.5, [(1, 4), (20, 30)])
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(num &gt;= min_ and num &lt;= max_ for min_, max_ in range_list)</span>


<span class="gd">-def cldr_modulo(a: float, b: float) -&gt;float:</span>
<span class="gi">+def cldr_modulo(a: float, b: float) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Javaish modulo.  This modulo operator returns the value with the sign
<span class="w"> </span>    of the dividend rather than the divisor like Python does:

<span class="gu">@@ -248,19 +310,91 @@ def cldr_modulo(a: float, b: float) -&gt;float:</span>
<span class="w"> </span>    &gt;&gt;&gt; cldr_modulo(3, 5)
<span class="w"> </span>    3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reverse = 0</span>
<span class="gi">+    if a &lt; 0:</span>
<span class="gi">+        a *= -1</span>
<span class="gi">+        reverse = 1</span>
<span class="gi">+    if b &lt; 0:</span>
<span class="gi">+        b *= -1</span>
<span class="gi">+    rv = a % b</span>
<span class="gi">+    if reverse:</span>
<span class="gi">+        rv *= -1</span>
<span class="gi">+    return rv</span>


<span class="w"> </span>class RuleError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised if a rule is malformed.&quot;&quot;&quot;


<span class="gd">-_VARS = {&#39;n&#39;, &#39;i&#39;, &#39;v&#39;, &#39;w&#39;, &#39;f&#39;, &#39;t&#39;, &#39;c&#39;, &#39;e&#39;}</span>
<span class="gd">-_RULES: list[tuple[str | None, re.Pattern[str]]] = [(None, re.compile(</span>
<span class="gd">-    &#39;\\s+&#39;, re.UNICODE)), (&#39;word&#39;, re.compile(</span>
<span class="gd">-    f&quot;\\b(and|or|is|(?:with)?in|not|mod|[{&#39;&#39;.join(_VARS)}])\\b&quot;)), (&#39;value&#39;,</span>
<span class="gd">-    re.compile(&#39;\\d+&#39;)), (&#39;symbol&#39;, re.compile(&#39;%|,|!=|=&#39;)), (&#39;ellipsis&#39;,</span>
<span class="gd">-    re.compile(&#39;\\.{2,3}|\\u2026&#39;, re.UNICODE))]</span>
<span class="gi">+_VARS = {</span>
<span class="gi">+    &#39;n&#39;,  # absolute value of the source number.</span>
<span class="gi">+    &#39;i&#39;,  # integer digits of n.</span>
<span class="gi">+    &#39;v&#39;,  # number of visible fraction digits in n, with trailing zeros.*</span>
<span class="gi">+    &#39;w&#39;,  # number of visible fraction digits in n, without trailing zeros.*</span>
<span class="gi">+    &#39;f&#39;,  # visible fraction digits in n, with trailing zeros.*</span>
<span class="gi">+    &#39;t&#39;,  # visible fraction digits in n, without trailing zeros.*</span>
<span class="gi">+    &#39;c&#39;,  # compact decimal exponent value: exponent of the power of 10 used in compact decimal formatting.</span>
<span class="gi">+    &#39;e&#39;,  # currently, synonym for `c`. however, may be redefined in the future.</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+_RULES: list[tuple[str | None, re.Pattern[str]]] = [</span>
<span class="gi">+    (None, re.compile(r&#39;\s+&#39;, re.UNICODE)),</span>
<span class="gi">+    (&#39;word&#39;, re.compile(fr&#39;\b(and|or|is|(?:with)?in|not|mod|[{&quot;&quot;.join(_VARS)}])\b&#39;)),</span>
<span class="gi">+    (&#39;value&#39;, re.compile(r&#39;\d+&#39;)),</span>
<span class="gi">+    (&#39;symbol&#39;, re.compile(r&#39;%|,|!=|=&#39;)),</span>
<span class="gi">+    (&#39;ellipsis&#39;, re.compile(r&#39;\.{2,3}|\u2026&#39;, re.UNICODE)),  # U+2026: ELLIPSIS</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tokenize_rule(s: str) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+    s = s.split(&#39;@&#39;)[0]</span>
<span class="gi">+    result: list[tuple[str, str]] = []</span>
<span class="gi">+    pos = 0</span>
<span class="gi">+    end = len(s)</span>
<span class="gi">+    while pos &lt; end:</span>
<span class="gi">+        for tok, rule in _RULES:</span>
<span class="gi">+            match = rule.match(s, pos)</span>
<span class="gi">+            if match is not None:</span>
<span class="gi">+                pos = match.end()</span>
<span class="gi">+                if tok:</span>
<span class="gi">+                    result.append((tok, match.group()))</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuleError(&#39;malformed CLDR pluralization rule.  &#39;</span>
<span class="gi">+                            &#39;Got unexpected %r&#39; % s[pos])</span>
<span class="gi">+    return result[::-1]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def test_next_token(</span>
<span class="gi">+    tokens: list[tuple[str, str]],</span>
<span class="gi">+    type_: str,</span>
<span class="gi">+    value: str | None = None,</span>
<span class="gi">+) -&gt; list[tuple[str, str]] | bool:</span>
<span class="gi">+    return tokens and tokens[-1][0] == type_ and \</span>
<span class="gi">+        (value is None or tokens[-1][1] == value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def skip_token(tokens: list[tuple[str, str]], type_: str, value: str | None = None):</span>
<span class="gi">+    if test_next_token(tokens, type_, value):</span>
<span class="gi">+        return tokens.pop()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def value_node(value: int) -&gt; tuple[Literal[&#39;value&#39;], tuple[int]]:</span>
<span class="gi">+    return &#39;value&#39;, (value, )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ident_node(name: str) -&gt; tuple[str, tuple[()]]:</span>
<span class="gi">+    return name, ()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def range_list_node(</span>
<span class="gi">+    range_list: Iterable[Iterable[float | decimal.Decimal]],</span>
<span class="gi">+) -&gt; tuple[Literal[&#39;range_list&#39;], Iterable[Iterable[float | decimal.Decimal]]]:</span>
<span class="gi">+    return &#39;range_list&#39;, range_list</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def negate(rv: tuple[Any, ...]) -&gt; tuple[Literal[&#39;not&#39;], tuple[tuple[Any, ...]]]:</span>
<span class="gi">+    return &#39;not&#39;, (rv,)</span>


<span class="w"> </span>class _Parser:
<span class="gu">@@ -300,22 +434,99 @@ class _Parser:</span>
<span class="w"> </span>    def __init__(self, string):
<span class="w"> </span>        self.tokens = tokenize_rule(string)
<span class="w"> </span>        if not self.tokens:
<span class="gi">+            # If the pattern is only samples, it&#39;s entirely possible</span>
<span class="gi">+            # no stream of tokens whatsoever is generated.</span>
<span class="w"> </span>            self.ast = None
<span class="w"> </span>            return
<span class="w"> </span>        self.ast = self.condition()
<span class="w"> </span>        if self.tokens:
<span class="gd">-            raise RuleError(f&#39;Expected end of rule, got {self.tokens[-1][1]!r}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise RuleError(f&quot;Expected end of rule, got {self.tokens[-1][1]!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def expect(self, type_, value=None, term=None):</span>
<span class="gi">+        token = skip_token(self.tokens, type_, value)</span>
<span class="gi">+        if token is not None:</span>
<span class="gi">+            return token</span>
<span class="gi">+        if term is None:</span>
<span class="gi">+            term = repr(value is None and type_ or value)</span>
<span class="gi">+        if not self.tokens:</span>
<span class="gi">+            raise RuleError(f&quot;expected {term} but end of rule reached&quot;)</span>
<span class="gi">+        raise RuleError(f&quot;expected {term} but got {self.tokens[-1][1]!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def condition(self):</span>
<span class="gi">+        op = self.and_condition()</span>
<span class="gi">+        while skip_token(self.tokens, &#39;word&#39;, &#39;or&#39;):</span>
<span class="gi">+            op = &#39;or&#39;, (op, self.and_condition())</span>
<span class="gi">+        return op</span>
<span class="gi">+</span>
<span class="gi">+    def and_condition(self):</span>
<span class="gi">+        op = self.relation()</span>
<span class="gi">+        while skip_token(self.tokens, &#39;word&#39;, &#39;and&#39;):</span>
<span class="gi">+            op = &#39;and&#39;, (op, self.relation())</span>
<span class="gi">+        return op</span>
<span class="gi">+</span>
<span class="gi">+    def relation(self):</span>
<span class="gi">+        left = self.expr()</span>
<span class="gi">+        if skip_token(self.tokens, &#39;word&#39;, &#39;is&#39;):</span>
<span class="gi">+            return skip_token(self.tokens, &#39;word&#39;, &#39;not&#39;) and &#39;isnot&#39; or &#39;is&#39;, \</span>
<span class="gi">+                (left, self.value())</span>
<span class="gi">+        negated = skip_token(self.tokens, &#39;word&#39;, &#39;not&#39;)</span>
<span class="gi">+        method = &#39;in&#39;</span>
<span class="gi">+        if skip_token(self.tokens, &#39;word&#39;, &#39;within&#39;):</span>
<span class="gi">+            method = &#39;within&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not skip_token(self.tokens, &#39;word&#39;, &#39;in&#39;):</span>
<span class="gi">+                if negated:</span>
<span class="gi">+                    raise RuleError(&#39;Cannot negate operator based rules.&#39;)</span>
<span class="gi">+                return self.newfangled_relation(left)</span>
<span class="gi">+        rv = &#39;relation&#39;, (method, left, self.range_list())</span>
<span class="gi">+        return negate(rv) if negated else rv</span>
<span class="gi">+</span>
<span class="gi">+    def newfangled_relation(self, left):</span>
<span class="gi">+        if skip_token(self.tokens, &#39;symbol&#39;, &#39;=&#39;):</span>
<span class="gi">+            negated = False</span>
<span class="gi">+        elif skip_token(self.tokens, &#39;symbol&#39;, &#39;!=&#39;):</span>
<span class="gi">+            negated = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuleError(&#39;Expected &quot;=&quot; or &quot;!=&quot; or legacy relation&#39;)</span>
<span class="gi">+        rv = &#39;relation&#39;, (&#39;in&#39;, left, self.range_list())</span>
<span class="gi">+        return negate(rv) if negated else rv</span>
<span class="gi">+</span>
<span class="gi">+    def range_or_value(self):</span>
<span class="gi">+        left = self.value()</span>
<span class="gi">+        if skip_token(self.tokens, &#39;ellipsis&#39;):</span>
<span class="gi">+            return left, self.value()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return left, left</span>
<span class="gi">+</span>
<span class="gi">+    def range_list(self):</span>
<span class="gi">+        range_list = [self.range_or_value()]</span>
<span class="gi">+        while skip_token(self.tokens, &#39;symbol&#39;, &#39;,&#39;):</span>
<span class="gi">+            range_list.append(self.range_or_value())</span>
<span class="gi">+        return range_list_node(range_list)</span>
<span class="gi">+</span>
<span class="gi">+    def expr(self):</span>
<span class="gi">+        word = skip_token(self.tokens, &#39;word&#39;)</span>
<span class="gi">+        if word is None or word[1] not in _VARS:</span>
<span class="gi">+            raise RuleError(&#39;Expected identifier variable&#39;)</span>
<span class="gi">+        name = word[1]</span>
<span class="gi">+        if skip_token(self.tokens, &#39;word&#39;, &#39;mod&#39;):</span>
<span class="gi">+            return &#39;mod&#39;, ((name, ()), self.value())</span>
<span class="gi">+        elif skip_token(self.tokens, &#39;symbol&#39;, &#39;%&#39;):</span>
<span class="gi">+            return &#39;mod&#39;, ((name, ()), self.value())</span>
<span class="gi">+        return ident_node(name)</span>
<span class="gi">+</span>
<span class="gi">+    def value(self):</span>
<span class="gi">+        return value_node(int(self.expect(&#39;value&#39;)[1]))</span>


<span class="w"> </span>def _binary_compiler(tmpl):
<span class="w"> </span>    &quot;&quot;&quot;Compiler factory for the `_Compiler`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return lambda self, left, right: tmpl % (self.compile(left), self.compile(right))</span>


<span class="w"> </span>def _unary_compiler(tmpl):
<span class="w"> </span>    &quot;&quot;&quot;Compiler factory for the `_Compiler`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return lambda self, x: tmpl % self.compile(x)</span>


<span class="w"> </span>compile_zero = lambda x: &#39;0&#39;
<span class="gu">@@ -325,6 +536,11 @@ class _Compiler:</span>
<span class="w"> </span>    &quot;&quot;&quot;The compilers are able to transform the expressions into multiple
<span class="w"> </span>    output formats.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def compile(self, arg):</span>
<span class="gi">+        op, args = arg</span>
<span class="gi">+        return getattr(self, f&quot;compile_{op}&quot;)(*args)</span>
<span class="gi">+</span>
<span class="w"> </span>    compile_n = lambda x: &#39;n&#39;
<span class="w"> </span>    compile_i = lambda x: &#39;i&#39;
<span class="w"> </span>    compile_v = lambda x: &#39;v&#39;
<span class="gu">@@ -341,37 +557,85 @@ class _Compiler:</span>
<span class="w"> </span>    compile_is = _binary_compiler(&#39;(%s == %s)&#39;)
<span class="w"> </span>    compile_isnot = _binary_compiler(&#39;(%s != %s)&#39;)

<span class="gi">+    def compile_relation(self, method, expr, range_list):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>

<span class="w"> </span>class _PythonCompiler(_Compiler):
<span class="w"> </span>    &quot;&quot;&quot;Compiles an expression to Python.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    compile_and = _binary_compiler(&#39;(%s and %s)&#39;)
<span class="w"> </span>    compile_or = _binary_compiler(&#39;(%s or %s)&#39;)
<span class="w"> </span>    compile_not = _unary_compiler(&#39;(not %s)&#39;)
<span class="w"> </span>    compile_mod = _binary_compiler(&#39;MOD(%s, %s)&#39;)

<span class="gi">+    def compile_relation(self, method, expr, range_list):</span>
<span class="gi">+        ranges = &quot;,&quot;.join([f&quot;({self.compile(a)}, {self.compile(b)})&quot; for (a, b) in range_list[1]])</span>
<span class="gi">+        return f&quot;{method.upper()}({self.compile(expr)}, [{ranges}])&quot;</span>
<span class="gi">+</span>

<span class="w"> </span>class _GettextCompiler(_Compiler):
<span class="w"> </span>    &quot;&quot;&quot;Compile into a gettext plural expression.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    compile_i = _Compiler.compile_n
<span class="w"> </span>    compile_v = compile_zero
<span class="w"> </span>    compile_w = compile_zero
<span class="w"> </span>    compile_f = compile_zero
<span class="w"> </span>    compile_t = compile_zero

<span class="gi">+    def compile_relation(self, method, expr, range_list):</span>
<span class="gi">+        rv = []</span>
<span class="gi">+        expr = self.compile(expr)</span>
<span class="gi">+        for item in range_list[1]:</span>
<span class="gi">+            if item[0] == item[1]:</span>
<span class="gi">+                rv.append(f&quot;({expr} == {self.compile(item[0])})&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                min, max = map(self.compile, item)</span>
<span class="gi">+                rv.append(f&quot;({expr} &gt;= {min} &amp;&amp; {expr} &lt;= {max})&quot;)</span>
<span class="gi">+        return f&quot;({&#39; || &#39;.join(rv)})&quot;</span>
<span class="gi">+</span>

<span class="w"> </span>class _JavaScriptCompiler(_GettextCompiler):
<span class="w"> </span>    &quot;&quot;&quot;Compiles the expression to plain of JavaScript.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # XXX: presently javascript does not support any of the</span>
<span class="gi">+    # fraction support and basically only deals with integers.</span>
<span class="w"> </span>    compile_i = lambda x: &#39;parseInt(n, 10)&#39;
<span class="w"> </span>    compile_v = compile_zero
<span class="w"> </span>    compile_w = compile_zero
<span class="w"> </span>    compile_f = compile_zero
<span class="w"> </span>    compile_t = compile_zero

<span class="gi">+    def compile_relation(self, method, expr, range_list):</span>
<span class="gi">+        code = _GettextCompiler.compile_relation(</span>
<span class="gi">+            self, method, expr, range_list)</span>
<span class="gi">+        if method == &#39;in&#39;:</span>
<span class="gi">+            expr = self.compile(expr)</span>
<span class="gi">+            code = f&quot;(parseInt({expr}, 10) == {expr} &amp;&amp; {code})&quot;</span>
<span class="gi">+        return code</span>
<span class="gi">+</span>

<span class="w"> </span>class _UnicodeCompiler(_Compiler):
<span class="w"> </span>    &quot;&quot;&quot;Returns a unicode pluralization rule again.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # XXX: this currently spits out the old syntax instead of the new</span>
<span class="gi">+    # one.  We can change that, but it will break a whole bunch of stuff</span>
<span class="gi">+    # for users I suppose.</span>
<span class="gi">+</span>
<span class="w"> </span>    compile_is = _binary_compiler(&#39;%s is %s&#39;)
<span class="w"> </span>    compile_isnot = _binary_compiler(&#39;%s is not %s&#39;)
<span class="w"> </span>    compile_and = _binary_compiler(&#39;%s and %s&#39;)
<span class="w"> </span>    compile_or = _binary_compiler(&#39;%s or %s&#39;)
<span class="w"> </span>    compile_mod = _binary_compiler(&#39;%s mod %s&#39;)
<span class="gi">+</span>
<span class="gi">+    def compile_not(self, relation):</span>
<span class="gi">+        return self.compile_relation(*relation[1], negated=True)</span>
<span class="gi">+</span>
<span class="gi">+    def compile_relation(self, method, expr, range_list, negated=False):</span>
<span class="gi">+        ranges = []</span>
<span class="gi">+        for item in range_list[1]:</span>
<span class="gi">+            if item[0] == item[1]:</span>
<span class="gi">+                ranges.append(self.compile(item[0]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                ranges.append(f&quot;{self.compile(item[0])}..{self.compile(item[1])}&quot;)</span>
<span class="gi">+        return f&quot;{self.compile(expr)}{&#39; not&#39; if negated else &#39;&#39;} {method} {&#39;,&#39;.join(ranges)}&quot;</span>
<span class="gh">diff --git a/babel/support.py b/babel/support.py</span>
<span class="gh">index bd493bb..1774d9d 100644</span>
<span class="gd">--- a/babel/support.py</span>
<span class="gi">+++ b/babel/support.py</span>
<span class="gu">@@ -11,17 +11,28 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import decimal
<span class="w"> </span>import gettext
<span class="w"> </span>import locale
<span class="w"> </span>import os
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Iterable
<span class="gi">+</span>
<span class="w"> </span>from babel.core import Locale
<span class="w"> </span>from babel.dates import format_date, format_datetime, format_time, format_timedelta
<span class="gd">-from babel.numbers import format_compact_currency, format_compact_decimal, format_currency, format_decimal, format_percent, format_scientific</span>
<span class="gi">+from babel.numbers import (</span>
<span class="gi">+    format_compact_currency,</span>
<span class="gi">+    format_compact_decimal,</span>
<span class="gi">+    format_currency,</span>
<span class="gi">+    format_decimal,</span>
<span class="gi">+    format_percent,</span>
<span class="gi">+    format_scientific,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal
<span class="gi">+</span>
<span class="w"> </span>    from babel.dates import _PredefinedTimeFormat


<span class="gu">@@ -38,9 +49,13 @@ class Format:</span>
<span class="w"> </span>    u&#39;1.234&#39;
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, locale: (Locale | str), tzinfo: (datetime.tzinfo |</span>
<span class="gd">-        None)=None, *, numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        locale: Locale | str,</span>
<span class="gi">+        tzinfo: datetime.tzinfo | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the formatter.

<span class="w"> </span>        :param locale: the locale identifier or `Locale` instance
<span class="gu">@@ -52,8 +67,11 @@ class Format:</span>
<span class="w"> </span>        self.tzinfo = tzinfo
<span class="w"> </span>        self.numbering_system = numbering_system

<span class="gd">-    def date(self, date: (datetime.date | None)=None, format: (</span>
<span class="gd">-        _PredefinedTimeFormat | str)=&#39;medium&#39;) -&gt;str:</span>
<span class="gi">+    def date(</span>
<span class="gi">+        self,</span>
<span class="gi">+        date: datetime.date | None = None,</span>
<span class="gi">+        format: _PredefinedTimeFormat | str = &#39;medium&#39;,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a date formatted according to the given pattern.

<span class="w"> </span>        &gt;&gt;&gt; from datetime import date
<span class="gu">@@ -61,36 +79,46 @@ class Format:</span>
<span class="w"> </span>        &gt;&gt;&gt; fmt.date(date(2007, 4, 1))
<span class="w"> </span>        u&#39;Apr 1, 2007&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_date(date, format, locale=self.locale)</span>

<span class="gd">-    def datetime(self, datetime: (datetime.date | None)=None, format: (</span>
<span class="gd">-        _PredefinedTimeFormat | str)=&#39;medium&#39;) -&gt;str:</span>
<span class="gi">+    def datetime(</span>
<span class="gi">+        self,</span>
<span class="gi">+        datetime: datetime.date | None = None,</span>
<span class="gi">+        format: _PredefinedTimeFormat | str = &#39;medium&#39;,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a date and time formatted according to the given pattern.

<span class="w"> </span>        &gt;&gt;&gt; from datetime import datetime
<span class="w"> </span>        &gt;&gt;&gt; from babel.dates import get_timezone
<span class="w"> </span>        &gt;&gt;&gt; fmt = Format(&#39;en_US&#39;, tzinfo=get_timezone(&#39;US/Eastern&#39;))
<span class="w"> </span>        &gt;&gt;&gt; fmt.datetime(datetime(2007, 4, 1, 15, 30))
<span class="gd">-        u&#39;Apr 1, 2007, 11:30:00AM&#39;</span>
<span class="gi">+        u&#39;Apr 1, 2007, 11:30:00\u202fAM&#39;</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_datetime(datetime, format, tzinfo=self.tzinfo, locale=self.locale)</span>

<span class="gd">-    def time(self, time: (datetime.time | datetime.datetime | None)=None,</span>
<span class="gd">-        format: (_PredefinedTimeFormat | str)=&#39;medium&#39;) -&gt;str:</span>
<span class="gi">+    def time(</span>
<span class="gi">+        self,</span>
<span class="gi">+        time: datetime.time | datetime.datetime | None = None,</span>
<span class="gi">+        format: _PredefinedTimeFormat | str = &#39;medium&#39;,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a time formatted according to the given pattern.

<span class="w"> </span>        &gt;&gt;&gt; from datetime import datetime
<span class="w"> </span>        &gt;&gt;&gt; from babel.dates import get_timezone
<span class="w"> </span>        &gt;&gt;&gt; fmt = Format(&#39;en_US&#39;, tzinfo=get_timezone(&#39;US/Eastern&#39;))
<span class="w"> </span>        &gt;&gt;&gt; fmt.time(datetime(2007, 4, 1, 15, 30))
<span class="gd">-        u&#39;11:30:00AM&#39;</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def timedelta(self, delta: (datetime.timedelta | int), granularity:</span>
<span class="gd">-        Literal[&#39;year&#39;, &#39;month&#39;, &#39;week&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;]</span>
<span class="gd">-        =&#39;second&#39;, threshold: float=0.85, format: Literal[&#39;narrow&#39;, &#39;short&#39;,</span>
<span class="gd">-        &#39;medium&#39;, &#39;long&#39;]=&#39;long&#39;, add_direction: bool=False) -&gt;str:</span>
<span class="gi">+        u&#39;11:30:00\u202fAM&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return format_time(time, format, tzinfo=self.tzinfo, locale=self.locale)</span>
<span class="gi">+</span>
<span class="gi">+    def timedelta(</span>
<span class="gi">+        self,</span>
<span class="gi">+        delta: datetime.timedelta | int,</span>
<span class="gi">+        granularity: Literal[&quot;year&quot;, &quot;month&quot;, &quot;week&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;] = &quot;second&quot;,</span>
<span class="gi">+        threshold: float = 0.85,</span>
<span class="gi">+        format: Literal[&quot;narrow&quot;, &quot;short&quot;, &quot;medium&quot;, &quot;long&quot;] = &quot;long&quot;,</span>
<span class="gi">+        add_direction: bool = False,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a time delta according to the rules of the given locale.

<span class="w"> </span>        &gt;&gt;&gt; from datetime import timedelta
<span class="gu">@@ -98,30 +126,35 @@ class Format:</span>
<span class="w"> </span>        &gt;&gt;&gt; fmt.timedelta(timedelta(weeks=11))
<span class="w"> </span>        u&#39;3 months&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_timedelta(delta, granularity=granularity,</span>
<span class="gi">+                                threshold=threshold,</span>
<span class="gi">+                                format=format, add_direction=add_direction,</span>
<span class="gi">+                                locale=self.locale)</span>

<span class="gd">-    def number(self, number: (float | decimal.Decimal | str)) -&gt;str:</span>
<span class="gi">+    def number(self, number: float | decimal.Decimal | str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an integer number formatted for the locale.

<span class="w"> </span>        &gt;&gt;&gt; fmt = Format(&#39;en_US&#39;)
<span class="w"> </span>        &gt;&gt;&gt; fmt.number(1099)
<span class="w"> </span>        u&#39;1,099&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_decimal(number, locale=self.locale, numbering_system=self.numbering_system)</span>

<span class="gd">-    def decimal(self, number: (float | decimal.Decimal | str), format: (str |</span>
<span class="gd">-        None)=None) -&gt;str:</span>
<span class="gi">+    def decimal(self, number: float | decimal.Decimal | str, format: str | None = None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a decimal number formatted for the locale.

<span class="w"> </span>        &gt;&gt;&gt; fmt = Format(&#39;en_US&#39;)
<span class="w"> </span>        &gt;&gt;&gt; fmt.decimal(1.2345)
<span class="w"> </span>        u&#39;1.234&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_decimal(number, format, locale=self.locale, numbering_system=self.numbering_system)</span>

<span class="gd">-    def compact_decimal(self, number: (float | decimal.Decimal | str),</span>
<span class="gd">-        format_type: Literal[&#39;short&#39;, &#39;long&#39;]=&#39;short&#39;, fraction_digits: int=0</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def compact_decimal(</span>
<span class="gi">+        self,</span>
<span class="gi">+        number: float | decimal.Decimal | str,</span>
<span class="gi">+        format_type: Literal[&#39;short&#39;, &#39;long&#39;] = &#39;short&#39;,</span>
<span class="gi">+        fraction_digits: int = 0,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a number formatted in compact form for the locale.

<span class="w"> </span>        &gt;&gt;&gt; fmt = Format(&#39;en_US&#39;)
<span class="gu">@@ -130,39 +163,48 @@ class Format:</span>
<span class="w"> </span>        &gt;&gt;&gt; fmt.compact_decimal(1234567, format_type=&#39;long&#39;, fraction_digits=2)
<span class="w"> </span>        &#39;1.23 million&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_compact_decimal(</span>
<span class="gi">+            number,</span>
<span class="gi">+            format_type=format_type,</span>
<span class="gi">+            fraction_digits=fraction_digits,</span>
<span class="gi">+            locale=self.locale,</span>
<span class="gi">+            numbering_system=self.numbering_system,</span>
<span class="gi">+        )</span>

<span class="gd">-    def currency(self, number: (float | decimal.Decimal | str), currency: str</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def currency(self, number: float | decimal.Decimal | str, currency: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a number in the given currency formatted for the locale.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_currency(number, currency, locale=self.locale, numbering_system=self.numbering_system)</span>

<span class="gd">-    def compact_currency(self, number: (float | decimal.Decimal | str),</span>
<span class="gd">-        currency: str, format_type: Literal[&#39;short&#39;]=&#39;short&#39;,</span>
<span class="gd">-        fraction_digits: int=0) -&gt;str:</span>
<span class="gi">+    def compact_currency(</span>
<span class="gi">+        self,</span>
<span class="gi">+        number: float | decimal.Decimal | str,</span>
<span class="gi">+        currency: str,</span>
<span class="gi">+        format_type: Literal[&#39;short&#39;] = &#39;short&#39;,</span>
<span class="gi">+        fraction_digits: int = 0,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a number in the given currency formatted for the locale
<span class="w"> </span>        using the compact number format.

<span class="w"> </span>        &gt;&gt;&gt; Format(&#39;en_US&#39;).compact_currency(1234567, &quot;USD&quot;, format_type=&#39;short&#39;, fraction_digits=2)
<span class="w"> </span>        &#39;$1.23M&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_compact_currency(number, currency, format_type=format_type, fraction_digits=fraction_digits,</span>
<span class="gi">+                                       locale=self.locale, numbering_system=self.numbering_system)</span>

<span class="gd">-    def percent(self, number: (float | decimal.Decimal | str), format: (str |</span>
<span class="gd">-        None)=None) -&gt;str:</span>
<span class="gi">+    def percent(self, number: float | decimal.Decimal | str, format: str | None = None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a number formatted as percentage for the locale.

<span class="w"> </span>        &gt;&gt;&gt; fmt = Format(&#39;en_US&#39;)
<span class="w"> </span>        &gt;&gt;&gt; fmt.percent(0.34)
<span class="w"> </span>        u&#39;34%&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_percent(number, format, locale=self.locale, numbering_system=self.numbering_system)</span>

<span class="gd">-    def scientific(self, number: (float | decimal.Decimal | str)) -&gt;str:</span>
<span class="gi">+    def scientific(self, number: float | decimal.Decimal | str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a number formatted using scientific notation for the locale.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return format_scientific(number, locale=self.locale, numbering_system=self.numbering_system)</span>


<span class="w"> </span>class LazyProxy:
<span class="gu">@@ -200,8 +242,8 @@ class LazyProxy:</span>
<span class="w"> </span>    Hello, universe!
<span class="w"> </span>    Hello, world!
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;_func&#39;, &#39;_args&#39;, &#39;_kwargs&#39;, &#39;_value&#39;, &#39;_is_cache_enabled&#39;,</span>
<span class="gd">-        &#39;_attribute_error&#39;]</span>
<span class="gi">+    __slots__ = [&#39;_func&#39;, &#39;_args&#39;, &#39;_kwargs&#39;, &#39;_value&#39;, &#39;_is_cache_enabled&#39;, &#39;_attribute_error&#39;]</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        _func: Callable[..., Any]
<span class="w"> </span>        _args: tuple[Any, ...]
<span class="gu">@@ -210,8 +252,8 @@ class LazyProxy:</span>
<span class="w"> </span>        _value: Any
<span class="w"> </span>        _attribute_error: AttributeError | None

<span class="gd">-    def __init__(self, func: Callable[..., Any], *args: Any, enable_cache:</span>
<span class="gd">-        bool=True, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, func: Callable[..., Any], *args: Any, enable_cache: bool = True, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        # Avoid triggering our own __setattr__ implementation</span>
<span class="w"> </span>        object.__setattr__(self, &#39;_func&#39;, func)
<span class="w"> </span>        object.__setattr__(self, &#39;_args&#39;, args)
<span class="w"> </span>        object.__setattr__(self, &#39;_kwargs&#39;, kwargs)
<span class="gu">@@ -219,158 +261,200 @@ class LazyProxy:</span>
<span class="w"> </span>        object.__setattr__(self, &#39;_value&#39;, None)
<span class="w"> </span>        object.__setattr__(self, &#39;_attribute_error&#39;, None)

<span class="gd">-    def __contains__(self, key: object) -&gt;bool:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def value(self) -&gt; Any:</span>
<span class="gi">+        if self._value is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = self._func(*self._args, **self._kwargs)</span>
<span class="gi">+            except AttributeError as error:</span>
<span class="gi">+                object.__setattr__(self, &#39;_attribute_error&#39;, error)</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            if not self._is_cache_enabled:</span>
<span class="gi">+                return value</span>
<span class="gi">+            object.__setattr__(self, &#39;_value&#39;, value)</span>
<span class="gi">+        return self._value</span>
<span class="gi">+</span>
<span class="gi">+    def __contains__(self, key: object) -&gt; bool:</span>
<span class="w"> </span>        return key in self.value

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        return bool(self.value)

<span class="gd">-    def __dir__(self) -&gt;list[str]:</span>
<span class="gi">+    def __dir__(self) -&gt; list[str]:</span>
<span class="w"> </span>        return dir(self.value)

<span class="gd">-    def __iter__(self) -&gt;Iterator[Any]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Any]:</span>
<span class="w"> </span>        return iter(self.value)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self.value)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self.value)

<span class="gd">-    def __add__(self, other: object) -&gt;Any:</span>
<span class="gi">+    def __add__(self, other: object) -&gt; Any:</span>
<span class="w"> </span>        return self.value + other

<span class="gd">-    def __radd__(self, other: object) -&gt;Any:</span>
<span class="gi">+    def __radd__(self, other: object) -&gt; Any:</span>
<span class="w"> </span>        return other + self.value

<span class="gd">-    def __mod__(self, other: object) -&gt;Any:</span>
<span class="gi">+    def __mod__(self, other: object) -&gt; Any:</span>
<span class="w"> </span>        return self.value % other

<span class="gd">-    def __rmod__(self, other: object) -&gt;Any:</span>
<span class="gi">+    def __rmod__(self, other: object) -&gt; Any:</span>
<span class="w"> </span>        return other % self.value

<span class="gd">-    def __mul__(self, other: object) -&gt;Any:</span>
<span class="gi">+    def __mul__(self, other: object) -&gt; Any:</span>
<span class="w"> </span>        return self.value * other

<span class="gd">-    def __rmul__(self, other: object) -&gt;Any:</span>
<span class="gi">+    def __rmul__(self, other: object) -&gt; Any:</span>
<span class="w"> </span>        return other * self.value

<span class="gd">-    def __call__(self, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="w"> </span>        return self.value(*args, **kwargs)

<span class="gd">-    def __lt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value &lt; other

<span class="gd">-    def __le__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value &lt;= other

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value == other

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value != other

<span class="gd">-    def __gt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value &gt; other

<span class="gd">-    def __ge__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value &gt;= other

<span class="gd">-    def __delattr__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __delattr__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        delattr(self.value, name)

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        if self._attribute_error is not None:
<span class="w"> </span>            raise self._attribute_error
<span class="w"> </span>        return getattr(self.value, name)

<span class="gd">-    def __setattr__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        setattr(self.value, name, value)

<span class="gd">-    def __delitem__(self, key: Any) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key: Any) -&gt; None:</span>
<span class="w"> </span>        del self.value[key]

<span class="gd">-    def __getitem__(self, key: Any) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: Any) -&gt; Any:</span>
<span class="w"> </span>        return self.value[key]

<span class="gd">-    def __setitem__(self, key: Any, value: Any) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: Any, value: Any) -&gt; None:</span>
<span class="w"> </span>        self.value[key] = value

<span class="gd">-    def __copy__(self) -&gt;LazyProxy:</span>
<span class="gd">-        return LazyProxy(self._func, *self._args, enable_cache=self.</span>
<span class="gd">-            _is_cache_enabled, **self._kwargs)</span>
<span class="gi">+    def __copy__(self) -&gt; LazyProxy:</span>
<span class="gi">+        return LazyProxy(</span>
<span class="gi">+            self._func,</span>
<span class="gi">+            enable_cache=self._is_cache_enabled,</span>
<span class="gi">+            *self._args,  # noqa: B026</span>
<span class="gi">+            **self._kwargs,</span>
<span class="gi">+        )</span>

<span class="gd">-    def __deepcopy__(self, memo: Any) -&gt;LazyProxy:</span>
<span class="gi">+    def __deepcopy__(self, memo: Any) -&gt; LazyProxy:</span>
<span class="w"> </span>        from copy import deepcopy
<span class="gd">-        return LazyProxy(deepcopy(self._func, memo), *deepcopy(self._args,</span>
<span class="gd">-            memo), enable_cache=deepcopy(self._is_cache_enabled, memo), **</span>
<span class="gd">-            deepcopy(self._kwargs, memo))</span>
<span class="gi">+        return LazyProxy(</span>
<span class="gi">+            deepcopy(self._func, memo),</span>
<span class="gi">+            enable_cache=deepcopy(self._is_cache_enabled, memo),</span>
<span class="gi">+            *deepcopy(self._args, memo),  # noqa: B026</span>
<span class="gi">+            **deepcopy(self._kwargs, memo),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class NullTranslations(gettext.NullTranslations):
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        _info: dict[str, str]
<span class="w"> </span>        _fallback: NullTranslations | None
<span class="gi">+</span>
<span class="w"> </span>    DEFAULT_DOMAIN = None

<span class="gd">-    def __init__(self, fp: (gettext._TranslationsReader | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, fp: gettext._TranslationsReader | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a simple translations class which is not backed by a
<span class="w"> </span>        real catalog. Behaves similar to gettext.NullTranslations but also
<span class="w"> </span>        offers Babel&#39;s on *gettext methods (e.g. &#39;dgettext()&#39;).

<span class="w"> </span>        :param fp: a file-like object (ignored in this class)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # These attributes are set by gettext.NullTranslations when a catalog</span>
<span class="gi">+        # is parsed (fp != None). Ensure that they are always present because</span>
<span class="gi">+        # some *gettext methods (including &#39;.gettext()&#39;) rely on the attributes.</span>
<span class="w"> </span>        self._catalog: dict[tuple[str, Any] | str, str] = {}
<span class="gd">-        self.plural: Callable[[float | decimal.Decimal], int] = lambda n: int(</span>
<span class="gd">-            n != 1)</span>
<span class="gi">+        self.plural: Callable[[float | decimal.Decimal], int] = lambda n: int(n != 1)</span>
<span class="w"> </span>        super().__init__(fp=fp)
<span class="w"> </span>        self.files = list(filter(None, [getattr(fp, &#39;name&#39;, None)]))
<span class="w"> </span>        self.domain = self.DEFAULT_DOMAIN
<span class="w"> </span>        self._domains: dict[str, NullTranslations] = {}

<span class="gd">-    def dgettext(self, domain: str, message: str) -&gt;str:</span>
<span class="gi">+    def dgettext(self, domain: str, message: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``gettext()``, but look the message up in the specified
<span class="w"> </span>        domain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).gettext(message)</span>

<span class="gd">-    def ldgettext(self, domain: str, message: str) -&gt;str:</span>
<span class="gi">+    def ldgettext(self, domain: str, message: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``lgettext()``, but look the message up in the specified
<span class="w"> </span>        domain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import warnings</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;ldgettext() is deprecated, use dgettext() instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self._domains.get(domain, self).lgettext(message)</span>

<span class="gd">-    def udgettext(self, domain: str, message: str) -&gt;str:</span>
<span class="gi">+    def udgettext(self, domain: str, message: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``ugettext()``, but look the message up in the specified
<span class="w"> </span>        domain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).ugettext(message)</span>
<span class="gi">+    # backward compatibility with 0.9</span>
<span class="w"> </span>    dugettext = udgettext

<span class="gd">-    def dngettext(self, domain: str, singular: str, plural: str, num: int</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def dngettext(self, domain: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``ngettext()``, but look the message up in the specified
<span class="w"> </span>        domain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).ngettext(singular, plural, num)</span>

<span class="gd">-    def ldngettext(self, domain: str, singular: str, plural: str, num: int</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def ldngettext(self, domain: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``lngettext()``, but look the message up in the specified
<span class="w"> </span>        domain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import warnings</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;ldngettext() is deprecated, use dngettext() instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self._domains.get(domain, self).lngettext(singular, plural, num)</span>

<span class="gd">-    def udngettext(self, domain: str, singular: str, plural: str, num: int</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def udngettext(self, domain: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``ungettext()`` but look the message up in the specified
<span class="w"> </span>        domain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).ungettext(singular, plural, num)</span>
<span class="gi">+    # backward compatibility with 0.9</span>
<span class="w"> </span>    dungettext = udngettext
<span class="gi">+</span>
<span class="gi">+    # Most of the downwards code, until it gets included in stdlib, from:</span>
<span class="gi">+    #    https://bugs.python.org/file10036/gettext-pgettext.patch</span>
<span class="gi">+    #</span>
<span class="gi">+    # The encoding of a msgctxt and a msgid in a .mo file is</span>
<span class="gi">+    # msgctxt + &quot;\x04&quot; + msgid (gettext version &gt;= 0.15)</span>
<span class="w"> </span>    CONTEXT_ENCODING = &#39;%s\x04%s&#39;

<span class="gd">-    def pgettext(self, context: str, message: str) -&gt;(str | object):</span>
<span class="gi">+    def pgettext(self, context: str, message: str) -&gt; str | object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look up the `context` and `message` id in the catalog and return the
<span class="w"> </span>        corresponding message string, as an 8-bit string encoded with the
<span class="w"> </span>        catalog&#39;s charset encoding, if known.  If there is no entry in the
<span class="gu">@@ -378,17 +462,31 @@ class NullTranslations(gettext.NullTranslations):</span>
<span class="w"> </span>        set, the look up is forwarded to the fallback&#39;s ``pgettext()``
<span class="w"> </span>        method. Otherwise, the `message` id is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctxt_msg_id = self.CONTEXT_ENCODING % (context, message)</span>
<span class="gi">+        missing = object()</span>
<span class="gi">+        tmsg = self._catalog.get(ctxt_msg_id, missing)</span>
<span class="gi">+        if tmsg is missing:</span>
<span class="gi">+            if self._fallback:</span>
<span class="gi">+                return self._fallback.pgettext(context, message)</span>
<span class="gi">+            return message</span>
<span class="gi">+        return tmsg</span>

<span class="gd">-    def lpgettext(self, context: str, message: str) -&gt;(str | bytes | object):</span>
<span class="gi">+    def lpgettext(self, context: str, message: str) -&gt; str | bytes | object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Equivalent to ``pgettext()``, but the translation is returned in the
<span class="w"> </span>        preferred system encoding, if no other encoding was explicitly set with
<span class="w"> </span>        ``bind_textdomain_codeset()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def npgettext(self, context: str, singular: str, plural: str, num: int</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        import warnings</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;lpgettext() is deprecated, use pgettext() instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        tmsg = self.pgettext(context, message)</span>
<span class="gi">+        encoding = getattr(self, &quot;_output_charset&quot;, None) or locale.getpreferredencoding()</span>
<span class="gi">+        return tmsg.encode(encoding) if isinstance(tmsg, str) else tmsg</span>
<span class="gi">+</span>
<span class="gi">+    def npgettext(self, context: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do a plural-forms lookup of a message id.  `singular` is used as the
<span class="w"> </span>        message id for purposes of lookup in the catalog, while `num` is used to
<span class="w"> </span>        determine which plural form to use.  The returned message string is an
<span class="gu">@@ -399,27 +497,60 @@ class NullTranslations(gettext.NullTranslations):</span>
<span class="w"> </span>        ``npgettext()`` method.  Otherwise, when ``num`` is 1 ``singular`` is
<span class="w"> </span>        returned, and ``plural`` is returned in all other cases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def lnpgettext(self, context: str, singular: str, plural: str, num: int</span>
<span class="gd">-        ) -&gt;(str | bytes):</span>
<span class="gi">+        ctxt_msg_id = self.CONTEXT_ENCODING % (context, singular)</span>
<span class="gi">+        try:</span>
<span class="gi">+            tmsg = self._catalog[(ctxt_msg_id, self.plural(num))]</span>
<span class="gi">+            return tmsg</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if self._fallback:</span>
<span class="gi">+                return self._fallback.npgettext(context, singular, plural, num)</span>
<span class="gi">+            if num == 1:</span>
<span class="gi">+                return singular</span>
<span class="gi">+            else:</span>
<span class="gi">+                return plural</span>
<span class="gi">+</span>
<span class="gi">+    def lnpgettext(self, context: str, singular: str, plural: str, num: int) -&gt; str | bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Equivalent to ``npgettext()``, but the translation is returned in the
<span class="w"> </span>        preferred system encoding, if no other encoding was explicitly set with
<span class="w"> </span>        ``bind_textdomain_codeset()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def upgettext(self, context: str, message: str) -&gt;str:</span>
<span class="gi">+        import warnings</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;lnpgettext() is deprecated, use npgettext() instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        ctxt_msg_id = self.CONTEXT_ENCODING % (context, singular)</span>
<span class="gi">+        try:</span>
<span class="gi">+            tmsg = self._catalog[(ctxt_msg_id, self.plural(num))]</span>
<span class="gi">+            encoding = getattr(self, &quot;_output_charset&quot;, None) or locale.getpreferredencoding()</span>
<span class="gi">+            return tmsg.encode(encoding)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if self._fallback:</span>
<span class="gi">+                return self._fallback.lnpgettext(context, singular, plural, num)</span>
<span class="gi">+            if num == 1:</span>
<span class="gi">+                return singular</span>
<span class="gi">+            else:</span>
<span class="gi">+                return plural</span>
<span class="gi">+</span>
<span class="gi">+    def upgettext(self, context: str, message: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look up the `context` and `message` id in the catalog and return the
<span class="w"> </span>        corresponding message string, as a Unicode string.  If there is no entry
<span class="w"> </span>        in the catalog for the `message` id and `context`, and a fallback has
<span class="w"> </span>        been set, the look up is forwarded to the fallback&#39;s ``upgettext()``
<span class="w"> </span>        method.  Otherwise, the `message` id is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def unpgettext(self, context: str, singular: str, plural: str, num: int</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        ctxt_message_id = self.CONTEXT_ENCODING % (context, message)</span>
<span class="gi">+        missing = object()</span>
<span class="gi">+        tmsg = self._catalog.get(ctxt_message_id, missing)</span>
<span class="gi">+        if tmsg is missing:</span>
<span class="gi">+            if self._fallback:</span>
<span class="gi">+                return self._fallback.upgettext(context, message)</span>
<span class="gi">+            return str(message)</span>
<span class="gi">+        assert isinstance(tmsg, str)</span>
<span class="gi">+        return tmsg</span>
<span class="gi">+</span>
<span class="gi">+    def unpgettext(self, context: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do a plural-forms lookup of a message id.  `singular` is used as the
<span class="w"> </span>        message id for purposes of lookup in the catalog, while `num` is used to
<span class="w"> </span>        determine which plural form to use.  The returned message string is a
<span class="gu">@@ -430,62 +561,70 @@ class NullTranslations(gettext.NullTranslations):</span>
<span class="w"> </span>        ``unpgettext()`` method.  Otherwise, when `num` is 1 `singular` is
<span class="w"> </span>        returned, and `plural` is returned in all other cases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctxt_message_id = self.CONTEXT_ENCODING % (context, singular)</span>
<span class="gi">+        try:</span>
<span class="gi">+            tmsg = self._catalog[(ctxt_message_id, self.plural(num))]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if self._fallback:</span>
<span class="gi">+                return self._fallback.unpgettext(context, singular, plural, num)</span>
<span class="gi">+            tmsg = str(singular) if num == 1 else str(plural)</span>
<span class="gi">+        return tmsg</span>

<span class="gd">-    def dpgettext(self, domain: str, context: str, message: str) -&gt;(str |</span>
<span class="gd">-        object):</span>
<span class="gi">+    def dpgettext(self, domain: str, context: str, message: str) -&gt; str | object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like `pgettext()`, but look the message up in the specified
<span class="w"> </span>        `domain`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).pgettext(context, message)</span>

<span class="gd">-    def udpgettext(self, domain: str, context: str, message: str) -&gt;str:</span>
<span class="gi">+    def udpgettext(self, domain: str, context: str, message: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like `upgettext()`, but look the message up in the specified
<span class="w"> </span>        `domain`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).upgettext(context, message)</span>
<span class="gi">+    # backward compatibility with 0.9</span>
<span class="w"> </span>    dupgettext = udpgettext

<span class="gd">-    def ldpgettext(self, domain: str, context: str, message: str) -&gt;(str |</span>
<span class="gd">-        bytes | object):</span>
<span class="gi">+    def ldpgettext(self, domain: str, context: str, message: str) -&gt; str | bytes | object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Equivalent to ``dpgettext()``, but the translation is returned in the
<span class="w"> </span>        preferred system encoding, if no other encoding was explicitly set with
<span class="w"> </span>        ``bind_textdomain_codeset()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).lpgettext(context, message)</span>

<span class="gd">-    def dnpgettext(self, domain: str, context: str, singular: str, plural:</span>
<span class="gd">-        str, num: int) -&gt;str:</span>
<span class="gi">+    def dnpgettext(self, domain: str, context: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``npgettext``, but look the message up in the specified
<span class="w"> </span>        `domain`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).npgettext(context, singular,</span>
<span class="gi">+                                                         plural, num)</span>

<span class="gd">-    def udnpgettext(self, domain: str, context: str, singular: str, plural:</span>
<span class="gd">-        str, num: int) -&gt;str:</span>
<span class="gi">+    def udnpgettext(self, domain: str, context: str, singular: str, plural: str, num: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like ``unpgettext``, but look the message up in the specified
<span class="w"> </span>        `domain`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).unpgettext(context, singular,</span>
<span class="gi">+                                                          plural, num)</span>
<span class="gi">+    # backward compatibility with 0.9</span>
<span class="w"> </span>    dunpgettext = udnpgettext

<span class="gd">-    def ldnpgettext(self, domain: str, context: str, singular: str, plural:</span>
<span class="gd">-        str, num: int) -&gt;(str | bytes):</span>
<span class="gi">+    def ldnpgettext(self, domain: str, context: str, singular: str, plural: str, num: int) -&gt; str | bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Equivalent to ``dnpgettext()``, but the translation is returned in
<span class="w"> </span>        the preferred system encoding, if no other encoding was explicitly set
<span class="w"> </span>        with ``bind_textdomain_codeset()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._domains.get(domain, self).lnpgettext(context, singular,</span>
<span class="gi">+                                                          plural, num)</span>
<span class="gi">+</span>
<span class="w"> </span>    ugettext = gettext.NullTranslations.gettext
<span class="w"> </span>    ungettext = gettext.NullTranslations.ngettext


<span class="w"> </span>class Translations(NullTranslations, gettext.GNUTranslations):
<span class="w"> </span>    &quot;&quot;&quot;An extended translation catalog class.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    DEFAULT_DOMAIN = &#39;messages&#39;

<span class="gd">-    def __init__(self, fp: (gettext._TranslationsReader | None)=None,</span>
<span class="gd">-        domain: (str | None)=None):</span>
<span class="gi">+    def __init__(self, fp: gettext._TranslationsReader | None = None, domain: str | None = None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the translations catalog.

<span class="w"> </span>        :param fp: the file-like object the translation should be read from
<span class="gu">@@ -493,13 +632,17 @@ class Translations(NullTranslations, gettext.GNUTranslations):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super().__init__(fp=fp)
<span class="w"> </span>        self.domain = domain or self.DEFAULT_DOMAIN
<span class="gi">+</span>
<span class="w"> </span>    ugettext = gettext.GNUTranslations.gettext
<span class="w"> </span>    ungettext = gettext.GNUTranslations.ngettext

<span class="w"> </span>    @classmethod
<span class="gd">-    def load(cls, dirname: (str | os.PathLike[str] | None)=None, locales: (</span>
<span class="gd">-        Iterable[str | Locale] | str | Locale | None)=None, domain: (str |</span>
<span class="gd">-        None)=None) -&gt;NullTranslations:</span>
<span class="gi">+    def load(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        dirname: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        locales: Iterable[str | Locale] | str | Locale | None = None,</span>
<span class="gi">+        domain: str | None = None,</span>
<span class="gi">+    ) -&gt; NullTranslations:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load translations from the given directory.

<span class="w"> </span>        :param dirname: the directory containing the ``MO`` files
<span class="gu">@@ -508,13 +651,19 @@ class Translations(NullTranslations, gettext.GNUTranslations):</span>
<span class="w"> </span>                        strings)
<span class="w"> </span>        :param domain: the message domain (default: &#39;messages&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not domain:</span>
<span class="gi">+            domain = cls.DEFAULT_DOMAIN</span>
<span class="gi">+        filename = gettext.find(domain, dirname, _locales_to_names(locales))</span>
<span class="gi">+        if not filename:</span>
<span class="gi">+            return NullTranslations()</span>
<span class="gi">+        with open(filename, &#39;rb&#39;) as fp:</span>
<span class="gi">+            return cls(fp=fp, domain=domain)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        version = self._info.get(&#39;project-id-version&#39;)
<span class="w"> </span>        return f&#39;&lt;{type(self).__name__}: &quot;{version}&quot;&gt;&#39;

<span class="gd">-    def add(self, translations: Translations, merge: bool=True):</span>
<span class="gi">+    def add(self, translations: Translations, merge: bool = True):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add the given translations to the catalog.

<span class="w"> </span>        If the domain of the translations is different than that of the
<span class="gu">@@ -527,7 +676,18 @@ class Translations(NullTranslations, gettext.GNUTranslations):</span>
<span class="w"> </span>                      already been added should be merged with the existing
<span class="w"> </span>                      translations
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        domain = getattr(translations, &#39;domain&#39;, self.DEFAULT_DOMAIN)</span>
<span class="gi">+        if merge and domain == self.domain:</span>
<span class="gi">+            return self.merge(translations)</span>
<span class="gi">+</span>
<span class="gi">+        existing = self._domains.get(domain)</span>
<span class="gi">+        if merge and isinstance(existing, Translations):</span>
<span class="gi">+            existing.merge(translations)</span>
<span class="gi">+        else:</span>
<span class="gi">+            translations.add_fallback(self)</span>
<span class="gi">+            self._domains[domain] = translations</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def merge(self, translations: Translations):
<span class="w"> </span>        &quot;&quot;&quot;Merge the given translations into the catalog.
<span class="gu">@@ -538,15 +698,27 @@ class Translations(NullTranslations, gettext.GNUTranslations):</span>
<span class="w"> </span>        :param translations: the `Translations` instance with the messages to
<span class="w"> </span>                             merge
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(translations, gettext.GNUTranslations):</span>
<span class="gi">+            self._catalog.update(translations._catalog)</span>
<span class="gi">+            if isinstance(translations, Translations):</span>
<span class="gi">+                self.files.extend(translations.files)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="gd">-def _locales_to_names(locales: (Iterable[str | Locale] | str | Locale | None)</span>
<span class="gd">-    ) -&gt;(list[str] | None):</span>
<span class="gi">+def _locales_to_names(</span>
<span class="gi">+    locales: Iterable[str | Locale] | str | Locale | None,</span>
<span class="gi">+) -&gt; list[str] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Normalize a `locales` argument to a list of locale names.

<span class="w"> </span>    :param locales: the list of locales in order of preference (items in
<span class="w"> </span>                    this list can be either `Locale` objects or locale
<span class="w"> </span>                    strings)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if locales is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if isinstance(locales, Locale):</span>
<span class="gi">+        return [str(locales)]</span>
<span class="gi">+    if isinstance(locales, str):</span>
<span class="gi">+        return [locales]</span>
<span class="gi">+    return [str(locale) for locale in locales]</span>
<span class="gh">diff --git a/babel/units.py b/babel/units.py</span>
<span class="gh">index d6014db..36206d0 100644</span>
<span class="gd">--- a/babel/units.py</span>
<span class="gi">+++ b/babel/units.py</span>
<span class="gu">@@ -1,20 +1,25 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import decimal
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from babel.core import Locale
<span class="w"> </span>from babel.numbers import LC_NUMERIC, format_decimal
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal


<span class="w"> </span>class UnknownUnitError(ValueError):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, unit: str, locale: Locale) -&gt;None:</span>
<span class="gd">-        ValueError.__init__(self, f&#39;{unit} is not a known unit in {locale}&#39;)</span>
<span class="gi">+    def __init__(self, unit: str, locale: Locale) -&gt; None:</span>
<span class="gi">+        ValueError.__init__(self, f&quot;{unit} is not a known unit in {locale}&quot;)</span>


<span class="gd">-def get_unit_name(measurement_unit: str, length: Literal[&#39;short&#39;, &#39;long&#39;,</span>
<span class="gd">-    &#39;narrow&#39;]=&#39;long&#39;, locale: (Locale | str | None)=LC_NUMERIC) -&gt;(str | None):</span>
<span class="gi">+def get_unit_name(</span>
<span class="gi">+    measurement_unit: str,</span>
<span class="gi">+    length: Literal[&#39;short&#39;, &#39;long&#39;, &#39;narrow&#39;] = &#39;long&#39;,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the display name for a measurement unit in the given locale.

<span class="gu">@@ -36,11 +41,14 @@ def get_unit_name(measurement_unit: str, length: Literal[&#39;short&#39;, &#39;long&#39;,</span>
<span class="w"> </span>    :param locale: the `Locale` object or locale identifier
<span class="w"> </span>    :return: The unit display name, or None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    unit = _find_unit_pattern(measurement_unit, locale=locale)</span>
<span class="gi">+    if not unit:</span>
<span class="gi">+        raise UnknownUnitError(unit=measurement_unit, locale=locale)</span>
<span class="gi">+    return locale.unit_display_names.get(unit, {}).get(length)</span>


<span class="gd">-def _find_unit_pattern(unit_id: str, locale: (Locale | str | None)=LC_NUMERIC</span>
<span class="gd">-    ) -&gt;(str | None):</span>
<span class="gi">+def _find_unit_pattern(unit_id: str, locale: Locale | str | None = LC_NUMERIC) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Expand a unit into a qualified form.

<span class="gu">@@ -57,13 +65,25 @@ def _find_unit_pattern(unit_id: str, locale: (Locale | str | None)=LC_NUMERIC</span>
<span class="w"> </span>    :param unit_id: the code of a measurement unit.
<span class="w"> </span>    :return: A key to the `unit_patterns` mapping, or None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_unit(value: (str | float | decimal.Decimal), measurement_unit:</span>
<span class="gd">-    str, length: Literal[&#39;short&#39;, &#39;long&#39;, &#39;narrow&#39;]=&#39;long&#39;, format: (str |</span>
<span class="gd">-    None)=None, locale: (Locale | str | None)=LC_NUMERIC, *,</span>
<span class="gd">-    numbering_system: (Literal[&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;str:</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+    unit_patterns = locale._data[&quot;unit_patterns&quot;]</span>
<span class="gi">+    if unit_id in unit_patterns:</span>
<span class="gi">+        return unit_id</span>
<span class="gi">+    for unit_pattern in sorted(unit_patterns, key=len):</span>
<span class="gi">+        if unit_pattern.endswith(unit_id):</span>
<span class="gi">+            return unit_pattern</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_unit(</span>
<span class="gi">+    value: str | float | decimal.Decimal,</span>
<span class="gi">+    measurement_unit: str,</span>
<span class="gi">+    length: Literal[&#39;short&#39;, &#39;long&#39;, &#39;narrow&#39;] = &#39;long&#39;,</span>
<span class="gi">+    format: str | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format a value of a given unit.

<span class="w"> </span>    Values are formatted according to the locale&#39;s usual pluralization rules
<span class="gu">@@ -115,11 +135,34 @@ def format_unit(value: (str | float | decimal.Decimal), measurement_unit:</span>
<span class="w"> </span>                             The special value &quot;default&quot; will use the default numbering system of the locale.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _find_compound_unit(numerator_unit: str, denominator_unit: str, locale:</span>
<span class="gd">-    (Locale | str | None)=LC_NUMERIC) -&gt;(str | None):</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    q_unit = _find_unit_pattern(measurement_unit, locale=locale)</span>
<span class="gi">+    if not q_unit:</span>
<span class="gi">+        raise UnknownUnitError(unit=measurement_unit, locale=locale)</span>
<span class="gi">+    unit_patterns = locale._data[&quot;unit_patterns&quot;][q_unit].get(length, {})</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, str):  # Assume the value is a preformatted singular.</span>
<span class="gi">+        formatted_value = value</span>
<span class="gi">+        plural_form = &quot;one&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        formatted_value = format_decimal(value, format, locale, numbering_system=numbering_system)</span>
<span class="gi">+        plural_form = locale.plural_form(value)</span>
<span class="gi">+</span>
<span class="gi">+    if plural_form in unit_patterns:</span>
<span class="gi">+        return unit_patterns[plural_form].format(formatted_value)</span>
<span class="gi">+</span>
<span class="gi">+    # Fall back to a somewhat bad representation.</span>
<span class="gi">+    # nb: This is marked as no-cover, as the current CLDR seemingly has no way for this to happen.</span>
<span class="gi">+    fallback_name = get_unit_name(measurement_unit, length=length, locale=locale)  # pragma: no cover</span>
<span class="gi">+    return f&quot;{formatted_value} {fallback_name or measurement_unit}&quot;  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_compound_unit(</span>
<span class="gi">+    numerator_unit: str,</span>
<span class="gi">+    denominator_unit: str,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find a predefined compound unit pattern.

<span class="gu">@@ -143,15 +186,41 @@ def _find_compound_unit(numerator_unit: str, denominator_unit: str, locale:</span>
<span class="w"> </span>    :return: A key to the `unit_patterns` mapping, or None.
<span class="w"> </span>    :rtype: str|None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    # Qualify the numerator and denominator units.  This will turn possibly partial</span>
<span class="gi">+    # units like &quot;kilometer&quot; or &quot;hour&quot; into actual units like &quot;length-kilometer&quot; and</span>
<span class="gi">+    # &quot;duration-hour&quot;.</span>
<span class="gi">+</span>
<span class="gi">+    resolved_numerator_unit = _find_unit_pattern(numerator_unit, locale=locale)</span>
<span class="gi">+    resolved_denominator_unit = _find_unit_pattern(denominator_unit, locale=locale)</span>
<span class="gi">+</span>
<span class="gi">+    # If either was not found, we can&#39;t possibly build a suitable compound unit either.</span>
<span class="gi">+    if not (resolved_numerator_unit and resolved_denominator_unit):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # Since compound units are named &quot;speed-kilometer-per-hour&quot;, we&#39;ll have to slice off</span>
<span class="gi">+    # the quantities (i.e. &quot;length&quot;, &quot;duration&quot;) from both qualified units.</span>
<span class="gi">+</span>
<span class="gi">+    bare_numerator_unit = resolved_numerator_unit.split(&quot;-&quot;, 1)[-1]</span>
<span class="gi">+    bare_denominator_unit = resolved_denominator_unit.split(&quot;-&quot;, 1)[-1]</span>
<span class="gi">+</span>
<span class="gi">+    # Now we can try and rebuild a compound unit specifier, then qualify it:</span>
<span class="gi">+</span>
<span class="gi">+    return _find_unit_pattern(f&quot;{bare_numerator_unit}-per-{bare_denominator_unit}&quot;, locale=locale)</span>


<span class="gd">-def format_compound_unit(numerator_value: (str | float | decimal.Decimal),</span>
<span class="gd">-    numerator_unit: (str | None)=None, denominator_value: (str | float |</span>
<span class="gd">-    decimal.Decimal)=1, denominator_unit: (str | None)=None, length:</span>
<span class="gd">-    Literal[&#39;short&#39;, &#39;long&#39;, &#39;narrow&#39;]=&#39;long&#39;, format: (str | None)=None,</span>
<span class="gd">-    locale: (Locale | str | None)=LC_NUMERIC, *, numbering_system: (Literal</span>
<span class="gd">-    [&#39;default&#39;] | str)=&#39;latn&#39;) -&gt;(str | None):</span>
<span class="gi">+def format_compound_unit(</span>
<span class="gi">+    numerator_value: str | float | decimal.Decimal,</span>
<span class="gi">+    numerator_unit: str | None = None,</span>
<span class="gi">+    denominator_value: str | float | decimal.Decimal = 1,</span>
<span class="gi">+    denominator_unit: str | None = None,</span>
<span class="gi">+    length: Literal[&quot;short&quot;, &quot;long&quot;, &quot;narrow&quot;] = &quot;long&quot;,</span>
<span class="gi">+    format: str | None = None,</span>
<span class="gi">+    locale: Locale | str | None = LC_NUMERIC,</span>
<span class="gi">+    *,</span>
<span class="gi">+    numbering_system: Literal[&quot;default&quot;] | str = &quot;latn&quot;,</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Format a compound number value, i.e. &quot;kilometers per hour&quot; or similar.

<span class="gu">@@ -202,4 +271,73 @@ def format_compound_unit(numerator_value: (str | float | decimal.Decimal),</span>
<span class="w"> </span>    :return: A formatted compound value.
<span class="w"> </span>    :raise `UnsupportedNumberingSystemError`: If the numbering system is not supported by the locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locale = Locale.parse(locale)</span>
<span class="gi">+</span>
<span class="gi">+    # Look for a specific compound unit first...</span>
<span class="gi">+</span>
<span class="gi">+    if numerator_unit and denominator_unit and denominator_value == 1:</span>
<span class="gi">+        compound_unit = _find_compound_unit(numerator_unit, denominator_unit, locale=locale)</span>
<span class="gi">+        if compound_unit:</span>
<span class="gi">+            return format_unit(</span>
<span class="gi">+                numerator_value,</span>
<span class="gi">+                compound_unit,</span>
<span class="gi">+                length=length,</span>
<span class="gi">+                format=format,</span>
<span class="gi">+                locale=locale,</span>
<span class="gi">+                numbering_system=numbering_system,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # ... failing that, construct one &quot;by hand&quot;.</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(numerator_value, str):  # Numerator is preformatted</span>
<span class="gi">+        formatted_numerator = numerator_value</span>
<span class="gi">+    elif numerator_unit:  # Numerator has unit</span>
<span class="gi">+        formatted_numerator = format_unit(</span>
<span class="gi">+            numerator_value,</span>
<span class="gi">+            numerator_unit,</span>
<span class="gi">+            length=length,</span>
<span class="gi">+            format=format,</span>
<span class="gi">+            locale=locale,</span>
<span class="gi">+            numbering_system=numbering_system,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:  # Unitless numerator</span>
<span class="gi">+        formatted_numerator = format_decimal(</span>
<span class="gi">+            numerator_value,</span>
<span class="gi">+            format=format,</span>
<span class="gi">+            locale=locale,</span>
<span class="gi">+            numbering_system=numbering_system,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(denominator_value, str):  # Denominator is preformatted</span>
<span class="gi">+        formatted_denominator = denominator_value</span>
<span class="gi">+    elif denominator_unit:  # Denominator has unit</span>
<span class="gi">+        if denominator_value == 1:  # support perUnitPatterns when the denominator is 1</span>
<span class="gi">+            denominator_unit = _find_unit_pattern(denominator_unit, locale=locale)</span>
<span class="gi">+            per_pattern = locale._data[&quot;unit_patterns&quot;].get(denominator_unit, {}).get(length, {}).get(&quot;per&quot;)</span>
<span class="gi">+            if per_pattern:</span>
<span class="gi">+                return per_pattern.format(formatted_numerator)</span>
<span class="gi">+            # See TR-35&#39;s per-unit pattern algorithm, point 3.2.</span>
<span class="gi">+            # For denominator 1, we replace the value to be formatted with the empty string;</span>
<span class="gi">+            # this will make `format_unit` return &quot; second&quot; instead of &quot;1 second&quot;.</span>
<span class="gi">+            denominator_value = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        formatted_denominator = format_unit(</span>
<span class="gi">+            denominator_value,</span>
<span class="gi">+            measurement_unit=(denominator_unit or &quot;&quot;),</span>
<span class="gi">+            length=length,</span>
<span class="gi">+            format=format,</span>
<span class="gi">+            locale=locale,</span>
<span class="gi">+            numbering_system=numbering_system,</span>
<span class="gi">+        ).strip()</span>
<span class="gi">+    else:  # Bare denominator</span>
<span class="gi">+        formatted_denominator = format_decimal(</span>
<span class="gi">+            denominator_value,</span>
<span class="gi">+            format=format,</span>
<span class="gi">+            locale=locale,</span>
<span class="gi">+            numbering_system=numbering_system,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: this doesn&#39;t support &quot;compound_variations&quot; (or &quot;prefix&quot;), and will fall back to the &quot;x/y&quot; representation</span>
<span class="gi">+    per_pattern = locale._data[&quot;compound_unit_patterns&quot;].get(&quot;per&quot;, {}).get(length, {}).get(&quot;compound&quot;, &quot;{0}/{1}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return per_pattern.format(formatted_numerator, formatted_denominator)</span>
<span class="gh">diff --git a/babel/util.py b/babel/util.py</span>
<span class="gh">index cec00b5..093197f 100644</span>
<span class="gd">--- a/babel/util.py</span>
<span class="gi">+++ b/babel/util.py</span>
<span class="gu">@@ -8,6 +8,7 @@</span>
<span class="w"> </span>    :license: BSD, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import collections
<span class="w"> </span>import datetime
<span class="gu">@@ -16,12 +17,15 @@ import re</span>
<span class="w"> </span>import textwrap
<span class="w"> </span>from collections.abc import Generator, Iterable
<span class="w"> </span>from typing import IO, Any, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from babel import dates, localtime
<span class="gi">+</span>
<span class="w"> </span>missing = object()
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="gd">-def distinct(iterable: Iterable[_T]) -&gt;Generator[_T, None, None]:</span>
<span class="gi">+def distinct(iterable: Iterable[_T]) -&gt; Generator[_T, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Yield all items in an iterable collection that are distinct.

<span class="w"> </span>    Unlike when using sets for a similar effect, the original ordering of the
<span class="gu">@@ -34,14 +38,19 @@ def distinct(iterable: Iterable[_T]) -&gt;Generator[_T, None, None]:</span>

<span class="w"> </span>    :param iterable: the iterable collection providing the data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for item in iter(iterable):</span>
<span class="gi">+        if item not in seen:</span>
<span class="gi">+            yield item</span>
<span class="gi">+            seen.add(item)</span>


<span class="gi">+# Regexp to match python magic encoding line</span>
<span class="w"> </span>PYTHON_MAGIC_COMMENT_re = re.compile(
<span class="gd">-    b&#39;[ \\t\\f]* \\# .* coding[=:][ \\t]*([-\\w.]+)&#39;, re.VERBOSE)</span>
<span class="gi">+    br&#39;[ \t\f]* \# .* coding[=:][ \t]*([-\w.]+)&#39;, re.VERBOSE)</span>


<span class="gd">-def parse_encoding(fp: IO[bytes]) -&gt;(str | None):</span>
<span class="gi">+def parse_encoding(fp: IO[bytes]) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Deduce the encoding of a source file from magic comment.

<span class="w"> </span>    It does this in the same way as the `Python interpreter`__
<span class="gu">@@ -52,21 +61,80 @@ def parse_encoding(fp: IO[bytes]) -&gt;(str | None):</span>

<span class="w"> </span>    (From Jeff Dairiki)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pos = fp.tell()</span>
<span class="gi">+    fp.seek(0)</span>
<span class="gi">+    try:</span>
<span class="gi">+        line1 = fp.readline()</span>
<span class="gi">+        has_bom = line1.startswith(codecs.BOM_UTF8)</span>
<span class="gi">+        if has_bom:</span>
<span class="gi">+            line1 = line1[len(codecs.BOM_UTF8):]</span>
<span class="gi">+</span>
<span class="gi">+        m = PYTHON_MAGIC_COMMENT_re.match(line1)</span>
<span class="gi">+        if not m:</span>
<span class="gi">+            try:</span>
<span class="gi">+                import ast</span>
<span class="gi">+                ast.parse(line1.decode(&#39;latin-1&#39;))</span>
<span class="gi">+            except (ImportError, SyntaxError, UnicodeEncodeError):</span>
<span class="gi">+                # Either it&#39;s a real syntax error, in which case the source is</span>
<span class="gi">+                # not valid python source, or line2 is a continuation of line1,</span>
<span class="gi">+                # in which case we don&#39;t want to scan line2 for a magic</span>
<span class="gi">+                # comment.</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                line2 = fp.readline()</span>
<span class="gi">+                m = PYTHON_MAGIC_COMMENT_re.match(line2)</span>
<span class="gi">+</span>
<span class="gi">+        if has_bom:</span>
<span class="gi">+            if m:</span>
<span class="gi">+                magic_comment_encoding = m.group(1).decode(&#39;latin-1&#39;)</span>
<span class="gi">+                if magic_comment_encoding != &#39;utf-8&#39;:</span>
<span class="gi">+                    raise SyntaxError(f&quot;encoding problem: {magic_comment_encoding} with BOM&quot;)</span>
<span class="gi">+            return &#39;utf-8&#39;</span>
<span class="gi">+        elif m:</span>
<span class="gi">+            return m.group(1).decode(&#39;latin-1&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+    finally:</span>
<span class="gi">+        fp.seek(pos)</span>


<span class="w"> </span>PYTHON_FUTURE_IMPORT_re = re.compile(
<span class="gd">-    &#39;from\\s+__future__\\s+import\\s+\\(*(.+)\\)*&#39;)</span>
<span class="gi">+    r&#39;from\s+__future__\s+import\s+\(*(.+)\)*&#39;)</span>


<span class="gd">-def parse_future_flags(fp: IO[bytes], encoding: str=&#39;latin-1&#39;) -&gt;int:</span>
<span class="gi">+def parse_future_flags(fp: IO[bytes], encoding: str = &#39;latin-1&#39;) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse the compiler flags by :mod:`__future__` from the given Python
<span class="w"> </span>    code.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def pathmatch(pattern: str, filename: str) -&gt;bool:</span>
<span class="gi">+    import __future__</span>
<span class="gi">+    pos = fp.tell()</span>
<span class="gi">+    fp.seek(0)</span>
<span class="gi">+    flags = 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        body = fp.read().decode(encoding)</span>
<span class="gi">+</span>
<span class="gi">+        # Fix up the source to be (hopefully) parsable by regexpen.</span>
<span class="gi">+        # This will likely do untoward things if the source code itself is broken.</span>
<span class="gi">+</span>
<span class="gi">+        # (1) Fix `import (\n...` to be `import (...`.</span>
<span class="gi">+        body = re.sub(r&#39;import\s*\([\r\n]+&#39;, &#39;import (&#39;, body)</span>
<span class="gi">+        # (2) Join line-ending commas with the next line.</span>
<span class="gi">+        body = re.sub(r&#39;,\s*[\r\n]+&#39;, &#39;, &#39;, body)</span>
<span class="gi">+        # (3) Remove backslash line continuations.</span>
<span class="gi">+        body = re.sub(r&#39;\\\s*[\r\n]+&#39;, &#39; &#39;, body)</span>
<span class="gi">+</span>
<span class="gi">+        for m in PYTHON_FUTURE_IMPORT_re.finditer(body):</span>
<span class="gi">+            names = [x.strip().strip(&#39;()&#39;) for x in m.group(1).split(&#39;,&#39;)]</span>
<span class="gi">+            for name in names:</span>
<span class="gi">+                feature = getattr(__future__, name, None)</span>
<span class="gi">+                if feature:</span>
<span class="gi">+                    flags |= feature.compiler_flag</span>
<span class="gi">+    finally:</span>
<span class="gi">+        fp.seek(pos)</span>
<span class="gi">+    return flags</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pathmatch(pattern: str, filename: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extended pathname pattern matching.

<span class="w"> </span>    This function is similar to what is provided by the ``fnmatch`` module in
<span class="gu">@@ -104,16 +172,41 @@ def pathmatch(pattern: str, filename: str) -&gt;bool:</span>
<span class="w"> </span>    :param pattern: the glob pattern
<span class="w"> </span>    :param filename: the path name of the file to match against
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    symbols = {</span>
<span class="gi">+        &#39;?&#39;: &#39;[^/]&#39;,</span>
<span class="gi">+        &#39;?/&#39;: &#39;[^/]/&#39;,</span>
<span class="gi">+        &#39;*&#39;: &#39;[^/]+&#39;,</span>
<span class="gi">+        &#39;*/&#39;: &#39;[^/]+/&#39;,</span>
<span class="gi">+        &#39;**/&#39;: &#39;(?:.+/)*?&#39;,</span>
<span class="gi">+        &#39;**&#39;: &#39;(?:.+/)*?[^/]+&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if pattern.startswith(&#39;^&#39;):</span>
<span class="gi">+        buf = [&#39;^&#39;]</span>
<span class="gi">+        pattern = pattern[1:]</span>
<span class="gi">+    elif pattern.startswith(&#39;./&#39;):</span>
<span class="gi">+        buf = [&#39;^&#39;]</span>
<span class="gi">+        pattern = pattern[2:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        buf = []</span>
<span class="gi">+</span>
<span class="gi">+    for idx, part in enumerate(re.split(&#39;([?*]+/?)&#39;, pattern)):</span>
<span class="gi">+        if idx % 2:</span>
<span class="gi">+            buf.append(symbols[part])</span>
<span class="gi">+        elif part:</span>
<span class="gi">+            buf.append(re.escape(part))</span>
<span class="gi">+    match = re.match(f&quot;{&#39;&#39;.join(buf)}$&quot;, filename.replace(os.sep, &quot;/&quot;))</span>
<span class="gi">+    return match is not None</span>


<span class="w"> </span>class TextWrapper(textwrap.TextWrapper):
<span class="w"> </span>    wordsep_re = re.compile(
<span class="gd">-        &#39;(\\s+|(?&lt;=[\\w\\!\\&quot;\\\&#39;\\&amp;\\.\\,\\?])-{2,}(?=\\w))&#39;)</span>
<span class="gi">+        r&#39;(\s+|&#39;                                  # any whitespace</span>
<span class="gi">+        r&#39;(?&lt;=[\w\!\&quot;\&#39;\&amp;\.\,\?])-{2,}(?=\w))&#39;,   # em-dash</span>
<span class="gi">+    )</span>


<span class="gd">-def wraptext(text: str, width: int=70, initial_indent: str=&#39;&#39;,</span>
<span class="gd">-    subsequent_indent: str=&#39;&#39;) -&gt;list[str]:</span>
<span class="gi">+def wraptext(text: str, width: int = 70, initial_indent: str = &#39;&#39;, subsequent_indent: str = &#39;&#39;) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Simple wrapper around the ``textwrap.wrap`` function in the standard
<span class="w"> </span>    library. This version does not wrap lines on hyphens in words.

<span class="gu">@@ -124,28 +217,45 @@ def wraptext(text: str, width: int=70, initial_indent: str=&#39;&#39;,</span>
<span class="w"> </span>    :param subsequent_indent: string that will be prepended to all lines save
<span class="w"> </span>                              the first of wrapped output
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    wrapper = TextWrapper(width=width, initial_indent=initial_indent,</span>
<span class="gi">+                          subsequent_indent=subsequent_indent,</span>
<span class="gi">+                          break_long_words=False)</span>
<span class="gi">+    return wrapper.wrap(text)</span>


<span class="gi">+# TODO (Babel 3.x): Remove this re-export</span>
<span class="w"> </span>odict = collections.OrderedDict


<span class="w"> </span>class FixedOffsetTimezone(datetime.tzinfo):
<span class="w"> </span>    &quot;&quot;&quot;Fixed offset in minutes east from UTC.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, offset: float, name: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, offset: float, name: str | None = None) -&gt; None:</span>
<span class="gi">+</span>
<span class="w"> </span>        self._offset = datetime.timedelta(minutes=offset)
<span class="w"> </span>        if name is None:
<span class="w"> </span>            name = &#39;Etc/GMT%+d&#39; % offset
<span class="w"> </span>        self.zone = name

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.zone

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;&lt;FixedOffset &quot;{self.zone}&quot; {self._offset}&gt;&#39;

<span class="gi">+    def utcoffset(self, dt: datetime.datetime) -&gt; datetime.timedelta:</span>
<span class="gi">+        return self._offset</span>

<span class="gi">+    def tzname(self, dt: datetime.datetime) -&gt; str:</span>
<span class="gi">+        return self.zone</span>
<span class="gi">+</span>
<span class="gi">+    def dst(self, dt: datetime.datetime) -&gt; datetime.timedelta:</span>
<span class="gi">+        return ZERO</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Export the localtime functionality here because that&#39;s</span>
<span class="gi">+# where it was in the past.</span>
<span class="gi">+# TODO(3.0): remove these aliases</span>
<span class="w"> </span>UTC = dates.UTC
<span class="w"> </span>LOCALTZ = dates.LOCALTZ
<span class="w"> </span>get_localzone = localtime.get_localzone
<span class="gu">@@ -153,3 +263,7 @@ STDOFFSET = localtime.STDOFFSET</span>
<span class="w"> </span>DSTOFFSET = localtime.DSTOFFSET
<span class="w"> </span>DSTDIFF = localtime.DSTDIFF
<span class="w"> </span>ZERO = localtime.ZERO
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _cmp(a: Any, b: Any):</span>
<span class="gi">+    return (a &gt; b) - (a &lt; b)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>