
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference python progressbar - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-python-progressbar" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference python progressbar
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-python-progressbar"><strong>Reference (Gold)</strong>: python-progressbar</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">385</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">385</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">385</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/progressbar/__about__.py b/progressbar/__about__.py</span>
<span class="gh">index c945e66..914b679 100644</span>
<span class="gd">--- a/progressbar/__about__.py</span>
<span class="gi">+++ b/progressbar/__about__.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;Text progress bar library for Python.</span>
<span class="gi">+&#39;&#39;&#39;Text progress bar library for Python.</span>

<span class="w"> </span>A text progress bar is typically used to display the progress of a long
<span class="w"> </span>running operation, providing a visual cue that processing is underway.
<span class="gu">@@ -9,16 +9,17 @@ differently depending on the state of the progress bar.</span>

<span class="w"> </span>The progressbar module is very easy to use, yet very powerful. It will also
<span class="w"> </span>automatically enable features like auto-resizing when the system supports it.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>__title__ = &#39;Python Progressbar&#39;
<span class="w"> </span>__package_name__ = &#39;progressbar2&#39;
<span class="w"> </span>__author__ = &#39;Rick van Hattem (Wolph)&#39;
<span class="w"> </span>__description__ = &#39; &#39;.join(
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>A Python Progressbar library to provide visual (yet text based) progress to
<span class="w"> </span>long running operations.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .strip().split())</span>
<span class="gi">+&#39;&#39;&#39;.strip().split(),</span>
<span class="gi">+)</span>
<span class="w"> </span>__email__ = &#39;wolph@wol.ph&#39;
<span class="w"> </span>__version__ = &#39;4.4.2&#39;
<span class="w"> </span>__license__ = &#39;BSD&#39;
<span class="gh">diff --git a/progressbar/algorithms.py b/progressbar/algorithms.py</span>
<span class="gh">index 3698a37..bb8586e 100644</span>
<span class="gd">--- a/progressbar/algorithms.py</span>
<span class="gi">+++ b/progressbar/algorithms.py</span>
<span class="gu">@@ -1,42 +1,51 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>from datetime import timedelta


<span class="w"> </span>class SmoothingAlgorithm(abc.ABC):
<span class="gd">-</span>
<span class="w"> </span>    @abc.abstractmethod
<span class="w"> </span>    def __init__(self, **kwargs):
<span class="w"> </span>        raise NotImplementedError

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def update(self, new_value: float, elapsed: timedelta) -&gt;float:</span>
<span class="gd">-        &quot;&quot;&quot;Updates the algorithm with a new value and returns the smoothed</span>
<span class="gi">+    def update(self, new_value: float, elapsed: timedelta) -&gt; float:</span>
<span class="gi">+        &#39;&#39;&#39;Updates the algorithm with a new value and returns the smoothed</span>
<span class="w"> </span>        value.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class ExponentialMovingAverage(SmoothingAlgorithm):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    The Exponential Moving Average (EMA) is an exponentially weighted moving
<span class="w"> </span>    average that reduces the lag that&#39;s typically associated with a simple
<span class="w"> </span>    moving average. It&#39;s more responsive to recent changes in data.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, alpha: float=0.5) -&gt;None:</span>
<span class="gi">+    def __init__(self, alpha: float = 0.5) -&gt; None:</span>
<span class="w"> </span>        self.alpha = alpha
<span class="w"> </span>        self.value = 0

<span class="gi">+    def update(self, new_value: float, elapsed: timedelta) -&gt; float:</span>
<span class="gi">+        self.value = self.alpha * new_value + (1 - self.alpha) * self.value</span>
<span class="gi">+        return self.value</span>
<span class="gi">+</span>

<span class="w"> </span>class DoubleExponentialMovingAverage(SmoothingAlgorithm):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    The Double Exponential Moving Average (DEMA) is essentially an EMA of an
<span class="w"> </span>    EMA, which reduces the lag that&#39;s typically associated with a simple EMA.
<span class="w"> </span>    It&#39;s more responsive to recent changes in data.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, alpha: float=0.5) -&gt;None:</span>
<span class="gi">+    def __init__(self, alpha: float = 0.5) -&gt; None:</span>
<span class="w"> </span>        self.alpha = alpha
<span class="w"> </span>        self.ema1 = 0
<span class="w"> </span>        self.ema2 = 0
<span class="gi">+</span>
<span class="gi">+    def update(self, new_value: float, elapsed: timedelta) -&gt; float:</span>
<span class="gi">+        self.ema1 = self.alpha * new_value + (1 - self.alpha) * self.ema1</span>
<span class="gi">+        self.ema2 = self.alpha * self.ema1 + (1 - self.alpha) * self.ema2</span>
<span class="gi">+        return 2 * self.ema1 - self.ema2</span>
<span class="gh">diff --git a/progressbar/bar.py b/progressbar/bar.py</span>
<span class="gh">index d3c579a..7a048bf 100644</span>
<span class="gd">--- a/progressbar/bar.py</span>
<span class="gi">+++ b/progressbar/bar.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import contextlib
<span class="w"> </span>import itertools
<span class="gu">@@ -11,14 +12,27 @@ import timeit</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from datetime import datetime
<span class="gi">+</span>
<span class="w"> </span>from python_utils import converters, types
<span class="gi">+</span>
<span class="w"> </span>import progressbar.env
<span class="w"> </span>import progressbar.terminal
<span class="w"> </span>import progressbar.terminal.stream
<span class="gd">-from . import base, utils, widgets, widgets as widgets_module</span>
<span class="gi">+</span>
<span class="gi">+from . import (</span>
<span class="gi">+    base,</span>
<span class="gi">+    utils,</span>
<span class="gi">+    widgets,</span>
<span class="gi">+    widgets as widgets_module,  # Avoid name collision</span>
<span class="gi">+)</span>
<span class="w"> </span>from .terminal import os_specific
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+# float also accepts integers and longs but we don&#39;t want an explicit union</span>
<span class="gi">+# due to type checking complexity</span>
<span class="w"> </span>NumberT = float
<span class="gi">+</span>
<span class="w"> </span>T = types.TypeVar(&#39;T&#39;)


<span class="gu">@@ -26,35 +40,97 @@ class ProgressBarMixinBase(abc.ABC):</span>
<span class="w"> </span>    _started = False
<span class="w"> </span>    _finished = False
<span class="w"> </span>    _last_update_time: types.Optional[float] = None
<span class="gi">+</span>
<span class="gi">+    #: The terminal width. This should be automatically detected but will</span>
<span class="gi">+    #: fall back to 80 if auto detection is not possible.</span>
<span class="w"> </span>    term_width: int = 80
<span class="gi">+    #: The widgets to render, defaults to the result of `default_widget()`</span>
<span class="w"> </span>    widgets: types.MutableSequence[widgets_module.WidgetBase | str]
<span class="gi">+    #: When going beyond the max_value, raise an error if True or silently</span>
<span class="gi">+    #: ignore otherwise</span>
<span class="w"> </span>    max_error: bool
<span class="gi">+    #: Prefix the progressbar with the given string</span>
<span class="w"> </span>    prefix: types.Optional[str]
<span class="gi">+    #: Suffix the progressbar with the given string</span>
<span class="w"> </span>    suffix: types.Optional[str]
<span class="gi">+    #: Justify to the left if `True` or the right if `False`</span>
<span class="w"> </span>    left_justify: bool
<span class="gi">+    #: The default keyword arguments for the `default_widgets` if no widgets</span>
<span class="gi">+    #: are configured</span>
<span class="w"> </span>    widget_kwargs: types.Dict[str, types.Any]
<span class="gi">+    #: Custom length function for multibyte characters such as CJK</span>
<span class="gi">+    # mypy and pyright can&#39;t agree on what the correct one is... so we&#39;ll</span>
<span class="gi">+    # need to use a helper function :(</span>
<span class="gi">+    # custom_len: types.Callable[[&#39;ProgressBarMixinBase&#39;, str], int]</span>
<span class="w"> </span>    custom_len: types.Callable[[str], int]
<span class="gi">+    #: The time the progress bar was started</span>
<span class="w"> </span>    initial_start_time: types.Optional[datetime]
<span class="gi">+    #: The interval to poll for updates in seconds if there are updates</span>
<span class="w"> </span>    poll_interval: types.Optional[float]
<span class="gi">+    #: The minimum interval to poll for updates in seconds even if there are</span>
<span class="gi">+    #: no updates</span>
<span class="w"> </span>    min_poll_interval: float
<span class="gi">+</span>
<span class="gi">+    #: Deprecated: The number of intervals that can fit on the screen with a</span>
<span class="gi">+    #: minimum of 100</span>
<span class="w"> </span>    num_intervals: int = 0
<span class="gi">+    #: Deprecated: The `next_update` is kept for compatibility with external</span>
<span class="gi">+    #: libs: https://github.com/WoLpH/python-progressbar/issues/207</span>
<span class="w"> </span>    next_update: int = 0
<span class="gi">+</span>
<span class="gi">+    #: Current progress (min_value &lt;= value &lt;= max_value)</span>
<span class="w"> </span>    value: NumberT
<span class="gi">+    #: Previous progress value</span>
<span class="w"> </span>    previous_value: types.Optional[NumberT]
<span class="gi">+    #: The minimum/start value for the progress bar</span>
<span class="w"> </span>    min_value: NumberT
<span class="gi">+    #: Maximum (and final) value. Beyond this value an error will be raised</span>
<span class="gi">+    #: unless the `max_error` parameter is `False`.</span>
<span class="w"> </span>    max_value: NumberT | types.Type[base.UnknownLength]
<span class="gi">+    #: The time the progressbar reached `max_value` or when `finish()` was</span>
<span class="gi">+    #: called.</span>
<span class="w"> </span>    end_time: types.Optional[datetime]
<span class="gi">+    #: The time `start()` was called or iteration started.</span>
<span class="w"> </span>    start_time: types.Optional[datetime]
<span class="gi">+    #: Seconds between `start_time` and last call to `update()`</span>
<span class="w"> </span>    seconds_elapsed: float
<span class="gi">+</span>
<span class="gi">+    #: Extra data for widgets with persistent state. This is used by</span>
<span class="gi">+    #: sampling widgets for example. Since widgets can be shared between</span>
<span class="gi">+    #: multiple progressbars we need to store the state with the progressbar.</span>
<span class="w"> </span>    extra: types.Dict[str, types.Any]
<span class="gi">+</span>
<span class="gi">+    def get_last_update_time(self) -&gt; types.Optional[datetime]:</span>
<span class="gi">+        if self._last_update_time:</span>
<span class="gi">+            return datetime.fromtimestamp(self._last_update_time)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def set_last_update_time(self, value: types.Optional[datetime]):</span>
<span class="gi">+        if value:</span>
<span class="gi">+            self._last_update_time = time.mktime(value.timetuple())</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._last_update_time = None</span>
<span class="gi">+</span>
<span class="w"> </span>    last_update_time = property(get_last_update_time, set_last_update_time)

<span class="gd">-    def __init__(self, **kwargs):</span>
<span class="gi">+    def __init__(self, **kwargs):  # noqa: B027</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def start(self, **kwargs):</span>
<span class="gi">+        self._started = True</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, value=None):  # noqa: B027</span>
<span class="w"> </span>        pass

<span class="gi">+    def finish(self):  # pragma: no cover</span>
<span class="gi">+        self._finished = True</span>
<span class="gi">+</span>
<span class="w"> </span>    def __del__(self):
<span class="gd">-        if not self._finished and self._started:</span>
<span class="gd">-            try:</span>
<span class="gi">+        if not self._finished and self._started:  # pragma: no cover</span>
<span class="gi">+            # We&#39;re not using contextlib.suppress here because during teardown</span>
<span class="gi">+            # contextlib is not available anymore.</span>
<span class="gi">+            try:  # noqa: SIM105</span>
<span class="w"> </span>                self.finish()
<span class="w"> </span>            except AttributeError:
<span class="w"> </span>                pass
<span class="gu">@@ -62,6 +138,15 @@ class ProgressBarMixinBase(abc.ABC):</span>
<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        return self.__dict__

<span class="gi">+    def data(self) -&gt; types.Dict[str, types.Any]:  # pragma: no cover</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def started(self) -&gt; bool:</span>
<span class="gi">+        return self._finished or self._started</span>
<span class="gi">+</span>
<span class="gi">+    def finished(self) -&gt; bool:</span>
<span class="gi">+        return self._finished</span>
<span class="gi">+</span>

<span class="w"> </span>class ProgressBarBase(types.Iterable, ProgressBarMixinBase):
<span class="w"> </span>    _index_counter = itertools.count()
<span class="gu">@@ -78,31 +163,80 @@ class ProgressBarBase(types.Iterable, ProgressBarMixinBase):</span>


<span class="w"> </span>class DefaultFdMixin(ProgressBarMixinBase):
<span class="gi">+    # The file descriptor to write to. Defaults to `sys.stderr`</span>
<span class="w"> </span>    fd: base.TextIO = sys.stderr
<span class="gi">+    #: Set the terminal to be ANSI compatible. If a terminal is ANSI</span>
<span class="gi">+    #: compatible we will automatically enable `colors` and disable</span>
<span class="gi">+    #: `line_breaks`.</span>
<span class="w"> </span>    is_ansi_terminal: bool | None = False
<span class="gi">+    #: Whether the file descriptor is a terminal or not. This is used to</span>
<span class="gi">+    #: determine whether to use ANSI escape codes or not.</span>
<span class="w"> </span>    is_terminal: bool | None
<span class="gi">+    #: Whether to print line breaks. This is useful for logging the</span>
<span class="gi">+    #: progressbar. When disabled the current line is overwritten.</span>
<span class="w"> </span>    line_breaks: bool | None = True
<span class="gi">+    #: Specify the type and number of colors to support. Defaults to auto</span>
<span class="gi">+    #: detection based on the file descriptor type (i.e. interactive terminal)</span>
<span class="gi">+    #: environment variables such as `COLORTERM` and `TERM`. Color output can</span>
<span class="gi">+    #: be forced in non-interactive terminals using the</span>
<span class="gi">+    #: `PROGRESSBAR_ENABLE_COLORS` environment variable which can also be used</span>
<span class="gi">+    #: to force a specific number of colors by specifying `24bit`, `256` or</span>
<span class="gi">+    #: `16`.</span>
<span class="gi">+    #: For true (24 bit/16M) color support you can use `COLORTERM=truecolor`.</span>
<span class="gi">+    #: For 256 color support you can use `TERM=xterm-256color`.</span>
<span class="gi">+    #: For 16 colorsupport you can use `TERM=xterm`.</span>
<span class="w"> </span>    enable_colors: progressbar.env.ColorSupport = progressbar.env.COLOR_SUPPORT

<span class="gd">-    def __init__(self, fd: base.TextIO=sys.stderr, is_terminal: (bool |</span>
<span class="gd">-        None)=None, line_breaks: (bool | None)=None, enable_colors: (</span>
<span class="gd">-        progressbar.env.ColorSupport | None)=None, line_offset: int=0, **kwargs</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            fd: base.TextIO = sys.stderr,</span>
<span class="gi">+            is_terminal: bool | None = None,</span>
<span class="gi">+            line_breaks: bool | None = None,</span>
<span class="gi">+            enable_colors: progressbar.env.ColorSupport | None = None,</span>
<span class="gi">+            line_offset: int = 0,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if fd is sys.stdout:
<span class="w"> </span>            fd = utils.streams.original_stdout
<span class="w"> </span>        elif fd is sys.stderr:
<span class="w"> </span>            fd = utils.streams.original_stderr
<span class="gi">+</span>
<span class="w"> </span>        fd = self._apply_line_offset(fd, line_offset)
<span class="w"> </span>        self.fd = fd
<span class="w"> </span>        self.is_ansi_terminal = progressbar.env.is_ansi_terminal(fd)
<span class="w"> </span>        self.is_terminal = progressbar.env.is_terminal(fd, is_terminal)
<span class="w"> </span>        self.line_breaks = self._determine_line_breaks(line_breaks)
<span class="w"> </span>        self.enable_colors = self._determine_enable_colors(enable_colors)
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gd">-    def _determine_enable_colors(self, enable_colors: (progressbar.env.</span>
<span class="gd">-        ColorSupport | None)) -&gt;progressbar.env.ColorSupport:</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+    def _apply_line_offset(</span>
<span class="gi">+            self,</span>
<span class="gi">+            fd: base.TextIO,</span>
<span class="gi">+            line_offset: int,</span>
<span class="gi">+    ) -&gt; base.TextIO:</span>
<span class="gi">+        if line_offset:</span>
<span class="gi">+            return progressbar.terminal.stream.LineOffsetStreamWrapper(</span>
<span class="gi">+                line_offset,</span>
<span class="gi">+                fd,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return fd</span>
<span class="gi">+</span>
<span class="gi">+    def _determine_line_breaks(self, line_breaks: bool | None) -&gt; bool | None:</span>
<span class="gi">+        if line_breaks is None:</span>
<span class="gi">+            return progressbar.env.env_flag(</span>
<span class="gi">+                &#39;PROGRESSBAR_LINE_BREAKS&#39;,</span>
<span class="gi">+                not self.is_terminal,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return line_breaks</span>
<span class="gi">+</span>
<span class="gi">+    def _determine_enable_colors(</span>
<span class="gi">+            self,</span>
<span class="gi">+            enable_colors: progressbar.env.ColorSupport | None,</span>
<span class="gi">+    ) -&gt; progressbar.env.ColorSupport:</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Determines the color support for the progress bar.

<span class="w"> </span>        This method checks the `enable_colors` parameter and the environment
<span class="gu">@@ -128,32 +262,160 @@ class DefaultFdMixin(ProgressBarMixinBase):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            ValueError: If `enable_colors` is not None, True, False, or an
<span class="w"> </span>            instance of `progressbar.env.ColorSupport`.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        color_support: progressbar.env.ColorSupport</span>
<span class="gi">+        if enable_colors is None:</span>
<span class="gi">+            colors = (</span>
<span class="gi">+                progressbar.env.env_flag(&#39;PROGRESSBAR_ENABLE_COLORS&#39;),</span>
<span class="gi">+                progressbar.env.env_flag(&#39;FORCE_COLOR&#39;),</span>
<span class="gi">+                self.is_ansi_terminal,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            for color_enabled in colors:</span>
<span class="gi">+                if color_enabled is not None:</span>
<span class="gi">+                    if color_enabled:</span>
<span class="gi">+                        color_support = progressbar.env.COLOR_SUPPORT</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        color_support = progressbar.env.ColorSupport.NONE</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                color_support = progressbar.env.ColorSupport.NONE</span>
<span class="gi">+</span>
<span class="gi">+        elif enable_colors is True:</span>
<span class="gi">+            color_support = progressbar.env.ColorSupport.XTERM_256</span>
<span class="gi">+        elif enable_colors is False:</span>
<span class="gi">+            color_support = progressbar.env.ColorSupport.NONE</span>
<span class="gi">+        elif isinstance(enable_colors, progressbar.env.ColorSupport):</span>
<span class="gi">+            color_support = enable_colors</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&#39;Invalid color support value: {enable_colors}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return color_support</span>
<span class="gi">+</span>
<span class="gi">+    def print(self, *args: types.Any, **kwargs: types.Any) -&gt; None:</span>
<span class="gi">+        print(*args, file=self.fd, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def start(self, **kwargs):</span>
<span class="gi">+        os_specific.set_console_mode()</span>
<span class="gi">+        super().start()</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, *args: types.Any, **kwargs: types.Any) -&gt; None:</span>
<span class="gi">+        ProgressBarMixinBase.update(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        line: str = converters.to_unicode(self._format_line())</span>
<span class="gi">+        if not self.enable_colors:</span>
<span class="gi">+            line = utils.no_color(line)</span>
<span class="gi">+</span>
<span class="gi">+        line = line.rstrip() + &#39;\n&#39; if self.line_breaks else &#39;\r&#39; + line</span>
<span class="gi">+</span>
<span class="gi">+        try:  # pragma: no cover</span>
<span class="gi">+            self.fd.write(line)</span>
<span class="gi">+        except UnicodeEncodeError:  # pragma: no cover</span>
<span class="gi">+            self.fd.write(types.cast(str, line.encode(&#39;ascii&#39;, &#39;replace&#39;)))</span>
<span class="gi">+</span>
<span class="gi">+    def finish(</span>
<span class="gi">+            self,</span>
<span class="gi">+            *args: types.Any,</span>
<span class="gi">+            **kwargs: types.Any,</span>
<span class="gi">+    ) -&gt; None:  # pragma: no cover</span>
<span class="gi">+        os_specific.reset_console_mode()</span>
<span class="gi">+</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        end = kwargs.pop(&#39;end&#39;, &#39;\n&#39;)</span>
<span class="gi">+        ProgressBarMixinBase.finish(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if end and not self.line_breaks:</span>
<span class="gi">+            self.fd.write(end)</span>
<span class="gi">+</span>
<span class="gi">+        self.fd.flush()</span>

<span class="w"> </span>    def _format_line(self):
<span class="gd">-        &quot;&quot;&quot;Joins the widgets and justifies the line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;Joins the widgets and justifies the line.&#39;</span>
<span class="gi">+        widgets = &#39;&#39;.join(self._to_unicode(self._format_widgets()))</span>

<span class="gi">+        if self.left_justify:</span>
<span class="gi">+            return widgets.ljust(self.term_width)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return widgets.rjust(self.term_width)</span>
<span class="gi">+</span>
<span class="gi">+    def _format_widgets(self):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        expanding = []</span>
<span class="gi">+        width = self.term_width</span>
<span class="gi">+        data = self.data()</span>
<span class="gi">+</span>
<span class="gi">+        for index, widget in enumerate(self.widgets):</span>
<span class="gi">+            if isinstance(</span>
<span class="gi">+                    widget,</span>
<span class="gi">+                    widgets.WidgetBase,</span>
<span class="gi">+            ) and not widget.check_size(self):</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif isinstance(widget, widgets.AutoWidthWidgetBase):</span>
<span class="gi">+                result.append(widget)</span>
<span class="gi">+                expanding.insert(0, index)</span>
<span class="gi">+            elif isinstance(widget, str):</span>
<span class="gi">+                result.append(widget)</span>
<span class="gi">+                width -= self.custom_len(widget)  # type: ignore</span>
<span class="gi">+            else:</span>
<span class="gi">+                widget_output = converters.to_unicode(widget(self, data))</span>
<span class="gi">+                result.append(widget_output)</span>
<span class="gi">+                width -= self.custom_len(widget_output)  # type: ignore</span>

<span class="gd">-class ResizableMixin(ProgressBarMixinBase):</span>
<span class="gi">+        count = len(expanding)</span>
<span class="gi">+        while expanding:</span>
<span class="gi">+            portion = max(int(math.ceil(width * 1.0 / count)), 0)</span>
<span class="gi">+            index = expanding.pop()</span>
<span class="gi">+            widget = result[index]</span>
<span class="gi">+            count -= 1</span>
<span class="gi">+</span>
<span class="gi">+            widget_output = widget(self, data, portion)</span>
<span class="gi">+            width -= self.custom_len(widget_output)  # type: ignore</span>
<span class="gi">+            result[index] = widget_output</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="gd">-    def __init__(self, term_width: (int | None)=None, **kwargs):</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _to_unicode(cls, args):</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            yield converters.to_unicode(arg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ResizableMixin(ProgressBarMixinBase):</span>
<span class="gi">+    def __init__(self, term_width: int | None = None, **kwargs):</span>
<span class="w"> </span>        ProgressBarMixinBase.__init__(self, **kwargs)
<span class="gi">+</span>
<span class="w"> </span>        self.signal_set = False
<span class="w"> </span>        if term_width:
<span class="w"> </span>            self.term_width = term_width
<span class="gd">-        else:</span>
<span class="gi">+        else:  # pragma: no cover</span>
<span class="w"> </span>            with contextlib.suppress(Exception):
<span class="w"> </span>                self._handle_resize()
<span class="w"> </span>                import signal
<span class="gd">-                self._prev_handle = signal.getsignal(signal.SIGWINCH)</span>
<span class="gd">-                signal.signal(signal.SIGWINCH, self._handle_resize)</span>
<span class="gi">+</span>
<span class="gi">+                self._prev_handle = signal.getsignal(</span>
<span class="gi">+                    signal.SIGWINCH  # type: ignore</span>
<span class="gi">+                )</span>
<span class="gi">+                signal.signal(</span>
<span class="gi">+                    signal.SIGWINCH, self._handle_resize  # type: ignore</span>
<span class="gi">+                )</span>
<span class="w"> </span>                self.signal_set = True

<span class="w"> </span>    def _handle_resize(self, signum=None, frame=None):
<span class="gd">-        &quot;&quot;&quot;Tries to catch resize signals sent from the terminal.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;Tries to catch resize signals sent from the terminal.&#39;</span>
<span class="gi">+        w, h = utils.get_terminal_size()</span>
<span class="gi">+        self.term_width = w</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self):  # pragma: no cover</span>
<span class="gi">+        ProgressBarMixinBase.finish(self)</span>
<span class="gi">+        if self.signal_set:</span>
<span class="gi">+            with contextlib.suppress(Exception):</span>
<span class="gi">+                import signal</span>
<span class="gi">+</span>
<span class="gi">+                signal.signal(</span>
<span class="gi">+                    signal.SIGWINCH, self._prev_handle  # type: ignore</span>
<span class="gi">+                )</span>


<span class="w"> </span>class StdRedirectMixin(DefaultFdMixin):
<span class="gu">@@ -164,17 +426,57 @@ class StdRedirectMixin(DefaultFdMixin):</span>
<span class="w"> </span>    _stdout: base.IO
<span class="w"> </span>    _stderr: base.IO

<span class="gd">-    def __init__(self, redirect_stderr: bool=False, redirect_stdout: bool=</span>
<span class="gd">-        False, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            redirect_stderr: bool = False,</span>
<span class="gi">+            redirect_stdout: bool = False,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        DefaultFdMixin.__init__(self, **kwargs)
<span class="w"> </span>        self.redirect_stderr = redirect_stderr
<span class="w"> </span>        self.redirect_stdout = redirect_stdout
<span class="w"> </span>        self._stdout = self.stdout = sys.stdout
<span class="w"> </span>        self._stderr = self.stderr = sys.stderr

<span class="gi">+    def start(self, *args, **kwargs):</span>
<span class="gi">+        if self.redirect_stdout:</span>
<span class="gi">+            utils.streams.wrap_stdout()</span>

<span class="gd">-class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>
<span class="gd">-    &quot;&quot;&quot;The ProgressBar class which updates and prints the bar.</span>
<span class="gi">+        if self.redirect_stderr:</span>
<span class="gi">+            utils.streams.wrap_stderr()</span>
<span class="gi">+</span>
<span class="gi">+        self._stdout = utils.streams.original_stdout</span>
<span class="gi">+        self._stderr = utils.streams.original_stderr</span>
<span class="gi">+</span>
<span class="gi">+        self.stdout = utils.streams.stdout</span>
<span class="gi">+        self.stderr = utils.streams.stderr</span>
<span class="gi">+</span>
<span class="gi">+        utils.streams.start_capturing(self)</span>
<span class="gi">+        DefaultFdMixin.start(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, value: types.Optional[float] = None):</span>
<span class="gi">+        if not self.line_breaks and utils.streams.needs_clear():</span>
<span class="gi">+            self.fd.write(&#39;\r&#39; + &#39; &#39; * self.term_width + &#39;\r&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        utils.streams.flush()</span>
<span class="gi">+        DefaultFdMixin.update(self, value=value)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self, end=&#39;\n&#39;):</span>
<span class="gi">+        DefaultFdMixin.finish(self, end=end)</span>
<span class="gi">+        utils.streams.stop_capturing(self)</span>
<span class="gi">+        if self.redirect_stdout:</span>
<span class="gi">+            utils.streams.unwrap_stdout()</span>
<span class="gi">+</span>
<span class="gi">+        if self.redirect_stderr:</span>
<span class="gi">+            utils.streams.unwrap_stderr()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ProgressBar(</span>
<span class="gi">+    StdRedirectMixin,</span>
<span class="gi">+    ResizableMixin,</span>
<span class="gi">+    ProgressBarBase,</span>
<span class="gi">+):</span>
<span class="gi">+    &#39;&#39;&#39;The ProgressBar class which updates and prints the bar.</span>

<span class="w"> </span>    Args:
<span class="w"> </span>        min_value (int): The minimum/start value for the progress bar
<span class="gu">@@ -245,79 +547,144 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>
<span class="w"> </span>    the current progress bar. As a result, you have access to the
<span class="w"> </span>    ProgressBar&#39;s methods and attributes. Although there is nothing preventing
<span class="w"> </span>    you from changing the ProgressBar you should treat it as read only.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    _iterable: types.Optional[types.Iterator]
<span class="gi">+</span>
<span class="w"> </span>    _DEFAULT_MAXVAL: type[base.UnknownLength] = base.UnknownLength
<span class="gd">-    _MINIMUM_UPDATE_INTERVAL: float = 0.05</span>
<span class="gi">+    # update every 50 milliseconds (up to a 20 times per second)</span>
<span class="gi">+    _MINIMUM_UPDATE_INTERVAL: float = 0.050</span>
<span class="w"> </span>    _last_update_time: types.Optional[float] = None
<span class="w"> </span>    paused: bool = False

<span class="gd">-    def __init__(self, min_value: NumberT=0, max_value: (NumberT | types.</span>
<span class="gd">-        Type[base.UnknownLength] | None)=None, widgets: types.Optional[</span>
<span class="gd">-        types.Sequence[widgets_module.WidgetBase | str]]=None, left_justify:</span>
<span class="gd">-        bool=True, initial_value: NumberT=0, poll_interval: types.Optional[</span>
<span class="gd">-        float]=None, widget_kwargs: types.Optional[types.Dict[str, types.</span>
<span class="gd">-        Any]]=None, custom_len: types.Callable[[str], int]=utils.len_color,</span>
<span class="gd">-        max_error=True, prefix=None, suffix=None, variables=None,</span>
<span class="gd">-        min_poll_interval=None, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Initializes a progress bar with sane defaults.&quot;&quot;&quot;</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            min_value: NumberT = 0,</span>
<span class="gi">+            max_value: NumberT | types.Type[base.UnknownLength] | None = None,</span>
<span class="gi">+            widgets: types.Optional[</span>
<span class="gi">+                types.Sequence[widgets_module.WidgetBase | str]</span>
<span class="gi">+            ] = None,</span>
<span class="gi">+            left_justify: bool = True,</span>
<span class="gi">+            initial_value: NumberT = 0,</span>
<span class="gi">+            poll_interval: types.Optional[float] = None,</span>
<span class="gi">+            widget_kwargs: types.Optional[types.Dict[str, types.Any]] = None,</span>
<span class="gi">+            custom_len: types.Callable[[str], int] = utils.len_color,</span>
<span class="gi">+            max_error=True,</span>
<span class="gi">+            prefix=None,</span>
<span class="gi">+            suffix=None,</span>
<span class="gi">+            variables=None,</span>
<span class="gi">+            min_poll_interval=None,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+    ):  # sourcery skip: low-code-quality</span>
<span class="gi">+        &#39;&#39;&#39;Initializes a progress bar with sane defaults.&#39;&#39;&#39;</span>
<span class="w"> </span>        StdRedirectMixin.__init__(self, **kwargs)
<span class="w"> </span>        ResizableMixin.__init__(self, **kwargs)
<span class="w"> </span>        ProgressBarBase.__init__(self, **kwargs)
<span class="w"> </span>        if not max_value and kwargs.get(&#39;maxval&#39;) is not None:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &#39;The usage of `maxval` is deprecated, please use `max_value` instead&#39;</span>
<span class="gd">-                , DeprecationWarning, stacklevel=1)</span>
<span class="gi">+                &#39;The usage of `maxval` is deprecated, please use &#39;</span>
<span class="gi">+                &#39;`max_value` instead&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=1,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            max_value = kwargs.get(&#39;maxval&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if not poll_interval and kwargs.get(&#39;poll&#39;):
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &#39;The usage of `poll` is deprecated, please use `poll_interval` instead&#39;</span>
<span class="gd">-                , DeprecationWarning, stacklevel=1)</span>
<span class="gi">+                &#39;The usage of `poll` is deprecated, please use &#39;</span>
<span class="gi">+                &#39;`poll_interval` instead&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=1,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            poll_interval = kwargs.get(&#39;poll&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if max_value and min_value &gt; types.cast(NumberT, max_value):
<span class="gd">-            raise ValueError(&#39;Max value needs to be bigger than the min value&#39;)</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &#39;Max value needs to be bigger than the min value&#39;,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self.min_value = min_value
<span class="gd">-        self.max_value = max_value</span>
<span class="gi">+        # Legacy issue, `max_value` can be `None` before execution. After</span>
<span class="gi">+        # that it either has a value or is `UnknownLength`</span>
<span class="gi">+        self.max_value = max_value  # type: ignore</span>
<span class="w"> </span>        self.max_error = max_error
<span class="gi">+</span>
<span class="gi">+        # Only copy the widget if it&#39;s safe to copy. Most widgets are so we</span>
<span class="gi">+        # assume this to be true</span>
<span class="w"> </span>        self.widgets = []
<span class="gd">-        for widget in (widgets or []):</span>
<span class="gi">+        for widget in widgets or []:</span>
<span class="w"> </span>            if getattr(widget, &#39;copy&#39;, True):
<span class="w"> </span>                widget = deepcopy(widget)
<span class="w"> </span>            self.widgets.append(widget)
<span class="gi">+</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.suffix = suffix
<span class="w"> </span>        self.widget_kwargs = widget_kwargs or {}
<span class="w"> </span>        self.left_justify = left_justify
<span class="w"> </span>        self.value = initial_value
<span class="w"> </span>        self._iterable = None
<span class="gd">-        self.custom_len = custom_len</span>
<span class="gi">+        self.custom_len = custom_len  # type: ignore</span>
<span class="w"> </span>        self.initial_start_time = kwargs.get(&#39;start_time&#39;)
<span class="w"> </span>        self.init()
<span class="gi">+</span>
<span class="gi">+        # Convert a given timedelta to a floating point number as internal</span>
<span class="gi">+        # interval. We&#39;re not using timedelta&#39;s internally for two reasons:</span>
<span class="gi">+        # 1. Backwards compatibility (most important one)</span>
<span class="gi">+        # 2. Performance. Even though the amount of time it takes to compare a</span>
<span class="gi">+        # timedelta with a float versus a float directly is negligible, this</span>
<span class="gi">+        # comparison is run for _every_ update. With billions of updates</span>
<span class="gi">+        # (downloading a 1GiB file for example) this adds up.</span>
<span class="w"> </span>        poll_interval = utils.deltas_to_seconds(poll_interval, default=None)
<span class="gd">-        min_poll_interval = utils.deltas_to_seconds(min_poll_interval,</span>
<span class="gd">-            default=None)</span>
<span class="gd">-        self._MINIMUM_UPDATE_INTERVAL = utils.deltas_to_seconds(self.</span>
<span class="gd">-            _MINIMUM_UPDATE_INTERVAL) or self._MINIMUM_UPDATE_INTERVAL</span>
<span class="gi">+        min_poll_interval = utils.deltas_to_seconds(</span>
<span class="gi">+            min_poll_interval,</span>
<span class="gi">+            default=None,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._MINIMUM_UPDATE_INTERVAL = (</span>
<span class="gi">+                utils.deltas_to_seconds(self._MINIMUM_UPDATE_INTERVAL)</span>
<span class="gi">+                or self._MINIMUM_UPDATE_INTERVAL</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Note that the _MINIMUM_UPDATE_INTERVAL sets the minimum in case of</span>
<span class="gi">+        # low values.</span>
<span class="w"> </span>        self.poll_interval = poll_interval
<span class="gd">-        self.min_poll_interval = max(min_poll_interval or self.</span>
<span class="gd">-            _MINIMUM_UPDATE_INTERVAL, self._MINIMUM_UPDATE_INTERVAL, float(</span>
<span class="gd">-            os.environ.get(&#39;PROGRESSBAR_MINIMUM_UPDATE_INTERVAL&#39;, 0)))</span>
<span class="gi">+        self.min_poll_interval = max(</span>
<span class="gi">+            min_poll_interval or self._MINIMUM_UPDATE_INTERVAL,</span>
<span class="gi">+            self._MINIMUM_UPDATE_INTERVAL,</span>
<span class="gi">+            float(os.environ.get(&#39;PROGRESSBAR_MINIMUM_UPDATE_INTERVAL&#39;, 0)),</span>
<span class="gi">+        )  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        # A dictionary of names that can be used by Variable and FormatWidget</span>
<span class="w"> </span>        self.variables = utils.AttributeDict(variables or {})
<span class="w"> </span>        for widget in self.widgets:
<span class="gd">-            if isinstance(widget, widgets_module.VariableMixin</span>
<span class="gd">-                ) and widget.name not in self.variables:</span>
<span class="gi">+            if (</span>
<span class="gi">+                    isinstance(widget, widgets_module.VariableMixin)</span>
<span class="gi">+                    and widget.name not in self.variables</span>
<span class="gi">+            ):</span>
<span class="w"> </span>                self.variables[widget.name] = None

<span class="gi">+    @property</span>
<span class="gi">+    def dynamic_messages(self):  # pragma: no cover</span>
<span class="gi">+        return self.variables</span>
<span class="gi">+</span>
<span class="gi">+    @dynamic_messages.setter</span>
<span class="gi">+    def dynamic_messages(self, value):  # pragma: no cover</span>
<span class="gi">+        self.variables = value</span>
<span class="gi">+</span>
<span class="w"> </span>    def init(self):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        (re)initialize values to original state so the progressbar can be
<span class="w"> </span>        used (again).
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        self.previous_value = None</span>
<span class="gi">+        self.last_update_time = None</span>
<span class="gi">+        self.start_time = None</span>
<span class="gi">+        self.updates = 0</span>
<span class="gi">+        self.end_time = None</span>
<span class="gi">+        self.extra = dict()</span>
<span class="gi">+        self._last_update_timer = timeit.default_timer()</span>

<span class="w"> </span>    @property
<span class="gd">-    def percentage(self) -&gt;(float | None):</span>
<span class="gd">-        &quot;&quot;&quot;Return current percentage, returns None if no max_value is given.</span>
<span class="gi">+    def percentage(self) -&gt; float | None:</span>
<span class="gi">+        &#39;&#39;&#39;Return current percentage, returns None if no max_value is given.</span>

<span class="w"> </span>        &gt;&gt;&gt; progress = ProgressBar()
<span class="w"> </span>        &gt;&gt;&gt; progress.max_value = 10
<span class="gu">@@ -346,11 +713,20 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>
<span class="w"> </span>        25.0
<span class="w"> </span>        &gt;&gt;&gt; progress.max_value = None
<span class="w"> </span>        &gt;&gt;&gt; progress.percentage
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if self.max_value is None or self.max_value is base.UnknownLength:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif self.max_value:</span>
<span class="gi">+            todo = self.value - self.min_value</span>
<span class="gi">+            total = self.max_value - self.min_value  # type: ignore</span>
<span class="gi">+            percentage = 100.0 * todo / total</span>
<span class="gi">+        else:</span>
<span class="gi">+            percentage = 100.0</span>
<span class="gi">+</span>
<span class="gi">+        return percentage</span>

<span class="gd">-    def data(self) -&gt;types.Dict[str, types.Any]:</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+    def data(self) -&gt; types.Dict[str, types.Any]:</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="w"> </span>        Returns:
<span class="w"> </span>            dict:
<span class="gu">@@ -376,18 +752,87 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>
<span class="w"> </span>                - `variables`: Dictionary of user-defined variables for the
<span class="w"> </span>                  :py:class:`~progressbar.widgets.Variable`&#39;s.

<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        self._last_update_time = time.time()</span>
<span class="gi">+        self._last_update_timer = timeit.default_timer()</span>
<span class="gi">+        elapsed = self.last_update_time - self.start_time  # type: ignore</span>
<span class="gi">+        # For Python 2.7 and higher we have _`timedelta.total_seconds`, but we</span>
<span class="gi">+        # want to support older versions as well</span>
<span class="gi">+        total_seconds_elapsed = utils.deltas_to_seconds(elapsed)</span>
<span class="gi">+        return dict(</span>
<span class="gi">+            # The maximum value (can be None with iterators)</span>
<span class="gi">+            max_value=self.max_value,</span>
<span class="gi">+            # Start time of the widget</span>
<span class="gi">+            start_time=self.start_time,</span>
<span class="gi">+            # Last update time of the widget</span>
<span class="gi">+            last_update_time=self.last_update_time,</span>
<span class="gi">+            # End time of the widget</span>
<span class="gi">+            end_time=self.end_time,</span>
<span class="gi">+            # The current value</span>
<span class="gi">+            value=self.value,</span>
<span class="gi">+            # The previous value</span>
<span class="gi">+            previous_value=self.previous_value,</span>
<span class="gi">+            # The total update count</span>
<span class="gi">+            updates=self.updates,</span>
<span class="gi">+            # The seconds since the bar started</span>
<span class="gi">+            total_seconds_elapsed=total_seconds_elapsed,</span>
<span class="gi">+            # The seconds since the bar started modulo 60</span>
<span class="gi">+            seconds_elapsed=(elapsed.seconds % 60)</span>
<span class="gi">+                            + (elapsed.microseconds / 1000000.0),</span>
<span class="gi">+            # The minutes since the bar started modulo 60</span>
<span class="gi">+            minutes_elapsed=(elapsed.seconds / 60) % 60,</span>
<span class="gi">+            # The hours since the bar started modulo 24</span>
<span class="gi">+            hours_elapsed=(elapsed.seconds / (60 * 60)) % 24,</span>
<span class="gi">+            # The hours since the bar started</span>
<span class="gi">+            days_elapsed=(elapsed.seconds / (60 * 60 * 24)),</span>
<span class="gi">+            # The raw elapsed `datetime.timedelta` object</span>
<span class="gi">+            time_elapsed=elapsed,</span>
<span class="gi">+            # Percentage as a float or `None` if no max_value is available</span>
<span class="gi">+            percentage=self.percentage,</span>
<span class="gi">+            # Dictionary of user-defined</span>
<span class="gi">+            # :py:class:`progressbar.widgets.Variable`&#39;s</span>
<span class="gi">+            variables=self.variables,</span>
<span class="gi">+            # Deprecated alias for `variables`</span>
<span class="gi">+            dynamic_messages=self.variables,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def default_widgets(self):</span>
<span class="gi">+        if self.max_value:</span>
<span class="gi">+            return [</span>
<span class="gi">+                widgets.Percentage(**self.widget_kwargs),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.SimpleProgress(</span>
<span class="gi">+                    format=f&#39;({widgets.SimpleProgress.DEFAULT_FORMAT})&#39;,</span>
<span class="gi">+                    **self.widget_kwargs,</span>
<span class="gi">+                ),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Bar(**self.widget_kwargs),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Timer(**self.widget_kwargs),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.SmoothingETA(**self.widget_kwargs),</span>
<span class="gi">+            ]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [</span>
<span class="gi">+                widgets.AnimatedMarker(**self.widget_kwargs),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.BouncingBar(**self.widget_kwargs),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Counter(**self.widget_kwargs),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Timer(**self.widget_kwargs),</span>
<span class="gi">+            ]</span>

<span class="w"> </span>    def __call__(self, iterable, max_value=None):
<span class="gd">-        &quot;&quot;&quot;Use a ProgressBar to iterate through an iterable.&quot;&quot;&quot;</span>
<span class="gi">+        &#39;Use a ProgressBar to iterate through an iterable.&#39;</span>
<span class="w"> </span>        if max_value is not None:
<span class="w"> </span>            self.max_value = max_value
<span class="w"> </span>        elif self.max_value is None:
<span class="w"> </span>            try:
<span class="w"> </span>                self.max_value = len(iterable)
<span class="gd">-            except TypeError:</span>
<span class="gi">+            except TypeError:  # pragma: no cover</span>
<span class="w"> </span>                self.max_value = base.UnknownLength
<span class="gi">+</span>
<span class="w"> </span>        self._iterable = iter(iterable)
<span class="w"> </span>        return self

<span class="gu">@@ -396,18 +841,20 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>

<span class="w"> </span>    def __next__(self):
<span class="w"> </span>        try:
<span class="gd">-            if self._iterable is None:</span>
<span class="gi">+            if self._iterable is None:  # pragma: no cover</span>
<span class="w"> </span>                value = self.value
<span class="w"> </span>            else:
<span class="w"> </span>                value = next(self._iterable)
<span class="gi">+</span>
<span class="w"> </span>            if self.start_time is None:
<span class="w"> </span>                self.start()
<span class="w"> </span>            else:
<span class="w"> </span>                self.update(self.value + 1)
<span class="gi">+</span>
<span class="w"> </span>        except StopIteration:
<span class="w"> </span>            self.finish()
<span class="w"> </span>            raise
<span class="gd">-        except GeneratorExit:</span>
<span class="gi">+        except GeneratorExit:  # pragma: no cover</span>
<span class="w"> </span>            self.finish(dirty=True)
<span class="w"> </span>            raise
<span class="w"> </span>        else:
<span class="gu">@@ -418,22 +865,103 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gi">+</span>
<span class="gi">+    # Create an alias so that Python 2.x won&#39;t complain about not being</span>
<span class="gi">+    # an iterator.</span>
<span class="w"> </span>    next = __next__

<span class="w"> </span>    def __iadd__(self, value):
<span class="gd">-        &quot;&quot;&quot;Updates the ProgressBar by adding a new value.&quot;&quot;&quot;</span>
<span class="gi">+        &#39;Updates the ProgressBar by adding a new value.&#39;</span>
<span class="w"> </span>        return self.increment(value)

<span class="gi">+    def increment(self, value=1, *args, **kwargs):</span>
<span class="gi">+        self.update(self.value + value, *args, **kwargs)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="w"> </span>    def _needs_update(self):
<span class="gd">-        &quot;&quot;&quot;Returns whether the ProgressBar should redraw the line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;Returns whether the ProgressBar should redraw the line.&#39;</span>
<span class="gi">+        if self.paused:</span>
<span class="gi">+            return False</span>
<span class="gi">+        delta = timeit.default_timer() - self._last_update_timer</span>
<span class="gi">+        if delta &lt; self.min_poll_interval:</span>
<span class="gi">+            # Prevent updating too often</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif self.poll_interval and delta &gt; self.poll_interval:</span>
<span class="gi">+            # Needs to redraw timers and animations</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        # Update if value increment is not large enough to</span>
<span class="gi">+        # add more bars to progressbar (according to current</span>
<span class="gi">+        # terminal width)</span>
<span class="gi">+        with contextlib.suppress(Exception):</span>
<span class="gi">+            divisor: float = self.max_value / self.term_width  # type: ignore</span>
<span class="gi">+            value_divisor = self.value // divisor  # type: ignore</span>
<span class="gi">+            pvalue_divisor = self.previous_value // divisor  # type: ignore</span>
<span class="gi">+            if value_divisor != pvalue_divisor:</span>
<span class="gi">+                return True</span>
<span class="gi">+        # No need to redraw yet</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def update(self, value=None, force=False, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Updates the ProgressBar to a new value.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;Updates the ProgressBar to a new value.&#39;</span>
<span class="gi">+        if self.start_time is None:</span>
<span class="gi">+            self.start()</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+                value is not None</span>
<span class="gi">+                and value is not base.UnknownLength</span>
<span class="gi">+                and isinstance(value, (int, float))</span>
<span class="gi">+        ):</span>
<span class="gi">+            if self.max_value is base.UnknownLength:</span>
<span class="gi">+                # Can&#39;t compare against unknown lengths so just update</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif self.min_value &gt; value:  # type: ignore</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&#39;Value {value} is too small. Should be &#39;</span>
<span class="gi">+                    f&#39;between {self.min_value} and {self.max_value}&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+            elif self.max_value &lt; value:  # type: ignore</span>
<span class="gi">+                if self.max_error:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        f&#39;Value {value} is too large. Should be between &#39;</span>
<span class="gi">+                        f&#39;{self.min_value} and {self.max_value}&#39;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    value = self.max_value</span>
<span class="gi">+</span>
<span class="gi">+            self.previous_value = self.value</span>
<span class="gi">+            self.value = value  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        # Save the updated values for dynamic messages</span>
<span class="gi">+        variables_changed = self._update_variables(kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if self._needs_update() or variables_changed or force:</span>
<span class="gi">+            self._update_parents(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_variables(self, kwargs):</span>
<span class="gi">+        variables_changed = False</span>
<span class="gi">+        for key, value_ in kwargs.items():</span>
<span class="gi">+            if key not in self.variables:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &#39;update() got an unexpected variable name as argument &#39;</span>
<span class="gi">+                    &#39;{key!r}&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+            elif self.variables[key] != value_:</span>
<span class="gi">+                self.variables[key] = kwargs[key]</span>
<span class="gi">+                variables_changed = True</span>
<span class="gi">+        return variables_changed</span>
<span class="gi">+</span>
<span class="gi">+    def _update_parents(self, value):</span>
<span class="gi">+        self.updates += 1</span>
<span class="gi">+        ResizableMixin.update(self, value=value)</span>
<span class="gi">+        ProgressBarBase.update(self, value=value)</span>
<span class="gi">+        StdRedirectMixin.update(self, value=value)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        # Only flush if something was actually written</span>
<span class="gi">+        self.fd.flush()</span>

<span class="w"> </span>    def start(self, max_value=None, init=True, *args, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Starts measuring time, and prints the bar at 0%.</span>
<span class="gi">+        &#39;&#39;&#39;Starts measuring time, and prints the bar at 0%.</span>

<span class="w"> </span>        It returns self so you can use it like this:

<span class="gu">@@ -449,11 +977,83 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>
<span class="w"> </span>        ...    pbar.update(i+1)
<span class="w"> </span>        ...
<span class="w"> </span>        &gt;&gt;&gt; pbar.finish()
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if init:</span>
<span class="gi">+            self.init()</span>
<span class="gi">+</span>
<span class="gi">+        # Prevent multiple starts</span>
<span class="gi">+        if self.start_time is not None:  # pragma: no cover</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        if max_value is not None:</span>
<span class="gi">+            self.max_value = max_value</span>
<span class="gi">+</span>
<span class="gi">+        if self.max_value is None:</span>
<span class="gi">+            self.max_value = self._DEFAULT_MAXVAL</span>
<span class="gi">+</span>
<span class="gi">+        StdRedirectMixin.start(self, max_value=max_value)</span>
<span class="gi">+        ResizableMixin.start(self, max_value=max_value)</span>
<span class="gi">+        ProgressBarBase.start(self, max_value=max_value)</span>
<span class="gi">+</span>
<span class="gi">+        # Constructing the default widgets is only done when we know max_value</span>
<span class="gi">+        if not self.widgets:</span>
<span class="gi">+            self.widgets = self.default_widgets()</span>
<span class="gi">+</span>
<span class="gi">+        self._init_prefix()</span>
<span class="gi">+        self._init_suffix()</span>
<span class="gi">+        self._calculate_poll_interval()</span>
<span class="gi">+        self._verify_max_value()</span>
<span class="gi">+</span>
<span class="gi">+        now = datetime.now()</span>
<span class="gi">+        self.start_time = self.initial_start_time or now</span>
<span class="gi">+        self.last_update_time = now</span>
<span class="gi">+        self._last_update_timer = timeit.default_timer()</span>
<span class="gi">+        self.update(self.min_value, force=True)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _init_suffix(self):</span>
<span class="gi">+        if self.suffix:</span>
<span class="gi">+            self.widgets.append(</span>
<span class="gi">+                widgets.FormatLabel(self.suffix, new_style=True),</span>
<span class="gi">+            )</span>
<span class="gi">+            # Unset the suffix variable after applying so an extra start()</span>
<span class="gi">+            # won&#39;t keep copying it</span>
<span class="gi">+            self.suffix = None</span>
<span class="gi">+</span>
<span class="gi">+    def _init_prefix(self):</span>
<span class="gi">+        if self.prefix:</span>
<span class="gi">+            self.widgets.insert(</span>
<span class="gi">+                0,</span>
<span class="gi">+                widgets.FormatLabel(self.prefix, new_style=True),</span>
<span class="gi">+            )</span>
<span class="gi">+            # Unset the prefix variable after applying so an extra start()</span>
<span class="gi">+            # won&#39;t keep copying it</span>
<span class="gi">+            self.prefix = None</span>
<span class="gi">+</span>
<span class="gi">+    def _verify_max_value(self):</span>
<span class="gi">+        if (</span>
<span class="gi">+                self.max_value is not base.UnknownLength</span>
<span class="gi">+                and self.max_value is not None</span>
<span class="gi">+                and self.max_value &lt; 0  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise ValueError(&#39;max_value out of range, got %r&#39; % self.max_value)</span>
<span class="gi">+</span>
<span class="gi">+    def _calculate_poll_interval(self) -&gt; None:</span>
<span class="gi">+        self.num_intervals = max(100, self.term_width)</span>
<span class="gi">+        for widget in self.widgets:</span>
<span class="gi">+            interval: int | float | None = utils.deltas_to_seconds(</span>
<span class="gi">+                getattr(widget, &#39;INTERVAL&#39;, None),</span>
<span class="gi">+                default=None,</span>
<span class="gi">+            )</span>
<span class="gi">+            if interval is not None:</span>
<span class="gi">+                self.poll_interval = min(</span>
<span class="gi">+                    self.poll_interval or interval,</span>
<span class="gi">+                    interval,</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def finish(self, end=&#39;\n&#39;, dirty=False):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Puts the ProgressBar bar in the finished state.

<span class="w"> </span>        Also flushes and disables output buffering if this was the last
<span class="gu">@@ -464,27 +1064,70 @@ class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):</span>
<span class="w"> </span>                newline
<span class="w"> </span>            dirty (bool): When True the progressbar kept the current state and
<span class="w"> </span>                won&#39;t be set to 100 percent
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if not dirty:</span>
<span class="gi">+            self.end_time = datetime.now()</span>
<span class="gi">+            self.update(self.max_value, force=True)</span>
<span class="gi">+</span>
<span class="gi">+        StdRedirectMixin.finish(self, end=end)</span>
<span class="gi">+        ResizableMixin.finish(self)</span>
<span class="gi">+        ProgressBarBase.finish(self)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def currval(self):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Legacy method to make progressbar-2 compatible with the original
<span class="w"> </span>        progressbar package.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The usage of `currval` is deprecated, please use &#39;</span>
<span class="gi">+            &#39;`value` instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=1,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.value</span>


<span class="w"> </span>class DataTransferBar(ProgressBar):
<span class="gd">-    &quot;&quot;&quot;A progress bar with sensible defaults for downloads etc.</span>
<span class="gi">+    &#39;&#39;&#39;A progress bar with sensible defaults for downloads etc.</span>

<span class="w"> </span>    This assumes that the values its given are numbers of bytes.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def default_widgets(self):</span>
<span class="gi">+        if self.max_value:</span>
<span class="gi">+            return [</span>
<span class="gi">+                widgets.Percentage(),</span>
<span class="gi">+                &#39; of &#39;,</span>
<span class="gi">+                widgets.DataSize(&#39;max_value&#39;),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Bar(),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Timer(),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.SmoothingETA(),</span>
<span class="gi">+            ]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [</span>
<span class="gi">+                widgets.AnimatedMarker(),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.DataSize(),</span>
<span class="gi">+                &#39; &#39;,</span>
<span class="gi">+                widgets.Timer(),</span>
<span class="gi">+            ]</span>


<span class="w"> </span>class NullBar(ProgressBar):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Progress bar that does absolutely nothing. Useful for single verbosity
<span class="w"> </span>    flags.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def start(self, *args, **kwargs):</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, *args, **kwargs):</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self, *args, **kwargs):</span>
<span class="gi">+        return self</span>
<span class="gh">diff --git a/progressbar/base.py b/progressbar/base.py</span>
<span class="gh">index 9c7fad7..f3f2ef5 100644</span>
<span class="gd">--- a/progressbar/base.py</span>
<span class="gi">+++ b/progressbar/base.py</span>
<span class="gu">@@ -2,14 +2,14 @@ from python_utils import types</span>


<span class="w"> </span>class FalseMeta(type):
<span class="gd">-</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __bool__(cls):</span>
<span class="gi">+    def __bool__(cls):  # pragma: no cover</span>
<span class="w"> </span>        return False

<span class="w"> </span>    @classmethod
<span class="gd">-    def __cmp__(cls, other):</span>
<span class="gi">+    def __cmp__(cls, other):  # pragma: no cover</span>
<span class="w"> </span>        return -1
<span class="gi">+</span>
<span class="w"> </span>    __nonzero__ = __bool__


<span class="gu">@@ -21,10 +21,11 @@ class Undefined(metaclass=FalseMeta):</span>
<span class="w"> </span>    pass


<span class="gd">-try:</span>
<span class="gd">-    IO = types.IO</span>
<span class="gd">-    TextIO = types.TextIO</span>
<span class="gd">-except AttributeError:</span>
<span class="gd">-    from typing.io import IO, TextIO</span>
<span class="gi">+try:  # pragma: no cover</span>
<span class="gi">+    IO = types.IO  # type: ignore</span>
<span class="gi">+    TextIO = types.TextIO  # type: ignore</span>
<span class="gi">+except AttributeError:  # pragma: no cover</span>
<span class="gi">+    from typing.io import IO, TextIO  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>assert IO is not None
<span class="w"> </span>assert TextIO is not None
<span class="gh">diff --git a/progressbar/env.py b/progressbar/env.py</span>
<span class="gh">index b58929e..54e3729 100644</span>
<span class="gd">--- a/progressbar/env.py</span>
<span class="gi">+++ b/progressbar/env.py</span>
<span class="gu">@@ -1,25 +1,41 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import enum
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from . import base


<span class="gi">+@typing.overload</span>
<span class="gi">+def env_flag(name: str, default: bool) -&gt; bool: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def env_flag(name: str, default: bool | None = None) -&gt; bool | None: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def env_flag(name, default=None):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Accepts environt variables formatted as y/n, yes/no, 1/0, true/false,
<span class="w"> </span>    on/off, and returns it as a boolean.

<span class="w"> </span>    If the environment variable is not defined, or has an unknown value,
<span class="w"> </span>    returns `default`
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    v = os.getenv(name)</span>
<span class="gi">+    if v and v.lower() in (&#39;y&#39;, &#39;yes&#39;, &#39;t&#39;, &#39;true&#39;, &#39;on&#39;, &#39;1&#39;):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if v and v.lower() in (&#39;n&#39;, &#39;no&#39;, &#39;f&#39;, &#39;false&#39;, &#39;off&#39;, &#39;0&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return default</span>


<span class="w"> </span>class ColorSupport(enum.IntEnum):
<span class="gd">-    &quot;&quot;&quot;Color support for the terminal.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Color support for the terminal.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    NONE = 0
<span class="w"> </span>    XTERM = 16
<span class="w"> </span>    XTERM_256 = 256
<span class="gu">@@ -28,7 +44,7 @@ class ColorSupport(enum.IntEnum):</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_env(cls):
<span class="gd">-        &quot;&quot;&quot;Get the color support from the environment.</span>
<span class="gi">+        &#39;&#39;&#39;Get the color support from the environment.</span>

<span class="w"> </span>        If any of the environment variables contain `24bit` or `truecolor`,
<span class="w"> </span>        we will enable true color/24 bit support. If they contain `256`, we
<span class="gu">@@ -40,15 +56,131 @@ class ColorSupport(enum.IntEnum):</span>

<span class="w"> </span>        Note that the highest available value will be used! Having
<span class="w"> </span>        `COLORTERM=truecolor` will override `TERM=xterm-256color`.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        variables = (</span>
<span class="gi">+            &#39;FORCE_COLOR&#39;,</span>
<span class="gi">+            &#39;PROGRESSBAR_ENABLE_COLORS&#39;,</span>
<span class="gi">+            &#39;COLORTERM&#39;,</span>
<span class="gi">+            &#39;TERM&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if JUPYTER:</span>
<span class="gi">+            # Jupyter notebook always supports true color.</span>
<span class="gi">+            return cls.XTERM_TRUECOLOR</span>
<span class="gi">+        elif os.name == &#39;nt&#39;:</span>
<span class="gi">+            # We can&#39;t reliably detect true color support on Windows, so we</span>
<span class="gi">+            # will assume it is supported if the console is configured to</span>
<span class="gi">+            # support it.</span>
<span class="gi">+            from .terminal.os_specific import windows</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                windows.get_console_mode()</span>
<span class="gi">+                &amp; windows.WindowsConsoleModeFlags.ENABLE_PROCESSED_OUTPUT</span>
<span class="gi">+            ):</span>
<span class="gi">+                return cls.XTERM_TRUECOLOR</span>
<span class="gi">+            else:</span>
<span class="gi">+                return cls.WINDOWS  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+        support = cls.NONE</span>
<span class="gi">+        for variable in variables:</span>
<span class="gi">+            value = os.environ.get(variable)</span>
<span class="gi">+            if value is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif value in {&#39;truecolor&#39;, &#39;24bit&#39;}:</span>
<span class="gi">+                # Truecolor support, we don&#39;t need to check anything else.</span>
<span class="gi">+                support = cls.XTERM_TRUECOLOR</span>
<span class="gi">+                break</span>
<span class="gi">+            elif &#39;256&#39; in value:</span>
<span class="gi">+                support = max(cls.XTERM_256, support)</span>
<span class="gi">+            elif value == &#39;xterm&#39;:</span>
<span class="gi">+                support = max(cls.XTERM, support)</span>
<span class="gi">+</span>
<span class="gi">+        return support</span>


<span class="gi">+def is_ansi_terminal(</span>
<span class="gi">+    fd: base.IO,</span>
<span class="gi">+    is_terminal: bool | None = None,</span>
<span class="gi">+) -&gt; bool | None:  # pragma: no cover</span>
<span class="gi">+    if is_terminal is None:</span>
<span class="gi">+        # Jupyter Notebooks support progress bars</span>
<span class="gi">+        if JUPYTER:</span>
<span class="gi">+            is_terminal = True</span>
<span class="gi">+        # This works for newer versions of pycharm only. With older versions</span>
<span class="gi">+        # there is no way to check.</span>
<span class="gi">+        elif os.environ.get(&#39;PYCHARM_HOSTED&#39;) == &#39;1&#39; and not os.environ.get(</span>
<span class="gi">+            &#39;PYTEST_CURRENT_TEST&#39;</span>
<span class="gi">+        ):</span>
<span class="gi">+            is_terminal = True</span>
<span class="gi">+</span>
<span class="gi">+    if is_terminal is None:</span>
<span class="gi">+        # check if we are writing to a terminal or not. typically a file object</span>
<span class="gi">+        # is going to return False if the instance has been overridden and</span>
<span class="gi">+        # isatty has not been defined we have no way of knowing so we will not</span>
<span class="gi">+        # use ansi.  ansi terminals will typically define one of the 2</span>
<span class="gi">+        # environment variables.</span>
<span class="gi">+        with contextlib.suppress(Exception):</span>
<span class="gi">+            is_tty = fd.isatty()</span>
<span class="gi">+            # Try and match any of the huge amount of Linux/Unix ANSI consoles</span>
<span class="gi">+            if is_tty and ANSI_TERM_RE.match(os.environ.get(&#39;TERM&#39;, &#39;&#39;)):</span>
<span class="gi">+                is_terminal = True</span>
<span class="gi">+            # ANSICON is a Windows ANSI compatible console</span>
<span class="gi">+            elif &#39;ANSICON&#39; in os.environ:</span>
<span class="gi">+                is_terminal = True</span>
<span class="gi">+            elif os.name == &#39;nt&#39;:</span>
<span class="gi">+                from .terminal.os_specific import windows</span>
<span class="gi">+</span>
<span class="gi">+                return bool(</span>
<span class="gi">+                    windows.get_console_mode()</span>
<span class="gi">+                    &amp; windows.WindowsConsoleModeFlags.ENABLE_PROCESSED_OUTPUT,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                is_terminal = None</span>
<span class="gi">+</span>
<span class="gi">+    return is_terminal</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_terminal(fd: base.IO, is_terminal: bool | None = None) -&gt; bool | None:</span>
<span class="gi">+    if is_terminal is None:</span>
<span class="gi">+        # Full ansi support encompasses what we expect from a terminal</span>
<span class="gi">+        is_terminal = is_ansi_terminal(fd) or None</span>
<span class="gi">+</span>
<span class="gi">+    if is_terminal is None:</span>
<span class="gi">+        # Allow a environment variable override</span>
<span class="gi">+        is_terminal = env_flag(&#39;PROGRESSBAR_IS_TERMINAL&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+    if is_terminal is None:  # pragma: no cover</span>
<span class="gi">+        # Bare except because a lot can go wrong on different systems. If we do</span>
<span class="gi">+        # get a TTY we know this is a valid terminal</span>
<span class="gi">+        try:</span>
<span class="gi">+            is_terminal = fd.isatty()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            is_terminal = False</span>
<span class="gi">+</span>
<span class="gi">+    return is_terminal</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Enable Windows full color mode if possible</span>
<span class="w"> </span>if os.name == &#39;nt&#39;:
<span class="w"> </span>    pass
<span class="gd">-JUPYTER = bool(os.environ.get(&#39;JUPYTER_COLUMNS&#39;) or os.environ.get(</span>
<span class="gd">-    &#39;JUPYTER_LINES&#39;) or os.environ.get(&#39;JPY_PARENT_PID&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # os_specific.set_console_mode()</span>
<span class="gi">+</span>
<span class="gi">+JUPYTER = bool(</span>
<span class="gi">+    os.environ.get(&#39;JUPYTER_COLUMNS&#39;)</span>
<span class="gi">+    or os.environ.get(&#39;JUPYTER_LINES&#39;)</span>
<span class="gi">+    or os.environ.get(&#39;JPY_PARENT_PID&#39;)</span>
<span class="gi">+)</span>
<span class="w"> </span>COLOR_SUPPORT = ColorSupport.from_env()
<span class="gd">-ANSI_TERMS = (&#39;([xe]|bv)term&#39;, &#39;(sco)?ansi&#39;, &#39;cygwin&#39;, &#39;konsole&#39;, &#39;linux&#39;,</span>
<span class="gd">-    &#39;rxvt&#39;, &#39;screen&#39;, &#39;tmux&#39;, &#39;vt(10[02]|220|320)&#39;)</span>
<span class="gi">+ANSI_TERMS = (</span>
<span class="gi">+    &#39;([xe]|bv)term&#39;,</span>
<span class="gi">+    &#39;(sco)?ansi&#39;,</span>
<span class="gi">+    &#39;cygwin&#39;,</span>
<span class="gi">+    &#39;konsole&#39;,</span>
<span class="gi">+    &#39;linux&#39;,</span>
<span class="gi">+    &#39;rxvt&#39;,</span>
<span class="gi">+    &#39;screen&#39;,</span>
<span class="gi">+    &#39;tmux&#39;,</span>
<span class="gi">+    &#39;vt(10[02]|220|320)&#39;,</span>
<span class="gi">+)</span>
<span class="w"> </span>ANSI_TERM_RE = re.compile(f&quot;^({&#39;|&#39;.join(ANSI_TERMS)})&quot;, re.IGNORECASE)
<span class="gh">diff --git a/progressbar/multi.py b/progressbar/multi.py</span>
<span class="gh">index bcf8152..ae3dd23 100644</span>
<span class="gd">--- a/progressbar/multi.py</span>
<span class="gi">+++ b/progressbar/multi.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import enum
<span class="w"> </span>import io
<span class="w"> </span>import itertools
<span class="gu">@@ -9,14 +10,17 @@ import time</span>
<span class="w"> </span>import timeit
<span class="w"> </span>import typing
<span class="w"> </span>from datetime import timedelta
<span class="gi">+</span>
<span class="w"> </span>import python_utils
<span class="gi">+</span>
<span class="w"> </span>from . import bar, terminal
<span class="w"> </span>from .terminal import stream
<span class="gi">+</span>
<span class="w"> </span>SortKeyFunc = typing.Callable[[bar.ProgressBar], typing.Any]


<span class="w"> </span>class SortKey(str, enum.Enum):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Sort keys for the MultiBar.

<span class="w"> </span>    This is a string enum, so you can use any
<span class="gu">@@ -26,7 +30,8 @@ class SortKey(str, enum.Enum):</span>
<span class="w"> </span>    progressbars. This means that sorting by dynamic attributes such as
<span class="w"> </span>    `value` might result in more rendering which can have a small performance
<span class="w"> </span>    impact.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    CREATED = &#39;index&#39;
<span class="w"> </span>    LABEL = &#39;label&#39;
<span class="w"> </span>    VALUE = &#39;value&#39;
<span class="gu">@@ -36,15 +41,31 @@ class SortKey(str, enum.Enum):</span>
<span class="w"> </span>class MultiBar(typing.Dict[str, bar.ProgressBar]):
<span class="w"> </span>    fd: typing.TextIO
<span class="w"> </span>    _buffer: io.StringIO
<span class="gi">+</span>
<span class="gi">+    #: The format for the label to append/prepend to the progressbar</span>
<span class="w"> </span>    label_format: str
<span class="gi">+    #: Automatically prepend the label to the progressbars</span>
<span class="w"> </span>    prepend_label: bool
<span class="gi">+    #: Automatically append the label to the progressbars</span>
<span class="w"> </span>    append_label: bool
<span class="gi">+    #: If `initial_format` is `None`, the progressbar rendering is used</span>
<span class="gi">+    # which will *start* the progressbar. That means the progressbar will</span>
<span class="gi">+    # have no knowledge of your data and will run as an infinite progressbar.</span>
<span class="w"> </span>    initial_format: str | None
<span class="gi">+    #: If `finished_format` is `None`, the progressbar rendering is used.</span>
<span class="w"> </span>    finished_format: str | None
<span class="gi">+</span>
<span class="gi">+    #: The multibar updates at a fixed interval regardless of the progressbar</span>
<span class="gi">+    # updates</span>
<span class="w"> </span>    update_interval: float
<span class="w"> </span>    remove_finished: float | None
<span class="gi">+</span>
<span class="gi">+    #: The kwargs passed to the progressbar constructor</span>
<span class="w"> </span>    progressbar_kwargs: dict[str, typing.Any]
<span class="gi">+</span>
<span class="gi">+    #: The progressbar sorting key function</span>
<span class="w"> </span>    sort_keyfunc: SortKeyFunc
<span class="gi">+</span>
<span class="w"> </span>    _previous_output: list[str]
<span class="w"> </span>    _finished_at: dict[bar.ProgressBar, float]
<span class="w"> </span>    _labeled: set[bar.ProgressBar]
<span class="gu">@@ -53,56 +74,80 @@ class MultiBar(typing.Dict[str, bar.ProgressBar]):</span>
<span class="w"> </span>    _thread_finished: threading.Event = threading.Event()
<span class="w"> </span>    _thread_closed: threading.Event = threading.Event()

<span class="gd">-    def __init__(self, bars: (typing.Iterable[tuple[str, bar.ProgressBar]] |</span>
<span class="gd">-        None)=None, fd: typing.TextIO=sys.stderr, prepend_label: bool=True,</span>
<span class="gd">-        append_label: bool=False, label_format=&#39;{label:20.20} &#39;,</span>
<span class="gd">-        initial_format: (str | None)=&#39;{label:20.20} Not yet started&#39;,</span>
<span class="gd">-        finished_format: (str | None)=None, update_interval: float=1 / 60.0,</span>
<span class="gd">-        show_initial: bool=True, show_finished: bool=True, remove_finished:</span>
<span class="gd">-        (timedelta | float)=timedelta(seconds=3600), sort_key: (str |</span>
<span class="gd">-        SortKey)=SortKey.CREATED, sort_reverse: bool=True, sort_keyfunc: (</span>
<span class="gd">-        SortKeyFunc | None)=None, **progressbar_kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        bars: typing.Iterable[tuple[str, bar.ProgressBar]] | None = None,</span>
<span class="gi">+        fd: typing.TextIO = sys.stderr,</span>
<span class="gi">+        prepend_label: bool = True,</span>
<span class="gi">+        append_label: bool = False,</span>
<span class="gi">+        label_format=&#39;{label:20.20} &#39;,</span>
<span class="gi">+        initial_format: str | None = &#39;{label:20.20} Not yet started&#39;,</span>
<span class="gi">+        finished_format: str | None = None,</span>
<span class="gi">+        update_interval: float = 1 / 60.0,  # 60fps</span>
<span class="gi">+        show_initial: bool = True,</span>
<span class="gi">+        show_finished: bool = True,</span>
<span class="gi">+        remove_finished: timedelta | float = timedelta(seconds=3600),</span>
<span class="gi">+        sort_key: str | SortKey = SortKey.CREATED,</span>
<span class="gi">+        sort_reverse: bool = True,</span>
<span class="gi">+        sort_keyfunc: SortKeyFunc | None = None,</span>
<span class="gi">+        **progressbar_kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.fd = fd
<span class="gi">+</span>
<span class="w"> </span>        self.prepend_label = prepend_label
<span class="w"> </span>        self.append_label = append_label
<span class="w"> </span>        self.label_format = label_format
<span class="w"> </span>        self.initial_format = initial_format
<span class="w"> </span>        self.finished_format = finished_format
<span class="gi">+</span>
<span class="w"> </span>        self.update_interval = update_interval
<span class="gi">+</span>
<span class="w"> </span>        self.show_initial = show_initial
<span class="w"> </span>        self.show_finished = show_finished
<span class="w"> </span>        self.remove_finished = python_utils.delta_to_seconds_or_none(
<span class="gd">-            remove_finished)</span>
<span class="gi">+            remove_finished,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.progressbar_kwargs = progressbar_kwargs
<span class="gi">+</span>
<span class="w"> </span>        if sort_keyfunc is None:
<span class="w"> </span>            sort_keyfunc = operator.attrgetter(sort_key)
<span class="gi">+</span>
<span class="w"> </span>        self.sort_keyfunc = sort_keyfunc
<span class="w"> </span>        self.sort_reverse = sort_reverse
<span class="gi">+</span>
<span class="w"> </span>        self._labeled = set()
<span class="w"> </span>        self._finished_at = {}
<span class="w"> </span>        self._previous_output = []
<span class="w"> </span>        self._buffer = io.StringIO()
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(bars or {})

<span class="w"> </span>    def __setitem__(self, key: str, bar: bar.ProgressBar):
<span class="gd">-        &quot;&quot;&quot;Add a progressbar to the multibar.&quot;&quot;&quot;</span>
<span class="gd">-        if bar.label != key or not key:</span>
<span class="gi">+        &#39;&#39;&#39;Add a progressbar to the multibar.&#39;&#39;&#39;</span>
<span class="gi">+        if bar.label != key or not key:  # pragma: no branch</span>
<span class="w"> </span>            bar.label = key
<span class="w"> </span>            bar.fd = stream.LastLineStream(self.fd)
<span class="w"> </span>            bar.paused = True
<span class="gd">-            bar.print = self.print</span>
<span class="gi">+            # Essentially `bar.print = self.print`, but `mypy` doesn&#39;t</span>
<span class="gi">+            # like that</span>
<span class="gi">+            bar.print = self.print  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        # Just in case someone is using a progressbar with a custom</span>
<span class="gi">+        # constructor and forgot to call the super constructor</span>
<span class="w"> </span>        if bar.index == -1:
<span class="w"> </span>            bar.index = next(bar._index_counter)
<span class="gi">+</span>
<span class="w"> </span>        super().__setitem__(key, bar)

<span class="w"> </span>    def __delitem__(self, key):
<span class="gd">-        &quot;&quot;&quot;Remove a progressbar from the multibar.&quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;Remove a progressbar from the multibar.&#39;&#39;&#39;</span>
<span class="w"> </span>        super().__delitem__(key)
<span class="w"> </span>        self._finished_at.pop(key, None)
<span class="w"> </span>        self._labeled.discard(key)

<span class="w"> </span>    def __getitem__(self, key):
<span class="gd">-        &quot;&quot;&quot;Get (and create if needed) a progressbar from the multibar.&quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;Get (and create if needed) a progressbar from the multibar.&#39;&#39;&#39;</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return super().__getitem__(key)
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -110,13 +155,132 @@ class MultiBar(typing.Dict[str, bar.ProgressBar]):</span>
<span class="w"> </span>            self[key] = progress
<span class="w"> </span>            return progress

<span class="gd">-    def render(self, flush: bool=True, force: bool=False):</span>
<span class="gd">-        &quot;&quot;&quot;Render the multibar to the given stream.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _label_bar(self, bar: bar.ProgressBar):</span>
<span class="gi">+        if bar in self._labeled:  # pragma: no branch</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        assert bar.widgets, &#39;Cannot prepend label to empty progressbar&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if self.prepend_label:  # pragma: no branch</span>
<span class="gi">+            self._labeled.add(bar)</span>
<span class="gi">+            bar.widgets.insert(0, self.label_format.format(label=bar.label))</span>
<span class="gi">+</span>
<span class="gi">+        if self.append_label and bar not in self._labeled:  # pragma: no branch</span>
<span class="gi">+            self._labeled.add(bar)</span>
<span class="gi">+            bar.widgets.append(self.label_format.format(label=bar.label))</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, flush: bool = True, force: bool = False):</span>
<span class="gi">+        &#39;&#39;&#39;Render the multibar to the given stream.&#39;&#39;&#39;</span>
<span class="gi">+        now = timeit.default_timer()</span>
<span class="gi">+        expired = now - self.remove_finished if self.remove_finished else None</span>
<span class="gi">+</span>
<span class="gi">+        # sourcery skip: list-comprehension</span>
<span class="gi">+        output: list[str] = []</span>
<span class="gi">+        for bar_ in self.get_sorted_bars():</span>
<span class="gi">+            if not bar_.started() and not self.show_initial:</span>
<span class="gi">+                continue</span>

<span class="gd">-    def print(self, *args, end=&#39;\n&#39;, offset=None, flush=True, clear=True,</span>
<span class="gd">-        **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+            output.extend(</span>
<span class="gi">+                iter(self._render_bar(bar_, expired=expired, now=now)),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        with self._print_lock:</span>
<span class="gi">+            # Clear the previous output if progressbars have been removed</span>
<span class="gi">+            for i in range(len(output), len(self._previous_output)):</span>
<span class="gi">+                self._buffer.write(</span>
<span class="gi">+                    terminal.clear_line(i + 1),</span>
<span class="gi">+                )  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+            # Add empty lines to the end of the output if progressbars have</span>
<span class="gi">+            # been added</span>
<span class="gi">+            for _ in range(len(self._previous_output), len(output)):</span>
<span class="gi">+                # Adding a new line so we don&#39;t overwrite previous output</span>
<span class="gi">+                self._buffer.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            for i, (previous, current) in enumerate(</span>
<span class="gi">+                itertools.zip_longest(</span>
<span class="gi">+                    self._previous_output,</span>
<span class="gi">+                    output,</span>
<span class="gi">+                    fillvalue=&#39;&#39;,</span>
<span class="gi">+                ),</span>
<span class="gi">+            ):</span>
<span class="gi">+                if previous != current or force:  # pragma: no branch</span>
<span class="gi">+                    self.print(</span>
<span class="gi">+                        &#39;\r&#39; + current.strip(),</span>
<span class="gi">+                        offset=i + 1,</span>
<span class="gi">+                        end=&#39;&#39;,</span>
<span class="gi">+                        clear=False,</span>
<span class="gi">+                        flush=False,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            self._previous_output = output</span>
<span class="gi">+</span>
<span class="gi">+            if flush:  # pragma: no branch</span>
<span class="gi">+                self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def _render_bar(</span>
<span class="gi">+        self,</span>
<span class="gi">+        bar_: bar.ProgressBar,</span>
<span class="gi">+        now,</span>
<span class="gi">+        expired,</span>
<span class="gi">+    ) -&gt; typing.Iterable[str]:</span>
<span class="gi">+        def update(force=True, write=True):  # pragma: no cover</span>
<span class="gi">+            self._label_bar(bar_)</span>
<span class="gi">+            bar_.update(force=force)</span>
<span class="gi">+            if write:</span>
<span class="gi">+                yield typing.cast(stream.LastLineStream, bar_.fd).line</span>
<span class="gi">+</span>
<span class="gi">+        if bar_.finished():</span>
<span class="gi">+            yield from self._render_finished_bar(bar_, now, expired, update)</span>
<span class="gi">+</span>
<span class="gi">+        elif bar_.started():</span>
<span class="gi">+            update()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.initial_format is None:</span>
<span class="gi">+                bar_.start()</span>
<span class="gi">+                update()</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield self.initial_format.format(label=bar_.label)</span>
<span class="gi">+</span>
<span class="gi">+    def _render_finished_bar(</span>
<span class="gi">+        self,</span>
<span class="gi">+        bar_: bar.ProgressBar,</span>
<span class="gi">+        now,</span>
<span class="gi">+        expired,</span>
<span class="gi">+        update,</span>
<span class="gi">+    ) -&gt; typing.Iterable[str]:</span>
<span class="gi">+        if bar_ not in self._finished_at:</span>
<span class="gi">+            self._finished_at[bar_] = now</span>
<span class="gi">+            # Force update to get the finished format</span>
<span class="gi">+            update(write=False)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.remove_finished</span>
<span class="gi">+            and expired is not None</span>
<span class="gi">+            and expired &gt;= self._finished_at[bar_]</span>
<span class="gi">+        ):</span>
<span class="gi">+            del self[bar_.label]</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not self.show_finished:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if bar_.finished():  # pragma: no branch</span>
<span class="gi">+            if self.finished_format is None:</span>
<span class="gi">+                update(force=False)</span>
<span class="gi">+            else:  # pragma: no cover</span>
<span class="gi">+                yield self.finished_format.format(label=bar_.label)</span>
<span class="gi">+</span>
<span class="gi">+    def print(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *args,</span>
<span class="gi">+        end=&#39;\n&#39;,</span>
<span class="gi">+        offset=None,</span>
<span class="gi">+        flush=True,</span>
<span class="gi">+        clear=True,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Print to the progressbar stream without overwriting the progressbars.

<span class="w"> </span>        Args:
<span class="gu">@@ -126,15 +290,80 @@ class MultiBar(typing.Dict[str, bar.ProgressBar]):</span>
<span class="w"> </span>            flush: Whether to flush the output to the stream
<span class="w"> </span>            clear: If True, the line will be cleared before printing.
<span class="w"> </span>            **kwargs: Additional keyword arguments to pass to print
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        with self._print_lock:</span>
<span class="gi">+            if offset is None:</span>
<span class="gi">+                offset = len(self._previous_output)</span>
<span class="gi">+</span>
<span class="gi">+            if not clear:</span>
<span class="gi">+                self._buffer.write(terminal.PREVIOUS_LINE(offset))</span>
<span class="gi">+</span>
<span class="gi">+            if clear:</span>
<span class="gi">+                self._buffer.write(terminal.PREVIOUS_LINE(offset))</span>
<span class="gi">+                self._buffer.write(terminal.CLEAR_LINE_ALL())</span>
<span class="gi">+</span>
<span class="gi">+            print(*args, **kwargs, file=self._buffer, end=end)</span>
<span class="gi">+</span>
<span class="gi">+            if clear:</span>
<span class="gi">+                self._buffer.write(terminal.CLEAR_SCREEN_TILL_END())</span>
<span class="gi">+                for line in self._previous_output:</span>
<span class="gi">+                    self._buffer.write(line.strip())</span>
<span class="gi">+                    self._buffer.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._buffer.write(terminal.NEXT_LINE(offset))</span>
<span class="gi">+</span>
<span class="gi">+            if flush:</span>
<span class="gi">+                self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self):</span>
<span class="gi">+        self.fd.write(self._buffer.getvalue())</span>
<span class="gi">+        self._buffer.truncate(0)</span>
<span class="gi">+        self.fd.flush()</span>

<span class="w"> </span>    def run(self, join=True):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Start the multibar render loop and run the progressbars until they
<span class="w"> </span>        have force _thread_finished.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        while not self._thread_finished.is_set():  # pragma: no branch</span>
<span class="gi">+            self.render()</span>
<span class="gi">+            time.sleep(self.update_interval)</span>
<span class="gi">+</span>
<span class="gi">+            if join or self._thread_closed.is_set():</span>
<span class="gi">+                # If the thread is closed, we need to check if the progressbars</span>
<span class="gi">+                # have finished. If they have, we can exit the loop</span>
<span class="gi">+                for bar_ in self.values():  # pragma: no cover</span>
<span class="gi">+                    if not bar_.finished():</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Render one last time to make sure the progressbars are</span>
<span class="gi">+                    # correctly finished</span>
<span class="gi">+                    self.render(force=True)</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+    def start(self):</span>
<span class="gi">+        assert not self._thread, &#39;Multibar already started&#39;</span>
<span class="gi">+        self._thread_closed.set()</span>
<span class="gi">+        self._thread = threading.Thread(target=self.run, args=(False,))</span>
<span class="gi">+        self._thread.start()</span>
<span class="gi">+</span>
<span class="gi">+    def join(self, timeout=None):</span>
<span class="gi">+        if self._thread is not None:</span>
<span class="gi">+            self._thread_closed.set()</span>
<span class="gi">+            self._thread.join(timeout=timeout)</span>
<span class="gi">+            self._thread = None</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self, timeout: float | None = None):</span>
<span class="gi">+        self._thread_finished.set()</span>
<span class="gi">+        self.join(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+    def get_sorted_bars(self):</span>
<span class="gi">+        return sorted(</span>
<span class="gi">+            self.values(),</span>
<span class="gi">+            key=self.sort_keyfunc,</span>
<span class="gi">+            reverse=self.sort_reverse,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        self.start()
<span class="gh">diff --git a/progressbar/shortcuts.py b/progressbar/shortcuts.py</span>
<span class="gh">index de13ddf..b16f19a 100644</span>
<span class="gd">--- a/progressbar/shortcuts.py</span>
<span class="gi">+++ b/progressbar/shortcuts.py</span>
<span class="gu">@@ -1 +1,22 @@</span>
<span class="w"> </span>from . import bar
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def progressbar(</span>
<span class="gi">+    iterator,</span>
<span class="gi">+    min_value=0,</span>
<span class="gi">+    max_value=None,</span>
<span class="gi">+    widgets=None,</span>
<span class="gi">+    prefix=None,</span>
<span class="gi">+    suffix=None,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+    progressbar = bar.ProgressBar(</span>
<span class="gi">+        min_value=min_value,</span>
<span class="gi">+        max_value=max_value,</span>
<span class="gi">+        widgets=widgets,</span>
<span class="gi">+        prefix=prefix,</span>
<span class="gi">+        suffix=suffix,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    yield from progressbar(iterator)</span>
<span class="gh">diff --git a/progressbar/terminal/base.py b/progressbar/terminal/base.py</span>
<span class="gh">index 6c22ca8..895887b 100644</span>
<span class="gd">--- a/progressbar/terminal/base.py</span>
<span class="gi">+++ b/progressbar/terminal/base.py</span>
<span class="gu">@@ -1,15 +1,25 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import collections
<span class="w"> </span>import colorsys
<span class="w"> </span>import enum
<span class="w"> </span>import threading
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="gi">+# Ruff is being stupid and doesn&#39;t understand `ClassVar` if it comes from the</span>
<span class="gi">+# `types` module</span>
<span class="w"> </span>from typing import ClassVar
<span class="gi">+</span>
<span class="w"> </span>from python_utils import converters, types
<span class="gd">-from .. import base as pbase, env</span>
<span class="gi">+</span>
<span class="gi">+from .. import (</span>
<span class="gi">+    base as pbase,</span>
<span class="gi">+    env,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .os_specific import getch
<span class="gd">-ESC = &#39;\x1b&#39;</span>
<span class="gi">+</span>
<span class="gi">+ESC = &#39;\x1B&#39;</span>


<span class="w"> </span>class CSI:
<span class="gu">@@ -21,63 +31,153 @@ class CSI:</span>
<span class="w"> </span>        self._default_args = default_args

<span class="w"> </span>    def __call__(self, *args):
<span class="gd">-        return self._template.format(args=&#39;;&#39;.join(map(str, args or self.</span>
<span class="gd">-            _default_args)), code=self._code)</span>
<span class="gi">+        return self._template.format(</span>
<span class="gi">+            args=&#39;;&#39;.join(map(str, args or self._default_args)),</span>
<span class="gi">+            code=self._code,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self()


<span class="w"> </span>class CSINoArg(CSI):
<span class="gd">-</span>
<span class="w"> </span>    def __call__(self):
<span class="w"> </span>        return super().__call__()


<span class="gi">+#: Cursor Position [row;column] (default = [1,1])</span>
<span class="w"> </span>CUP = CSI(&#39;H&#39;, 1, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Up Ps Times (default = 1) (CUU)</span>
<span class="w"> </span>UP = CSI(&#39;A&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Down Ps Times (default = 1) (CUD)</span>
<span class="w"> </span>DOWN = CSI(&#39;B&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Forward Ps Times (default = 1) (CUF)</span>
<span class="w"> </span>RIGHT = CSI(&#39;C&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Backward Ps Times (default = 1) (CUB)</span>
<span class="w"> </span>LEFT = CSI(&#39;D&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Next Line Ps Times (default = 1) (CNL)</span>
<span class="gi">+#: Same as Cursor Down Ps Times</span>
<span class="w"> </span>NEXT_LINE = CSI(&#39;E&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Preceding Line Ps Times (default = 1) (CPL)</span>
<span class="gi">+#: Same as Cursor Up Ps Times</span>
<span class="w"> </span>PREVIOUS_LINE = CSI(&#39;F&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Cursor Character Absolute  [column] (default = [row,1]) (CHA)</span>
<span class="w"> </span>COLUMN = CSI(&#39;G&#39;, 1)
<span class="gi">+</span>
<span class="gi">+#: Erase in Display (ED)</span>
<span class="w"> </span>CLEAR_SCREEN = CSI(&#39;J&#39;, 0)
<span class="gi">+</span>
<span class="gi">+#: Erase till end of screen</span>
<span class="w"> </span>CLEAR_SCREEN_TILL_END = CSINoArg(&#39;0J&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase till start of screen</span>
<span class="w"> </span>CLEAR_SCREEN_TILL_START = CSINoArg(&#39;1J&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase whole screen</span>
<span class="w"> </span>CLEAR_SCREEN_ALL = CSINoArg(&#39;2J&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase whole screen and history</span>
<span class="w"> </span>CLEAR_SCREEN_ALL_AND_HISTORY = CSINoArg(&#39;3J&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase in Line (EL)</span>
<span class="w"> </span>CLEAR_LINE_ALL = CSI(&#39;K&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase in Line from Cursor to End of Line (default)</span>
<span class="w"> </span>CLEAR_LINE_RIGHT = CSINoArg(&#39;0K&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase in Line from Cursor to Beginning of Line</span>
<span class="w"> </span>CLEAR_LINE_LEFT = CSINoArg(&#39;1K&#39;)
<span class="gi">+</span>
<span class="gi">+#: Erase Line containing Cursor</span>
<span class="w"> </span>CLEAR_LINE = CSINoArg(&#39;2K&#39;)
<span class="gi">+</span>
<span class="gi">+#: Scroll up Ps lines (default = 1) (SU)</span>
<span class="gi">+#: Scroll down Ps lines (default = 1) (SD)</span>
<span class="w"> </span>SCROLL_UP = CSI(&#39;S&#39;)
<span class="w"> </span>SCROLL_DOWN = CSI(&#39;T&#39;)
<span class="gi">+</span>
<span class="gi">+#: Save Cursor Position (SCP)</span>
<span class="w"> </span>SAVE_CURSOR = CSINoArg(&#39;s&#39;)
<span class="gi">+</span>
<span class="gi">+#: Restore Cursor Position (RCP)</span>
<span class="w"> </span>RESTORE_CURSOR = CSINoArg(&#39;u&#39;)
<span class="gi">+</span>
<span class="gi">+#: Cursor Visibility (DECTCEM)</span>
<span class="w"> </span>HIDE_CURSOR = CSINoArg(&#39;?25l&#39;)
<span class="w"> </span>SHOW_CURSOR = CSINoArg(&#39;?25h&#39;)


<span class="gd">-class _CPR(str):</span>
<span class="gi">+#</span>
<span class="gi">+# UP = CSI + &#39;{n}A&#39;  # Cursor Up</span>
<span class="gi">+# DOWN = CSI + &#39;{n}B&#39;  # Cursor Down</span>
<span class="gi">+# RIGHT = CSI + &#39;{n}C&#39;  # Cursor Forward</span>
<span class="gi">+# LEFT = CSI + &#39;{n}D&#39;  # Cursor Backward</span>
<span class="gi">+# NEXT = CSI + &#39;{n}E&#39;  # Cursor Next Line</span>
<span class="gi">+# PREV = CSI + &#39;{n}F&#39;  # Cursor Previous Line</span>
<span class="gi">+# MOVE_COLUMN = CSI + &#39;{n}G&#39;  # Cursor Horizontal Absolute</span>
<span class="gi">+# MOVE = CSI + &#39;{row};{column}H&#39;  # Cursor Position [row;column] (default = [</span>
<span class="gi">+# 1,1])</span>
<span class="gi">+#</span>
<span class="gi">+# CLEAR = CSI + &#39;{n}J&#39;  # Clear (part of) the screen</span>
<span class="gi">+# CLEAR_BOTTOM = CLEAR.format(n=0)  # Clear from cursor to end of screen</span>
<span class="gi">+# CLEAR_TOP = CLEAR.format(n=1)  # Clear from cursor to beginning of screen</span>
<span class="gi">+# CLEAR_SCREEN = CLEAR.format(n=2)  # Clear Screen</span>
<span class="gi">+# CLEAR_WIPE = CLEAR.format(n=3)  # Clear Screen and scrollback buffer</span>
<span class="gi">+#</span>
<span class="gi">+# CLEAR_LINE = CSI + &#39;{n}K&#39;  # Erase in Line</span>
<span class="gi">+# CLEAR_LINE_RIGHT = CLEAR_LINE.format(n=0)  # Clear from cursor to end of line</span>
<span class="gi">+# CLEAR_LINE_LEFT = CLEAR_LINE.format(n=1)  # Clear from cursor to beginning</span>
<span class="gi">+# of line</span>
<span class="gi">+# CLEAR_LINE_ALL = CLEAR_LINE.format(n=2)  # Clear Line</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def clear_line(n):</span>
<span class="gi">+    return UP(n) + CLEAR_LINE_ALL() + DOWN(n)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Report Cursor Position (CPR), response = [row;column] as row;columnR</span>
<span class="gi">+class _CPR(str):  # pragma: no cover</span>
<span class="w"> </span>    _response_lock = threading.Lock()

<span class="gd">-    def __call__(self, stream) -&gt;tuple[int, int]:</span>
<span class="gi">+    def __call__(self, stream) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        res: str = &#39;&#39;
<span class="gi">+</span>
<span class="w"> </span>        with self._response_lock:
<span class="w"> </span>            stream.write(str(self))
<span class="w"> </span>            stream.flush()
<span class="gi">+</span>
<span class="w"> </span>            while not res.endswith(&#39;R&#39;):
<span class="w"> </span>                char = getch()
<span class="gi">+</span>
<span class="w"> </span>                if char is not None:
<span class="w"> </span>                    res += char
<span class="gi">+</span>
<span class="w"> </span>            res_list = res[2:-1].split(&#39;;&#39;)
<span class="gd">-            res_list = tuple(int(item) if item.isdigit() else item for item in</span>
<span class="gd">-                res_list)</span>
<span class="gi">+</span>
<span class="gi">+            res_list = tuple(</span>
<span class="gi">+                int(item) if item.isdigit() else item for item in res_list</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>            if len(res_list) == 1:
<span class="w"> </span>                return types.cast(types.Tuple[int, int], res_list[0])
<span class="gi">+</span>
<span class="w"> </span>            return types.cast(types.Tuple[int, int], tuple(res_list))

<span class="gi">+    def row(self, stream):</span>
<span class="gi">+        row, _ = self(stream)</span>
<span class="gi">+        return row</span>
<span class="gi">+</span>
<span class="gi">+    def column(self, stream):</span>
<span class="gi">+        _, column = self(stream)</span>
<span class="gi">+        return column</span>
<span class="gi">+</span>

<span class="w"> </span>class WindowsColors(enum.Enum):
<span class="w"> </span>    BLACK = 0, 0, 0
<span class="gu">@@ -99,7 +199,7 @@ class WindowsColors(enum.Enum):</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_rgb(rgb: types.Tuple[int, int, int]):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Find the closest WindowsColors to the given RGB color.

<span class="w"> </span>        &gt;&gt;&gt; WindowsColors.from_rgb((0, 0, 0))
<span class="gu">@@ -116,25 +216,40 @@ class WindowsColors(enum.Enum):</span>

<span class="w"> </span>        &gt;&gt;&gt; WindowsColors.from_rgb((128, 0, 128))
<span class="w"> </span>        &lt;WindowsColors.MAGENTA: (128, 0, 128)&gt;
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        def color_distance(rgb1, rgb2):</span>
<span class="gi">+            return sum((c1 - c2) ** 2 for c1, c2 in zip(rgb1, rgb2))</span>
<span class="gi">+</span>
<span class="gi">+        return min(</span>
<span class="gi">+            WindowsColors,</span>
<span class="gi">+            key=lambda color: color_distance(color.value, rgb),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class WindowsColor:
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Windows compatible color class for when ANSI is not supported.
<span class="w"> </span>    Currently a no-op because it is not possible to buffer these colors.

<span class="w"> </span>    &gt;&gt;&gt; WindowsColor(WindowsColors.RED)(&#39;test&#39;)
<span class="w"> </span>    &#39;test&#39;
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    __slots__ = &#39;color&#39;,</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&#39;color&#39;,)</span>

<span class="w"> </span>    def __init__(self, color: Color):
<span class="w"> </span>        self.color = color

<span class="w"> </span>    def __call__(self, text):
<span class="w"> </span>        return text
<span class="gi">+        ## In the future we might want to use this, but it requires direct</span>
<span class="gi">+        ## printing to stdout and all of our surrounding functions expect</span>
<span class="gi">+        ## buffered output so it&#39;s not feasible right now. Additionally,</span>
<span class="gi">+        ## recent Windows versions all support ANSI codes without issue so</span>
<span class="gi">+        ## there is little need.</span>
<span class="gi">+        # from progressbar.terminal.os_specific import windows</span>
<span class="gi">+        # windows.print_color(text, WindowsColors.from_rgb(self.color.rgb))</span>


<span class="w"> </span>class RGB(collections.namedtuple(&#39;RGB&#39;, [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;])):
<span class="gu">@@ -143,40 +258,98 @@ class RGB(collections.namedtuple(&#39;RGB&#39;, [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;])):</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.rgb

<span class="gi">+    @property</span>
<span class="gi">+    def rgb(self):</span>
<span class="gi">+        return f&#39;rgb({self.red}, {self.green}, {self.blue})&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def hex(self):</span>
<span class="gi">+        return f&#39;#{self.red:02x}{self.green:02x}{self.blue:02x}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def to_ansi_16(self):</span>
<span class="gi">+        # Using int instead of round because it maps slightly better</span>
<span class="gi">+        red = int(self.red / 255)</span>
<span class="gi">+        green = int(self.green / 255)</span>
<span class="gi">+        blue = int(self.blue / 255)</span>
<span class="gi">+        return (blue &lt;&lt; 2) | (green &lt;&lt; 1) | red</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def to_ansi_256(self):</span>
<span class="gi">+        red = round(self.red / 255 * 5)</span>
<span class="gi">+        green = round(self.green / 255 * 5)</span>
<span class="gi">+        blue = round(self.blue / 255 * 5)</span>
<span class="gi">+        return 16 + 36 * red + 6 * green + blue</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def to_windows(self):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Convert an RGB color (0-255 per channel) to the closest color in the
<span class="w"> </span>        Windows 16 color scheme.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        return WindowsColors.from_rgb((self.red, self.green, self.blue))</span>
<span class="gi">+</span>
<span class="gi">+    def interpolate(self, end: RGB, step: float) -&gt; RGB:</span>
<span class="gi">+        return RGB(</span>
<span class="gi">+            int(self.red + (end.red - self.red) * step),</span>
<span class="gi">+            int(self.green + (end.green - self.green) * step),</span>
<span class="gi">+            int(self.blue + (end.blue - self.blue) * step),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class HSL(collections.namedtuple(&#39;HSL&#39;, [&#39;hue&#39;, &#39;saturation&#39;, &#39;lightness&#39;])):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Hue, Saturation, Lightness color.

<span class="w"> </span>    Hue is a value between 0 and 360, saturation and lightness are between 0(%)
<span class="w"> </span>    and 100(%).

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_rgb(cls, rgb: RGB) -&gt;HSL:</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+    def from_rgb(cls, rgb: RGB) -&gt; HSL:</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Convert a 0-255 RGB color to a 0-255 HLS color.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        hls = colorsys.rgb_to_hls(</span>
<span class="gi">+            rgb.red / 255,</span>
<span class="gi">+            rgb.green / 255,</span>
<span class="gi">+            rgb.blue / 255,</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            round(hls[0] * 360),</span>
<span class="gi">+            round(hls[2] * 100),</span>
<span class="gi">+            round(hls[1] * 100),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def interpolate(self, end: HSL, step: float) -&gt; HSL:</span>
<span class="gi">+        return HSL(</span>
<span class="gi">+            self.hue + (end.hue - self.hue) * step,</span>
<span class="gi">+            self.lightness + (end.lightness - self.lightness) * step,</span>
<span class="gi">+            self.saturation + (end.saturation - self.saturation) * step,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ColorBase(abc.ABC):
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-class Color(collections.namedtuple(&#39;Color&#39;, [&#39;rgb&#39;, &#39;hls&#39;, &#39;name&#39;, &#39;xterm&#39;]</span>
<span class="gd">-    ), ColorBase):</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    def get_color(self, value: float) -&gt; Color:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Color(</span>
<span class="gi">+    collections.namedtuple(</span>
<span class="gi">+        &#39;Color&#39;,</span>
<span class="gi">+        [</span>
<span class="gi">+            &#39;rgb&#39;,</span>
<span class="gi">+            &#39;hls&#39;,</span>
<span class="gi">+            &#39;name&#39;,</span>
<span class="gi">+            &#39;xterm&#39;,</span>
<span class="gi">+        ],</span>
<span class="gi">+    ),</span>
<span class="gi">+    ColorBase,</span>
<span class="gi">+):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Color base class.

<span class="w"> </span>    This class contains the colors in RGB (Red, Green, Blue), HSL (Hue,
<span class="gu">@@ -186,12 +359,62 @@ class Color(collections.namedtuple(&#39;Color&#39;, [&#39;rgb&#39;, &#39;hls&#39;, &#39;name&#39;, &#39;xterm&#39;]</span>
<span class="w"> </span>    To make a custom color the only required arguments are the RGB values.
<span class="w"> </span>    The other values will be automatically interpolated from that if needed,
<span class="w"> </span>    but you can be more explicitly if you wish.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __call__(self, value: str) -&gt;str:</span>
<span class="gi">+    def __call__(self, value: str) -&gt; str:</span>
<span class="w"> </span>        return self.fg(value)

<span class="gi">+    @property</span>
<span class="gi">+    def fg(self):</span>
<span class="gi">+        if env.COLOR_SUPPORT is env.ColorSupport.WINDOWS:</span>
<span class="gi">+            return WindowsColor(self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SGRColor(self, 38, 39)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def bg(self):</span>
<span class="gi">+        if env.COLOR_SUPPORT is env.ColorSupport.WINDOWS:</span>
<span class="gi">+            return DummyColor()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SGRColor(self, 48, 49)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def underline(self):</span>
<span class="gi">+        if env.COLOR_SUPPORT is env.ColorSupport.WINDOWS:</span>
<span class="gi">+            return DummyColor()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SGRColor(self, 58, 59)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def ansi(self) -&gt; types.Optional[str]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            env.COLOR_SUPPORT is env.ColorSupport.XTERM_TRUECOLOR</span>
<span class="gi">+        ):  # pragma: no branch</span>
<span class="gi">+            return f&#39;2;{self.rgb.red};{self.rgb.green};{self.rgb.blue}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if self.xterm:  # pragma: no branch</span>
<span class="gi">+            color = self.xterm</span>
<span class="gi">+        elif (</span>
<span class="gi">+            env.COLOR_SUPPORT is env.ColorSupport.XTERM_256</span>
<span class="gi">+        ):  # pragma: no branch</span>
<span class="gi">+            color = self.rgb.to_ansi_256</span>
<span class="gi">+        elif env.COLOR_SUPPORT is env.ColorSupport.XTERM:  # pragma: no branch</span>
<span class="gi">+            color = self.rgb.to_ansi_16</span>
<span class="gi">+        else:  # pragma: no branch</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return f&#39;5;{color}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def interpolate(self, end: Color, step: float) -&gt; Color:</span>
<span class="gi">+        return Color(</span>
<span class="gi">+            self.rgb.interpolate(end.rgb, step),</span>
<span class="gi">+            self.hls.interpolate(end.hls, step),</span>
<span class="gi">+            self.name if step &lt; 0.5 else end.name,</span>
<span class="gi">+            self.xterm if step &lt; 0.5 else end.xterm,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.name

<span class="gu">@@ -203,51 +426,147 @@ class Color(collections.namedtuple(&#39;Color&#39;, [&#39;rgb&#39;, &#39;hls&#39;, &#39;name&#39;, &#39;xterm&#39;]</span>


<span class="w"> </span>class Colors:
<span class="gd">-    by_name: ClassVar[defaultdict[str, types.List[Color]]</span>
<span class="gd">-        ] = collections.defaultdict(list)</span>
<span class="gd">-    by_lowername: ClassVar[defaultdict[str, types.List[Color]]</span>
<span class="gd">-        ] = collections.defaultdict(list)</span>
<span class="gd">-    by_hex: ClassVar[defaultdict[str, types.List[Color]]</span>
<span class="gd">-        ] = collections.defaultdict(list)</span>
<span class="gd">-    by_rgb: ClassVar[defaultdict[RGB, types.List[Color]]</span>
<span class="gd">-        ] = collections.defaultdict(list)</span>
<span class="gd">-    by_hls: ClassVar[defaultdict[HSL, types.List[Color]]</span>
<span class="gd">-        ] = collections.defaultdict(list)</span>
<span class="gi">+    by_name: ClassVar[defaultdict[str, types.List[Color]]] = (</span>
<span class="gi">+        collections.defaultdict(list)</span>
<span class="gi">+    )</span>
<span class="gi">+    by_lowername: ClassVar[defaultdict[str, types.List[Color]]] = (</span>
<span class="gi">+        collections.defaultdict(list)</span>
<span class="gi">+    )</span>
<span class="gi">+    by_hex: ClassVar[defaultdict[str, types.List[Color]]] = (</span>
<span class="gi">+        collections.defaultdict(list)</span>
<span class="gi">+    )</span>
<span class="gi">+    by_rgb: ClassVar[defaultdict[RGB, types.List[Color]]] = (</span>
<span class="gi">+        collections.defaultdict(list)</span>
<span class="gi">+    )</span>
<span class="gi">+    by_hls: ClassVar[defaultdict[HSL, types.List[Color]]] = (</span>
<span class="gi">+        collections.defaultdict(list)</span>
<span class="gi">+    )</span>
<span class="w"> </span>    by_xterm: ClassVar[dict[int, Color]] = dict()

<span class="gi">+    @classmethod</span>
<span class="gi">+    def register(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        rgb: RGB,</span>
<span class="gi">+        hls: types.Optional[HSL] = None,</span>
<span class="gi">+        name: types.Optional[str] = None,</span>
<span class="gi">+        xterm: types.Optional[int] = None,</span>
<span class="gi">+    ) -&gt; Color:</span>
<span class="gi">+        color = Color(rgb, hls, name, xterm)</span>
<span class="gi">+</span>
<span class="gi">+        if name:</span>
<span class="gi">+            cls.by_name[name].append(color)</span>
<span class="gi">+            cls.by_lowername[name.lower()].append(color)</span>

<span class="gd">-class ColorGradient(ColorBase):</span>
<span class="gi">+        if hls is None:</span>
<span class="gi">+            hls = HSL.from_rgb(rgb)</span>
<span class="gi">+</span>
<span class="gi">+        cls.by_hex[rgb.hex].append(color)</span>
<span class="gi">+        cls.by_rgb[rgb].append(color)</span>
<span class="gi">+        cls.by_hls[hls].append(color)</span>
<span class="gi">+</span>
<span class="gi">+        if xterm is not None:</span>
<span class="gi">+            cls.by_xterm[xterm] = color</span>
<span class="gi">+</span>
<span class="gi">+        return color</span>

<span class="gi">+    @classmethod</span>
<span class="gi">+    def interpolate(cls, color_a: Color, color_b: Color, step: float) -&gt; Color:</span>
<span class="gi">+        return color_a.interpolate(color_b, step)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ColorGradient(ColorBase):</span>
<span class="w"> </span>    def __init__(self, *colors: Color, interpolate=Colors.interpolate):
<span class="w"> </span>        assert colors
<span class="w"> </span>        self.colors = colors
<span class="w"> </span>        self.interpolate = interpolate

<span class="gd">-    def __call__(self, value: float) -&gt;Color:</span>
<span class="gi">+    def __call__(self, value: float) -&gt; Color:</span>
<span class="w"> </span>        return self.get_color(value)

<span class="gd">-    def get_color(self, value: float) -&gt;Color:</span>
<span class="gd">-        &quot;&quot;&quot;Map a value from 0 to 1 to a color.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_color(self, value: float) -&gt; Color:</span>
<span class="gi">+        &#39;Map a value from 0 to 1 to a color.&#39;</span>
<span class="gi">+        if (</span>
<span class="gi">+            value == pbase.Undefined</span>
<span class="gi">+            or value == pbase.UnknownLength</span>
<span class="gi">+            or value &lt;= 0</span>
<span class="gi">+        ):</span>
<span class="gi">+            return self.colors[0]</span>
<span class="gi">+        elif value &gt;= 1:</span>
<span class="gi">+            return self.colors[-1]</span>
<span class="gi">+</span>
<span class="gi">+        max_color_idx = len(self.colors) - 1</span>
<span class="gi">+        if max_color_idx == 0:</span>
<span class="gi">+            return self.colors[0]</span>
<span class="gi">+        elif self.interpolate:</span>
<span class="gi">+            if max_color_idx &gt; 1:</span>
<span class="gi">+                index = round(</span>
<span class="gi">+                    converters.remap(value, 0, 1, 0, max_color_idx - 1),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                index = 0</span>
<span class="gi">+</span>
<span class="gi">+            step = converters.remap(</span>
<span class="gi">+                value,</span>
<span class="gi">+                index / (max_color_idx),</span>
<span class="gi">+                (index + 1) / (max_color_idx),</span>
<span class="gi">+                0,</span>
<span class="gi">+                1,</span>
<span class="gi">+            )</span>
<span class="gi">+            color = self.interpolate(</span>
<span class="gi">+                self.colors[index],</span>
<span class="gi">+                self.colors[index + 1],</span>
<span class="gi">+                float(step),</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            index = round(converters.remap(value, 0, 1, 0, max_color_idx))</span>
<span class="gi">+            color = self.colors[index]</span>
<span class="gi">+</span>
<span class="gi">+        return color</span>


<span class="w"> </span>OptionalColor = types.Union[Color, ColorGradient, None]


<span class="gd">-def apply_colors(text: str, percentage: (float | None)=None, *, fg:</span>
<span class="gd">-    OptionalColor=None, bg: OptionalColor=None, fg_none: (Color | None)=</span>
<span class="gd">-    None, bg_none: (Color | None)=None, **kwargs: types.Any) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Apply colors/gradients to a string depending on the given percentage.</span>
<span class="gi">+def get_color(value: float, color: OptionalColor) -&gt; Color | None:</span>
<span class="gi">+    if isinstance(color, ColorGradient):</span>
<span class="gi">+        color = color(value)</span>
<span class="gi">+    return color</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_colors(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    percentage: float | None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    fg: OptionalColor = None,</span>
<span class="gi">+    bg: OptionalColor = None,</span>
<span class="gi">+    fg_none: Color | None = None,</span>
<span class="gi">+    bg_none: Color | None = None,</span>
<span class="gi">+    **kwargs: types.Any,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    &#39;&#39;&#39;Apply colors/gradients to a string depending on the given percentage.</span>

<span class="w"> </span>    When percentage is `None`, the `fg_none` and `bg_none` colors will be used.
<span class="w"> </span>    Otherwise, the `fg` and `bg` colors will be used. If the colors are
<span class="w"> </span>    gradients, the color will be interpolated depending on the percentage.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    if percentage is None:</span>
<span class="gi">+        if fg_none is not None:</span>
<span class="gi">+            text = fg_none.fg(text)</span>
<span class="gi">+        if bg_none is not None:</span>
<span class="gi">+            text = bg_none.bg(text)</span>
<span class="gi">+    elif fg is not None or bg is not None:</span>
<span class="gi">+        fg = get_color(percentage * 0.01, fg)</span>
<span class="gi">+        bg = get_color(percentage * 0.01, bg)</span>

<span class="gi">+        if fg is not None:  # pragma: no branch</span>
<span class="gi">+            text = fg.fg(text)</span>
<span class="gi">+        if bg is not None:  # pragma: no branch</span>
<span class="gi">+            text = bg.bg(text)</span>
<span class="gi">+</span>
<span class="gi">+    return text</span>

<span class="gd">-class DummyColor:</span>

<span class="gi">+class DummyColor:</span>
<span class="w"> </span>    def __call__(self, text):
<span class="w"> </span>        return text

<span class="gu">@@ -265,6 +584,14 @@ class SGR(CSI):</span>
<span class="w"> </span>        self._start_code = start_code
<span class="w"> </span>        self._end_code = end_code

<span class="gi">+    @property</span>
<span class="gi">+    def _start_template(self):</span>
<span class="gi">+        return super().__call__(self._start_code)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _end_template(self):</span>
<span class="gi">+        return super().__call__(self._end_code)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __call__(self, text, *args):
<span class="w"> </span>        return self._start_template + text + self._end_template

<span class="gu">@@ -276,6 +603,10 @@ class SGRColor(SGR):</span>
<span class="w"> </span>        self._color = color
<span class="w"> </span>        super().__init__(start_code, end_code)

<span class="gi">+    @property</span>
<span class="gi">+    def _start_template(self):</span>
<span class="gi">+        return CSI.__call__(self, self._start_code, self._color.ansi)</span>
<span class="gi">+</span>

<span class="w"> </span>encircled = SGR(52, 54)
<span class="w"> </span>framed = SGR(51, 54)
<span class="gh">diff --git a/progressbar/terminal/colors.py b/progressbar/terminal/colors.py</span>
<span class="gh">index 95e6de2..53354ac 100644</span>
<span class="gd">--- a/progressbar/terminal/colors.py</span>
<span class="gi">+++ b/progressbar/terminal/colors.py</span>
<span class="gu">@@ -1,5 +1,8 @@</span>
<span class="gi">+# Based on: https://www.ditig.com/256-colors-cheat-sheet</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from progressbar.terminal.base import HSL, RGB, ColorGradient, Colors
<span class="gi">+</span>
<span class="w"> </span>black = Colors.register(RGB(0, 0, 0), HSL(0, 0, 0), &#39;Black&#39;, 0)
<span class="w"> </span>maroon = Colors.register(RGB(128, 0, 0), HSL(0, 100, 25), &#39;Maroon&#39;, 1)
<span class="w"> </span>green = Colors.register(RGB(0, 128, 0), HSL(120, 100, 25), &#39;Green&#39;, 2)
<span class="gu">@@ -23,369 +26,989 @@ blue3 = Colors.register(RGB(0, 0, 175), HSL(240, 100, 34), &#39;Blue3&#39;, 19)</span>
<span class="w"> </span>blue3 = Colors.register(RGB(0, 0, 215), HSL(240, 100, 42), &#39;Blue3&#39;, 20)
<span class="w"> </span>blue1 = Colors.register(RGB(0, 0, 255), HSL(240, 100, 50), &#39;Blue1&#39;, 21)
<span class="w"> </span>dark_green = Colors.register(RGB(0, 95, 0), HSL(120, 100, 18), &#39;DarkGreen&#39;, 22)
<span class="gd">-deep_sky_blue4 = Colors.register(RGB(0, 95, 95), HSL(180, 100, 18),</span>
<span class="gd">-    &#39;DeepSkyBlue4&#39;, 23)</span>
<span class="gd">-deep_sky_blue4 = Colors.register(RGB(0, 95, 135), HSL(97, 100, 26),</span>
<span class="gd">-    &#39;DeepSkyBlue4&#39;, 24)</span>
<span class="gd">-deep_sky_blue4 = Colors.register(RGB(0, 95, 175), HSL(7, 100, 34),</span>
<span class="gd">-    &#39;DeepSkyBlue4&#39;, 25)</span>
<span class="gd">-dodger_blue3 = Colors.register(RGB(0, 95, 215), HSL(13, 100, 42),</span>
<span class="gd">-    &#39;DodgerBlue3&#39;, 26)</span>
<span class="gd">-dodger_blue2 = Colors.register(RGB(0, 95, 255), HSL(17, 100, 50),</span>
<span class="gd">-    &#39;DodgerBlue2&#39;, 27)</span>
<span class="gi">+deep_sky_blue4 = Colors.register(</span>
<span class="gi">+    RGB(0, 95, 95),</span>
<span class="gi">+    HSL(180, 100, 18),</span>
<span class="gi">+    &#39;DeepSkyBlue4&#39;,</span>
<span class="gi">+    23,</span>
<span class="gi">+)</span>
<span class="gi">+deep_sky_blue4 = Colors.register(</span>
<span class="gi">+    RGB(0, 95, 135),</span>
<span class="gi">+    HSL(97, 100, 26),</span>
<span class="gi">+    &#39;DeepSkyBlue4&#39;,</span>
<span class="gi">+    24,</span>
<span class="gi">+)</span>
<span class="gi">+deep_sky_blue4 = Colors.register(</span>
<span class="gi">+    RGB(0, 95, 175),</span>
<span class="gi">+    HSL(7, 100, 34),</span>
<span class="gi">+    &#39;DeepSkyBlue4&#39;,</span>
<span class="gi">+    25,</span>
<span class="gi">+)</span>
<span class="gi">+dodger_blue3 = Colors.register(</span>
<span class="gi">+    RGB(0, 95, 215),</span>
<span class="gi">+    HSL(13, 100, 42),</span>
<span class="gi">+    &#39;DodgerBlue3&#39;,</span>
<span class="gi">+    26,</span>
<span class="gi">+)</span>
<span class="gi">+dodger_blue2 = Colors.register(</span>
<span class="gi">+    RGB(0, 95, 255),</span>
<span class="gi">+    HSL(17, 100, 50),</span>
<span class="gi">+    &#39;DodgerBlue2&#39;,</span>
<span class="gi">+    27,</span>
<span class="gi">+)</span>
<span class="w"> </span>green4 = Colors.register(RGB(0, 135, 0), HSL(120, 100, 26), &#39;Green4&#39;, 28)
<span class="gd">-spring_green4 = Colors.register(RGB(0, 135, 95), HSL(62, 100, 26),</span>
<span class="gd">-    &#39;SpringGreen4&#39;, 29)</span>
<span class="gd">-turquoise4 = Colors.register(RGB(0, 135, 135), HSL(180, 100, 26),</span>
<span class="gd">-    &#39;Turquoise4&#39;, 30)</span>
<span class="gd">-deep_sky_blue3 = Colors.register(RGB(0, 135, 175), HSL(93, 100, 34),</span>
<span class="gd">-    &#39;DeepSkyBlue3&#39;, 31)</span>
<span class="gd">-deep_sky_blue3 = Colors.register(RGB(0, 135, 215), HSL(2, 100, 42),</span>
<span class="gd">-    &#39;DeepSkyBlue3&#39;, 32)</span>
<span class="gd">-dodger_blue1 = Colors.register(RGB(0, 135, 255), HSL(8, 100, 50),</span>
<span class="gd">-    &#39;DodgerBlue1&#39;, 33)</span>
<span class="gi">+spring_green4 = Colors.register(</span>
<span class="gi">+    RGB(0, 135, 95),</span>
<span class="gi">+    HSL(62, 100, 26),</span>
<span class="gi">+    &#39;SpringGreen4&#39;,</span>
<span class="gi">+    29,</span>
<span class="gi">+)</span>
<span class="gi">+turquoise4 = Colors.register(</span>
<span class="gi">+    RGB(0, 135, 135),</span>
<span class="gi">+    HSL(180, 100, 26),</span>
<span class="gi">+    &#39;Turquoise4&#39;,</span>
<span class="gi">+    30,</span>
<span class="gi">+)</span>
<span class="gi">+deep_sky_blue3 = Colors.register(</span>
<span class="gi">+    RGB(0, 135, 175),</span>
<span class="gi">+    HSL(93, 100, 34),</span>
<span class="gi">+    &#39;DeepSkyBlue3&#39;,</span>
<span class="gi">+    31,</span>
<span class="gi">+)</span>
<span class="gi">+deep_sky_blue3 = Colors.register(</span>
<span class="gi">+    RGB(0, 135, 215),</span>
<span class="gi">+    HSL(2, 100, 42),</span>
<span class="gi">+    &#39;DeepSkyBlue3&#39;,</span>
<span class="gi">+    32,</span>
<span class="gi">+)</span>
<span class="gi">+dodger_blue1 = Colors.register(</span>
<span class="gi">+    RGB(0, 135, 255),</span>
<span class="gi">+    HSL(8, 100, 50),</span>
<span class="gi">+    &#39;DodgerBlue1&#39;,</span>
<span class="gi">+    33,</span>
<span class="gi">+)</span>
<span class="w"> </span>green3 = Colors.register(RGB(0, 175, 0), HSL(120, 100, 34), &#39;Green3&#39;, 34)
<span class="gd">-spring_green3 = Colors.register(RGB(0, 175, 95), HSL(52, 100, 34),</span>
<span class="gd">-    &#39;SpringGreen3&#39;, 35)</span>
<span class="gi">+spring_green3 = Colors.register(</span>
<span class="gi">+    RGB(0, 175, 95),</span>
<span class="gi">+    HSL(52, 100, 34),</span>
<span class="gi">+    &#39;SpringGreen3&#39;,</span>
<span class="gi">+    35,</span>
<span class="gi">+)</span>
<span class="w"> </span>dark_cyan = Colors.register(RGB(0, 175, 135), HSL(66, 100, 34), &#39;DarkCyan&#39;, 36)
<span class="gd">-light_sea_green = Colors.register(RGB(0, 175, 175), HSL(180, 100, 34),</span>
<span class="gd">-    &#39;LightSeaGreen&#39;, 37)</span>
<span class="gd">-deep_sky_blue2 = Colors.register(RGB(0, 175, 215), HSL(91, 100, 42),</span>
<span class="gd">-    &#39;DeepSkyBlue2&#39;, 38)</span>
<span class="gd">-deep_sky_blue1 = Colors.register(RGB(0, 175, 255), HSL(98, 100, 50),</span>
<span class="gd">-    &#39;DeepSkyBlue1&#39;, 39)</span>
<span class="gi">+light_sea_green = Colors.register(</span>
<span class="gi">+    RGB(0, 175, 175),</span>
<span class="gi">+    HSL(180, 100, 34),</span>
<span class="gi">+    &#39;LightSeaGreen&#39;,</span>
<span class="gi">+    37,</span>
<span class="gi">+)</span>
<span class="gi">+deep_sky_blue2 = Colors.register(</span>
<span class="gi">+    RGB(0, 175, 215),</span>
<span class="gi">+    HSL(91, 100, 42),</span>
<span class="gi">+    &#39;DeepSkyBlue2&#39;,</span>
<span class="gi">+    38,</span>
<span class="gi">+)</span>
<span class="gi">+deep_sky_blue1 = Colors.register(</span>
<span class="gi">+    RGB(0, 175, 255),</span>
<span class="gi">+    HSL(98, 100, 50),</span>
<span class="gi">+    &#39;DeepSkyBlue1&#39;,</span>
<span class="gi">+    39,</span>
<span class="gi">+)</span>
<span class="w"> </span>green3 = Colors.register(RGB(0, 215, 0), HSL(120, 100, 42), &#39;Green3&#39;, 40)
<span class="gd">-spring_green3 = Colors.register(RGB(0, 215, 95), HSL(46, 100, 42),</span>
<span class="gd">-    &#39;SpringGreen3&#39;, 41)</span>
<span class="gd">-spring_green2 = Colors.register(RGB(0, 215, 135), HSL(57, 100, 42),</span>
<span class="gd">-    &#39;SpringGreen2&#39;, 42)</span>
<span class="gi">+spring_green3 = Colors.register(</span>
<span class="gi">+    RGB(0, 215, 95),</span>
<span class="gi">+    HSL(46, 100, 42),</span>
<span class="gi">+    &#39;SpringGreen3&#39;,</span>
<span class="gi">+    41,</span>
<span class="gi">+)</span>
<span class="gi">+spring_green2 = Colors.register(</span>
<span class="gi">+    RGB(0, 215, 135),</span>
<span class="gi">+    HSL(57, 100, 42),</span>
<span class="gi">+    &#39;SpringGreen2&#39;,</span>
<span class="gi">+    42,</span>
<span class="gi">+)</span>
<span class="w"> </span>cyan3 = Colors.register(RGB(0, 215, 175), HSL(68, 100, 42), &#39;Cyan3&#39;, 43)
<span class="gd">-dark_turquoise = Colors.register(RGB(0, 215, 215), HSL(180, 100, 42),</span>
<span class="gd">-    &#39;DarkTurquoise&#39;, 44)</span>
<span class="gd">-turquoise2 = Colors.register(RGB(0, 215, 255), HSL(89, 100, 50),</span>
<span class="gd">-    &#39;Turquoise2&#39;, 45)</span>
<span class="gi">+dark_turquoise = Colors.register(</span>
<span class="gi">+    RGB(0, 215, 215),</span>
<span class="gi">+    HSL(180, 100, 42),</span>
<span class="gi">+    &#39;DarkTurquoise&#39;,</span>
<span class="gi">+    44,</span>
<span class="gi">+)</span>
<span class="gi">+turquoise2 = Colors.register(</span>
<span class="gi">+    RGB(0, 215, 255),</span>
<span class="gi">+    HSL(89, 100, 50),</span>
<span class="gi">+    &#39;Turquoise2&#39;,</span>
<span class="gi">+    45,</span>
<span class="gi">+)</span>
<span class="w"> </span>green1 = Colors.register(RGB(0, 255, 0), HSL(120, 100, 50), &#39;Green1&#39;, 46)
<span class="gd">-spring_green2 = Colors.register(RGB(0, 255, 95), HSL(42, 100, 50),</span>
<span class="gd">-    &#39;SpringGreen2&#39;, 47)</span>
<span class="gd">-spring_green1 = Colors.register(RGB(0, 255, 135), HSL(51, 100, 50),</span>
<span class="gd">-    &#39;SpringGreen1&#39;, 48)</span>
<span class="gd">-medium_spring_green = Colors.register(RGB(0, 255, 175), HSL(61, 100, 50),</span>
<span class="gd">-    &#39;MediumSpringGreen&#39;, 49)</span>
<span class="gi">+spring_green2 = Colors.register(</span>
<span class="gi">+    RGB(0, 255, 95),</span>
<span class="gi">+    HSL(42, 100, 50),</span>
<span class="gi">+    &#39;SpringGreen2&#39;,</span>
<span class="gi">+    47,</span>
<span class="gi">+)</span>
<span class="gi">+spring_green1 = Colors.register(</span>
<span class="gi">+    RGB(0, 255, 135),</span>
<span class="gi">+    HSL(51, 100, 50),</span>
<span class="gi">+    &#39;SpringGreen1&#39;,</span>
<span class="gi">+    48,</span>
<span class="gi">+)</span>
<span class="gi">+medium_spring_green = Colors.register(</span>
<span class="gi">+    RGB(0, 255, 175),</span>
<span class="gi">+    HSL(61, 100, 50),</span>
<span class="gi">+    &#39;MediumSpringGreen&#39;,</span>
<span class="gi">+    49,</span>
<span class="gi">+)</span>
<span class="w"> </span>cyan2 = Colors.register(RGB(0, 255, 215), HSL(70, 100, 50), &#39;Cyan2&#39;, 50)
<span class="w"> </span>cyan1 = Colors.register(RGB(0, 255, 255), HSL(180, 100, 50), &#39;Cyan1&#39;, 51)
<span class="w"> </span>dark_red = Colors.register(RGB(95, 0, 0), HSL(0, 100, 18), &#39;DarkRed&#39;, 52)
<span class="gd">-deep_pink4 = Colors.register(RGB(95, 0, 95), HSL(300, 100, 18), &#39;DeepPink4&#39;, 53</span>
<span class="gd">-    )</span>
<span class="gi">+deep_pink4 = Colors.register(</span>
<span class="gi">+    RGB(95, 0, 95),</span>
<span class="gi">+    HSL(300, 100, 18),</span>
<span class="gi">+    &#39;DeepPink4&#39;,</span>
<span class="gi">+    53,</span>
<span class="gi">+)</span>
<span class="w"> </span>purple4 = Colors.register(RGB(95, 0, 135), HSL(82, 100, 26), &#39;Purple4&#39;, 54)
<span class="w"> </span>purple4 = Colors.register(RGB(95, 0, 175), HSL(72, 100, 34), &#39;Purple4&#39;, 55)
<span class="w"> </span>purple3 = Colors.register(RGB(95, 0, 215), HSL(66, 100, 42), &#39;Purple3&#39;, 56)
<span class="gd">-blue_violet = Colors.register(RGB(95, 0, 255), HSL(62, 100, 50),</span>
<span class="gd">-    &#39;BlueViolet&#39;, 57)</span>
<span class="gi">+blue_violet = Colors.register(</span>
<span class="gi">+    RGB(95, 0, 255),</span>
<span class="gi">+    HSL(62, 100, 50),</span>
<span class="gi">+    &#39;BlueViolet&#39;,</span>
<span class="gi">+    57,</span>
<span class="gi">+)</span>
<span class="w"> </span>orange4 = Colors.register(RGB(95, 95, 0), HSL(60, 100, 18), &#39;Orange4&#39;, 58)
<span class="w"> </span>grey37 = Colors.register(RGB(95, 95, 95), HSL(0, 0, 37), &#39;Grey37&#39;, 59)
<span class="gd">-medium_purple4 = Colors.register(RGB(95, 95, 135), HSL(240, 17, 45),</span>
<span class="gd">-    &#39;MediumPurple4&#39;, 60)</span>
<span class="gd">-slate_blue3 = Colors.register(RGB(95, 95, 175), HSL(240, 33, 52),</span>
<span class="gd">-    &#39;SlateBlue3&#39;, 61)</span>
<span class="gd">-slate_blue3 = Colors.register(RGB(95, 95, 215), HSL(240, 60, 60),</span>
<span class="gd">-    &#39;SlateBlue3&#39;, 62)</span>
<span class="gd">-royal_blue1 = Colors.register(RGB(95, 95, 255), HSL(240, 100, 68),</span>
<span class="gd">-    &#39;RoyalBlue1&#39;, 63)</span>
<span class="gd">-chartreuse4 = Colors.register(RGB(95, 135, 0), HSL(7, 100, 26),</span>
<span class="gd">-    &#39;Chartreuse4&#39;, 64)</span>
<span class="gd">-dark_sea_green4 = Colors.register(RGB(95, 135, 95), HSL(120, 17, 45),</span>
<span class="gd">-    &#39;DarkSeaGreen4&#39;, 65)</span>
<span class="gd">-pale_turquoise4 = Colors.register(RGB(95, 135, 135), HSL(180, 17, 45),</span>
<span class="gd">-    &#39;PaleTurquoise4&#39;, 66)</span>
<span class="gd">-steel_blue = Colors.register(RGB(95, 135, 175), HSL(210, 33, 52),</span>
<span class="gd">-    &#39;SteelBlue&#39;, 67)</span>
<span class="gd">-steel_blue3 = Colors.register(RGB(95, 135, 215), HSL(220, 60, 60),</span>
<span class="gd">-    &#39;SteelBlue3&#39;, 68)</span>
<span class="gd">-cornflower_blue = Colors.register(RGB(95, 135, 255), HSL(225, 100, 68),</span>
<span class="gd">-    &#39;CornflowerBlue&#39;, 69)</span>
<span class="gd">-chartreuse3 = Colors.register(RGB(95, 175, 0), HSL(7, 100, 34),</span>
<span class="gd">-    &#39;Chartreuse3&#39;, 70)</span>
<span class="gd">-dark_sea_green4 = Colors.register(RGB(95, 175, 95), HSL(120, 33, 52),</span>
<span class="gd">-    &#39;DarkSeaGreen4&#39;, 71)</span>
<span class="gd">-cadet_blue = Colors.register(RGB(95, 175, 135), HSL(150, 33, 52),</span>
<span class="gd">-    &#39;CadetBlue&#39;, 72)</span>
<span class="gd">-cadet_blue = Colors.register(RGB(95, 175, 175), HSL(180, 33, 52),</span>
<span class="gd">-    &#39;CadetBlue&#39;, 73)</span>
<span class="gd">-sky_blue3 = Colors.register(RGB(95, 175, 215), HSL(200, 60, 60), &#39;SkyBlue3&#39;, 74</span>
<span class="gd">-    )</span>
<span class="gd">-steel_blue1 = Colors.register(RGB(95, 175, 255), HSL(210, 100, 68),</span>
<span class="gd">-    &#39;SteelBlue1&#39;, 75)</span>
<span class="gd">-chartreuse3 = Colors.register(RGB(95, 215, 0), HSL(3, 100, 42),</span>
<span class="gd">-    &#39;Chartreuse3&#39;, 76)</span>
<span class="gd">-pale_green3 = Colors.register(RGB(95, 215, 95), HSL(120, 60, 60),</span>
<span class="gd">-    &#39;PaleGreen3&#39;, 77)</span>
<span class="gd">-sea_green3 = Colors.register(RGB(95, 215, 135), HSL(140, 60, 60),</span>
<span class="gd">-    &#39;SeaGreen3&#39;, 78)</span>
<span class="gd">-aquamarine3 = Colors.register(RGB(95, 215, 175), HSL(160, 60, 60),</span>
<span class="gd">-    &#39;Aquamarine3&#39;, 79)</span>
<span class="gd">-medium_turquoise = Colors.register(RGB(95, 215, 215), HSL(180, 60, 60),</span>
<span class="gd">-    &#39;MediumTurquoise&#39;, 80)</span>
<span class="gd">-steel_blue1 = Colors.register(RGB(95, 215, 255), HSL(195, 100, 68),</span>
<span class="gd">-    &#39;SteelBlue1&#39;, 81)</span>
<span class="gd">-chartreuse2 = Colors.register(RGB(95, 255, 0), HSL(7, 100, 50),</span>
<span class="gd">-    &#39;Chartreuse2&#39;, 82)</span>
<span class="gd">-sea_green2 = Colors.register(RGB(95, 255, 95), HSL(120, 100, 68),</span>
<span class="gd">-    &#39;SeaGreen2&#39;, 83)</span>
<span class="gd">-sea_green1 = Colors.register(RGB(95, 255, 135), HSL(135, 100, 68),</span>
<span class="gd">-    &#39;SeaGreen1&#39;, 84)</span>
<span class="gd">-sea_green1 = Colors.register(RGB(95, 255, 175), HSL(150, 100, 68),</span>
<span class="gd">-    &#39;SeaGreen1&#39;, 85)</span>
<span class="gd">-aquamarine1 = Colors.register(RGB(95, 255, 215), HSL(165, 100, 68),</span>
<span class="gd">-    &#39;Aquamarine1&#39;, 86)</span>
<span class="gd">-dark_slate_gray2 = Colors.register(RGB(95, 255, 255), HSL(180, 100, 68),</span>
<span class="gd">-    &#39;DarkSlateGray2&#39;, 87)</span>
<span class="gi">+medium_purple4 = Colors.register(</span>
<span class="gi">+    RGB(95, 95, 135),</span>
<span class="gi">+    HSL(240, 17, 45),</span>
<span class="gi">+    &#39;MediumPurple4&#39;,</span>
<span class="gi">+    60,</span>
<span class="gi">+)</span>
<span class="gi">+slate_blue3 = Colors.register(</span>
<span class="gi">+    RGB(95, 95, 175),</span>
<span class="gi">+    HSL(240, 33, 52),</span>
<span class="gi">+    &#39;SlateBlue3&#39;,</span>
<span class="gi">+    61,</span>
<span class="gi">+)</span>
<span class="gi">+slate_blue3 = Colors.register(</span>
<span class="gi">+    RGB(95, 95, 215),</span>
<span class="gi">+    HSL(240, 60, 60),</span>
<span class="gi">+    &#39;SlateBlue3&#39;,</span>
<span class="gi">+    62,</span>
<span class="gi">+)</span>
<span class="gi">+royal_blue1 = Colors.register(</span>
<span class="gi">+    RGB(95, 95, 255),</span>
<span class="gi">+    HSL(240, 100, 68),</span>
<span class="gi">+    &#39;RoyalBlue1&#39;,</span>
<span class="gi">+    63,</span>
<span class="gi">+)</span>
<span class="gi">+chartreuse4 = Colors.register(</span>
<span class="gi">+    RGB(95, 135, 0),</span>
<span class="gi">+    HSL(7, 100, 26),</span>
<span class="gi">+    &#39;Chartreuse4&#39;,</span>
<span class="gi">+    64,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green4 = Colors.register(</span>
<span class="gi">+    RGB(95, 135, 95),</span>
<span class="gi">+    HSL(120, 17, 45),</span>
<span class="gi">+    &#39;DarkSeaGreen4&#39;,</span>
<span class="gi">+    65,</span>
<span class="gi">+)</span>
<span class="gi">+pale_turquoise4 = Colors.register(</span>
<span class="gi">+    RGB(95, 135, 135),</span>
<span class="gi">+    HSL(180, 17, 45),</span>
<span class="gi">+    &#39;PaleTurquoise4&#39;,</span>
<span class="gi">+    66,</span>
<span class="gi">+)</span>
<span class="gi">+steel_blue = Colors.register(</span>
<span class="gi">+    RGB(95, 135, 175),</span>
<span class="gi">+    HSL(210, 33, 52),</span>
<span class="gi">+    &#39;SteelBlue&#39;,</span>
<span class="gi">+    67,</span>
<span class="gi">+)</span>
<span class="gi">+steel_blue3 = Colors.register(</span>
<span class="gi">+    RGB(95, 135, 215),</span>
<span class="gi">+    HSL(220, 60, 60),</span>
<span class="gi">+    &#39;SteelBlue3&#39;,</span>
<span class="gi">+    68,</span>
<span class="gi">+)</span>
<span class="gi">+cornflower_blue = Colors.register(</span>
<span class="gi">+    RGB(95, 135, 255),</span>
<span class="gi">+    HSL(225, 100, 68),</span>
<span class="gi">+    &#39;CornflowerBlue&#39;,</span>
<span class="gi">+    69,</span>
<span class="gi">+)</span>
<span class="gi">+chartreuse3 = Colors.register(</span>
<span class="gi">+    RGB(95, 175, 0),</span>
<span class="gi">+    HSL(7, 100, 34),</span>
<span class="gi">+    &#39;Chartreuse3&#39;,</span>
<span class="gi">+    70,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green4 = Colors.register(</span>
<span class="gi">+    RGB(95, 175, 95),</span>
<span class="gi">+    HSL(120, 33, 52),</span>
<span class="gi">+    &#39;DarkSeaGreen4&#39;,</span>
<span class="gi">+    71,</span>
<span class="gi">+)</span>
<span class="gi">+cadet_blue = Colors.register(</span>
<span class="gi">+    RGB(95, 175, 135),</span>
<span class="gi">+    HSL(150, 33, 52),</span>
<span class="gi">+    &#39;CadetBlue&#39;,</span>
<span class="gi">+    72,</span>
<span class="gi">+)</span>
<span class="gi">+cadet_blue = Colors.register(</span>
<span class="gi">+    RGB(95, 175, 175),</span>
<span class="gi">+    HSL(180, 33, 52),</span>
<span class="gi">+    &#39;CadetBlue&#39;,</span>
<span class="gi">+    73,</span>
<span class="gi">+)</span>
<span class="gi">+sky_blue3 = Colors.register(</span>
<span class="gi">+    RGB(95, 175, 215),</span>
<span class="gi">+    HSL(200, 60, 60),</span>
<span class="gi">+    &#39;SkyBlue3&#39;,</span>
<span class="gi">+    74,</span>
<span class="gi">+)</span>
<span class="gi">+steel_blue1 = Colors.register(</span>
<span class="gi">+    RGB(95, 175, 255),</span>
<span class="gi">+    HSL(210, 100, 68),</span>
<span class="gi">+    &#39;SteelBlue1&#39;,</span>
<span class="gi">+    75,</span>
<span class="gi">+)</span>
<span class="gi">+chartreuse3 = Colors.register(</span>
<span class="gi">+    RGB(95, 215, 0),</span>
<span class="gi">+    HSL(3, 100, 42),</span>
<span class="gi">+    &#39;Chartreuse3&#39;,</span>
<span class="gi">+    76,</span>
<span class="gi">+)</span>
<span class="gi">+pale_green3 = Colors.register(</span>
<span class="gi">+    RGB(95, 215, 95),</span>
<span class="gi">+    HSL(120, 60, 60),</span>
<span class="gi">+    &#39;PaleGreen3&#39;,</span>
<span class="gi">+    77,</span>
<span class="gi">+)</span>
<span class="gi">+sea_green3 = Colors.register(</span>
<span class="gi">+    RGB(95, 215, 135),</span>
<span class="gi">+    HSL(140, 60, 60),</span>
<span class="gi">+    &#39;SeaGreen3&#39;,</span>
<span class="gi">+    78,</span>
<span class="gi">+)</span>
<span class="gi">+aquamarine3 = Colors.register(</span>
<span class="gi">+    RGB(95, 215, 175),</span>
<span class="gi">+    HSL(160, 60, 60),</span>
<span class="gi">+    &#39;Aquamarine3&#39;,</span>
<span class="gi">+    79,</span>
<span class="gi">+)</span>
<span class="gi">+medium_turquoise = Colors.register(</span>
<span class="gi">+    RGB(95, 215, 215),</span>
<span class="gi">+    HSL(180, 60, 60),</span>
<span class="gi">+    &#39;MediumTurquoise&#39;,</span>
<span class="gi">+    80,</span>
<span class="gi">+)</span>
<span class="gi">+steel_blue1 = Colors.register(</span>
<span class="gi">+    RGB(95, 215, 255),</span>
<span class="gi">+    HSL(195, 100, 68),</span>
<span class="gi">+    &#39;SteelBlue1&#39;,</span>
<span class="gi">+    81,</span>
<span class="gi">+)</span>
<span class="gi">+chartreuse2 = Colors.register(</span>
<span class="gi">+    RGB(95, 255, 0),</span>
<span class="gi">+    HSL(7, 100, 50),</span>
<span class="gi">+    &#39;Chartreuse2&#39;,</span>
<span class="gi">+    82,</span>
<span class="gi">+)</span>
<span class="gi">+sea_green2 = Colors.register(</span>
<span class="gi">+    RGB(95, 255, 95),</span>
<span class="gi">+    HSL(120, 100, 68),</span>
<span class="gi">+    &#39;SeaGreen2&#39;,</span>
<span class="gi">+    83,</span>
<span class="gi">+)</span>
<span class="gi">+sea_green1 = Colors.register(</span>
<span class="gi">+    RGB(95, 255, 135),</span>
<span class="gi">+    HSL(135, 100, 68),</span>
<span class="gi">+    &#39;SeaGreen1&#39;,</span>
<span class="gi">+    84,</span>
<span class="gi">+)</span>
<span class="gi">+sea_green1 = Colors.register(</span>
<span class="gi">+    RGB(95, 255, 175),</span>
<span class="gi">+    HSL(150, 100, 68),</span>
<span class="gi">+    &#39;SeaGreen1&#39;,</span>
<span class="gi">+    85,</span>
<span class="gi">+)</span>
<span class="gi">+aquamarine1 = Colors.register(</span>
<span class="gi">+    RGB(95, 255, 215),</span>
<span class="gi">+    HSL(165, 100, 68),</span>
<span class="gi">+    &#39;Aquamarine1&#39;,</span>
<span class="gi">+    86,</span>
<span class="gi">+)</span>
<span class="gi">+dark_slate_gray2 = Colors.register(</span>
<span class="gi">+    RGB(95, 255, 255),</span>
<span class="gi">+    HSL(180, 100, 68),</span>
<span class="gi">+    &#39;DarkSlateGray2&#39;,</span>
<span class="gi">+    87,</span>
<span class="gi">+)</span>
<span class="w"> </span>dark_red = Colors.register(RGB(135, 0, 0), HSL(0, 100, 26), &#39;DarkRed&#39;, 88)
<span class="gd">-deep_pink4 = Colors.register(RGB(135, 0, 95), HSL(17, 100, 26), &#39;DeepPink4&#39;, 89</span>
<span class="gd">-    )</span>
<span class="gd">-dark_magenta = Colors.register(RGB(135, 0, 135), HSL(300, 100, 26),</span>
<span class="gd">-    &#39;DarkMagenta&#39;, 90)</span>
<span class="gd">-dark_magenta = Colors.register(RGB(135, 0, 175), HSL(86, 100, 34),</span>
<span class="gd">-    &#39;DarkMagenta&#39;, 91)</span>
<span class="gd">-dark_violet = Colors.register(RGB(135, 0, 215), HSL(77, 100, 42),</span>
<span class="gd">-    &#39;DarkViolet&#39;, 92)</span>
<span class="gi">+deep_pink4 = Colors.register(</span>
<span class="gi">+    RGB(135, 0, 95),</span>
<span class="gi">+    HSL(17, 100, 26),</span>
<span class="gi">+    &#39;DeepPink4&#39;,</span>
<span class="gi">+    89,</span>
<span class="gi">+)</span>
<span class="gi">+dark_magenta = Colors.register(</span>
<span class="gi">+    RGB(135, 0, 135),</span>
<span class="gi">+    HSL(300, 100, 26),</span>
<span class="gi">+    &#39;DarkMagenta&#39;,</span>
<span class="gi">+    90,</span>
<span class="gi">+)</span>
<span class="gi">+dark_magenta = Colors.register(</span>
<span class="gi">+    RGB(135, 0, 175),</span>
<span class="gi">+    HSL(86, 100, 34),</span>
<span class="gi">+    &#39;DarkMagenta&#39;,</span>
<span class="gi">+    91,</span>
<span class="gi">+)</span>
<span class="gi">+dark_violet = Colors.register(</span>
<span class="gi">+    RGB(135, 0, 215),</span>
<span class="gi">+    HSL(77, 100, 42),</span>
<span class="gi">+    &#39;DarkViolet&#39;,</span>
<span class="gi">+    92,</span>
<span class="gi">+)</span>
<span class="w"> </span>purple = Colors.register(RGB(135, 0, 255), HSL(71, 100, 50), &#39;Purple&#39;, 93)
<span class="w"> </span>orange4 = Colors.register(RGB(135, 95, 0), HSL(2, 100, 26), &#39;Orange4&#39;, 94)
<span class="gd">-light_pink4 = Colors.register(RGB(135, 95, 95), HSL(0, 17, 45),</span>
<span class="gd">-    &#39;LightPink4&#39;, 95)</span>
<span class="gi">+light_pink4 = Colors.register(</span>
<span class="gi">+    RGB(135, 95, 95),</span>
<span class="gi">+    HSL(0, 17, 45),</span>
<span class="gi">+    &#39;LightPink4&#39;,</span>
<span class="gi">+    95,</span>
<span class="gi">+)</span>
<span class="w"> </span>plum4 = Colors.register(RGB(135, 95, 135), HSL(300, 17, 45), &#39;Plum4&#39;, 96)
<span class="gd">-medium_purple3 = Colors.register(RGB(135, 95, 175), HSL(270, 33, 52),</span>
<span class="gd">-    &#39;MediumPurple3&#39;, 97)</span>
<span class="gd">-medium_purple3 = Colors.register(RGB(135, 95, 215), HSL(260, 60, 60),</span>
<span class="gd">-    &#39;MediumPurple3&#39;, 98)</span>
<span class="gd">-slate_blue1 = Colors.register(RGB(135, 95, 255), HSL(255, 100, 68),</span>
<span class="gd">-    &#39;SlateBlue1&#39;, 99)</span>
<span class="gi">+medium_purple3 = Colors.register(</span>
<span class="gi">+    RGB(135, 95, 175),</span>
<span class="gi">+    HSL(270, 33, 52),</span>
<span class="gi">+    &#39;MediumPurple3&#39;,</span>
<span class="gi">+    97,</span>
<span class="gi">+)</span>
<span class="gi">+medium_purple3 = Colors.register(</span>
<span class="gi">+    RGB(135, 95, 215),</span>
<span class="gi">+    HSL(260, 60, 60),</span>
<span class="gi">+    &#39;MediumPurple3&#39;,</span>
<span class="gi">+    98,</span>
<span class="gi">+)</span>
<span class="gi">+slate_blue1 = Colors.register(</span>
<span class="gi">+    RGB(135, 95, 255),</span>
<span class="gi">+    HSL(255, 100, 68),</span>
<span class="gi">+    &#39;SlateBlue1&#39;,</span>
<span class="gi">+    99,</span>
<span class="gi">+)</span>
<span class="w"> </span>yellow4 = Colors.register(RGB(135, 135, 0), HSL(60, 100, 26), &#39;Yellow4&#39;, 100)
<span class="w"> </span>wheat4 = Colors.register(RGB(135, 135, 95), HSL(60, 17, 45), &#39;Wheat4&#39;, 101)
<span class="w"> </span>grey53 = Colors.register(RGB(135, 135, 135), HSL(0, 0, 52), &#39;Grey53&#39;, 102)
<span class="gd">-light_slate_grey = Colors.register(RGB(135, 135, 175), HSL(240, 20, 60),</span>
<span class="gd">-    &#39;LightSlateGrey&#39;, 103)</span>
<span class="gd">-medium_purple = Colors.register(RGB(135, 135, 215), HSL(240, 50, 68),</span>
<span class="gd">-    &#39;MediumPurple&#39;, 104)</span>
<span class="gd">-light_slate_blue = Colors.register(RGB(135, 135, 255), HSL(240, 100, 76),</span>
<span class="gd">-    &#39;LightSlateBlue&#39;, 105)</span>
<span class="gi">+light_slate_grey = Colors.register(</span>
<span class="gi">+    RGB(135, 135, 175),</span>
<span class="gi">+    HSL(240, 20, 60),</span>
<span class="gi">+    &#39;LightSlateGrey&#39;,</span>
<span class="gi">+    103,</span>
<span class="gi">+)</span>
<span class="gi">+medium_purple = Colors.register(</span>
<span class="gi">+    RGB(135, 135, 215),</span>
<span class="gi">+    HSL(240, 50, 68),</span>
<span class="gi">+    &#39;MediumPurple&#39;,</span>
<span class="gi">+    104,</span>
<span class="gi">+)</span>
<span class="gi">+light_slate_blue = Colors.register(</span>
<span class="gi">+    RGB(135, 135, 255),</span>
<span class="gi">+    HSL(240, 100, 76),</span>
<span class="gi">+    &#39;LightSlateBlue&#39;,</span>
<span class="gi">+    105,</span>
<span class="gi">+)</span>
<span class="w"> </span>yellow4 = Colors.register(RGB(135, 175, 0), HSL(3, 100, 34), &#39;Yellow4&#39;, 106)
<span class="gd">-dark_olive_green3 = Colors.register(RGB(135, 175, 95), HSL(90, 33, 52),</span>
<span class="gd">-    &#39;DarkOliveGreen3&#39;, 107)</span>
<span class="gd">-dark_sea_green = Colors.register(RGB(135, 175, 135), HSL(120, 20, 60),</span>
<span class="gd">-    &#39;DarkSeaGreen&#39;, 108)</span>
<span class="gd">-light_sky_blue3 = Colors.register(RGB(135, 175, 175), HSL(180, 20, 60),</span>
<span class="gd">-    &#39;LightSkyBlue3&#39;, 109)</span>
<span class="gd">-light_sky_blue3 = Colors.register(RGB(135, 175, 215), HSL(210, 50, 68),</span>
<span class="gd">-    &#39;LightSkyBlue3&#39;, 110)</span>
<span class="gd">-sky_blue2 = Colors.register(RGB(135, 175, 255), HSL(220, 100, 76),</span>
<span class="gd">-    &#39;SkyBlue2&#39;, 111)</span>
<span class="gd">-chartreuse2 = Colors.register(RGB(135, 215, 0), HSL(2, 100, 42),</span>
<span class="gd">-    &#39;Chartreuse2&#39;, 112)</span>
<span class="gd">-dark_olive_green3 = Colors.register(RGB(135, 215, 95), HSL(100, 60, 60),</span>
<span class="gd">-    &#39;DarkOliveGreen3&#39;, 113)</span>
<span class="gd">-pale_green3 = Colors.register(RGB(135, 215, 135), HSL(120, 50, 68),</span>
<span class="gd">-    &#39;PaleGreen3&#39;, 114)</span>
<span class="gd">-dark_sea_green3 = Colors.register(RGB(135, 215, 175), HSL(150, 50, 68),</span>
<span class="gd">-    &#39;DarkSeaGreen3&#39;, 115)</span>
<span class="gd">-dark_slate_gray3 = Colors.register(RGB(135, 215, 215), HSL(180, 50, 68),</span>
<span class="gd">-    &#39;DarkSlateGray3&#39;, 116)</span>
<span class="gd">-sky_blue1 = Colors.register(RGB(135, 215, 255), HSL(200, 100, 76),</span>
<span class="gd">-    &#39;SkyBlue1&#39;, 117)</span>
<span class="gd">-chartreuse1 = Colors.register(RGB(135, 255, 0), HSL(8, 100, 50),</span>
<span class="gd">-    &#39;Chartreuse1&#39;, 118)</span>
<span class="gd">-light_green = Colors.register(RGB(135, 255, 95), HSL(105, 100, 68),</span>
<span class="gd">-    &#39;LightGreen&#39;, 119)</span>
<span class="gd">-light_green = Colors.register(RGB(135, 255, 135), HSL(120, 100, 76),</span>
<span class="gd">-    &#39;LightGreen&#39;, 120)</span>
<span class="gd">-pale_green1 = Colors.register(RGB(135, 255, 175), HSL(140, 100, 76),</span>
<span class="gd">-    &#39;PaleGreen1&#39;, 121)</span>
<span class="gd">-aquamarine1 = Colors.register(RGB(135, 255, 215), HSL(160, 100, 76),</span>
<span class="gd">-    &#39;Aquamarine1&#39;, 122)</span>
<span class="gd">-dark_slate_gray1 = Colors.register(RGB(135, 255, 255), HSL(180, 100, 76),</span>
<span class="gd">-    &#39;DarkSlateGray1&#39;, 123)</span>
<span class="gi">+dark_olive_green3 = Colors.register(</span>
<span class="gi">+    RGB(135, 175, 95),</span>
<span class="gi">+    HSL(90, 33, 52),</span>
<span class="gi">+    &#39;DarkOliveGreen3&#39;,</span>
<span class="gi">+    107,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green = Colors.register(</span>
<span class="gi">+    RGB(135, 175, 135),</span>
<span class="gi">+    HSL(120, 20, 60),</span>
<span class="gi">+    &#39;DarkSeaGreen&#39;,</span>
<span class="gi">+    108,</span>
<span class="gi">+)</span>
<span class="gi">+light_sky_blue3 = Colors.register(</span>
<span class="gi">+    RGB(135, 175, 175),</span>
<span class="gi">+    HSL(180, 20, 60),</span>
<span class="gi">+    &#39;LightSkyBlue3&#39;,</span>
<span class="gi">+    109,</span>
<span class="gi">+)</span>
<span class="gi">+light_sky_blue3 = Colors.register(</span>
<span class="gi">+    RGB(135, 175, 215),</span>
<span class="gi">+    HSL(210, 50, 68),</span>
<span class="gi">+    &#39;LightSkyBlue3&#39;,</span>
<span class="gi">+    110,</span>
<span class="gi">+)</span>
<span class="gi">+sky_blue2 = Colors.register(</span>
<span class="gi">+    RGB(135, 175, 255),</span>
<span class="gi">+    HSL(220, 100, 76),</span>
<span class="gi">+    &#39;SkyBlue2&#39;,</span>
<span class="gi">+    111,</span>
<span class="gi">+)</span>
<span class="gi">+chartreuse2 = Colors.register(</span>
<span class="gi">+    RGB(135, 215, 0),</span>
<span class="gi">+    HSL(2, 100, 42),</span>
<span class="gi">+    &#39;Chartreuse2&#39;,</span>
<span class="gi">+    112,</span>
<span class="gi">+)</span>
<span class="gi">+dark_olive_green3 = Colors.register(</span>
<span class="gi">+    RGB(135, 215, 95),</span>
<span class="gi">+    HSL(100, 60, 60),</span>
<span class="gi">+    &#39;DarkOliveGreen3&#39;,</span>
<span class="gi">+    113,</span>
<span class="gi">+)</span>
<span class="gi">+pale_green3 = Colors.register(</span>
<span class="gi">+    RGB(135, 215, 135),</span>
<span class="gi">+    HSL(120, 50, 68),</span>
<span class="gi">+    &#39;PaleGreen3&#39;,</span>
<span class="gi">+    114,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green3 = Colors.register(</span>
<span class="gi">+    RGB(135, 215, 175),</span>
<span class="gi">+    HSL(150, 50, 68),</span>
<span class="gi">+    &#39;DarkSeaGreen3&#39;,</span>
<span class="gi">+    115,</span>
<span class="gi">+)</span>
<span class="gi">+dark_slate_gray3 = Colors.register(</span>
<span class="gi">+    RGB(135, 215, 215),</span>
<span class="gi">+    HSL(180, 50, 68),</span>
<span class="gi">+    &#39;DarkSlateGray3&#39;,</span>
<span class="gi">+    116,</span>
<span class="gi">+)</span>
<span class="gi">+sky_blue1 = Colors.register(</span>
<span class="gi">+    RGB(135, 215, 255),</span>
<span class="gi">+    HSL(200, 100, 76),</span>
<span class="gi">+    &#39;SkyBlue1&#39;,</span>
<span class="gi">+    117,</span>
<span class="gi">+)</span>
<span class="gi">+chartreuse1 = Colors.register(</span>
<span class="gi">+    RGB(135, 255, 0),</span>
<span class="gi">+    HSL(8, 100, 50),</span>
<span class="gi">+    &#39;Chartreuse1&#39;,</span>
<span class="gi">+    118,</span>
<span class="gi">+)</span>
<span class="gi">+light_green = Colors.register(</span>
<span class="gi">+    RGB(135, 255, 95),</span>
<span class="gi">+    HSL(105, 100, 68),</span>
<span class="gi">+    &#39;LightGreen&#39;,</span>
<span class="gi">+    119,</span>
<span class="gi">+)</span>
<span class="gi">+light_green = Colors.register(</span>
<span class="gi">+    RGB(135, 255, 135),</span>
<span class="gi">+    HSL(120, 100, 76),</span>
<span class="gi">+    &#39;LightGreen&#39;,</span>
<span class="gi">+    120,</span>
<span class="gi">+)</span>
<span class="gi">+pale_green1 = Colors.register(</span>
<span class="gi">+    RGB(135, 255, 175),</span>
<span class="gi">+    HSL(140, 100, 76),</span>
<span class="gi">+    &#39;PaleGreen1&#39;,</span>
<span class="gi">+    121,</span>
<span class="gi">+)</span>
<span class="gi">+aquamarine1 = Colors.register(</span>
<span class="gi">+    RGB(135, 255, 215),</span>
<span class="gi">+    HSL(160, 100, 76),</span>
<span class="gi">+    &#39;Aquamarine1&#39;,</span>
<span class="gi">+    122,</span>
<span class="gi">+)</span>
<span class="gi">+dark_slate_gray1 = Colors.register(</span>
<span class="gi">+    RGB(135, 255, 255),</span>
<span class="gi">+    HSL(180, 100, 76),</span>
<span class="gi">+    &#39;DarkSlateGray1&#39;,</span>
<span class="gi">+    123,</span>
<span class="gi">+)</span>
<span class="w"> </span>red3 = Colors.register(RGB(175, 0, 0), HSL(0, 100, 34), &#39;Red3&#39;, 124)
<span class="gd">-deep_pink4 = Colors.register(RGB(175, 0, 95), HSL(27, 100, 34), &#39;DeepPink4&#39;,</span>
<span class="gd">-    125)</span>
<span class="gd">-medium_violet_red = Colors.register(RGB(175, 0, 135), HSL(13, 100, 34),</span>
<span class="gd">-    &#39;MediumVioletRed&#39;, 126)</span>
<span class="gd">-magenta3 = Colors.register(RGB(175, 0, 175), HSL(300, 100, 34), &#39;Magenta3&#39;, 127</span>
<span class="gd">-    )</span>
<span class="gd">-dark_violet = Colors.register(RGB(175, 0, 215), HSL(88, 100, 42),</span>
<span class="gd">-    &#39;DarkViolet&#39;, 128)</span>
<span class="gi">+deep_pink4 = Colors.register(</span>
<span class="gi">+    RGB(175, 0, 95),</span>
<span class="gi">+    HSL(27, 100, 34),</span>
<span class="gi">+    &#39;DeepPink4&#39;,</span>
<span class="gi">+    125,</span>
<span class="gi">+)</span>
<span class="gi">+medium_violet_red = Colors.register(</span>
<span class="gi">+    RGB(175, 0, 135),</span>
<span class="gi">+    HSL(13, 100, 34),</span>
<span class="gi">+    &#39;MediumVioletRed&#39;,</span>
<span class="gi">+    126,</span>
<span class="gi">+)</span>
<span class="gi">+magenta3 = Colors.register(</span>
<span class="gi">+    RGB(175, 0, 175),</span>
<span class="gi">+    HSL(300, 100, 34),</span>
<span class="gi">+    &#39;Magenta3&#39;,</span>
<span class="gi">+    127,</span>
<span class="gi">+)</span>
<span class="gi">+dark_violet = Colors.register(</span>
<span class="gi">+    RGB(175, 0, 215),</span>
<span class="gi">+    HSL(88, 100, 42),</span>
<span class="gi">+    &#39;DarkViolet&#39;,</span>
<span class="gi">+    128,</span>
<span class="gi">+)</span>
<span class="w"> </span>purple = Colors.register(RGB(175, 0, 255), HSL(81, 100, 50), &#39;Purple&#39;, 129)
<span class="gd">-dark_orange3 = Colors.register(RGB(175, 95, 0), HSL(2, 100, 34),</span>
<span class="gd">-    &#39;DarkOrange3&#39;, 130)</span>
<span class="gd">-indian_red = Colors.register(RGB(175, 95, 95), HSL(0, 33, 52), &#39;IndianRed&#39;, 131</span>
<span class="gd">-    )</span>
<span class="gd">-hot_pink3 = Colors.register(RGB(175, 95, 135), HSL(330, 33, 52), &#39;HotPink3&#39;,</span>
<span class="gd">-    132)</span>
<span class="gd">-medium_orchid3 = Colors.register(RGB(175, 95, 175), HSL(300, 33, 52),</span>
<span class="gd">-    &#39;MediumOrchid3&#39;, 133)</span>
<span class="gd">-medium_orchid = Colors.register(RGB(175, 95, 215), HSL(280, 60, 60),</span>
<span class="gd">-    &#39;MediumOrchid&#39;, 134)</span>
<span class="gd">-medium_purple2 = Colors.register(RGB(175, 95, 255), HSL(270, 100, 68),</span>
<span class="gd">-    &#39;MediumPurple2&#39;, 135)</span>
<span class="gd">-dark_goldenrod = Colors.register(RGB(175, 135, 0), HSL(6, 100, 34),</span>
<span class="gd">-    &#39;DarkGoldenrod&#39;, 136)</span>
<span class="gd">-light_salmon3 = Colors.register(RGB(175, 135, 95), HSL(30, 33, 52),</span>
<span class="gd">-    &#39;LightSalmon3&#39;, 137)</span>
<span class="gd">-rosy_brown = Colors.register(RGB(175, 135, 135), HSL(0, 20, 60),</span>
<span class="gd">-    &#39;RosyBrown&#39;, 138)</span>
<span class="gi">+dark_orange3 = Colors.register(</span>
<span class="gi">+    RGB(175, 95, 0),</span>
<span class="gi">+    HSL(2, 100, 34),</span>
<span class="gi">+    &#39;DarkOrange3&#39;,</span>
<span class="gi">+    130,</span>
<span class="gi">+)</span>
<span class="gi">+indian_red = Colors.register(</span>
<span class="gi">+    RGB(175, 95, 95),</span>
<span class="gi">+    HSL(0, 33, 52),</span>
<span class="gi">+    &#39;IndianRed&#39;,</span>
<span class="gi">+    131,</span>
<span class="gi">+)</span>
<span class="gi">+hot_pink3 = Colors.register(</span>
<span class="gi">+    RGB(175, 95, 135),</span>
<span class="gi">+    HSL(330, 33, 52),</span>
<span class="gi">+    &#39;HotPink3&#39;,</span>
<span class="gi">+    132,</span>
<span class="gi">+)</span>
<span class="gi">+medium_orchid3 = Colors.register(</span>
<span class="gi">+    RGB(175, 95, 175),</span>
<span class="gi">+    HSL(300, 33, 52),</span>
<span class="gi">+    &#39;MediumOrchid3&#39;,</span>
<span class="gi">+    133,</span>
<span class="gi">+)</span>
<span class="gi">+medium_orchid = Colors.register(</span>
<span class="gi">+    RGB(175, 95, 215),</span>
<span class="gi">+    HSL(280, 60, 60),</span>
<span class="gi">+    &#39;MediumOrchid&#39;,</span>
<span class="gi">+    134,</span>
<span class="gi">+)</span>
<span class="gi">+medium_purple2 = Colors.register(</span>
<span class="gi">+    RGB(175, 95, 255),</span>
<span class="gi">+    HSL(270, 100, 68),</span>
<span class="gi">+    &#39;MediumPurple2&#39;,</span>
<span class="gi">+    135,</span>
<span class="gi">+)</span>
<span class="gi">+dark_goldenrod = Colors.register(</span>
<span class="gi">+    RGB(175, 135, 0),</span>
<span class="gi">+    HSL(6, 100, 34),</span>
<span class="gi">+    &#39;DarkGoldenrod&#39;,</span>
<span class="gi">+    136,</span>
<span class="gi">+)</span>
<span class="gi">+light_salmon3 = Colors.register(</span>
<span class="gi">+    RGB(175, 135, 95),</span>
<span class="gi">+    HSL(30, 33, 52),</span>
<span class="gi">+    &#39;LightSalmon3&#39;,</span>
<span class="gi">+    137,</span>
<span class="gi">+)</span>
<span class="gi">+rosy_brown = Colors.register(</span>
<span class="gi">+    RGB(175, 135, 135),</span>
<span class="gi">+    HSL(0, 20, 60),</span>
<span class="gi">+    &#39;RosyBrown&#39;,</span>
<span class="gi">+    138,</span>
<span class="gi">+)</span>
<span class="w"> </span>grey63 = Colors.register(RGB(175, 135, 175), HSL(300, 20, 60), &#39;Grey63&#39;, 139)
<span class="gd">-medium_purple2 = Colors.register(RGB(175, 135, 215), HSL(270, 50, 68),</span>
<span class="gd">-    &#39;MediumPurple2&#39;, 140)</span>
<span class="gd">-medium_purple1 = Colors.register(RGB(175, 135, 255), HSL(260, 100, 76),</span>
<span class="gd">-    &#39;MediumPurple1&#39;, 141)</span>
<span class="gi">+medium_purple2 = Colors.register(</span>
<span class="gi">+    RGB(175, 135, 215),</span>
<span class="gi">+    HSL(270, 50, 68),</span>
<span class="gi">+    &#39;MediumPurple2&#39;,</span>
<span class="gi">+    140,</span>
<span class="gi">+)</span>
<span class="gi">+medium_purple1 = Colors.register(</span>
<span class="gi">+    RGB(175, 135, 255),</span>
<span class="gi">+    HSL(260, 100, 76),</span>
<span class="gi">+    &#39;MediumPurple1&#39;,</span>
<span class="gi">+    141,</span>
<span class="gi">+)</span>
<span class="w"> </span>gold3 = Colors.register(RGB(175, 175, 0), HSL(60, 100, 34), &#39;Gold3&#39;, 142)
<span class="gd">-dark_khaki = Colors.register(RGB(175, 175, 95), HSL(60, 33, 52),</span>
<span class="gd">-    &#39;DarkKhaki&#39;, 143)</span>
<span class="gd">-navajo_white3 = Colors.register(RGB(175, 175, 135), HSL(60, 20, 60),</span>
<span class="gd">-    &#39;NavajoWhite3&#39;, 144)</span>
<span class="gi">+dark_khaki = Colors.register(</span>
<span class="gi">+    RGB(175, 175, 95),</span>
<span class="gi">+    HSL(60, 33, 52),</span>
<span class="gi">+    &#39;DarkKhaki&#39;,</span>
<span class="gi">+    143,</span>
<span class="gi">+)</span>
<span class="gi">+navajo_white3 = Colors.register(</span>
<span class="gi">+    RGB(175, 175, 135),</span>
<span class="gi">+    HSL(60, 20, 60),</span>
<span class="gi">+    &#39;NavajoWhite3&#39;,</span>
<span class="gi">+    144,</span>
<span class="gi">+)</span>
<span class="w"> </span>grey69 = Colors.register(RGB(175, 175, 175), HSL(0, 0, 68), &#39;Grey69&#39;, 145)
<span class="gd">-light_steel_blue3 = Colors.register(RGB(175, 175, 215), HSL(240, 33, 76),</span>
<span class="gd">-    &#39;LightSteelBlue3&#39;, 146)</span>
<span class="gd">-light_steel_blue = Colors.register(RGB(175, 175, 255), HSL(240, 100, 84),</span>
<span class="gd">-    &#39;LightSteelBlue&#39;, 147)</span>
<span class="gi">+light_steel_blue3 = Colors.register(</span>
<span class="gi">+    RGB(175, 175, 215),</span>
<span class="gi">+    HSL(240, 33, 76),</span>
<span class="gi">+    &#39;LightSteelBlue3&#39;,</span>
<span class="gi">+    146,</span>
<span class="gi">+)</span>
<span class="gi">+light_steel_blue = Colors.register(</span>
<span class="gi">+    RGB(175, 175, 255),</span>
<span class="gi">+    HSL(240, 100, 84),</span>
<span class="gi">+    &#39;LightSteelBlue&#39;,</span>
<span class="gi">+    147,</span>
<span class="gi">+)</span>
<span class="w"> </span>yellow3 = Colors.register(RGB(175, 215, 0), HSL(1, 100, 42), &#39;Yellow3&#39;, 148)
<span class="gd">-dark_olive_green3 = Colors.register(RGB(175, 215, 95), HSL(80, 60, 60),</span>
<span class="gd">-    &#39;DarkOliveGreen3&#39;, 149)</span>
<span class="gd">-dark_sea_green3 = Colors.register(RGB(175, 215, 135), HSL(90, 50, 68),</span>
<span class="gd">-    &#39;DarkSeaGreen3&#39;, 150)</span>
<span class="gd">-dark_sea_green2 = Colors.register(RGB(175, 215, 175), HSL(120, 33, 76),</span>
<span class="gd">-    &#39;DarkSeaGreen2&#39;, 151)</span>
<span class="gd">-light_cyan3 = Colors.register(RGB(175, 215, 215), HSL(180, 33, 76),</span>
<span class="gd">-    &#39;LightCyan3&#39;, 152)</span>
<span class="gd">-light_sky_blue1 = Colors.register(RGB(175, 215, 255), HSL(210, 100, 84),</span>
<span class="gd">-    &#39;LightSkyBlue1&#39;, 153)</span>
<span class="gd">-green_yellow = Colors.register(RGB(175, 255, 0), HSL(8, 100, 50),</span>
<span class="gd">-    &#39;GreenYellow&#39;, 154)</span>
<span class="gd">-dark_olive_green2 = Colors.register(RGB(175, 255, 95), HSL(90, 100, 68),</span>
<span class="gd">-    &#39;DarkOliveGreen2&#39;, 155)</span>
<span class="gd">-pale_green1 = Colors.register(RGB(175, 255, 135), HSL(100, 100, 76),</span>
<span class="gd">-    &#39;PaleGreen1&#39;, 156)</span>
<span class="gd">-dark_sea_green2 = Colors.register(RGB(175, 255, 175), HSL(120, 100, 84),</span>
<span class="gd">-    &#39;DarkSeaGreen2&#39;, 157)</span>
<span class="gd">-dark_sea_green1 = Colors.register(RGB(175, 255, 215), HSL(150, 100, 84),</span>
<span class="gd">-    &#39;DarkSeaGreen1&#39;, 158)</span>
<span class="gd">-pale_turquoise1 = Colors.register(RGB(175, 255, 255), HSL(180, 100, 84),</span>
<span class="gd">-    &#39;PaleTurquoise1&#39;, 159)</span>
<span class="gi">+dark_olive_green3 = Colors.register(</span>
<span class="gi">+    RGB(175, 215, 95),</span>
<span class="gi">+    HSL(80, 60, 60),</span>
<span class="gi">+    &#39;DarkOliveGreen3&#39;,</span>
<span class="gi">+    149,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green3 = Colors.register(</span>
<span class="gi">+    RGB(175, 215, 135),</span>
<span class="gi">+    HSL(90, 50, 68),</span>
<span class="gi">+    &#39;DarkSeaGreen3&#39;,</span>
<span class="gi">+    150,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green2 = Colors.register(</span>
<span class="gi">+    RGB(175, 215, 175),</span>
<span class="gi">+    HSL(120, 33, 76),</span>
<span class="gi">+    &#39;DarkSeaGreen2&#39;,</span>
<span class="gi">+    151,</span>
<span class="gi">+)</span>
<span class="gi">+light_cyan3 = Colors.register(</span>
<span class="gi">+    RGB(175, 215, 215),</span>
<span class="gi">+    HSL(180, 33, 76),</span>
<span class="gi">+    &#39;LightCyan3&#39;,</span>
<span class="gi">+    152,</span>
<span class="gi">+)</span>
<span class="gi">+light_sky_blue1 = Colors.register(</span>
<span class="gi">+    RGB(175, 215, 255),</span>
<span class="gi">+    HSL(210, 100, 84),</span>
<span class="gi">+    &#39;LightSkyBlue1&#39;,</span>
<span class="gi">+    153,</span>
<span class="gi">+)</span>
<span class="gi">+green_yellow = Colors.register(</span>
<span class="gi">+    RGB(175, 255, 0),</span>
<span class="gi">+    HSL(8, 100, 50),</span>
<span class="gi">+    &#39;GreenYellow&#39;,</span>
<span class="gi">+    154,</span>
<span class="gi">+)</span>
<span class="gi">+dark_olive_green2 = Colors.register(</span>
<span class="gi">+    RGB(175, 255, 95),</span>
<span class="gi">+    HSL(90, 100, 68),</span>
<span class="gi">+    &#39;DarkOliveGreen2&#39;,</span>
<span class="gi">+    155,</span>
<span class="gi">+)</span>
<span class="gi">+pale_green1 = Colors.register(</span>
<span class="gi">+    RGB(175, 255, 135),</span>
<span class="gi">+    HSL(100, 100, 76),</span>
<span class="gi">+    &#39;PaleGreen1&#39;,</span>
<span class="gi">+    156,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green2 = Colors.register(</span>
<span class="gi">+    RGB(175, 255, 175),</span>
<span class="gi">+    HSL(120, 100, 84),</span>
<span class="gi">+    &#39;DarkSeaGreen2&#39;,</span>
<span class="gi">+    157,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green1 = Colors.register(</span>
<span class="gi">+    RGB(175, 255, 215),</span>
<span class="gi">+    HSL(150, 100, 84),</span>
<span class="gi">+    &#39;DarkSeaGreen1&#39;,</span>
<span class="gi">+    158,</span>
<span class="gi">+)</span>
<span class="gi">+pale_turquoise1 = Colors.register(</span>
<span class="gi">+    RGB(175, 255, 255),</span>
<span class="gi">+    HSL(180, 100, 84),</span>
<span class="gi">+    &#39;PaleTurquoise1&#39;,</span>
<span class="gi">+    159,</span>
<span class="gi">+)</span>
<span class="w"> </span>red3 = Colors.register(RGB(215, 0, 0), HSL(0, 100, 42), &#39;Red3&#39;, 160)
<span class="gd">-deep_pink3 = Colors.register(RGB(215, 0, 95), HSL(33, 100, 42), &#39;DeepPink3&#39;,</span>
<span class="gd">-    161)</span>
<span class="gd">-deep_pink3 = Colors.register(RGB(215, 0, 135), HSL(22, 100, 42),</span>
<span class="gd">-    &#39;DeepPink3&#39;, 162)</span>
<span class="gi">+deep_pink3 = Colors.register(</span>
<span class="gi">+    RGB(215, 0, 95),</span>
<span class="gi">+    HSL(33, 100, 42),</span>
<span class="gi">+    &#39;DeepPink3&#39;,</span>
<span class="gi">+    161,</span>
<span class="gi">+)</span>
<span class="gi">+deep_pink3 = Colors.register(</span>
<span class="gi">+    RGB(215, 0, 135),</span>
<span class="gi">+    HSL(22, 100, 42),</span>
<span class="gi">+    &#39;DeepPink3&#39;,</span>
<span class="gi">+    162,</span>
<span class="gi">+)</span>
<span class="w"> </span>magenta3 = Colors.register(RGB(215, 0, 175), HSL(11, 100, 42), &#39;Magenta3&#39;, 163)
<span class="gd">-magenta3 = Colors.register(RGB(215, 0, 215), HSL(300, 100, 42), &#39;Magenta3&#39;, 164</span>
<span class="gd">-    )</span>
<span class="gi">+magenta3 = Colors.register(</span>
<span class="gi">+    RGB(215, 0, 215),</span>
<span class="gi">+    HSL(300, 100, 42),</span>
<span class="gi">+    &#39;Magenta3&#39;,</span>
<span class="gi">+    164,</span>
<span class="gi">+)</span>
<span class="w"> </span>magenta2 = Colors.register(RGB(215, 0, 255), HSL(90, 100, 50), &#39;Magenta2&#39;, 165)
<span class="gd">-dark_orange3 = Colors.register(RGB(215, 95, 0), HSL(6, 100, 42),</span>
<span class="gd">-    &#39;DarkOrange3&#39;, 166)</span>
<span class="gd">-indian_red = Colors.register(RGB(215, 95, 95), HSL(0, 60, 60), &#39;IndianRed&#39;, 167</span>
<span class="gd">-    )</span>
<span class="gd">-hot_pink3 = Colors.register(RGB(215, 95, 135), HSL(340, 60, 60), &#39;HotPink3&#39;,</span>
<span class="gd">-    168)</span>
<span class="gd">-hot_pink2 = Colors.register(RGB(215, 95, 175), HSL(320, 60, 60), &#39;HotPink2&#39;,</span>
<span class="gd">-    169)</span>
<span class="gi">+dark_orange3 = Colors.register(</span>
<span class="gi">+    RGB(215, 95, 0),</span>
<span class="gi">+    HSL(6, 100, 42),</span>
<span class="gi">+    &#39;DarkOrange3&#39;,</span>
<span class="gi">+    166,</span>
<span class="gi">+)</span>
<span class="gi">+indian_red = Colors.register(</span>
<span class="gi">+    RGB(215, 95, 95),</span>
<span class="gi">+    HSL(0, 60, 60),</span>
<span class="gi">+    &#39;IndianRed&#39;,</span>
<span class="gi">+    167,</span>
<span class="gi">+)</span>
<span class="gi">+hot_pink3 = Colors.register(</span>
<span class="gi">+    RGB(215, 95, 135),</span>
<span class="gi">+    HSL(340, 60, 60),</span>
<span class="gi">+    &#39;HotPink3&#39;,</span>
<span class="gi">+    168,</span>
<span class="gi">+)</span>
<span class="gi">+hot_pink2 = Colors.register(</span>
<span class="gi">+    RGB(215, 95, 175),</span>
<span class="gi">+    HSL(320, 60, 60),</span>
<span class="gi">+    &#39;HotPink2&#39;,</span>
<span class="gi">+    169,</span>
<span class="gi">+)</span>
<span class="w"> </span>orchid = Colors.register(RGB(215, 95, 215), HSL(300, 60, 60), &#39;Orchid&#39;, 170)
<span class="gd">-medium_orchid1 = Colors.register(RGB(215, 95, 255), HSL(285, 100, 68),</span>
<span class="gd">-    &#39;MediumOrchid1&#39;, 171)</span>
<span class="gi">+medium_orchid1 = Colors.register(</span>
<span class="gi">+    RGB(215, 95, 255),</span>
<span class="gi">+    HSL(285, 100, 68),</span>
<span class="gi">+    &#39;MediumOrchid1&#39;,</span>
<span class="gi">+    171,</span>
<span class="gi">+)</span>
<span class="w"> </span>orange3 = Colors.register(RGB(215, 135, 0), HSL(7, 100, 42), &#39;Orange3&#39;, 172)
<span class="gd">-light_salmon3 = Colors.register(RGB(215, 135, 95), HSL(20, 60, 60),</span>
<span class="gd">-    &#39;LightSalmon3&#39;, 173)</span>
<span class="gd">-light_pink3 = Colors.register(RGB(215, 135, 135), HSL(0, 50, 68),</span>
<span class="gd">-    &#39;LightPink3&#39;, 174)</span>
<span class="gi">+light_salmon3 = Colors.register(</span>
<span class="gi">+    RGB(215, 135, 95),</span>
<span class="gi">+    HSL(20, 60, 60),</span>
<span class="gi">+    &#39;LightSalmon3&#39;,</span>
<span class="gi">+    173,</span>
<span class="gi">+)</span>
<span class="gi">+light_pink3 = Colors.register(</span>
<span class="gi">+    RGB(215, 135, 135),</span>
<span class="gi">+    HSL(0, 50, 68),</span>
<span class="gi">+    &#39;LightPink3&#39;,</span>
<span class="gi">+    174,</span>
<span class="gi">+)</span>
<span class="w"> </span>pink3 = Colors.register(RGB(215, 135, 175), HSL(330, 50, 68), &#39;Pink3&#39;, 175)
<span class="w"> </span>plum3 = Colors.register(RGB(215, 135, 215), HSL(300, 50, 68), &#39;Plum3&#39;, 176)
<span class="w"> </span>violet = Colors.register(RGB(215, 135, 255), HSL(280, 100, 76), &#39;Violet&#39;, 177)
<span class="w"> </span>gold3 = Colors.register(RGB(215, 175, 0), HSL(8, 100, 42), &#39;Gold3&#39;, 178)
<span class="gd">-light_goldenrod3 = Colors.register(RGB(215, 175, 95), HSL(40, 60, 60),</span>
<span class="gd">-    &#39;LightGoldenrod3&#39;, 179)</span>
<span class="gi">+light_goldenrod3 = Colors.register(</span>
<span class="gi">+    RGB(215, 175, 95),</span>
<span class="gi">+    HSL(40, 60, 60),</span>
<span class="gi">+    &#39;LightGoldenrod3&#39;,</span>
<span class="gi">+    179,</span>
<span class="gi">+)</span>
<span class="w"> </span>tan = Colors.register(RGB(215, 175, 135), HSL(30, 50, 68), &#39;Tan&#39;, 180)
<span class="gd">-misty_rose3 = Colors.register(RGB(215, 175, 175), HSL(0, 33, 76),</span>
<span class="gd">-    &#39;MistyRose3&#39;, 181)</span>
<span class="gd">-thistle3 = Colors.register(RGB(215, 175, 215), HSL(300, 33, 76), &#39;Thistle3&#39;,</span>
<span class="gd">-    182)</span>
<span class="gi">+misty_rose3 = Colors.register(</span>
<span class="gi">+    RGB(215, 175, 175),</span>
<span class="gi">+    HSL(0, 33, 76),</span>
<span class="gi">+    &#39;MistyRose3&#39;,</span>
<span class="gi">+    181,</span>
<span class="gi">+)</span>
<span class="gi">+thistle3 = Colors.register(</span>
<span class="gi">+    RGB(215, 175, 215),</span>
<span class="gi">+    HSL(300, 33, 76),</span>
<span class="gi">+    &#39;Thistle3&#39;,</span>
<span class="gi">+    182,</span>
<span class="gi">+)</span>
<span class="w"> </span>plum2 = Colors.register(RGB(215, 175, 255), HSL(270, 100, 84), &#39;Plum2&#39;, 183)
<span class="w"> </span>yellow3 = Colors.register(RGB(215, 215, 0), HSL(60, 100, 42), &#39;Yellow3&#39;, 184)
<span class="w"> </span>khaki3 = Colors.register(RGB(215, 215, 95), HSL(60, 60, 60), &#39;Khaki3&#39;, 185)
<span class="gd">-light_goldenrod2 = Colors.register(RGB(215, 215, 135), HSL(60, 50, 68),</span>
<span class="gd">-    &#39;LightGoldenrod2&#39;, 186)</span>
<span class="gd">-light_yellow3 = Colors.register(RGB(215, 215, 175), HSL(60, 33, 76),</span>
<span class="gd">-    &#39;LightYellow3&#39;, 187)</span>
<span class="gi">+light_goldenrod2 = Colors.register(</span>
<span class="gi">+    RGB(215, 215, 135),</span>
<span class="gi">+    HSL(60, 50, 68),</span>
<span class="gi">+    &#39;LightGoldenrod2&#39;,</span>
<span class="gi">+    186,</span>
<span class="gi">+)</span>
<span class="gi">+light_yellow3 = Colors.register(</span>
<span class="gi">+    RGB(215, 215, 175),</span>
<span class="gi">+    HSL(60, 33, 76),</span>
<span class="gi">+    &#39;LightYellow3&#39;,</span>
<span class="gi">+    187,</span>
<span class="gi">+)</span>
<span class="w"> </span>grey84 = Colors.register(RGB(215, 215, 215), HSL(0, 0, 84), &#39;Grey84&#39;, 188)
<span class="gd">-light_steel_blue1 = Colors.register(RGB(215, 215, 255), HSL(240, 100, 92),</span>
<span class="gd">-    &#39;LightSteelBlue1&#39;, 189)</span>
<span class="gi">+light_steel_blue1 = Colors.register(</span>
<span class="gi">+    RGB(215, 215, 255),</span>
<span class="gi">+    HSL(240, 100, 92),</span>
<span class="gi">+    &#39;LightSteelBlue1&#39;,</span>
<span class="gi">+    189,</span>
<span class="gi">+)</span>
<span class="w"> </span>yellow2 = Colors.register(RGB(215, 255, 0), HSL(9, 100, 50), &#39;Yellow2&#39;, 190)
<span class="gd">-dark_olive_green1 = Colors.register(RGB(215, 255, 95), HSL(75, 100, 68),</span>
<span class="gd">-    &#39;DarkOliveGreen1&#39;, 191)</span>
<span class="gd">-dark_olive_green1 = Colors.register(RGB(215, 255, 135), HSL(80, 100, 76),</span>
<span class="gd">-    &#39;DarkOliveGreen1&#39;, 192)</span>
<span class="gd">-dark_sea_green1 = Colors.register(RGB(215, 255, 175), HSL(90, 100, 84),</span>
<span class="gd">-    &#39;DarkSeaGreen1&#39;, 193)</span>
<span class="gd">-honeydew2 = Colors.register(RGB(215, 255, 215), HSL(120, 100, 92),</span>
<span class="gd">-    &#39;Honeydew2&#39;, 194)</span>
<span class="gd">-light_cyan1 = Colors.register(RGB(215, 255, 255), HSL(180, 100, 92),</span>
<span class="gd">-    &#39;LightCyan1&#39;, 195)</span>
<span class="gi">+dark_olive_green1 = Colors.register(</span>
<span class="gi">+    RGB(215, 255, 95),</span>
<span class="gi">+    HSL(75, 100, 68),</span>
<span class="gi">+    &#39;DarkOliveGreen1&#39;,</span>
<span class="gi">+    191,</span>
<span class="gi">+)</span>
<span class="gi">+dark_olive_green1 = Colors.register(</span>
<span class="gi">+    RGB(215, 255, 135),</span>
<span class="gi">+    HSL(80, 100, 76),</span>
<span class="gi">+    &#39;DarkOliveGreen1&#39;,</span>
<span class="gi">+    192,</span>
<span class="gi">+)</span>
<span class="gi">+dark_sea_green1 = Colors.register(</span>
<span class="gi">+    RGB(215, 255, 175),</span>
<span class="gi">+    HSL(90, 100, 84),</span>
<span class="gi">+    &#39;DarkSeaGreen1&#39;,</span>
<span class="gi">+    193,</span>
<span class="gi">+)</span>
<span class="gi">+honeydew2 = Colors.register(</span>
<span class="gi">+    RGB(215, 255, 215),</span>
<span class="gi">+    HSL(120, 100, 92),</span>
<span class="gi">+    &#39;Honeydew2&#39;,</span>
<span class="gi">+    194,</span>
<span class="gi">+)</span>
<span class="gi">+light_cyan1 = Colors.register(</span>
<span class="gi">+    RGB(215, 255, 255),</span>
<span class="gi">+    HSL(180, 100, 92),</span>
<span class="gi">+    &#39;LightCyan1&#39;,</span>
<span class="gi">+    195,</span>
<span class="gi">+)</span>
<span class="w"> </span>red1 = Colors.register(RGB(255, 0, 0), HSL(0, 100, 50), &#39;Red1&#39;, 196)
<span class="gd">-deep_pink2 = Colors.register(RGB(255, 0, 95), HSL(37, 100, 50), &#39;DeepPink2&#39;,</span>
<span class="gd">-    197)</span>
<span class="gd">-deep_pink1 = Colors.register(RGB(255, 0, 135), HSL(28, 100, 50),</span>
<span class="gd">-    &#39;DeepPink1&#39;, 198)</span>
<span class="gd">-deep_pink1 = Colors.register(RGB(255, 0, 175), HSL(18, 100, 50),</span>
<span class="gd">-    &#39;DeepPink1&#39;, 199)</span>
<span class="gi">+deep_pink2 = Colors.register(</span>
<span class="gi">+    RGB(255, 0, 95),</span>
<span class="gi">+    HSL(37, 100, 50),</span>
<span class="gi">+    &#39;DeepPink2&#39;,</span>
<span class="gi">+    197,</span>
<span class="gi">+)</span>
<span class="gi">+deep_pink1 = Colors.register(</span>
<span class="gi">+    RGB(255, 0, 135),</span>
<span class="gi">+    HSL(28, 100, 50),</span>
<span class="gi">+    &#39;DeepPink1&#39;,</span>
<span class="gi">+    198,</span>
<span class="gi">+)</span>
<span class="gi">+deep_pink1 = Colors.register(</span>
<span class="gi">+    RGB(255, 0, 175),</span>
<span class="gi">+    HSL(18, 100, 50),</span>
<span class="gi">+    &#39;DeepPink1&#39;,</span>
<span class="gi">+    199,</span>
<span class="gi">+)</span>
<span class="w"> </span>magenta2 = Colors.register(RGB(255, 0, 215), HSL(9, 100, 50), &#39;Magenta2&#39;, 200)
<span class="gd">-magenta1 = Colors.register(RGB(255, 0, 255), HSL(300, 100, 50), &#39;Magenta1&#39;, 201</span>
<span class="gd">-    )</span>
<span class="gd">-orange_red1 = Colors.register(RGB(255, 95, 0), HSL(2, 100, 50),</span>
<span class="gd">-    &#39;OrangeRed1&#39;, 202)</span>
<span class="gd">-indian_red1 = Colors.register(RGB(255, 95, 95), HSL(0, 100, 68),</span>
<span class="gd">-    &#39;IndianRed1&#39;, 203)</span>
<span class="gd">-indian_red1 = Colors.register(RGB(255, 95, 135), HSL(345, 100, 68),</span>
<span class="gd">-    &#39;IndianRed1&#39;, 204)</span>
<span class="gd">-hot_pink = Colors.register(RGB(255, 95, 175), HSL(330, 100, 68), &#39;HotPink&#39;, 205</span>
<span class="gd">-    )</span>
<span class="gd">-hot_pink = Colors.register(RGB(255, 95, 215), HSL(315, 100, 68), &#39;HotPink&#39;, 206</span>
<span class="gd">-    )</span>
<span class="gd">-medium_orchid1 = Colors.register(RGB(255, 95, 255), HSL(300, 100, 68),</span>
<span class="gd">-    &#39;MediumOrchid1&#39;, 207)</span>
<span class="gd">-dark_orange = Colors.register(RGB(255, 135, 0), HSL(1, 100, 50),</span>
<span class="gd">-    &#39;DarkOrange&#39;, 208)</span>
<span class="gi">+magenta1 = Colors.register(</span>
<span class="gi">+    RGB(255, 0, 255),</span>
<span class="gi">+    HSL(300, 100, 50),</span>
<span class="gi">+    &#39;Magenta1&#39;,</span>
<span class="gi">+    201,</span>
<span class="gi">+)</span>
<span class="gi">+orange_red1 = Colors.register(</span>
<span class="gi">+    RGB(255, 95, 0),</span>
<span class="gi">+    HSL(2, 100, 50),</span>
<span class="gi">+    &#39;OrangeRed1&#39;,</span>
<span class="gi">+    202,</span>
<span class="gi">+)</span>
<span class="gi">+indian_red1 = Colors.register(</span>
<span class="gi">+    RGB(255, 95, 95),</span>
<span class="gi">+    HSL(0, 100, 68),</span>
<span class="gi">+    &#39;IndianRed1&#39;,</span>
<span class="gi">+    203,</span>
<span class="gi">+)</span>
<span class="gi">+indian_red1 = Colors.register(</span>
<span class="gi">+    RGB(255, 95, 135),</span>
<span class="gi">+    HSL(345, 100, 68),</span>
<span class="gi">+    &#39;IndianRed1&#39;,</span>
<span class="gi">+    204,</span>
<span class="gi">+)</span>
<span class="gi">+hot_pink = Colors.register(</span>
<span class="gi">+    RGB(255, 95, 175),</span>
<span class="gi">+    HSL(330, 100, 68),</span>
<span class="gi">+    &#39;HotPink&#39;,</span>
<span class="gi">+    205,</span>
<span class="gi">+)</span>
<span class="gi">+hot_pink = Colors.register(</span>
<span class="gi">+    RGB(255, 95, 215),</span>
<span class="gi">+    HSL(315, 100, 68),</span>
<span class="gi">+    &#39;HotPink&#39;,</span>
<span class="gi">+    206,</span>
<span class="gi">+)</span>
<span class="gi">+medium_orchid1 = Colors.register(</span>
<span class="gi">+    RGB(255, 95, 255),</span>
<span class="gi">+    HSL(300, 100, 68),</span>
<span class="gi">+    &#39;MediumOrchid1&#39;,</span>
<span class="gi">+    207,</span>
<span class="gi">+)</span>
<span class="gi">+dark_orange = Colors.register(</span>
<span class="gi">+    RGB(255, 135, 0),</span>
<span class="gi">+    HSL(1, 100, 50),</span>
<span class="gi">+    &#39;DarkOrange&#39;,</span>
<span class="gi">+    208,</span>
<span class="gi">+)</span>
<span class="w"> </span>salmon1 = Colors.register(RGB(255, 135, 95), HSL(15, 100, 68), &#39;Salmon1&#39;, 209)
<span class="gd">-light_coral = Colors.register(RGB(255, 135, 135), HSL(0, 100, 76),</span>
<span class="gd">-    &#39;LightCoral&#39;, 210)</span>
<span class="gd">-pale_violet_red1 = Colors.register(RGB(255, 135, 175), HSL(340, 100, 76),</span>
<span class="gd">-    &#39;PaleVioletRed1&#39;, 211)</span>
<span class="gd">-orchid2 = Colors.register(RGB(255, 135, 215), HSL(320, 100, 76), &#39;Orchid2&#39;, 212</span>
<span class="gd">-    )</span>
<span class="gd">-orchid1 = Colors.register(RGB(255, 135, 255), HSL(300, 100, 76), &#39;Orchid1&#39;, 213</span>
<span class="gd">-    )</span>
<span class="gi">+light_coral = Colors.register(</span>
<span class="gi">+    RGB(255, 135, 135),</span>
<span class="gi">+    HSL(0, 100, 76),</span>
<span class="gi">+    &#39;LightCoral&#39;,</span>
<span class="gi">+    210,</span>
<span class="gi">+)</span>
<span class="gi">+pale_violet_red1 = Colors.register(</span>
<span class="gi">+    RGB(255, 135, 175),</span>
<span class="gi">+    HSL(340, 100, 76),</span>
<span class="gi">+    &#39;PaleVioletRed1&#39;,</span>
<span class="gi">+    211,</span>
<span class="gi">+)</span>
<span class="gi">+orchid2 = Colors.register(</span>
<span class="gi">+    RGB(255, 135, 215),</span>
<span class="gi">+    HSL(320, 100, 76),</span>
<span class="gi">+    &#39;Orchid2&#39;,</span>
<span class="gi">+    212,</span>
<span class="gi">+)</span>
<span class="gi">+orchid1 = Colors.register(</span>
<span class="gi">+    RGB(255, 135, 255),</span>
<span class="gi">+    HSL(300, 100, 76),</span>
<span class="gi">+    &#39;Orchid1&#39;,</span>
<span class="gi">+    213,</span>
<span class="gi">+)</span>
<span class="w"> </span>orange1 = Colors.register(RGB(255, 175, 0), HSL(1, 100, 50), &#39;Orange1&#39;, 214)
<span class="gd">-sandy_brown = Colors.register(RGB(255, 175, 95), HSL(30, 100, 68),</span>
<span class="gd">-    &#39;SandyBrown&#39;, 215)</span>
<span class="gd">-light_salmon1 = Colors.register(RGB(255, 175, 135), HSL(20, 100, 76),</span>
<span class="gd">-    &#39;LightSalmon1&#39;, 216)</span>
<span class="gd">-light_pink1 = Colors.register(RGB(255, 175, 175), HSL(0, 100, 84),</span>
<span class="gd">-    &#39;LightPink1&#39;, 217)</span>
<span class="gi">+sandy_brown = Colors.register(</span>
<span class="gi">+    RGB(255, 175, 95),</span>
<span class="gi">+    HSL(30, 100, 68),</span>
<span class="gi">+    &#39;SandyBrown&#39;,</span>
<span class="gi">+    215,</span>
<span class="gi">+)</span>
<span class="gi">+light_salmon1 = Colors.register(</span>
<span class="gi">+    RGB(255, 175, 135),</span>
<span class="gi">+    HSL(20, 100, 76),</span>
<span class="gi">+    &#39;LightSalmon1&#39;,</span>
<span class="gi">+    216,</span>
<span class="gi">+)</span>
<span class="gi">+light_pink1 = Colors.register(</span>
<span class="gi">+    RGB(255, 175, 175),</span>
<span class="gi">+    HSL(0, 100, 84),</span>
<span class="gi">+    &#39;LightPink1&#39;,</span>
<span class="gi">+    217,</span>
<span class="gi">+)</span>
<span class="w"> </span>pink1 = Colors.register(RGB(255, 175, 215), HSL(330, 100, 84), &#39;Pink1&#39;, 218)
<span class="w"> </span>plum1 = Colors.register(RGB(255, 175, 255), HSL(300, 100, 84), &#39;Plum1&#39;, 219)
<span class="w"> </span>gold1 = Colors.register(RGB(255, 215, 0), HSL(0, 100, 50), &#39;Gold1&#39;, 220)
<span class="gd">-light_goldenrod2 = Colors.register(RGB(255, 215, 95), HSL(45, 100, 68),</span>
<span class="gd">-    &#39;LightGoldenrod2&#39;, 221)</span>
<span class="gd">-light_goldenrod2 = Colors.register(RGB(255, 215, 135), HSL(40, 100, 76),</span>
<span class="gd">-    &#39;LightGoldenrod2&#39;, 222)</span>
<span class="gd">-navajo_white1 = Colors.register(RGB(255, 215, 175), HSL(30, 100, 84),</span>
<span class="gd">-    &#39;NavajoWhite1&#39;, 223)</span>
<span class="gd">-misty_rose1 = Colors.register(RGB(255, 215, 215), HSL(0, 100, 92),</span>
<span class="gd">-    &#39;MistyRose1&#39;, 224)</span>
<span class="gd">-thistle1 = Colors.register(RGB(255, 215, 255), HSL(300, 100, 92),</span>
<span class="gd">-    &#39;Thistle1&#39;, 225)</span>
<span class="gi">+light_goldenrod2 = Colors.register(</span>
<span class="gi">+    RGB(255, 215, 95),</span>
<span class="gi">+    HSL(45, 100, 68),</span>
<span class="gi">+    &#39;LightGoldenrod2&#39;,</span>
<span class="gi">+    221,</span>
<span class="gi">+)</span>
<span class="gi">+light_goldenrod2 = Colors.register(</span>
<span class="gi">+    RGB(255, 215, 135),</span>
<span class="gi">+    HSL(40, 100, 76),</span>
<span class="gi">+    &#39;LightGoldenrod2&#39;,</span>
<span class="gi">+    222,</span>
<span class="gi">+)</span>
<span class="gi">+navajo_white1 = Colors.register(</span>
<span class="gi">+    RGB(255, 215, 175),</span>
<span class="gi">+    HSL(30, 100, 84),</span>
<span class="gi">+    &#39;NavajoWhite1&#39;,</span>
<span class="gi">+    223,</span>
<span class="gi">+)</span>
<span class="gi">+misty_rose1 = Colors.register(</span>
<span class="gi">+    RGB(255, 215, 215),</span>
<span class="gi">+    HSL(0, 100, 92),</span>
<span class="gi">+    &#39;MistyRose1&#39;,</span>
<span class="gi">+    224,</span>
<span class="gi">+)</span>
<span class="gi">+thistle1 = Colors.register(</span>
<span class="gi">+    RGB(255, 215, 255),</span>
<span class="gi">+    HSL(300, 100, 92),</span>
<span class="gi">+    &#39;Thistle1&#39;,</span>
<span class="gi">+    225,</span>
<span class="gi">+)</span>
<span class="w"> </span>yellow1 = Colors.register(RGB(255, 255, 0), HSL(60, 100, 50), &#39;Yellow1&#39;, 226)
<span class="gd">-light_goldenrod1 = Colors.register(RGB(255, 255, 95), HSL(60, 100, 68),</span>
<span class="gd">-    &#39;LightGoldenrod1&#39;, 227)</span>
<span class="gi">+light_goldenrod1 = Colors.register(</span>
<span class="gi">+    RGB(255, 255, 95),</span>
<span class="gi">+    HSL(60, 100, 68),</span>
<span class="gi">+    &#39;LightGoldenrod1&#39;,</span>
<span class="gi">+    227,</span>
<span class="gi">+)</span>
<span class="w"> </span>khaki1 = Colors.register(RGB(255, 255, 135), HSL(60, 100, 76), &#39;Khaki1&#39;, 228)
<span class="w"> </span>wheat1 = Colors.register(RGB(255, 255, 175), HSL(60, 100, 84), &#39;Wheat1&#39;, 229)
<span class="gd">-cornsilk1 = Colors.register(RGB(255, 255, 215), HSL(60, 100, 92),</span>
<span class="gd">-    &#39;Cornsilk1&#39;, 230)</span>
<span class="gi">+cornsilk1 = Colors.register(</span>
<span class="gi">+    RGB(255, 255, 215),</span>
<span class="gi">+    HSL(60, 100, 92),</span>
<span class="gi">+    &#39;Cornsilk1&#39;,</span>
<span class="gi">+    230,</span>
<span class="gi">+)</span>
<span class="w"> </span>grey100 = Colors.register(RGB(255, 255, 255), HSL(0, 0, 100), &#39;Grey100&#39;, 231)
<span class="w"> </span>grey3 = Colors.register(RGB(8, 8, 8), HSL(0, 0, 3), &#39;Grey3&#39;, 232)
<span class="w"> </span>grey7 = Colors.register(RGB(18, 18, 18), HSL(0, 0, 7), &#39;Grey7&#39;, 233)
<span class="gu">@@ -411,15 +1034,37 @@ grey82 = Colors.register(RGB(208, 208, 208), HSL(0, 0, 81), &#39;Grey82&#39;, 252)</span>
<span class="w"> </span>grey85 = Colors.register(RGB(218, 218, 218), HSL(0, 0, 85), &#39;Grey85&#39;, 253)
<span class="w"> </span>grey89 = Colors.register(RGB(228, 228, 228), HSL(0, 0, 89), &#39;Grey89&#39;, 254)
<span class="w"> </span>grey93 = Colors.register(RGB(238, 238, 238), HSL(0, 0, 93), &#39;Grey93&#39;, 255)
<span class="gd">-dark_gradient = ColorGradient(red1, orange_red1, dark_orange, orange1,</span>
<span class="gd">-    yellow1, yellow2, green_yellow, green1)</span>
<span class="gd">-light_gradient = ColorGradient(red1, orange_red1, dark_orange, orange1,</span>
<span class="gd">-    gold3, dark_olive_green3, yellow4, green3)</span>
<span class="gi">+</span>
<span class="gi">+dark_gradient = ColorGradient(</span>
<span class="gi">+    red1,</span>
<span class="gi">+    orange_red1,</span>
<span class="gi">+    dark_orange,</span>
<span class="gi">+    orange1,</span>
<span class="gi">+    yellow1,</span>
<span class="gi">+    yellow2,</span>
<span class="gi">+    green_yellow,</span>
<span class="gi">+    green1,</span>
<span class="gi">+)</span>
<span class="gi">+light_gradient = ColorGradient(</span>
<span class="gi">+    red1,</span>
<span class="gi">+    orange_red1,</span>
<span class="gi">+    dark_orange,</span>
<span class="gi">+    orange1,</span>
<span class="gi">+    gold3,</span>
<span class="gi">+    dark_olive_green3,</span>
<span class="gi">+    yellow4,</span>
<span class="gi">+    green3,</span>
<span class="gi">+)</span>
<span class="w"> </span>bg_gradient = ColorGradient(black)
<span class="gi">+</span>
<span class="gi">+# Check if the background is light or dark. This is by no means a foolproof</span>
<span class="gi">+# method, but there is no reliable way to detect this.</span>
<span class="w"> </span>_colorfgbg = os.environ.get(&#39;COLORFGBG&#39;, &#39;15;0&#39;).split(&#39;;&#39;)
<span class="gd">-if _colorfgbg[-1] == str(white.xterm):</span>
<span class="gi">+if _colorfgbg[-1] == str(white.xterm):  # pragma: no cover</span>
<span class="gi">+    # Light background</span>
<span class="w"> </span>    gradient = light_gradient
<span class="w"> </span>    primary = black
<span class="w"> </span>else:
<span class="gi">+    # Default, expect a dark background</span>
<span class="w"> </span>    gradient = dark_gradient
<span class="w"> </span>    primary = white
<span class="gh">diff --git a/progressbar/terminal/os_specific/posix.py b/progressbar/terminal/os_specific/posix.py</span>
<span class="gh">index 5b593c2..52a9560 100644</span>
<span class="gd">--- a/progressbar/terminal/os_specific/posix.py</span>
<span class="gi">+++ b/progressbar/terminal/os_specific/posix.py</span>
<span class="gu">@@ -1,3 +1,15 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>import termios
<span class="w"> </span>import tty
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def getch():</span>
<span class="gi">+    fd = sys.stdin.fileno()</span>
<span class="gi">+    old_settings = termios.tcgetattr(fd)  # type: ignore</span>
<span class="gi">+    try:</span>
<span class="gi">+        tty.setraw(sys.stdin.fileno())  # type: ignore</span>
<span class="gi">+        ch = sys.stdin.read(1)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return ch</span>
<span class="gh">diff --git a/progressbar/terminal/os_specific/windows.py b/progressbar/terminal/os_specific/windows.py</span>
<span class="gh">index efdb404..425d349 100644</span>
<span class="gd">--- a/progressbar/terminal/os_specific/windows.py</span>
<span class="gi">+++ b/progressbar/terminal/os_specific/windows.py</span>
<span class="gu">@@ -1,33 +1,47 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+# ruff: noqa: N801</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="w"> </span>Windows specific code for the terminal.

<span class="w"> </span>Note that the naming convention here is non-pythonic because we are
<span class="w"> </span>matching the Windows API naming.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ctypes
<span class="w"> </span>import enum
<span class="gd">-from ctypes.wintypes import BOOL as _BOOL, CHAR as _CHAR, DWORD as _DWORD, HANDLE as _HANDLE, SHORT as _SHORT, UINT as _UINT, WCHAR as _WCHAR, WORD as _WORD</span>
<span class="gd">-_kernel32 = ctypes.windll.Kernel32</span>
<span class="gi">+from ctypes.wintypes import (</span>
<span class="gi">+    BOOL as _BOOL,</span>
<span class="gi">+    CHAR as _CHAR,</span>
<span class="gi">+    DWORD as _DWORD,</span>
<span class="gi">+    HANDLE as _HANDLE,</span>
<span class="gi">+    SHORT as _SHORT,</span>
<span class="gi">+    UINT as _UINT,</span>
<span class="gi">+    WCHAR as _WCHAR,</span>
<span class="gi">+    WORD as _WORD,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_kernel32 = ctypes.windll.Kernel32  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>_STD_INPUT_HANDLE = _DWORD(-10)
<span class="w"> </span>_STD_OUTPUT_HANDLE = _DWORD(-11)


<span class="w"> </span>class WindowsConsoleModeFlags(enum.IntFlag):
<span class="gd">-    ENABLE_ECHO_INPUT = 4</span>
<span class="gd">-    ENABLE_EXTENDED_FLAGS = 128</span>
<span class="gd">-    ENABLE_INSERT_MODE = 32</span>
<span class="gd">-    ENABLE_LINE_INPUT = 2</span>
<span class="gd">-    ENABLE_MOUSE_INPUT = 16</span>
<span class="gd">-    ENABLE_PROCESSED_INPUT = 1</span>
<span class="gd">-    ENABLE_QUICK_EDIT_MODE = 64</span>
<span class="gd">-    ENABLE_WINDOW_INPUT = 8</span>
<span class="gd">-    ENABLE_VIRTUAL_TERMINAL_INPUT = 512</span>
<span class="gd">-    ENABLE_PROCESSED_OUTPUT = 1</span>
<span class="gd">-    ENABLE_WRAP_AT_EOL_OUTPUT = 2</span>
<span class="gd">-    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4</span>
<span class="gd">-    DISABLE_NEWLINE_AUTO_RETURN = 8</span>
<span class="gd">-    ENABLE_LVB_GRID_WORLDWIDE = 16</span>
<span class="gi">+    ENABLE_ECHO_INPUT = 0x0004</span>
<span class="gi">+    ENABLE_EXTENDED_FLAGS = 0x0080</span>
<span class="gi">+    ENABLE_INSERT_MODE = 0x0020</span>
<span class="gi">+    ENABLE_LINE_INPUT = 0x0002</span>
<span class="gi">+    ENABLE_MOUSE_INPUT = 0x0010</span>
<span class="gi">+    ENABLE_PROCESSED_INPUT = 0x0001</span>
<span class="gi">+    ENABLE_QUICK_EDIT_MODE = 0x0040</span>
<span class="gi">+    ENABLE_WINDOW_INPUT = 0x0008</span>
<span class="gi">+    ENABLE_VIRTUAL_TERMINAL_INPUT = 0x0200</span>
<span class="gi">+</span>
<span class="gi">+    ENABLE_PROCESSED_OUTPUT = 0x0001</span>
<span class="gi">+    ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002</span>
<span class="gi">+    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004</span>
<span class="gi">+    DISABLE_NEWLINE_AUTO_RETURN = 0x0008</span>
<span class="gi">+    ENABLE_LVB_GRID_WORLDWIDE = 0x0010</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return f&#39;{self.name} (0x{self.value:04X})&#39;
<span class="gu">@@ -35,57 +49,125 @@ class WindowsConsoleModeFlags(enum.IntFlag):</span>

<span class="w"> </span>_GetConsoleMode = _kernel32.GetConsoleMode
<span class="w"> </span>_GetConsoleMode.restype = _BOOL
<span class="gi">+</span>
<span class="w"> </span>_SetConsoleMode = _kernel32.SetConsoleMode
<span class="w"> </span>_SetConsoleMode.restype = _BOOL
<span class="gi">+</span>
<span class="w"> </span>_GetStdHandle = _kernel32.GetStdHandle
<span class="w"> </span>_GetStdHandle.restype = _HANDLE
<span class="gi">+</span>
<span class="w"> </span>_ReadConsoleInput = _kernel32.ReadConsoleInputA
<span class="w"> </span>_ReadConsoleInput.restype = _BOOL
<span class="gi">+</span>
<span class="w"> </span>_h_console_input = _GetStdHandle(_STD_INPUT_HANDLE)
<span class="w"> </span>_input_mode = _DWORD()
<span class="w"> </span>_GetConsoleMode(_HANDLE(_h_console_input), ctypes.byref(_input_mode))
<span class="gi">+</span>
<span class="w"> </span>_h_console_output = _GetStdHandle(_STD_OUTPUT_HANDLE)
<span class="w"> </span>_output_mode = _DWORD()
<span class="w"> </span>_GetConsoleMode(_HANDLE(_h_console_output), ctypes.byref(_output_mode))


<span class="w"> </span>class _COORD(ctypes.Structure):
<span class="gd">-    _fields_ = (&#39;X&#39;, _SHORT), (&#39;Y&#39;, _SHORT)</span>
<span class="gi">+    _fields_ = ((&#39;X&#39;, _SHORT), (&#39;Y&#39;, _SHORT))</span>


<span class="w"> </span>class _FOCUS_EVENT_RECORD(ctypes.Structure):
<span class="gd">-    _fields_ = (&#39;bSetFocus&#39;, _BOOL),</span>
<span class="gi">+    _fields_ = ((&#39;bSetFocus&#39;, _BOOL),)</span>


<span class="w"> </span>class _KEY_EVENT_RECORD(ctypes.Structure):
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    class _uchar(ctypes.Union):
<span class="gd">-        _fields_ = (&#39;UnicodeChar&#39;, _WCHAR), (&#39;AsciiChar&#39;, _CHAR)</span>
<span class="gd">-    _fields_ = (&#39;bKeyDown&#39;, _BOOL), (&#39;wRepeatCount&#39;, _WORD), (&#39;wVirtualKeyCode&#39;</span>
<span class="gd">-        , _WORD), (&#39;wVirtualScanCode&#39;, _WORD), (&#39;uChar&#39;, _uchar), (</span>
<span class="gd">-        &#39;dwControlKeyState&#39;, _DWORD)</span>
<span class="gi">+        _fields_ = ((&#39;UnicodeChar&#39;, _WCHAR), (&#39;AsciiChar&#39;, _CHAR))</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = (</span>
<span class="gi">+        (&#39;bKeyDown&#39;, _BOOL),</span>
<span class="gi">+        (&#39;wRepeatCount&#39;, _WORD),</span>
<span class="gi">+        (&#39;wVirtualKeyCode&#39;, _WORD),</span>
<span class="gi">+        (&#39;wVirtualScanCode&#39;, _WORD),</span>
<span class="gi">+        (&#39;uChar&#39;, _uchar),</span>
<span class="gi">+        (&#39;dwControlKeyState&#39;, _DWORD),</span>
<span class="gi">+    )</span>


<span class="w"> </span>class _MENU_EVENT_RECORD(ctypes.Structure):
<span class="gd">-    _fields_ = (&#39;dwCommandId&#39;, _UINT),</span>
<span class="gi">+    _fields_ = ((&#39;dwCommandId&#39;, _UINT),)</span>


<span class="w"> </span>class _MOUSE_EVENT_RECORD(ctypes.Structure):
<span class="gd">-    _fields_ = (&#39;dwMousePosition&#39;, _COORD), (&#39;dwButtonState&#39;, _DWORD), (</span>
<span class="gd">-        &#39;dwControlKeyState&#39;, _DWORD), (&#39;dwEventFlags&#39;, _DWORD)</span>
<span class="gi">+    _fields_ = (</span>
<span class="gi">+        (&#39;dwMousePosition&#39;, _COORD),</span>
<span class="gi">+        (&#39;dwButtonState&#39;, _DWORD),</span>
<span class="gi">+        (&#39;dwControlKeyState&#39;, _DWORD),</span>
<span class="gi">+        (&#39;dwEventFlags&#39;, _DWORD),</span>
<span class="gi">+    )</span>


<span class="w"> </span>class _WINDOW_BUFFER_SIZE_RECORD(ctypes.Structure):
<span class="gd">-    _fields_ = (&#39;dwSize&#39;, _COORD),</span>
<span class="gi">+    _fields_ = ((&#39;dwSize&#39;, _COORD),)</span>


<span class="w"> </span>class _INPUT_RECORD(ctypes.Structure):
<span class="gi">+    class _Event(ctypes.Union):</span>
<span class="gi">+        _fields_ = (</span>
<span class="gi">+            (&#39;KeyEvent&#39;, _KEY_EVENT_RECORD),</span>
<span class="gi">+            (&#39;MouseEvent&#39;, _MOUSE_EVENT_RECORD),</span>
<span class="gi">+            (&#39;WindowBufferSizeEvent&#39;, _WINDOW_BUFFER_SIZE_RECORD),</span>
<span class="gi">+            (&#39;MenuEvent&#39;, _MENU_EVENT_RECORD),</span>
<span class="gi">+            (&#39;FocusEvent&#39;, _FOCUS_EVENT_RECORD),</span>
<span class="gi">+        )</span>

<span class="gi">+    _fields_ = ((&#39;EventType&#39;, _WORD), (&#39;Event&#39;, _Event))</span>

<span class="gd">-    class _Event(ctypes.Union):</span>
<span class="gd">-        _fields_ = (&#39;KeyEvent&#39;, _KEY_EVENT_RECORD), (&#39;MouseEvent&#39;,</span>
<span class="gd">-            _MOUSE_EVENT_RECORD), (&#39;WindowBufferSizeEvent&#39;,</span>
<span class="gd">-            _WINDOW_BUFFER_SIZE_RECORD), (&#39;MenuEvent&#39;, _MENU_EVENT_RECORD), (</span>
<span class="gd">-            &#39;FocusEvent&#39;, _FOCUS_EVENT_RECORD)</span>
<span class="gd">-    _fields_ = (&#39;EventType&#39;, _WORD), (&#39;Event&#39;, _Event)</span>
<span class="gi">+</span>
<span class="gi">+def reset_console_mode() -&gt; None:</span>
<span class="gi">+    _SetConsoleMode(_HANDLE(_h_console_input), _DWORD(_input_mode.value))</span>
<span class="gi">+    _SetConsoleMode(_HANDLE(_h_console_output), _DWORD(_output_mode.value))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_console_mode() -&gt; bool:</span>
<span class="gi">+    mode = (</span>
<span class="gi">+        _input_mode.value</span>
<span class="gi">+        | WindowsConsoleModeFlags.ENABLE_VIRTUAL_TERMINAL_INPUT</span>
<span class="gi">+    )</span>
<span class="gi">+    _SetConsoleMode(_HANDLE(_h_console_input), _DWORD(mode))</span>
<span class="gi">+</span>
<span class="gi">+    mode = (</span>
<span class="gi">+        _output_mode.value</span>
<span class="gi">+        | WindowsConsoleModeFlags.ENABLE_PROCESSED_OUTPUT</span>
<span class="gi">+        | WindowsConsoleModeFlags.ENABLE_VIRTUAL_TERMINAL_PROCESSING</span>
<span class="gi">+    )</span>
<span class="gi">+    return bool(_SetConsoleMode(_HANDLE(_h_console_output), _DWORD(mode)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_console_mode() -&gt; int:</span>
<span class="gi">+    return _input_mode.value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_text_color(color) -&gt; None:</span>
<span class="gi">+    _kernel32.SetConsoleTextAttribute(_h_console_output, color)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def print_color(text, color):</span>
<span class="gi">+    set_text_color(color)</span>
<span class="gi">+    print(text)  # noqa: T201</span>
<span class="gi">+    set_text_color(7)  # Reset to default color, grey</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def getch():</span>
<span class="gi">+    lp_buffer = (_INPUT_RECORD * 2)()</span>
<span class="gi">+    n_length = _DWORD(2)</span>
<span class="gi">+    lp_number_of_events_read = _DWORD()</span>
<span class="gi">+</span>
<span class="gi">+    _ReadConsoleInput(</span>
<span class="gi">+        _HANDLE(_h_console_input),</span>
<span class="gi">+        lp_buffer,</span>
<span class="gi">+        n_length,</span>
<span class="gi">+        ctypes.byref(lp_number_of_events_read),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    char = lp_buffer[1].Event.KeyEvent.uChar.AsciiChar.decode(&#39;ascii&#39;)</span>
<span class="gi">+    if char == &#39;\x00&#39;:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return char</span>
<span class="gh">diff --git a/progressbar/terminal/stream.py b/progressbar/terminal/stream.py</span>
<span class="gh">index a5242d6..ee02a9d 100644</span>
<span class="gd">--- a/progressbar/terminal/stream.py</span>
<span class="gi">+++ b/progressbar/terminal/stream.py</span>
<span class="gu">@@ -1,41 +1,138 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import typing
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>from typing import Iterable, Iterator
<span class="gd">-from progressbar import base</span>

<span class="gi">+from progressbar import base</span>

<span class="gd">-class TextIOOutputWrapper(base.TextIO):</span>

<span class="gi">+class TextIOOutputWrapper(base.TextIO):  # pragma: no cover</span>
<span class="w"> </span>    def __init__(self, stream: base.TextIO):
<span class="w"> </span>        self.stream = stream

<span class="gd">-    def __next__(self) -&gt;str:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self.stream.close()</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return self.stream.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def isatty(self) -&gt; bool:</span>
<span class="gi">+        return self.stream.isatty()</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, __n: int = -1) -&gt; str:</span>
<span class="gi">+        return self.stream.read(__n)</span>
<span class="gi">+</span>
<span class="gi">+    def readable(self) -&gt; bool:</span>
<span class="gi">+        return self.stream.readable()</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self, __limit: int = -1) -&gt; str:</span>
<span class="gi">+        return self.stream.readline(__limit)</span>
<span class="gi">+</span>
<span class="gi">+    def readlines(self, __hint: int = -1) -&gt; list[str]:</span>
<span class="gi">+        return self.stream.readlines(__hint)</span>
<span class="gi">+</span>
<span class="gi">+    def seek(self, __offset: int, __whence: int = 0) -&gt; int:</span>
<span class="gi">+        return self.stream.seek(__offset, __whence)</span>
<span class="gi">+</span>
<span class="gi">+    def seekable(self) -&gt; bool:</span>
<span class="gi">+        return self.stream.seekable()</span>
<span class="gi">+</span>
<span class="gi">+    def tell(self) -&gt; int:</span>
<span class="gi">+        return self.stream.tell()</span>
<span class="gi">+</span>
<span class="gi">+    def truncate(self, __size: int | None = None) -&gt; int:</span>
<span class="gi">+        return self.stream.truncate(__size)</span>
<span class="gi">+</span>
<span class="gi">+    def writable(self) -&gt; bool:</span>
<span class="gi">+        return self.stream.writable()</span>
<span class="gi">+</span>
<span class="gi">+    def writelines(self, __lines: Iterable[str]) -&gt; None:</span>
<span class="gi">+        return self.stream.writelines(__lines)</span>
<span class="gi">+</span>
<span class="gi">+    def __next__(self) -&gt; str:</span>
<span class="w"> </span>        return self.stream.__next__()

<span class="gd">-    def __iter__(self) -&gt;Iterator[str]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[str]:</span>
<span class="w"> </span>        return self.stream.__iter__()

<span class="gd">-    def __exit__(self, __t: (type[BaseException] | None), __value: (</span>
<span class="gd">-        BaseException | None), __traceback: (TracebackType | None)) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        __t: type[BaseException] | None,</span>
<span class="gi">+        __value: BaseException | None,</span>
<span class="gi">+        __traceback: TracebackType | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        return self.stream.__exit__(__t, __value, __traceback)

<span class="gd">-    def __enter__(self) -&gt;base.TextIO:</span>
<span class="gi">+    def __enter__(self) -&gt; base.TextIO:</span>
<span class="w"> </span>        return self.stream.__enter__()


<span class="w"> </span>class LineOffsetStreamWrapper(TextIOOutputWrapper):
<span class="gd">-    UP = &#39;\x1b[F&#39;</span>
<span class="gd">-    DOWN = &#39;\x1b[B&#39;</span>
<span class="gi">+    UP = &#39;\033[F&#39;</span>
<span class="gi">+    DOWN = &#39;\033[B&#39;</span>

<span class="w"> </span>    def __init__(self, lines=0, stream=sys.stderr):
<span class="w"> </span>        self.lines = lines
<span class="w"> </span>        super().__init__(stream)

<span class="gi">+    def write(self, data):</span>
<span class="gi">+        # Move the cursor up</span>
<span class="gi">+        self.stream.write(self.UP * self.lines)</span>
<span class="gi">+        # Print a carriage return to reset the cursor position</span>
<span class="gi">+        self.stream.write(&#39;\r&#39;)</span>
<span class="gi">+        # Print the data without newlines so we don&#39;t change the position</span>
<span class="gi">+        self.stream.write(data.rstrip(&#39;\n&#39;))</span>
<span class="gi">+        # Move the cursor down</span>
<span class="gi">+        self.stream.write(self.DOWN * self.lines)</span>
<span class="gi">+</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+</span>

<span class="w"> </span>class LastLineStream(TextIOOutputWrapper):
<span class="w"> </span>    line: str = &#39;&#39;

<span class="gd">-    def __iter__(self) -&gt;typing.Generator[str, typing.Any, typing.Any]:</span>
<span class="gi">+    def seekable(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def readable(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, __n: int = -1) -&gt; str:</span>
<span class="gi">+        if __n &lt; 0:</span>
<span class="gi">+            return self.line</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.line[:__n]</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self, __limit: int = -1) -&gt; str:</span>
<span class="gi">+        if __limit &lt; 0:</span>
<span class="gi">+            return self.line</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.line[:__limit]</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data: str) -&gt; int:</span>
<span class="gi">+        self.line = data</span>
<span class="gi">+        return len(data)</span>
<span class="gi">+</span>
<span class="gi">+    def truncate(self, __size: int | None = None) -&gt; int:</span>
<span class="gi">+        if __size is None:</span>
<span class="gi">+            self.line = &#39;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.line = self.line[:__size]</span>
<span class="gi">+</span>
<span class="gi">+        return len(self.line)</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; typing.Generator[str, typing.Any, typing.Any]:</span>
<span class="w"> </span>        yield self.line
<span class="gi">+</span>
<span class="gi">+    def writelines(self, __lines: Iterable[str]) -&gt; None:</span>
<span class="gi">+        line = &#39;&#39;</span>
<span class="gi">+        # Walk through the lines and take the last one</span>
<span class="gi">+        for line in __lines:  # noqa: B007</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        self.line = line</span>
<span class="gh">diff --git a/progressbar/utils.py b/progressbar/utils.py</span>
<span class="gh">index edf654a..46d0cb2 100644</span>
<span class="gd">--- a/progressbar/utils.py</span>
<span class="gi">+++ b/progressbar/utils.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import atexit
<span class="w"> </span>import contextlib
<span class="w"> </span>import datetime
<span class="gu">@@ -9,24 +10,32 @@ import re</span>
<span class="w"> </span>import sys
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>from typing import Iterable, Iterator
<span class="gi">+</span>
<span class="w"> </span>from python_utils import types
<span class="w"> </span>from python_utils.converters import scale_1024
<span class="w"> </span>from python_utils.terminal import get_terminal_size
<span class="w"> </span>from python_utils.time import epoch, format_time, timedelta_to_seconds
<span class="gi">+</span>
<span class="w"> </span>from progressbar import base, env, terminal
<span class="gi">+</span>
<span class="w"> </span>if types.TYPE_CHECKING:
<span class="w"> </span>    from .bar import ProgressBar, ProgressBarMixinBase
<span class="gi">+</span>
<span class="gi">+# Make sure these are available for import</span>
<span class="w"> </span>assert timedelta_to_seconds is not None
<span class="w"> </span>assert get_terminal_size is not None
<span class="w"> </span>assert format_time is not None
<span class="w"> </span>assert scale_1024 is not None
<span class="w"> </span>assert epoch is not None
<span class="gi">+</span>
<span class="w"> </span>StringT = types.TypeVar(&#39;StringT&#39;, bound=types.StringTypes)


<span class="gd">-def deltas_to_seconds(*deltas, default: types.Optional[types.Type[</span>
<span class="gd">-    ValueError]]=ValueError) -&gt;(int | float | None):</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+def deltas_to_seconds(</span>
<span class="gi">+    *deltas,</span>
<span class="gi">+    default: types.Optional[types.Type[ValueError]] = ValueError,</span>
<span class="gi">+) -&gt; int | float | None:</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Convert timedeltas and seconds as int to seconds as float while coalescing.

<span class="w"> </span>    &gt;&gt;&gt; deltas_to_seconds(datetime.timedelta(seconds=1, milliseconds=234))
<span class="gu">@@ -49,40 +58,60 @@ def deltas_to_seconds(*deltas, default: types.Optional[types.Type[</span>
<span class="w"> </span>    ValueError: No valid deltas passed to `deltas_to_seconds`
<span class="w"> </span>    &gt;&gt;&gt; deltas_to_seconds(default=0.0)
<span class="w"> </span>    0.0
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    for delta in deltas:</span>
<span class="gi">+        if delta is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(delta, datetime.timedelta):</span>
<span class="gi">+            return timedelta_to_seconds(delta)</span>
<span class="gi">+        elif not isinstance(delta, float):</span>
<span class="gi">+            return float(delta)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return delta</span>
<span class="gi">+</span>
<span class="gi">+    if default is ValueError:</span>
<span class="gi">+        raise ValueError(&#39;No valid deltas passed to `deltas_to_seconds`&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # mypy doesn&#39;t understand the `default is ValueError` check</span>
<span class="gi">+        return default  # type: ignore</span>


<span class="gd">-def no_color(value: StringT) -&gt;StringT:</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+def no_color(value: StringT) -&gt; StringT:</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Return the `value` without ANSI escape codes.

<span class="gd">-    &gt;&gt;&gt; no_color(b&#39;[1234]abc&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; no_color(b&#39;\u001b[1234]abc&#39;)</span>
<span class="w"> </span>    b&#39;abc&#39;
<span class="gd">-    &gt;&gt;&gt; str(no_color(u&#39;[1234]abc&#39;))</span>
<span class="gi">+    &gt;&gt;&gt; str(no_color(u&#39;\u001b[1234]abc&#39;))</span>
<span class="w"> </span>    &#39;abc&#39;
<span class="gd">-    &gt;&gt;&gt; str(no_color(&#39;[1234]abc&#39;))</span>
<span class="gi">+    &gt;&gt;&gt; str(no_color(&#39;\u001b[1234]abc&#39;))</span>
<span class="w"> </span>    &#39;abc&#39;
<span class="w"> </span>    &gt;&gt;&gt; no_color(123)
<span class="w"> </span>    Traceback (most recent call last):
<span class="w"> </span>    ...
<span class="w"> </span>    TypeError: `value` must be a string or bytes, got 123
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def len_color(value: types.StringTypes) -&gt;int:</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        pattern: bytes = bytes(terminal.ESC, &#39;ascii&#39;) + b&#39;\\[.*?[@-~]&#39;</span>
<span class="gi">+        return re.sub(pattern, b&#39;&#39;, value)  # type: ignore</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        return re.sub(&#39;\x1b\\[.*?[@-~]&#39;, &#39;&#39;, value)  # type: ignore</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&#39;`value` must be a string or bytes, got %r&#39; % value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def len_color(value: types.StringTypes) -&gt; int:</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Return the length of `value` without ANSI escape codes.

<span class="gd">-    &gt;&gt;&gt; len_color(b&#39;[1234]abc&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; len_color(b&#39;\u001b[1234]abc&#39;)</span>
<span class="w"> </span>    3
<span class="gd">-    &gt;&gt;&gt; len_color(u&#39;[1234]abc&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; len_color(u&#39;\u001b[1234]abc&#39;)</span>
<span class="w"> </span>    3
<span class="gd">-    &gt;&gt;&gt; len_color(&#39;[1234]abc&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; len_color(&#39;\u001b[1234]abc&#39;)</span>
<span class="w"> </span>    3
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    return len(no_color(value))</span>


<span class="w"> </span>class WrappingIO:
<span class="gu">@@ -92,34 +121,122 @@ class WrappingIO:</span>
<span class="w"> </span>    listeners: set
<span class="w"> </span>    needs_clear: bool = False

<span class="gd">-    def __init__(self, target: base.IO, capturing: bool=False, listeners:</span>
<span class="gd">-        types.Optional[types.Set[ProgressBar]]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        target: base.IO,</span>
<span class="gi">+        capturing: bool = False,</span>
<span class="gi">+        listeners: types.Optional[types.Set[ProgressBar]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.buffer = io.StringIO()
<span class="w"> </span>        self.target = target
<span class="w"> </span>        self.capturing = capturing
<span class="w"> </span>        self.listeners = listeners or set()
<span class="w"> </span>        self.needs_clear = False

<span class="gd">-    def __enter__(self) -&gt;WrappingIO:</span>
<span class="gi">+    def write(self, value: str) -&gt; int:</span>
<span class="gi">+        ret = 0</span>
<span class="gi">+        if self.capturing:</span>
<span class="gi">+            ret += self.buffer.write(value)</span>
<span class="gi">+            if &#39;\n&#39; in value:  # pragma: no branch</span>
<span class="gi">+                self.needs_clear = True</span>
<span class="gi">+                for listener in self.listeners:  # pragma: no branch</span>
<span class="gi">+                    listener.update()</span>
<span class="gi">+        else:</span>
<span class="gi">+            ret += self.target.write(value)</span>
<span class="gi">+            if &#39;\n&#39; in value:  # pragma: no branch</span>
<span class="gi">+                self.flush_target()</span>
<span class="gi">+</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        self.buffer.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def _flush(self) -&gt; None:</span>
<span class="gi">+        if value := self.buffer.getvalue():</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+            self.target.write(value)</span>
<span class="gi">+            self.buffer.seek(0)</span>
<span class="gi">+            self.buffer.truncate(0)</span>
<span class="gi">+            self.needs_clear = False</span>
<span class="gi">+</span>
<span class="gi">+        # when explicitly flushing, always flush the target as well</span>
<span class="gi">+        self.flush_target()</span>
<span class="gi">+</span>
<span class="gi">+    def flush_target(self) -&gt; None:  # pragma: no cover</span>
<span class="gi">+        if not self.target.closed and getattr(self.target, &#39;flush&#39;, None):</span>
<span class="gi">+            self.target.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; WrappingIO:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __next__(self) -&gt;str:</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return self.target.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def isatty(self) -&gt; bool:</span>
<span class="gi">+        return self.target.isatty()</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, n: int = -1) -&gt; str:</span>
<span class="gi">+        return self.target.read(n)</span>
<span class="gi">+</span>
<span class="gi">+    def readable(self) -&gt; bool:</span>
<span class="gi">+        return self.target.readable()</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self, limit: int = -1) -&gt; str:</span>
<span class="gi">+        return self.target.readline(limit)</span>
<span class="gi">+</span>
<span class="gi">+    def readlines(self, hint: int = -1) -&gt; list[str]:</span>
<span class="gi">+        return self.target.readlines(hint)</span>
<span class="gi">+</span>
<span class="gi">+    def seek(self, offset: int, whence: int = os.SEEK_SET) -&gt; int:</span>
<span class="gi">+        return self.target.seek(offset, whence)</span>
<span class="gi">+</span>
<span class="gi">+    def seekable(self) -&gt; bool:</span>
<span class="gi">+        return self.target.seekable()</span>
<span class="gi">+</span>
<span class="gi">+    def tell(self) -&gt; int:</span>
<span class="gi">+        return self.target.tell()</span>
<span class="gi">+</span>
<span class="gi">+    def truncate(self, size: types.Optional[int] = None) -&gt; int:</span>
<span class="gi">+        return self.target.truncate(size)</span>
<span class="gi">+</span>
<span class="gi">+    def writable(self) -&gt; bool:</span>
<span class="gi">+        return self.target.writable()</span>
<span class="gi">+</span>
<span class="gi">+    def writelines(self, lines: Iterable[str]) -&gt; None:</span>
<span class="gi">+        return self.target.writelines(lines)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        self.target.close()</span>
<span class="gi">+</span>
<span class="gi">+    def __next__(self) -&gt; str:</span>
<span class="w"> </span>        return self.target.__next__()

<span class="gd">-    def __iter__(self) -&gt;Iterator[str]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[str]:</span>
<span class="w"> </span>        return self.target.__iter__()

<span class="gd">-    def __exit__(self, __t: (type[BaseException] | None), __value: (</span>
<span class="gd">-        BaseException | None), __traceback: (TracebackType | None)) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        __t: type[BaseException] | None,</span>
<span class="gi">+        __value: BaseException | None,</span>
<span class="gi">+        __traceback: TracebackType | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.close()


<span class="w"> </span>class StreamWrapper:
<span class="gd">-    &quot;&quot;&quot;Wrap stdout and stderr globally.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Wrap stdout and stderr globally.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    stdout: base.TextIO | WrappingIO
<span class="w"> </span>    stderr: base.TextIO | WrappingIO
<span class="gd">-    original_excepthook: types.Callable[[types.Type[BaseException],</span>
<span class="gd">-        BaseException, TracebackType | None], None]</span>
<span class="gi">+    original_excepthook: types.Callable[</span>
<span class="gi">+        [</span>
<span class="gi">+            types.Type[BaseException],</span>
<span class="gi">+            BaseException,</span>
<span class="gi">+            TracebackType | None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        None,</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    wrapped_stdout: int = 0
<span class="w"> </span>    wrapped_stderr: int = 0
<span class="w"> </span>    wrapped_excepthook: int = 0
<span class="gu">@@ -135,14 +252,134 @@ class StreamWrapper:</span>
<span class="w"> </span>        self.wrapped_excepthook = 0
<span class="w"> </span>        self.capturing = 0
<span class="w"> </span>        self.listeners = set()
<span class="gd">-        if env.env_flag(&#39;WRAP_STDOUT&#39;, default=False):</span>
<span class="gi">+</span>
<span class="gi">+        if env.env_flag(&#39;WRAP_STDOUT&#39;, default=False):  # pragma: no cover</span>
<span class="w"> </span>            self.wrap_stdout()
<span class="gd">-        if env.env_flag(&#39;WRAP_STDERR&#39;, default=False):</span>
<span class="gi">+</span>
<span class="gi">+        if env.env_flag(&#39;WRAP_STDERR&#39;, default=False):  # pragma: no cover</span>
<span class="gi">+            self.wrap_stderr()</span>
<span class="gi">+</span>
<span class="gi">+    def start_capturing(self, bar: ProgressBarMixinBase | None = None) -&gt; None:</span>
<span class="gi">+        if bar:  # pragma: no branch</span>
<span class="gi">+            self.listeners.add(bar)</span>
<span class="gi">+</span>
<span class="gi">+        self.capturing += 1</span>
<span class="gi">+        self.update_capturing()</span>
<span class="gi">+</span>
<span class="gi">+    def stop_capturing(self, bar: ProgressBarMixinBase | None = None) -&gt; None:</span>
<span class="gi">+        if bar:  # pragma: no branch</span>
<span class="gi">+            with contextlib.suppress(KeyError):</span>
<span class="gi">+                self.listeners.remove(bar)</span>
<span class="gi">+</span>
<span class="gi">+        self.capturing -= 1</span>
<span class="gi">+        self.update_capturing()</span>
<span class="gi">+</span>
<span class="gi">+    def update_capturing(self) -&gt; None:  # pragma: no cover</span>
<span class="gi">+        if isinstance(self.stdout, WrappingIO):</span>
<span class="gi">+            self.stdout.capturing = self.capturing &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self.stderr, WrappingIO):</span>
<span class="gi">+            self.stderr.capturing = self.capturing &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        if self.capturing &lt;= 0:</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(self, stdout: bool = False, stderr: bool = False) -&gt; None:</span>
<span class="gi">+        if stdout:</span>
<span class="gi">+            self.wrap_stdout()</span>
<span class="gi">+</span>
<span class="gi">+        if stderr:</span>
<span class="w"> </span>            self.wrap_stderr()

<span class="gi">+    def wrap_stdout(self) -&gt; WrappingIO:</span>
<span class="gi">+        self.wrap_excepthook()</span>
<span class="gi">+</span>
<span class="gi">+        if not self.wrapped_stdout:</span>
<span class="gi">+            self.stdout = sys.stdout = WrappingIO(  # type: ignore</span>
<span class="gi">+                self.original_stdout,</span>
<span class="gi">+                listeners=self.listeners,</span>
<span class="gi">+            )</span>
<span class="gi">+        self.wrapped_stdout += 1</span>
<span class="gi">+</span>
<span class="gi">+        return sys.stdout  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def wrap_stderr(self) -&gt; WrappingIO:</span>
<span class="gi">+        self.wrap_excepthook()</span>
<span class="gi">+</span>
<span class="gi">+        if not self.wrapped_stderr:</span>
<span class="gi">+            self.stderr = sys.stderr = WrappingIO(  # type: ignore</span>
<span class="gi">+                self.original_stderr,</span>
<span class="gi">+                listeners=self.listeners,</span>
<span class="gi">+            )</span>
<span class="gi">+        self.wrapped_stderr += 1</span>
<span class="gi">+</span>
<span class="gi">+        return sys.stderr  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def unwrap_excepthook(self) -&gt; None:</span>
<span class="gi">+        if self.wrapped_excepthook:</span>
<span class="gi">+            self.wrapped_excepthook -= 1</span>
<span class="gi">+            sys.excepthook = self.original_excepthook</span>
<span class="gi">+</span>
<span class="gi">+    def wrap_excepthook(self) -&gt; None:</span>
<span class="gi">+        if not self.wrapped_excepthook:</span>
<span class="gi">+            logger.debug(&#39;wrapping excepthook&#39;)</span>
<span class="gi">+            self.wrapped_excepthook += 1</span>
<span class="gi">+            sys.excepthook = self.excepthook</span>
<span class="gi">+</span>
<span class="gi">+    def unwrap(self, stdout: bool = False, stderr: bool = False) -&gt; None:</span>
<span class="gi">+        if stdout:</span>
<span class="gi">+            self.unwrap_stdout()</span>
<span class="gi">+</span>
<span class="gi">+        if stderr:</span>
<span class="gi">+            self.unwrap_stderr()</span>
<span class="gi">+</span>
<span class="gi">+    def unwrap_stdout(self) -&gt; None:</span>
<span class="gi">+        if self.wrapped_stdout &gt; 1:</span>
<span class="gi">+            self.wrapped_stdout -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys.stdout = self.original_stdout</span>
<span class="gi">+            self.wrapped_stdout = 0</span>
<span class="gi">+</span>
<span class="gi">+    def unwrap_stderr(self) -&gt; None:</span>
<span class="gi">+        if self.wrapped_stderr &gt; 1:</span>
<span class="gi">+            self.wrapped_stderr -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys.stderr = self.original_stderr</span>
<span class="gi">+            self.wrapped_stderr = 0</span>
<span class="gi">+</span>
<span class="gi">+    def needs_clear(self) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+        stdout_needs_clear = getattr(self.stdout, &#39;needs_clear&#39;, False)</span>
<span class="gi">+        stderr_needs_clear = getattr(self.stderr, &#39;needs_clear&#39;, False)</span>
<span class="gi">+        return stderr_needs_clear or stdout_needs_clear</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        if self.wrapped_stdout and isinstance(self.stdout, WrappingIO):</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.stdout._flush()</span>
<span class="gi">+            except io.UnsupportedOperation:  # pragma: no cover</span>
<span class="gi">+                self.wrapped_stdout = False</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    &#39;Disabling stdout redirection, %r is not seekable&#39;,</span>
<span class="gi">+                    sys.stdout,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if self.wrapped_stderr and isinstance(self.stderr, WrappingIO):</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.stderr._flush()</span>
<span class="gi">+            except io.UnsupportedOperation:  # pragma: no cover</span>
<span class="gi">+                self.wrapped_stderr = False</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    &#39;Disabling stderr redirection, %r is not seekable&#39;,</span>
<span class="gi">+                    sys.stderr,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def excepthook(self, exc_type, exc_value, exc_traceback):</span>
<span class="gi">+        self.original_excepthook(exc_type, exc_value, exc_traceback)</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+</span>

<span class="w"> </span>class AttributeDict(dict):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    A dict that can be accessed with .attribute.

<span class="w"> </span>    &gt;&gt;&gt; attrs = AttributeDict(spam=123)
<span class="gu">@@ -185,18 +422,18 @@ class AttributeDict(dict):</span>
<span class="w"> </span>    Traceback (most recent call last):
<span class="w"> </span>    ...
<span class="w"> </span>    AttributeError: No such attribute: spam
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="gd">-    def __getattr__(self, name: str) -&gt;int:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; int:</span>
<span class="w"> </span>        if name in self:
<span class="w"> </span>            return self[name]
<span class="w"> </span>        else:
<span class="w"> </span>            raise AttributeError(f&#39;No such attribute: {name}&#39;)

<span class="gd">-    def __setattr__(self, name: str, value: int) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, name: str, value: int) -&gt; None:</span>
<span class="w"> </span>        self[name] = value

<span class="gd">-    def __delattr__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __delattr__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        if name in self:
<span class="w"> </span>            del self[name]
<span class="w"> </span>        else:
<span class="gh">diff --git a/progressbar/widgets.py b/progressbar/widgets.py</span>
<span class="gh">index be97fda..e5046b6 100644</span>
<span class="gd">--- a/progressbar/widgets.py</span>
<span class="gi">+++ b/progressbar/widgets.py</span>
<span class="gu">@@ -1,27 +1,49 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import contextlib
<span class="w"> </span>import datetime
<span class="w"> </span>import functools
<span class="w"> </span>import logging
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="gi">+# Ruff is being stupid and doesn&#39;t understand `ClassVar` if it comes from the</span>
<span class="gi">+# `types` module</span>
<span class="w"> </span>from typing import ClassVar
<span class="gi">+</span>
<span class="w"> </span>from python_utils import containers, converters, types
<span class="gi">+</span>
<span class="w"> </span>from . import algorithms, base, terminal, utils
<span class="w"> </span>from .terminal import colors
<span class="gi">+</span>
<span class="w"> </span>if types.TYPE_CHECKING:
<span class="w"> </span>    from .bar import ProgressBarMixinBase
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>MAX_DATE = datetime.date.max
<span class="w"> </span>MAX_TIME = datetime.time.max
<span class="w"> </span>MAX_DATETIME = datetime.datetime.max
<span class="gi">+</span>
<span class="w"> </span>Data = types.Dict[str, types.Any]
<span class="w"> </span>FormatString = typing.Optional[str]
<span class="gi">+</span>
<span class="w"> </span>T = typing.TypeVar(&#39;T&#39;)


<span class="gi">+def string_or_lambda(input_):</span>
<span class="gi">+    if isinstance(input_, str):</span>
<span class="gi">+</span>
<span class="gi">+        def render_input(progress, data, width):</span>
<span class="gi">+            return input_ % data</span>
<span class="gi">+</span>
<span class="gi">+        return render_input</span>
<span class="gi">+    else:</span>
<span class="gi">+        return input_</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def create_wrapper(wrapper):
<span class="gd">-    &quot;&quot;&quot;Convert a wrapper tuple or format string to a format string.</span>
<span class="gi">+    &#39;&#39;&#39;Convert a wrapper tuple or format string to a format string.</span>

<span class="w"> </span>    &gt;&gt;&gt; create_wrapper(&#39;&#39;)

<span class="gu">@@ -30,20 +52,63 @@ def create_wrapper(wrapper):</span>

<span class="w"> </span>    &gt;&gt;&gt; print(create_wrapper((&#39;a&#39;, &#39;b&#39;)))
<span class="w"> </span>    a{}b
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    if isinstance(wrapper, tuple) and len(wrapper) == 2:</span>
<span class="gi">+        a, b = wrapper</span>
<span class="gi">+        wrapper = (a or &#39;&#39;) + &#39;{}&#39; + (b or &#39;&#39;)</span>
<span class="gi">+    elif not wrapper:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(wrapper, str):</span>
<span class="gi">+        assert &#39;{}&#39; in wrapper, &#39;Expected string with {} for formatting&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise RuntimeError(  # noqa: TRY004</span>
<span class="gi">+            &#39;Pass either a begin/end string as a tuple or a template string &#39;</span>
<span class="gi">+            &#39;with `{}`&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def wrapper(function, wrapper_):
<span class="gd">-    &quot;&quot;&quot;Wrap the output of a function in a template string or a tuple with</span>
<span class="gi">+    &#39;&#39;&#39;Wrap the output of a function in a template string or a tuple with</span>
<span class="w"> </span>    begin/end strings.

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    wrapper_ = create_wrapper(wrapper_)</span>
<span class="gi">+    if not wrapper_:</span>
<span class="gi">+        return function</span>
<span class="gi">+</span>
<span class="gi">+    @functools.wraps(function)</span>
<span class="gi">+    def wrap(*args, **kwargs):</span>
<span class="gi">+        return wrapper_.format(function(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+    return wrap</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_marker(marker, wrap=None):</span>
<span class="gi">+    def _marker(progress, data, width):</span>
<span class="gi">+        if (</span>
<span class="gi">+            progress.max_value is not base.UnknownLength</span>
<span class="gi">+            and progress.max_value &gt; 0</span>
<span class="gi">+        ):</span>
<span class="gi">+            length = int(progress.value / progress.max_value * width)</span>
<span class="gi">+            return marker * length</span>
<span class="gi">+        else:</span>
<span class="gi">+            return marker</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(marker, str):</span>
<span class="gi">+        marker = converters.to_unicode(marker)</span>
<span class="gi">+        assert (</span>
<span class="gi">+            utils.len_color(marker) == 1</span>
<span class="gi">+        ), &#39;Markers are required to be 1 char&#39;</span>
<span class="gi">+        return wrapper(_marker, wrap)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return wrapper(marker, wrap)</span>


<span class="w"> </span>class FormatWidgetMixin(abc.ABC):
<span class="gd">-    &quot;&quot;&quot;Mixin to format widgets using a formatstring.</span>
<span class="gi">+    &#39;&#39;&#39;Mixin to format widgets using a formatstring.</span>

<span class="w"> </span>    Variables available:
<span class="w"> </span>     - max_value: The maximum value (can be None with iterators)
<span class="gu">@@ -56,15 +121,27 @@ class FormatWidgetMixin(abc.ABC):</span>
<span class="w"> </span>     - time_elapsed: Shortcut for HH:MM:SS time since the bar started including
<span class="w"> </span>       days
<span class="w"> </span>     - percentage: Percentage as a float
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, format: str, new_style: bool=False, **kwargs):</span>
<span class="gi">+    def __init__(self, format: str, new_style: bool = False, **kwargs):</span>
<span class="w"> </span>        self.new_style = new_style
<span class="w"> </span>        self.format = format

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format:</span>
<span class="gd">-        types.Optional[str]=None) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Formats the widget into a string.&quot;&quot;&quot;</span>
<span class="gi">+    def get_format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        return format or self.format</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        &#39;&#39;&#39;Formats the widget into a string.&#39;&#39;&#39;</span>
<span class="w"> </span>        format_ = self.get_format(progress, data, format)
<span class="w"> </span>        try:
<span class="w"> </span>            if self.new_style:
<span class="gu">@@ -72,13 +149,16 @@ class FormatWidgetMixin(abc.ABC):</span>
<span class="w"> </span>            else:
<span class="w"> </span>                return format_ % data
<span class="w"> </span>        except (TypeError, KeyError):
<span class="gd">-            logger.exception(&#39;Error while formatting %r with data: %r&#39;,</span>
<span class="gd">-                format_, data)</span>
<span class="gi">+            logger.exception(</span>
<span class="gi">+                &#39;Error while formatting %r with data: %r&#39;,</span>
<span class="gi">+                format_,</span>
<span class="gi">+                data,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            raise


<span class="w"> </span>class WidthWidgetMixin(abc.ABC):
<span class="gd">-    &quot;&quot;&quot;Mixing to make sure widgets are only visible if the screen is within a</span>
<span class="gi">+    &#39;&#39;&#39;Mixing to make sure widgets are only visible if the screen is within a</span>
<span class="w"> </span>    specified size range so the progressbar fits on both large and small
<span class="w"> </span>    screens.

<span class="gu">@@ -100,12 +180,22 @@ class WidthWidgetMixin(abc.ABC):</span>
<span class="w"> </span>    &gt;&gt;&gt; Progress.term_width = 11
<span class="w"> </span>    &gt;&gt;&gt; WidthWidgetMixin(5, 10).check_size(Progress)
<span class="w"> </span>    False
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, min_width=None, max_width=None, **kwargs):
<span class="w"> </span>        self.min_width = min_width
<span class="w"> </span>        self.max_width = max_width

<span class="gi">+    def check_size(self, progress: ProgressBarMixinBase):</span>
<span class="gi">+        max_width = self.max_width</span>
<span class="gi">+        min_width = self.min_width</span>
<span class="gi">+        if min_width and min_width &gt; progress.term_width:</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif max_width and max_width &lt; progress.term_width:  # noqa: SIM103</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>

<span class="w"> </span>class TGradientColors(typing.TypedDict):
<span class="w"> </span>    fg: types.Optional[terminal.OptionalColor | None]
<span class="gu">@@ -118,7 +208,7 @@ class TFixedColors(typing.TypedDict):</span>


<span class="w"> </span>class WidgetBase(WidthWidgetMixin, metaclass=abc.ABCMeta):
<span class="gd">-    &quot;&quot;&quot;The base class for all widgets.</span>
<span class="gi">+    &#39;&#39;&#39;The base class for all widgets.</span>

<span class="w"> </span>    The ProgressBar will call the widget&#39;s update value when the widget should
<span class="w"> </span>    be updated. The widget&#39;s size may change between calls, but the widget may
<span class="gu">@@ -144,61 +234,102 @@ class WidgetBase(WidthWidgetMixin, metaclass=abc.ABCMeta):</span>
<span class="w"> </span>       progressbar can be reused. Some widgets such as the FormatCustomText
<span class="w"> </span>       require the shared state so this needs to be optional

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    copy = True

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Updates the widget.</span>
<span class="gi">+    def __call__(self, progress: ProgressBarMixinBase, data: Data) -&gt; str:</span>
<span class="gi">+        &#39;&#39;&#39;Updates the widget.</span>

<span class="w"> </span>        progress - a reference to the calling ProgressBar
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-    _fixed_colors: ClassVar[TFixedColors] = TFixedColors(fg_none=None,</span>
<span class="gd">-        bg_none=None)</span>
<span class="gd">-    _gradient_colors: ClassVar[TGradientColors] = TGradientColors(fg=None,</span>
<span class="gd">-        bg=None)</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    _fixed_colors: ClassVar[TFixedColors] = TFixedColors(</span>
<span class="gi">+        fg_none=None,</span>
<span class="gi">+        bg_none=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    _gradient_colors: ClassVar[TGradientColors] = TGradientColors(</span>
<span class="gi">+        fg=None,</span>
<span class="gi">+        bg=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    # _fixed_colors: ClassVar[dict[str, terminal.Color | None]] = dict()</span>
<span class="gi">+    # _gradient_colors: ClassVar[dict[str, terminal.OptionalColor | None]] = (</span>
<span class="gi">+    #     dict())</span>
<span class="w"> </span>    _len: typing.Callable[[str | bytes], int] = len

<span class="gd">-    def __init__(self, *args, fixed_colors=None, gradient_colors=None, **kwargs</span>
<span class="gd">-        ):</span>
<span class="gi">+    @functools.cached_property</span>
<span class="gi">+    def uses_colors(self):</span>
<span class="gi">+        for value in self._gradient_colors.values():  # pragma: no branch</span>
<span class="gi">+            if value is not None:  # pragma: no branch</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return any(value is not None for value in self._fixed_colors.values())</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_colors(self, text: str, data: Data) -&gt; str:</span>
<span class="gi">+        if self.uses_colors:</span>
<span class="gi">+            return terminal.apply_colors(</span>
<span class="gi">+                text,</span>
<span class="gi">+                data.get(&#39;percentage&#39;),</span>
<span class="gi">+                **self._gradient_colors,</span>
<span class="gi">+                **self._fixed_colors,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return text</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *args,</span>
<span class="gi">+        fixed_colors=None,</span>
<span class="gi">+        gradient_colors=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if fixed_colors is not None:
<span class="w"> </span>            self._fixed_colors.update(fixed_colors)
<span class="gi">+</span>
<span class="w"> </span>        if gradient_colors is not None:
<span class="w"> </span>            self._gradient_colors.update(gradient_colors)
<span class="gi">+</span>
<span class="w"> </span>        if self.uses_colors:
<span class="w"> </span>            self._len = utils.len_color
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)


<span class="w"> </span>class AutoWidthWidgetBase(WidgetBase, metaclass=abc.ABCMeta):
<span class="gd">-    &quot;&quot;&quot;The base class for all variable width widgets.</span>
<span class="gi">+    &#39;&#39;&#39;The base class for all variable width widgets.</span>

<span class="w"> </span>    This widget is much like the \\hfill command in TeX, it will expand to
<span class="w"> </span>    fill the line. You can use more than one in the same line, and they will
<span class="w"> </span>    all have the same width, and together will fill the line.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width: int=0</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Updates the widget providing the total width the widget must fill.</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        &#39;&#39;&#39;Updates the widget providing the total width the widget must fill.</span>

<span class="w"> </span>        progress - a reference to the calling ProgressBar
<span class="w"> </span>        width - The total width the widget must fill
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>


<span class="w"> </span>class TimeSensitiveWidgetBase(WidgetBase, metaclass=abc.ABCMeta):
<span class="gd">-    &quot;&quot;&quot;The base class for all time sensitive widgets.</span>
<span class="gi">+    &#39;&#39;&#39;The base class for all time sensitive widgets.</span>

<span class="w"> </span>    Some widgets like timers would become out of date unless updated at least
<span class="w"> </span>    every `INTERVAL`
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    INTERVAL = datetime.timedelta(milliseconds=100)


<span class="w"> </span>class FormatLabel(FormatWidgetMixin, WidgetBase):
<span class="gd">-    &quot;&quot;&quot;Displays a formatted label.</span>
<span class="gi">+    &#39;&#39;&#39;Displays a formatted label.</span>

<span class="w"> </span>    &gt;&gt;&gt; label = FormatLabel(&#39;%(value)s&#39;, min_width=5, max_width=10)
<span class="w"> </span>    &gt;&gt;&gt; class Progress:
<span class="gu">@@ -207,41 +338,54 @@ class FormatLabel(FormatWidgetMixin, WidgetBase):</span>
<span class="w"> </span>    &gt;&gt;&gt; str(label(Progress, dict(value=&#39;test&#39;)))
<span class="w"> </span>    &#39;test ::  test &#39;

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    mapping: ClassVar[types.Dict[str, types.Tuple[str, types.Any]]] = dict(
<span class="gd">-        finished=(&#39;end_time&#39;, None), last_update=(&#39;last_update_time&#39;, None),</span>
<span class="gd">-        max=(&#39;max_value&#39;, None), seconds=(&#39;seconds_elapsed&#39;, None), start=(</span>
<span class="gd">-        &#39;start_time&#39;, None), elapsed=(&#39;total_seconds_elapsed&#39;, utils.</span>
<span class="gd">-        format_time), value=(&#39;value&#39;, None))</span>
<span class="gi">+        finished=(&#39;end_time&#39;, None),</span>
<span class="gi">+        last_update=(&#39;last_update_time&#39;, None),</span>
<span class="gi">+        max=(&#39;max_value&#39;, None),</span>
<span class="gi">+        seconds=(&#39;seconds_elapsed&#39;, None),</span>
<span class="gi">+        start=(&#39;start_time&#39;, None),</span>
<span class="gi">+        elapsed=(&#39;total_seconds_elapsed&#39;, utils.format_time),</span>
<span class="gi">+        value=(&#39;value&#39;, None),</span>
<span class="gi">+    )</span>

<span class="w"> </span>    def __init__(self, format: str, **kwargs):
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        WidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format:</span>
<span class="gd">-        types.Optional[str]=None):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        for name, (key, transform) in self.mapping.items():
<span class="w"> </span>            with contextlib.suppress(KeyError, ValueError, IndexError):
<span class="w"> </span>                if transform is None:
<span class="w"> </span>                    data[name] = data[key]
<span class="w"> </span>                else:
<span class="w"> </span>                    data[name] = transform(data[key])
<span class="gi">+</span>
<span class="w"> </span>        return FormatWidgetMixin.__call__(self, progress, data, format)


<span class="w"> </span>class Timer(FormatLabel, TimeSensitiveWidgetBase):
<span class="gd">-    &quot;&quot;&quot;WidgetBase which displays the elapsed seconds.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;WidgetBase which displays the elapsed seconds.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, format=&#39;Elapsed Time: %(elapsed)s&#39;, **kwargs):
<span class="w"> </span>        if &#39;%s&#39; in format and &#39;%(elapsed)s&#39; not in format:
<span class="w"> </span>            format = format.replace(&#39;%s&#39;, &#39;%(elapsed)s&#39;)
<span class="gi">+</span>
<span class="w"> </span>        FormatLabel.__init__(self, format=format, **kwargs)
<span class="w"> </span>        TimeSensitiveWidgetBase.__init__(self, **kwargs)
<span class="gi">+</span>
<span class="gi">+    # This is exposed as a static method for backwards compatibility</span>
<span class="w"> </span>    format_time = staticmethod(utils.format_time)


<span class="w"> </span>class SamplesMixin(TimeSensitiveWidgetBase, metaclass=abc.ABCMeta):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Mixing for widgets that average multiple measurements.

<span class="w"> </span>    Note that samples can be either an integer or a timedelta to indicate a
<span class="gu">@@ -270,37 +414,65 @@ class SamplesMixin(TimeSensitiveWidgetBase, metaclass=abc.ABCMeta):</span>

<span class="w"> </span>    &gt;&gt;&gt; samples(progress, None, True) == (datetime.timedelta(seconds=1), 0)
<span class="w"> </span>    True
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, samples=datetime.timedelta(seconds=2), key_prefix=</span>
<span class="gd">-        None, **kwargs):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        samples=datetime.timedelta(seconds=2),</span>
<span class="gi">+        key_prefix=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.samples = samples
<span class="w"> </span>        self.key_prefix = (key_prefix or self.__class__.__name__) + &#39;_&#39;
<span class="w"> </span>        TimeSensitiveWidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, delta:</span>
<span class="gd">-        bool=False):</span>
<span class="gi">+    def get_sample_times(self, progress: ProgressBarMixinBase, data: Data):</span>
<span class="gi">+        return progress.extra.setdefault(</span>
<span class="gi">+            f&#39;{self.key_prefix}sample_times&#39;,</span>
<span class="gi">+            containers.SliceableDeque(),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_sample_values(self, progress: ProgressBarMixinBase, data: Data):</span>
<span class="gi">+        return progress.extra.setdefault(</span>
<span class="gi">+            f&#39;{self.key_prefix}sample_values&#39;,</span>
<span class="gi">+            containers.SliceableDeque(),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        delta: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        sample_times = self.get_sample_times(progress, data)
<span class="w"> </span>        sample_values = self.get_sample_values(progress, data)
<span class="gi">+</span>
<span class="w"> </span>        if sample_times:
<span class="w"> </span>            sample_time = sample_times[-1]
<span class="w"> </span>        else:
<span class="w"> </span>            sample_time = datetime.datetime.min
<span class="gi">+</span>
<span class="w"> </span>        if progress.last_update_time - sample_time &gt; self.INTERVAL:
<span class="gi">+            # Add a sample but limit the size to `num_samples`</span>
<span class="w"> </span>            sample_times.append(progress.last_update_time)
<span class="w"> </span>            sample_values.append(progress.value)
<span class="gi">+</span>
<span class="w"> </span>            if isinstance(self.samples, datetime.timedelta):
<span class="w"> </span>                minimum_time = progress.last_update_time - self.samples
<span class="w"> </span>                minimum_value = sample_values[-1]
<span class="gd">-                while sample_times[2:] and minimum_time &gt; sample_times[1</span>
<span class="gd">-                    ] and minimum_value &gt; sample_values[1]:</span>
<span class="gi">+                while (</span>
<span class="gi">+                    sample_times[2:]</span>
<span class="gi">+                    and minimum_time &gt; sample_times[1]</span>
<span class="gi">+                    and minimum_value &gt; sample_values[1]</span>
<span class="gi">+                ):</span>
<span class="w"> </span>                    sample_times.pop(0)
<span class="w"> </span>                    sample_values.pop(0)
<span class="w"> </span>            elif len(sample_times) &gt; self.samples:
<span class="w"> </span>                sample_times.pop(0)
<span class="w"> </span>                sample_values.pop(0)
<span class="gi">+</span>
<span class="w"> </span>        if delta:
<span class="gd">-            if (delta_time := sample_times[-1] - sample_times[0]):</span>
<span class="gi">+            if delta_time := sample_times[-1] - sample_times[0]:</span>
<span class="w"> </span>                delta_value = sample_values[-1] - sample_values[0]
<span class="w"> </span>                return delta_time, delta_value
<span class="w"> </span>            else:
<span class="gu">@@ -310,13 +482,20 @@ class SamplesMixin(TimeSensitiveWidgetBase, metaclass=abc.ABCMeta):</span>


<span class="w"> </span>class ETA(Timer):
<span class="gd">-    &quot;&quot;&quot;WidgetBase which attempts to estimate the time of arrival.&quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, format_not_started=&#39;ETA:  --:--:--&#39;, format_finished</span>
<span class="gd">-        =&#39;Time: %(elapsed)8s&#39;, format=&#39;ETA:  %(eta)8s&#39;, format_zero=</span>
<span class="gd">-        &#39;ETA:  00:00:00&#39;, format_na=&#39;ETA:      N/A&#39;, **kwargs):</span>
<span class="gi">+    &#39;&#39;&#39;WidgetBase which attempts to estimate the time of arrival.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format_not_started=&#39;ETA:  --:--:--&#39;,</span>
<span class="gi">+        format_finished=&#39;Time: %(elapsed)8s&#39;,</span>
<span class="gi">+        format=&#39;ETA:  %(eta)8s&#39;,</span>
<span class="gi">+        format_zero=&#39;ETA:  00:00:00&#39;,</span>
<span class="gi">+        format_na=&#39;ETA:      N/A&#39;,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if &#39;%s&#39; in format and &#39;%(eta)s&#39; not in format:
<span class="w"> </span>            format = format.replace(&#39;%s&#39;, &#39;%(eta)s&#39;)
<span class="gi">+</span>
<span class="w"> </span>        Timer.__init__(self, **kwargs)
<span class="w"> </span>        self.format_not_started = format_not_started
<span class="w"> </span>        self.format_finished = format_finished
<span class="gu">@@ -324,29 +503,53 @@ class ETA(Timer):</span>
<span class="w"> </span>        self.format_zero = format_zero
<span class="w"> </span>        self.format_NA = format_na

<span class="gd">-    def _calculate_eta(self, progress: ProgressBarMixinBase, data: Data,</span>
<span class="gd">-        value, elapsed):</span>
<span class="gd">-        &quot;&quot;&quot;Updates the widget to show the ETA or total time when finished.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, value=</span>
<span class="gd">-        None, elapsed=None):</span>
<span class="gd">-        &quot;&quot;&quot;Updates the widget to show the ETA or total time when finished.&quot;&quot;&quot;</span>
<span class="gi">+    def _calculate_eta(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        value,</span>
<span class="gi">+        elapsed,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Updates the widget to show the ETA or total time when finished.&#39;&#39;&#39;</span>
<span class="gi">+        if elapsed:</span>
<span class="gi">+            # The max() prevents zero division errors</span>
<span class="gi">+            per_item = elapsed.total_seconds() / max(value, 1e-6)</span>
<span class="gi">+            remaining = progress.max_value - data[&#39;value&#39;]</span>
<span class="gi">+            return remaining * per_item</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        value=None,</span>
<span class="gi">+        elapsed=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Updates the widget to show the ETA or total time when finished.&#39;&#39;&#39;</span>
<span class="w"> </span>        if value is None:
<span class="w"> </span>            value = data[&#39;value&#39;]
<span class="gi">+</span>
<span class="w"> </span>        if elapsed is None:
<span class="w"> </span>            elapsed = data[&#39;time_elapsed&#39;]
<span class="gi">+</span>
<span class="w"> </span>        eta_na = False
<span class="w"> </span>        try:
<span class="gd">-            data[&#39;eta_seconds&#39;] = self._calculate_eta(progress, data, value</span>
<span class="gd">-                =value, elapsed=elapsed)</span>
<span class="gi">+            data[&#39;eta_seconds&#39;] = self._calculate_eta(</span>
<span class="gi">+                progress,</span>
<span class="gi">+                data,</span>
<span class="gi">+                value=value,</span>
<span class="gi">+                elapsed=elapsed,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except TypeError:
<span class="w"> </span>            data[&#39;eta_seconds&#39;] = None
<span class="w"> </span>            eta_na = True
<span class="gi">+</span>
<span class="w"> </span>        data[&#39;eta&#39;] = None
<span class="w"> </span>        if data[&#39;eta_seconds&#39;]:
<span class="w"> </span>            with contextlib.suppress(ValueError, OverflowError):
<span class="w"> </span>                data[&#39;eta&#39;] = utils.format_time(data[&#39;eta_seconds&#39;])
<span class="gi">+</span>
<span class="w"> </span>        if data[&#39;value&#39;] == progress.min_value:
<span class="w"> </span>            fmt = self.format_not_started
<span class="w"> </span>        elif progress.end_time:
<span class="gu">@@ -357,141 +560,230 @@ class ETA(Timer):</span>
<span class="w"> </span>            fmt = self.format_NA
<span class="w"> </span>        else:
<span class="w"> </span>            fmt = self.format_zero
<span class="gi">+</span>
<span class="w"> </span>        return Timer.__call__(self, progress, data, format=fmt)


<span class="w"> </span>class AbsoluteETA(ETA):
<span class="gd">-    &quot;&quot;&quot;Widget which attempts to estimate the absolute time of arrival.&quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, format_not_started=</span>
<span class="gd">-        &#39;Estimated finish time:  ----/--/-- --:--:--&#39;, format_finished=</span>
<span class="gd">-        &#39;Finished at: %(elapsed)s&#39;, format=&#39;Estimated finish time: %(eta)s&#39;,</span>
<span class="gd">-        **kwargs):</span>
<span class="gd">-        ETA.__init__(self, format_not_started=format_not_started,</span>
<span class="gd">-            format_finished=format_finished, format=format, **kwargs)</span>
<span class="gi">+    &#39;&#39;&#39;Widget which attempts to estimate the absolute time of arrival.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def _calculate_eta(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        value,</span>
<span class="gi">+        elapsed,</span>
<span class="gi">+    ):</span>
<span class="gi">+        eta_seconds = ETA._calculate_eta(self, progress, data, value, elapsed)</span>
<span class="gi">+        now = datetime.datetime.now()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return now + datetime.timedelta(seconds=eta_seconds)</span>
<span class="gi">+        except OverflowError:  # pragma: no cover</span>
<span class="gi">+            return datetime.datetime.max</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format_not_started=&#39;Estimated finish time:  ----/--/-- --:--:--&#39;,</span>
<span class="gi">+        format_finished=&#39;Finished at: %(elapsed)s&#39;,</span>
<span class="gi">+        format=&#39;Estimated finish time: %(eta)s&#39;,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        ETA.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            format_not_started=format_not_started,</span>
<span class="gi">+            format_finished=format_finished,</span>
<span class="gi">+            format=format,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class AdaptiveETA(ETA, SamplesMixin):
<span class="gd">-    &quot;&quot;&quot;WidgetBase which attempts to estimate the time of arrival.</span>
<span class="gi">+    &#39;&#39;&#39;WidgetBase which attempts to estimate the time of arrival.</span>

<span class="w"> </span>    Uses a sampled average of the speed based on the 10 last updates.
<span class="w"> </span>    Very convenient for resuming the progress halfway.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    exponential_smoothing: bool
<span class="w"> </span>    exponential_smoothing_factor: float

<span class="gd">-    def __init__(self, exponential_smoothing=True,</span>
<span class="gd">-        exponential_smoothing_factor=0.1, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exponential_smoothing=True,</span>
<span class="gi">+        exponential_smoothing_factor=0.1,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.exponential_smoothing = exponential_smoothing
<span class="w"> </span>        self.exponential_smoothing_factor = exponential_smoothing_factor
<span class="w"> </span>        ETA.__init__(self, **kwargs)
<span class="w"> </span>        SamplesMixin.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, value=</span>
<span class="gd">-        None, elapsed=None):</span>
<span class="gd">-        elapsed, value = SamplesMixin.__call__(self, progress, data, delta=True</span>
<span class="gd">-            )</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        value=None,</span>
<span class="gi">+        elapsed=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        elapsed, value = SamplesMixin.__call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            progress,</span>
<span class="gi">+            data,</span>
<span class="gi">+            delta=True,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if not elapsed:
<span class="w"> </span>            value = None
<span class="w"> </span>            elapsed = 0
<span class="gi">+</span>
<span class="w"> </span>        return ETA.__call__(self, progress, data, value=value, elapsed=elapsed)


<span class="w"> </span>class SmoothingETA(ETA):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    WidgetBase which attempts to estimate the time of arrival using an
<span class="w"> </span>    exponential moving average (EMA) of the speed.

<span class="w"> </span>    EMA applies more weight to recent data points and less to older ones,
<span class="w"> </span>    and doesn&#39;t require storing all past values. This approach works well
<span class="w"> </span>    with varying data points and smooths out fluctuations effectively.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    smoothing_algorithm: algorithms.SmoothingAlgorithm
<span class="w"> </span>    smoothing_parameters: dict[str, float]

<span class="gd">-    def __init__(self, smoothing_algorithm: type[algorithms.</span>
<span class="gd">-        SmoothingAlgorithm]=algorithms.ExponentialMovingAverage,</span>
<span class="gd">-        smoothing_parameters: (dict[str, float] | None)=None, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        smoothing_algorithm: type[</span>
<span class="gi">+            algorithms.SmoothingAlgorithm</span>
<span class="gi">+        ] = algorithms.ExponentialMovingAverage,</span>
<span class="gi">+        smoothing_parameters: dict[str, float] | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.smoothing_parameters = smoothing_parameters or {}
<span class="gd">-        self.smoothing_algorithm = smoothing_algorithm(**self.</span>
<span class="gd">-            smoothing_parameters or {})</span>
<span class="gi">+        self.smoothing_algorithm = smoothing_algorithm(</span>
<span class="gi">+            **(self.smoothing_parameters or {}),</span>
<span class="gi">+        )</span>
<span class="w"> </span>        ETA.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, value=</span>
<span class="gd">-        None, elapsed=None):</span>
<span class="gd">-        if value is None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        value=None,</span>
<span class="gi">+        elapsed=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if value is None:  # pragma: no branch</span>
<span class="w"> </span>            value = data[&#39;value&#39;]
<span class="gd">-        if elapsed is None:</span>
<span class="gi">+</span>
<span class="gi">+        if elapsed is None:  # pragma: no branch</span>
<span class="w"> </span>            elapsed = data[&#39;time_elapsed&#39;]
<span class="gi">+</span>
<span class="w"> </span>        self.smoothing_algorithm.update(value, elapsed)
<span class="w"> </span>        return ETA.__call__(self, progress, data, value=value, elapsed=elapsed)


<span class="w"> </span>class DataSize(FormatWidgetMixin, WidgetBase):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Widget for showing an amount of data transferred/processed.

<span class="w"> </span>    Automatically formats the value (assumed to be a count of bytes) with an
<span class="w"> </span>    appropriate sized unit, based on the IEC binary prefixes (powers of 1024).
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, variable=&#39;value&#39;, format=</span>
<span class="gd">-        &#39;%(scaled)5.1f %(prefix)s%(unit)s&#39;, unit=&#39;B&#39;, prefixes=(&#39;&#39;, &#39;Ki&#39;,</span>
<span class="gd">-        &#39;Mi&#39;, &#39;Gi&#39;, &#39;Ti&#39;, &#39;Pi&#39;, &#39;Ei&#39;, &#39;Zi&#39;, &#39;Yi&#39;), **kwargs):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        variable=&#39;value&#39;,</span>
<span class="gi">+        format=&#39;%(scaled)5.1f %(prefix)s%(unit)s&#39;,</span>
<span class="gi">+        unit=&#39;B&#39;,</span>
<span class="gi">+        prefixes=(&#39;&#39;, &#39;Ki&#39;, &#39;Mi&#39;, &#39;Gi&#39;, &#39;Ti&#39;, &#39;Pi&#39;, &#39;Ei&#39;, &#39;Zi&#39;, &#39;Yi&#39;),</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.variable = variable
<span class="w"> </span>        self.unit = unit
<span class="w"> </span>        self.prefixes = prefixes
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        WidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format:</span>
<span class="gd">-        types.Optional[str]=None):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        value = data[self.variable]
<span class="w"> </span>        if value is not None:
<span class="w"> </span>            scaled, power = utils.scale_1024(value, len(self.prefixes))
<span class="w"> </span>        else:
<span class="w"> </span>            scaled = power = 0
<span class="gi">+</span>
<span class="w"> </span>        data[&#39;scaled&#39;] = scaled
<span class="w"> </span>        data[&#39;prefix&#39;] = self.prefixes[power]
<span class="w"> </span>        data[&#39;unit&#39;] = self.unit
<span class="gi">+</span>
<span class="w"> </span>        return FormatWidgetMixin.__call__(self, progress, data, format)


<span class="w"> </span>class FileTransferSpeed(FormatWidgetMixin, TimeSensitiveWidgetBase):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Widget for showing the current transfer speed (useful for file transfers).
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, format=&#39;%(scaled)5.1f %(prefix)s%(unit)-s/s&#39;,</span>
<span class="gd">-        inverse_format=&#39;%(scaled)5.1f s/%(prefix)s%(unit)-s&#39;, unit=&#39;B&#39;,</span>
<span class="gd">-        prefixes=(&#39;&#39;, &#39;Ki&#39;, &#39;Mi&#39;, &#39;Gi&#39;, &#39;Ti&#39;, &#39;Pi&#39;, &#39;Ei&#39;, &#39;Zi&#39;, &#39;Yi&#39;), **kwargs</span>
<span class="gd">-        ):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format=&#39;%(scaled)5.1f %(prefix)s%(unit)-s/s&#39;,</span>
<span class="gi">+        inverse_format=&#39;%(scaled)5.1f s/%(prefix)s%(unit)-s&#39;,</span>
<span class="gi">+        unit=&#39;B&#39;,</span>
<span class="gi">+        prefixes=(&#39;&#39;, &#39;Ki&#39;, &#39;Mi&#39;, &#39;Gi&#39;, &#39;Ti&#39;, &#39;Pi&#39;, &#39;Ei&#39;, &#39;Zi&#39;, &#39;Yi&#39;),</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.unit = unit
<span class="w"> </span>        self.prefixes = prefixes
<span class="w"> </span>        self.inverse_format = inverse_format
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        TimeSensitiveWidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data, value=None,</span>
<span class="gd">-        total_seconds_elapsed=None):</span>
<span class="gd">-        &quot;&quot;&quot;Updates the widget with the current SI prefixed speed.&quot;&quot;&quot;</span>
<span class="gi">+    def _speed(self, value, elapsed):</span>
<span class="gi">+        speed = float(value) / elapsed</span>
<span class="gi">+        return utils.scale_1024(speed, len(self.prefixes))</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data,</span>
<span class="gi">+        value=None,</span>
<span class="gi">+        total_seconds_elapsed=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Updates the widget with the current SI prefixed speed.&#39;&#39;&#39;</span>
<span class="w"> </span>        if value is None:
<span class="w"> </span>            value = data[&#39;value&#39;]
<span class="gd">-        elapsed = utils.deltas_to_seconds(total_seconds_elapsed, data[</span>
<span class="gd">-            &#39;total_seconds_elapsed&#39;])</span>
<span class="gd">-        if (value is not None and elapsed is not None and elapsed &gt; 2e-06 and</span>
<span class="gd">-            value &gt; 2e-06):</span>
<span class="gi">+</span>
<span class="gi">+        elapsed = utils.deltas_to_seconds(</span>
<span class="gi">+            total_seconds_elapsed,</span>
<span class="gi">+            data[&#39;total_seconds_elapsed&#39;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            value is not None</span>
<span class="gi">+            and elapsed is not None</span>
<span class="gi">+            and elapsed &gt; 2e-6</span>
<span class="gi">+            and value &gt; 2e-6</span>
<span class="gi">+        ):  # =~ 0</span>
<span class="w"> </span>            scaled, power = self._speed(value, elapsed)
<span class="w"> </span>        else:
<span class="w"> </span>            scaled = power = 0
<span class="gi">+</span>
<span class="w"> </span>        data[&#39;unit&#39;] = self.unit
<span class="w"> </span>        if power == 0 and scaled &lt; 0.1:
<span class="w"> </span>            if scaled &gt; 0:
<span class="w"> </span>                scaled = 1 / scaled
<span class="w"> </span>            data[&#39;scaled&#39;] = scaled
<span class="w"> </span>            data[&#39;prefix&#39;] = self.prefixes[0]
<span class="gd">-            return FormatWidgetMixin.__call__(self, progress, data, self.</span>
<span class="gd">-                inverse_format)</span>
<span class="gi">+            return FormatWidgetMixin.__call__(</span>
<span class="gi">+                self,</span>
<span class="gi">+                progress,</span>
<span class="gi">+                data,</span>
<span class="gi">+                self.inverse_format,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            data[&#39;scaled&#39;] = scaled
<span class="w"> </span>            data[&#39;prefix&#39;] = self.prefixes[power]
<span class="gu">@@ -499,26 +791,42 @@ class FileTransferSpeed(FormatWidgetMixin, TimeSensitiveWidgetBase):</span>


<span class="w"> </span>class AdaptiveTransferSpeed(FileTransferSpeed, SamplesMixin):
<span class="gd">-    &quot;&quot;&quot;Widget for showing the transfer speed based on the last X samples.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Widget for showing the transfer speed based on the last X samples.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, **kwargs):
<span class="w"> </span>        FileTransferSpeed.__init__(self, **kwargs)
<span class="w"> </span>        SamplesMixin.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data, value=None,</span>
<span class="gd">-        total_seconds_elapsed=None):</span>
<span class="gd">-        elapsed, value = SamplesMixin.__call__(self, progress, data, delta=True</span>
<span class="gd">-            )</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data,</span>
<span class="gi">+        value=None,</span>
<span class="gi">+        total_seconds_elapsed=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        elapsed, value = SamplesMixin.__call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            progress,</span>
<span class="gi">+            data,</span>
<span class="gi">+            delta=True,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return FileTransferSpeed.__call__(self, progress, data, value, elapsed)


<span class="w"> </span>class AnimatedMarker(TimeSensitiveWidgetBase):
<span class="gd">-    &quot;&quot;&quot;An animated marker for the progress bar which defaults to appear as if</span>
<span class="gi">+    &#39;&#39;&#39;An animated marker for the progress bar which defaults to appear as if</span>
<span class="w"> </span>    it were rotating.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, markers=&#39;|/-\\&#39;, default=None, fill=&#39;&#39;, marker_wrap=</span>
<span class="gd">-        None, fill_wrap=None, **kwargs):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        markers=&#39;|/-\\&#39;,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        fill=&#39;&#39;,</span>
<span class="gi">+        marker_wrap=None,</span>
<span class="gi">+        fill_wrap=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.markers = markers
<span class="w"> </span>        self.marker_wrap = create_wrapper(marker_wrap)
<span class="w"> </span>        self.default = default or markers[0]
<span class="gu">@@ -527,62 +835,105 @@ class AnimatedMarker(TimeSensitiveWidgetBase):</span>
<span class="w"> </span>        WidgetBase.__init__(self, **kwargs)

<span class="w"> </span>    def __call__(self, progress: ProgressBarMixinBase, data: Data, width=None):
<span class="gd">-        &quot;&quot;&quot;Updates the widget to show the next marker or the first marker when</span>
<span class="gi">+        &#39;&#39;&#39;Updates the widget to show the next marker or the first marker when</span>
<span class="w"> </span>        finished.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        if progress.end_time:
<span class="w"> </span>            return self.default
<span class="gi">+</span>
<span class="w"> </span>        marker = self.markers[data[&#39;updates&#39;] % len(self.markers)]
<span class="w"> </span>        if self.marker_wrap:
<span class="w"> </span>            marker = self.marker_wrap.format(marker)
<span class="gi">+</span>
<span class="w"> </span>        if self.fill:
<span class="gd">-            fill = self.fill(progress, data, width - progress.custom_len(</span>
<span class="gd">-                marker))</span>
<span class="gi">+            # Cut the last character so we can replace it with our marker</span>
<span class="gi">+            fill = self.fill(</span>
<span class="gi">+                progress,</span>
<span class="gi">+                data,</span>
<span class="gi">+                width - progress.custom_len(marker),  # type: ignore</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            fill = &#39;&#39;
<span class="gd">-        if isinstance(marker, int):</span>
<span class="gi">+</span>
<span class="gi">+        # Python 3 returns an int when indexing bytes</span>
<span class="gi">+        if isinstance(marker, int):  # pragma: no cover</span>
<span class="w"> </span>            marker = bytes(marker)
<span class="w"> </span>            fill = fill.encode()
<span class="w"> </span>        else:
<span class="gi">+            # cast fill to the same type as marker</span>
<span class="w"> </span>            fill = type(marker)(fill)
<span class="gd">-        return fill + marker</span>
<span class="gi">+</span>
<span class="gi">+        return fill + marker  # type: ignore</span>


<span class="gi">+# Alias for backwards compatibility</span>
<span class="w"> </span>RotatingMarker = AnimatedMarker


<span class="w"> </span>class Counter(FormatWidgetMixin, WidgetBase):
<span class="gd">-    &quot;&quot;&quot;Displays the current count.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Displays the current count.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, format=&#39;%(value)d&#39;, **kwargs):
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        WidgetBase.__init__(self, format=format, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        return FormatWidgetMixin.__call__(self, progress, data, format)


<span class="w"> </span>class ColoredMixin:
<span class="gd">-    _fixed_colors: ClassVar[TFixedColors] = TFixedColors(fg_none=colors.</span>
<span class="gd">-        yellow, bg_none=None)</span>
<span class="gd">-    _gradient_colors: ClassVar[TGradientColors] = TGradientColors(fg=colors</span>
<span class="gd">-        .gradient, bg=None)</span>
<span class="gi">+    _fixed_colors: ClassVar[TFixedColors] = TFixedColors(</span>
<span class="gi">+        fg_none=colors.yellow,</span>
<span class="gi">+        bg_none=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    _gradient_colors: ClassVar[TGradientColors] = TGradientColors(</span>
<span class="gi">+        fg=colors.gradient,</span>
<span class="gi">+        bg=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    # _fixed_colors: ClassVar[dict[str, terminal.Color | None]] = dict(</span>
<span class="gi">+    #     fg_none=colors.yellow, bg_none=None)</span>
<span class="gi">+    # _gradient_colors: ClassVar[dict[str, terminal.OptionalColor |</span>
<span class="gi">+    #                                      None]] = dict(fg=colors.gradient,</span>
<span class="gi">+    #                                                    bg=None)</span>


<span class="w"> </span>class Percentage(FormatWidgetMixin, ColoredMixin, WidgetBase):
<span class="gd">-    &quot;&quot;&quot;Displays the current percentage as a number with a percent sign.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Displays the current percentage as a number with a percent sign.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, format=&#39;%(percentage)3d%%&#39;, na=&#39;N/A%%&#39;, **kwargs):
<span class="w"> </span>        self.na = na
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        WidgetBase.__init__(self, format=format, **kwargs)

<span class="gi">+    def get_format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # If percentage is not available, display N/A%</span>
<span class="gi">+        percentage = data.get(&#39;percentage&#39;, base.Undefined)</span>
<span class="gi">+        if not percentage and percentage != 0:</span>
<span class="gi">+            output = self.na</span>
<span class="gi">+        else:</span>
<span class="gi">+            output = FormatWidgetMixin.get_format(self, progress, data, format)</span>
<span class="gi">+</span>
<span class="gi">+        return self._apply_colors(output, data)</span>
<span class="gi">+</span>

<span class="w"> </span>class SimpleProgress(FormatWidgetMixin, ColoredMixin, WidgetBase):
<span class="gd">-    &quot;&quot;&quot;Returns progress as a count of the total (e.g.: &quot;5 of 47&quot;).&quot;&quot;&quot;</span>
<span class="gd">-    max_width_cache: dict[types.Union[str, tuple[float, float | types.Type[</span>
<span class="gd">-        base.UnknownLength]]], types.Optional[int]]</span>
<span class="gi">+    &#39;&#39;&#39;Returns progress as a count of the total (e.g.: &quot;5 of 47&quot;).&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    max_width_cache: dict[</span>
<span class="gi">+        types.Union[str, tuple[float, float | types.Type[base.UnknownLength]]],</span>
<span class="gi">+        types.Optional[int],</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>    DEFAULT_FORMAT = &#39;%(value_s)s of %(max_value_s)s&#39;

<span class="w"> </span>    def __init__(self, format=DEFAULT_FORMAT, **kwargs):
<span class="gu">@@ -590,44 +941,80 @@ class SimpleProgress(FormatWidgetMixin, ColoredMixin, WidgetBase):</span>
<span class="w"> </span>        WidgetBase.__init__(self, format=format, **kwargs)
<span class="w"> </span>        self.max_width_cache = dict(default=self.max_width or 0)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # If max_value is not available, display N/A</span>
<span class="w"> </span>        if data.get(&#39;max_value&#39;):
<span class="w"> </span>            data[&#39;max_value_s&#39;] = data[&#39;max_value&#39;]
<span class="w"> </span>        else:
<span class="w"> </span>            data[&#39;max_value_s&#39;] = &#39;N/A&#39;
<span class="gi">+</span>
<span class="gi">+        # if value is not available it&#39;s the zeroth iteration</span>
<span class="w"> </span>        if data.get(&#39;value&#39;):
<span class="w"> </span>            data[&#39;value_s&#39;] = data[&#39;value&#39;]
<span class="w"> </span>        else:
<span class="w"> </span>            data[&#39;value_s&#39;] = 0
<span class="gd">-        formatted = FormatWidgetMixin.__call__(self, progress, data, format</span>
<span class="gd">-            =format)</span>
<span class="gi">+</span>
<span class="gi">+        formatted = FormatWidgetMixin.__call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            progress,</span>
<span class="gi">+            data,</span>
<span class="gi">+            format=format,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Guess the maximum width from the min and max value</span>
<span class="w"> </span>        key = progress.min_value, progress.max_value
<span class="gd">-        max_width: types.Optional[int] = self.max_width_cache.get(key, self</span>
<span class="gd">-            .max_width)</span>
<span class="gi">+        max_width: types.Optional[int] = self.max_width_cache.get(</span>
<span class="gi">+            key,</span>
<span class="gi">+            self.max_width,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if not max_width:
<span class="w"> </span>            temporary_data = data.copy()
<span class="w"> </span>            for value in key:
<span class="gd">-                if value is None:</span>
<span class="gi">+                if value is None:  # pragma: no cover</span>
<span class="w"> </span>                    continue
<span class="gi">+</span>
<span class="w"> </span>                temporary_data[&#39;value&#39;] = value
<span class="gd">-                if (width := progress.custom_len(FormatWidgetMixin.__call__</span>
<span class="gd">-                    (self, progress, temporary_data, format=format))):</span>
<span class="gi">+                if width := progress.custom_len(  # pragma: no branch</span>
<span class="gi">+                    FormatWidgetMixin.__call__(</span>
<span class="gi">+                        self,</span>
<span class="gi">+                        progress,</span>
<span class="gi">+                        temporary_data,</span>
<span class="gi">+                        format=format,</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ):</span>
<span class="w"> </span>                    max_width = max(max_width or 0, width)
<span class="gi">+</span>
<span class="w"> </span>            self.max_width_cache[key] = max_width
<span class="gd">-        if max_width:</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust the output to have a consistent size in all cases</span>
<span class="gi">+        if max_width:  # pragma: no branch</span>
<span class="w"> </span>            formatted = formatted.rjust(max_width)
<span class="gi">+</span>
<span class="w"> </span>        return self._apply_colors(formatted, data)


<span class="w"> </span>class Bar(AutoWidthWidgetBase):
<span class="gd">-    &quot;&quot;&quot;A progress bar which stretches to fill the line.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;A progress bar which stretches to fill the line.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    fg: terminal.OptionalColor | None = colors.gradient
<span class="w"> </span>    bg: terminal.OptionalColor | None = None

<span class="gd">-    def __init__(self, marker=&#39;#&#39;, left=&#39;|&#39;, right=&#39;|&#39;, fill=&#39; &#39;, fill_left</span>
<span class="gd">-        =True, marker_wrap=None, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Creates a customizable progress bar.</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        marker=&#39;#&#39;,</span>
<span class="gi">+        left=&#39;|&#39;,</span>
<span class="gi">+        right=&#39;|&#39;,</span>
<span class="gi">+        fill=&#39; &#39;,</span>
<span class="gi">+        fill_left=True,</span>
<span class="gi">+        marker_wrap=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Creates a customizable progress bar.</span>

<span class="w"> </span>        The callable takes the same parameters as the `__call__` method

<span class="gu">@@ -636,94 +1023,146 @@ class Bar(AutoWidthWidgetBase):</span>
<span class="w"> </span>        right - string or callable object to use as a right border
<span class="w"> </span>        fill - character to use for the empty part of the progress bar
<span class="w"> </span>        fill_left - whether to fill from the left or the right
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        self.marker = create_marker(marker, marker_wrap)
<span class="w"> </span>        self.left = string_or_lambda(left)
<span class="w"> </span>        self.right = string_or_lambda(right)
<span class="w"> </span>        self.fill = string_or_lambda(fill)
<span class="w"> </span>        self.fill_left = fill_left
<span class="gi">+</span>
<span class="w"> </span>        AutoWidthWidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width:</span>
<span class="gd">-        int=0, color=True):</span>
<span class="gd">-        &quot;&quot;&quot;Updates the progress bar and its subcomponents.&quot;&quot;&quot;</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+        color=True,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Updates the progress bar and its subcomponents.&#39;&#39;&#39;</span>
<span class="w"> </span>        left = converters.to_unicode(self.left(progress, data, width))
<span class="w"> </span>        right = converters.to_unicode(self.right(progress, data, width))
<span class="w"> </span>        width -= progress.custom_len(left) + progress.custom_len(right)
<span class="w"> </span>        marker = converters.to_unicode(self.marker(progress, data, width))
<span class="w"> </span>        fill = converters.to_unicode(self.fill(progress, data, width))
<span class="gi">+</span>
<span class="gi">+        # Make sure we ignore invisible characters when filling</span>
<span class="w"> </span>        width += len(marker) - progress.custom_len(marker)
<span class="gi">+</span>
<span class="w"> </span>        if self.fill_left:
<span class="w"> </span>            marker = marker.ljust(width, fill)
<span class="w"> </span>        else:
<span class="w"> </span>            marker = marker.rjust(width, fill)
<span class="gi">+</span>
<span class="w"> </span>        if color:
<span class="w"> </span>            marker = self._apply_colors(marker, data)
<span class="gi">+</span>
<span class="w"> </span>        return left + marker + right


<span class="w"> </span>class ReverseBar(Bar):
<span class="gd">-    &quot;&quot;&quot;A bar which has a marker that goes from right to left.&quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, marker=&#39;#&#39;, left=&#39;|&#39;, right=&#39;|&#39;, fill=&#39; &#39;, fill_left</span>
<span class="gd">-        =False, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Creates a customizable progress bar.</span>
<span class="gi">+    &#39;&#39;&#39;A bar which has a marker that goes from right to left.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        marker=&#39;#&#39;,</span>
<span class="gi">+        left=&#39;|&#39;,</span>
<span class="gi">+        right=&#39;|&#39;,</span>
<span class="gi">+        fill=&#39; &#39;,</span>
<span class="gi">+        fill_left=False,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Creates a customizable progress bar.</span>

<span class="w"> </span>        marker - string or updatable object to use as a marker
<span class="w"> </span>        left - string or updatable object to use as a left border
<span class="w"> </span>        right - string or updatable object to use as a right border
<span class="w"> </span>        fill - character to use for the empty part of the progress bar
<span class="w"> </span>        fill_left - whether to fill from the left or the right
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Bar.__init__(self, marker=marker, left=left, right=right, fill=fill,</span>
<span class="gd">-            fill_left=fill_left, **kwargs)</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        Bar.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            marker=marker,</span>
<span class="gi">+            left=left,</span>
<span class="gi">+            right=right,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            fill_left=fill_left,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class BouncingBar(Bar, TimeSensitiveWidgetBase):
<span class="gd">-    &quot;&quot;&quot;A bar which has a marker which bounces from side to side.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;A bar which has a marker which bounces from side to side.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    INTERVAL = datetime.timedelta(milliseconds=100)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width:</span>
<span class="gd">-        int=0, color=True):</span>
<span class="gd">-        &quot;&quot;&quot;Updates the progress bar and its subcomponents.&quot;&quot;&quot;</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+        color=True,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Updates the progress bar and its subcomponents.&#39;&#39;&#39;</span>
<span class="w"> </span>        left = converters.to_unicode(self.left(progress, data, width))
<span class="w"> </span>        right = converters.to_unicode(self.right(progress, data, width))
<span class="w"> </span>        width -= progress.custom_len(left) + progress.custom_len(right)
<span class="w"> </span>        marker = converters.to_unicode(self.marker(progress, data, width))
<span class="gi">+</span>
<span class="w"> </span>        fill = converters.to_unicode(self.fill(progress, data, width))
<span class="gd">-        if width:</span>
<span class="gd">-            value = int(data[&#39;total_seconds_elapsed&#39;] / self.INTERVAL.</span>
<span class="gd">-                total_seconds())</span>
<span class="gi">+</span>
<span class="gi">+        if width:  # pragma: no branch</span>
<span class="gi">+            value = int(</span>
<span class="gi">+                data[&#39;total_seconds_elapsed&#39;] / self.INTERVAL.total_seconds(),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>            a = value % width
<span class="w"> </span>            b = width - a - 1
<span class="w"> </span>            if value % (width * 2) &gt;= width:
<span class="w"> </span>                a, b = b, a
<span class="gi">+</span>
<span class="w"> </span>            if self.fill_left:
<span class="w"> </span>                marker = a * fill + marker + b * fill
<span class="w"> </span>            else:
<span class="w"> </span>                marker = b * fill + marker + a * fill
<span class="gi">+</span>
<span class="w"> </span>        return left + marker + right


<span class="w"> </span>class FormatCustomText(FormatWidgetMixin, WidgetBase):
<span class="gd">-    mapping: types.Dict[str, types.Any] = dict()</span>
<span class="gi">+    mapping: types.Dict[str, types.Any] = dict()  # noqa: RUF012</span>
<span class="w"> </span>    copy = False

<span class="gd">-    def __init__(self, format: str, mapping: types.Optional[types.Dict[str,</span>
<span class="gd">-        types.Any]]=None, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format: str,</span>
<span class="gi">+        mapping: types.Optional[types.Dict[str, types.Any]] = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.format = format
<span class="w"> </span>        self.mapping = mapping or self.mapping
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        WidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format:</span>
<span class="gd">-        types.Optional[str]=None):</span>
<span class="gd">-        return FormatWidgetMixin.__call__(self, progress, self.mapping, </span>
<span class="gd">-            format or self.format)</span>
<span class="gi">+    def update_mapping(self, **mapping: types.Dict[str, types.Any]):</span>
<span class="gi">+        self.mapping.update(mapping)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        return FormatWidgetMixin.__call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            progress,</span>
<span class="gi">+            self.mapping,</span>
<span class="gi">+            format or self.format,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class VariableMixin:
<span class="gd">-    &quot;&quot;&quot;Mixin to display a custom user variable.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Mixin to display a custom user variable.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, name, **kwargs):
<span class="w"> </span>        if not isinstance(name, str):
<span class="gu">@@ -734,7 +1173,7 @@ class VariableMixin:</span>


<span class="w"> </span>class MultiRangeBar(Bar, VariableMixin):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    A bar with multiple sub-ranges, each represented by a different symbol.

<span class="w"> </span>    The various ranges are represented on a user-defined variable, formatted as
<span class="gu">@@ -746,20 +1185,29 @@ class MultiRangeBar(Bar, VariableMixin):</span>
<span class="w"> </span>            [&#39;Symbol2&#39;, amount2],
<span class="w"> </span>            ...
<span class="w"> </span>        ]
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, name, markers, **kwargs):
<span class="w"> </span>        VariableMixin.__init__(self, name)
<span class="w"> </span>        Bar.__init__(self, **kwargs)
<span class="w"> </span>        self.markers = [string_or_lambda(marker) for marker in markers]

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width:</span>
<span class="gd">-        int=0, color=True):</span>
<span class="gd">-        &quot;&quot;&quot;Updates the progress bar and its subcomponents.&quot;&quot;&quot;</span>
<span class="gi">+    def get_values(self, progress: ProgressBarMixinBase, data: Data):</span>
<span class="gi">+        return data[&#39;variables&#39;][self.name] or []</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+        color=True,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Updates the progress bar and its subcomponents.&#39;&#39;&#39;</span>
<span class="w"> </span>        left = converters.to_unicode(self.left(progress, data, width))
<span class="w"> </span>        right = converters.to_unicode(self.right(progress, data, width))
<span class="w"> </span>        width -= progress.custom_len(left) + progress.custom_len(right)
<span class="w"> </span>        values = self.get_values(progress, data)
<span class="gi">+</span>
<span class="w"> </span>        values_sum = sum(values)
<span class="w"> </span>        if width and values_sum:
<span class="w"> </span>            middle = &#39;&#39;
<span class="gu">@@ -768,6 +1216,7 @@ class MultiRangeBar(Bar, VariableMixin):</span>
<span class="w"> </span>            for marker, value in zip(self.markers, values):
<span class="w"> </span>                marker = converters.to_unicode(marker(progress, data, width))
<span class="w"> </span>                assert progress.custom_len(marker) == 1
<span class="gi">+</span>
<span class="w"> </span>                values_accumulated += value
<span class="w"> </span>                item_width = int(values_accumulated / values_sum * width)
<span class="w"> </span>                item_width -= width_accumulated
<span class="gu">@@ -777,14 +1226,51 @@ class MultiRangeBar(Bar, VariableMixin):</span>
<span class="w"> </span>            fill = converters.to_unicode(self.fill(progress, data, width))
<span class="w"> </span>            assert progress.custom_len(fill) == 1
<span class="w"> </span>            middle = fill * width
<span class="gi">+</span>
<span class="w"> </span>        return left + middle + right


<span class="w"> </span>class MultiProgressBar(MultiRangeBar):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name, markers=&#39; &#39;, **kwargs):</span>
<span class="gd">-        MultiRangeBar.__init__(self, name=name, markers=list(reversed(</span>
<span class="gd">-            markers)), **kwargs)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        # NOTE: the markers are not whitespace even though some</span>
<span class="gi">+        # terminals don&#39;t show the characters correctly!</span>
<span class="gi">+        markers=&#39; &#39;,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        MultiRangeBar.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            markers=list(reversed(markers)),</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_values(self, progress: ProgressBarMixinBase, data: Data):</span>
<span class="gi">+        ranges = [0.0] * len(self.markers)</span>
<span class="gi">+        for value in data[&#39;variables&#39;][self.name] or []:</span>
<span class="gi">+            if not isinstance(value, (int, float)):</span>
<span class="gi">+                # Progress is (value, max)</span>
<span class="gi">+                progress_value, progress_max = value</span>
<span class="gi">+                value = float(progress_value) / float(progress_max)</span>
<span class="gi">+</span>
<span class="gi">+            if not 0 &lt;= value &lt;= 1:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &#39;Range value needs to be in the range [0..1], &#39;</span>
<span class="gi">+                    f&#39;got {value}&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            range_ = value * (len(ranges) - 1)</span>
<span class="gi">+            pos = int(range_)</span>
<span class="gi">+            frac = range_ % 1</span>
<span class="gi">+            ranges[pos] += 1 - frac</span>
<span class="gi">+            if frac:</span>
<span class="gi">+                ranges[pos + 1] += frac</span>
<span class="gi">+</span>
<span class="gi">+        if self.fill_left:  # pragma: no branch</span>
<span class="gi">+            ranges = list(reversed(ranges))</span>
<span class="gi">+</span>
<span class="gi">+        return ranges</span>


<span class="w"> </span>class GranularMarkers:
<span class="gu">@@ -797,7 +1283,7 @@ class GranularMarkers:</span>


<span class="w"> </span>class GranularBar(AutoWidthWidgetBase):
<span class="gd">-    &quot;&quot;&quot;A progressbar that can display progress at a sub-character granularity</span>
<span class="gi">+    &#39;&#39;&#39;A progressbar that can display progress at a sub-character granularity</span>
<span class="w"> </span>    by using multiple marker characters.

<span class="w"> </span>    Examples of markers:
<span class="gu">@@ -810,130 +1296,214 @@ class GranularBar(AutoWidthWidgetBase):</span>

<span class="w"> </span>    The markers can be accessed through GranularMarkers. GranularMarkers.dots
<span class="w"> </span>    for example
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, markers=GranularMarkers.smooth, left=&#39;|&#39;, right=&#39;|&#39;,</span>
<span class="gd">-        **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Creates a customizable progress bar.</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        markers=GranularMarkers.smooth,</span>
<span class="gi">+        left=&#39;|&#39;,</span>
<span class="gi">+        right=&#39;|&#39;,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Creates a customizable progress bar.</span>

<span class="w"> </span>        markers - string of characters to use as granular progress markers. The
<span class="w"> </span>                  first character should represent 0% and the last 100%.
<span class="w"> </span>                  Ex: ` .oO`.
<span class="w"> </span>        left - string or callable object to use as a left border
<span class="w"> </span>        right - string or callable object to use as a right border
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        self.markers = markers
<span class="w"> </span>        self.left = string_or_lambda(left)
<span class="w"> </span>        self.right = string_or_lambda(right)
<span class="gi">+</span>
<span class="w"> </span>        AutoWidthWidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width: int=0</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        left = converters.to_unicode(self.left(progress, data, width))
<span class="w"> </span>        right = converters.to_unicode(self.right(progress, data, width))
<span class="w"> </span>        width -= progress.custom_len(left) + progress.custom_len(right)
<span class="gi">+</span>
<span class="w"> </span>        max_value = progress.max_value
<span class="gd">-        if max_value is not base.UnknownLength and max_value &gt; 0:</span>
<span class="gd">-            percent = progress.value / max_value</span>
<span class="gi">+        # mypy doesn&#39;t get that the first part of the if statement makes sure</span>
<span class="gi">+        # we get the correct type</span>
<span class="gi">+        if (</span>
<span class="gi">+            max_value is not base.UnknownLength</span>
<span class="gi">+            and max_value &gt; 0  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            percent = progress.value / max_value  # type: ignore</span>
<span class="w"> </span>        else:
<span class="w"> </span>            percent = 0
<span class="gi">+</span>
<span class="w"> </span>        num_chars = percent * width
<span class="gi">+</span>
<span class="w"> </span>        marker = self.markers[-1] * int(num_chars)
<span class="gd">-        if (marker_idx := int(num_chars % 1 * (len(self.markers) - 1))):</span>
<span class="gi">+</span>
<span class="gi">+        if marker_idx := int((num_chars % 1) * (len(self.markers) - 1)):</span>
<span class="w"> </span>            marker += self.markers[marker_idx]
<span class="gi">+</span>
<span class="w"> </span>        marker = converters.to_unicode(marker)
<span class="gi">+</span>
<span class="gi">+        # Make sure we ignore invisible characters when filling</span>
<span class="w"> </span>        width += len(marker) - progress.custom_len(marker)
<span class="w"> </span>        marker = marker.ljust(width, self.markers[0])
<span class="gi">+</span>
<span class="w"> </span>        return left + marker + right


<span class="w"> </span>class FormatLabelBar(FormatLabel, Bar):
<span class="gd">-    &quot;&quot;&quot;A bar which has a formatted label in the center.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;A bar which has a formatted label in the center.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, format, **kwargs):
<span class="w"> </span>        FormatLabel.__init__(self, format, **kwargs)
<span class="w"> </span>        Bar.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width:</span>
<span class="gd">-        int=0, format: FormatString=None):</span>
<span class="gi">+    def __call__(  # type: ignore</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+        format: FormatString = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        center = FormatLabel.__call__(self, progress, data, format=format)
<span class="w"> </span>        bar = Bar.__call__(self, progress, data, width, color=False)
<span class="gi">+</span>
<span class="gi">+        # Aligns the center of the label to the center of the bar</span>
<span class="w"> </span>        center_len = progress.custom_len(center)
<span class="w"> </span>        center_left = int((width - center_len) / 2)
<span class="w"> </span>        center_right = center_left + center_len
<span class="gd">-        return self._apply_colors(bar[:center_left], data</span>
<span class="gd">-            ) + self._apply_colors(center, data) + self._apply_colors(bar[</span>
<span class="gd">-            center_right:], data)</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._apply_colors(</span>
<span class="gi">+                bar[:center_left],</span>
<span class="gi">+                data,</span>
<span class="gi">+            )</span>
<span class="gi">+            + self._apply_colors(</span>
<span class="gi">+                center,</span>
<span class="gi">+                data,</span>
<span class="gi">+            )</span>
<span class="gi">+            + self._apply_colors(</span>
<span class="gi">+                bar[center_right:],</span>
<span class="gi">+                data,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PercentageLabelBar(Percentage, FormatLabelBar):
<span class="gd">-    &quot;&quot;&quot;A bar which displays the current percentage in the center.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;A bar which displays the current percentage in the center.&#39;&#39;&#39;</span>

<span class="gi">+    # %3d adds an extra space that makes it look off-center</span>
<span class="gi">+    # %2d keeps the label somewhat consistently in-place</span>
<span class="w"> </span>    def __init__(self, format=&#39;%(percentage)2d%%&#39;, na=&#39;N/A%%&#39;, **kwargs):
<span class="w"> </span>        Percentage.__init__(self, format, na=na, **kwargs)
<span class="w"> </span>        FormatLabelBar.__init__(self, format, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width:</span>
<span class="gd">-        int=0, format: FormatString=None):</span>
<span class="gi">+    def __call__(  # type: ignore</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+        format: FormatString = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        return super().__call__(progress, data, width, format=format)


<span class="w"> </span>class Variable(FormatWidgetMixin, VariableMixin, WidgetBase):
<span class="gd">-    &quot;&quot;&quot;Displays a custom variable.&quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name, format=&#39;{name}: {formatted_value}&#39;, width=6,</span>
<span class="gd">-        precision=3, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Creates a Variable associated with the given name.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Displays a custom variable.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        format=&#39;{name}: {formatted_value}&#39;,</span>
<span class="gi">+        width=6,</span>
<span class="gi">+        precision=3,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &#39;&#39;&#39;Creates a Variable associated with the given name.&#39;&#39;&#39;</span>
<span class="w"> </span>        self.format = format
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.precision = precision
<span class="w"> </span>        VariableMixin.__init__(self, name=name)
<span class="w"> </span>        WidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format:</span>
<span class="gd">-        types.Optional[str]=None):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        value = data[&#39;variables&#39;][self.name]
<span class="w"> </span>        context = data.copy()
<span class="w"> </span>        context[&#39;value&#39;] = value
<span class="w"> </span>        context[&#39;name&#39;] = self.name
<span class="w"> </span>        context[&#39;width&#39;] = self.width
<span class="w"> </span>        context[&#39;precision&#39;] = self.precision
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="gi">+            # Make sure to try and cast the value first, otherwise the</span>
<span class="gi">+            # formatting will generate warnings/errors on newer Python releases</span>
<span class="w"> </span>            value = float(value)
<span class="w"> </span>            fmt = &#39;{value:{width}.{precision}}&#39;
<span class="w"> </span>            context[&#39;formatted_value&#39;] = fmt.format(**context)
<span class="w"> </span>        except (TypeError, ValueError):
<span class="w"> </span>            if value:
<span class="gd">-                context[&#39;formatted_value&#39;] = &#39;{value:{width}}&#39;.format(**context</span>
<span class="gd">-                    )</span>
<span class="gi">+                context[&#39;formatted_value&#39;] = &#39;{value:{width}}&#39;.format(</span>
<span class="gi">+                    **context,</span>
<span class="gi">+                )</span>
<span class="w"> </span>            else:
<span class="w"> </span>                context[&#39;formatted_value&#39;] = &#39;-&#39; * self.width
<span class="gi">+</span>
<span class="w"> </span>        return self.format.format(**context)


<span class="w"> </span>class DynamicMessage(Variable):
<span class="gd">-    &quot;&quot;&quot;Kept for backwards compatibility, please use `Variable` instead.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Kept for backwards compatibility, please use `Variable` instead.&#39;&#39;&#39;</span>


<span class="w"> </span>class CurrentTime(FormatWidgetMixin, TimeSensitiveWidgetBase):
<span class="gd">-    &quot;&quot;&quot;Widget which displays the current (date)time with seconds resolution.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Widget which displays the current (date)time with seconds resolution.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    INTERVAL = datetime.timedelta(seconds=1)

<span class="gd">-    def __init__(self, format=&#39;Current Time: %(current_time)s&#39;,</span>
<span class="gd">-        microseconds=False, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format=&#39;Current Time: %(current_time)s&#39;,</span>
<span class="gi">+        microseconds=False,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.microseconds = microseconds
<span class="w"> </span>        FormatWidgetMixin.__init__(self, format=format, **kwargs)
<span class="w"> </span>        TimeSensitiveWidgetBase.__init__(self, **kwargs)

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, format:</span>
<span class="gd">-        types.Optional[str]=None):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        format: types.Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        data[&#39;current_time&#39;] = self.current_time()
<span class="w"> </span>        data[&#39;current_datetime&#39;] = self.current_datetime()
<span class="gi">+</span>
<span class="w"> </span>        return FormatWidgetMixin.__call__(self, progress, data, format=format)

<span class="gi">+    def current_datetime(self):</span>
<span class="gi">+        now = datetime.datetime.now()</span>
<span class="gi">+        if not self.microseconds:</span>
<span class="gi">+            now = now.replace(microsecond=0)</span>
<span class="gi">+</span>
<span class="gi">+        return now</span>
<span class="gi">+</span>
<span class="gi">+    def current_time(self):</span>
<span class="gi">+        return self.current_datetime().time()</span>
<span class="gi">+</span>

<span class="w"> </span>class JobStatusBar(Bar, VariableMixin):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Widget which displays the job status as markers on the bar.

<span class="w"> </span>    The status updates can be given either as a boolean or as a string. If it&#39;s
<span class="gu">@@ -953,7 +1523,8 @@ class JobStatusBar(Bar, VariableMixin):</span>
<span class="w"> </span>        failure_fg_color: The foreground color to use for failed jobs.
<span class="w"> </span>        failure_bg_color: The background color to use for failed jobs.
<span class="w"> </span>        failure_marker: The marker to use for failed jobs.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    success_fg_color: terminal.Color | None = colors.green
<span class="w"> </span>    success_bg_color: terminal.Color | None = None
<span class="w"> </span>    success_marker: str = &#39;&#39;
<span class="gu">@@ -962,10 +1533,21 @@ class JobStatusBar(Bar, VariableMixin):</span>
<span class="w"> </span>    failure_marker: str = &#39;X&#39;
<span class="w"> </span>    job_markers: list[str]

<span class="gd">-    def __init__(self, name: str, left=&#39;|&#39;, right=&#39;|&#39;, fill=&#39; &#39;, fill_left=</span>
<span class="gd">-        True, success_fg_color=colors.green, success_bg_color=None,</span>
<span class="gd">-        success_marker=&#39;&#39;, failure_fg_color=colors.red, failure_bg_color=</span>
<span class="gd">-        None, failure_marker=&#39;X&#39;, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        left=&#39;|&#39;,</span>
<span class="gi">+        right=&#39;|&#39;,</span>
<span class="gi">+        fill=&#39; &#39;,</span>
<span class="gi">+        fill_left=True,</span>
<span class="gi">+        success_fg_color=colors.green,</span>
<span class="gi">+        success_bg_color=None,</span>
<span class="gi">+        success_marker=&#39;&#39;,</span>
<span class="gi">+        failure_fg_color=colors.red,</span>
<span class="gi">+        failure_bg_color=None,</span>
<span class="gi">+        failure_marker=&#39;X&#39;,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        VariableMixin.__init__(self, name)
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.job_markers = []
<span class="gu">@@ -978,41 +1560,60 @@ class JobStatusBar(Bar, VariableMixin):</span>
<span class="w"> </span>        self.failure_fg_color = failure_fg_color
<span class="w"> </span>        self.failure_bg_color = failure_bg_color
<span class="w"> </span>        self.failure_marker = failure_marker
<span class="gd">-        Bar.__init__(self, left=left, right=right, fill=fill, fill_left=</span>
<span class="gd">-            fill_left, **kwargs)</span>

<span class="gd">-    def __call__(self, progress: ProgressBarMixinBase, data: Data, width:</span>
<span class="gd">-        int=0, color=True):</span>
<span class="gi">+        Bar.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            left=left,</span>
<span class="gi">+            right=right,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            fill_left=fill_left,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: ProgressBarMixinBase,</span>
<span class="gi">+        data: Data,</span>
<span class="gi">+        width: int = 0,</span>
<span class="gi">+        color=True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        left = converters.to_unicode(self.left(progress, data, width))
<span class="w"> </span>        right = converters.to_unicode(self.right(progress, data, width))
<span class="w"> </span>        width -= progress.custom_len(left) + progress.custom_len(right)
<span class="gi">+</span>
<span class="w"> </span>        status: str | bool | None = data[&#39;variables&#39;].get(self.name)
<span class="gi">+</span>
<span class="w"> </span>        if width and status is not None:
<span class="w"> </span>            if status is True:
<span class="w"> </span>                marker = self.success_marker
<span class="w"> </span>                fg_color = self.success_fg_color
<span class="w"> </span>                bg_color = self.success_bg_color
<span class="gd">-            elif status is False:</span>
<span class="gi">+            elif status is False:  # pragma: no branch</span>
<span class="w"> </span>                marker = self.failure_marker
<span class="w"> </span>                fg_color = self.failure_fg_color
<span class="w"> </span>                bg_color = self.failure_bg_color
<span class="gd">-            else:</span>
<span class="gi">+            else:  # pragma: no cover</span>
<span class="w"> </span>                marker = status
<span class="w"> </span>                fg_color = bg_color = None
<span class="gi">+</span>
<span class="w"> </span>            marker = converters.to_unicode(marker)
<span class="gd">-            if fg_color:</span>
<span class="gi">+            if fg_color:  # pragma: no branch</span>
<span class="w"> </span>                marker = fg_color.fg(marker)
<span class="gd">-            if bg_color:</span>
<span class="gi">+            if bg_color:  # pragma: no cover</span>
<span class="w"> </span>                marker = bg_color.bg(marker)
<span class="gi">+</span>
<span class="w"> </span>            self.job_markers.append(marker)
<span class="w"> </span>            marker = &#39;&#39;.join(self.job_markers)
<span class="w"> </span>            width -= progress.custom_len(marker)
<span class="gi">+</span>
<span class="w"> </span>            fill = converters.to_unicode(self.fill(progress, data, width))
<span class="w"> </span>            fill = self._apply_colors(fill * width, data)
<span class="gd">-            if self.fill_left:</span>
<span class="gi">+</span>
<span class="gi">+            if self.fill_left:  # pragma: no branch</span>
<span class="w"> </span>                marker += fill
<span class="gd">-            else:</span>
<span class="gi">+            else:  # pragma: no cover</span>
<span class="w"> </span>                marker = fill + marker
<span class="w"> </span>        else:
<span class="w"> </span>            marker = &#39;&#39;
<span class="gi">+</span>
<span class="w"> </span>        return left + marker + right
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>