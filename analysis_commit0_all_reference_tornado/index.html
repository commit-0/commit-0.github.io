
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference tornado - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-tornado" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference tornado
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-test" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_connection_closed" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_connection_closed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_read_until_close" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_read_until_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_read_zero_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_read_zero_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_write_while_connecting" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_write_while_connecting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_future_interface" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_future_interface
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_future_close_while_reading" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_future_close_while_reading
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreamwebmixintest_future_read_until_close" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamWebMixin::test_future_read_until_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_write_zero_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_write_zero_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_future_delayed_close_callback" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_future_delayed_close_callback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_close_buffered_data" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_close_buffered_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_close_after_close" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_close_after_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_large_read_until" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_large_read_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_with_close_after_second_packet" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_with_close_after_second_packet
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_unsatisfied_after_close" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_unsatisfied_after_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_close_callback_with_pending_read" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_close_callback_with_pending_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_future_close_callback" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_future_close_callback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_write_memoryview" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_write_memoryview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_bytes_partial" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_bytes_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_max_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_max_bytes_inline" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes_inline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_max_bytes_ignores_extra" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes_ignores_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_regex_max_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_regex_max_bytes_inline" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes_inline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_until_regex_max_bytes_ignores_extra" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes_ignores_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_small_reads_from_large_buffer" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_small_reads_from_large_buffer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_small_read_untils_from_large_buffer" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_small_read_untils_from_large_buffer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_flow_control" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_flow_control
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_into" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_into
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_into_partial" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_into_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_read_into_zero_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_read_into_zero_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestreadwritemixintest_many_mixed_reads" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestReadWriteMixin::test_many_mixed_reads
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_write_zero_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_write_zero_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_future_delayed_close_callback" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_future_delayed_close_callback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_close_buffered_data" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_close_buffered_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_close_after_close" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_close_after_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_large_read_until" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_large_read_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_with_close_after_second_packet" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_with_close_after_second_packet
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_unsatisfied_after_close" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_unsatisfied_after_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_close_callback_with_pending_read" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_close_callback_with_pending_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_future_close_callback" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_future_close_callback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_write_memoryview" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_write_memoryview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_bytes_partial" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_bytes_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_max_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_max_bytes_inline" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes_inline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_max_bytes_ignores_extra" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes_ignores_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_regex_max_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_regex_max_bytes_inline" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes_inline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_regex_max_bytes_ignores_extra" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes_ignores_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_small_reads_from_large_buffer" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_small_reads_from_large_buffer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_small_read_untils_from_large_buffer" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_small_read_untils_from_large_buffer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_flow_control" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_flow_control
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_into" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_into
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_into_partial" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_into_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_into_zero_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_into_zero_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_many_mixed_reads" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_many_mixed_reads
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_connection_refused" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_connection_refused
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_gaierror" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_gaierror
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_read_until_close_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_read_until_close_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_inline_read_error" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_inline_read_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_async_read_error_logging" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_async_read_error_logging
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iostream_testpytestiostreammixintest_future_write" class="md-nav__link">
    <span class="md-ellipsis">
      iostream_test.py::TestIOStreamMixin::test_future_write
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-tornado"><strong>Reference (Gold)</strong>: tornado</h1>
<h2 id="pytest-summary-for-test-test">Pytest Summary for test <code>test</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1144</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">57</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">61</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1262</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1262</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="iostream_testpytestiostreamwebmixintest_connection_closed">iostream_test.py::TestIOStreamWebMixin::test_connection_closed</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_connection_closed</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f0240ba5d80>

    def test_connection_closed(self: typing.Any):
        # When a server sends a response and then closes the connection,
        # the client must be allowed to read the data before the IOStream
        # closes itself.  Epoll reports closed connections with a separate
        # EPOLLRDHUP event delivered at the same time as the read event,
        # while kqueue reports them as a second read/write event with an EOF
        # flag.
>       response = self.fetch("/", headers={"Connection": "close"})
E       AttributeError: 'TestIOStreamWebMixin' object has no attribute 'fetch'

tornado/test/iostream_test.py:73: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreamwebmixintest_read_until_close">iostream_test.py::TestIOStreamWebMixin::test_read_until_close</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_read_until_close</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f0240ba5510>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamWebMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreamwebmixintest_read_zero_bytes">iostream_test.py::TestIOStreamWebMixin::test_read_zero_bytes</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_read_zero_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f0240ba77c0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamWebMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreamwebmixintest_write_while_connecting">iostream_test.py::TestIOStreamWebMixin::test_write_while_connecting</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_write_while_connecting</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f0240ba7f10>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamWebMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreamwebmixintest_future_interface">iostream_test.py::TestIOStreamWebMixin::test_future_interface</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_future_interface</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f0240ba7220>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamWebMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreamwebmixintest_future_close_while_reading">iostream_test.py::TestIOStreamWebMixin::test_future_close_while_reading</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_future_close_while_reading</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f0240ba7040>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamWebMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreamwebmixintest_future_read_until_close">iostream_test.py::TestIOStreamWebMixin::test_future_read_until_close</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamWebMixin::test_future_read_until_close</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamWebMixin object at 0x7f024210dff0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamWebMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_write_zero_bytes">iostream_test.py::TestReadWriteMixin::test_write_zero_bytes</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_write_zero_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210f940>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_future_delayed_close_callback">iostream_test.py::TestReadWriteMixin::test_future_delayed_close_callback</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_future_delayed_close_callback</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210dc90>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_close_buffered_data">iostream_test.py::TestReadWriteMixin::test_close_buffered_data</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_close_buffered_data</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210e5f0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_close_after_close">iostream_test.py::TestReadWriteMixin::test_read_until_close_after_close</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_close_after_close</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210cd30>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_large_read_until">iostream_test.py::TestReadWriteMixin::test_large_read_until</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_large_read_until</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210cbb0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_with_close_after_second_packet">iostream_test.py::TestReadWriteMixin::test_read_until_with_close_after_second_packet</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_with_close_after_second_packet</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210e380>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_unsatisfied_after_close">iostream_test.py::TestReadWriteMixin::test_read_until_unsatisfied_after_close</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_unsatisfied_after_close</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210eec0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_close_callback_with_pending_read">iostream_test.py::TestReadWriteMixin::test_close_callback_with_pending_read</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_close_callback_with_pending_read</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f0240ba5e70>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_future_close_callback">iostream_test.py::TestReadWriteMixin::test_future_close_callback</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_future_close_callback</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f0240ba59c0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_write_memoryview">iostream_test.py::TestReadWriteMixin::test_write_memoryview</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_write_memoryview</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210ff10>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_bytes_partial">iostream_test.py::TestReadWriteMixin::test_read_bytes_partial</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_bytes_partial</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210ef20>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_max_bytes">iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210d300>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_max_bytes_inline">iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes_inline</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes_inline</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210c910>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_max_bytes_ignores_extra">iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes_ignores_extra</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_max_bytes_ignores_extra</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210c610>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_regex_max_bytes">iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210ea10>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_regex_max_bytes_inline">iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes_inline</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes_inline</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210ece0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_until_regex_max_bytes_ignores_extra">iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes_ignores_extra</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_until_regex_max_bytes_ignores_extra</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210d540>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_small_reads_from_large_buffer">iostream_test.py::TestReadWriteMixin::test_small_reads_from_large_buffer</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_small_reads_from_large_buffer</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210fb80>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_small_read_untils_from_large_buffer">iostream_test.py::TestReadWriteMixin::test_small_read_untils_from_large_buffer</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_small_read_untils_from_large_buffer</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210dc30>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_flow_control">iostream_test.py::TestReadWriteMixin::test_flow_control</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_flow_control</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210d9f0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_into">iostream_test.py::TestReadWriteMixin::test_read_into</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_into</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f024210f3d0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_into_partial">iostream_test.py::TestReadWriteMixin::test_read_into_partial</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_into_partial</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f0241956e60>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_read_into_zero_bytes">iostream_test.py::TestReadWriteMixin::test_read_into_zero_bytes</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_read_into_zero_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f0241956aa0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestreadwritemixintest_many_mixed_reads">iostream_test.py::TestReadWriteMixin::test_many_mixed_reads</h3>
<details><summary> <pre>iostream_test.py::TestReadWriteMixin::test_many_mixed_reads</pre></summary><pre>
self = <tornado.test.iostream_test.TestReadWriteMixin object at 0x7f02419569b0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestReadWriteMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_write_zero_bytes">iostream_test.py::TestIOStreamMixin::test_write_zero_bytes</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_write_zero_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0241955600>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_future_delayed_close_callback">iostream_test.py::TestIOStreamMixin::test_future_delayed_close_callback</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_future_delayed_close_callback</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f024210fe50>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_close_buffered_data">iostream_test.py::TestIOStreamMixin::test_close_buffered_data</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_close_buffered_data</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f024210faf0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_close_after_close">iostream_test.py::TestIOStreamMixin::test_read_until_close_after_close</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_close_after_close</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f024210d810>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_large_read_until">iostream_test.py::TestIOStreamMixin::test_large_read_until</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_large_read_until</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f024210cca0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_with_close_after_second_packet">iostream_test.py::TestIOStreamMixin::test_read_until_with_close_after_second_packet</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_with_close_after_second_packet</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240ba6fb0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_unsatisfied_after_close">iostream_test.py::TestIOStreamMixin::test_read_until_unsatisfied_after_close</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_unsatisfied_after_close</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbd780>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_close_callback_with_pending_read">iostream_test.py::TestIOStreamMixin::test_close_callback_with_pending_read</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_close_callback_with_pending_read</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbd990>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_future_close_callback">iostream_test.py::TestIOStreamMixin::test_future_close_callback</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_future_close_callback</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbfcd0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_write_memoryview">iostream_test.py::TestIOStreamMixin::test_write_memoryview</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_write_memoryview</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbd2a0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_bytes_partial">iostream_test.py::TestIOStreamMixin::test_read_bytes_partial</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_bytes_partial</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbce20>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_max_bytes">iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbe500>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_max_bytes_inline">iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes_inline</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes_inline</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbe3e0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_max_bytes_ignores_extra">iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes_ignores_extra</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_max_bytes_ignores_extra</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbdc30>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_regex_max_bytes">iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbf4f0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_regex_max_bytes_inline">iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes_inline</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes_inline</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbe620>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_regex_max_bytes_ignores_extra">iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes_ignores_extra</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_regex_max_bytes_ignores_extra</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbd3c0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_small_reads_from_large_buffer">iostream_test.py::TestIOStreamMixin::test_small_reads_from_large_buffer</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_small_reads_from_large_buffer</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbd240>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_small_read_untils_from_large_buffer">iostream_test.py::TestIOStreamMixin::test_small_read_untils_from_large_buffer</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_small_read_untils_from_large_buffer</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbe6e0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_flow_control">iostream_test.py::TestIOStreamMixin::test_flow_control</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_flow_control</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbc490>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_into">iostream_test.py::TestIOStreamMixin::test_read_into</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_into</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbc1c0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_into_partial">iostream_test.py::TestIOStreamMixin::test_read_into_partial</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_into_partial</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbc310>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_into_zero_bytes">iostream_test.py::TestIOStreamMixin::test_read_into_zero_bytes</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_into_zero_bytes</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f024210efb0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_many_mixed_reads">iostream_test.py::TestIOStreamMixin::test_many_mixed_reads</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_many_mixed_reads</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0241954df0>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_connection_refused">iostream_test.py::TestIOStreamMixin::test_connection_refused</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_connection_refused</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0241956f50>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_gaierror">iostream_test.py::TestIOStreamMixin::test_gaierror</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_gaierror</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0241956980>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_read_until_close_with_error">iostream_test.py::TestIOStreamMixin::test_read_until_close_with_error</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_read_until_close_with_error</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbf160>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_inline_read_error">iostream_test.py::TestIOStreamMixin::test_inline_read_error</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_inline_read_error</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbee90>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_async_read_error_logging">iostream_test.py::TestIOStreamMixin::test_async_read_error_logging</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_async_read_error_logging</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0240bbf670>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>
<h3 id="iostream_testpytestiostreammixintest_future_write">iostream_test.py::TestIOStreamMixin::test_future_write</h3>
<details><summary> <pre>iostream_test.py::TestIOStreamMixin::test_future_write</pre></summary><pre>
self = <tornado.test.iostream_test.TestIOStreamMixin object at 0x7f0241954d00>
args = (), kwargs = {}

    @functools.wraps(coro)
    def post_coroutine(self, *args, **kwargs):
        # type: (AsyncTestCase, *Any, **Any) -> None
        try:
>           return self.io_loop.run_sync(
                functools.partial(coro, self, *args, **kwargs), timeout=timeout
            )
E           AttributeError: 'TestIOStreamMixin' object has no attribute 'io_loop'

tornado/testing.py:604: AttributeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/tornado/_locale_data.py b/tornado/_locale_data.py</span>
<span class="gh">index 6e70773f..7a5d2852 100644</span>
<span class="gd">--- a/tornado/_locale_data.py</span>
<span class="gi">+++ b/tornado/_locale_data.py</span>
<span class="gu">@@ -1,51 +1,80 @@</span>
<span class="gi">+# Copyright 2012 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Data used by the tornado.locale module.&quot;&quot;&quot;
<span class="gd">-LOCALE_NAMES = {&#39;af_ZA&#39;: {&#39;name_en&#39;: &#39;Afrikaans&#39;, &#39;name&#39;: &#39;Afrikaans&#39;},</span>
<span class="gd">-    &#39;am_ET&#39;: {&#39;name_en&#39;: &#39;Amharic&#39;, &#39;name&#39;: &#39;&#39;}, &#39;ar_AR&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Arabic&#39;, &#39;name&#39;: &#39;&#39;}, &#39;bg_BG&#39;: {&#39;name_en&#39;: &#39;Bulgarian&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;&#39;}, &#39;bn_IN&#39;: {&#39;name_en&#39;: &#39;Bengali&#39;, &#39;name&#39;: &#39;&#39;}, &#39;bs_BA&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Bosnian&#39;, &#39;name&#39;: &#39;Bosanski&#39;}, &#39;ca_ES&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Catalan&#39;, &#39;name&#39;: &#39;Catal&#39;}, &#39;cs_CZ&#39;: {&#39;name_en&#39;: &#39;Czech&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;etina&#39;}, &#39;cy_GB&#39;: {&#39;name_en&#39;: &#39;Welsh&#39;, &#39;name&#39;: &#39;Cymraeg&#39;}, &#39;da_DK&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Danish&#39;, &#39;name&#39;: &#39;Dansk&#39;}, &#39;de_DE&#39;: {&#39;name_en&#39;: &#39;German&#39;,</span>
<span class="gd">-    &#39;name&#39;: &#39;Deutsch&#39;}, &#39;el_GR&#39;: {&#39;name_en&#39;: &#39;Greek&#39;, &#39;name&#39;: &#39;&#39;},</span>
<span class="gd">-    &#39;en_GB&#39;: {&#39;name_en&#39;: &#39;English (UK)&#39;, &#39;name&#39;: &#39;English (UK)&#39;}, &#39;en_US&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;English (US)&#39;, &#39;name&#39;: &#39;English (US)&#39;}, &#39;es_ES&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Spanish (Spain)&#39;, &#39;name&#39;: &#39;Espaol (Espaa)&#39;}, &#39;es_LA&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Spanish&#39;, &#39;name&#39;: &#39;Espaol&#39;}, &#39;et_EE&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Estonian&#39;, &#39;name&#39;: &#39;Eesti&#39;}, &#39;eu_ES&#39;: {&#39;name_en&#39;: &#39;Basque&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;Euskara&#39;}, &#39;fa_IR&#39;: {&#39;name_en&#39;: &#39;Persian&#39;, &#39;name&#39;: &#39;&#39;}, &#39;fi_FI&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Finnish&#39;, &#39;name&#39;: &#39;Suomi&#39;}, &#39;fr_CA&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;French (Canada)&#39;, &#39;name&#39;: &#39;Franais (Canada)&#39;}, &#39;fr_FR&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;French&#39;, &#39;name&#39;: &#39;Franais&#39;}, &#39;ga_IE&#39;: {&#39;name_en&#39;: &#39;Irish&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;Gaeilge&#39;}, &#39;gl_ES&#39;: {&#39;name_en&#39;: &#39;Galician&#39;, &#39;name&#39;: &#39;Galego&#39;}, &#39;he_IL&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Hebrew&#39;, &#39;name&#39;: &#39;&#39;}, &#39;hi_IN&#39;: {&#39;name_en&#39;: &#39;Hindi&#39;,</span>
<span class="gd">-    &#39;name&#39;: &#39;&#39;}, &#39;hr_HR&#39;: {&#39;name_en&#39;: &#39;Croatian&#39;, &#39;name&#39;: &#39;Hrvatski&#39;},</span>
<span class="gd">-    &#39;hu_HU&#39;: {&#39;name_en&#39;: &#39;Hungarian&#39;, &#39;name&#39;: &#39;Magyar&#39;}, &#39;id_ID&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Indonesian&#39;, &#39;name&#39;: &#39;Bahasa Indonesia&#39;}, &#39;is_IS&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Icelandic&#39;, &#39;name&#39;: &#39;slenska&#39;}, &#39;it_IT&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Italian&#39;, &#39;name&#39;: &#39;Italiano&#39;}, &#39;ja_JP&#39;: {&#39;name_en&#39;: &#39;Japanese&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;&#39;}, &#39;ko_KR&#39;: {&#39;name_en&#39;: &#39;Korean&#39;, &#39;name&#39;: &#39;&#39;}, &#39;lt_LT&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Lithuanian&#39;, &#39;name&#39;: &#39;Lietuvi&#39;}, &#39;lv_LV&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Latvian&#39;, &#39;name&#39;: &#39;Latvieu&#39;}, &#39;mk_MK&#39;: {&#39;name_en&#39;: &#39;Macedonian&#39;,</span>
<span class="gd">-    &#39;name&#39;: &#39;&#39;}, &#39;ml_IN&#39;: {&#39;name_en&#39;: &#39;Malayalam&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;&#39;}, &#39;ms_MY&#39;: {&#39;name_en&#39;: &#39;Malay&#39;, &#39;name&#39;: &#39;Bahasa Melayu&#39;},</span>
<span class="gd">-    &#39;nb_NO&#39;: {&#39;name_en&#39;: &#39;Norwegian (bokmal)&#39;, &#39;name&#39;: &#39;Norsk (bokml)&#39;},</span>
<span class="gd">-    &#39;nl_NL&#39;: {&#39;name_en&#39;: &#39;Dutch&#39;, &#39;name&#39;: &#39;Nederlands&#39;}, &#39;nn_NO&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Norwegian (nynorsk)&#39;, &#39;name&#39;: &#39;Norsk (nynorsk)&#39;}, &#39;pa_IN&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Punjabi&#39;, &#39;name&#39;: &#39;&#39;}, &#39;pl_PL&#39;: {&#39;name_en&#39;: &#39;Polish&#39;,</span>
<span class="gd">-    &#39;name&#39;: &#39;Polski&#39;}, &#39;pt_BR&#39;: {&#39;name_en&#39;: &#39;Portuguese (Brazil)&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;Portugus (Brasil)&#39;}, &#39;pt_PT&#39;: {&#39;name_en&#39;: &#39;Portuguese (Portugal)&#39;,</span>
<span class="gd">-    &#39;name&#39;: &#39;Portugus (Portugal)&#39;}, &#39;ro_RO&#39;: {&#39;name_en&#39;: &#39;Romanian&#39;,</span>
<span class="gd">-    &#39;name&#39;: &#39;Romn&#39;}, &#39;ru_RU&#39;: {&#39;name_en&#39;: &#39;Russian&#39;, &#39;name&#39;: &#39;&#39;},</span>
<span class="gd">-    &#39;sk_SK&#39;: {&#39;name_en&#39;: &#39;Slovak&#39;, &#39;name&#39;: &#39;Slovenina&#39;}, &#39;sl_SI&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Slovenian&#39;, &#39;name&#39;: &#39;Slovenina&#39;}, &#39;sq_AL&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Albanian&#39;, &#39;name&#39;: &#39;Shqip&#39;}, &#39;sr_RS&#39;: {&#39;name_en&#39;: &#39;Serbian&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;&#39;}, &#39;sv_SE&#39;: {&#39;name_en&#39;: &#39;Swedish&#39;, &#39;name&#39;: &#39;Svenska&#39;}, &#39;sw_KE&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Swahili&#39;, &#39;name&#39;: &#39;Kiswahili&#39;}, &#39;ta_IN&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Tamil&#39;, &#39;name&#39;: &#39;&#39;}, &#39;te_IN&#39;: {&#39;name_en&#39;: &#39;Telugu&#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;&#39;}, &#39;th_TH&#39;: {&#39;name_en&#39;: &#39;Thai&#39;, &#39;name&#39;: &#39;&#39;}, &#39;tl_PH&#39;: {</span>
<span class="gd">-    &#39;name_en&#39;: &#39;Filipino&#39;, &#39;name&#39;: &#39;Filipino&#39;}, &#39;tr_TR&#39;: {&#39;name_en&#39;:</span>
<span class="gd">-    &#39;Turkish&#39;, &#39;name&#39;: &#39;Trke&#39;}, &#39;uk_UA&#39;: {&#39;name_en&#39;: &#39;Ukraini &#39;, &#39;name&#39;:</span>
<span class="gd">-    &#39;&#39;}, &#39;vi_VN&#39;: {&#39;name_en&#39;: &#39;Vietnamese&#39;, &#39;name&#39;: &#39;Ting Vit&#39;},</span>
<span class="gd">-    &#39;zh_CN&#39;: {&#39;name_en&#39;: &#39;Chinese (Simplified)&#39;, &#39;name&#39;: &#39;()&#39;}, &#39;zh_TW&#39;:</span>
<span class="gd">-    {&#39;name_en&#39;: &#39;Chinese (Traditional)&#39;, &#39;name&#39;: &#39;()&#39;}}</span>
<span class="gi">+</span>
<span class="gi">+LOCALE_NAMES = {</span>
<span class="gi">+    &quot;af_ZA&quot;: {&quot;name_en&quot;: &quot;Afrikaans&quot;, &quot;name&quot;: &quot;Afrikaans&quot;},</span>
<span class="gi">+    &quot;am_ET&quot;: {&quot;name_en&quot;: &quot;Amharic&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;ar_AR&quot;: {&quot;name_en&quot;: &quot;Arabic&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;bg_BG&quot;: {&quot;name_en&quot;: &quot;Bulgarian&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;bn_IN&quot;: {&quot;name_en&quot;: &quot;Bengali&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;bs_BA&quot;: {&quot;name_en&quot;: &quot;Bosnian&quot;, &quot;name&quot;: &quot;Bosanski&quot;},</span>
<span class="gi">+    &quot;ca_ES&quot;: {&quot;name_en&quot;: &quot;Catalan&quot;, &quot;name&quot;: &quot;Catal&quot;},</span>
<span class="gi">+    &quot;cs_CZ&quot;: {&quot;name_en&quot;: &quot;Czech&quot;, &quot;name&quot;: &quot;etina&quot;},</span>
<span class="gi">+    &quot;cy_GB&quot;: {&quot;name_en&quot;: &quot;Welsh&quot;, &quot;name&quot;: &quot;Cymraeg&quot;},</span>
<span class="gi">+    &quot;da_DK&quot;: {&quot;name_en&quot;: &quot;Danish&quot;, &quot;name&quot;: &quot;Dansk&quot;},</span>
<span class="gi">+    &quot;de_DE&quot;: {&quot;name_en&quot;: &quot;German&quot;, &quot;name&quot;: &quot;Deutsch&quot;},</span>
<span class="gi">+    &quot;el_GR&quot;: {&quot;name_en&quot;: &quot;Greek&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;en_GB&quot;: {&quot;name_en&quot;: &quot;English (UK)&quot;, &quot;name&quot;: &quot;English (UK)&quot;},</span>
<span class="gi">+    &quot;en_US&quot;: {&quot;name_en&quot;: &quot;English (US)&quot;, &quot;name&quot;: &quot;English (US)&quot;},</span>
<span class="gi">+    &quot;es_ES&quot;: {&quot;name_en&quot;: &quot;Spanish (Spain)&quot;, &quot;name&quot;: &quot;Espaol (Espaa)&quot;},</span>
<span class="gi">+    &quot;es_LA&quot;: {&quot;name_en&quot;: &quot;Spanish&quot;, &quot;name&quot;: &quot;Espaol&quot;},</span>
<span class="gi">+    &quot;et_EE&quot;: {&quot;name_en&quot;: &quot;Estonian&quot;, &quot;name&quot;: &quot;Eesti&quot;},</span>
<span class="gi">+    &quot;eu_ES&quot;: {&quot;name_en&quot;: &quot;Basque&quot;, &quot;name&quot;: &quot;Euskara&quot;},</span>
<span class="gi">+    &quot;fa_IR&quot;: {&quot;name_en&quot;: &quot;Persian&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;fi_FI&quot;: {&quot;name_en&quot;: &quot;Finnish&quot;, &quot;name&quot;: &quot;Suomi&quot;},</span>
<span class="gi">+    &quot;fr_CA&quot;: {&quot;name_en&quot;: &quot;French (Canada)&quot;, &quot;name&quot;: &quot;Franais (Canada)&quot;},</span>
<span class="gi">+    &quot;fr_FR&quot;: {&quot;name_en&quot;: &quot;French&quot;, &quot;name&quot;: &quot;Franais&quot;},</span>
<span class="gi">+    &quot;ga_IE&quot;: {&quot;name_en&quot;: &quot;Irish&quot;, &quot;name&quot;: &quot;Gaeilge&quot;},</span>
<span class="gi">+    &quot;gl_ES&quot;: {&quot;name_en&quot;: &quot;Galician&quot;, &quot;name&quot;: &quot;Galego&quot;},</span>
<span class="gi">+    &quot;he_IL&quot;: {&quot;name_en&quot;: &quot;Hebrew&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;hi_IN&quot;: {&quot;name_en&quot;: &quot;Hindi&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;hr_HR&quot;: {&quot;name_en&quot;: &quot;Croatian&quot;, &quot;name&quot;: &quot;Hrvatski&quot;},</span>
<span class="gi">+    &quot;hu_HU&quot;: {&quot;name_en&quot;: &quot;Hungarian&quot;, &quot;name&quot;: &quot;Magyar&quot;},</span>
<span class="gi">+    &quot;id_ID&quot;: {&quot;name_en&quot;: &quot;Indonesian&quot;, &quot;name&quot;: &quot;Bahasa Indonesia&quot;},</span>
<span class="gi">+    &quot;is_IS&quot;: {&quot;name_en&quot;: &quot;Icelandic&quot;, &quot;name&quot;: &quot;slenska&quot;},</span>
<span class="gi">+    &quot;it_IT&quot;: {&quot;name_en&quot;: &quot;Italian&quot;, &quot;name&quot;: &quot;Italiano&quot;},</span>
<span class="gi">+    &quot;ja_JP&quot;: {&quot;name_en&quot;: &quot;Japanese&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;ko_KR&quot;: {&quot;name_en&quot;: &quot;Korean&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;lt_LT&quot;: {&quot;name_en&quot;: &quot;Lithuanian&quot;, &quot;name&quot;: &quot;Lietuvi&quot;},</span>
<span class="gi">+    &quot;lv_LV&quot;: {&quot;name_en&quot;: &quot;Latvian&quot;, &quot;name&quot;: &quot;Latvieu&quot;},</span>
<span class="gi">+    &quot;mk_MK&quot;: {&quot;name_en&quot;: &quot;Macedonian&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;ml_IN&quot;: {&quot;name_en&quot;: &quot;Malayalam&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;ms_MY&quot;: {&quot;name_en&quot;: &quot;Malay&quot;, &quot;name&quot;: &quot;Bahasa Melayu&quot;},</span>
<span class="gi">+    &quot;nb_NO&quot;: {&quot;name_en&quot;: &quot;Norwegian (bokmal)&quot;, &quot;name&quot;: &quot;Norsk (bokml)&quot;},</span>
<span class="gi">+    &quot;nl_NL&quot;: {&quot;name_en&quot;: &quot;Dutch&quot;, &quot;name&quot;: &quot;Nederlands&quot;},</span>
<span class="gi">+    &quot;nn_NO&quot;: {&quot;name_en&quot;: &quot;Norwegian (nynorsk)&quot;, &quot;name&quot;: &quot;Norsk (nynorsk)&quot;},</span>
<span class="gi">+    &quot;pa_IN&quot;: {&quot;name_en&quot;: &quot;Punjabi&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;pl_PL&quot;: {&quot;name_en&quot;: &quot;Polish&quot;, &quot;name&quot;: &quot;Polski&quot;},</span>
<span class="gi">+    &quot;pt_BR&quot;: {&quot;name_en&quot;: &quot;Portuguese (Brazil)&quot;, &quot;name&quot;: &quot;Portugus (Brasil)&quot;},</span>
<span class="gi">+    &quot;pt_PT&quot;: {&quot;name_en&quot;: &quot;Portuguese (Portugal)&quot;, &quot;name&quot;: &quot;Portugus (Portugal)&quot;},</span>
<span class="gi">+    &quot;ro_RO&quot;: {&quot;name_en&quot;: &quot;Romanian&quot;, &quot;name&quot;: &quot;Romn&quot;},</span>
<span class="gi">+    &quot;ru_RU&quot;: {&quot;name_en&quot;: &quot;Russian&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;sk_SK&quot;: {&quot;name_en&quot;: &quot;Slovak&quot;, &quot;name&quot;: &quot;Slovenina&quot;},</span>
<span class="gi">+    &quot;sl_SI&quot;: {&quot;name_en&quot;: &quot;Slovenian&quot;, &quot;name&quot;: &quot;Slovenina&quot;},</span>
<span class="gi">+    &quot;sq_AL&quot;: {&quot;name_en&quot;: &quot;Albanian&quot;, &quot;name&quot;: &quot;Shqip&quot;},</span>
<span class="gi">+    &quot;sr_RS&quot;: {&quot;name_en&quot;: &quot;Serbian&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;sv_SE&quot;: {&quot;name_en&quot;: &quot;Swedish&quot;, &quot;name&quot;: &quot;Svenska&quot;},</span>
<span class="gi">+    &quot;sw_KE&quot;: {&quot;name_en&quot;: &quot;Swahili&quot;, &quot;name&quot;: &quot;Kiswahili&quot;},</span>
<span class="gi">+    &quot;ta_IN&quot;: {&quot;name_en&quot;: &quot;Tamil&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;te_IN&quot;: {&quot;name_en&quot;: &quot;Telugu&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;th_TH&quot;: {&quot;name_en&quot;: &quot;Thai&quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;tl_PH&quot;: {&quot;name_en&quot;: &quot;Filipino&quot;, &quot;name&quot;: &quot;Filipino&quot;},</span>
<span class="gi">+    &quot;tr_TR&quot;: {&quot;name_en&quot;: &quot;Turkish&quot;, &quot;name&quot;: &quot;Trke&quot;},</span>
<span class="gi">+    &quot;uk_UA&quot;: {&quot;name_en&quot;: &quot;Ukraini &quot;, &quot;name&quot;: &quot;&quot;},</span>
<span class="gi">+    &quot;vi_VN&quot;: {&quot;name_en&quot;: &quot;Vietnamese&quot;, &quot;name&quot;: &quot;Ting Vit&quot;},</span>
<span class="gi">+    &quot;zh_CN&quot;: {&quot;name_en&quot;: &quot;Chinese (Simplified)&quot;, &quot;name&quot;: &quot;()&quot;},</span>
<span class="gi">+    &quot;zh_TW&quot;: {&quot;name_en&quot;: &quot;Chinese (Traditional)&quot;, &quot;name&quot;: &quot;()&quot;},</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/tornado/auth.py b/tornado/auth.py</span>
<span class="gh">index bbf6ea3c..d1edcc65 100644</span>
<span class="gd">--- a/tornado/auth.py</span>
<span class="gi">+++ b/tornado/auth.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;This module contains implementations of various third-party
<span class="w"> </span>authentication schemes.

<span class="gu">@@ -56,6 +71,7 @@ Example usage for Google OAuth:</span>
<span class="w"> </span>   :hide:

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import binascii
<span class="w"> </span>import hashlib
<span class="gu">@@ -64,11 +80,13 @@ import time</span>
<span class="w"> </span>import urllib.parse
<span class="w"> </span>import uuid
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from tornado import httpclient
<span class="w"> </span>from tornado import escape
<span class="w"> </span>from tornado.httputil import url_concat
<span class="w"> </span>from tornado.util import unicode_type
<span class="w"> </span>from tornado.web import RequestHandler
<span class="gi">+</span>
<span class="w"> </span>from typing import List, Any, Dict, cast, Iterable, Union, Optional


<span class="gu">@@ -84,8 +102,11 @@ class OpenIdMixin(object):</span>
<span class="w"> </span>    * ``_OPENID_ENDPOINT``: the identity provider&#39;s URI.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def authenticate_redirect(self, callback_uri: Optional[str]=None,</span>
<span class="gd">-        ax_attrs: List[str]=[&#39;name&#39;, &#39;email&#39;, &#39;language&#39;, &#39;username&#39;]) -&gt;None:</span>
<span class="gi">+    def authenticate_redirect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        callback_uri: Optional[str] = None,</span>
<span class="gi">+        ax_attrs: List[str] = [&quot;name&quot;, &quot;email&quot;, &quot;language&quot;, &quot;username&quot;],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Redirects to the authentication URL for this service.

<span class="w"> </span>        After authentication, the service will redirect back to the given
<span class="gu">@@ -102,10 +123,16 @@ class OpenIdMixin(object):</span>
<span class="w"> </span>            longer returns an awaitable object. It is now an ordinary
<span class="w"> </span>            synchronous function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def get_authenticated_user(self, http_client: Optional[httpclient</span>
<span class="gd">-        .AsyncHTTPClient]=None) -&gt;Dict[str, Any]:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        callback_uri = callback_uri or handler.request.uri</span>
<span class="gi">+        assert callback_uri is not None</span>
<span class="gi">+        args = self._openid_args(callback_uri, ax_attrs=ax_attrs)</span>
<span class="gi">+        endpoint = self._OPENID_ENDPOINT  # type: ignore</span>
<span class="gi">+        handler.redirect(endpoint + &quot;?&quot; + urllib.parse.urlencode(args))</span>
<span class="gi">+</span>
<span class="gi">+    async def get_authenticated_user(</span>
<span class="gi">+        self, http_client: Optional[httpclient.AsyncHTTPClient] = None</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetches the authenticated user data upon redirect.

<span class="w"> </span>        This method should be called by the handler that receives the
<span class="gu">@@ -121,15 +148,143 @@ class OpenIdMixin(object):</span>
<span class="w"> </span>            The ``callback`` argument was removed. Use the returned
<span class="w"> </span>            awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_auth_http_client(self) -&gt;httpclient.AsyncHTTPClient:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        # Verify the OpenID response via direct request to the OP</span>
<span class="gi">+        args = dict(</span>
<span class="gi">+            (k, v[-1]) for k, v in handler.request.arguments.items()</span>
<span class="gi">+        )  # type: Dict[str, Union[str, bytes]]</span>
<span class="gi">+        args[&quot;openid.mode&quot;] = &quot;check_authentication&quot;</span>
<span class="gi">+        url = self._OPENID_ENDPOINT  # type: ignore</span>
<span class="gi">+        if http_client is None:</span>
<span class="gi">+            http_client = self.get_auth_http_client()</span>
<span class="gi">+        resp = await http_client.fetch(</span>
<span class="gi">+            url, method=&quot;POST&quot;, body=urllib.parse.urlencode(args)</span>
<span class="gi">+        )</span>
<span class="gi">+        return self._on_authentication_verified(resp)</span>
<span class="gi">+</span>
<span class="gi">+    def _openid_args(</span>
<span class="gi">+        self,</span>
<span class="gi">+        callback_uri: str,</span>
<span class="gi">+        ax_attrs: Iterable[str] = [],</span>
<span class="gi">+        oauth_scope: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; Dict[str, str]:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        url = urllib.parse.urljoin(handler.request.full_url(), callback_uri)</span>
<span class="gi">+        args = {</span>
<span class="gi">+            &quot;openid.ns&quot;: &quot;http://specs.openid.net/auth/2.0&quot;,</span>
<span class="gi">+            &quot;openid.claimed_id&quot;: &quot;http://specs.openid.net/auth/2.0/identifier_select&quot;,</span>
<span class="gi">+            &quot;openid.identity&quot;: &quot;http://specs.openid.net/auth/2.0/identifier_select&quot;,</span>
<span class="gi">+            &quot;openid.return_to&quot;: url,</span>
<span class="gi">+            &quot;openid.realm&quot;: urllib.parse.urljoin(url, &quot;/&quot;),</span>
<span class="gi">+            &quot;openid.mode&quot;: &quot;checkid_setup&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+        if ax_attrs:</span>
<span class="gi">+            args.update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    &quot;openid.ns.ax&quot;: &quot;http://openid.net/srv/ax/1.0&quot;,</span>
<span class="gi">+                    &quot;openid.ax.mode&quot;: &quot;fetch_request&quot;,</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+            ax_attrs = set(ax_attrs)</span>
<span class="gi">+            required = []  # type: List[str]</span>
<span class="gi">+            if &quot;name&quot; in ax_attrs:</span>
<span class="gi">+                ax_attrs -= set([&quot;name&quot;, &quot;firstname&quot;, &quot;fullname&quot;, &quot;lastname&quot;])</span>
<span class="gi">+                required += [&quot;firstname&quot;, &quot;fullname&quot;, &quot;lastname&quot;]</span>
<span class="gi">+                args.update(</span>
<span class="gi">+                    {</span>
<span class="gi">+                        &quot;openid.ax.type.firstname&quot;: &quot;http://axschema.org/namePerson/first&quot;,</span>
<span class="gi">+                        &quot;openid.ax.type.fullname&quot;: &quot;http://axschema.org/namePerson&quot;,</span>
<span class="gi">+                        &quot;openid.ax.type.lastname&quot;: &quot;http://axschema.org/namePerson/last&quot;,</span>
<span class="gi">+                    }</span>
<span class="gi">+                )</span>
<span class="gi">+            known_attrs = {</span>
<span class="gi">+                &quot;email&quot;: &quot;http://axschema.org/contact/email&quot;,</span>
<span class="gi">+                &quot;language&quot;: &quot;http://axschema.org/pref/language&quot;,</span>
<span class="gi">+                &quot;username&quot;: &quot;http://axschema.org/namePerson/friendly&quot;,</span>
<span class="gi">+            }</span>
<span class="gi">+            for name in ax_attrs:</span>
<span class="gi">+                args[&quot;openid.ax.type.&quot; + name] = known_attrs[name]</span>
<span class="gi">+                required.append(name)</span>
<span class="gi">+            args[&quot;openid.ax.required&quot;] = &quot;,&quot;.join(required)</span>
<span class="gi">+        if oauth_scope:</span>
<span class="gi">+            args.update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    &quot;openid.ns.oauth&quot;: &quot;http://specs.openid.net/extensions/oauth/1.0&quot;,</span>
<span class="gi">+                    &quot;openid.oauth.consumer&quot;: handler.request.host.split(&quot;:&quot;)[0],</span>
<span class="gi">+                    &quot;openid.oauth.scope&quot;: oauth_scope,</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+        return args</span>
<span class="gi">+</span>
<span class="gi">+    def _on_authentication_verified(</span>
<span class="gi">+        self, response: httpclient.HTTPResponse</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        if b&quot;is_valid:true&quot; not in response.body:</span>
<span class="gi">+            raise AuthError(&quot;Invalid OpenID response: %r&quot; % response.body)</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure we got back at least an email from attribute exchange</span>
<span class="gi">+        ax_ns = None</span>
<span class="gi">+        for key in handler.request.arguments:</span>
<span class="gi">+            if (</span>
<span class="gi">+                key.startswith(&quot;openid.ns.&quot;)</span>
<span class="gi">+                and handler.get_argument(key) == &quot;http://openid.net/srv/ax/1.0&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                ax_ns = key[10:]</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        def get_ax_arg(uri: str) -&gt; str:</span>
<span class="gi">+            if not ax_ns:</span>
<span class="gi">+                return &quot;&quot;</span>
<span class="gi">+            prefix = &quot;openid.&quot; + ax_ns + &quot;.type.&quot;</span>
<span class="gi">+            ax_name = None</span>
<span class="gi">+            for name in handler.request.arguments.keys():</span>
<span class="gi">+                if handler.get_argument(name) == uri and name.startswith(prefix):</span>
<span class="gi">+                    part = name[len(prefix) :]</span>
<span class="gi">+                    ax_name = &quot;openid.&quot; + ax_ns + &quot;.value.&quot; + part</span>
<span class="gi">+                    break</span>
<span class="gi">+            if not ax_name:</span>
<span class="gi">+                return &quot;&quot;</span>
<span class="gi">+            return handler.get_argument(ax_name, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        email = get_ax_arg(&quot;http://axschema.org/contact/email&quot;)</span>
<span class="gi">+        name = get_ax_arg(&quot;http://axschema.org/namePerson&quot;)</span>
<span class="gi">+        first_name = get_ax_arg(&quot;http://axschema.org/namePerson/first&quot;)</span>
<span class="gi">+        last_name = get_ax_arg(&quot;http://axschema.org/namePerson/last&quot;)</span>
<span class="gi">+        username = get_ax_arg(&quot;http://axschema.org/namePerson/friendly&quot;)</span>
<span class="gi">+        locale = get_ax_arg(&quot;http://axschema.org/pref/language&quot;).lower()</span>
<span class="gi">+        user = dict()</span>
<span class="gi">+        name_parts = []</span>
<span class="gi">+        if first_name:</span>
<span class="gi">+            user[&quot;first_name&quot;] = first_name</span>
<span class="gi">+            name_parts.append(first_name)</span>
<span class="gi">+        if last_name:</span>
<span class="gi">+            user[&quot;last_name&quot;] = last_name</span>
<span class="gi">+            name_parts.append(last_name)</span>
<span class="gi">+        if name:</span>
<span class="gi">+            user[&quot;name&quot;] = name</span>
<span class="gi">+        elif name_parts:</span>
<span class="gi">+            user[&quot;name&quot;] = &quot; &quot;.join(name_parts)</span>
<span class="gi">+        elif email:</span>
<span class="gi">+            user[&quot;name&quot;] = email.split(&quot;@&quot;)[0]</span>
<span class="gi">+        if email:</span>
<span class="gi">+            user[&quot;email&quot;] = email</span>
<span class="gi">+        if locale:</span>
<span class="gi">+            user[&quot;locale&quot;] = locale</span>
<span class="gi">+        if username:</span>
<span class="gi">+            user[&quot;username&quot;] = username</span>
<span class="gi">+        claimed_id = handler.get_argument(&quot;openid.claimed_id&quot;, None)</span>
<span class="gi">+        if claimed_id:</span>
<span class="gi">+            user[&quot;claimed_id&quot;] = claimed_id</span>
<span class="gi">+        return user</span>
<span class="gi">+</span>
<span class="gi">+    def get_auth_http_client(self) -&gt; httpclient.AsyncHTTPClient:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.AsyncHTTPClient` instance to be used for auth requests.

<span class="w"> </span>        May be overridden by subclasses to use an HTTP client other than
<span class="w"> </span>        the default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return httpclient.AsyncHTTPClient()</span>


<span class="w"> </span>class OAuthMixin(object):
<span class="gu">@@ -149,9 +304,12 @@ class OAuthMixin(object):</span>
<span class="w"> </span>    `_oauth_consumer_token` methods.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    async def authorize_redirect(self, callback_uri: Optional[str]=None,</span>
<span class="gd">-        extra_params: Optional[Dict[str, Any]]=None, http_client: Optional[</span>
<span class="gd">-        httpclient.AsyncHTTPClient]=None) -&gt;None:</span>
<span class="gi">+    async def authorize_redirect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        callback_uri: Optional[str] = None,</span>
<span class="gi">+        extra_params: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        http_client: Optional[httpclient.AsyncHTTPClient] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Redirects the user to obtain OAuth authorization for this service.

<span class="w"> </span>        The ``callback_uri`` may be omitted if you have previously
<span class="gu">@@ -179,10 +337,25 @@ class OAuthMixin(object):</span>
<span class="w"> </span>           awaitable object instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def get_authenticated_user(self, http_client: Optional[httpclient</span>
<span class="gd">-        .AsyncHTTPClient]=None) -&gt;Dict[str, Any]:</span>
<span class="gi">+        if callback_uri and getattr(self, &quot;_OAUTH_NO_CALLBACKS&quot;, False):</span>
<span class="gi">+            raise Exception(&quot;This service does not support oauth_callback&quot;)</span>
<span class="gi">+        if http_client is None:</span>
<span class="gi">+            http_client = self.get_auth_http_client()</span>
<span class="gi">+        assert http_client is not None</span>
<span class="gi">+        if getattr(self, &quot;_OAUTH_VERSION&quot;, &quot;1.0a&quot;) == &quot;1.0a&quot;:</span>
<span class="gi">+            response = await http_client.fetch(</span>
<span class="gi">+                self._oauth_request_token_url(</span>
<span class="gi">+                    callback_uri=callback_uri, extra_params=extra_params</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = await http_client.fetch(self._oauth_request_token_url())</span>
<span class="gi">+        url = self._OAUTH_AUTHORIZE_URL  # type: ignore</span>
<span class="gi">+        self._on_request_token(url, callback_uri, response)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_authenticated_user(</span>
<span class="gi">+        self, http_client: Optional[httpclient.AsyncHTTPClient] = None</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gets the OAuth authorized user and access token.

<span class="w"> </span>        This method should be called from the handler for your
<span class="gu">@@ -198,17 +371,125 @@ class OAuthMixin(object):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _oauth_consumer_token(self) -&gt;Dict[str, Any]:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        request_key = escape.utf8(handler.get_argument(&quot;oauth_token&quot;))</span>
<span class="gi">+        oauth_verifier = handler.get_argument(&quot;oauth_verifier&quot;, None)</span>
<span class="gi">+        request_cookie = handler.get_cookie(&quot;_oauth_request_token&quot;)</span>
<span class="gi">+        if not request_cookie:</span>
<span class="gi">+            raise AuthError(&quot;Missing OAuth request token cookie&quot;)</span>
<span class="gi">+        handler.clear_cookie(&quot;_oauth_request_token&quot;)</span>
<span class="gi">+        cookie_key, cookie_secret = [</span>
<span class="gi">+            base64.b64decode(escape.utf8(i)) for i in request_cookie.split(&quot;|&quot;)</span>
<span class="gi">+        ]</span>
<span class="gi">+        if cookie_key != request_key:</span>
<span class="gi">+            raise AuthError(&quot;Request token does not match cookie&quot;)</span>
<span class="gi">+        token = dict(</span>
<span class="gi">+            key=cookie_key, secret=cookie_secret</span>
<span class="gi">+        )  # type: Dict[str, Union[str, bytes]]</span>
<span class="gi">+        if oauth_verifier:</span>
<span class="gi">+            token[&quot;verifier&quot;] = oauth_verifier</span>
<span class="gi">+        if http_client is None:</span>
<span class="gi">+            http_client = self.get_auth_http_client()</span>
<span class="gi">+        assert http_client is not None</span>
<span class="gi">+        response = await http_client.fetch(self._oauth_access_token_url(token))</span>
<span class="gi">+        access_token = _oauth_parse_response(response.body)</span>
<span class="gi">+        user = await self._oauth_get_user_future(access_token)</span>
<span class="gi">+        if not user:</span>
<span class="gi">+            raise AuthError(&quot;Error getting user&quot;)</span>
<span class="gi">+        user[&quot;access_token&quot;] = access_token</span>
<span class="gi">+        return user</span>
<span class="gi">+</span>
<span class="gi">+    def _oauth_request_token_url(</span>
<span class="gi">+        self,</span>
<span class="gi">+        callback_uri: Optional[str] = None,</span>
<span class="gi">+        extra_params: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        consumer_token = self._oauth_consumer_token()</span>
<span class="gi">+        url = self._OAUTH_REQUEST_TOKEN_URL  # type: ignore</span>
<span class="gi">+        args = dict(</span>
<span class="gi">+            oauth_consumer_key=escape.to_basestring(consumer_token[&quot;key&quot;]),</span>
<span class="gi">+            oauth_signature_method=&quot;HMAC-SHA1&quot;,</span>
<span class="gi">+            oauth_timestamp=str(int(time.time())),</span>
<span class="gi">+            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),</span>
<span class="gi">+            oauth_version=&quot;1.0&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        if getattr(self, &quot;_OAUTH_VERSION&quot;, &quot;1.0a&quot;) == &quot;1.0a&quot;:</span>
<span class="gi">+            if callback_uri == &quot;oob&quot;:</span>
<span class="gi">+                args[&quot;oauth_callback&quot;] = &quot;oob&quot;</span>
<span class="gi">+            elif callback_uri:</span>
<span class="gi">+                args[&quot;oauth_callback&quot;] = urllib.parse.urljoin(</span>
<span class="gi">+                    handler.request.full_url(), callback_uri</span>
<span class="gi">+                )</span>
<span class="gi">+            if extra_params:</span>
<span class="gi">+                args.update(extra_params)</span>
<span class="gi">+            signature = _oauth10a_signature(consumer_token, &quot;GET&quot;, url, args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            signature = _oauth_signature(consumer_token, &quot;GET&quot;, url, args)</span>
<span class="gi">+</span>
<span class="gi">+        args[&quot;oauth_signature&quot;] = signature</span>
<span class="gi">+        return url + &quot;?&quot; + urllib.parse.urlencode(args)</span>
<span class="gi">+</span>
<span class="gi">+    def _on_request_token(</span>
<span class="gi">+        self,</span>
<span class="gi">+        authorize_url: str,</span>
<span class="gi">+        callback_uri: Optional[str],</span>
<span class="gi">+        response: httpclient.HTTPResponse,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        request_token = _oauth_parse_response(response.body)</span>
<span class="gi">+        data = (</span>
<span class="gi">+            base64.b64encode(escape.utf8(request_token[&quot;key&quot;]))</span>
<span class="gi">+            + b&quot;|&quot;</span>
<span class="gi">+            + base64.b64encode(escape.utf8(request_token[&quot;secret&quot;]))</span>
<span class="gi">+        )</span>
<span class="gi">+        handler.set_cookie(&quot;_oauth_request_token&quot;, data)</span>
<span class="gi">+        args = dict(oauth_token=request_token[&quot;key&quot;])</span>
<span class="gi">+        if callback_uri == &quot;oob&quot;:</span>
<span class="gi">+            handler.finish(authorize_url + &quot;?&quot; + urllib.parse.urlencode(args))</span>
<span class="gi">+            return</span>
<span class="gi">+        elif callback_uri:</span>
<span class="gi">+            args[&quot;oauth_callback&quot;] = urllib.parse.urljoin(</span>
<span class="gi">+                handler.request.full_url(), callback_uri</span>
<span class="gi">+            )</span>
<span class="gi">+        handler.redirect(authorize_url + &quot;?&quot; + urllib.parse.urlencode(args))</span>
<span class="gi">+</span>
<span class="gi">+    def _oauth_access_token_url(self, request_token: Dict[str, Any]) -&gt; str:</span>
<span class="gi">+        consumer_token = self._oauth_consumer_token()</span>
<span class="gi">+        url = self._OAUTH_ACCESS_TOKEN_URL  # type: ignore</span>
<span class="gi">+        args = dict(</span>
<span class="gi">+            oauth_consumer_key=escape.to_basestring(consumer_token[&quot;key&quot;]),</span>
<span class="gi">+            oauth_token=escape.to_basestring(request_token[&quot;key&quot;]),</span>
<span class="gi">+            oauth_signature_method=&quot;HMAC-SHA1&quot;,</span>
<span class="gi">+            oauth_timestamp=str(int(time.time())),</span>
<span class="gi">+            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),</span>
<span class="gi">+            oauth_version=&quot;1.0&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        if &quot;verifier&quot; in request_token:</span>
<span class="gi">+            args[&quot;oauth_verifier&quot;] = request_token[&quot;verifier&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if getattr(self, &quot;_OAUTH_VERSION&quot;, &quot;1.0a&quot;) == &quot;1.0a&quot;:</span>
<span class="gi">+            signature = _oauth10a_signature(</span>
<span class="gi">+                consumer_token, &quot;GET&quot;, url, args, request_token</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            signature = _oauth_signature(</span>
<span class="gi">+                consumer_token, &quot;GET&quot;, url, args, request_token</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        args[&quot;oauth_signature&quot;] = signature</span>
<span class="gi">+        return url + &quot;?&quot; + urllib.parse.urlencode(args)</span>
<span class="gi">+</span>
<span class="gi">+    def _oauth_consumer_token(self) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Subclasses must override this to return their OAuth consumer keys.

<span class="w"> </span>        The return value should be a `dict` with keys ``key`` and ``secret``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    async def _oauth_get_user_future(self, access_token: Dict[str, Any]</span>
<span class="gd">-        ) -&gt;Dict[str, Any]:</span>
<span class="gi">+    async def _oauth_get_user_future(</span>
<span class="gi">+        self, access_token: Dict[str, Any]</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Subclasses must override this to get basic information about the
<span class="w"> </span>        user.

<span class="gu">@@ -228,25 +509,50 @@ class OAuthMixin(object):</span>

<span class="w"> </span>           A synchronous fallback to ``_oauth_get_user`` was removed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _oauth_request_parameters(self, url: str, access_token: Dict[str,</span>
<span class="gd">-        Any], parameters: Dict[str, Any]={}, method: str=&#39;GET&#39;) -&gt;Dict[str, Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _oauth_request_parameters(</span>
<span class="gi">+        self,</span>
<span class="gi">+        url: str,</span>
<span class="gi">+        access_token: Dict[str, Any],</span>
<span class="gi">+        parameters: Dict[str, Any] = {},</span>
<span class="gi">+        method: str = &quot;GET&quot;,</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the OAuth parameters as a dict for the given request.

<span class="w"> </span>        parameters should include all POST arguments and query string arguments
<span class="w"> </span>        that will be sent with the request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_auth_http_client(self) -&gt;httpclient.AsyncHTTPClient:</span>
<span class="gi">+        consumer_token = self._oauth_consumer_token()</span>
<span class="gi">+        base_args = dict(</span>
<span class="gi">+            oauth_consumer_key=escape.to_basestring(consumer_token[&quot;key&quot;]),</span>
<span class="gi">+            oauth_token=escape.to_basestring(access_token[&quot;key&quot;]),</span>
<span class="gi">+            oauth_signature_method=&quot;HMAC-SHA1&quot;,</span>
<span class="gi">+            oauth_timestamp=str(int(time.time())),</span>
<span class="gi">+            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),</span>
<span class="gi">+            oauth_version=&quot;1.0&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        args = {}</span>
<span class="gi">+        args.update(base_args)</span>
<span class="gi">+        args.update(parameters)</span>
<span class="gi">+        if getattr(self, &quot;_OAUTH_VERSION&quot;, &quot;1.0a&quot;) == &quot;1.0a&quot;:</span>
<span class="gi">+            signature = _oauth10a_signature(</span>
<span class="gi">+                consumer_token, method, url, args, access_token</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            signature = _oauth_signature(</span>
<span class="gi">+                consumer_token, method, url, args, access_token</span>
<span class="gi">+            )</span>
<span class="gi">+        base_args[&quot;oauth_signature&quot;] = escape.to_basestring(signature)</span>
<span class="gi">+        return base_args</span>
<span class="gi">+</span>
<span class="gi">+    def get_auth_http_client(self) -&gt; httpclient.AsyncHTTPClient:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.AsyncHTTPClient` instance to be used for auth requests.

<span class="w"> </span>        May be overridden by subclasses to use an HTTP client other than
<span class="w"> </span>        the default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return httpclient.AsyncHTTPClient()</span>


<span class="w"> </span>class OAuth2Mixin(object):
<span class="gu">@@ -261,10 +567,15 @@ class OAuth2Mixin(object):</span>
<span class="w"> </span>    * ``_OAUTH_ACCESS_TOKEN_URL``:  The service&#39;s access token url.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def authorize_redirect(self, redirect_uri: Optional[str]=None,</span>
<span class="gd">-        client_id: Optional[str]=None, client_secret: Optional[str]=None,</span>
<span class="gd">-        extra_params: Optional[Dict[str, Any]]=None, scope: Optional[List[</span>
<span class="gd">-        str]]=None, response_type: str=&#39;code&#39;) -&gt;None:</span>
<span class="gi">+    def authorize_redirect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        redirect_uri: Optional[str] = None,</span>
<span class="gi">+        client_id: Optional[str] = None,</span>
<span class="gi">+        client_secret: Optional[str] = None,</span>
<span class="gi">+        extra_params: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        scope: Optional[List[str]] = None,</span>
<span class="gi">+        response_type: str = &quot;code&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Redirects the user to obtain OAuth authorization for this service.

<span class="w"> </span>        Some providers require that you register a redirect URL with
<span class="gu">@@ -282,10 +593,50 @@ class OAuth2Mixin(object):</span>
<span class="w"> </span>           The ``client_secret`` argument (which has never had any effect)
<span class="w"> </span>           is deprecated and will be removed in Tornado 7.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def oauth2_request(self, url: str, access_token: Optional[str]=</span>
<span class="gd">-        None, post_args: Optional[Dict[str, Any]]=None, **args: Any) -&gt;Any:</span>
<span class="gi">+        if client_secret is not None:</span>
<span class="gi">+            warnings.warn(&quot;client_secret argument is deprecated&quot;, DeprecationWarning)</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        args = {&quot;response_type&quot;: response_type}</span>
<span class="gi">+        if redirect_uri is not None:</span>
<span class="gi">+            args[&quot;redirect_uri&quot;] = redirect_uri</span>
<span class="gi">+        if client_id is not None:</span>
<span class="gi">+            args[&quot;client_id&quot;] = client_id</span>
<span class="gi">+        if extra_params:</span>
<span class="gi">+            args.update(extra_params)</span>
<span class="gi">+        if scope:</span>
<span class="gi">+            args[&quot;scope&quot;] = &quot; &quot;.join(scope)</span>
<span class="gi">+        url = self._OAUTH_AUTHORIZE_URL  # type: ignore</span>
<span class="gi">+        handler.redirect(url_concat(url, args))</span>
<span class="gi">+</span>
<span class="gi">+    def _oauth_request_token_url(</span>
<span class="gi">+        self,</span>
<span class="gi">+        redirect_uri: Optional[str] = None,</span>
<span class="gi">+        client_id: Optional[str] = None,</span>
<span class="gi">+        client_secret: Optional[str] = None,</span>
<span class="gi">+        code: Optional[str] = None,</span>
<span class="gi">+        extra_params: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        url = self._OAUTH_ACCESS_TOKEN_URL  # type: ignore</span>
<span class="gi">+        args = {}  # type: Dict[str, str]</span>
<span class="gi">+        if redirect_uri is not None:</span>
<span class="gi">+            args[&quot;redirect_uri&quot;] = redirect_uri</span>
<span class="gi">+        if code is not None:</span>
<span class="gi">+            args[&quot;code&quot;] = code</span>
<span class="gi">+        if client_id is not None:</span>
<span class="gi">+            args[&quot;client_id&quot;] = client_id</span>
<span class="gi">+        if client_secret is not None:</span>
<span class="gi">+            args[&quot;client_secret&quot;] = client_secret</span>
<span class="gi">+        if extra_params:</span>
<span class="gi">+            args.update(extra_params)</span>
<span class="gi">+        return url_concat(url, args)</span>
<span class="gi">+</span>
<span class="gi">+    async def oauth2_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        url: str,</span>
<span class="gi">+        access_token: Optional[str] = None,</span>
<span class="gi">+        post_args: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        **args: Any</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetches the given URL auth an OAuth2 access token.

<span class="w"> </span>        If the request is a POST, ``post_args`` should be provided. Query
<span class="gu">@@ -319,9 +670,23 @@ class OAuth2Mixin(object):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_auth_http_client(self) -&gt;httpclient.AsyncHTTPClient:</span>
<span class="gi">+        all_args = {}</span>
<span class="gi">+        if access_token:</span>
<span class="gi">+            all_args[&quot;access_token&quot;] = access_token</span>
<span class="gi">+            all_args.update(args)</span>
<span class="gi">+</span>
<span class="gi">+        if all_args:</span>
<span class="gi">+            url += &quot;?&quot; + urllib.parse.urlencode(all_args)</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        if post_args is not None:</span>
<span class="gi">+            response = await http.fetch(</span>
<span class="gi">+                url, method=&quot;POST&quot;, body=urllib.parse.urlencode(post_args)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = await http.fetch(url)</span>
<span class="gi">+        return escape.json_decode(response.body)</span>
<span class="gi">+</span>
<span class="gi">+    def get_auth_http_client(self) -&gt; httpclient.AsyncHTTPClient:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.AsyncHTTPClient` instance to be used for auth requests.

<span class="w"> </span>        May be overridden by subclasses to use an HTTP client other than
<span class="gu">@@ -329,7 +694,7 @@ class OAuth2Mixin(object):</span>

<span class="w"> </span>        .. versionadded:: 4.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return httpclient.AsyncHTTPClient()</span>


<span class="w"> </span>class TwitterMixin(OAuthMixin):
<span class="gu">@@ -370,15 +735,15 @@ class TwitterMixin(OAuthMixin):</span>
<span class="w"> </span>       API, this class will no longer be updated and will be removed in the
<span class="w"> </span>       future.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _OAUTH_REQUEST_TOKEN_URL = &#39;https://api.twitter.com/oauth/request_token&#39;</span>
<span class="gd">-    _OAUTH_ACCESS_TOKEN_URL = &#39;https://api.twitter.com/oauth/access_token&#39;</span>
<span class="gd">-    _OAUTH_AUTHORIZE_URL = &#39;https://api.twitter.com/oauth/authorize&#39;</span>
<span class="gd">-    _OAUTH_AUTHENTICATE_URL = &#39;https://api.twitter.com/oauth/authenticate&#39;</span>
<span class="gi">+</span>
<span class="gi">+    _OAUTH_REQUEST_TOKEN_URL = &quot;https://api.twitter.com/oauth/request_token&quot;</span>
<span class="gi">+    _OAUTH_ACCESS_TOKEN_URL = &quot;https://api.twitter.com/oauth/access_token&quot;</span>
<span class="gi">+    _OAUTH_AUTHORIZE_URL = &quot;https://api.twitter.com/oauth/authorize&quot;</span>
<span class="gi">+    _OAUTH_AUTHENTICATE_URL = &quot;https://api.twitter.com/oauth/authenticate&quot;</span>
<span class="w"> </span>    _OAUTH_NO_CALLBACKS = False
<span class="gd">-    _TWITTER_BASE_URL = &#39;https://api.twitter.com/1.1&#39;</span>
<span class="gi">+    _TWITTER_BASE_URL = &quot;https://api.twitter.com/1.1&quot;</span>

<span class="gd">-    async def authenticate_redirect(self, callback_uri: Optional[str]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    async def authenticate_redirect(self, callback_uri: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Just like `~OAuthMixin.authorize_redirect`, but
<span class="w"> </span>        auto-redirects if authorized.

<span class="gu">@@ -394,10 +759,19 @@ class TwitterMixin(OAuthMixin):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def twitter_request(self, path: str, access_token: Dict[str, Any],</span>
<span class="gd">-        post_args: Optional[Dict[str, Any]]=None, **args: Any) -&gt;Any:</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        response = await http.fetch(</span>
<span class="gi">+            self._oauth_request_token_url(callback_uri=callback_uri)</span>
<span class="gi">+        )</span>
<span class="gi">+        self._on_request_token(self._OAUTH_AUTHENTICATE_URL, None, response)</span>
<span class="gi">+</span>
<span class="gi">+    async def twitter_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path: str,</span>
<span class="gi">+        access_token: Dict[str, Any],</span>
<span class="gi">+        post_args: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        **args: Any</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetches the given API path, e.g., ``statuses/user_timeline/btaylor``

<span class="w"> </span>        The path should not include the format or API version number.
<span class="gu">@@ -439,7 +813,51 @@ class TwitterMixin(OAuthMixin):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if path.startswith(&quot;http:&quot;) or path.startswith(&quot;https:&quot;):</span>
<span class="gi">+            # Raw urls are useful for e.g. search which doesn&#39;t follow the</span>
<span class="gi">+            # usual pattern: http://search.twitter.com/search.json</span>
<span class="gi">+            url = path</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = self._TWITTER_BASE_URL + path + &quot;.json&quot;</span>
<span class="gi">+        # Add the OAuth resource request signature if we have credentials</span>
<span class="gi">+        if access_token:</span>
<span class="gi">+            all_args = {}</span>
<span class="gi">+            all_args.update(args)</span>
<span class="gi">+            all_args.update(post_args or {})</span>
<span class="gi">+            method = &quot;POST&quot; if post_args is not None else &quot;GET&quot;</span>
<span class="gi">+            oauth = self._oauth_request_parameters(</span>
<span class="gi">+                url, access_token, all_args, method=method</span>
<span class="gi">+            )</span>
<span class="gi">+            args.update(oauth)</span>
<span class="gi">+        if args:</span>
<span class="gi">+            url += &quot;?&quot; + urllib.parse.urlencode(args)</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        if post_args is not None:</span>
<span class="gi">+            response = await http.fetch(</span>
<span class="gi">+                url, method=&quot;POST&quot;, body=urllib.parse.urlencode(post_args)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = await http.fetch(url)</span>
<span class="gi">+        return escape.json_decode(response.body)</span>
<span class="gi">+</span>
<span class="gi">+    def _oauth_consumer_token(self) -&gt; Dict[str, Any]:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        handler.require_setting(&quot;twitter_consumer_key&quot;, &quot;Twitter OAuth&quot;)</span>
<span class="gi">+        handler.require_setting(&quot;twitter_consumer_secret&quot;, &quot;Twitter OAuth&quot;)</span>
<span class="gi">+        return dict(</span>
<span class="gi">+            key=handler.settings[&quot;twitter_consumer_key&quot;],</span>
<span class="gi">+            secret=handler.settings[&quot;twitter_consumer_secret&quot;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async def _oauth_get_user_future(</span>
<span class="gi">+        self, access_token: Dict[str, Any]</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="gi">+        user = await self.twitter_request(</span>
<span class="gi">+            &quot;/account/verify_credentials&quot;, access_token=access_token</span>
<span class="gi">+        )</span>
<span class="gi">+        if user:</span>
<span class="gi">+            user[&quot;username&quot;] = user[&quot;screen_name&quot;]</span>
<span class="gi">+        return user</span>


<span class="w"> </span>class GoogleOAuth2Mixin(OAuth2Mixin):
<span class="gu">@@ -465,13 +883,14 @@ class GoogleOAuth2Mixin(OAuth2Mixin):</span>

<span class="w"> </span>    .. versionadded:: 3.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _OAUTH_AUTHORIZE_URL = &#39;https://accounts.google.com/o/oauth2/v2/auth&#39;</span>
<span class="gd">-    _OAUTH_ACCESS_TOKEN_URL = &#39;https://www.googleapis.com/oauth2/v4/token&#39;</span>
<span class="gd">-    _OAUTH_USERINFO_URL = &#39;https://www.googleapis.com/oauth2/v1/userinfo&#39;</span>
<span class="gi">+</span>
<span class="gi">+    _OAUTH_AUTHORIZE_URL = &quot;https://accounts.google.com/o/oauth2/v2/auth&quot;</span>
<span class="gi">+    _OAUTH_ACCESS_TOKEN_URL = &quot;https://www.googleapis.com/oauth2/v4/token&quot;</span>
<span class="gi">+    _OAUTH_USERINFO_URL = &quot;https://www.googleapis.com/oauth2/v1/userinfo&quot;</span>
<span class="w"> </span>    _OAUTH_NO_CALLBACKS = False
<span class="gd">-    _OAUTH_SETTINGS_KEY = &#39;google_oauth&#39;</span>
<span class="gi">+    _OAUTH_SETTINGS_KEY = &quot;google_oauth&quot;</span>

<span class="gd">-    def get_google_oauth_settings(self) -&gt;Dict[str, str]:</span>
<span class="gi">+    def get_google_oauth_settings(self) -&gt; Dict[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the Google OAuth 2.0 credentials that you created with
<span class="w"> </span>        [Google Cloud
<span class="w"> </span>        Platform](https://console.cloud.google.com/apis/credentials). The dict
<span class="gu">@@ -484,11 +903,16 @@ class GoogleOAuth2Mixin(OAuth2Mixin):</span>
<span class="w"> </span>        If your credentials are stored differently (e.g. in a db) you can
<span class="w"> </span>        override this method for custom provision.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def get_authenticated_user(self, redirect_uri: str, code: str,</span>
<span class="gd">-        client_id: Optional[str]=None, client_secret: Optional[str]=None</span>
<span class="gd">-        ) -&gt;Dict[str, Any]:</span>
<span class="gi">+        handler = cast(RequestHandler, self)</span>
<span class="gi">+        return handler.settings[self._OAUTH_SETTINGS_KEY]</span>
<span class="gi">+</span>
<span class="gi">+    async def get_authenticated_user(</span>
<span class="gi">+        self,</span>
<span class="gi">+        redirect_uri: str,</span>
<span class="gi">+        code: str,</span>
<span class="gi">+        client_id: Optional[str] = None,</span>
<span class="gi">+        client_secret: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles the login for the Google user, returning an access token.

<span class="w"> </span>        The result is a dictionary containing an ``access_token`` field
<span class="gu">@@ -541,20 +965,50 @@ class GoogleOAuth2Mixin(OAuth2Mixin):</span>
<span class="w"> </span>        .. versionchanged:: 6.0

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: E501</span>
<span class="gi">+</span>
<span class="gi">+        if client_id is None or client_secret is None:</span>
<span class="gi">+            settings = self.get_google_oauth_settings()</span>
<span class="gi">+            if client_id is None:</span>
<span class="gi">+                client_id = settings[&quot;key&quot;]</span>
<span class="gi">+            if client_secret is None:</span>
<span class="gi">+                client_secret = settings[&quot;secret&quot;]</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        body = urllib.parse.urlencode(</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;redirect_uri&quot;: redirect_uri,</span>
<span class="gi">+                &quot;code&quot;: code,</span>
<span class="gi">+                &quot;client_id&quot;: client_id,</span>
<span class="gi">+                &quot;client_secret&quot;: client_secret,</span>
<span class="gi">+                &quot;grant_type&quot;: &quot;authorization_code&quot;,</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        response = await http.fetch(</span>
<span class="gi">+            self._OAUTH_ACCESS_TOKEN_URL,</span>
<span class="gi">+            method=&quot;POST&quot;,</span>
<span class="gi">+            headers={&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;},</span>
<span class="gi">+            body=body,</span>
<span class="gi">+        )</span>
<span class="gi">+        return escape.json_decode(response.body)</span>


<span class="w"> </span>class FacebookGraphMixin(OAuth2Mixin):
<span class="w"> </span>    &quot;&quot;&quot;Facebook authentication using the new Graph API and OAuth2.&quot;&quot;&quot;
<span class="gd">-    _OAUTH_ACCESS_TOKEN_URL = &#39;https://graph.facebook.com/oauth/access_token?&#39;</span>
<span class="gd">-    _OAUTH_AUTHORIZE_URL = &#39;https://www.facebook.com/dialog/oauth?&#39;</span>
<span class="gd">-    _OAUTH_NO_CALLBACKS = False</span>
<span class="gd">-    _FACEBOOK_BASE_URL = &#39;https://graph.facebook.com&#39;</span>

<span class="gd">-    async def get_authenticated_user(self, redirect_uri: str, client_id:</span>
<span class="gd">-        str, client_secret: str, code: str, extra_fields: Optional[Dict[str,</span>
<span class="gd">-        Any]]=None) -&gt;Optional[Dict[str, Any]]:</span>
<span class="gi">+    _OAUTH_ACCESS_TOKEN_URL = &quot;https://graph.facebook.com/oauth/access_token?&quot;</span>
<span class="gi">+    _OAUTH_AUTHORIZE_URL = &quot;https://www.facebook.com/dialog/oauth?&quot;</span>
<span class="gi">+    _OAUTH_NO_CALLBACKS = False</span>
<span class="gi">+    _FACEBOOK_BASE_URL = &quot;https://graph.facebook.com&quot;</span>
<span class="gi">+</span>
<span class="gi">+    async def get_authenticated_user(</span>
<span class="gi">+        self,</span>
<span class="gi">+        redirect_uri: str,</span>
<span class="gi">+        client_id: str,</span>
<span class="gi">+        client_secret: str,</span>
<span class="gi">+        code: str,</span>
<span class="gi">+        extra_fields: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; Optional[Dict[str, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles the login for the Facebook user, returning a user object.

<span class="w"> </span>        Example usage:
<span class="gu">@@ -603,10 +1057,67 @@ class FacebookGraphMixin(OAuth2Mixin):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def facebook_request(self, path: str, access_token: Optional[str]</span>
<span class="gd">-        =None, post_args: Optional[Dict[str, Any]]=None, **args: Any) -&gt;Any:</span>
<span class="gi">+        http = self.get_auth_http_client()</span>
<span class="gi">+        args = {</span>
<span class="gi">+            &quot;redirect_uri&quot;: redirect_uri,</span>
<span class="gi">+            &quot;code&quot;: code,</span>
<span class="gi">+            &quot;client_id&quot;: client_id,</span>
<span class="gi">+            &quot;client_secret&quot;: client_secret,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        fields = set(</span>
<span class="gi">+            [&quot;id&quot;, &quot;name&quot;, &quot;first_name&quot;, &quot;last_name&quot;, &quot;locale&quot;, &quot;picture&quot;, &quot;link&quot;]</span>
<span class="gi">+        )</span>
<span class="gi">+        if extra_fields:</span>
<span class="gi">+            fields.update(extra_fields)</span>
<span class="gi">+</span>
<span class="gi">+        response = await http.fetch(</span>
<span class="gi">+            self._oauth_request_token_url(**args)  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+        args = escape.json_decode(response.body)</span>
<span class="gi">+        session = {</span>
<span class="gi">+            &quot;access_token&quot;: args.get(&quot;access_token&quot;),</span>
<span class="gi">+            &quot;expires_in&quot;: args.get(&quot;expires_in&quot;),</span>
<span class="gi">+        }</span>
<span class="gi">+        assert session[&quot;access_token&quot;] is not None</span>
<span class="gi">+</span>
<span class="gi">+        user = await self.facebook_request(</span>
<span class="gi">+            path=&quot;/me&quot;,</span>
<span class="gi">+            access_token=session[&quot;access_token&quot;],</span>
<span class="gi">+            appsecret_proof=hmac.new(</span>
<span class="gi">+                key=client_secret.encode(&quot;utf8&quot;),</span>
<span class="gi">+                msg=session[&quot;access_token&quot;].encode(&quot;utf8&quot;),</span>
<span class="gi">+                digestmod=hashlib.sha256,</span>
<span class="gi">+            ).hexdigest(),</span>
<span class="gi">+            fields=&quot;,&quot;.join(fields),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if user is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        fieldmap = {}</span>
<span class="gi">+        for field in fields:</span>
<span class="gi">+            fieldmap[field] = user.get(field)</span>
<span class="gi">+</span>
<span class="gi">+        # session_expires is converted to str for compatibility with</span>
<span class="gi">+        # older versions in which the server used url-encoding and</span>
<span class="gi">+        # this code simply returned the string verbatim.</span>
<span class="gi">+        # This should change in Tornado 5.0.</span>
<span class="gi">+        fieldmap.update(</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;access_token&quot;: session[&quot;access_token&quot;],</span>
<span class="gi">+                &quot;session_expires&quot;: str(session.get(&quot;expires_in&quot;)),</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+        return fieldmap</span>
<span class="gi">+</span>
<span class="gi">+    async def facebook_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path: str,</span>
<span class="gi">+        access_token: Optional[str] = None,</span>
<span class="gi">+        post_args: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        **args: Any</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetches the given relative API path, e.g., &quot;/btaylor/picture&quot;

<span class="w"> </span>        If the request is a POST, ``post_args`` should be provided. Query
<span class="gu">@@ -657,24 +1168,95 @@ class FacebookGraphMixin(OAuth2Mixin):</span>

<span class="w"> </span>           The ``callback`` argument was removed. Use the returned awaitable object instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _oauth_signature(consumer_token: Dict[str, Any], method: str, url: str,</span>
<span class="gd">-    parameters: Dict[str, Any]={}, token: Optional[Dict[str, Any]]=None</span>
<span class="gd">-    ) -&gt;bytes:</span>
<span class="gi">+        url = self._FACEBOOK_BASE_URL + path</span>
<span class="gi">+        return await self.oauth2_request(</span>
<span class="gi">+            url, access_token=access_token, post_args=post_args, **args</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _oauth_signature(</span>
<span class="gi">+    consumer_token: Dict[str, Any],</span>
<span class="gi">+    method: str,</span>
<span class="gi">+    url: str,</span>
<span class="gi">+    parameters: Dict[str, Any] = {},</span>
<span class="gi">+    token: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Calculates the HMAC-SHA1 OAuth signature for the given request.

<span class="w"> </span>    See http://oauth.net/core/1.0/#signing_process
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _oauth10a_signature(consumer_token: Dict[str, Any], method: str, url:</span>
<span class="gd">-    str, parameters: Dict[str, Any]={}, token: Optional[Dict[str, Any]]=None</span>
<span class="gd">-    ) -&gt;bytes:</span>
<span class="gi">+    parts = urllib.parse.urlparse(url)</span>
<span class="gi">+    scheme, netloc, path = parts[:3]</span>
<span class="gi">+    normalized_url = scheme.lower() + &quot;://&quot; + netloc.lower() + path</span>
<span class="gi">+</span>
<span class="gi">+    base_elems = []</span>
<span class="gi">+    base_elems.append(method.upper())</span>
<span class="gi">+    base_elems.append(normalized_url)</span>
<span class="gi">+    base_elems.append(</span>
<span class="gi">+        &quot;&amp;&quot;.join(</span>
<span class="gi">+            &quot;%s=%s&quot; % (k, _oauth_escape(str(v))) for k, v in sorted(parameters.items())</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    base_string = &quot;&amp;&quot;.join(_oauth_escape(e) for e in base_elems)</span>
<span class="gi">+</span>
<span class="gi">+    key_elems = [escape.utf8(consumer_token[&quot;secret&quot;])]</span>
<span class="gi">+    key_elems.append(escape.utf8(token[&quot;secret&quot;] if token else &quot;&quot;))</span>
<span class="gi">+    key = b&quot;&amp;&quot;.join(key_elems)</span>
<span class="gi">+</span>
<span class="gi">+    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)</span>
<span class="gi">+    return binascii.b2a_base64(hash.digest())[:-1]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _oauth10a_signature(</span>
<span class="gi">+    consumer_token: Dict[str, Any],</span>
<span class="gi">+    method: str,</span>
<span class="gi">+    url: str,</span>
<span class="gi">+    parameters: Dict[str, Any] = {},</span>
<span class="gi">+    token: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.

<span class="w"> </span>    See http://oauth.net/core/1.0a/#signing_process
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = urllib.parse.urlparse(url)</span>
<span class="gi">+    scheme, netloc, path = parts[:3]</span>
<span class="gi">+    normalized_url = scheme.lower() + &quot;://&quot; + netloc.lower() + path</span>
<span class="gi">+</span>
<span class="gi">+    base_elems = []</span>
<span class="gi">+    base_elems.append(method.upper())</span>
<span class="gi">+    base_elems.append(normalized_url)</span>
<span class="gi">+    base_elems.append(</span>
<span class="gi">+        &quot;&amp;&quot;.join(</span>
<span class="gi">+            &quot;%s=%s&quot; % (k, _oauth_escape(str(v))) for k, v in sorted(parameters.items())</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    base_string = &quot;&amp;&quot;.join(_oauth_escape(e) for e in base_elems)</span>
<span class="gi">+    key_elems = [escape.utf8(urllib.parse.quote(consumer_token[&quot;secret&quot;], safe=&quot;~&quot;))]</span>
<span class="gi">+    key_elems.append(</span>
<span class="gi">+        escape.utf8(urllib.parse.quote(token[&quot;secret&quot;], safe=&quot;~&quot;) if token else &quot;&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    key = b&quot;&amp;&quot;.join(key_elems)</span>
<span class="gi">+</span>
<span class="gi">+    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)</span>
<span class="gi">+    return binascii.b2a_base64(hash.digest())[:-1]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _oauth_escape(val: Union[str, bytes]) -&gt; str:</span>
<span class="gi">+    if isinstance(val, unicode_type):</span>
<span class="gi">+        val = val.encode(&quot;utf-8&quot;)</span>
<span class="gi">+    return urllib.parse.quote(val, safe=&quot;~&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _oauth_parse_response(body: bytes) -&gt; Dict[str, Any]:</span>
<span class="gi">+    # I can&#39;t find an officially-defined encoding for oauth responses and</span>
<span class="gi">+    # have never seen anyone use non-ascii.  Leave the response in a byte</span>
<span class="gi">+    # string for python 2, and use utf8 on python 3.</span>
<span class="gi">+    body_str = escape.native_str(body)</span>
<span class="gi">+    p = urllib.parse.parse_qs(body_str, keep_blank_values=False)</span>
<span class="gi">+    token = dict(key=p[&quot;oauth_token&quot;][0], secret=p[&quot;oauth_token_secret&quot;][0])</span>
<span class="gi">+</span>
<span class="gi">+    # Add the extra parameters the Provider included to the token</span>
<span class="gi">+    special = (&quot;oauth_token&quot;, &quot;oauth_token_secret&quot;)</span>
<span class="gi">+    token.update((k, p[k][0]) for k in p if k not in special)</span>
<span class="gi">+    return token</span>
<span class="gh">diff --git a/tornado/autoreload.py b/tornado/autoreload.py</span>
<span class="gh">index 05cda05c..c6a6e82d 100644</span>
<span class="gd">--- a/tornado/autoreload.py</span>
<span class="gi">+++ b/tornado/autoreload.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Automatically restart the server when a source file is modified.

<span class="w"> </span>Most applications should not access this module directly.  Instead,
<span class="gu">@@ -27,11 +42,38 @@ Additionally, modifying these variables will cause reloading to behave</span>
<span class="w"> </span>incorrectly.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+</span>
<span class="gi">+# sys.path handling</span>
<span class="gi">+# -----------------</span>
<span class="gi">+#</span>
<span class="gi">+# If a module is run with &quot;python -m&quot;, the current directory (i.e. &quot;&quot;)</span>
<span class="gi">+# is automatically prepended to sys.path, but not if it is run as</span>
<span class="gi">+# &quot;path/to/file.py&quot;.  The processing for &quot;-m&quot; rewrites the former to</span>
<span class="gi">+# the latter, so subsequent executions won&#39;t have the same path as the</span>
<span class="gi">+# original.</span>
<span class="gi">+#</span>
<span class="gi">+# Conversely, when run as path/to/file.py, the directory containing</span>
<span class="gi">+# file.py gets added to the path, which can cause confusion as imports</span>
<span class="gi">+# may become relative in spite of the future import.</span>
<span class="gi">+#</span>
<span class="gi">+# We address the former problem by reconstructing the original command</span>
<span class="gi">+# line before re-execution so the new process will</span>
<span class="gi">+# see the correct path.  We attempt to address the latter problem when</span>
<span class="gi">+# tornado.autoreload is run as __main__.</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="gi">+    # This sys.path manipulation must come before our imports (as much</span>
<span class="gi">+    # as possible - if we introduced a tornado.sys or tornado.os</span>
<span class="gi">+    # module we&#39;d be in trouble), or else our imports would become</span>
<span class="gi">+    # relative again despite the future import.</span>
<span class="gi">+    #</span>
<span class="gi">+    # There is a separate __main__ block at the end of the file to call main().</span>
<span class="w"> </span>    if sys.path[0] == os.path.dirname(__file__):
<span class="w"> </span>        del sys.path[0]
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>import importlib.abc
<span class="w"> </span>import os
<span class="gu">@@ -41,60 +83,158 @@ import traceback</span>
<span class="w"> </span>import types
<span class="w"> </span>import subprocess
<span class="w"> </span>import weakref
<span class="gi">+</span>
<span class="w"> </span>from tornado import ioloop
<span class="w"> </span>from tornado.log import gen_log
<span class="w"> </span>from tornado import process
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import signal
<span class="w"> </span>except ImportError:
<span class="gd">-    signal = None</span>
<span class="gi">+    signal = None  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable, Dict, Optional, List, Union
<span class="gd">-_has_execv = sys.platform != &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+# os.execv is broken on Windows and can&#39;t properly parse command line</span>
<span class="gi">+# arguments and executable name if they contain whitespaces. subprocess</span>
<span class="gi">+# fixes that behavior.</span>
<span class="gi">+_has_execv = sys.platform != &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>_watched_files = set()
<span class="w"> </span>_reload_hooks = []
<span class="w"> </span>_reload_attempted = False
<span class="gd">-_io_loops: &#39;weakref.WeakKeyDictionary[ioloop.IOLoop, bool]&#39; = (weakref.</span>
<span class="gd">-    WeakKeyDictionary())</span>
<span class="gi">+_io_loops: &quot;weakref.WeakKeyDictionary[ioloop.IOLoop, bool]&quot; = (</span>
<span class="gi">+    weakref.WeakKeyDictionary()</span>
<span class="gi">+)</span>
<span class="w"> </span>_autoreload_is_main = False
<span class="w"> </span>_original_argv: Optional[List[str]] = None
<span class="w"> </span>_original_spec = None


<span class="gd">-def start(check_time: int=500) -&gt;None:</span>
<span class="gi">+def start(check_time: int = 500) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Begins watching source files for changes.

<span class="w"> </span>    .. versionchanged:: 5.0
<span class="w"> </span>       The ``io_loop`` argument (deprecated since version 4.1) has been removed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+    if io_loop in _io_loops:</span>
<span class="gi">+        return</span>
<span class="gi">+    _io_loops[io_loop] = True</span>
<span class="gi">+    if len(_io_loops) &gt; 1:</span>
<span class="gi">+        gen_log.warning(&quot;tornado.autoreload started more than once in the same process&quot;)</span>
<span class="gi">+    modify_times: Dict[str, float] = {}</span>
<span class="gi">+    callback = functools.partial(_reload_on_update, modify_times)</span>
<span class="gi">+    scheduler = ioloop.PeriodicCallback(callback, check_time)</span>
<span class="gi">+    scheduler.start()</span>


<span class="gd">-def wait() -&gt;None:</span>
<span class="gi">+def wait() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wait for a watched file to change, then restart the process.

<span class="w"> </span>    Intended to be used at the end of scripts like unit test runners,
<span class="w"> </span>    to run the tests again after any source file changes (but see also
<span class="w"> </span>    the command-line interface in `main`)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    io_loop = ioloop.IOLoop()</span>
<span class="gi">+    io_loop.add_callback(start)</span>
<span class="gi">+    io_loop.start()</span>


<span class="gd">-def watch(filename: str) -&gt;None:</span>
<span class="gi">+def watch(filename: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a file to the watch list.

<span class="w"> </span>    All imported modules are watched by default.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _watched_files.add(filename)</span>


<span class="gd">-def add_reload_hook(fn: Callable[[], None]) -&gt;None:</span>
<span class="gi">+def add_reload_hook(fn: Callable[[], None]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a function to be called before reloading the process.

<span class="w"> </span>    Note that for open file and socket handles it is generally
<span class="w"> </span>    preferable to set the ``FD_CLOEXEC`` flag (using `fcntl` or
<span class="w"> </span>    `os.set_inheritable`) instead of using a reload hook to close them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _reload_hooks.append(fn)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _reload_on_update(modify_times: Dict[str, float]) -&gt; None:</span>
<span class="gi">+    if _reload_attempted:</span>
<span class="gi">+        # We already tried to reload and it didn&#39;t work, so don&#39;t try again.</span>
<span class="gi">+        return</span>
<span class="gi">+    if process.task_id() is not None:</span>
<span class="gi">+        # We&#39;re in a child process created by fork_processes.  If child</span>
<span class="gi">+        # processes restarted themselves, they&#39;d all restart and then</span>
<span class="gi">+        # all call fork_processes again.</span>
<span class="gi">+        return</span>
<span class="gi">+    for module in list(sys.modules.values()):</span>
<span class="gi">+        # Some modules play games with sys.modules (e.g. email/__init__.py</span>
<span class="gi">+        # in the standard library), and occasionally this can cause strange</span>
<span class="gi">+        # failures in getattr.  Just ignore anything that&#39;s not an ordinary</span>
<span class="gi">+        # module.</span>
<span class="gi">+        if not isinstance(module, types.ModuleType):</span>
<span class="gi">+            continue</span>
<span class="gi">+        path = getattr(module, &quot;__file__&quot;, None)</span>
<span class="gi">+        if not path:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if path.endswith(&quot;.pyc&quot;) or path.endswith(&quot;.pyo&quot;):</span>
<span class="gi">+            path = path[:-1]</span>
<span class="gi">+        _check_file(modify_times, path)</span>
<span class="gi">+    for path in _watched_files:</span>
<span class="gi">+        _check_file(modify_times, path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_file(modify_times: Dict[str, float], path: str) -&gt; None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        modified = os.stat(path).st_mtime</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return</span>
<span class="gi">+    if path not in modify_times:</span>
<span class="gi">+        modify_times[path] = modified</span>
<span class="gi">+        return</span>
<span class="gi">+    if modify_times[path] != modified:</span>
<span class="gi">+        gen_log.info(&quot;%s modified; restarting server&quot;, path)</span>
<span class="gi">+        _reload()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _reload() -&gt; None:</span>
<span class="gi">+    global _reload_attempted</span>
<span class="gi">+    _reload_attempted = True</span>
<span class="gi">+    for fn in _reload_hooks:</span>
<span class="gi">+        fn()</span>
<span class="gi">+    if sys.platform != &quot;win32&quot;:</span>
<span class="gi">+        # Clear the alarm signal set by</span>
<span class="gi">+        # ioloop.set_blocking_log_threshold so it doesn&#39;t fire</span>
<span class="gi">+        # after the exec.</span>
<span class="gi">+        signal.setitimer(signal.ITIMER_REAL, 0, 0)</span>
<span class="gi">+    # sys.path fixes: see comments at top of file.  If __main__.__spec__</span>
<span class="gi">+    # exists, we were invoked with -m and the effective path is about to</span>
<span class="gi">+    # change on re-exec.  Reconstruct the original command line to</span>
<span class="gi">+    # ensure that the new process sees the same path we did.</span>
<span class="gi">+    if _autoreload_is_main:</span>
<span class="gi">+        assert _original_argv is not None</span>
<span class="gi">+        spec = _original_spec</span>
<span class="gi">+        argv = _original_argv</span>
<span class="gi">+    else:</span>
<span class="gi">+        spec = getattr(sys.modules[&quot;__main__&quot;], &quot;__spec__&quot;, None)</span>
<span class="gi">+        argv = sys.argv</span>
<span class="gi">+    if spec and spec.name != &quot;__main__&quot;:</span>
<span class="gi">+        # __spec__ is set in two cases: when running a module, and when running a directory. (when</span>
<span class="gi">+        # running a file, there is no spec). In the former case, we must pass -m to maintain the</span>
<span class="gi">+        # module-style behavior (setting sys.path), even though python stripped -m from its argv at</span>
<span class="gi">+        # startup. If sys.path is exactly __main__, we&#39;re running a directory and should fall</span>
<span class="gi">+        # through to the non-module behavior.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Some of this, including the use of exactly __main__ as a spec for directory mode,</span>
<span class="gi">+        # is documented at https://docs.python.org/3/library/runpy.html#runpy.run_path</span>
<span class="gi">+        argv = [&quot;-m&quot;, spec.name] + argv[1:]</span>
<span class="gi">+</span>
<span class="gi">+    if not _has_execv:</span>
<span class="gi">+        subprocess.Popen([sys.executable] + argv)</span>
<span class="gi">+        os._exit(0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        os.execv(sys.executable, [sys.executable] + argv)</span>


<span class="w"> </span>_USAGE = &quot;&quot;&quot;
<span class="gu">@@ -103,7 +243,7 @@ _USAGE = &quot;&quot;&quot;</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def main() -&gt;None:</span>
<span class="gi">+def main() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Command-line wrapper to re-run a script whenever its source changes.

<span class="w"> </span>    Scripts may be specified by filename or module name::
<span class="gu">@@ -116,8 +256,95 @@ def main() -&gt;None:</span>
<span class="w"> </span>    can catch import-time problems like syntax errors that would otherwise
<span class="w"> </span>    prevent the script from reaching its call to `wait`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Remember that we were launched with autoreload as main.</span>
<span class="gi">+    # The main module can be tricky; set the variables both in our globals</span>
<span class="gi">+    # (which may be __main__) and the real importable version.</span>
<span class="gi">+    #</span>
<span class="gi">+    # We use optparse instead of the newer argparse because we want to</span>
<span class="gi">+    # mimic the python command-line interface which requires stopping</span>
<span class="gi">+    # parsing at the first positional argument. optparse supports</span>
<span class="gi">+    # this but as far as I can tell argparse does not.</span>
<span class="gi">+    import optparse</span>
<span class="gi">+    import tornado.autoreload</span>
<span class="gi">+</span>
<span class="gi">+    global _autoreload_is_main</span>
<span class="gi">+    global _original_argv, _original_spec</span>
<span class="gi">+    tornado.autoreload._autoreload_is_main = _autoreload_is_main = True</span>
<span class="gi">+    original_argv = sys.argv</span>
<span class="gi">+    tornado.autoreload._original_argv = _original_argv = original_argv</span>
<span class="gi">+    original_spec = getattr(sys.modules[&quot;__main__&quot;], &quot;__spec__&quot;, None)</span>
<span class="gi">+    tornado.autoreload._original_spec = _original_spec = original_spec</span>
<span class="gi">+</span>
<span class="gi">+    parser = optparse.OptionParser(</span>
<span class="gi">+        prog=&quot;python -m tornado.autoreload&quot;,</span>
<span class="gi">+        usage=_USAGE,</span>
<span class="gi">+        epilog=&quot;Either -m or a path must be specified, but not both&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.disable_interspersed_args()</span>
<span class="gi">+    parser.add_option(&quot;-m&quot;, dest=&quot;module&quot;, metavar=&quot;module&quot;, help=&quot;module to run&quot;)</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;--until-success&quot;,</span>
<span class="gi">+        action=&quot;store_true&quot;,</span>
<span class="gi">+        help=&quot;stop reloading after the program exist successfully (status code 0)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    opts, rest = parser.parse_args()</span>
<span class="gi">+    if opts.module is None:</span>
<span class="gi">+        if not rest:</span>
<span class="gi">+            print(&quot;Either -m or a path must be specified&quot;, file=sys.stderr)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+        path = rest[0]</span>
<span class="gi">+        sys.argv = rest[:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        path = None</span>
<span class="gi">+        sys.argv = [sys.argv[0]] + rest</span>
<span class="gi">+</span>
<span class="gi">+    # SystemExit.code is typed funny: https://github.com/python/typeshed/issues/8513</span>
<span class="gi">+    # All we care about is truthiness</span>
<span class="gi">+    exit_status: Union[int, str, None] = 1</span>
<span class="gi">+    try:</span>
<span class="gi">+        import runpy</span>
<span class="gi">+</span>
<span class="gi">+        if opts.module is not None:</span>
<span class="gi">+            runpy.run_module(opts.module, run_name=&quot;__main__&quot;, alter_sys=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert path is not None</span>
<span class="gi">+            runpy.run_path(path, run_name=&quot;__main__&quot;)</span>
<span class="gi">+    except SystemExit as e:</span>
<span class="gi">+        exit_status = e.code</span>
<span class="gi">+        gen_log.info(&quot;Script exited with status %s&quot;, e.code)</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        gen_log.warning(&quot;Script exited with uncaught exception&quot;, exc_info=True)</span>
<span class="gi">+        # If an exception occurred at import time, the file with the error</span>
<span class="gi">+        # never made it into sys.modules and so we won&#39;t know to watch it.</span>
<span class="gi">+        # Just to make sure we&#39;ve covered everything, walk the stack trace</span>
<span class="gi">+        # from the exception and watch every file.</span>
<span class="gi">+        for filename, lineno, name, line in traceback.extract_tb(sys.exc_info()[2]):</span>
<span class="gi">+            watch(filename)</span>
<span class="gi">+        if isinstance(e, SyntaxError):</span>
<span class="gi">+            # SyntaxErrors are special:  their innermost stack frame is fake</span>
<span class="gi">+            # so extract_tb won&#39;t see it and we have to get the filename</span>
<span class="gi">+            # from the exception object.</span>
<span class="gi">+            if e.filename is not None:</span>
<span class="gi">+                watch(e.filename)</span>
<span class="gi">+    else:</span>
<span class="gi">+        exit_status = 0</span>
<span class="gi">+        gen_log.info(&quot;Script exited normally&quot;)</span>
<span class="gi">+    # restore sys.argv so subsequent executions will include autoreload</span>
<span class="gi">+    sys.argv = original_argv</span>
<span class="gi">+</span>
<span class="gi">+    if opts.module is not None:</span>
<span class="gi">+        assert opts.module is not None</span>
<span class="gi">+        # runpy did a fake import of the module as __main__, but now it&#39;s</span>
<span class="gi">+        # no longer in sys.modules.  Figure out where it is and watch it.</span>
<span class="gi">+        loader = pkgutil.get_loader(opts.module)</span>
<span class="gi">+        if loader is not None and isinstance(loader, importlib.abc.FileLoader):</span>
<span class="gi">+            watch(loader.get_filename())</span>
<span class="gi">+    if opts.until_success and not exit_status:</span>
<span class="gi">+        return</span>
<span class="gi">+    wait()</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="gi">+    # See also the other __main__ block at the top of the file, which modifies</span>
<span class="gi">+    # sys.path before our imports</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/tornado/concurrent.py b/tornado/concurrent.py</span>
<span class="gh">index 16b042a9..5047c538 100644</span>
<span class="gd">--- a/tornado/concurrent.py</span>
<span class="gi">+++ b/tornado/concurrent.py</span>
<span class="gu">@@ -1,3 +1,17 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2012 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for working with ``Future`` objects.

<span class="w"> </span>Tornado previously provided its own ``Future`` class, but now uses
<span class="gu">@@ -10,33 +24,61 @@ implementation, applications rarely need to interact with it</span>
<span class="w"> </span>directly.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>from concurrent import futures
<span class="w"> </span>import functools
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="gi">+</span>
<span class="w"> </span>from tornado.log import app_log
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Any, Callable, Optional, Tuple, Union
<span class="gd">-_T = typing.TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = typing.TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class ReturnValueIgnoredError(Exception):
<span class="gi">+    # No longer used; was previously used by @return_future</span>
<span class="w"> </span>    pass


<span class="w"> </span>Future = asyncio.Future
<span class="gd">-FUTURES = futures.Future, Future</span>
<span class="gi">+</span>
<span class="gi">+FUTURES = (futures.Future, Future)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_future(x: Any) -&gt; bool:</span>
<span class="gi">+    return isinstance(x, FUTURES)</span>


<span class="w"> </span>class DummyExecutor(futures.Executor):
<span class="gi">+    def submit(  # type: ignore[override]</span>
<span class="gi">+        self, fn: Callable[..., _T], *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; &quot;futures.Future[_T]&quot;:</span>
<span class="gi">+        future = futures.Future()  # type: futures.Future[_T]</span>
<span class="gi">+        try:</span>
<span class="gi">+            future_set_result_unless_cancelled(future, fn(*args, **kwargs))</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            future_set_exc_info(future, sys.exc_info())</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="w"> </span>    if sys.version_info &gt;= (3, 9):

<span class="gi">+        def shutdown(self, wait: bool = True, cancel_futures: bool = False) -&gt; None:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def shutdown(self, wait: bool = True) -&gt; None:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>

<span class="w"> </span>dummy_executor = DummyExecutor()


<span class="gd">-def run_on_executor(*args: Any, **kwargs: Any) -&gt;Callable:</span>
<span class="gi">+def run_on_executor(*args: Any, **kwargs: Any) -&gt; Callable:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to run a synchronous method asynchronously on an executor.

<span class="w"> </span>    Returns a future.
<span class="gu">@@ -76,13 +118,34 @@ def run_on_executor(*args: Any, **kwargs: Any) -&gt;Callable:</span>

<span class="w"> </span>       The ``callback`` argument was removed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Fully type-checking decorators is tricky, and this one is</span>
<span class="gi">+    # discouraged anyway so it doesn&#39;t have all the generic magic.</span>
<span class="gi">+    def run_on_executor_decorator(fn: Callable) -&gt; Callable[..., Future]:</span>
<span class="gi">+        executor = kwargs.get(&quot;executor&quot;, &quot;executor&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(fn)</span>
<span class="gi">+        def wrapper(self: Any, *args: Any, **kwargs: Any) -&gt; Future:</span>
<span class="gi">+            async_future = Future()  # type: Future</span>
<span class="gi">+            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)</span>
<span class="gi">+            chain_future(conc_future, async_future)</span>
<span class="gi">+            return async_future</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    if args and kwargs:</span>
<span class="gi">+        raise ValueError(&quot;cannot combine positional and keyword args&quot;)</span>
<span class="gi">+    if len(args) == 1:</span>
<span class="gi">+        return run_on_executor_decorator(args[0])</span>
<span class="gi">+    elif len(args) != 0:</span>
<span class="gi">+        raise ValueError(&quot;expected 1 argument, got %d&quot;, len(args))</span>
<span class="gi">+    return run_on_executor_decorator</span>


<span class="w"> </span>_NO_RESULT = object()


<span class="gd">-def chain_future(a: &#39;Future[_T]&#39;, b: &#39;Future[_T]&#39;) -&gt;None:</span>
<span class="gi">+def chain_future(a: &quot;Future[_T]&quot;, b: &quot;Future[_T]&quot;) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Chain two futures together so that when one completes, so does the other.

<span class="w"> </span>    The result (success or failure) of ``a`` will be copied to ``b``, unless
<span class="gu">@@ -94,11 +157,31 @@ def chain_future(a: &#39;Future[_T]&#39;, b: &#39;Future[_T]&#39;) -&gt;None:</span>
<span class="w"> </span>       `concurrent.futures.Future`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def future_set_result_unless_cancelled(future:</span>
<span class="gd">-    &#39;Union[futures.Future[_T], Future[_T]]&#39;, value: _T) -&gt;None:</span>
<span class="gi">+    def copy(a: &quot;Future[_T]&quot;) -&gt; None:</span>
<span class="gi">+        if b.done():</span>
<span class="gi">+            return</span>
<span class="gi">+        if hasattr(a, &quot;exc_info&quot;) and a.exc_info() is not None:  # type: ignore</span>
<span class="gi">+            future_set_exc_info(b, a.exc_info())  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            a_exc = a.exception()</span>
<span class="gi">+            if a_exc is not None:</span>
<span class="gi">+                b.set_exception(a_exc)</span>
<span class="gi">+            else:</span>
<span class="gi">+                b.set_result(a.result())</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(a, Future):</span>
<span class="gi">+        future_add_done_callback(a, copy)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # concurrent.futures.Future</span>
<span class="gi">+        from tornado.ioloop import IOLoop</span>
<span class="gi">+</span>
<span class="gi">+        IOLoop.current().add_future(a, copy)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def future_set_result_unless_cancelled(</span>
<span class="gi">+    future: &quot;Union[futures.Future[_T], Future[_T]]&quot;, value: _T</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the given ``value`` as the `Future`&#39;s result, if not cancelled.

<span class="w"> </span>    Avoids ``asyncio.InvalidStateError`` when calling ``set_result()`` on
<span class="gu">@@ -106,11 +189,13 @@ def future_set_result_unless_cancelled(future:</span>

<span class="w"> </span>    .. versionadded:: 5.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not future.cancelled():</span>
<span class="gi">+        future.set_result(value)</span>


<span class="gd">-def future_set_exception_unless_cancelled(future:</span>
<span class="gd">-    &#39;Union[futures.Future[_T], Future[_T]]&#39;, exc: BaseException) -&gt;None:</span>
<span class="gi">+def future_set_exception_unless_cancelled(</span>
<span class="gi">+    future: &quot;Union[futures.Future[_T], Future[_T]]&quot;, exc: BaseException</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the given ``exc`` as the `Future`&#39;s exception.

<span class="w"> </span>    If the Future is already canceled, logs the exception instead. If
<span class="gu">@@ -124,12 +209,18 @@ def future_set_exception_unless_cancelled(future:</span>
<span class="w"> </span>    .. versionadded:: 6.0

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def future_set_exc_info(future: &#39;Union[futures.Future[_T], Future[_T]]&#39;,</span>
<span class="gd">-    exc_info: Tuple[Optional[type], Optional[BaseException], Optional[types</span>
<span class="gd">-    .TracebackType]]) -&gt;None:</span>
<span class="gi">+    if not future.cancelled():</span>
<span class="gi">+        future.set_exception(exc)</span>
<span class="gi">+    else:</span>
<span class="gi">+        app_log.error(&quot;Exception after Future was cancelled&quot;, exc_info=exc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def future_set_exc_info(</span>
<span class="gi">+    future: &quot;Union[futures.Future[_T], Future[_T]]&quot;,</span>
<span class="gi">+    exc_info: Tuple[</span>
<span class="gi">+        Optional[type], Optional[BaseException], Optional[types.TracebackType]</span>
<span class="gi">+    ],</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the given ``exc_info`` as the `Future`&#39;s exception.

<span class="w"> </span>    Understands both `asyncio.Future` and the extensions in older
<span class="gu">@@ -143,12 +234,28 @@ def future_set_exc_info(future: &#39;Union[futures.Future[_T], Future[_T]]&#39;,</span>
<span class="w"> </span>       (previously ``asyncio.InvalidStateError`` would be raised)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    if exc_info[1] is None:</span>
<span class="gi">+        raise Exception(&quot;future_set_exc_info called with no exception&quot;)</span>
<span class="gi">+    future_set_exception_unless_cancelled(future, exc_info[1])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def future_add_done_callback(</span>
<span class="gi">+    future: &quot;futures.Future[_T]&quot;, callback: Callable[[&quot;futures.Future[_T]&quot;], None]</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    pass


<span class="gd">-def future_add_done_callback(future:</span>
<span class="gd">-    &#39;Union[futures.Future[_T], Future[_T]]&#39;, callback: Callable[..., None]</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+@typing.overload  # noqa: F811</span>
<span class="gi">+def future_add_done_callback(</span>
<span class="gi">+    future: &quot;Future[_T]&quot;, callback: Callable[[&quot;Future[_T]&quot;], None]</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def future_add_done_callback(  # noqa: F811</span>
<span class="gi">+    future: &quot;Union[futures.Future[_T], Future[_T]]&quot;, callback: Callable[..., None]</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Arrange to call ``callback`` when ``future`` is complete.

<span class="w"> </span>    ``callback`` is invoked with one argument, the ``future``.
<span class="gu">@@ -159,4 +266,7 @@ def future_add_done_callback(future:</span>

<span class="w"> </span>    .. versionadded:: 5.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if future.done():</span>
<span class="gi">+        callback(future)</span>
<span class="gi">+    else:</span>
<span class="gi">+        future.add_done_callback(callback)</span>
<span class="gh">diff --git a/tornado/curl_httpclient.py b/tornado/curl_httpclient.py</span>
<span class="gh">index 548b9c4d..397c3a97 100644</span>
<span class="gd">--- a/tornado/curl_httpclient.py</span>
<span class="gi">+++ b/tornado/curl_httpclient.py</span>
<span class="gu">@@ -1,4 +1,20 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Non-blocking HTTP client implementation using pycurl.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import functools
<span class="w"> </span>import logging
<span class="gu">@@ -7,62 +23,566 @@ import re</span>
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="w"> </span>from io import BytesIO
<span class="gi">+</span>
<span class="w"> </span>from tornado import httputil
<span class="w"> </span>from tornado import ioloop
<span class="gi">+</span>
<span class="w"> </span>from tornado.escape import utf8, native_str
<span class="gd">-from tornado.httpclient import HTTPRequest, HTTPResponse, HTTPError, AsyncHTTPClient, main</span>
<span class="gi">+from tornado.httpclient import (</span>
<span class="gi">+    HTTPRequest,</span>
<span class="gi">+    HTTPResponse,</span>
<span class="gi">+    HTTPError,</span>
<span class="gi">+    AsyncHTTPClient,</span>
<span class="gi">+    main,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.log import app_log
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict, Any, Callable, Union, Optional
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Deque, Tuple</span>
<span class="gd">-curl_log = logging.getLogger(&#39;tornado.curl_httpclient&#39;)</span>
<span class="gd">-CR_OR_LF_RE = re.compile(b&#39;\r|\n&#39;)</span>
<span class="gi">+    from typing import Deque, Tuple  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+curl_log = logging.getLogger(&quot;tornado.curl_httpclient&quot;)</span>
<span class="gi">+</span>
<span class="gi">+CR_OR_LF_RE = re.compile(b&quot;\r|\n&quot;)</span>


<span class="w"> </span>class CurlAsyncHTTPClient(AsyncHTTPClient):
<span class="gi">+    def initialize(  # type: ignore</span>
<span class="gi">+        self, max_clients: int = 10, defaults: Optional[Dict[str, Any]] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().initialize(defaults=defaults)</span>
<span class="gi">+        # Typeshed is incomplete for CurlMulti, so just use Any for now.</span>
<span class="gi">+        self._multi = pycurl.CurlMulti()  # type: Any</span>
<span class="gi">+        self._multi.setopt(pycurl.M_TIMERFUNCTION, self._set_timeout)</span>
<span class="gi">+        self._multi.setopt(pycurl.M_SOCKETFUNCTION, self._handle_socket)</span>
<span class="gi">+        self._curls = [self._curl_create() for i in range(max_clients)]</span>
<span class="gi">+        self._free_list = self._curls[:]</span>
<span class="gi">+        self._requests = (</span>
<span class="gi">+            collections.deque()</span>
<span class="gi">+        )  # type: Deque[Tuple[HTTPRequest, Callable[[HTTPResponse], None], float]]</span>
<span class="gi">+        self._fds = {}  # type: Dict[int, int]</span>
<span class="gi">+        self._timeout = None  # type: Optional[object]</span>
<span class="gi">+</span>
<span class="gi">+        # libcurl has bugs that sometimes cause it to not report all</span>
<span class="gi">+        # relevant file descriptors and timeouts to TIMERFUNCTION/</span>
<span class="gi">+        # SOCKETFUNCTION.  Mitigate the effects of such bugs by</span>
<span class="gi">+        # forcing a periodic scan of all active requests.</span>
<span class="gi">+        self._force_timeout_callback = ioloop.PeriodicCallback(</span>
<span class="gi">+            self._handle_force_timeout, 1000</span>
<span class="gi">+        )</span>
<span class="gi">+        self._force_timeout_callback.start()</span>
<span class="gi">+</span>
<span class="gi">+        # Work around a bug in libcurl 7.29.0: Some fields in the curl</span>
<span class="gi">+        # multi object are initialized lazily, and its destructor will</span>
<span class="gi">+        # segfault if it is destroyed without having been used.  Add</span>
<span class="gi">+        # and remove a dummy handle to make sure everything is</span>
<span class="gi">+        # initialized.</span>
<span class="gi">+        dummy_curl_handle = pycurl.Curl()</span>
<span class="gi">+        self._multi.add_handle(dummy_curl_handle)</span>
<span class="gi">+        self._multi.remove_handle(dummy_curl_handle)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self._force_timeout_callback.stop()</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self._timeout)</span>
<span class="gi">+        for curl in self._curls:</span>
<span class="gi">+            curl.close()</span>
<span class="gi">+        self._multi.close()</span>
<span class="gi">+        super().close()</span>

<span class="gd">-    def _handle_socket(self, event: int, fd: int, multi: Any, data: bytes</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # Set below properties to None to reduce the reference count of current</span>
<span class="gi">+        # instance, because those properties hold some methods of current</span>
<span class="gi">+        # instance that will case circular reference.</span>
<span class="gi">+        self._force_timeout_callback = None  # type: ignore</span>
<span class="gi">+        self._multi = None</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_impl(</span>
<span class="gi">+        self, request: HTTPRequest, callback: Callable[[HTTPResponse], None]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._requests.append((request, callback, self.io_loop.time()))</span>
<span class="gi">+        self._process_queue()</span>
<span class="gi">+        self._set_timeout(0)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_socket(self, event: int, fd: int, multi: Any, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by libcurl when it wants to change the file descriptors
<span class="w"> </span>        it cares about.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        event_map = {</span>
<span class="gi">+            pycurl.POLL_NONE: ioloop.IOLoop.NONE,</span>
<span class="gi">+            pycurl.POLL_IN: ioloop.IOLoop.READ,</span>
<span class="gi">+            pycurl.POLL_OUT: ioloop.IOLoop.WRITE,</span>
<span class="gi">+            pycurl.POLL_INOUT: ioloop.IOLoop.READ | ioloop.IOLoop.WRITE,</span>
<span class="gi">+        }</span>
<span class="gi">+        if event == pycurl.POLL_REMOVE:</span>
<span class="gi">+            if fd in self._fds:</span>
<span class="gi">+                self.io_loop.remove_handler(fd)</span>
<span class="gi">+                del self._fds[fd]</span>
<span class="gi">+        else:</span>
<span class="gi">+            ioloop_event = event_map[event]</span>
<span class="gi">+            # libcurl sometimes closes a socket and then opens a new</span>
<span class="gi">+            # one using the same FD without giving us a POLL_NONE in</span>
<span class="gi">+            # between.  This is a problem with the epoll IOLoop,</span>
<span class="gi">+            # because the kernel can tell when a socket is closed and</span>
<span class="gi">+            # removes it from the epoll automatically, causing future</span>
<span class="gi">+            # update_handler calls to fail.  Since we can&#39;t tell when</span>
<span class="gi">+            # this has happened, always use remove and re-add</span>
<span class="gi">+            # instead of update.</span>
<span class="gi">+            if fd in self._fds:</span>
<span class="gi">+                self.io_loop.remove_handler(fd)</span>
<span class="gi">+            self.io_loop.add_handler(fd, self._handle_events, ioloop_event)</span>
<span class="gi">+            self._fds[fd] = ioloop_event</span>

<span class="gd">-    def _set_timeout(self, msecs: int) -&gt;None:</span>
<span class="gi">+    def _set_timeout(self, msecs: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by libcurl to schedule a timeout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self._timeout)</span>
<span class="gi">+        self._timeout = self.io_loop.add_timeout(</span>
<span class="gi">+            self.io_loop.time() + msecs / 1000.0, self._handle_timeout</span>
<span class="gi">+        )</span>

<span class="gd">-    def _handle_events(self, fd: int, events: int) -&gt;None:</span>
<span class="gi">+    def _handle_events(self, fd: int, events: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by IOLoop when there is activity on one of our
<span class="w"> </span>        file descriptors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        action = 0</span>
<span class="gi">+        if events &amp; ioloop.IOLoop.READ:</span>
<span class="gi">+            action |= pycurl.CSELECT_IN</span>
<span class="gi">+        if events &amp; ioloop.IOLoop.WRITE:</span>
<span class="gi">+            action |= pycurl.CSELECT_OUT</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ret, num_handles = self._multi.socket_action(fd, action)</span>
<span class="gi">+            except pycurl.error as e:</span>
<span class="gi">+                ret = e.args[0]</span>
<span class="gi">+            if ret != pycurl.E_CALL_MULTI_PERFORM:</span>
<span class="gi">+                break</span>
<span class="gi">+        self._finish_pending_requests()</span>

<span class="gd">-    def _handle_timeout(self) -&gt;None:</span>
<span class="gi">+    def _handle_timeout(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by IOLoop when the requested timeout has passed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._timeout = None</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ret, num_handles = self._multi.socket_action(pycurl.SOCKET_TIMEOUT, 0)</span>
<span class="gi">+            except pycurl.error as e:</span>
<span class="gi">+                ret = e.args[0]</span>
<span class="gi">+            if ret != pycurl.E_CALL_MULTI_PERFORM:</span>
<span class="gi">+                break</span>
<span class="gi">+        self._finish_pending_requests()</span>
<span class="gi">+</span>
<span class="gi">+        # In theory, we shouldn&#39;t have to do this because curl will</span>
<span class="gi">+        # call _set_timeout whenever the timeout changes.  However,</span>
<span class="gi">+        # sometimes after _handle_timeout we will need to reschedule</span>
<span class="gi">+        # immediately even though nothing has changed from curl&#39;s</span>
<span class="gi">+        # perspective.  This is because when socket_action is</span>
<span class="gi">+        # called with SOCKET_TIMEOUT, libcurl decides internally which</span>
<span class="gi">+        # timeouts need to be processed by using a monotonic clock</span>
<span class="gi">+        # (where available) while tornado uses python&#39;s time.time()</span>
<span class="gi">+        # to decide when timeouts have occurred.  When those clocks</span>
<span class="gi">+        # disagree on elapsed time (as they will whenever there is an</span>
<span class="gi">+        # NTP adjustment), tornado might call _handle_timeout before</span>
<span class="gi">+        # libcurl is ready.  After each timeout, resync the scheduled</span>
<span class="gi">+        # timeout with libcurl&#39;s current state.</span>
<span class="gi">+        new_timeout = self._multi.timeout()</span>
<span class="gi">+        if new_timeout &gt;= 0:</span>
<span class="gi">+            self._set_timeout(new_timeout)</span>

<span class="gd">-    def _handle_force_timeout(self) -&gt;None:</span>
<span class="gi">+    def _handle_force_timeout(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by IOLoop periodically to ask libcurl to process any
<span class="w"> </span>        events it may have forgotten about.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ret, num_handles = self._multi.socket_all()</span>
<span class="gi">+            except pycurl.error as e:</span>
<span class="gi">+                ret = e.args[0]</span>
<span class="gi">+            if ret != pycurl.E_CALL_MULTI_PERFORM:</span>
<span class="gi">+                break</span>
<span class="gi">+        self._finish_pending_requests()</span>

<span class="gd">-    def _finish_pending_requests(self) -&gt;None:</span>
<span class="gi">+    def _finish_pending_requests(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process any requests that were completed by the last
<span class="w"> </span>        call to multi.socket_action.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            num_q, ok_list, err_list = self._multi.info_read()</span>
<span class="gi">+            for curl in ok_list:</span>
<span class="gi">+                self._finish(curl)</span>
<span class="gi">+            for curl, errnum, errmsg in err_list:</span>
<span class="gi">+                self._finish(curl, errnum, errmsg)</span>
<span class="gi">+            if num_q == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+        self._process_queue()</span>

<span class="gi">+    def _process_queue(self) -&gt; None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            started = 0</span>
<span class="gi">+            while self._free_list and self._requests:</span>
<span class="gi">+                started += 1</span>
<span class="gi">+                curl = self._free_list.pop()</span>
<span class="gi">+                (request, callback, queue_start_time) = self._requests.popleft()</span>
<span class="gi">+                # TODO: Don&#39;t smuggle extra data on an attribute of the Curl object.</span>
<span class="gi">+                curl.info = {  # type: ignore</span>
<span class="gi">+                    &quot;headers&quot;: httputil.HTTPHeaders(),</span>
<span class="gi">+                    &quot;buffer&quot;: BytesIO(),</span>
<span class="gi">+                    &quot;request&quot;: request,</span>
<span class="gi">+                    &quot;callback&quot;: callback,</span>
<span class="gi">+                    &quot;queue_start_time&quot;: queue_start_time,</span>
<span class="gi">+                    &quot;curl_start_time&quot;: time.time(),</span>
<span class="gi">+                    &quot;curl_start_ioloop_time&quot;: self.io_loop.current().time(),  # type: ignore</span>
<span class="gi">+                }</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._curl_setup_request(</span>
<span class="gi">+                        curl,</span>
<span class="gi">+                        request,</span>
<span class="gi">+                        curl.info[&quot;buffer&quot;],  # type: ignore</span>
<span class="gi">+                        curl.info[&quot;headers&quot;],  # type: ignore</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception as e:</span>
<span class="gi">+                    # If there was an error in setup, pass it on</span>
<span class="gi">+                    # to the callback. Note that allowing the</span>
<span class="gi">+                    # error to escape here will appear to work</span>
<span class="gi">+                    # most of the time since we are still in the</span>
<span class="gi">+                    # caller&#39;s original stack frame, but when</span>
<span class="gi">+                    # _process_queue() is called from</span>
<span class="gi">+                    # _finish_pending_requests the exceptions have</span>
<span class="gi">+                    # nowhere to go.</span>
<span class="gi">+                    self._free_list.append(curl)</span>
<span class="gi">+                    callback(HTTPResponse(request=request, code=599, error=e))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._multi.add_handle(curl)</span>

<span class="gd">-class CurlError(HTTPError):</span>
<span class="gi">+            if not started:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def _finish(</span>
<span class="gi">+        self,</span>
<span class="gi">+        curl: pycurl.Curl,</span>
<span class="gi">+        curl_error: Optional[int] = None,</span>
<span class="gi">+        curl_message: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        info = curl.info  # type: ignore</span>
<span class="gi">+        curl.info = None  # type: ignore</span>
<span class="gi">+        self._multi.remove_handle(curl)</span>
<span class="gi">+        self._free_list.append(curl)</span>
<span class="gi">+        buffer = info[&quot;buffer&quot;]</span>
<span class="gi">+        if curl_error:</span>
<span class="gi">+            assert curl_message is not None</span>
<span class="gi">+            error = CurlError(curl_error, curl_message)  # type: Optional[CurlError]</span>
<span class="gi">+            assert error is not None</span>
<span class="gi">+            code = error.code</span>
<span class="gi">+            effective_url = None</span>
<span class="gi">+            buffer.close()</span>
<span class="gi">+            buffer = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            error = None</span>
<span class="gi">+            code = curl.getinfo(pycurl.HTTP_CODE)</span>
<span class="gi">+            effective_url = curl.getinfo(pycurl.EFFECTIVE_URL)</span>
<span class="gi">+            buffer.seek(0)</span>
<span class="gi">+        # the various curl timings are documented at</span>
<span class="gi">+        # http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html</span>
<span class="gi">+        time_info = dict(</span>
<span class="gi">+            queue=info[&quot;curl_start_ioloop_time&quot;] - info[&quot;queue_start_time&quot;],</span>
<span class="gi">+            namelookup=curl.getinfo(pycurl.NAMELOOKUP_TIME),</span>
<span class="gi">+            connect=curl.getinfo(pycurl.CONNECT_TIME),</span>
<span class="gi">+            appconnect=curl.getinfo(pycurl.APPCONNECT_TIME),</span>
<span class="gi">+            pretransfer=curl.getinfo(pycurl.PRETRANSFER_TIME),</span>
<span class="gi">+            starttransfer=curl.getinfo(pycurl.STARTTRANSFER_TIME),</span>
<span class="gi">+            total=curl.getinfo(pycurl.TOTAL_TIME),</span>
<span class="gi">+            redirect=curl.getinfo(pycurl.REDIRECT_TIME),</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            info[&quot;callback&quot;](</span>
<span class="gi">+                HTTPResponse(</span>
<span class="gi">+                    request=info[&quot;request&quot;],</span>
<span class="gi">+                    code=code,</span>
<span class="gi">+                    headers=info[&quot;headers&quot;],</span>
<span class="gi">+                    buffer=buffer,</span>
<span class="gi">+                    effective_url=effective_url,</span>
<span class="gi">+                    error=error,</span>
<span class="gi">+                    reason=info[&quot;headers&quot;].get(&quot;X-Http-Reason&quot;, None),</span>
<span class="gi">+                    request_time=self.io_loop.time() - info[&quot;curl_start_ioloop_time&quot;],</span>
<span class="gi">+                    start_time=info[&quot;curl_start_time&quot;],</span>
<span class="gi">+                    time_info=time_info,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            self.handle_callback_exception(info[&quot;callback&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    def handle_callback_exception(self, callback: Any) -&gt; None:</span>
<span class="gi">+        app_log.error(&quot;Exception in callback %r&quot;, callback, exc_info=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _curl_create(self) -&gt; pycurl.Curl:</span>
<span class="gi">+        curl = pycurl.Curl()</span>
<span class="gi">+        if curl_log.isEnabledFor(logging.DEBUG):</span>
<span class="gi">+            curl.setopt(pycurl.VERBOSE, 1)</span>
<span class="gi">+            curl.setopt(pycurl.DEBUGFUNCTION, self._curl_debug)</span>
<span class="gi">+        if hasattr(</span>
<span class="gi">+            pycurl, &quot;PROTOCOLS&quot;</span>
<span class="gi">+        ):  # PROTOCOLS first appeared in pycurl 7.19.5 (2014-07-12)</span>
<span class="gi">+            curl.setopt(pycurl.PROTOCOLS, pycurl.PROTO_HTTP | pycurl.PROTO_HTTPS)</span>
<span class="gi">+            curl.setopt(pycurl.REDIR_PROTOCOLS, pycurl.PROTO_HTTP | pycurl.PROTO_HTTPS)</span>
<span class="gi">+        return curl</span>
<span class="gi">+</span>
<span class="gi">+    def _curl_setup_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        curl: pycurl.Curl,</span>
<span class="gi">+        request: HTTPRequest,</span>
<span class="gi">+        buffer: BytesIO,</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        curl.setopt(pycurl.URL, native_str(request.url))</span>
<span class="gi">+</span>
<span class="gi">+        # libcurl&#39;s magic &quot;Expect: 100-continue&quot; behavior causes delays</span>
<span class="gi">+        # with servers that don&#39;t support it (which include, among others,</span>
<span class="gi">+        # Google&#39;s OpenID endpoint).  Additionally, this behavior has</span>
<span class="gi">+        # a bug in conjunction with the curl_multi_socket_action API</span>
<span class="gi">+        # (https://sourceforge.net/tracker/?func=detail&amp;atid=100976&amp;aid=3039744&amp;group_id=976),</span>
<span class="gi">+        # which increases the delays.  It&#39;s more trouble than it&#39;s worth,</span>
<span class="gi">+        # so just turn off the feature (yes, setting Expect: to an empty</span>
<span class="gi">+        # value is the official way to disable this)</span>
<span class="gi">+        if &quot;Expect&quot; not in request.headers:</span>
<span class="gi">+            request.headers[&quot;Expect&quot;] = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # libcurl adds Pragma: no-cache by default; disable that too</span>
<span class="gi">+        if &quot;Pragma&quot; not in request.headers:</span>
<span class="gi">+            request.headers[&quot;Pragma&quot;] = &quot;&quot;</span>

<span class="gd">-    def __init__(self, errno: int, message: str) -&gt;None:</span>
<span class="gi">+        encoded_headers = [</span>
<span class="gi">+            b&quot;%s: %s&quot;</span>
<span class="gi">+            % (native_str(k).encode(&quot;ASCII&quot;), native_str(v).encode(&quot;ISO8859-1&quot;))</span>
<span class="gi">+            for k, v in request.headers.get_all()</span>
<span class="gi">+        ]</span>
<span class="gi">+        for line in encoded_headers:</span>
<span class="gi">+            if CR_OR_LF_RE.search(line):</span>
<span class="gi">+                raise ValueError(&quot;Illegal characters in header (CR or LF): %r&quot; % line)</span>
<span class="gi">+        curl.setopt(pycurl.HTTPHEADER, encoded_headers)</span>
<span class="gi">+</span>
<span class="gi">+        curl.setopt(</span>
<span class="gi">+            pycurl.HEADERFUNCTION,</span>
<span class="gi">+            functools.partial(</span>
<span class="gi">+                self._curl_header_callback, headers, request.header_callback</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        if request.streaming_callback:</span>
<span class="gi">+</span>
<span class="gi">+            def write_function(b: Union[bytes, bytearray]) -&gt; int:</span>
<span class="gi">+                assert request.streaming_callback is not None</span>
<span class="gi">+                self.io_loop.add_callback(request.streaming_callback, b)</span>
<span class="gi">+                return len(b)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            write_function = buffer.write  # type: ignore</span>
<span class="gi">+        curl.setopt(pycurl.WRITEFUNCTION, write_function)</span>
<span class="gi">+        curl.setopt(pycurl.FOLLOWLOCATION, request.follow_redirects)</span>
<span class="gi">+        curl.setopt(pycurl.MAXREDIRS, request.max_redirects)</span>
<span class="gi">+        assert request.connect_timeout is not None</span>
<span class="gi">+        curl.setopt(pycurl.CONNECTTIMEOUT_MS, int(1000 * request.connect_timeout))</span>
<span class="gi">+        assert request.request_timeout is not None</span>
<span class="gi">+        curl.setopt(pycurl.TIMEOUT_MS, int(1000 * request.request_timeout))</span>
<span class="gi">+        if request.user_agent:</span>
<span class="gi">+            curl.setopt(pycurl.USERAGENT, native_str(request.user_agent))</span>
<span class="gi">+        else:</span>
<span class="gi">+            curl.setopt(pycurl.USERAGENT, &quot;Mozilla/5.0 (compatible; pycurl)&quot;)</span>
<span class="gi">+        if request.network_interface:</span>
<span class="gi">+            curl.setopt(pycurl.INTERFACE, request.network_interface)</span>
<span class="gi">+        if request.decompress_response:</span>
<span class="gi">+            curl.setopt(pycurl.ENCODING, &quot;gzip,deflate&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            curl.setopt(pycurl.ENCODING, None)</span>
<span class="gi">+        if request.proxy_host and request.proxy_port:</span>
<span class="gi">+            curl.setopt(pycurl.PROXY, request.proxy_host)</span>
<span class="gi">+            curl.setopt(pycurl.PROXYPORT, request.proxy_port)</span>
<span class="gi">+            if request.proxy_username:</span>
<span class="gi">+                assert request.proxy_password is not None</span>
<span class="gi">+                credentials = httputil.encode_username_password(</span>
<span class="gi">+                    request.proxy_username, request.proxy_password</span>
<span class="gi">+                )</span>
<span class="gi">+                curl.setopt(pycurl.PROXYUSERPWD, credentials)</span>
<span class="gi">+</span>
<span class="gi">+            if request.proxy_auth_mode is None or request.proxy_auth_mode == &quot;basic&quot;:</span>
<span class="gi">+                curl.setopt(pycurl.PROXYAUTH, pycurl.HTTPAUTH_BASIC)</span>
<span class="gi">+            elif request.proxy_auth_mode == &quot;digest&quot;:</span>
<span class="gi">+                curl.setopt(pycurl.PROXYAUTH, pycurl.HTTPAUTH_DIGEST)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Unsupported proxy_auth_mode %s&quot; % request.proxy_auth_mode</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                curl.unsetopt(pycurl.PROXY)</span>
<span class="gi">+            except TypeError:  # not supported, disable proxy</span>
<span class="gi">+                curl.setopt(pycurl.PROXY, &quot;&quot;)</span>
<span class="gi">+            curl.unsetopt(pycurl.PROXYUSERPWD)</span>
<span class="gi">+        if request.validate_cert:</span>
<span class="gi">+            curl.setopt(pycurl.SSL_VERIFYPEER, 1)</span>
<span class="gi">+            curl.setopt(pycurl.SSL_VERIFYHOST, 2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            curl.setopt(pycurl.SSL_VERIFYPEER, 0)</span>
<span class="gi">+            curl.setopt(pycurl.SSL_VERIFYHOST, 0)</span>
<span class="gi">+        if request.ca_certs is not None:</span>
<span class="gi">+            curl.setopt(pycurl.CAINFO, request.ca_certs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # There is no way to restore pycurl.CAINFO to its default value</span>
<span class="gi">+            # (Using unsetopt makes it reject all certificates).</span>
<span class="gi">+            # I don&#39;t see any way to read the default value from python so it</span>
<span class="gi">+            # can be restored later.  We&#39;ll have to just leave CAINFO untouched</span>
<span class="gi">+            # if no ca_certs file was specified, and require that if any</span>
<span class="gi">+            # request uses a custom ca_certs file, they all must.</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        if request.allow_ipv6 is False:</span>
<span class="gi">+            # Curl behaves reasonably when DNS resolution gives an ipv6 address</span>
<span class="gi">+            # that we can&#39;t reach, so allow ipv6 unless the user asks to disable.</span>
<span class="gi">+            curl.setopt(pycurl.IPRESOLVE, pycurl.IPRESOLVE_V4)</span>
<span class="gi">+        else:</span>
<span class="gi">+            curl.setopt(pycurl.IPRESOLVE, pycurl.IPRESOLVE_WHATEVER)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the request method through curl&#39;s irritating interface which makes</span>
<span class="gi">+        # up names for almost every single method</span>
<span class="gi">+        curl_options = {</span>
<span class="gi">+            &quot;GET&quot;: pycurl.HTTPGET,</span>
<span class="gi">+            &quot;POST&quot;: pycurl.POST,</span>
<span class="gi">+            &quot;PUT&quot;: pycurl.UPLOAD,</span>
<span class="gi">+            &quot;HEAD&quot;: pycurl.NOBODY,</span>
<span class="gi">+        }</span>
<span class="gi">+        custom_methods = set([&quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;PATCH&quot;])</span>
<span class="gi">+        for o in curl_options.values():</span>
<span class="gi">+            curl.setopt(o, False)</span>
<span class="gi">+        if request.method in curl_options:</span>
<span class="gi">+            curl.unsetopt(pycurl.CUSTOMREQUEST)</span>
<span class="gi">+            curl.setopt(curl_options[request.method], True)</span>
<span class="gi">+        elif request.allow_nonstandard_methods or request.method in custom_methods:</span>
<span class="gi">+            curl.setopt(pycurl.CUSTOMREQUEST, request.method)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise KeyError(&quot;unknown method &quot; + request.method)</span>
<span class="gi">+</span>
<span class="gi">+        body_expected = request.method in (&quot;POST&quot;, &quot;PATCH&quot;, &quot;PUT&quot;)</span>
<span class="gi">+        body_present = request.body is not None</span>
<span class="gi">+        if not request.allow_nonstandard_methods:</span>
<span class="gi">+            # Some HTTP methods nearly always have bodies while others</span>
<span class="gi">+            # almost never do. Fail in this case unless the user has</span>
<span class="gi">+            # opted out of sanity checks with allow_nonstandard_methods.</span>
<span class="gi">+            if (body_expected and not body_present) or (</span>
<span class="gi">+                body_present and not body_expected</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Body must %sbe None for method %s (unless &quot;</span>
<span class="gi">+                    &quot;allow_nonstandard_methods is true)&quot;</span>
<span class="gi">+                    % (&quot;not &quot; if body_expected else &quot;&quot;, request.method)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if body_expected or body_present:</span>
<span class="gi">+            if request.method == &quot;GET&quot;:</span>
<span class="gi">+                # Even with `allow_nonstandard_methods` we disallow</span>
<span class="gi">+                # GET with a body (because libcurl doesn&#39;t allow it</span>
<span class="gi">+                # unless we use CUSTOMREQUEST). While the spec doesn&#39;t</span>
<span class="gi">+                # forbid clients from sending a body, it arguably</span>
<span class="gi">+                # disallows the server from doing anything with them.</span>
<span class="gi">+                raise ValueError(&quot;Body must be None for GET request&quot;)</span>
<span class="gi">+            request_buffer = BytesIO(utf8(request.body or &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            def ioctl(cmd: int) -&gt; None:</span>
<span class="gi">+                if cmd == curl.IOCMD_RESTARTREAD:  # type: ignore</span>
<span class="gi">+                    request_buffer.seek(0)</span>
<span class="gi">+</span>
<span class="gi">+            curl.setopt(pycurl.READFUNCTION, request_buffer.read)</span>
<span class="gi">+            curl.setopt(pycurl.IOCTLFUNCTION, ioctl)</span>
<span class="gi">+            if request.method == &quot;POST&quot;:</span>
<span class="gi">+                curl.setopt(pycurl.POSTFIELDSIZE, len(request.body or &quot;&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                curl.setopt(pycurl.UPLOAD, True)</span>
<span class="gi">+                curl.setopt(pycurl.INFILESIZE, len(request.body or &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if request.auth_username is not None:</span>
<span class="gi">+            assert request.auth_password is not None</span>
<span class="gi">+            if request.auth_mode is None or request.auth_mode == &quot;basic&quot;:</span>
<span class="gi">+                curl.setopt(pycurl.HTTPAUTH, pycurl.HTTPAUTH_BASIC)</span>
<span class="gi">+            elif request.auth_mode == &quot;digest&quot;:</span>
<span class="gi">+                curl.setopt(pycurl.HTTPAUTH, pycurl.HTTPAUTH_DIGEST)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;Unsupported auth_mode %s&quot; % request.auth_mode)</span>
<span class="gi">+</span>
<span class="gi">+            userpwd = httputil.encode_username_password(</span>
<span class="gi">+                request.auth_username, request.auth_password</span>
<span class="gi">+            )</span>
<span class="gi">+            curl.setopt(pycurl.USERPWD, userpwd)</span>
<span class="gi">+            curl_log.debug(</span>
<span class="gi">+                &quot;%s %s (username: %r)&quot;,</span>
<span class="gi">+                request.method,</span>
<span class="gi">+                request.url,</span>
<span class="gi">+                request.auth_username,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            curl.unsetopt(pycurl.USERPWD)</span>
<span class="gi">+            curl_log.debug(&quot;%s %s&quot;, request.method, request.url)</span>
<span class="gi">+</span>
<span class="gi">+        if request.client_cert is not None:</span>
<span class="gi">+            curl.setopt(pycurl.SSLCERT, request.client_cert)</span>
<span class="gi">+</span>
<span class="gi">+        if request.client_key is not None:</span>
<span class="gi">+            curl.setopt(pycurl.SSLKEY, request.client_key)</span>
<span class="gi">+</span>
<span class="gi">+        if request.ssl_options is not None:</span>
<span class="gi">+            raise ValueError(&quot;ssl_options not supported in curl_httpclient&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if threading.active_count() &gt; 1:</span>
<span class="gi">+            # libcurl/pycurl is not thread-safe by default.  When multiple threads</span>
<span class="gi">+            # are used, signals should be disabled.  This has the side effect</span>
<span class="gi">+            # of disabling DNS timeouts in some environments (when libcurl is</span>
<span class="gi">+            # not linked against ares), so we don&#39;t do it when there is only one</span>
<span class="gi">+            # thread.  Applications that use many short-lived threads may need</span>
<span class="gi">+            # to set NOSIGNAL manually in a prepare_curl_callback since</span>
<span class="gi">+            # there may not be any other threads running at the time we call</span>
<span class="gi">+            # threading.activeCount.</span>
<span class="gi">+            curl.setopt(pycurl.NOSIGNAL, 1)</span>
<span class="gi">+        if request.prepare_curl_callback is not None:</span>
<span class="gi">+            request.prepare_curl_callback(curl)</span>
<span class="gi">+</span>
<span class="gi">+    def _curl_header_callback(</span>
<span class="gi">+        self,</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+        header_callback: Callable[[str], None],</span>
<span class="gi">+        header_line_bytes: bytes,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        header_line = native_str(header_line_bytes.decode(&quot;latin1&quot;))</span>
<span class="gi">+        if header_callback is not None:</span>
<span class="gi">+            self.io_loop.add_callback(header_callback, header_line)</span>
<span class="gi">+        # header_line as returned by curl includes the end-of-line characters.</span>
<span class="gi">+        # whitespace at the start should be preserved to allow multi-line headers</span>
<span class="gi">+        header_line = header_line.rstrip()</span>
<span class="gi">+        if header_line.startswith(&quot;HTTP/&quot;):</span>
<span class="gi">+            headers.clear()</span>
<span class="gi">+            try:</span>
<span class="gi">+                (__, __, reason) = httputil.parse_response_start_line(header_line)</span>
<span class="gi">+                header_line = &quot;X-Http-Reason: %s&quot; % reason</span>
<span class="gi">+            except httputil.HTTPInputError:</span>
<span class="gi">+                return</span>
<span class="gi">+        if not header_line:</span>
<span class="gi">+            return</span>
<span class="gi">+        headers.parse_line(header_line)</span>
<span class="gi">+</span>
<span class="gi">+    def _curl_debug(self, debug_type: int, debug_msg: str) -&gt; None:</span>
<span class="gi">+        debug_types = (&quot;I&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)</span>
<span class="gi">+        if debug_type == 0:</span>
<span class="gi">+            debug_msg = native_str(debug_msg)</span>
<span class="gi">+            curl_log.debug(&quot;%s&quot;, debug_msg.strip())</span>
<span class="gi">+        elif debug_type in (1, 2):</span>
<span class="gi">+            debug_msg = native_str(debug_msg)</span>
<span class="gi">+            for line in debug_msg.splitlines():</span>
<span class="gi">+                curl_log.debug(&quot;%s %s&quot;, debug_types[debug_type], line)</span>
<span class="gi">+        elif debug_type == 4:</span>
<span class="gi">+            curl_log.debug(&quot;%s %r&quot;, debug_types[debug_type], debug_msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class CurlError(HTTPError):</span>
<span class="gi">+    def __init__(self, errno: int, message: str) -&gt; None:</span>
<span class="w"> </span>        HTTPError.__init__(self, 599, message)
<span class="w"> </span>        self.errno = errno


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    AsyncHTTPClient.configure(CurlAsyncHTTPClient)
<span class="w"> </span>    main()
<span class="gh">diff --git a/tornado/escape.py b/tornado/escape.py</span>
<span class="gh">index 15f61dbe..84abfca6 100644</span>
<span class="gd">--- a/tornado/escape.py</span>
<span class="gi">+++ b/tornado/escape.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Escaping/unescaping methods for HTML, JSON, URLs, and others.

<span class="w"> </span>Also includes a few other miscellaneous string manipulation functions that
<span class="gu">@@ -9,16 +24,19 @@ and were more relevant in Python 2). In new code, the standard library</span>
<span class="w"> </span>functions are encouraged instead of this module where applicable. See the
<span class="w"> </span>docstrings on each function for details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import html
<span class="w"> </span>import json
<span class="w"> </span>import re
<span class="w"> </span>import urllib.parse
<span class="gi">+</span>
<span class="w"> </span>from tornado.util import unicode_type
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Union, Any, Optional, Dict, List, Callable


<span class="gd">-def xhtml_escape(value: Union[str, bytes]) -&gt;str:</span>
<span class="gi">+def xhtml_escape(value: Union[str, bytes]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Escapes a string so it is valid within HTML or XML.

<span class="w"> </span>    Escapes the characters ``&lt;``, ``&gt;``, ``&quot;``, ``&#39;``, and ``&amp;``.
<span class="gu">@@ -38,10 +56,10 @@ def xhtml_escape(value: Union[str, bytes]) -&gt;str:</span>
<span class="w"> </span>       except that single quotes are now escaped as ``&amp;#x27;`` instead of
<span class="w"> </span>       ``&amp;#39;`` and performance may be different.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return html.escape(to_unicode(value))</span>


<span class="gd">-def xhtml_unescape(value: Union[str, bytes]) -&gt;str:</span>
<span class="gi">+def xhtml_unescape(value: Union[str, bytes]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Un-escapes an XML-escaped string.

<span class="w"> </span>    Equivalent to `html.unescape` except that this function always returns
<span class="gu">@@ -56,33 +74,42 @@ def xhtml_unescape(value: Union[str, bytes]) -&gt;str:</span>
<span class="w"> </span>       Some invalid inputs such as surrogates now raise an error, and numeric
<span class="w"> </span>       references to certain ISO-8859-1 characters are now handled correctly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return html.unescape(to_unicode(value))</span>


<span class="gd">-def json_encode(value: Any) -&gt;str:</span>
<span class="gi">+# The fact that json_encode wraps json.dumps is an implementation detail.</span>
<span class="gi">+# Please see https://github.com/tornadoweb/tornado/pull/706</span>
<span class="gi">+# before sending a pull request that adds **kwargs to this function.</span>
<span class="gi">+def json_encode(value: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;JSON-encodes the given Python object.

<span class="w"> </span>    Equivalent to `json.dumps` with the additional guarantee that the output
<span class="w"> </span>    will never contain the character sequence ``&lt;/`` which can be problematic
<span class="w"> </span>    when JSON is embedded in an HTML ``&lt;script&gt;`` tag.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # JSON permits but does not require forward slashes to be escaped.</span>
<span class="gi">+    # This is useful when json data is emitted in a &lt;script&gt; tag</span>
<span class="gi">+    # in HTML, as it prevents &lt;/script&gt; tags from prematurely terminating</span>
<span class="gi">+    # the JavaScript.  Some json libraries do this escaping by default,</span>
<span class="gi">+    # although python&#39;s standard library does not, so we do it here.</span>
<span class="gi">+    # http://stackoverflow.com/questions/1580647/json-why-are-forward-slashes-escaped</span>
<span class="gi">+    return json.dumps(value).replace(&quot;&lt;/&quot;, &quot;&lt;\\/&quot;)</span>


<span class="gd">-def json_decode(value: Union[str, bytes]) -&gt;Any:</span>
<span class="gi">+def json_decode(value: Union[str, bytes]) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns Python objects for the given JSON string.

<span class="w"> </span>    Supports both `str` and `bytes` inputs. Equvalent to `json.loads`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return json.loads(value)</span>


<span class="gd">-def squeeze(value: str) -&gt;str:</span>
<span class="gi">+def squeeze(value: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Replace all sequences of whitespace chars with a single space.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.sub(r&quot;[\x00-\x20]+&quot;, &quot; &quot;, value).strip()</span>


<span class="gd">-def url_escape(value: Union[str, bytes], plus: bool=True) -&gt;str:</span>
<span class="gi">+def url_escape(value: Union[str, bytes], plus: bool = True) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a URL-encoded version of the given value.

<span class="w"> </span>    Equivalent to either `urllib.parse.quote_plus` or `urllib.parse.quote` depending on the ``plus``
<span class="gu">@@ -97,11 +124,25 @@ def url_escape(value: Union[str, bytes], plus: bool=True) -&gt;str:</span>
<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>        The ``plus`` argument
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    quote = urllib.parse.quote_plus if plus else urllib.parse.quote</span>
<span class="gi">+    return quote(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def url_unescape(value: Union[str, bytes], encoding: None, plus: bool = True) -&gt; bytes:</span>
<span class="w"> </span>    pass


<span class="gd">-def url_unescape(value: Union[str, bytes], encoding: Optional[str]=&#39;utf-8&#39;,</span>
<span class="gd">-    plus: bool=True) -&gt;Union[str, bytes]:</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def url_unescape(</span>
<span class="gi">+    value: Union[str, bytes], encoding: str = &quot;utf-8&quot;, plus: bool = True</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def url_unescape(</span>
<span class="gi">+    value: Union[str, bytes], encoding: Optional[str] = &quot;utf-8&quot;, plus: bool = True</span>
<span class="gi">+) -&gt; Union[str, bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decodes the given value from a URL.

<span class="w"> </span>    The argument may be either a byte or unicode string.
<span class="gu">@@ -119,11 +160,19 @@ def url_unescape(value: Union[str, bytes], encoding: Optional[str]=&#39;utf-8&#39;,</span>
<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>       The ``plus`` argument
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_qs_bytes(qs: Union[str, bytes], keep_blank_values: bool=False,</span>
<span class="gd">-    strict_parsing: bool=False) -&gt;Dict[str, List[bytes]]:</span>
<span class="gi">+    if encoding is None:</span>
<span class="gi">+        if plus:</span>
<span class="gi">+            # unquote_to_bytes doesn&#39;t have a _plus variant</span>
<span class="gi">+            value = to_basestring(value).replace(&quot;+&quot;, &quot; &quot;)</span>
<span class="gi">+        return urllib.parse.unquote_to_bytes(value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        unquote = urllib.parse.unquote_plus if plus else urllib.parse.unquote</span>
<span class="gi">+        return unquote(to_basestring(value), encoding=encoding)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_qs_bytes(</span>
<span class="gi">+    qs: Union[str, bytes], keep_blank_values: bool = False, strict_parsing: bool = False</span>
<span class="gi">+) -&gt; Dict[str, List[bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses a query string like urlparse.parse_qs,
<span class="w"> </span>    but takes bytes and returns the values as byte strings.

<span class="gu">@@ -131,54 +180,131 @@ def parse_qs_bytes(qs: Union[str, bytes], keep_blank_values: bool=False,</span>
<span class="w"> </span>    because it&#39;s too painful to keep them as byte strings in
<span class="w"> </span>    python3 and in practice they&#39;re nearly always ascii anyway.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # This is gross, but python3 doesn&#39;t give us another way.</span>
<span class="gi">+    # Latin1 is the universal donor of character encodings.</span>
<span class="gi">+    if isinstance(qs, bytes):</span>
<span class="gi">+        qs = qs.decode(&quot;latin1&quot;)</span>
<span class="gi">+    result = urllib.parse.parse_qs(</span>
<span class="gi">+        qs, keep_blank_values, strict_parsing, encoding=&quot;latin1&quot;, errors=&quot;strict&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    encoded = {}</span>
<span class="gi">+    for k, v in result.items():</span>
<span class="gi">+        encoded[k] = [i.encode(&quot;latin1&quot;) for i in v]</span>
<span class="gi">+    return encoded</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_UTF8_TYPES = (bytes, type(None))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def utf8(value: bytes) -&gt; bytes:</span>
<span class="w"> </span>    pass


<span class="gd">-_UTF8_TYPES = bytes, type(None)</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def utf8(value: str) -&gt; bytes:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>

<span class="gi">+@typing.overload</span>
<span class="gi">+def utf8(value: None) -&gt; None:</span>
<span class="gi">+    pass</span>

<span class="gd">-def utf8(value: Union[None, str, bytes]) -&gt;Optional[bytes]:</span>
<span class="gi">+</span>
<span class="gi">+def utf8(value: Union[None, str, bytes]) -&gt; Optional[bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts a string argument to a byte string.

<span class="w"> </span>    If the argument is already a byte string or None, it is returned unchanged.
<span class="w"> </span>    Otherwise it must be a unicode string and is encoded as utf8.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    if isinstance(value, _UTF8_TYPES):</span>
<span class="gi">+        return value</span>
<span class="gi">+    if not isinstance(value, unicode_type):</span>
<span class="gi">+        raise TypeError(&quot;Expected bytes, unicode, or None; got %r&quot; % type(value))</span>
<span class="gi">+    return value.encode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_TO_UNICODE_TYPES = (unicode_type, type(None))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def to_unicode(value: str) -&gt; str:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def to_unicode(value: bytes) -&gt; str:</span>
<span class="w"> </span>    pass


<span class="gd">-_TO_UNICODE_TYPES = unicode_type, type(None)</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def to_unicode(value: None) -&gt; None:</span>
<span class="gi">+    pass</span>


<span class="gd">-def to_unicode(value: Union[None, str, bytes]) -&gt;Optional[str]:</span>
<span class="gi">+def to_unicode(value: Union[None, str, bytes]) -&gt; Optional[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts a string argument to a unicode string.

<span class="w"> </span>    If the argument is already a unicode string or None, it is returned
<span class="w"> </span>    unchanged.  Otherwise it must be a byte string and is decoded as utf8.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, _TO_UNICODE_TYPES):</span>
<span class="gi">+        return value</span>
<span class="gi">+    if not isinstance(value, bytes):</span>
<span class="gi">+        raise TypeError(&quot;Expected bytes, unicode, or None; got %r&quot; % type(value))</span>
<span class="gi">+    return value.decode(&quot;utf-8&quot;)</span>


<span class="gi">+# to_unicode was previously named _unicode not because it was private,</span>
<span class="gi">+# but to avoid conflicts with the built-in unicode() function/type</span>
<span class="w"> </span>_unicode = to_unicode
<span class="gi">+</span>
<span class="gi">+# When dealing with the standard library across python 2 and 3 it is</span>
<span class="gi">+# sometimes useful to have a direct conversion to the native string type</span>
<span class="w"> </span>native_str = to_unicode
<span class="w"> </span>to_basestring = to_unicode


<span class="gd">-def recursive_unicode(obj: Any) -&gt;Any:</span>
<span class="gi">+def recursive_unicode(obj: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Walks a simple data structure, converting byte strings to unicode.

<span class="w"> </span>    Supports lists, tuples, and dictionaries.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_URL_RE = re.compile(to_unicode(</span>
<span class="gd">-    &#39;\\b((?:([\\w-]+):(/{1,3})|www[.])(?:(?:(?:[^\\s&amp;()]|&amp;amp;|&amp;quot;)*(?:[^!&quot;#$%&amp;\&#39;()*+,.:;&lt;=&gt;?@\\[\\]^`{|}~\\s]))|(?:\\((?:[^\\s&amp;()]|&amp;amp;|&amp;quot;)*\\)))+)&#39;</span>
<span class="gd">-    ))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def linkify(text: Union[str, bytes], shorten: bool=False, extra_params:</span>
<span class="gd">-    Union[str, Callable[[str], str]]=&#39;&#39;, require_protocol: bool=False,</span>
<span class="gd">-    permitted_protocols: List[str]=[&#39;http&#39;, &#39;https&#39;]) -&gt;str:</span>
<span class="gi">+    if isinstance(obj, dict):</span>
<span class="gi">+        return dict(</span>
<span class="gi">+            (recursive_unicode(k), recursive_unicode(v)) for (k, v) in obj.items()</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(obj, list):</span>
<span class="gi">+        return list(recursive_unicode(i) for i in obj)</span>
<span class="gi">+    elif isinstance(obj, tuple):</span>
<span class="gi">+        return tuple(recursive_unicode(i) for i in obj)</span>
<span class="gi">+    elif isinstance(obj, bytes):</span>
<span class="gi">+        return to_unicode(obj)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# I originally used the regex from</span>
<span class="gi">+# http://daringfireball.net/2010/07/improved_regex_for_matching_urls</span>
<span class="gi">+# but it gets all exponential on certain patterns (such as too many trailing</span>
<span class="gi">+# dots), causing the regex matcher to never return.</span>
<span class="gi">+# This regex should avoid those problems.</span>
<span class="gi">+# Use to_unicode instead of tornado.util.u - we don&#39;t want backslashes getting</span>
<span class="gi">+# processed as escapes.</span>
<span class="gi">+_URL_RE = re.compile(</span>
<span class="gi">+    to_unicode(</span>
<span class="gi">+        r&quot;&quot;&quot;\b((?:([\w-]+):(/{1,3})|www[.])(?:(?:(?:[^\s&amp;()]|&amp;amp;|&amp;quot;)*(?:[^!&quot;#$%&amp;&#39;()*+,.:;&lt;=&gt;?@\[\]^`{|}~\s]))|(?:\((?:[^\s&amp;()]|&amp;amp;|&amp;quot;)*\)))+)&quot;&quot;&quot;  # noqa: E501</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def linkify(</span>
<span class="gi">+    text: Union[str, bytes],</span>
<span class="gi">+    shorten: bool = False,</span>
<span class="gi">+    extra_params: Union[str, Callable[[str], str]] = &quot;&quot;,</span>
<span class="gi">+    require_protocol: bool = False,</span>
<span class="gi">+    permitted_protocols: List[str] = [&quot;http&quot;, &quot;https&quot;],</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts plain text into HTML with links.

<span class="w"> </span>    For example: ``linkify(&quot;Hello http://tornadoweb.org!&quot;)`` would return
<span class="gu">@@ -208,4 +334,70 @@ def linkify(text: Union[str, bytes], shorten: bool=False, extra_params:</span>
<span class="w"> </span>      &quot;mailto&quot;])``. It is very unsafe to include protocols such as
<span class="w"> </span>      ``javascript``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if extra_params and not callable(extra_params):</span>
<span class="gi">+        extra_params = &quot; &quot; + extra_params.strip()</span>
<span class="gi">+</span>
<span class="gi">+    def make_link(m: typing.Match) -&gt; str:</span>
<span class="gi">+        url = m.group(1)</span>
<span class="gi">+        proto = m.group(2)</span>
<span class="gi">+        if require_protocol and not proto:</span>
<span class="gi">+            return url  # not protocol, no linkify</span>
<span class="gi">+</span>
<span class="gi">+        if proto and proto not in permitted_protocols:</span>
<span class="gi">+            return url  # bad protocol, no linkify</span>
<span class="gi">+</span>
<span class="gi">+        href = m.group(1)</span>
<span class="gi">+        if not proto:</span>
<span class="gi">+            href = &quot;http://&quot; + href  # no proto specified, use http</span>
<span class="gi">+</span>
<span class="gi">+        if callable(extra_params):</span>
<span class="gi">+            params = &quot; &quot; + extra_params(href).strip()</span>
<span class="gi">+        else:</span>
<span class="gi">+            params = extra_params</span>
<span class="gi">+</span>
<span class="gi">+        # clip long urls. max_len is just an approximation</span>
<span class="gi">+        max_len = 30</span>
<span class="gi">+        if shorten and len(url) &gt; max_len:</span>
<span class="gi">+            before_clip = url</span>
<span class="gi">+            if proto:</span>
<span class="gi">+                proto_len = len(proto) + 1 + len(m.group(3) or &quot;&quot;)  # +1 for :</span>
<span class="gi">+            else:</span>
<span class="gi">+                proto_len = 0</span>
<span class="gi">+</span>
<span class="gi">+            parts = url[proto_len:].split(&quot;/&quot;)</span>
<span class="gi">+            if len(parts) &gt; 1:</span>
<span class="gi">+                # Grab the whole host part plus the first bit of the path</span>
<span class="gi">+                # The path is usually not that interesting once shortened</span>
<span class="gi">+                # (no more slug, etc), so it really just provides a little</span>
<span class="gi">+                # extra indication of shortening.</span>
<span class="gi">+                url = (</span>
<span class="gi">+                    url[:proto_len]</span>
<span class="gi">+                    + parts[0]</span>
<span class="gi">+                    + &quot;/&quot;</span>
<span class="gi">+                    + parts[1][:8].split(&quot;?&quot;)[0].split(&quot;.&quot;)[0]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if len(url) &gt; max_len * 1.5:  # still too long</span>
<span class="gi">+                url = url[:max_len]</span>
<span class="gi">+</span>
<span class="gi">+            if url != before_clip:</span>
<span class="gi">+                amp = url.rfind(&quot;&amp;&quot;)</span>
<span class="gi">+                # avoid splitting html char entities</span>
<span class="gi">+                if amp &gt; max_len - 5:</span>
<span class="gi">+                    url = url[:amp]</span>
<span class="gi">+                url += &quot;...&quot;</span>
<span class="gi">+</span>
<span class="gi">+                if len(url) &gt;= len(before_clip):</span>
<span class="gi">+                    url = before_clip</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # full url is visible on mouse-over (for those who don&#39;t</span>
<span class="gi">+                    # have a status bar, such as Safari by default)</span>
<span class="gi">+                    params += &#39; title=&quot;%s&quot;&#39; % href</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;&lt;a href=&quot;%s&quot;%s&gt;%s&lt;/a&gt;&#39; % (href, params, url)</span>
<span class="gi">+</span>
<span class="gi">+    # First HTML-escape so that our strings are all safe.</span>
<span class="gi">+    # The regex is modified to avoid character entites other than &amp;amp; so</span>
<span class="gi">+    # that we won&#39;t pick up &amp;quot;, etc.</span>
<span class="gi">+    text = _unicode(xhtml_escape(text))</span>
<span class="gi">+    return _URL_RE.sub(make_link, text)</span>
<span class="gh">diff --git a/tornado/gen.py b/tornado/gen.py</span>
<span class="gh">index 19f311cf..0e3c7a6f 100644</span>
<span class="gd">--- a/tornado/gen.py</span>
<span class="gi">+++ b/tornado/gen.py</span>
<span class="gu">@@ -66,6 +66,7 @@ function to extend this mechanism.</span>
<span class="w"> </span>   via ``singledispatch``.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import builtins
<span class="w"> </span>import collections
<span class="gu">@@ -77,21 +78,35 @@ from functools import singledispatch</span>
<span class="w"> </span>from inspect import isawaitable
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="gd">-from tornado.concurrent import Future, is_future, chain_future, future_set_exc_info, future_add_done_callback, future_set_result_unless_cancelled</span>
<span class="gi">+</span>
<span class="gi">+from tornado.concurrent import (</span>
<span class="gi">+    Future,</span>
<span class="gi">+    is_future,</span>
<span class="gi">+    chain_future,</span>
<span class="gi">+    future_set_exc_info,</span>
<span class="gi">+    future_add_done_callback,</span>
<span class="gi">+    future_set_result_unless_cancelled,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.log import app_log
<span class="w"> </span>from tornado.util import TimeoutError
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import contextvars
<span class="w"> </span>except ImportError:
<span class="gd">-    contextvars = None</span>
<span class="gi">+    contextvars = None  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Union, Any, Callable, List, Type, Tuple, Awaitable, Dict, overload
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Sequence, Deque, Optional, Set, Iterable</span>
<span class="gd">-_T = typing.TypeVar(&#39;_T&#39;)</span>
<span class="gd">-_Yieldable = Union[None, Awaitable, List[Awaitable], Dict[Any, Awaitable],</span>
<span class="gd">-    concurrent.futures.Future]</span>
<span class="gi">+    from typing import Sequence, Deque, Optional, Set, Iterable  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+_T = typing.TypeVar(&quot;_T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+_Yieldable = Union[</span>
<span class="gi">+    None, Awaitable, List[Awaitable], Dict[Any, Awaitable], concurrent.futures.Future</span>
<span class="gi">+]</span>


<span class="w"> </span>class KeyReuseError(Exception):
<span class="gu">@@ -114,8 +129,53 @@ class ReturnValueIgnoredError(Exception):</span>
<span class="w"> </span>    pass


<span class="gd">-def coroutine(func: Union[Callable[..., &#39;Generator[Any, Any, _T]&#39;],</span>
<span class="gd">-    Callable[..., _T]]) -&gt;Callable[..., &#39;Future[_T]&#39;]:</span>
<span class="gi">+def _value_from_stopiteration(e: Union[StopIteration, &quot;Return&quot;]) -&gt; Any:</span>
<span class="gi">+    try:</span>
<span class="gi">+        # StopIteration has a value attribute beginning in py33.</span>
<span class="gi">+        # So does our Return class.</span>
<span class="gi">+        return e.value</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Cython backports coroutine functionality by putting the value in</span>
<span class="gi">+        # e.args[0].</span>
<span class="gi">+        return e.args[0]</span>
<span class="gi">+    except (AttributeError, IndexError):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_future() -&gt; Future:</span>
<span class="gi">+    future = Future()  # type: Future</span>
<span class="gi">+    # Fixup asyncio debug info by removing extraneous stack entries</span>
<span class="gi">+    source_traceback = getattr(future, &quot;_source_traceback&quot;, ())</span>
<span class="gi">+    while source_traceback:</span>
<span class="gi">+        # Each traceback entry is equivalent to a</span>
<span class="gi">+        # (filename, self.lineno, self.name, self.line) tuple</span>
<span class="gi">+        filename = source_traceback[-1][0]</span>
<span class="gi">+        if filename == __file__:</span>
<span class="gi">+            del source_traceback[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+    return future</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _fake_ctx_run(f: Callable[..., _T], *args: Any, **kw: Any) -&gt; _T:</span>
<span class="gi">+    return f(*args, **kw)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def coroutine(</span>
<span class="gi">+    func: Callable[..., &quot;Generator[Any, Any, _T]&quot;]</span>
<span class="gi">+) -&gt; Callable[..., &quot;Future[_T]&quot;]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def coroutine(func: Callable[..., _T]) -&gt; Callable[..., &quot;Future[_T]&quot;]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def coroutine(</span>
<span class="gi">+    func: Union[Callable[..., &quot;Generator[Any, Any, _T]&quot;], Callable[..., _T]]</span>
<span class="gi">+) -&gt; Callable[..., &quot;Future[_T]&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator for asynchronous generators.

<span class="w"> </span>    For compatibility with older versions of Python, coroutines may
<span class="gu">@@ -140,16 +200,82 @@ def coroutine(func: Union[Callable[..., &#39;Generator[Any, Any, _T]&#39;],</span>
<span class="w"> </span>       awaitable object instead.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def is_coroutine_function(func: Any) -&gt;bool:</span>
<span class="gi">+    @functools.wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        # type: (*Any, **Any) -&gt; Future[_T]</span>
<span class="gi">+        # This function is type-annotated with a comment to work around</span>
<span class="gi">+        # https://bitbucket.org/pypy/pypy/issues/2868/segfault-with-args-type-annotation-in</span>
<span class="gi">+        future = _create_future()</span>
<span class="gi">+        if contextvars is not None:</span>
<span class="gi">+            ctx_run = contextvars.copy_context().run  # type: Callable</span>
<span class="gi">+        else:</span>
<span class="gi">+            ctx_run = _fake_ctx_run</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = ctx_run(func, *args, **kwargs)</span>
<span class="gi">+        except (Return, StopIteration) as e:</span>
<span class="gi">+            result = _value_from_stopiteration(e)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            future_set_exc_info(future, sys.exc_info())</span>
<span class="gi">+            try:</span>
<span class="gi">+                return future</span>
<span class="gi">+            finally:</span>
<span class="gi">+                # Avoid circular references</span>
<span class="gi">+                future = None  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(result, Generator):</span>
<span class="gi">+                # Inline the first iteration of Runner.run.  This lets us</span>
<span class="gi">+                # avoid the cost of creating a Runner when the coroutine</span>
<span class="gi">+                # never actually yields, which in turn allows us to</span>
<span class="gi">+                # use &quot;optional&quot; coroutines in critical path code without</span>
<span class="gi">+                # performance penalty for the synchronous case.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yielded = ctx_run(next, result)</span>
<span class="gi">+                except (StopIteration, Return) as e:</span>
<span class="gi">+                    future_set_result_unless_cancelled(</span>
<span class="gi">+                        future, _value_from_stopiteration(e)</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    future_set_exc_info(future, sys.exc_info())</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Provide strong references to Runner objects as long</span>
<span class="gi">+                    # as their result future objects also have strong</span>
<span class="gi">+                    # references (typically from the parent coroutine&#39;s</span>
<span class="gi">+                    # Runner). This keeps the coroutine&#39;s Runner alive.</span>
<span class="gi">+                    # We do this by exploiting the public API</span>
<span class="gi">+                    # add_done_callback() instead of putting a private</span>
<span class="gi">+                    # attribute on the Future.</span>
<span class="gi">+                    # (GitHub issues #1769, #2229).</span>
<span class="gi">+                    runner = Runner(ctx_run, result, future, yielded)</span>
<span class="gi">+                    future.add_done_callback(lambda _: runner)</span>
<span class="gi">+                yielded = None</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return future</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    # Subtle memory optimization: if next() raised an exception,</span>
<span class="gi">+                    # the future&#39;s exc_info contains a traceback which</span>
<span class="gi">+                    # includes this stack frame.  This creates a cycle,</span>
<span class="gi">+                    # which will be collected at the next full GC but has</span>
<span class="gi">+                    # been shown to greatly increase memory usage of</span>
<span class="gi">+                    # benchmarks (relative to the refcount-based scheme</span>
<span class="gi">+                    # used in the absence of cycles).  We can avoid the</span>
<span class="gi">+                    # cycle by clearing the local variable after we return it.</span>
<span class="gi">+                    future = None  # type: ignore</span>
<span class="gi">+        future_set_result_unless_cancelled(future, result)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    wrapper.__wrapped__ = func  # type: ignore</span>
<span class="gi">+    wrapper.__tornado_coroutine__ = True  # type: ignore</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_coroutine_function(func: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return whether *func* is a coroutine function, i.e. a function
<span class="w"> </span>    wrapped with `~.gen.coroutine`.

<span class="w"> </span>    .. versionadded:: 4.5
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return getattr(func, &quot;__tornado_coroutine__&quot;, False)</span>


<span class="w"> </span>class Return(Exception):
<span class="gu">@@ -173,10 +299,11 @@ class Return(Exception):</span>
<span class="w"> </span>    statement can be used with no arguments instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, value: Any=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: Any = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.value = value
<span class="gd">-        self.args = value,</span>
<span class="gi">+        # Cython recognizes subclasses of StopIteration with a .args tuple.</span>
<span class="gi">+        self.args = (value,)</span>


<span class="w"> </span>class WaitIterator(object):
<span class="gu">@@ -233,54 +360,84 @@ class WaitIterator(object):</span>
<span class="w"> </span>       Added ``async for`` support in Python 3.5.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _unfinished = {}</span>

<span class="gd">-    def __init__(self, *args: Future, **kwargs: Future) -&gt;None:</span>
<span class="gi">+    _unfinished = {}  # type: Dict[Future, Union[int, str]]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *args: Future, **kwargs: Future) -&gt; None:</span>
<span class="w"> </span>        if args and kwargs:
<span class="gd">-            raise ValueError(&#39;You must provide args or kwargs, not both&#39;)</span>
<span class="gi">+            raise ValueError(&quot;You must provide args or kwargs, not both&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if kwargs:
<span class="gd">-            self._unfinished = dict((f, k) for k, f in kwargs.items())</span>
<span class="gd">-            futures = list(kwargs.values())</span>
<span class="gi">+            self._unfinished = dict((f, k) for (k, f) in kwargs.items())</span>
<span class="gi">+            futures = list(kwargs.values())  # type: Sequence[Future]</span>
<span class="w"> </span>        else:
<span class="gd">-            self._unfinished = dict((f, i) for i, f in enumerate(args))</span>
<span class="gi">+            self._unfinished = dict((f, i) for (i, f) in enumerate(args))</span>
<span class="w"> </span>            futures = args
<span class="gd">-        self._finished = collections.deque()</span>
<span class="gd">-        self.current_index = None</span>
<span class="gd">-        self.current_future = None</span>
<span class="gd">-        self._running_future = None</span>
<span class="gi">+</span>
<span class="gi">+        self._finished = collections.deque()  # type: Deque[Future]</span>
<span class="gi">+        self.current_index = None  # type: Optional[Union[str, int]]</span>
<span class="gi">+        self.current_future = None  # type: Optional[Future]</span>
<span class="gi">+        self._running_future = None  # type: Optional[Future]</span>
<span class="gi">+</span>
<span class="w"> </span>        for future in futures:
<span class="w"> </span>            future_add_done_callback(future, self._done_callback)

<span class="gd">-    def done(self) -&gt;bool:</span>
<span class="gi">+    def done(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns True if this iterator has no more results.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._finished or self._unfinished:</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Clear the &#39;current&#39; values when iteration is done.</span>
<span class="gi">+        self.current_index = self.current_future = None</span>
<span class="gi">+        return True</span>

<span class="gd">-    def next(self) -&gt;Future:</span>
<span class="gi">+    def next(self) -&gt; Future:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a `.Future` that will yield the next available result.

<span class="w"> </span>        Note that this `.Future` will not be the same object as any of
<span class="w"> </span>        the inputs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._running_future = Future()</span>

<span class="gd">-    def _return_result(self, done: Future) -&gt;Future:</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            return self._return_result(self._finished.popleft())</span>
<span class="gi">+</span>
<span class="gi">+        return self._running_future</span>
<span class="gi">+</span>
<span class="gi">+    def _done_callback(self, done: Future) -&gt; None:</span>
<span class="gi">+        if self._running_future and not self._running_future.done():</span>
<span class="gi">+            self._return_result(done)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._finished.append(done)</span>
<span class="gi">+</span>
<span class="gi">+    def _return_result(self, done: Future) -&gt; Future:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called set the returned future&#39;s state that of the future
<span class="w"> </span>        we yielded, and set the current future for the iterator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._running_future is None:</span>
<span class="gi">+            raise Exception(&quot;no future is running&quot;)</span>
<span class="gi">+        chain_future(done, self._running_future)</span>
<span class="gi">+</span>
<span class="gi">+        res = self._running_future</span>
<span class="gi">+        self._running_future = None</span>
<span class="gi">+        self.current_future = done</span>
<span class="gi">+        self.current_index = self._unfinished.pop(done)</span>

<span class="gd">-    def __aiter__(self) -&gt;typing.AsyncIterator:</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def __aiter__(self) -&gt; typing.AsyncIterator:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __anext__(self) -&gt;Future:</span>
<span class="gi">+    def __anext__(self) -&gt; Future:</span>
<span class="w"> </span>        if self.done():
<span class="gd">-            raise getattr(builtins, &#39;StopAsyncIteration&#39;)()</span>
<span class="gi">+            # Lookup by name to silence pyflakes on older versions.</span>
<span class="gi">+            raise getattr(builtins, &quot;StopAsyncIteration&quot;)()</span>
<span class="w"> </span>        return self.next()


<span class="gd">-def multi(children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="gd">-    quiet_exceptions: &#39;Union[Type[Exception], Tuple[Type[Exception], ...]]&#39;=()</span>
<span class="gd">-    ) -&gt;&#39;Union[Future[List], Future[Dict]]&#39;:</span>
<span class="gi">+def multi(</span>
<span class="gi">+    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="gi">+    quiet_exceptions: &quot;Union[Type[Exception], Tuple[Type[Exception], ...]]&quot; = (),</span>
<span class="gi">+) -&gt; &quot;Union[Future[List], Future[Dict]]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Runs multiple asynchronous operations in parallel.

<span class="w"> </span>    ``children`` may either be a list or a dict whose values are
<span class="gu">@@ -325,15 +482,16 @@ def multi(children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="w"> </span>       other than ``YieldPoint`` and `.Future`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return multi_future(children, quiet_exceptions=quiet_exceptions)</span>


<span class="w"> </span>Multi = multi


<span class="gd">-def multi_future(children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="gd">-    quiet_exceptions: &#39;Union[Type[Exception], Tuple[Type[Exception], ...]]&#39;=()</span>
<span class="gd">-    ) -&gt;&#39;Union[Future[List], Future[Dict]]&#39;:</span>
<span class="gi">+def multi_future(</span>
<span class="gi">+    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="gi">+    quiet_exceptions: &quot;Union[Type[Exception], Tuple[Type[Exception], ...]]&quot; = (),</span>
<span class="gi">+) -&gt; &quot;Union[Future[List], Future[Dict]]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wait for multiple asynchronous futures in parallel.

<span class="w"> </span>    Since Tornado 6.0, this function is exactly the same as `multi`.
<span class="gu">@@ -348,10 +506,52 @@ def multi_future(children: Union[List[_Yieldable], Dict[Any, _Yieldable]],</span>
<span class="w"> </span>    .. deprecated:: 4.3
<span class="w"> </span>       Use `multi` instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def maybe_future(x: Any) -&gt;Future:</span>
<span class="gi">+    if isinstance(children, dict):</span>
<span class="gi">+        keys = list(children.keys())  # type: Optional[List]</span>
<span class="gi">+        children_seq = children.values()  # type: Iterable</span>
<span class="gi">+    else:</span>
<span class="gi">+        keys = None</span>
<span class="gi">+        children_seq = children</span>
<span class="gi">+    children_futs = list(map(convert_yielded, children_seq))</span>
<span class="gi">+    assert all(is_future(i) or isinstance(i, _NullFuture) for i in children_futs)</span>
<span class="gi">+    unfinished_children = set(children_futs)</span>
<span class="gi">+</span>
<span class="gi">+    future = _create_future()</span>
<span class="gi">+    if not children_futs:</span>
<span class="gi">+        future_set_result_unless_cancelled(future, {} if keys is not None else [])</span>
<span class="gi">+</span>
<span class="gi">+    def callback(fut: Future) -&gt; None:</span>
<span class="gi">+        unfinished_children.remove(fut)</span>
<span class="gi">+        if not unfinished_children:</span>
<span class="gi">+            result_list = []</span>
<span class="gi">+            for f in children_futs:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    result_list.append(f.result())</span>
<span class="gi">+                except Exception as e:</span>
<span class="gi">+                    if future.done():</span>
<span class="gi">+                        if not isinstance(e, quiet_exceptions):</span>
<span class="gi">+                            app_log.error(</span>
<span class="gi">+                                &quot;Multiple exceptions in yield list&quot;, exc_info=True</span>
<span class="gi">+                            )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        future_set_exc_info(future, sys.exc_info())</span>
<span class="gi">+            if not future.done():</span>
<span class="gi">+                if keys is not None:</span>
<span class="gi">+                    future_set_result_unless_cancelled(</span>
<span class="gi">+                        future, dict(zip(keys, result_list))</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    future_set_result_unless_cancelled(future, result_list)</span>
<span class="gi">+</span>
<span class="gi">+    listening = set()  # type: Set[Future]</span>
<span class="gi">+    for f in children_futs:</span>
<span class="gi">+        if f not in listening:</span>
<span class="gi">+            listening.add(f)</span>
<span class="gi">+            future_add_done_callback(f, callback)</span>
<span class="gi">+    return future</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def maybe_future(x: Any) -&gt; Future:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts ``x`` into a `.Future`.

<span class="w"> </span>    If ``x`` is already a `.Future`, it is simply returned; otherwise
<span class="gu">@@ -364,12 +564,19 @@ def maybe_future(x: Any) -&gt;Future:</span>
<span class="w"> </span>       Instead of `maybe_future`, check for the non-future result types
<span class="w"> </span>       you expect (often just ``None``), and ``yield`` anything unknown.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def with_timeout(timeout: Union[float, datetime.timedelta], future:</span>
<span class="gd">-    _Yieldable, quiet_exceptions:</span>
<span class="gd">-    &#39;Union[Type[Exception], Tuple[Type[Exception], ...]]&#39;=()) -&gt;Future:</span>
<span class="gi">+    if is_future(x):</span>
<span class="gi">+        return x</span>
<span class="gi">+    else:</span>
<span class="gi">+        fut = _create_future()</span>
<span class="gi">+        fut.set_result(x)</span>
<span class="gi">+        return fut</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def with_timeout(</span>
<span class="gi">+    timeout: Union[float, datetime.timedelta],</span>
<span class="gi">+    future: _Yieldable,</span>
<span class="gi">+    quiet_exceptions: &quot;Union[Type[Exception], Tuple[Type[Exception], ...]]&quot; = (),</span>
<span class="gi">+) -&gt; Future:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wraps a `.Future` (or other yieldable object) in a timeout.

<span class="w"> </span>    Raises `tornado.util.TimeoutError` if the input future does not
<span class="gu">@@ -402,10 +609,51 @@ def with_timeout(timeout: Union[float, datetime.timedelta], future:</span>
<span class="w"> </span>       ``tornado.util.TimeoutError`` is now an alias to ``asyncio.TimeoutError``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def sleep(duration: float) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    # It&#39;s tempting to optimize this by cancelling the input future on timeout</span>
<span class="gi">+    # instead of creating a new one, but A) we can&#39;t know if we are the only</span>
<span class="gi">+    # one waiting on the input future, so cancelling it might disrupt other</span>
<span class="gi">+    # callers and B) concurrent futures can only be cancelled while they are</span>
<span class="gi">+    # in the queue, so cancellation cannot reliably bound our waiting time.</span>
<span class="gi">+    future_converted = convert_yielded(future)</span>
<span class="gi">+    result = _create_future()</span>
<span class="gi">+    chain_future(future_converted, result)</span>
<span class="gi">+    io_loop = IOLoop.current()</span>
<span class="gi">+</span>
<span class="gi">+    def error_callback(future: Future) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            future.result()</span>
<span class="gi">+        except asyncio.CancelledError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            if not isinstance(e, quiet_exceptions):</span>
<span class="gi">+                app_log.error(</span>
<span class="gi">+                    &quot;Exception in Future %r after timeout&quot;, future, exc_info=True</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def timeout_callback() -&gt; None:</span>
<span class="gi">+        if not result.done():</span>
<span class="gi">+            result.set_exception(TimeoutError(&quot;Timeout&quot;))</span>
<span class="gi">+        # In case the wrapped future goes on to fail, log it.</span>
<span class="gi">+        future_add_done_callback(future_converted, error_callback)</span>
<span class="gi">+</span>
<span class="gi">+    timeout_handle = io_loop.add_timeout(timeout, timeout_callback)</span>
<span class="gi">+    if isinstance(future_converted, Future):</span>
<span class="gi">+        # We know this future will resolve on the IOLoop, so we don&#39;t</span>
<span class="gi">+        # need the extra thread-safety of IOLoop.add_future (and we also</span>
<span class="gi">+        # don&#39;t care about StackContext here.</span>
<span class="gi">+        future_add_done_callback(</span>
<span class="gi">+            future_converted, lambda future: io_loop.remove_timeout(timeout_handle)</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        # concurrent.futures.Futures may resolve on any thread, so we</span>
<span class="gi">+        # need to route them back to the IOLoop.</span>
<span class="gi">+        io_loop.add_future(</span>
<span class="gi">+            future_converted, lambda future: io_loop.remove_timeout(timeout_handle)</span>
<span class="gi">+        )</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sleep(duration: float) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a `.Future` that resolves after the given number of seconds.

<span class="w"> </span>    When used with ``yield`` in a coroutine, this is a non-blocking
<span class="gu">@@ -419,7 +667,11 @@ def sleep(duration: float) -&gt;&#39;Future[None]&#39;:</span>

<span class="w"> </span>    .. versionadded:: 4.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f = _create_future()</span>
<span class="gi">+    IOLoop.current().call_later(</span>
<span class="gi">+        duration, lambda: future_set_result_unless_cancelled(f, None)</span>
<span class="gi">+    )</span>
<span class="gi">+    return f</span>


<span class="w"> </span>class _NullFuture(object):
<span class="gu">@@ -435,8 +687,18 @@ class _NullFuture(object):</span>
<span class="w"> </span>    with it.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def result(self) -&gt; None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def done(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="gi">+# _null_future is used as a dummy value in the coroutine runner. It differs</span>
<span class="gi">+# from moment in that moment always adds a delay of one IOLoop iteration</span>
<span class="gi">+# while _null_future is processed as soon as possible.</span>
<span class="w"> </span>_null_future = typing.cast(Future, _NullFuture())
<span class="gi">+</span>
<span class="w"> </span>moment = typing.cast(Future, _NullFuture())
<span class="w"> </span>moment.__doc__ = &quot;&quot;&quot;A special object which may be yielded to allow the IOLoop to run for
<span class="w"> </span>one iteration.
<span class="gu">@@ -466,28 +728,131 @@ class Runner(object):</span>
<span class="w"> </span>    `.Future`)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, ctx_run: Callable, gen:</span>
<span class="gd">-        &#39;Generator[_Yieldable, Any, _T]&#39;, result_future: &#39;Future[_T]&#39;,</span>
<span class="gd">-        first_yielded: _Yieldable) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ctx_run: Callable,</span>
<span class="gi">+        gen: &quot;Generator[_Yieldable, Any, _T]&quot;,</span>
<span class="gi">+        result_future: &quot;Future[_T]&quot;,</span>
<span class="gi">+        first_yielded: _Yieldable,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.ctx_run = ctx_run
<span class="w"> </span>        self.gen = gen
<span class="w"> </span>        self.result_future = result_future
<span class="gd">-        self.future = _null_future</span>
<span class="gi">+        self.future = _null_future  # type: Union[None, Future]</span>
<span class="w"> </span>        self.running = False
<span class="w"> </span>        self.finished = False
<span class="w"> </span>        self.io_loop = IOLoop.current()
<span class="w"> </span>        if self.ctx_run(self.handle_yield, first_yielded):
<span class="gd">-            gen = result_future = first_yielded = None</span>
<span class="gi">+            gen = result_future = first_yielded = None  # type: ignore</span>
<span class="w"> </span>            self.ctx_run(self.run)

<span class="gd">-    def run(self) -&gt;None:</span>
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts or resumes the generator, running until it reaches a
<span class="w"> </span>        yield point that is not ready.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.running or self.finished:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.running = True</span>
<span class="gi">+            while True:</span>
<span class="gi">+                future = self.future</span>
<span class="gi">+                if future is None:</span>
<span class="gi">+                    raise Exception(&quot;No pending future&quot;)</span>
<span class="gi">+                if not future.done():</span>
<span class="gi">+                    return</span>
<span class="gi">+                self.future = None</span>
<span class="gi">+                try:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = future.result()</span>
<span class="gi">+                    except Exception as e:</span>
<span class="gi">+                        # Save the exception for later. It&#39;s important that</span>
<span class="gi">+                        # gen.throw() not be called inside this try/except block</span>
<span class="gi">+                        # because that makes sys.exc_info behave unexpectedly.</span>
<span class="gi">+                        exc: Optional[Exception] = e</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        exc = None</span>
<span class="gi">+                    finally:</span>
<span class="gi">+                        future = None</span>
<span class="gi">+</span>
<span class="gi">+                    if exc is not None:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            yielded = self.gen.throw(exc)</span>
<span class="gi">+                        finally:</span>
<span class="gi">+                            # Break up a circular reference for faster GC on</span>
<span class="gi">+                            # CPython.</span>
<span class="gi">+                            del exc</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yielded = self.gen.send(value)</span>
<span class="gi">+</span>
<span class="gi">+                except (StopIteration, Return) as e:</span>
<span class="gi">+                    self.finished = True</span>
<span class="gi">+                    self.future = _null_future</span>
<span class="gi">+                    future_set_result_unless_cancelled(</span>
<span class="gi">+                        self.result_future, _value_from_stopiteration(e)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.result_future = None  # type: ignore</span>
<span class="gi">+                    return</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    self.finished = True</span>
<span class="gi">+                    self.future = _null_future</span>
<span class="gi">+                    future_set_exc_info(self.result_future, sys.exc_info())</span>
<span class="gi">+                    self.result_future = None  # type: ignore</span>
<span class="gi">+                    return</span>
<span class="gi">+                if not self.handle_yield(yielded):</span>
<span class="gi">+                    return</span>
<span class="gi">+                yielded = None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.running = False</span>
<span class="gi">+</span>
<span class="gi">+    def handle_yield(self, yielded: _Yieldable) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.future = convert_yielded(yielded)</span>
<span class="gi">+        except BadYieldError:</span>
<span class="gi">+            self.future = Future()</span>
<span class="gi">+            future_set_exc_info(self.future, sys.exc_info())</span>
<span class="gi">+</span>
<span class="gi">+        if self.future is moment:</span>
<span class="gi">+            self.io_loop.add_callback(self.ctx_run, self.run)</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif self.future is None:</span>
<span class="gi">+            raise Exception(&quot;no pending future&quot;)</span>
<span class="gi">+        elif not self.future.done():</span>
<span class="gi">+</span>
<span class="gi">+            def inner(f: Any) -&gt; None:</span>
<span class="gi">+                # Break a reference cycle to speed GC.</span>
<span class="gi">+                f = None  # noqa: F841</span>
<span class="gi">+                self.ctx_run(self.run)</span>
<span class="gi">+</span>
<span class="gi">+            self.io_loop.add_future(self.future, inner)</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def handle_exception(</span>
<span class="gi">+        self, typ: Type[Exception], value: Exception, tb: types.TracebackType</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if not self.running and not self.finished:</span>
<span class="gi">+            self.future = Future()</span>
<span class="gi">+            future_set_exc_info(self.future, (typ, value, tb))</span>
<span class="gi">+            self.ctx_run(self.run)</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>


<span class="gd">-def convert_yielded(yielded: _Yieldable) -&gt;Future:</span>
<span class="gi">+def _wrap_awaitable(awaitable: Awaitable) -&gt; Future:</span>
<span class="gi">+    # Convert Awaitables into Futures.</span>
<span class="gi">+    # Note that we use ensure_future, which handles both awaitables</span>
<span class="gi">+    # and coroutines, rather than create_task, which only accepts</span>
<span class="gi">+    # coroutines. (ensure_future calls create_task if given a coroutine)</span>
<span class="gi">+    fut = asyncio.ensure_future(awaitable)</span>
<span class="gi">+    # See comments on IOLoop._pending_tasks.</span>
<span class="gi">+    loop = IOLoop.current()</span>
<span class="gi">+    loop._register_task(fut)</span>
<span class="gi">+    fut.add_done_callback(lambda f: loop._unregister_task(f))</span>
<span class="gi">+    return fut</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_yielded(yielded: _Yieldable) -&gt; Future:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a yielded object into a `.Future`.

<span class="w"> </span>    The default implementation accepts lists, dictionaries, and
<span class="gu">@@ -504,7 +869,18 @@ def convert_yielded(yielded: _Yieldable) -&gt;Future:</span>
<span class="w"> </span>    .. versionadded:: 4.1

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if yielded is None or yielded is moment:</span>
<span class="gi">+        return moment</span>
<span class="gi">+    elif yielded is _null_future:</span>
<span class="gi">+        return _null_future</span>
<span class="gi">+    elif isinstance(yielded, (list, dict)):</span>
<span class="gi">+        return multi(yielded)  # type: ignore</span>
<span class="gi">+    elif is_future(yielded):</span>
<span class="gi">+        return typing.cast(Future, yielded)</span>
<span class="gi">+    elif isawaitable(yielded):</span>
<span class="gi">+        return _wrap_awaitable(yielded)  # type: ignore</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise BadYieldError(&quot;yielded unknown object %r&quot; % (yielded,))</span>


<span class="w"> </span>convert_yielded = singledispatch(convert_yielded)
<span class="gh">diff --git a/tornado/http1connection.py b/tornado/http1connection.py</span>
<span class="gh">index aa35011f..1a23f5c7 100644</span>
<span class="gd">--- a/tornado/http1connection.py</span>
<span class="gi">+++ b/tornado/http1connection.py</span>
<span class="gu">@@ -1,25 +1,48 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2014 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Client and server implementations of HTTP/1.x.

<span class="w"> </span>.. versionadded:: 4.0
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import logging
<span class="w"> </span>import re
<span class="w"> </span>import types
<span class="gd">-from tornado.concurrent import Future, future_add_done_callback, future_set_result_unless_cancelled</span>
<span class="gi">+</span>
<span class="gi">+from tornado.concurrent import (</span>
<span class="gi">+    Future,</span>
<span class="gi">+    future_add_done_callback,</span>
<span class="gi">+    future_set_result_unless_cancelled,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.escape import native_str, utf8
<span class="w"> </span>from tornado import gen
<span class="w"> </span>from tornado import httputil
<span class="w"> </span>from tornado import iostream
<span class="w"> </span>from tornado.log import gen_log, app_log
<span class="w"> </span>from tornado.util import GzipDecompressor
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import cast, Optional, Type, Awaitable, Callable, Union, Tuple
<span class="gd">-CR_OR_LF_RE = re.compile(b&#39;\r|\n&#39;)</span>

<span class="gi">+CR_OR_LF_RE = re.compile(b&quot;\r|\n&quot;)</span>

<span class="gd">-class _QuietException(Exception):</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+class _QuietException(Exception):</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        pass


<span class="gu">@@ -29,27 +52,37 @@ class _ExceptionLoggingContext(object):</span>
<span class="w"> </span>    converted to _QuietException
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, logger: logging.Logger) -&gt;None:</span>
<span class="gi">+    def __init__(self, logger: logging.Logger) -&gt; None:</span>
<span class="w"> </span>        self.logger = logger

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def __exit__(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], tb: types.TracebackType) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: types.TracebackType,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if value is not None:
<span class="w"> </span>            assert typ is not None
<span class="gd">-            self.logger.error(&#39;Uncaught exception&#39;, exc_info=(typ, value, tb))</span>
<span class="gi">+            self.logger.error(&quot;Uncaught exception&quot;, exc_info=(typ, value, tb))</span>
<span class="w"> </span>            raise _QuietException


<span class="w"> </span>class HTTP1ConnectionParameters(object):
<span class="w"> </span>    &quot;&quot;&quot;Parameters for `.HTTP1Connection` and `.HTTP1ServerConnection`.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, no_keep_alive: bool=False, chunk_size: Optional[int]</span>
<span class="gd">-        =None, max_header_size: Optional[int]=None, header_timeout:</span>
<span class="gd">-        Optional[float]=None, max_body_size: Optional[int]=None,</span>
<span class="gd">-        body_timeout: Optional[float]=None, decompress: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        no_keep_alive: bool = False,</span>
<span class="gi">+        chunk_size: Optional[int] = None,</span>
<span class="gi">+        max_header_size: Optional[int] = None,</span>
<span class="gi">+        header_timeout: Optional[float] = None,</span>
<span class="gi">+        max_body_size: Optional[int] = None,</span>
<span class="gi">+        body_timeout: Optional[float] = None,</span>
<span class="gi">+        decompress: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :arg bool no_keep_alive: If true, always close the connection after
<span class="w"> </span>            one request.
<span class="gu">@@ -77,9 +110,13 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>    for servers.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream: iostream.IOStream, is_client: bool, params:</span>
<span class="gd">-        Optional[HTTP1ConnectionParameters]=None, context: Optional[object]</span>
<span class="gd">-        =None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream: iostream.IOStream,</span>
<span class="gi">+        is_client: bool,</span>
<span class="gi">+        params: Optional[HTTP1ConnectionParameters] = None,</span>
<span class="gi">+        context: Optional[object] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :arg stream: an `.IOStream`
<span class="w"> </span>        :arg bool is_client: client or server
<span class="gu">@@ -94,23 +131,43 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        self.params = params
<span class="w"> </span>        self.context = context
<span class="w"> </span>        self.no_keep_alive = params.no_keep_alive
<span class="gd">-        self._max_body_size = (self.params.max_body_size if self.params.</span>
<span class="gd">-            max_body_size is not None else self.stream.max_buffer_size)</span>
<span class="gi">+        # The body limits can be altered by the delegate, so save them</span>
<span class="gi">+        # here instead of just referencing self.params later.</span>
<span class="gi">+        self._max_body_size = (</span>
<span class="gi">+            self.params.max_body_size</span>
<span class="gi">+            if self.params.max_body_size is not None</span>
<span class="gi">+            else self.stream.max_buffer_size</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._body_timeout = self.params.body_timeout
<span class="gi">+        # _write_finished is set to True when finish() has been called,</span>
<span class="gi">+        # i.e. there will be no more data sent.  Data may still be in the</span>
<span class="gi">+        # stream&#39;s write buffer.</span>
<span class="w"> </span>        self._write_finished = False
<span class="gi">+        # True when we have read the entire incoming body.</span>
<span class="w"> </span>        self._read_finished = False
<span class="gd">-        self._finish_future = Future()</span>
<span class="gi">+        # _finish_future resolves when all data has been written and flushed</span>
<span class="gi">+        # to the IOStream.</span>
<span class="gi">+        self._finish_future = Future()  # type: Future[None]</span>
<span class="gi">+        # If true, the connection should be closed after this request</span>
<span class="gi">+        # (after the response has been written in the server side,</span>
<span class="gi">+        # and after it has been read in the client)</span>
<span class="w"> </span>        self._disconnect_on_finish = False
<span class="w"> </span>        self._clear_callbacks()
<span class="gd">-        self._request_start_line = None</span>
<span class="gd">-        self._response_start_line = None</span>
<span class="gd">-        self._request_headers = None</span>
<span class="gi">+        # Save the start lines after we read or write them; they</span>
<span class="gi">+        # affect later processing (e.g. 304 responses and HEAD methods</span>
<span class="gi">+        # have content-length but no bodies)</span>
<span class="gi">+        self._request_start_line = None  # type: Optional[httputil.RequestStartLine]</span>
<span class="gi">+        self._response_start_line = None  # type: Optional[httputil.ResponseStartLine]</span>
<span class="gi">+        self._request_headers = None  # type: Optional[httputil.HTTPHeaders]</span>
<span class="gi">+        # True if we are writing output with chunked encoding.</span>
<span class="w"> </span>        self._chunking_output = False
<span class="gd">-        self._expected_content_remaining = None</span>
<span class="gd">-        self._pending_write = None</span>
<span class="gi">+        # While reading a body with a content-length, this is the</span>
<span class="gi">+        # amount left to read.</span>
<span class="gi">+        self._expected_content_remaining = None  # type: Optional[int]</span>
<span class="gi">+        # A Future for our outgoing writes, returned by IOStream.write.</span>
<span class="gi">+        self._pending_write = None  # type: Optional[Future[None]]</span>

<span class="gd">-    def read_response(self, delegate: httputil.HTTPMessageDelegate</span>
<span class="gd">-        ) -&gt;Awaitable[bool]:</span>
<span class="gi">+    def read_response(self, delegate: httputil.HTTPMessageDelegate) -&gt; Awaitable[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read a single HTTP response.

<span class="w"> </span>        Typical client-mode usage is to write a request using `write_headers`,
<span class="gu">@@ -121,18 +178,145 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        Returns a `.Future` that resolves to a bool after the full response has
<span class="w"> </span>        been read. The result is true if the stream is still open.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _clear_callbacks(self) -&gt;None:</span>
<span class="gi">+        if self.params.decompress:</span>
<span class="gi">+            delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)</span>
<span class="gi">+        return self._read_message(delegate)</span>
<span class="gi">+</span>
<span class="gi">+    async def _read_message(self, delegate: httputil.HTTPMessageDelegate) -&gt; bool:</span>
<span class="gi">+        need_delegate_close = False</span>
<span class="gi">+        try:</span>
<span class="gi">+            header_future = self.stream.read_until_regex(</span>
<span class="gi">+                b&quot;\r?\n\r?\n&quot;, max_bytes=self.params.max_header_size</span>
<span class="gi">+            )</span>
<span class="gi">+            if self.params.header_timeout is None:</span>
<span class="gi">+                header_data = await header_future</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    header_data = await gen.with_timeout(</span>
<span class="gi">+                        self.stream.io_loop.time() + self.params.header_timeout,</span>
<span class="gi">+                        header_future,</span>
<span class="gi">+                        quiet_exceptions=iostream.StreamClosedError,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except gen.TimeoutError:</span>
<span class="gi">+                    self.close()</span>
<span class="gi">+                    return False</span>
<span class="gi">+            start_line_str, headers = self._parse_headers(header_data)</span>
<span class="gi">+            if self.is_client:</span>
<span class="gi">+                resp_start_line = httputil.parse_response_start_line(start_line_str)</span>
<span class="gi">+                self._response_start_line = resp_start_line</span>
<span class="gi">+                start_line = (</span>
<span class="gi">+                    resp_start_line</span>
<span class="gi">+                )  # type: Union[httputil.RequestStartLine, httputil.ResponseStartLine]</span>
<span class="gi">+                # TODO: this will need to change to support client-side keepalive</span>
<span class="gi">+                self._disconnect_on_finish = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                req_start_line = httputil.parse_request_start_line(start_line_str)</span>
<span class="gi">+                self._request_start_line = req_start_line</span>
<span class="gi">+                self._request_headers = headers</span>
<span class="gi">+                start_line = req_start_line</span>
<span class="gi">+                self._disconnect_on_finish = not self._can_keep_alive(</span>
<span class="gi">+                    req_start_line, headers</span>
<span class="gi">+                )</span>
<span class="gi">+            need_delegate_close = True</span>
<span class="gi">+            with _ExceptionLoggingContext(app_log):</span>
<span class="gi">+                header_recv_future = delegate.headers_received(start_line, headers)</span>
<span class="gi">+                if header_recv_future is not None:</span>
<span class="gi">+                    await header_recv_future</span>
<span class="gi">+            if self.stream is None:</span>
<span class="gi">+                # We&#39;ve been detached.</span>
<span class="gi">+                need_delegate_close = False</span>
<span class="gi">+                return False</span>
<span class="gi">+            skip_body = False</span>
<span class="gi">+            if self.is_client:</span>
<span class="gi">+                assert isinstance(start_line, httputil.ResponseStartLine)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    self._request_start_line is not None</span>
<span class="gi">+                    and self._request_start_line.method == &quot;HEAD&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    skip_body = True</span>
<span class="gi">+                code = start_line.code</span>
<span class="gi">+                if code == 304:</span>
<span class="gi">+                    # 304 responses may include the content-length header</span>
<span class="gi">+                    # but do not actually have a body.</span>
<span class="gi">+                    # http://tools.ietf.org/html/rfc7230#section-3.3</span>
<span class="gi">+                    skip_body = True</span>
<span class="gi">+                if 100 &lt;= code &lt; 200:</span>
<span class="gi">+                    # 1xx responses should never indicate the presence of</span>
<span class="gi">+                    # a body.</span>
<span class="gi">+                    if &quot;Content-Length&quot; in headers or &quot;Transfer-Encoding&quot; in headers:</span>
<span class="gi">+                        raise httputil.HTTPInputError(</span>
<span class="gi">+                            &quot;Response code %d cannot have body&quot; % code</span>
<span class="gi">+                        )</span>
<span class="gi">+                    # TODO: client delegates will get headers_received twice</span>
<span class="gi">+                    # in the case of a 100-continue.  Document or change?</span>
<span class="gi">+                    await self._read_message(delegate)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if headers.get(&quot;Expect&quot;) == &quot;100-continue&quot; and not self._write_finished:</span>
<span class="gi">+                    self.stream.write(b&quot;HTTP/1.1 100 (Continue)\r\n\r\n&quot;)</span>
<span class="gi">+            if not skip_body:</span>
<span class="gi">+                body_future = self._read_body(</span>
<span class="gi">+                    resp_start_line.code if self.is_client else 0, headers, delegate</span>
<span class="gi">+                )</span>
<span class="gi">+                if body_future is not None:</span>
<span class="gi">+                    if self._body_timeout is None:</span>
<span class="gi">+                        await body_future</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            await gen.with_timeout(</span>
<span class="gi">+                                self.stream.io_loop.time() + self._body_timeout,</span>
<span class="gi">+                                body_future,</span>
<span class="gi">+                                quiet_exceptions=iostream.StreamClosedError,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        except gen.TimeoutError:</span>
<span class="gi">+                            gen_log.info(&quot;Timeout reading body from %s&quot;, self.context)</span>
<span class="gi">+                            self.stream.close()</span>
<span class="gi">+                            return False</span>
<span class="gi">+            self._read_finished = True</span>
<span class="gi">+            if not self._write_finished or self.is_client:</span>
<span class="gi">+                need_delegate_close = False</span>
<span class="gi">+                with _ExceptionLoggingContext(app_log):</span>
<span class="gi">+                    delegate.finish()</span>
<span class="gi">+            # If we&#39;re waiting for the application to produce an asynchronous</span>
<span class="gi">+            # response, and we&#39;re not detached, register a close callback</span>
<span class="gi">+            # on the stream (we didn&#39;t need one while we were reading)</span>
<span class="gi">+            if (</span>
<span class="gi">+                not self._finish_future.done()</span>
<span class="gi">+                and self.stream is not None</span>
<span class="gi">+                and not self.stream.closed()</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.stream.set_close_callback(self._on_connection_close)</span>
<span class="gi">+                await self._finish_future</span>
<span class="gi">+            if self.is_client and self._disconnect_on_finish:</span>
<span class="gi">+                self.close()</span>
<span class="gi">+            if self.stream is None:</span>
<span class="gi">+                return False</span>
<span class="gi">+        except httputil.HTTPInputError as e:</span>
<span class="gi">+            gen_log.info(&quot;Malformed HTTP message from %s: %s&quot;, self.context, e)</span>
<span class="gi">+            if not self.is_client:</span>
<span class="gi">+                await self.stream.write(b&quot;HTTP/1.1 400 Bad Request\r\n\r\n&quot;)</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            return False</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if need_delegate_close:</span>
<span class="gi">+                with _ExceptionLoggingContext(app_log):</span>
<span class="gi">+                    delegate.on_connection_close()</span>
<span class="gi">+            header_future = None  # type: ignore</span>
<span class="gi">+            self._clear_callbacks()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _clear_callbacks(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clears the callback attributes.

<span class="w"> </span>        This allows the request handler to be garbage collected more
<span class="w"> </span>        quickly in CPython by breaking up reference cycles.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._write_callback = None</span>
<span class="gi">+        self._write_future = None  # type: Optional[Future[None]]</span>
<span class="gi">+        self._close_callback = None  # type: Optional[Callable[[], None]]</span>
<span class="gi">+        if self.stream is not None:</span>
<span class="gi">+            self.stream.set_close_callback(None)</span>

<span class="gd">-    def set_close_callback(self, callback: Optional[Callable[[], None]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def set_close_callback(self, callback: Optional[Callable[[], None]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets a callback that will be run when the connection is closed.

<span class="w"> </span>        Note that this callback is slightly different from
<span class="gu">@@ -144,9 +328,28 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        after sending its request but before receiving all the
<span class="w"> </span>        response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close_callback = callback</span>
<span class="gi">+</span>
<span class="gi">+    def _on_connection_close(self) -&gt; None:</span>
<span class="gi">+        # Note that this callback is only registered on the IOStream</span>
<span class="gi">+        # when we have finished reading the request and are waiting for</span>
<span class="gi">+        # the application to produce its response.</span>
<span class="gi">+        if self._close_callback is not None:</span>
<span class="gi">+            callback = self._close_callback</span>
<span class="gi">+            self._close_callback = None</span>
<span class="gi">+            callback()</span>
<span class="gi">+        if not self._finish_future.done():</span>
<span class="gi">+            future_set_result_unless_cancelled(self._finish_future, None)</span>
<span class="gi">+        self._clear_callbacks()</span>

<span class="gd">-    def detach(self) -&gt;iostream.IOStream:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        if self.stream is not None:</span>
<span class="gi">+            self.stream.close()</span>
<span class="gi">+        self._clear_callbacks()</span>
<span class="gi">+        if not self._finish_future.done():</span>
<span class="gi">+            future_set_result_unless_cancelled(self._finish_future, None)</span>
<span class="gi">+</span>
<span class="gi">+    def detach(self) -&gt; iostream.IOStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Take control of the underlying stream.

<span class="w"> </span>        Returns the underlying `.IOStream` object and stops all further
<span class="gu">@@ -154,58 +357,419 @@ class HTTP1Connection(httputil.HTTPConnection):</span>
<span class="w"> </span>        `.HTTPMessageDelegate.headers_received`.  Intended for implementing
<span class="w"> </span>        protocols like websockets that tunnel over an HTTP handshake.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._clear_callbacks()</span>
<span class="gi">+        stream = self.stream</span>
<span class="gi">+        self.stream = None  # type: ignore</span>
<span class="gi">+        if not self._finish_future.done():</span>
<span class="gi">+            future_set_result_unless_cancelled(self._finish_future, None)</span>
<span class="gi">+        return stream</span>

<span class="gd">-    def set_body_timeout(self, timeout: float) -&gt;None:</span>
<span class="gi">+    def set_body_timeout(self, timeout: float) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the body timeout for a single request.

<span class="w"> </span>        Overrides the value from `.HTTP1ConnectionParameters`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._body_timeout = timeout</span>

<span class="gd">-    def set_max_body_size(self, max_body_size: int) -&gt;None:</span>
<span class="gi">+    def set_max_body_size(self, max_body_size: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the body size limit for a single request.

<span class="w"> </span>        Overrides the value from `.HTTP1ConnectionParameters`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_headers(self, start_line: Union[httputil.RequestStartLine,</span>
<span class="gd">-        httputil.ResponseStartLine], headers: httputil.HTTPHeaders, chunk:</span>
<span class="gd">-        Optional[bytes]=None) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+        self._max_body_size = max_body_size</span>
<span class="gi">+</span>
<span class="gi">+    def write_headers(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+        chunk: Optional[bytes] = None,</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Implements `.HTTPConnection.write_headers`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write(self, chunk: bytes) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        if self.is_client:</span>
<span class="gi">+            assert isinstance(start_line, httputil.RequestStartLine)</span>
<span class="gi">+            self._request_start_line = start_line</span>
<span class="gi">+            lines.append(utf8(&quot;%s %s HTTP/1.1&quot; % (start_line[0], start_line[1])))</span>
<span class="gi">+            # Client requests with a non-empty body must have either a</span>
<span class="gi">+            # Content-Length or a Transfer-Encoding. If Content-Length is not</span>
<span class="gi">+            # present we&#39;ll add our Transfer-Encoding below.</span>
<span class="gi">+            self._chunking_output = (</span>
<span class="gi">+                start_line.method in (&quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;)</span>
<span class="gi">+                and &quot;Content-Length&quot; not in headers</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert isinstance(start_line, httputil.ResponseStartLine)</span>
<span class="gi">+            assert self._request_start_line is not None</span>
<span class="gi">+            assert self._request_headers is not None</span>
<span class="gi">+            self._response_start_line = start_line</span>
<span class="gi">+            lines.append(utf8(&quot;HTTP/1.1 %d %s&quot; % (start_line[1], start_line[2])))</span>
<span class="gi">+            self._chunking_output = (</span>
<span class="gi">+                # TODO: should this use</span>
<span class="gi">+                # self._request_start_line.version or</span>
<span class="gi">+                # start_line.version?</span>
<span class="gi">+                self._request_start_line.version == &quot;HTTP/1.1&quot;</span>
<span class="gi">+                # Omit payload header field for HEAD request.</span>
<span class="gi">+                and self._request_start_line.method != &quot;HEAD&quot;</span>
<span class="gi">+                # 1xx, 204 and 304 responses have no body (not even a zero-length</span>
<span class="gi">+                # body), and so should not have either Content-Length or</span>
<span class="gi">+                # Transfer-Encoding headers.</span>
<span class="gi">+                and start_line.code not in (204, 304)</span>
<span class="gi">+                and (start_line.code &lt; 100 or start_line.code &gt;= 200)</span>
<span class="gi">+                # No need to chunk the output if a Content-Length is specified.</span>
<span class="gi">+                and &quot;Content-Length&quot; not in headers</span>
<span class="gi">+            )</span>
<span class="gi">+            # If connection to a 1.1 client will be closed, inform client</span>
<span class="gi">+            if (</span>
<span class="gi">+                self._request_start_line.version == &quot;HTTP/1.1&quot;</span>
<span class="gi">+                and self._disconnect_on_finish</span>
<span class="gi">+            ):</span>
<span class="gi">+                headers[&quot;Connection&quot;] = &quot;close&quot;</span>
<span class="gi">+            # If a 1.0 client asked for keep-alive, add the header.</span>
<span class="gi">+            if (</span>
<span class="gi">+                self._request_start_line.version == &quot;HTTP/1.0&quot;</span>
<span class="gi">+                and self._request_headers.get(&quot;Connection&quot;, &quot;&quot;).lower() == &quot;keep-alive&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                headers[&quot;Connection&quot;] = &quot;Keep-Alive&quot;</span>
<span class="gi">+        if self._chunking_output:</span>
<span class="gi">+            headers[&quot;Transfer-Encoding&quot;] = &quot;chunked&quot;</span>
<span class="gi">+        if not self.is_client and (</span>
<span class="gi">+            self._request_start_line.method == &quot;HEAD&quot;</span>
<span class="gi">+            or cast(httputil.ResponseStartLine, start_line).code == 304</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._expected_content_remaining = 0</span>
<span class="gi">+        elif &quot;Content-Length&quot; in headers:</span>
<span class="gi">+            self._expected_content_remaining = parse_int(headers[&quot;Content-Length&quot;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._expected_content_remaining = None</span>
<span class="gi">+        # TODO: headers are supposed to be of type str, but we still have some</span>
<span class="gi">+        # cases that let bytes slip through. Remove these native_str calls when those</span>
<span class="gi">+        # are fixed.</span>
<span class="gi">+        header_lines = (</span>
<span class="gi">+            native_str(n) + &quot;: &quot; + native_str(v) for n, v in headers.get_all()</span>
<span class="gi">+        )</span>
<span class="gi">+        lines.extend(line.encode(&quot;latin1&quot;) for line in header_lines)</span>
<span class="gi">+        for line in lines:</span>
<span class="gi">+            if CR_OR_LF_RE.search(line):</span>
<span class="gi">+                raise ValueError(&quot;Illegal characters (CR or LF) in header: %r&quot; % line)</span>
<span class="gi">+        future = None</span>
<span class="gi">+        if self.stream.closed():</span>
<span class="gi">+            future = self._write_future = Future()</span>
<span class="gi">+            future.set_exception(iostream.StreamClosedError())</span>
<span class="gi">+            future.exception()</span>
<span class="gi">+        else:</span>
<span class="gi">+            future = self._write_future = Future()</span>
<span class="gi">+            data = b&quot;\r\n&quot;.join(lines) + b&quot;\r\n\r\n&quot;</span>
<span class="gi">+            if chunk:</span>
<span class="gi">+                data += self._format_chunk(chunk)</span>
<span class="gi">+            self._pending_write = self.stream.write(data)</span>
<span class="gi">+            future_add_done_callback(self._pending_write, self._on_write_complete)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def _format_chunk(self, chunk: bytes) -&gt; bytes:</span>
<span class="gi">+        if self._expected_content_remaining is not None:</span>
<span class="gi">+            self._expected_content_remaining -= len(chunk)</span>
<span class="gi">+            if self._expected_content_remaining &lt; 0:</span>
<span class="gi">+                # Close the stream now to stop further framing errors.</span>
<span class="gi">+                self.stream.close()</span>
<span class="gi">+                raise httputil.HTTPOutputError(</span>
<span class="gi">+                    &quot;Tried to write more data than Content-Length&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        if self._chunking_output and chunk:</span>
<span class="gi">+            # Don&#39;t write out empty chunks because that means END-OF-STREAM</span>
<span class="gi">+            # with chunked encoding</span>
<span class="gi">+            return utf8(&quot;%x&quot; % len(chunk)) + b&quot;\r\n&quot; + chunk + b&quot;\r\n&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return chunk</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, chunk: bytes) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Implements `.HTTPConnection.write`.

<span class="w"> </span>        For backwards compatibility it is allowed but deprecated to
<span class="w"> </span>        skip `write_headers` and instead call `write()` with a
<span class="w"> </span>        pre-encoded header block.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def finish(self) -&gt;None:</span>
<span class="gi">+        future = None</span>
<span class="gi">+        if self.stream.closed():</span>
<span class="gi">+            future = self._write_future = Future()</span>
<span class="gi">+            self._write_future.set_exception(iostream.StreamClosedError())</span>
<span class="gi">+            self._write_future.exception()</span>
<span class="gi">+        else:</span>
<span class="gi">+            future = self._write_future = Future()</span>
<span class="gi">+            self._pending_write = self.stream.write(self._format_chunk(chunk))</span>
<span class="gi">+            future_add_done_callback(self._pending_write, self._on_write_complete)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Implements `.HTTPConnection.finish`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._expected_content_remaining is not None</span>
<span class="gi">+            and self._expected_content_remaining != 0</span>
<span class="gi">+            and not self.stream.closed()</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.stream.close()</span>
<span class="gi">+            raise httputil.HTTPOutputError(</span>
<span class="gi">+                &quot;Tried to write %d bytes less than Content-Length&quot;</span>
<span class="gi">+                % self._expected_content_remaining</span>
<span class="gi">+            )</span>
<span class="gi">+        if self._chunking_output:</span>
<span class="gi">+            if not self.stream.closed():</span>
<span class="gi">+                self._pending_write = self.stream.write(b&quot;0\r\n\r\n&quot;)</span>
<span class="gi">+                self._pending_write.add_done_callback(self._on_write_complete)</span>
<span class="gi">+        self._write_finished = True</span>
<span class="gi">+        # If the app finished the request while we&#39;re still reading,</span>
<span class="gi">+        # divert any remaining data away from the delegate and</span>
<span class="gi">+        # close the connection when we&#39;re done sending our response.</span>
<span class="gi">+        # Closing the connection is the only way to avoid reading the</span>
<span class="gi">+        # whole input body.</span>
<span class="gi">+        if not self._read_finished:</span>
<span class="gi">+            self._disconnect_on_finish = True</span>
<span class="gi">+        # No more data is coming, so instruct TCP to send any remaining</span>
<span class="gi">+        # data immediately instead of waiting for a full packet or ack.</span>
<span class="gi">+        self.stream.set_nodelay(True)</span>
<span class="gi">+        if self._pending_write is None:</span>
<span class="gi">+            self._finish_request(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            future_add_done_callback(self._pending_write, self._finish_request)</span>
<span class="gi">+</span>
<span class="gi">+    def _on_write_complete(self, future: &quot;Future[None]&quot;) -&gt; None:</span>
<span class="gi">+        exc = future.exception()</span>
<span class="gi">+        if exc is not None and not isinstance(exc, iostream.StreamClosedError):</span>
<span class="gi">+            future.result()</span>
<span class="gi">+        if self._write_callback is not None:</span>
<span class="gi">+            callback = self._write_callback</span>
<span class="gi">+            self._write_callback = None</span>
<span class="gi">+            self.stream.io_loop.add_callback(callback)</span>
<span class="gi">+        if self._write_future is not None:</span>
<span class="gi">+            future = self._write_future</span>
<span class="gi">+            self._write_future = None</span>
<span class="gi">+            future_set_result_unless_cancelled(future, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _can_keep_alive(</span>
<span class="gi">+        self, start_line: httputil.RequestStartLine, headers: httputil.HTTPHeaders</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if self.params.no_keep_alive:</span>
<span class="gi">+            return False</span>
<span class="gi">+        connection_header = headers.get(&quot;Connection&quot;)</span>
<span class="gi">+        if connection_header is not None:</span>
<span class="gi">+            connection_header = connection_header.lower()</span>
<span class="gi">+        if start_line.version == &quot;HTTP/1.1&quot;:</span>
<span class="gi">+            return connection_header != &quot;close&quot;</span>
<span class="gi">+        elif (</span>
<span class="gi">+            &quot;Content-Length&quot; in headers</span>
<span class="gi">+            or is_transfer_encoding_chunked(headers)</span>
<span class="gi">+            or getattr(start_line, &quot;method&quot;, None) in (&quot;HEAD&quot;, &quot;GET&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            # start_line may be a request or response start line; only</span>
<span class="gi">+            # the former has a method attribute.</span>
<span class="gi">+            return connection_header == &quot;keep-alive&quot;</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _finish_request(self, future: &quot;Optional[Future[None]]&quot;) -&gt; None:</span>
<span class="gi">+        self._clear_callbacks()</span>
<span class="gi">+        if not self.is_client and self._disconnect_on_finish:</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            return</span>
<span class="gi">+        # Turn Nagle&#39;s algorithm back on, leaving the stream in its</span>
<span class="gi">+        # default state for the next request.</span>
<span class="gi">+        self.stream.set_nodelay(False)</span>
<span class="gi">+        if not self._finish_future.done():</span>
<span class="gi">+            future_set_result_unless_cancelled(self._finish_future, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_headers(self, data: bytes) -&gt; Tuple[str, httputil.HTTPHeaders]:</span>
<span class="gi">+        # The lstrip removes newlines that some implementations sometimes</span>
<span class="gi">+        # insert between messages of a reused connection.  Per RFC 7230,</span>
<span class="gi">+        # we SHOULD ignore at least one empty line before the request.</span>
<span class="gi">+        # http://tools.ietf.org/html/rfc7230#section-3.5</span>
<span class="gi">+        data_str = native_str(data.decode(&quot;latin1&quot;)).lstrip(&quot;\r\n&quot;)</span>
<span class="gi">+        # RFC 7230 section allows for both CRLF and bare LF.</span>
<span class="gi">+        eol = data_str.find(&quot;\n&quot;)</span>
<span class="gi">+        start_line = data_str[:eol].rstrip(&quot;\r&quot;)</span>
<span class="gi">+        headers = httputil.HTTPHeaders.parse(data_str[eol:])</span>
<span class="gi">+        return start_line, headers</span>
<span class="gi">+</span>
<span class="gi">+    def _read_body(</span>
<span class="gi">+        self,</span>
<span class="gi">+        code: int,</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+        delegate: httputil.HTTPMessageDelegate,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if &quot;Content-Length&quot; in headers:</span>
<span class="gi">+            if &quot;,&quot; in headers[&quot;Content-Length&quot;]:</span>
<span class="gi">+                # Proxies sometimes cause Content-Length headers to get</span>
<span class="gi">+                # duplicated.  If all the values are identical then we can</span>
<span class="gi">+                # use them but if they differ it&#39;s an error.</span>
<span class="gi">+                pieces = re.split(r&quot;,\s*&quot;, headers[&quot;Content-Length&quot;])</span>
<span class="gi">+                if any(i != pieces[0] for i in pieces):</span>
<span class="gi">+                    raise httputil.HTTPInputError(</span>
<span class="gi">+                        &quot;Multiple unequal Content-Lengths: %r&quot;</span>
<span class="gi">+                        % headers[&quot;Content-Length&quot;]</span>
<span class="gi">+                    )</span>
<span class="gi">+                headers[&quot;Content-Length&quot;] = pieces[0]</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                content_length: Optional[int] = parse_int(headers[&quot;Content-Length&quot;])</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # Handles non-integer Content-Length value.</span>
<span class="gi">+                raise httputil.HTTPInputError(</span>
<span class="gi">+                    &quot;Only integer Content-Length is allowed: %s&quot;</span>
<span class="gi">+                    % headers[&quot;Content-Length&quot;]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if cast(int, content_length) &gt; self._max_body_size:</span>
<span class="gi">+                raise httputil.HTTPInputError(&quot;Content-Length too long&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            content_length = None</span>
<span class="gi">+</span>
<span class="gi">+        is_chunked = is_transfer_encoding_chunked(headers)</span>
<span class="gi">+</span>
<span class="gi">+        if code == 204:</span>
<span class="gi">+            # This response code is not allowed to have a non-empty body,</span>
<span class="gi">+            # and has an implicit length of zero instead of read-until-close.</span>
<span class="gi">+            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3</span>
<span class="gi">+            if is_chunked or content_length not in (None, 0):</span>
<span class="gi">+                raise httputil.HTTPInputError(</span>
<span class="gi">+                    &quot;Response with code %d should not have body&quot; % code</span>
<span class="gi">+                )</span>
<span class="gi">+            content_length = 0</span>
<span class="gi">+</span>
<span class="gi">+        if is_chunked:</span>
<span class="gi">+            return self._read_chunked_body(delegate)</span>
<span class="gi">+        if content_length is not None:</span>
<span class="gi">+            return self._read_fixed_body(content_length, delegate)</span>
<span class="gi">+        if self.is_client:</span>
<span class="gi">+            return self._read_body_until_close(delegate)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    async def _read_fixed_body(</span>
<span class="gi">+        self, content_length: int, delegate: httputil.HTTPMessageDelegate</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        while content_length &gt; 0:</span>
<span class="gi">+            body = await self.stream.read_bytes(</span>
<span class="gi">+                min(self.params.chunk_size, content_length), partial=True</span>
<span class="gi">+            )</span>
<span class="gi">+            content_length -= len(body)</span>
<span class="gi">+            if not self._write_finished or self.is_client:</span>
<span class="gi">+                with _ExceptionLoggingContext(app_log):</span>
<span class="gi">+                    ret = delegate.data_received(body)</span>
<span class="gi">+                    if ret is not None:</span>
<span class="gi">+                        await ret</span>
<span class="gi">+</span>
<span class="gi">+    async def _read_chunked_body(self, delegate: httputil.HTTPMessageDelegate) -&gt; None:</span>
<span class="gi">+        # TODO: &quot;chunk extensions&quot; http://tools.ietf.org/html/rfc2616#section-3.6.1</span>
<span class="gi">+        total_size = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            chunk_len_str = await self.stream.read_until(b&quot;\r\n&quot;, max_bytes=64)</span>
<span class="gi">+            try:</span>
<span class="gi">+                chunk_len = parse_hex_int(native_str(chunk_len_str[:-2]))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise httputil.HTTPInputError(&quot;invalid chunk size&quot;)</span>
<span class="gi">+            if chunk_len == 0:</span>
<span class="gi">+                crlf = await self.stream.read_bytes(2)</span>
<span class="gi">+                if crlf != b&quot;\r\n&quot;:</span>
<span class="gi">+                    raise httputil.HTTPInputError(</span>
<span class="gi">+                        &quot;improperly terminated chunked request&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                return</span>
<span class="gi">+            total_size += chunk_len</span>
<span class="gi">+            if total_size &gt; self._max_body_size:</span>
<span class="gi">+                raise httputil.HTTPInputError(&quot;chunked body too large&quot;)</span>
<span class="gi">+            bytes_to_read = chunk_len</span>
<span class="gi">+            while bytes_to_read:</span>
<span class="gi">+                chunk = await self.stream.read_bytes(</span>
<span class="gi">+                    min(bytes_to_read, self.params.chunk_size), partial=True</span>
<span class="gi">+                )</span>
<span class="gi">+                bytes_to_read -= len(chunk)</span>
<span class="gi">+                if not self._write_finished or self.is_client:</span>
<span class="gi">+                    with _ExceptionLoggingContext(app_log):</span>
<span class="gi">+                        ret = delegate.data_received(chunk)</span>
<span class="gi">+                        if ret is not None:</span>
<span class="gi">+                            await ret</span>
<span class="gi">+            # chunk ends with \r\n</span>
<span class="gi">+            crlf = await self.stream.read_bytes(2)</span>
<span class="gi">+            assert crlf == b&quot;\r\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    async def _read_body_until_close(</span>
<span class="gi">+        self, delegate: httputil.HTTPMessageDelegate</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        body = await self.stream.read_until_close()</span>
<span class="gi">+        if not self._write_finished or self.is_client:</span>
<span class="gi">+            with _ExceptionLoggingContext(app_log):</span>
<span class="gi">+                ret = delegate.data_received(body)</span>
<span class="gi">+                if ret is not None:</span>
<span class="gi">+                    await ret</span>


<span class="w"> </span>class _GzipMessageDelegate(httputil.HTTPMessageDelegate):
<span class="w"> </span>    &quot;&quot;&quot;Wraps an `HTTPMessageDelegate` to decode ``Content-Encoding: gzip``.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, delegate: httputil.HTTPMessageDelegate, chunk_size: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, delegate: httputil.HTTPMessageDelegate, chunk_size: int) -&gt; None:</span>
<span class="w"> </span>        self._delegate = delegate
<span class="w"> </span>        self._chunk_size = chunk_size
<span class="gd">-        self._decompressor = None</span>
<span class="gi">+        self._decompressor = None  # type: Optional[GzipDecompressor]</span>
<span class="gi">+</span>
<span class="gi">+    def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if headers.get(&quot;Content-Encoding&quot;, &quot;&quot;).lower() == &quot;gzip&quot;:</span>
<span class="gi">+            self._decompressor = GzipDecompressor()</span>
<span class="gi">+            # Downstream delegates will only see uncompressed data,</span>
<span class="gi">+            # so rename the content-encoding header.</span>
<span class="gi">+            # (but note that curl_httpclient doesn&#39;t do this).</span>
<span class="gi">+            headers.add(&quot;X-Consumed-Content-Encoding&quot;, headers[&quot;Content-Encoding&quot;])</span>
<span class="gi">+            del headers[&quot;Content-Encoding&quot;]</span>
<span class="gi">+        return self._delegate.headers_received(start_line, headers)</span>
<span class="gi">+</span>
<span class="gi">+    async def data_received(self, chunk: bytes) -&gt; None:</span>
<span class="gi">+        if self._decompressor:</span>
<span class="gi">+            compressed_data = chunk</span>
<span class="gi">+            while compressed_data:</span>
<span class="gi">+                decompressed = self._decompressor.decompress(</span>
<span class="gi">+                    compressed_data, self._chunk_size</span>
<span class="gi">+                )</span>
<span class="gi">+                if decompressed:</span>
<span class="gi">+                    ret = self._delegate.data_received(decompressed)</span>
<span class="gi">+                    if ret is not None:</span>
<span class="gi">+                        await ret</span>
<span class="gi">+                compressed_data = self._decompressor.unconsumed_tail</span>
<span class="gi">+                if compressed_data and not decompressed:</span>
<span class="gi">+                    raise httputil.HTTPInputError(</span>
<span class="gi">+                        &quot;encountered unconsumed gzip data without making progress&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+        else:</span>
<span class="gi">+            ret = self._delegate.data_received(chunk)</span>
<span class="gi">+            if ret is not None:</span>
<span class="gi">+                await ret</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        if self._decompressor is not None:</span>
<span class="gi">+            tail = self._decompressor.flush()</span>
<span class="gi">+            if tail:</span>
<span class="gi">+                # The tail should always be empty: decompress returned</span>
<span class="gi">+                # all that it can in data_received and the only</span>
<span class="gi">+                # purpose of the flush call is to detect errors such</span>
<span class="gi">+                # as truncated input. If we did legitimately get a new</span>
<span class="gi">+                # chunk at this point we&#39;d need to change the</span>
<span class="gi">+                # interface to make finish() a coroutine.</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;decompressor.flush returned data; possible truncated input&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        return self._delegate.finish()</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        return self._delegate.on_connection_close()</span>


<span class="w"> </span>class HTTP1ServerConnection(object):
<span class="w"> </span>    &quot;&quot;&quot;An HTTP/1.x server.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream: iostream.IOStream, params: Optional[</span>
<span class="gd">-        HTTP1ConnectionParameters]=None, context: Optional[object]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream: iostream.IOStream,</span>
<span class="gi">+        params: Optional[HTTP1ConnectionParameters] = None,</span>
<span class="gi">+        context: Optional[object] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :arg stream: an `.IOStream`
<span class="w"> </span>        :arg params: a `.HTTP1ConnectionParameters` or None
<span class="gu">@@ -217,41 +781,106 @@ class HTTP1ServerConnection(object):</span>
<span class="w"> </span>            params = HTTP1ConnectionParameters()
<span class="w"> </span>        self.params = params
<span class="w"> </span>        self.context = context
<span class="gd">-        self._serving_future = None</span>
<span class="gi">+        self._serving_future = None  # type: Optional[Future[None]]</span>

<span class="gd">-    async def close(self) -&gt;None:</span>
<span class="gi">+    async def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the connection.

<span class="w"> </span>        Returns a `.Future` that resolves after the serving loop has exited.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def start_serving(self, delegate: httputil.HTTPServerConnectionDelegate</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        self.stream.close()</span>
<span class="gi">+        # Block until the serving loop is done, but ignore any exceptions</span>
<span class="gi">+        # (start_serving is already responsible for logging them).</span>
<span class="gi">+        assert self._serving_future is not None</span>
<span class="gi">+        try:</span>
<span class="gi">+            await self._serving_future</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def start_serving(self, delegate: httputil.HTTPServerConnectionDelegate) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts serving requests on this connection.

<span class="w"> </span>        :arg delegate: a `.HTTPServerConnectionDelegate`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-DIGITS = re.compile(&#39;[0-9]+&#39;)</span>
<span class="gd">-HEXDIGITS = re.compile(&#39;[0-9a-fA-F]+&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_int(s: str) -&gt;int:</span>
<span class="gi">+        assert isinstance(delegate, httputil.HTTPServerConnectionDelegate)</span>
<span class="gi">+        fut = gen.convert_yielded(self._server_request_loop(delegate))</span>
<span class="gi">+        self._serving_future = fut</span>
<span class="gi">+        # Register the future on the IOLoop so its errors get logged.</span>
<span class="gi">+        self.stream.io_loop.add_future(fut, lambda f: f.result())</span>
<span class="gi">+</span>
<span class="gi">+    async def _server_request_loop(</span>
<span class="gi">+        self, delegate: httputil.HTTPServerConnectionDelegate</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                conn = HTTP1Connection(self.stream, False, self.params, self.context)</span>
<span class="gi">+                request_delegate = delegate.start_request(self, conn)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    ret = await conn.read_response(request_delegate)</span>
<span class="gi">+                except (</span>
<span class="gi">+                    iostream.StreamClosedError,</span>
<span class="gi">+                    iostream.UnsatisfiableReadError,</span>
<span class="gi">+                    asyncio.CancelledError,</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+                except _QuietException:</span>
<span class="gi">+                    # This exception was already logged.</span>
<span class="gi">+                    conn.close()</span>
<span class="gi">+                    return</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    gen_log.error(&quot;Uncaught exception&quot;, exc_info=True)</span>
<span class="gi">+                    conn.close()</span>
<span class="gi">+                    return</span>
<span class="gi">+                if not ret:</span>
<span class="gi">+                    return</span>
<span class="gi">+                await asyncio.sleep(0)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            delegate.on_close(self)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DIGITS = re.compile(r&quot;[0-9]+&quot;)</span>
<span class="gi">+HEXDIGITS = re.compile(r&quot;[0-9a-fA-F]+&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_int(s: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a non-negative integer from a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if DIGITS.fullmatch(s) is None:</span>
<span class="gi">+        raise ValueError(&quot;not an integer: %r&quot; % s)</span>
<span class="gi">+    return int(s)</span>


<span class="gd">-def parse_hex_int(s: str) -&gt;int:</span>
<span class="gi">+def parse_hex_int(s: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a non-negative hexadecimal integer from a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if HEXDIGITS.fullmatch(s) is None:</span>
<span class="gi">+        raise ValueError(&quot;not a hexadecimal integer: %r&quot; % s)</span>
<span class="gi">+    return int(s, 16)</span>


<span class="gd">-def is_transfer_encoding_chunked(headers: httputil.HTTPHeaders) -&gt;bool:</span>
<span class="gi">+def is_transfer_encoding_chunked(headers: httputil.HTTPHeaders) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if the headers specify Transfer-Encoding: chunked.

<span class="w"> </span>    Raise httputil.HTTPInputError if any other transfer encoding is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Note that transfer-encoding is an area in which postel&#39;s law can lead</span>
<span class="gi">+    # us astray. If a proxy and a backend server are liberal in what they accept,</span>
<span class="gi">+    # but accept slightly different things, this can lead to mismatched framing</span>
<span class="gi">+    # and request smuggling issues. Therefore we are as strict as possible here</span>
<span class="gi">+    # (even technically going beyond the requirements of the RFCs: a value of</span>
<span class="gi">+    # &quot;,chunked&quot; is legal but doesn&#39;t appear in practice for legitimate traffic)</span>
<span class="gi">+    if &quot;Transfer-Encoding&quot; not in headers:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if &quot;Content-Length&quot; in headers:</span>
<span class="gi">+        # Message cannot contain both Content-Length and</span>
<span class="gi">+        # Transfer-Encoding headers.</span>
<span class="gi">+        # http://tools.ietf.org/html/rfc7230#section-3.3.3</span>
<span class="gi">+        raise httputil.HTTPInputError(</span>
<span class="gi">+            &quot;Message with both Transfer-Encoding and Content-Length&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if headers[&quot;Transfer-Encoding&quot;].lower() == &quot;chunked&quot;:</span>
<span class="gi">+        return True</span>
<span class="gi">+    # We do not support any transfer-encodings other than chunked, and we do not</span>
<span class="gi">+    # expect to add any support because the concept of transfer-encoding has</span>
<span class="gi">+    # been removed in HTTP/2.</span>
<span class="gi">+    raise httputil.HTTPInputError(</span>
<span class="gi">+        &quot;Unsupported Transfer-Encoding %s&quot; % headers[&quot;Transfer-Encoding&quot;]</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/tornado/httpclient.py b/tornado/httpclient.py</span>
<span class="gh">index 6069b0be..3011c371 100644</span>
<span class="gd">--- a/tornado/httpclient.py</span>
<span class="gi">+++ b/tornado/httpclient.py</span>
<span class="gu">@@ -35,17 +35,24 @@ To select ``curl_httpclient``, call `AsyncHTTPClient.configure` at startup::</span>

<span class="w"> </span>    AsyncHTTPClient.configure(&quot;tornado.curl_httpclient.CurlAsyncHTTPClient&quot;)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import functools
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>import ssl
<span class="w"> </span>import time
<span class="w"> </span>import weakref
<span class="gd">-from tornado.concurrent import Future, future_set_result_unless_cancelled, future_set_exception_unless_cancelled</span>
<span class="gi">+</span>
<span class="gi">+from tornado.concurrent import (</span>
<span class="gi">+    Future,</span>
<span class="gi">+    future_set_result_unless_cancelled,</span>
<span class="gi">+    future_set_exception_unless_cancelled,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.escape import utf8, native_str
<span class="w"> </span>from tornado import gen, httputil
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.util import Configurable
<span class="gi">+</span>
<span class="w"> </span>from typing import Type, Any, Union, Dict, Callable, Optional, cast


<span class="gu">@@ -79,29 +86,42 @@ class HTTPClient(object):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, async_client_class:</span>
<span class="gd">-        &#39;Optional[Type[AsyncHTTPClient]]&#39;=None, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        async_client_class: &quot;Optional[Type[AsyncHTTPClient]]&quot; = None,</span>
<span class="gi">+        **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Initialize self._closed at the beginning of the constructor</span>
<span class="gi">+        # so that an exception raised here doesn&#39;t lead to confusing</span>
<span class="gi">+        # failures in __del__.</span>
<span class="w"> </span>        self._closed = True
<span class="w"> </span>        self._io_loop = IOLoop(make_current=False)
<span class="w"> </span>        if async_client_class is None:
<span class="w"> </span>            async_client_class = AsyncHTTPClient

<span class="gd">-        async def make_client() -&gt;&#39;AsyncHTTPClient&#39;:</span>
<span class="gi">+        # Create the client while our IOLoop is &quot;current&quot;, without</span>
<span class="gi">+        # clobbering the thread&#39;s real current IOLoop (if any).</span>
<span class="gi">+        async def make_client() -&gt; &quot;AsyncHTTPClient&quot;:</span>
<span class="w"> </span>            await gen.sleep(0)
<span class="w"> </span>            assert async_client_class is not None
<span class="w"> </span>            return async_client_class(**kwargs)
<span class="gi">+</span>
<span class="w"> </span>        self._async_client = self._io_loop.run_sync(make_client)
<span class="w"> </span>        self._closed = False

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="w"> </span>        self.close()

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the HTTPClient, freeing any resources used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fetch(self, request: Union[&#39;HTTPRequest&#39;, str], **kwargs: Any</span>
<span class="gd">-        ) -&gt;&#39;HTTPResponse&#39;:</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._async_client.close()</span>
<span class="gi">+            self._io_loop.close()</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+</span>
<span class="gi">+    def fetch(</span>
<span class="gi">+        self, request: Union[&quot;HTTPRequest&quot;, str], **kwargs: Any</span>
<span class="gi">+    ) -&gt; &quot;HTTPResponse&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Executes a request, returning an `HTTPResponse`.

<span class="w"> </span>        The request may be either a string URL or an `HTTPRequest` object.
<span class="gu">@@ -111,7 +131,10 @@ class HTTPClient(object):</span>
<span class="w"> </span>        If an error occurs during the fetch, we raise an `HTTPError` unless
<span class="w"> </span>        the ``raise_error`` keyword argument is set to False.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = self._io_loop.run_sync(</span>
<span class="gi">+            functools.partial(self._async_client.fetch, request, **kwargs)</span>
<span class="gi">+        )</span>
<span class="gi">+        return response</span>


<span class="w"> </span>class AsyncHTTPClient(Configurable):
<span class="gu">@@ -152,10 +175,27 @@ class AsyncHTTPClient(Configurable):</span>
<span class="w"> </span>       The ``io_loop`` argument (deprecated since version 4.1) has been removed.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _instance_cache = None</span>

<span class="gd">-    def __new__(cls, force_instance: bool=False, **kwargs: Any</span>
<span class="gd">-        ) -&gt;&#39;AsyncHTTPClient&#39;:</span>
<span class="gi">+    _instance_cache = None  # type: Dict[IOLoop, AsyncHTTPClient]</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_base(cls) -&gt; Type[Configurable]:</span>
<span class="gi">+        return AsyncHTTPClient</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_default(cls) -&gt; Type[Configurable]:</span>
<span class="gi">+        from tornado.simple_httpclient import SimpleAsyncHTTPClient</span>
<span class="gi">+</span>
<span class="gi">+        return SimpleAsyncHTTPClient</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _async_clients(cls) -&gt; Dict[IOLoop, &quot;AsyncHTTPClient&quot;]:</span>
<span class="gi">+        attr_name = &quot;_async_client_dict_&quot; + cls.__name__</span>
<span class="gi">+        if not hasattr(cls, attr_name):</span>
<span class="gi">+            setattr(cls, attr_name, weakref.WeakKeyDictionary())</span>
<span class="gi">+        return getattr(cls, attr_name)</span>
<span class="gi">+</span>
<span class="gi">+    def __new__(cls, force_instance: bool = False, **kwargs: Any) -&gt; &quot;AsyncHTTPClient&quot;:</span>
<span class="w"> </span>        io_loop = IOLoop.current()
<span class="w"> </span>        if force_instance:
<span class="w"> </span>            instance_cache = None
<span class="gu">@@ -163,13 +203,24 @@ class AsyncHTTPClient(Configurable):</span>
<span class="w"> </span>            instance_cache = cls._async_clients()
<span class="w"> </span>        if instance_cache is not None and io_loop in instance_cache:
<span class="w"> </span>            return instance_cache[io_loop]
<span class="gd">-        instance = super(AsyncHTTPClient, cls).__new__(cls, **kwargs)</span>
<span class="gi">+        instance = super(AsyncHTTPClient, cls).__new__(cls, **kwargs)  # type: ignore</span>
<span class="gi">+        # Make sure the instance knows which cache to remove itself from.</span>
<span class="gi">+        # It can&#39;t simply call _async_clients() because we may be in</span>
<span class="gi">+        # __new__(AsyncHTTPClient) but instance.__class__ may be</span>
<span class="gi">+        # SimpleAsyncHTTPClient.</span>
<span class="w"> </span>        instance._instance_cache = instance_cache
<span class="w"> </span>        if instance_cache is not None:
<span class="w"> </span>            instance_cache[instance.io_loop] = instance
<span class="w"> </span>        return instance

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def initialize(self, defaults: Optional[Dict[str, Any]] = None) -&gt; None:</span>
<span class="gi">+        self.io_loop = IOLoop.current()</span>
<span class="gi">+        self.defaults = dict(HTTPRequest._DEFAULTS)</span>
<span class="gi">+        if defaults is not None:</span>
<span class="gi">+            self.defaults.update(defaults)</span>
<span class="gi">+        self._closed = False</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Destroys this HTTP client, freeing any file descriptors used.

<span class="w"> </span>        This method is **not needed in normal use** due to the way
<span class="gu">@@ -182,10 +233,25 @@ class AsyncHTTPClient(Configurable):</span>
<span class="w"> </span>        ``close()``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fetch(self, request: Union[str, &#39;HTTPRequest&#39;], raise_error: bool=</span>
<span class="gd">-        True, **kwargs: Any) -&gt;&#39;Future[HTTPResponse]&#39;:</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+        if self._instance_cache is not None:</span>
<span class="gi">+            cached_val = self._instance_cache.pop(self.io_loop, None)</span>
<span class="gi">+            # If there&#39;s an object other than self in the instance</span>
<span class="gi">+            # cache for our IOLoop, something has gotten mixed up. A</span>
<span class="gi">+            # value of None appears to be possible when this is called</span>
<span class="gi">+            # from a destructor (HTTPClient.__del__) as the weakref</span>
<span class="gi">+            # gets cleared before the destructor runs.</span>
<span class="gi">+            if cached_val is not None and cached_val is not self:</span>
<span class="gi">+                raise RuntimeError(&quot;inconsistent AsyncHTTPClient cache&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def fetch(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: Union[str, &quot;HTTPRequest&quot;],</span>
<span class="gi">+        raise_error: bool = True,</span>
<span class="gi">+        **kwargs: Any</span>
<span class="gi">+    ) -&gt; &quot;Future[HTTPResponse]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Executes a request, asynchronously returning an `HTTPResponse`.

<span class="w"> </span>        The request may be either a string URL or an `HTTPRequest` object.
<span class="gu">@@ -214,11 +280,41 @@ class AsyncHTTPClient(Configurable):</span>
<span class="w"> </span>           `HTTPError` raised when a non-200 response code is used,
<span class="w"> </span>           instead of suppressing all errors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise RuntimeError(&quot;fetch() called on closed AsyncHTTPClient&quot;)</span>
<span class="gi">+        if not isinstance(request, HTTPRequest):</span>
<span class="gi">+            request = HTTPRequest(url=request, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if kwargs:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;kwargs can&#39;t be used if request is an HTTPRequest object&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        # We may modify this (to add Host, Accept-Encoding, etc),</span>
<span class="gi">+        # so make sure we don&#39;t modify the caller&#39;s object.  This is also</span>
<span class="gi">+        # where normal dicts get converted to HTTPHeaders objects.</span>
<span class="gi">+        request.headers = httputil.HTTPHeaders(request.headers)</span>
<span class="gi">+        request_proxy = _RequestProxy(request, self.defaults)</span>
<span class="gi">+        future = Future()  # type: Future[HTTPResponse]</span>
<span class="gi">+</span>
<span class="gi">+        def handle_response(response: &quot;HTTPResponse&quot;) -&gt; None:</span>
<span class="gi">+            if response.error:</span>
<span class="gi">+                if raise_error or not response._error_is_response_code:</span>
<span class="gi">+                    future_set_exception_unless_cancelled(future, response.error)</span>
<span class="gi">+                    return</span>
<span class="gi">+            future_set_result_unless_cancelled(future, response)</span>
<span class="gi">+</span>
<span class="gi">+        self.fetch_impl(cast(HTTPRequest, request_proxy), handle_response)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_impl(</span>
<span class="gi">+        self, request: &quot;HTTPRequest&quot;, callback: Callable[[&quot;HTTPResponse&quot;], None]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def configure(cls, impl: &#39;Union[None, str, Type[Configurable]]&#39;, **</span>
<span class="gd">-        kwargs: Any) -&gt;None:</span>
<span class="gi">+    def configure(</span>
<span class="gi">+        cls, impl: &quot;Union[None, str, Type[Configurable]]&quot;, **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Configures the `AsyncHTTPClient` subclass to use.

<span class="w"> </span>        ``AsyncHTTPClient()`` actually creates an instance of a subclass.
<span class="gu">@@ -237,38 +333,67 @@ class AsyncHTTPClient(Configurable):</span>

<span class="w"> </span>           AsyncHTTPClient.configure(&quot;tornado.curl_httpclient.CurlAsyncHTTPClient&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super(AsyncHTTPClient, cls).configure(impl, **kwargs)</span>


<span class="w"> </span>class HTTPRequest(object):
<span class="w"> </span>    &quot;&quot;&quot;HTTP client request object.&quot;&quot;&quot;
<span class="gd">-    _headers = None</span>
<span class="gd">-    _DEFAULTS = dict(connect_timeout=20.0, request_timeout=20.0,</span>
<span class="gd">-        follow_redirects=True, max_redirects=5, decompress_response=True,</span>
<span class="gd">-        proxy_password=&#39;&#39;, allow_nonstandard_methods=False, validate_cert=True)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, url: str, method: str=&#39;GET&#39;, headers: Optional[Union</span>
<span class="gd">-        [Dict[str, str], httputil.HTTPHeaders]]=None, body: Optional[Union[</span>
<span class="gd">-        bytes, str]]=None, auth_username: Optional[str]=None, auth_password:</span>
<span class="gd">-        Optional[str]=None, auth_mode: Optional[str]=None, connect_timeout:</span>
<span class="gd">-        Optional[float]=None, request_timeout: Optional[float]=None,</span>
<span class="gd">-        if_modified_since: Optional[Union[float, datetime.datetime]]=None,</span>
<span class="gd">-        follow_redirects: Optional[bool]=None, max_redirects: Optional[int]</span>
<span class="gd">-        =None, user_agent: Optional[str]=None, use_gzip: Optional[bool]=</span>
<span class="gd">-        None, network_interface: Optional[str]=None, streaming_callback:</span>
<span class="gd">-        Optional[Callable[[bytes], None]]=None, header_callback: Optional[</span>
<span class="gd">-        Callable[[str], None]]=None, prepare_curl_callback: Optional[</span>
<span class="gd">-        Callable[[Any], None]]=None, proxy_host: Optional[str]=None,</span>
<span class="gd">-        proxy_port: Optional[int]=None, proxy_username: Optional[str]=None,</span>
<span class="gd">-        proxy_password: Optional[str]=None, proxy_auth_mode: Optional[str]=</span>
<span class="gd">-        None, allow_nonstandard_methods: Optional[bool]=None, validate_cert:</span>
<span class="gd">-        Optional[bool]=None, ca_certs: Optional[str]=None, allow_ipv6:</span>
<span class="gd">-        Optional[bool]=None, client_key: Optional[str]=None, client_cert:</span>
<span class="gd">-        Optional[str]=None, body_producer: Optional[Callable[[Callable[[</span>
<span class="gd">-        bytes], None]], &#39;Future[None]&#39;]]=None, expect_100_continue: bool=</span>
<span class="gd">-        False, decompress_response: Optional[bool]=None, ssl_options:</span>
<span class="gd">-        Optional[Union[Dict[str, Any], ssl.SSLContext]]=None) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;All parameters except ``url`` are optional.</span>
<span class="gi">+</span>
<span class="gi">+    _headers = None  # type: Union[Dict[str, str], httputil.HTTPHeaders]</span>
<span class="gi">+</span>
<span class="gi">+    # Default values for HTTPRequest parameters.</span>
<span class="gi">+    # Merged with the values on the request object by AsyncHTTPClient</span>
<span class="gi">+    # implementations.</span>
<span class="gi">+    _DEFAULTS = dict(</span>
<span class="gi">+        connect_timeout=20.0,</span>
<span class="gi">+        request_timeout=20.0,</span>
<span class="gi">+        follow_redirects=True,</span>
<span class="gi">+        max_redirects=5,</span>
<span class="gi">+        decompress_response=True,</span>
<span class="gi">+        proxy_password=&quot;&quot;,</span>
<span class="gi">+        allow_nonstandard_methods=False,</span>
<span class="gi">+        validate_cert=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        url: str,</span>
<span class="gi">+        method: str = &quot;GET&quot;,</span>
<span class="gi">+        headers: Optional[Union[Dict[str, str], httputil.HTTPHeaders]] = None,</span>
<span class="gi">+        body: Optional[Union[bytes, str]] = None,</span>
<span class="gi">+        auth_username: Optional[str] = None,</span>
<span class="gi">+        auth_password: Optional[str] = None,</span>
<span class="gi">+        auth_mode: Optional[str] = None,</span>
<span class="gi">+        connect_timeout: Optional[float] = None,</span>
<span class="gi">+        request_timeout: Optional[float] = None,</span>
<span class="gi">+        if_modified_since: Optional[Union[float, datetime.datetime]] = None,</span>
<span class="gi">+        follow_redirects: Optional[bool] = None,</span>
<span class="gi">+        max_redirects: Optional[int] = None,</span>
<span class="gi">+        user_agent: Optional[str] = None,</span>
<span class="gi">+        use_gzip: Optional[bool] = None,</span>
<span class="gi">+        network_interface: Optional[str] = None,</span>
<span class="gi">+        streaming_callback: Optional[Callable[[bytes], None]] = None,</span>
<span class="gi">+        header_callback: Optional[Callable[[str], None]] = None,</span>
<span class="gi">+        prepare_curl_callback: Optional[Callable[[Any], None]] = None,</span>
<span class="gi">+        proxy_host: Optional[str] = None,</span>
<span class="gi">+        proxy_port: Optional[int] = None,</span>
<span class="gi">+        proxy_username: Optional[str] = None,</span>
<span class="gi">+        proxy_password: Optional[str] = None,</span>
<span class="gi">+        proxy_auth_mode: Optional[str] = None,</span>
<span class="gi">+        allow_nonstandard_methods: Optional[bool] = None,</span>
<span class="gi">+        validate_cert: Optional[bool] = None,</span>
<span class="gi">+        ca_certs: Optional[str] = None,</span>
<span class="gi">+        allow_ipv6: Optional[bool] = None,</span>
<span class="gi">+        client_key: Optional[str] = None,</span>
<span class="gi">+        client_cert: Optional[str] = None,</span>
<span class="gi">+        body_producer: Optional[</span>
<span class="gi">+            Callable[[Callable[[bytes], None]], &quot;Future[None]&quot;]</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+        expect_100_continue: bool = False,</span>
<span class="gi">+        decompress_response: Optional[bool] = None,</span>
<span class="gi">+        ssl_options: Optional[Union[Dict[str, Any], ssl.SSLContext]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        r&quot;&quot;&quot;All parameters except ``url`` are optional.</span>

<span class="w"> </span>        :arg str url: URL to fetch
<span class="w"> </span>        :arg str method: HTTP method, e.g. &quot;GET&quot; or &quot;POST&quot;
<span class="gu">@@ -318,8 +443,8 @@ class HTTPRequest(object):</span>
<span class="w"> </span>           the final response.
<span class="w"> </span>        :arg collections.abc.Callable header_callback: If set, ``header_callback`` will
<span class="w"> </span>           be run with each header line as it is received (including the
<span class="gd">-           first line, e.g. ``HTTP/1.0 200 OK\\r\\n``, and a final line</span>
<span class="gd">-           containing only ``\\r\\n``.  All lines include the trailing newline</span>
<span class="gi">+           first line, e.g. ``HTTP/1.0 200 OK\r\n``, and a final line</span>
<span class="gi">+           containing only ``\r\n``.  All lines include the trailing newline</span>
<span class="w"> </span>           characters).  ``HTTPResponse.headers`` will be empty in the final
<span class="w"> </span>           response.  This is most useful in conjunction with
<span class="w"> </span>           ``streaming_callback``, because it&#39;s the only way to get access to
<span class="gu">@@ -381,10 +506,13 @@ class HTTPRequest(object):</span>
<span class="w"> </span>        .. versionadded:: 4.5
<span class="w"> </span>           The ``proxy_auth_mode`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.headers = headers</span>
<span class="gi">+        # Note that some of these attributes go through property setters</span>
<span class="gi">+        # defined below.</span>
<span class="gi">+        self.headers = headers  # type: ignore</span>
<span class="w"> </span>        if if_modified_since:
<span class="gd">-            self.headers[&#39;If-Modified-Since&#39;] = httputil.format_timestamp(</span>
<span class="gd">-                if_modified_since)</span>
<span class="gi">+            self.headers[&quot;If-Modified-Since&quot;] = httputil.format_timestamp(</span>
<span class="gi">+                if_modified_since</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self.proxy_host = proxy_host
<span class="w"> </span>        self.proxy_port = proxy_port
<span class="w"> </span>        self.proxy_username = proxy_username
<span class="gu">@@ -392,7 +520,7 @@ class HTTPRequest(object):</span>
<span class="w"> </span>        self.proxy_auth_mode = proxy_auth_mode
<span class="w"> </span>        self.url = url
<span class="w"> </span>        self.method = method
<span class="gd">-        self.body = body</span>
<span class="gi">+        self.body = body  # type: ignore</span>
<span class="w"> </span>        self.body_producer = body_producer
<span class="w"> </span>        self.auth_username = auth_username
<span class="w"> </span>        self.auth_password = auth_password
<span class="gu">@@ -403,7 +531,7 @@ class HTTPRequest(object):</span>
<span class="w"> </span>        self.max_redirects = max_redirects
<span class="w"> </span>        self.user_agent = user_agent
<span class="w"> </span>        if decompress_response is not None:
<span class="gd">-            self.decompress_response = decompress_response</span>
<span class="gi">+            self.decompress_response = decompress_response  # type: Optional[bool]</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.decompress_response = use_gzip
<span class="w"> </span>        self.network_interface = network_interface
<span class="gu">@@ -420,6 +548,28 @@ class HTTPRequest(object):</span>
<span class="w"> </span>        self.expect_100_continue = expect_100_continue
<span class="w"> </span>        self.start_time = time.time()

<span class="gi">+    @property</span>
<span class="gi">+    def headers(self) -&gt; httputil.HTTPHeaders:</span>
<span class="gi">+        # TODO: headers may actually be a plain dict until fairly late in</span>
<span class="gi">+        # the process (AsyncHTTPClient.fetch), but practically speaking,</span>
<span class="gi">+        # whenever the property is used they&#39;re already HTTPHeaders.</span>
<span class="gi">+        return self._headers  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    @headers.setter</span>
<span class="gi">+    def headers(self, value: Union[Dict[str, str], httputil.HTTPHeaders]) -&gt; None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            self._headers = httputil.HTTPHeaders()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._headers = value  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def body(self) -&gt; bytes:</span>
<span class="gi">+        return self._body</span>
<span class="gi">+</span>
<span class="gi">+    @body.setter</span>
<span class="gi">+    def body(self, value: Union[bytes, str]) -&gt; None:</span>
<span class="gi">+        self._body = utf8(value)</span>
<span class="gi">+</span>

<span class="w"> </span>class HTTPResponse(object):
<span class="w"> </span>    &quot;&quot;&quot;HTTP Response object.
<span class="gu">@@ -470,28 +620,37 @@ class HTTPResponse(object):</span>
<span class="w"> </span>       is excluded in both implementations. ``request_time`` is now more accurate for
<span class="w"> </span>       ``curl_httpclient`` because it uses a monotonic clock when available.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    error = None</span>
<span class="gi">+</span>
<span class="gi">+    # I&#39;m not sure why these don&#39;t get type-inferred from the references in __init__.</span>
<span class="gi">+    error = None  # type: Optional[BaseException]</span>
<span class="w"> </span>    _error_is_response_code = False
<span class="gd">-    request = None</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, request: HTTPRequest, code: int, headers: Optional[</span>
<span class="gd">-        httputil.HTTPHeaders]=None, buffer: Optional[BytesIO]=None,</span>
<span class="gd">-        effective_url: Optional[str]=None, error: Optional[BaseException]=</span>
<span class="gd">-        None, request_time: Optional[float]=None, time_info: Optional[Dict[</span>
<span class="gd">-        str, float]]=None, reason: Optional[str]=None, start_time: Optional</span>
<span class="gd">-        [float]=None) -&gt;None:</span>
<span class="gi">+    request = None  # type: HTTPRequest</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: HTTPRequest,</span>
<span class="gi">+        code: int,</span>
<span class="gi">+        headers: Optional[httputil.HTTPHeaders] = None,</span>
<span class="gi">+        buffer: Optional[BytesIO] = None,</span>
<span class="gi">+        effective_url: Optional[str] = None,</span>
<span class="gi">+        error: Optional[BaseException] = None,</span>
<span class="gi">+        request_time: Optional[float] = None,</span>
<span class="gi">+        time_info: Optional[Dict[str, float]] = None,</span>
<span class="gi">+        reason: Optional[str] = None,</span>
<span class="gi">+        start_time: Optional[float] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if isinstance(request, _RequestProxy):
<span class="w"> </span>            self.request = request.request
<span class="w"> </span>        else:
<span class="w"> </span>            self.request = request
<span class="w"> </span>        self.code = code
<span class="gd">-        self.reason = reason or httputil.responses.get(code, &#39;Unknown&#39;)</span>
<span class="gi">+        self.reason = reason or httputil.responses.get(code, &quot;Unknown&quot;)</span>
<span class="w"> </span>        if headers is not None:
<span class="w"> </span>            self.headers = headers
<span class="w"> </span>        else:
<span class="w"> </span>            self.headers = httputil.HTTPHeaders()
<span class="w"> </span>        self.buffer = buffer
<span class="gd">-        self._body = None</span>
<span class="gi">+        self._body = None  # type: Optional[bytes]</span>
<span class="w"> </span>        if effective_url is None:
<span class="w"> </span>            self.effective_url = request.url
<span class="w"> </span>        else:
<span class="gu">@@ -500,8 +659,7 @@ class HTTPResponse(object):</span>
<span class="w"> </span>        if error is None:
<span class="w"> </span>            if self.code &lt; 200 or self.code &gt;= 300:
<span class="w"> </span>                self._error_is_response_code = True
<span class="gd">-                self.error = HTTPError(self.code, message=self.reason,</span>
<span class="gd">-                    response=self)</span>
<span class="gi">+                self.error = HTTPError(self.code, message=self.reason, response=self)</span>
<span class="w"> </span>            else:
<span class="w"> </span>                self.error = None
<span class="w"> </span>        else:
<span class="gu">@@ -510,13 +668,23 @@ class HTTPResponse(object):</span>
<span class="w"> </span>        self.request_time = request_time
<span class="w"> </span>        self.time_info = time_info or {}

<span class="gd">-    def rethrow(self) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def body(self) -&gt; bytes:</span>
<span class="gi">+        if self.buffer is None:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        elif self._body is None:</span>
<span class="gi">+            self._body = self.buffer.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+        return self._body</span>
<span class="gi">+</span>
<span class="gi">+    def rethrow(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;If there was an error on the request, raise an `HTTPError`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.error:</span>
<span class="gi">+            raise self.error</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        args = &#39;,&#39;.join(&#39;%s=%r&#39; % i for i in sorted(self.__dict__.items()))</span>
<span class="gd">-        return &#39;%s(%s)&#39; % (self.__class__.__name__, args)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        args = &quot;,&quot;.join(&quot;%s=%r&quot; % i for i in sorted(self.__dict__.items()))</span>
<span class="gi">+        return &quot;%s(%s)&quot; % (self.__class__.__name__, args)</span>


<span class="w"> </span>class HTTPClientError(Exception):
<span class="gu">@@ -540,15 +708,24 @@ class HTTPClientError(Exception):</span>
<span class="w"> </span>       as an alias.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, code: int, message: Optional[str]=None, response:</span>
<span class="gd">-        Optional[HTTPResponse]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        code: int,</span>
<span class="gi">+        message: Optional[str] = None,</span>
<span class="gi">+        response: Optional[HTTPResponse] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.code = code
<span class="gd">-        self.message = message or httputil.responses.get(code, &#39;Unknown&#39;)</span>
<span class="gi">+        self.message = message or httputil.responses.get(code, &quot;Unknown&quot;)</span>
<span class="w"> </span>        self.response = response
<span class="w"> </span>        super().__init__(code, message, response)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;HTTP %d: %s&#39; % (self.code, self.message)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;HTTP %d: %s&quot; % (self.code, self.message)</span>
<span class="gi">+</span>
<span class="gi">+    # There is a cyclic reference between self and self.response,</span>
<span class="gi">+    # which breaks the default __repr__ implementation.</span>
<span class="gi">+    # (especially on pypy, which doesn&#39;t have the same recursion</span>
<span class="gi">+    # detection as cpython).</span>
<span class="w"> </span>    __repr__ = __str__


<span class="gu">@@ -561,12 +738,13 @@ class _RequestProxy(object):</span>
<span class="w"> </span>    Used internally by AsyncHTTPClient implementations.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, request: HTTPRequest, defaults: Optional[Dict[str, Any]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, request: HTTPRequest, defaults: Optional[Dict[str, Any]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.request = request
<span class="w"> </span>        self.defaults = defaults

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        request_attr = getattr(self.request, name)
<span class="w"> </span>        if request_attr is not None:
<span class="w"> </span>            return request_attr
<span class="gu">@@ -576,5 +754,37 @@ class _RequestProxy(object):</span>
<span class="w"> </span>            return None


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+def main() -&gt; None:</span>
<span class="gi">+    from tornado.options import define, options, parse_command_line</span>
<span class="gi">+</span>
<span class="gi">+    define(&quot;print_headers&quot;, type=bool, default=False)</span>
<span class="gi">+    define(&quot;print_body&quot;, type=bool, default=True)</span>
<span class="gi">+    define(&quot;follow_redirects&quot;, type=bool, default=True)</span>
<span class="gi">+    define(&quot;validate_cert&quot;, type=bool, default=True)</span>
<span class="gi">+    define(&quot;proxy_host&quot;, type=str)</span>
<span class="gi">+    define(&quot;proxy_port&quot;, type=int)</span>
<span class="gi">+    args = parse_command_line()</span>
<span class="gi">+    client = HTTPClient()</span>
<span class="gi">+    for arg in args:</span>
<span class="gi">+        try:</span>
<span class="gi">+            response = client.fetch(</span>
<span class="gi">+                arg,</span>
<span class="gi">+                follow_redirects=options.follow_redirects,</span>
<span class="gi">+                validate_cert=options.validate_cert,</span>
<span class="gi">+                proxy_host=options.proxy_host,</span>
<span class="gi">+                proxy_port=options.proxy_port,</span>
<span class="gi">+            )</span>
<span class="gi">+        except HTTPError as e:</span>
<span class="gi">+            if e.response is not None:</span>
<span class="gi">+                response = e.response</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        if options.print_headers:</span>
<span class="gi">+            print(response.headers)</span>
<span class="gi">+        if options.print_body:</span>
<span class="gi">+            print(native_str(response.body))</span>
<span class="gi">+    client.close()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/tornado/httpserver.py b/tornado/httpserver.py</span>
<span class="gh">index 1a203b99..757f711b 100644</span>
<span class="gd">--- a/tornado/httpserver.py</span>
<span class="gi">+++ b/tornado/httpserver.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A non-blocking, single-threaded HTTP server.

<span class="w"> </span>Typical applications have little direct interaction with the `HTTPServer`
<span class="gu">@@ -9,8 +24,10 @@ class except to start a server at the beginning of the process</span>
<span class="w"> </span>   The ``HTTPRequest`` class that used to live in this module has been moved
<span class="w"> </span>   to `tornado.httputil.HTTPServerRequest`.  The old name remains as an alias.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="gi">+</span>
<span class="w"> </span>from tornado.escape import native_str
<span class="w"> </span>from tornado.http1connection import HTTP1ServerConnection, HTTP1ConnectionParameters
<span class="w"> </span>from tornado import httputil
<span class="gu">@@ -18,15 +35,16 @@ from tornado import iostream</span>
<span class="w"> </span>from tornado import netutil
<span class="w"> </span>from tornado.tcpserver import TCPServer
<span class="w"> </span>from tornado.util import Configurable
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Union, Any, Dict, Callable, List, Type, Tuple, Optional, Awaitable
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Set</span>
<span class="gi">+    from typing import Set  # noqa: F401</span>


<span class="gd">-class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;A non-blocking, single-threaded HTTP server.</span>
<span class="gi">+class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate):</span>
<span class="gi">+    r&quot;&quot;&quot;A non-blocking, single-threaded HTTP server.</span>

<span class="w"> </span>    A server is defined by a subclass of `.HTTPServerConnectionDelegate`,
<span class="w"> </span>    or, for backwards compatibility, a callback that takes an
<span class="gu">@@ -135,10 +153,67 @@ class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate</span>
<span class="w"> </span>       The ``io_loop`` argument has been removed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        # Ignore args to __init__; real initialization belongs in</span>
<span class="gi">+        # initialize since we&#39;re Configurable. (there&#39;s something</span>
<span class="gi">+        # weird in initialization order between this class,</span>
<span class="gi">+        # Configurable, and TCPServer so we can&#39;t leave __init__ out</span>
<span class="gi">+        # completely)</span>
<span class="w"> </span>        pass

<span class="gd">-    async def close_all_connections(self) -&gt;None:</span>
<span class="gi">+    def initialize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request_callback: Union[</span>
<span class="gi">+            httputil.HTTPServerConnectionDelegate,</span>
<span class="gi">+            Callable[[httputil.HTTPServerRequest], None],</span>
<span class="gi">+        ],</span>
<span class="gi">+        no_keep_alive: bool = False,</span>
<span class="gi">+        xheaders: bool = False,</span>
<span class="gi">+        ssl_options: Optional[Union[Dict[str, Any], ssl.SSLContext]] = None,</span>
<span class="gi">+        protocol: Optional[str] = None,</span>
<span class="gi">+        decompress_request: bool = False,</span>
<span class="gi">+        chunk_size: Optional[int] = None,</span>
<span class="gi">+        max_header_size: Optional[int] = None,</span>
<span class="gi">+        idle_connection_timeout: Optional[float] = None,</span>
<span class="gi">+        body_timeout: Optional[float] = None,</span>
<span class="gi">+        max_body_size: Optional[int] = None,</span>
<span class="gi">+        max_buffer_size: Optional[int] = None,</span>
<span class="gi">+        trusted_downstream: Optional[List[str]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # This method&#39;s signature is not extracted with autodoc</span>
<span class="gi">+        # because we want its arguments to appear on the class</span>
<span class="gi">+        # constructor. When changing this signature, also update the</span>
<span class="gi">+        # copy in httpserver.rst.</span>
<span class="gi">+        self.request_callback = request_callback</span>
<span class="gi">+        self.xheaders = xheaders</span>
<span class="gi">+        self.protocol = protocol</span>
<span class="gi">+        self.conn_params = HTTP1ConnectionParameters(</span>
<span class="gi">+            decompress=decompress_request,</span>
<span class="gi">+            chunk_size=chunk_size,</span>
<span class="gi">+            max_header_size=max_header_size,</span>
<span class="gi">+            header_timeout=idle_connection_timeout or 3600,</span>
<span class="gi">+            max_body_size=max_body_size,</span>
<span class="gi">+            body_timeout=body_timeout,</span>
<span class="gi">+            no_keep_alive=no_keep_alive,</span>
<span class="gi">+        )</span>
<span class="gi">+        TCPServer.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            ssl_options=ssl_options,</span>
<span class="gi">+            max_buffer_size=max_buffer_size,</span>
<span class="gi">+            read_chunk_size=chunk_size,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._connections = set()  # type: Set[HTTP1ServerConnection]</span>
<span class="gi">+        self.trusted_downstream = trusted_downstream</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_base(cls) -&gt; Type[Configurable]:</span>
<span class="gi">+        return HTTPServer</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_default(cls) -&gt; Type[Configurable]:</span>
<span class="gi">+        return HTTPServer</span>
<span class="gi">+</span>
<span class="gi">+    async def close_all_connections(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Close all open connections and asynchronously wait for them to finish.

<span class="w"> </span>        This method is used in combination with `~.TCPServer.stop` to
<span class="gu">@@ -152,72 +227,184 @@ class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate</span>
<span class="w"> </span>        Note that this method is a coroutine and must be called with ``await``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self._connections:</span>
<span class="gi">+            # Peek at an arbitrary element of the set</span>
<span class="gi">+            conn = next(iter(self._connections))</span>
<span class="gi">+            await conn.close()</span>
<span class="gi">+</span>
<span class="gi">+    def handle_stream(self, stream: iostream.IOStream, address: Tuple) -&gt; None:</span>
<span class="gi">+        context = _HTTPRequestContext(</span>
<span class="gi">+            stream, address, self.protocol, self.trusted_downstream</span>
<span class="gi">+        )</span>
<span class="gi">+        conn = HTTP1ServerConnection(stream, self.conn_params, context)</span>
<span class="gi">+        self._connections.add(conn)</span>
<span class="gi">+        conn.start_serving(self)</span>
<span class="gi">+</span>
<span class="gi">+    def start_request(</span>
<span class="gi">+        self, server_conn: object, request_conn: httputil.HTTPConnection</span>
<span class="gi">+    ) -&gt; httputil.HTTPMessageDelegate:</span>
<span class="gi">+        if isinstance(self.request_callback, httputil.HTTPServerConnectionDelegate):</span>
<span class="gi">+            delegate = self.request_callback.start_request(server_conn, request_conn)</span>
<span class="gi">+        else:</span>
<span class="gi">+            delegate = _CallableAdapter(self.request_callback, request_conn)</span>

<span class="gi">+        if self.xheaders:</span>
<span class="gi">+            delegate = _ProxyAdapter(delegate, request_conn)</span>

<span class="gd">-class _CallableAdapter(httputil.HTTPMessageDelegate):</span>
<span class="gi">+        return delegate</span>

<span class="gd">-    def __init__(self, request_callback: Callable[[httputil.</span>
<span class="gd">-        HTTPServerRequest], None], request_conn: httputil.HTTPConnection</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def on_close(self, server_conn: object) -&gt; None:</span>
<span class="gi">+        self._connections.remove(typing.cast(HTTP1ServerConnection, server_conn))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _CallableAdapter(httputil.HTTPMessageDelegate):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request_callback: Callable[[httputil.HTTPServerRequest], None],</span>
<span class="gi">+        request_conn: httputil.HTTPConnection,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.connection = request_conn
<span class="w"> </span>        self.request_callback = request_callback
<span class="gd">-        self.request = None</span>
<span class="gi">+        self.request = None  # type: Optional[httputil.HTTPServerRequest]</span>
<span class="w"> </span>        self.delegate = None
<span class="gd">-        self._chunks = []</span>
<span class="gi">+        self._chunks = []  # type: List[bytes]</span>
<span class="gi">+</span>
<span class="gi">+    def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        self.request = httputil.HTTPServerRequest(</span>
<span class="gi">+            connection=self.connection,</span>
<span class="gi">+            start_line=typing.cast(httputil.RequestStartLine, start_line),</span>
<span class="gi">+            headers=headers,</span>
<span class="gi">+        )</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, chunk: bytes) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        self._chunks.append(chunk)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        assert self.request is not None</span>
<span class="gi">+        self.request.body = b&quot;&quot;.join(self._chunks)</span>
<span class="gi">+        self.request._parse_body()</span>
<span class="gi">+        self.request_callback(self.request)</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        del self._chunks</span>


<span class="w"> </span>class _HTTPRequestContext(object):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, stream: iostream.IOStream, address: Tuple, protocol:</span>
<span class="gd">-        Optional[str], trusted_downstream: Optional[List[str]]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream: iostream.IOStream,</span>
<span class="gi">+        address: Tuple,</span>
<span class="gi">+        protocol: Optional[str],</span>
<span class="gi">+        trusted_downstream: Optional[List[str]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.address = address
<span class="gi">+        # Save the socket&#39;s address family now so we know how to</span>
<span class="gi">+        # interpret self.address even after the stream is closed</span>
<span class="gi">+        # and its socket attribute replaced with None.</span>
<span class="w"> </span>        if stream.socket is not None:
<span class="w"> </span>            self.address_family = stream.socket.family
<span class="w"> </span>        else:
<span class="w"> </span>            self.address_family = None
<span class="gd">-        if self.address_family in (socket.AF_INET, socket.AF_INET6</span>
<span class="gd">-            ) and address is not None:</span>
<span class="gi">+        # In HTTPServerRequest we want an IP, not a full socket address.</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.address_family in (socket.AF_INET, socket.AF_INET6)</span>
<span class="gi">+            and address is not None</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            self.remote_ip = address[0]
<span class="w"> </span>        else:
<span class="gd">-            self.remote_ip = &#39;0.0.0.0&#39;</span>
<span class="gi">+            # Unix (or other) socket; fake the remote address.</span>
<span class="gi">+            self.remote_ip = &quot;0.0.0.0&quot;</span>
<span class="w"> </span>        if protocol:
<span class="w"> </span>            self.protocol = protocol
<span class="w"> </span>        elif isinstance(stream, iostream.SSLIOStream):
<span class="gd">-            self.protocol = &#39;https&#39;</span>
<span class="gi">+            self.protocol = &quot;https&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            self.protocol = &#39;http&#39;</span>
<span class="gi">+            self.protocol = &quot;http&quot;</span>
<span class="w"> </span>        self._orig_remote_ip = self.remote_ip
<span class="w"> </span>        self._orig_protocol = self.protocol
<span class="w"> </span>        self.trusted_downstream = set(trusted_downstream or [])

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if self.address_family in (socket.AF_INET, socket.AF_INET6):
<span class="w"> </span>            return self.remote_ip
<span class="w"> </span>        elif isinstance(self.address, bytes):
<span class="gi">+            # Python 3 with the -bb option warns about str(bytes),</span>
<span class="gi">+            # so convert it explicitly.</span>
<span class="gi">+            # Unix socket addresses are str on mac but bytes on linux.</span>
<span class="w"> </span>            return native_str(self.address)
<span class="w"> </span>        else:
<span class="w"> </span>            return str(self.address)

<span class="gd">-    def _apply_xheaders(self, headers: httputil.HTTPHeaders) -&gt;None:</span>
<span class="gi">+    def _apply_xheaders(self, headers: httputil.HTTPHeaders) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Rewrite the ``remote_ip`` and ``protocol`` fields.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _unapply_xheaders(self) -&gt;None:</span>
<span class="gi">+        # Squid uses X-Forwarded-For, others use X-Real-Ip</span>
<span class="gi">+        ip = headers.get(&quot;X-Forwarded-For&quot;, self.remote_ip)</span>
<span class="gi">+        # Skip trusted downstream hosts in X-Forwarded-For list</span>
<span class="gi">+        for ip in (cand.strip() for cand in reversed(ip.split(&quot;,&quot;))):</span>
<span class="gi">+            if ip not in self.trusted_downstream:</span>
<span class="gi">+                break</span>
<span class="gi">+        ip = headers.get(&quot;X-Real-Ip&quot;, ip)</span>
<span class="gi">+        if netutil.is_valid_ip(ip):</span>
<span class="gi">+            self.remote_ip = ip</span>
<span class="gi">+        # AWS uses X-Forwarded-Proto</span>
<span class="gi">+        proto_header = headers.get(</span>
<span class="gi">+            &quot;X-Scheme&quot;, headers.get(&quot;X-Forwarded-Proto&quot;, self.protocol)</span>
<span class="gi">+        )</span>
<span class="gi">+        if proto_header:</span>
<span class="gi">+            # use only the last proto entry if there is more than one</span>
<span class="gi">+            # TODO: support trusting multiple layers of proxied protocol</span>
<span class="gi">+            proto_header = proto_header.split(&quot;,&quot;)[-1].strip()</span>
<span class="gi">+        if proto_header in (&quot;http&quot;, &quot;https&quot;):</span>
<span class="gi">+            self.protocol = proto_header</span>
<span class="gi">+</span>
<span class="gi">+    def _unapply_xheaders(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Undo changes from `_apply_xheaders`.

<span class="w"> </span>        Xheaders are per-request so they should not leak to the next
<span class="w"> </span>        request on the same connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.remote_ip = self._orig_remote_ip</span>
<span class="gi">+        self.protocol = self._orig_protocol</span>


<span class="w"> </span>class _ProxyAdapter(httputil.HTTPMessageDelegate):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, delegate: httputil.HTTPMessageDelegate, request_conn:</span>
<span class="gd">-        httputil.HTTPConnection) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        delegate: httputil.HTTPMessageDelegate,</span>
<span class="gi">+        request_conn: httputil.HTTPConnection,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.connection = request_conn
<span class="w"> </span>        self.delegate = delegate

<span class="gi">+    def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        # TODO: either make context an official part of the</span>
<span class="gi">+        # HTTPConnection interface or figure out some other way to do this.</span>
<span class="gi">+        self.connection.context._apply_xheaders(headers)  # type: ignore</span>
<span class="gi">+        return self.delegate.headers_received(start_line, headers)</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, chunk: bytes) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        return self.delegate.data_received(chunk)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        self.delegate.finish()</span>
<span class="gi">+        self._cleanup()</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        self.delegate.on_connection_close()</span>
<span class="gi">+        self._cleanup()</span>
<span class="gi">+</span>
<span class="gi">+    def _cleanup(self) -&gt; None:</span>
<span class="gi">+        self.connection.context._unapply_xheaders()  # type: ignore</span>
<span class="gi">+</span>

<span class="w"> </span>HTTPRequest = httputil.HTTPServerRequest
<span class="gh">diff --git a/tornado/httputil.py b/tornado/httputil.py</span>
<span class="gh">index 907aef4e..9ce992d8 100644</span>
<span class="gd">--- a/tornado/httputil.py</span>
<span class="gi">+++ b/tornado/httputil.py</span>
<span class="gu">@@ -1,8 +1,24 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;HTTP utility code shared by clients and servers.

<span class="w"> </span>This module also defines the `HTTPServerRequest` class which is exposed
<span class="w"> </span>via `tornado.web.RequestHandler.request`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import calendar
<span class="w"> </span>import collections.abc
<span class="w"> </span>import copy
<span class="gu">@@ -16,27 +32,48 @@ from ssl import SSLError</span>
<span class="w"> </span>import time
<span class="w"> </span>import unicodedata
<span class="w"> </span>from urllib.parse import urlencode, urlparse, urlunparse, parse_qsl
<span class="gi">+</span>
<span class="w"> </span>from tornado.escape import native_str, parse_qs_bytes, utf8
<span class="w"> </span>from tornado.log import gen_log
<span class="w"> </span>from tornado.util import ObjectDict, unicode_type
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# responses is unused in this file, but we re-export it to other files.</span>
<span class="gi">+# Reference it so pyflakes doesn&#39;t complain.</span>
<span class="w"> </span>responses
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gd">-from typing import Tuple, Iterable, List, Mapping, Iterator, Dict, Union, Optional, Awaitable, Generator, AnyStr</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Awaitable,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    AnyStr,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Deque</span>
<span class="gd">-    from asyncio import Future</span>
<span class="gd">-    import unittest</span>
<span class="gd">-HTTP_WHITESPACE = &#39; \t&#39;</span>
<span class="gi">+    from typing import Deque  # noqa: F401</span>
<span class="gi">+    from asyncio import Future  # noqa: F401</span>
<span class="gi">+    import unittest  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+# To be used with str.strip() and related methods.</span>
<span class="gi">+HTTP_WHITESPACE = &quot; \t&quot;</span>


<span class="w"> </span>@lru_cache(1000)
<span class="gd">-def _normalize_header(name: str) -&gt;str:</span>
<span class="gi">+def _normalize_header(name: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Map a header name to Http-Header-Case.

<span class="w"> </span>    &gt;&gt;&gt; _normalize_header(&quot;coNtent-TYPE&quot;)
<span class="w"> </span>    &#39;Content-Type&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &quot;-&quot;.join([w.capitalize() for w in name.split(&quot;-&quot;)])</span>


<span class="w"> </span>class HTTPHeaders(collections.abc.MutableMapping):
<span class="gu">@@ -69,49 +106,63 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @typing.overload
<span class="gd">-    def __init__(self, __arg: Mapping[str, List[str]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, __arg: Mapping[str, List[str]]) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    @typing.overload</span>
<span class="gd">-    def __init__(self, __arg: Mapping[str, str]) -&gt;None:</span>
<span class="gi">+    @typing.overload  # noqa: F811</span>
<span class="gi">+    def __init__(self, __arg: Mapping[str, str]) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    @typing.overload</span>
<span class="gd">-    def __init__(self, *args: Tuple[str, str]) -&gt;None:</span>
<span class="gi">+    @typing.overload  # noqa: F811</span>
<span class="gi">+    def __init__(self, *args: Tuple[str, str]) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    @typing.overload</span>
<span class="gd">-    def __init__(self, **kwargs: str) -&gt;None:</span>
<span class="gi">+    @typing.overload  # noqa: F811</span>
<span class="gi">+    def __init__(self, **kwargs: str) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def __init__(self, *args: typing.Any, **kwargs: str) -&gt;None:</span>
<span class="gd">-        self._dict = {}</span>
<span class="gd">-        self._as_list = {}</span>
<span class="gd">-        self._last_key = None</span>
<span class="gd">-        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0],</span>
<span class="gd">-            HTTPHeaders):</span>
<span class="gi">+    def __init__(self, *args: typing.Any, **kwargs: str) -&gt; None:  # noqa: F811</span>
<span class="gi">+        self._dict = {}  # type: typing.Dict[str, str]</span>
<span class="gi">+        self._as_list = {}  # type: typing.Dict[str, typing.List[str]]</span>
<span class="gi">+        self._last_key = None  # type: Optional[str]</span>
<span class="gi">+        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], HTTPHeaders):</span>
<span class="gi">+            # Copy constructor</span>
<span class="w"> </span>            for k, v in args[0].get_all():
<span class="w"> </span>                self.add(k, v)
<span class="w"> </span>        else:
<span class="gi">+            # Dict-style initialization</span>
<span class="w"> </span>            self.update(*args, **kwargs)

<span class="gd">-    def add(self, name: str, value: str) -&gt;None:</span>
<span class="gi">+    # new public methods</span>
<span class="gi">+</span>
<span class="gi">+    def add(self, name: str, value: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a new value for the given key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        norm_name = _normalize_header(name)</span>
<span class="gi">+        self._last_key = norm_name</span>
<span class="gi">+        if norm_name in self:</span>
<span class="gi">+            self._dict[norm_name] = (</span>
<span class="gi">+                native_str(self[norm_name]) + &quot;,&quot; + native_str(value)</span>
<span class="gi">+            )</span>
<span class="gi">+            self._as_list[norm_name].append(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self[norm_name] = value</span>

<span class="gd">-    def get_list(self, name: str) -&gt;List[str]:</span>
<span class="gi">+    def get_list(self, name: str) -&gt; List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns all values for the given header as a list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        norm_name = _normalize_header(name)</span>
<span class="gi">+        return self._as_list.get(norm_name, [])</span>

<span class="gd">-    def get_all(self) -&gt;Iterable[Tuple[str, str]]:</span>
<span class="gi">+    def get_all(self) -&gt; Iterable[Tuple[str, str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterable of all (name, value) pairs.

<span class="w"> </span>        If a header has multiple values, multiple pairs will be
<span class="w"> </span>        returned with the same name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, values in self._as_list.items():</span>
<span class="gi">+            for value in values:</span>
<span class="gi">+                yield (name, value)</span>

<span class="gd">-    def parse_line(self, line: str) -&gt;None:</span>
<span class="gi">+    def parse_line(self, line: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Updates the dictionary with a single header line.

<span class="w"> </span>        &gt;&gt;&gt; h = HTTPHeaders()
<span class="gu">@@ -119,10 +170,22 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>
<span class="w"> </span>        &gt;&gt;&gt; h.get(&#39;content-type&#39;)
<span class="w"> </span>        &#39;text/html&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if line[0].isspace():</span>
<span class="gi">+            # continuation of a multi-line header</span>
<span class="gi">+            if self._last_key is None:</span>
<span class="gi">+                raise HTTPInputError(&quot;first header line cannot start with whitespace&quot;)</span>
<span class="gi">+            new_part = &quot; &quot; + line.lstrip(HTTP_WHITESPACE)</span>
<span class="gi">+            self._as_list[self._last_key][-1] += new_part</span>
<span class="gi">+            self._dict[self._last_key] += new_part</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                name, value = line.split(&quot;:&quot;, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise HTTPInputError(&quot;no colon in header line&quot;)</span>
<span class="gi">+            self.add(name, value.strip(HTTP_WHITESPACE))</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def parse(cls, headers: str) -&gt;&#39;HTTPHeaders&#39;:</span>
<span class="gi">+    def parse(cls, headers: str) -&gt; &quot;HTTPHeaders&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a dictionary from HTTP header text.

<span class="w"> </span>        &gt;&gt;&gt; h = HTTPHeaders.parse(&quot;Content-Type: text/html\\r\\nContent-Length: 42\\r\\n&quot;)
<span class="gu">@@ -135,33 +198,52 @@ class HTTPHeaders(collections.abc.MutableMapping):</span>
<span class="w"> </span>           mix of `KeyError`, and `ValueError`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __setitem__(self, name: str, value: str) -&gt;None:</span>
<span class="gi">+        h = cls()</span>
<span class="gi">+        # RFC 7230 section 3.5: a recipient MAY recognize a single LF as a line</span>
<span class="gi">+        # terminator and ignore any preceding CR.</span>
<span class="gi">+        for line in headers.split(&quot;\n&quot;):</span>
<span class="gi">+            if line.endswith(&quot;\r&quot;):</span>
<span class="gi">+                line = line[:-1]</span>
<span class="gi">+            if line:</span>
<span class="gi">+                h.parse_line(line)</span>
<span class="gi">+        return h</span>
<span class="gi">+</span>
<span class="gi">+    # MutableMapping abstract method implementations.</span>
<span class="gi">+</span>
<span class="gi">+    def __setitem__(self, name: str, value: str) -&gt; None:</span>
<span class="w"> </span>        norm_name = _normalize_header(name)
<span class="w"> </span>        self._dict[norm_name] = value
<span class="w"> </span>        self._as_list[norm_name] = [value]

<span class="gd">-    def __getitem__(self, name: str) -&gt;str:</span>
<span class="gi">+    def __getitem__(self, name: str) -&gt; str:</span>
<span class="w"> </span>        return self._dict[_normalize_header(name)]

<span class="gd">-    def __delitem__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        norm_name = _normalize_header(name)
<span class="w"> </span>        del self._dict[norm_name]
<span class="w"> </span>        del self._as_list[norm_name]

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._dict)

<span class="gd">-    def __iter__(self) -&gt;Iterator[typing.Any]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[typing.Any]:</span>
<span class="w"> </span>        return iter(self._dict)
<span class="gi">+</span>
<span class="gi">+    def copy(self) -&gt; &quot;HTTPHeaders&quot;:</span>
<span class="gi">+        # defined in dict but not in MutableMapping.</span>
<span class="gi">+        return HTTPHeaders(self)</span>
<span class="gi">+</span>
<span class="gi">+    # Use our overridden copy method for the copy.copy module.</span>
<span class="gi">+    # This makes shallow copies one level deeper, but preserves</span>
<span class="gi">+    # the appearance that HTTPHeaders is a single container.</span>
<span class="w"> </span>    __copy__ = copy

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        lines = []
<span class="w"> </span>        for name, value in self.get_all():
<span class="gd">-            lines.append(&#39;%s: %s\n&#39; % (name, value))</span>
<span class="gd">-        return &#39;&#39;.join(lines)</span>
<span class="gi">+            lines.append(&quot;%s: %s\n&quot; % (name, value))</span>
<span class="gi">+        return &quot;&quot;.join(lines)</span>
<span class="gi">+</span>
<span class="w"> </span>    __unicode__ = __str__


<span class="gu">@@ -257,54 +339,90 @@ class HTTPServerRequest(object):</span>
<span class="w"> </span>    .. versionchanged:: 4.0
<span class="w"> </span>       Moved from ``tornado.httpserver.HTTPRequest``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    path = None</span>
<span class="gd">-    query = None</span>
<span class="gd">-    _body_future = None</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, method: Optional[str]=None, uri: Optional[str]=None,</span>
<span class="gd">-        version: str=&#39;HTTP/1.0&#39;, headers: Optional[HTTPHeaders]=None, body:</span>
<span class="gd">-        Optional[bytes]=None, host: Optional[str]=None, files: Optional[</span>
<span class="gd">-        Dict[str, List[&#39;HTTPFile&#39;]]]=None, connection: Optional[</span>
<span class="gd">-        &#39;HTTPConnection&#39;]=None, start_line: Optional[&#39;RequestStartLine&#39;]=</span>
<span class="gd">-        None, server_connection: Optional[object]=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    path = None  # type: str</span>
<span class="gi">+    query = None  # type: str</span>
<span class="gi">+</span>
<span class="gi">+    # HACK: Used for stream_request_body</span>
<span class="gi">+    _body_future = None  # type: Future[None]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        method: Optional[str] = None,</span>
<span class="gi">+        uri: Optional[str] = None,</span>
<span class="gi">+        version: str = &quot;HTTP/1.0&quot;,</span>
<span class="gi">+        headers: Optional[HTTPHeaders] = None,</span>
<span class="gi">+        body: Optional[bytes] = None,</span>
<span class="gi">+        host: Optional[str] = None,</span>
<span class="gi">+        files: Optional[Dict[str, List[&quot;HTTPFile&quot;]]] = None,</span>
<span class="gi">+        connection: Optional[&quot;HTTPConnection&quot;] = None,</span>
<span class="gi">+        start_line: Optional[&quot;RequestStartLine&quot;] = None,</span>
<span class="gi">+        server_connection: Optional[object] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if start_line is not None:
<span class="w"> </span>            method, uri, version = start_line
<span class="w"> </span>        self.method = method
<span class="w"> </span>        self.uri = uri
<span class="w"> </span>        self.version = version
<span class="w"> </span>        self.headers = headers or HTTPHeaders()
<span class="gd">-        self.body = body or b&#39;&#39;</span>
<span class="gd">-        context = getattr(connection, &#39;context&#39;, None)</span>
<span class="gd">-        self.remote_ip = getattr(context, &#39;remote_ip&#39;, None)</span>
<span class="gd">-        self.protocol = getattr(context, &#39;protocol&#39;, &#39;http&#39;)</span>
<span class="gd">-        self.host = host or self.headers.get(&#39;Host&#39;) or &#39;127.0.0.1&#39;</span>
<span class="gi">+        self.body = body or b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # set remote IP and protocol</span>
<span class="gi">+        context = getattr(connection, &quot;context&quot;, None)</span>
<span class="gi">+        self.remote_ip = getattr(context, &quot;remote_ip&quot;, None)</span>
<span class="gi">+        self.protocol = getattr(context, &quot;protocol&quot;, &quot;http&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.host = host or self.headers.get(&quot;Host&quot;) or &quot;127.0.0.1&quot;</span>
<span class="w"> </span>        self.host_name = split_host_and_port(self.host.lower())[0]
<span class="w"> </span>        self.files = files or {}
<span class="w"> </span>        self.connection = connection
<span class="w"> </span>        self.server_connection = server_connection
<span class="w"> </span>        self._start_time = time.time()
<span class="w"> </span>        self._finish_time = None
<span class="gi">+</span>
<span class="w"> </span>        if uri is not None:
<span class="gd">-            self.path, sep, self.query = uri.partition(&#39;?&#39;)</span>
<span class="gi">+            self.path, sep, self.query = uri.partition(&quot;?&quot;)</span>
<span class="w"> </span>        self.arguments = parse_qs_bytes(self.query, keep_blank_values=True)
<span class="w"> </span>        self.query_arguments = copy.deepcopy(self.arguments)
<span class="gd">-        self.body_arguments = {}</span>
<span class="gi">+        self.body_arguments = {}  # type: Dict[str, List[bytes]]</span>

<span class="w"> </span>    @property
<span class="gd">-    def cookies(self) -&gt;Dict[str, http.cookies.Morsel]:</span>
<span class="gi">+    def cookies(self) -&gt; Dict[str, http.cookies.Morsel]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A dictionary of ``http.cookies.Morsel`` objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def full_url(self) -&gt;str:</span>
<span class="gi">+        if not hasattr(self, &quot;_cookies&quot;):</span>
<span class="gi">+            self._cookies = (</span>
<span class="gi">+                http.cookies.SimpleCookie()</span>
<span class="gi">+            )  # type: http.cookies.SimpleCookie</span>
<span class="gi">+            if &quot;Cookie&quot; in self.headers:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    parsed = parse_cookie(self.headers[&quot;Cookie&quot;])</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    for k, v in parsed.items():</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            self._cookies[k] = v</span>
<span class="gi">+                        except Exception:</span>
<span class="gi">+                            # SimpleCookie imposes some restrictions on keys;</span>
<span class="gi">+                            # parse_cookie does not. Discard any cookies</span>
<span class="gi">+                            # with disallowed keys.</span>
<span class="gi">+                            pass</span>
<span class="gi">+        return self._cookies</span>
<span class="gi">+</span>
<span class="gi">+    def full_url(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reconstructs the full URL for this request.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.protocol + &quot;://&quot; + self.host + self.uri  # type: ignore[operator]</span>

<span class="gd">-    def request_time(self) -&gt;float:</span>
<span class="gi">+    def request_time(self) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the amount of time it took for this request to execute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._finish_time is None:</span>
<span class="gi">+            return time.time() - self._start_time</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._finish_time - self._start_time</span>

<span class="gd">-    def get_ssl_certificate(self, binary_form: bool=False) -&gt;Union[None,</span>
<span class="gd">-        Dict, bytes]:</span>
<span class="gi">+    def get_ssl_certificate(</span>
<span class="gi">+        self, binary_form: bool = False</span>
<span class="gi">+    ) -&gt; Union[None, Dict, bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the client&#39;s SSL certificate, if any.

<span class="w"> </span>        To use client certificates, the HTTPServer&#39;s
<span class="gu">@@ -323,12 +441,32 @@ class HTTPServerRequest(object):</span>
<span class="w"> </span>        details.
<span class="w"> </span>        http://docs.python.org/library/ssl.html#sslsocket-objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        attrs = &#39;protocol&#39;, &#39;host&#39;, &#39;method&#39;, &#39;uri&#39;, &#39;version&#39;, &#39;remote_ip&#39;</span>
<span class="gd">-        args = &#39;, &#39;.join([(&#39;%s=%r&#39; % (n, getattr(self, n))) for n in attrs])</span>
<span class="gd">-        return &#39;%s(%s)&#39; % (self.__class__.__name__, args)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.connection is None:</span>
<span class="gi">+                return None</span>
<span class="gi">+            # TODO: add a method to HTTPConnection for this so it can work with HTTP/2</span>
<span class="gi">+            return self.connection.stream.socket.getpeercert(  # type: ignore</span>
<span class="gi">+                binary_form=binary_form</span>
<span class="gi">+            )</span>
<span class="gi">+        except SSLError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_body(self) -&gt; None:</span>
<span class="gi">+        parse_body_arguments(</span>
<span class="gi">+            self.headers.get(&quot;Content-Type&quot;, &quot;&quot;),</span>
<span class="gi">+            self.body,</span>
<span class="gi">+            self.body_arguments,</span>
<span class="gi">+            self.files,</span>
<span class="gi">+            self.headers,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for k, v in self.body_arguments.items():</span>
<span class="gi">+            self.arguments.setdefault(k, []).extend(v)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        attrs = (&quot;protocol&quot;, &quot;host&quot;, &quot;method&quot;, &quot;uri&quot;, &quot;version&quot;, &quot;remote_ip&quot;)</span>
<span class="gi">+        args = &quot;, &quot;.join([&quot;%s=%r&quot; % (n, getattr(self, n)) for n in attrs])</span>
<span class="gi">+        return &quot;%s(%s)&quot; % (self.__class__.__name__, args)</span>


<span class="w"> </span>class HTTPInputError(Exception):
<span class="gu">@@ -337,6 +475,7 @@ class HTTPInputError(Exception):</span>

<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -345,6 +484,7 @@ class HTTPOutputError(Exception):</span>

<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -354,8 +494,9 @@ class HTTPServerConnectionDelegate(object):</span>
<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def start_request(self, server_conn: object, request_conn: &#39;HTTPConnection&#39;</span>
<span class="gd">-        ) -&gt;&#39;HTTPMessageDelegate&#39;:</span>
<span class="gi">+    def start_request(</span>
<span class="gi">+        self, server_conn: object, request_conn: &quot;HTTPConnection&quot;</span>
<span class="gi">+    ) -&gt; &quot;HTTPMessageDelegate&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is called by the server when a new request has started.

<span class="w"> </span>        :arg server_conn: is an opaque object representing the long-lived
<span class="gu">@@ -365,9 +506,9 @@ class HTTPServerConnectionDelegate(object):</span>

<span class="w"> </span>        This method should return a `.HTTPMessageDelegate`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def on_close(self, server_conn: object) -&gt;None:</span>
<span class="gi">+    def on_close(self, server_conn: object) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is called when a connection has been closed.

<span class="w"> </span>        :arg server_conn: is a server connection that has previously been
<span class="gu">@@ -382,9 +523,12 @@ class HTTPMessageDelegate(object):</span>
<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def headers_received(self, start_line: Union[&#39;RequestStartLine&#39;,</span>
<span class="gd">-        &#39;ResponseStartLine&#39;], headers: HTTPHeaders) -&gt;Optional[Awaitable[None]</span>
<span class="gd">-        ]:</span>
<span class="gi">+    # TODO: genericize this class to avoid exposing the Union.</span>
<span class="gi">+    def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[&quot;RequestStartLine&quot;, &quot;ResponseStartLine&quot;],</span>
<span class="gi">+        headers: HTTPHeaders,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called when the HTTP headers have been received and parsed.

<span class="w"> </span>        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`
<span class="gu">@@ -399,18 +543,18 @@ class HTTPMessageDelegate(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def data_received(self, chunk: bytes) -&gt;Optional[Awaitable[None]]:</span>
<span class="gi">+    def data_received(self, chunk: bytes) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called when a chunk of data has been received.

<span class="w"> </span>        May return a `.Future` for flow control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def finish(self) -&gt;None:</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called after the last chunk of data has been received.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def on_connection_close(self) -&gt;None:</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called if the connection is closed without finishing the request.

<span class="w"> </span>        If ``headers_received`` is called, either ``finish`` or
<span class="gu">@@ -425,9 +569,12 @@ class HTTPConnection(object):</span>
<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def write_headers(self, start_line: Union[&#39;RequestStartLine&#39;,</span>
<span class="gd">-        &#39;ResponseStartLine&#39;], headers: HTTPHeaders, chunk: Optional[bytes]=None</span>
<span class="gd">-        ) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    def write_headers(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[&quot;RequestStartLine&quot;, &quot;ResponseStartLine&quot;],</span>
<span class="gi">+        headers: HTTPHeaders,</span>
<span class="gi">+        chunk: Optional[bytes] = None,</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write an HTTP header block.

<span class="w"> </span>        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`.
<span class="gu">@@ -444,9 +591,9 @@ class HTTPConnection(object):</span>

<span class="w"> </span>           The ``callback`` argument was removed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def write(self, chunk: bytes) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    def write(self, chunk: bytes) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a chunk of body data.

<span class="w"> </span>        Returns a future for flow control.
<span class="gu">@@ -455,15 +602,19 @@ class HTTPConnection(object):</span>

<span class="w"> </span>           The ``callback`` argument was removed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def finish(self) -&gt;None:</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Indicates that the last body data has been written.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>


<span class="gd">-def url_concat(url: str, args: Union[None, Dict[str, str], List[Tuple[str,</span>
<span class="gd">-    str]], Tuple[Tuple[str, str], ...]]) -&gt;str:</span>
<span class="gi">+def url_concat(</span>
<span class="gi">+    url: str,</span>
<span class="gi">+    args: Union[</span>
<span class="gi">+        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]</span>
<span class="gi">+    ],</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Concatenate url and arguments regardless of whether
<span class="w"> </span>    url has existing query parameters.

<span class="gu">@@ -477,7 +628,32 @@ def url_concat(url: str, args: Union[None, Dict[str, str], List[Tuple[str,</span>
<span class="w"> </span>    &gt;&gt;&gt; url_concat(&quot;http://example.com/foo?a=b&quot;, [(&quot;c&quot;, &quot;d&quot;), (&quot;c&quot;, &quot;d2&quot;)])
<span class="w"> </span>    &#39;http://example.com/foo?a=b&amp;c=d&amp;c=d2&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if args is None:</span>
<span class="gi">+        return url</span>
<span class="gi">+    parsed_url = urlparse(url)</span>
<span class="gi">+    if isinstance(args, dict):</span>
<span class="gi">+        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)</span>
<span class="gi">+        parsed_query.extend(args.items())</span>
<span class="gi">+    elif isinstance(args, list) or isinstance(args, tuple):</span>
<span class="gi">+        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)</span>
<span class="gi">+        parsed_query.extend(args)</span>
<span class="gi">+    else:</span>
<span class="gi">+        err = &quot;&#39;args&#39; parameter should be dict, list or tuple. Not {0}&quot;.format(</span>
<span class="gi">+            type(args)</span>
<span class="gi">+        )</span>
<span class="gi">+        raise TypeError(err)</span>
<span class="gi">+    final_query = urlencode(parsed_query)</span>
<span class="gi">+    url = urlunparse(</span>
<span class="gi">+        (</span>
<span class="gi">+            parsed_url[0],</span>
<span class="gi">+            parsed_url[1],</span>
<span class="gi">+            parsed_url[2],</span>
<span class="gi">+            parsed_url[3],</span>
<span class="gi">+            final_query,</span>
<span class="gi">+            parsed_url[5],</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    return url</span>


<span class="w"> </span>class HTTPFile(ObjectDict):
<span class="gu">@@ -490,13 +666,15 @@ class HTTPFile(ObjectDict):</span>
<span class="w"> </span>    * ``body``
<span class="w"> </span>    * ``content_type``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    filename: str
<span class="w"> </span>    body: bytes
<span class="w"> </span>    content_type: str


<span class="gd">-def _parse_request_range(range_header: str) -&gt;Optional[Tuple[Optional[int],</span>
<span class="gd">-    Optional[int]]]:</span>
<span class="gi">+def _parse_request_range(</span>
<span class="gi">+    range_header: str,</span>
<span class="gi">+) -&gt; Optional[Tuple[Optional[int], Optional[int]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses a Range header.

<span class="w"> </span>    Returns either ``None`` or tuple ``(start, end)``.
<span class="gu">@@ -525,11 +703,27 @@ def _parse_request_range(range_header: str) -&gt;Optional[Tuple[Optional[int],</span>

<span class="w"> </span>    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unit, _, value = range_header.partition(&quot;=&quot;)</span>
<span class="gi">+    unit, value = unit.strip(), value.strip()</span>
<span class="gi">+    if unit != &quot;bytes&quot;:</span>
<span class="gi">+        return None</span>
<span class="gi">+    start_b, _, end_b = value.partition(&quot;-&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        start = _int_or_none(start_b)</span>
<span class="gi">+        end = _int_or_none(end_b)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if end is not None:</span>
<span class="gi">+        if start is None:</span>
<span class="gi">+            if end != 0:</span>
<span class="gi">+                start = -end</span>
<span class="gi">+                end = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            end += 1</span>
<span class="gi">+    return (start, end)</span>


<span class="gd">-def _get_content_range(start: Optional[int], end: Optional[int], total: int</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def _get_content_range(start: Optional[int], end: Optional[int], total: int) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a suitable Content-Range header:

<span class="w"> </span>    &gt;&gt;&gt; print(_get_content_range(None, 1, 4))
<span class="gu">@@ -539,12 +733,25 @@ def _get_content_range(start: Optional[int], end: Optional[int], total: int</span>
<span class="w"> </span>    &gt;&gt;&gt; print(_get_content_range(None, None, 4))
<span class="w"> </span>    bytes 0-3/4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    start = start or 0</span>
<span class="gi">+    end = (end or total) - 1</span>
<span class="gi">+    return &quot;bytes %s-%s/%s&quot; % (start, end, total)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _int_or_none(val: str) -&gt; Optional[int]:</span>
<span class="gi">+    val = val.strip()</span>
<span class="gi">+    if val == &quot;&quot;:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return int(val)</span>


<span class="gd">-def parse_body_arguments(content_type: str, body: bytes, arguments: Dict[</span>
<span class="gd">-    str, List[bytes]], files: Dict[str, List[HTTPFile]], headers: Optional[</span>
<span class="gd">-    HTTPHeaders]=None) -&gt;None:</span>
<span class="gi">+def parse_body_arguments(</span>
<span class="gi">+    content_type: str,</span>
<span class="gi">+    body: bytes,</span>
<span class="gi">+    arguments: Dict[str, List[bytes]],</span>
<span class="gi">+    files: Dict[str, List[HTTPFile]],</span>
<span class="gi">+    headers: Optional[HTTPHeaders] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses a form request body.

<span class="w"> </span>    Supports ``application/x-www-form-urlencoded`` and
<span class="gu">@@ -553,11 +760,46 @@ def parse_body_arguments(content_type: str, body: bytes, arguments: Dict[</span>
<span class="w"> </span>    and ``files`` parameters are dictionaries that will be updated
<span class="w"> </span>    with the parsed contents.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_multipart_form_data(boundary: bytes, data: bytes, arguments: Dict</span>
<span class="gd">-    [str, List[bytes]], files: Dict[str, List[HTTPFile]]) -&gt;None:</span>
<span class="gi">+    if content_type.startswith(&quot;application/x-www-form-urlencoded&quot;):</span>
<span class="gi">+        if headers and &quot;Content-Encoding&quot; in headers:</span>
<span class="gi">+            gen_log.warning(</span>
<span class="gi">+                &quot;Unsupported Content-Encoding: %s&quot;, headers[&quot;Content-Encoding&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            # real charset decoding will happen in RequestHandler.decode_argument()</span>
<span class="gi">+            uri_arguments = parse_qs_bytes(body, keep_blank_values=True)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            gen_log.warning(&quot;Invalid x-www-form-urlencoded body: %s&quot;, e)</span>
<span class="gi">+            uri_arguments = {}</span>
<span class="gi">+        for name, values in uri_arguments.items():</span>
<span class="gi">+            if values:</span>
<span class="gi">+                arguments.setdefault(name, []).extend(values)</span>
<span class="gi">+    elif content_type.startswith(&quot;multipart/form-data&quot;):</span>
<span class="gi">+        if headers and &quot;Content-Encoding&quot; in headers:</span>
<span class="gi">+            gen_log.warning(</span>
<span class="gi">+                &quot;Unsupported Content-Encoding: %s&quot;, headers[&quot;Content-Encoding&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            fields = content_type.split(&quot;;&quot;)</span>
<span class="gi">+            for field in fields:</span>
<span class="gi">+                k, sep, v = field.strip().partition(&quot;=&quot;)</span>
<span class="gi">+                if k == &quot;boundary&quot; and v:</span>
<span class="gi">+                    parse_multipart_form_data(utf8(v), body, arguments, files)</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;multipart boundary not found&quot;)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            gen_log.warning(&quot;Invalid multipart/form-data: %s&quot;, e)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_multipart_form_data(</span>
<span class="gi">+    boundary: bytes,</span>
<span class="gi">+    data: bytes,</span>
<span class="gi">+    arguments: Dict[str, List[bytes]],</span>
<span class="gi">+    files: Dict[str, List[HTTPFile]],</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses a ``multipart/form-data`` body.

<span class="w"> </span>    The ``boundary`` and ``data`` parameters are both byte strings.
<span class="gu">@@ -569,11 +811,50 @@ def parse_multipart_form_data(boundary: bytes, data: bytes, arguments: Dict</span>
<span class="w"> </span>       Now recognizes non-ASCII filenames in RFC 2231/5987
<span class="w"> </span>       (``filename*=``) format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The standard allows for the boundary to be quoted in the header,</span>
<span class="gi">+    # although it&#39;s rare (it happens at least for google app engine</span>
<span class="gi">+    # xmpp).  I think we&#39;re also supposed to handle backslash-escapes</span>
<span class="gi">+    # here but I&#39;ll save that until we see a client that uses them</span>
<span class="gi">+    # in the wild.</span>
<span class="gi">+    if boundary.startswith(b&#39;&quot;&#39;) and boundary.endswith(b&#39;&quot;&#39;):</span>
<span class="gi">+        boundary = boundary[1:-1]</span>
<span class="gi">+    final_boundary_index = data.rfind(b&quot;--&quot; + boundary + b&quot;--&quot;)</span>
<span class="gi">+    if final_boundary_index == -1:</span>
<span class="gi">+        gen_log.warning(&quot;Invalid multipart/form-data: no final boundary&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+    parts = data[:final_boundary_index].split(b&quot;--&quot; + boundary + b&quot;\r\n&quot;)</span>
<span class="gi">+    for part in parts:</span>
<span class="gi">+        if not part:</span>
<span class="gi">+            continue</span>
<span class="gi">+        eoh = part.find(b&quot;\r\n\r\n&quot;)</span>
<span class="gi">+        if eoh == -1:</span>
<span class="gi">+            gen_log.warning(&quot;multipart/form-data missing headers&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        headers = HTTPHeaders.parse(part[:eoh].decode(&quot;utf-8&quot;))</span>
<span class="gi">+        disp_header = headers.get(&quot;Content-Disposition&quot;, &quot;&quot;)</span>
<span class="gi">+        disposition, disp_params = _parse_header(disp_header)</span>
<span class="gi">+        if disposition != &quot;form-data&quot; or not part.endswith(b&quot;\r\n&quot;):</span>
<span class="gi">+            gen_log.warning(&quot;Invalid multipart/form-data&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        value = part[eoh + 4 : -2]</span>
<span class="gi">+        if not disp_params.get(&quot;name&quot;):</span>
<span class="gi">+            gen_log.warning(&quot;multipart/form-data value missing name&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        name = disp_params[&quot;name&quot;]</span>
<span class="gi">+        if disp_params.get(&quot;filename&quot;):</span>
<span class="gi">+            ctype = headers.get(&quot;Content-Type&quot;, &quot;application/unknown&quot;)</span>
<span class="gi">+            files.setdefault(name, []).append(</span>
<span class="gi">+                HTTPFile(</span>
<span class="gi">+                    filename=disp_params[&quot;filename&quot;], body=value, content_type=ctype</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            arguments.setdefault(name, []).append(value)</span>


<span class="gd">-def format_timestamp(ts: Union[int, float, tuple, time.struct_time,</span>
<span class="gd">-    datetime.datetime]) -&gt;str:</span>
<span class="gi">+def format_timestamp(</span>
<span class="gi">+    ts: Union[int, float, tuple, time.struct_time, datetime.datetime]</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Formats a timestamp in the format used by HTTP.

<span class="w"> </span>    The argument may be a numeric timestamp as returned by `time.time`,
<span class="gu">@@ -584,15 +865,26 @@ def format_timestamp(ts: Union[int, float, tuple, time.struct_time,</span>
<span class="w"> </span>    &gt;&gt;&gt; format_timestamp(1359312200)
<span class="w"> </span>    &#39;Sun, 27 Jan 2013 18:43:20 GMT&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(ts, (int, float)):</span>
<span class="gi">+        time_num = ts</span>
<span class="gi">+    elif isinstance(ts, (tuple, time.struct_time)):</span>
<span class="gi">+        time_num = calendar.timegm(ts)</span>
<span class="gi">+    elif isinstance(ts, datetime.datetime):</span>
<span class="gi">+        time_num = calendar.timegm(ts.utctimetuple())</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;unknown timestamp type: %r&quot; % ts)</span>
<span class="gi">+    return email.utils.formatdate(time_num, usegmt=True)</span>
<span class="gi">+</span>

<span class="gi">+RequestStartLine = collections.namedtuple(</span>
<span class="gi">+    &quot;RequestStartLine&quot;, [&quot;method&quot;, &quot;path&quot;, &quot;version&quot;]</span>
<span class="gi">+)</span>

<span class="gd">-RequestStartLine = collections.namedtuple(&#39;RequestStartLine&#39;, [&#39;method&#39;,</span>
<span class="gd">-    &#39;path&#39;, &#39;version&#39;])</span>
<span class="gd">-_http_version_re = re.compile(&#39;^HTTP/1\\.[0-9]$&#39;)</span>

<span class="gi">+_http_version_re = re.compile(r&quot;^HTTP/1\.[0-9]$&quot;)</span>

<span class="gd">-def parse_request_start_line(line: str) -&gt;RequestStartLine:</span>
<span class="gi">+</span>
<span class="gi">+def parse_request_start_line(line: str) -&gt; RequestStartLine:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a (method, path, version) tuple for an HTTP 1.x request line.

<span class="w"> </span>    The response is a `collections.namedtuple`.
<span class="gu">@@ -600,15 +892,28 @@ def parse_request_start_line(line: str) -&gt;RequestStartLine:</span>
<span class="w"> </span>    &gt;&gt;&gt; parse_request_start_line(&quot;GET /foo HTTP/1.1&quot;)
<span class="w"> </span>    RequestStartLine(method=&#39;GET&#39;, path=&#39;/foo&#39;, version=&#39;HTTP/1.1&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        method, path, version = line.split(&quot; &quot;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc7230#section-3.1.1</span>
<span class="gi">+        # invalid request-line SHOULD respond with a 400 (Bad Request)</span>
<span class="gi">+        raise HTTPInputError(&quot;Malformed HTTP request line&quot;)</span>
<span class="gi">+    if not _http_version_re.match(version):</span>
<span class="gi">+        raise HTTPInputError(</span>
<span class="gi">+            &quot;Malformed HTTP version in HTTP Request-Line: %r&quot; % version</span>
<span class="gi">+        )</span>
<span class="gi">+    return RequestStartLine(method, path, version)</span>
<span class="gi">+</span>

<span class="gi">+ResponseStartLine = collections.namedtuple(</span>
<span class="gi">+    &quot;ResponseStartLine&quot;, [&quot;version&quot;, &quot;code&quot;, &quot;reason&quot;]</span>
<span class="gi">+)</span>

<span class="gd">-ResponseStartLine = collections.namedtuple(&#39;ResponseStartLine&#39;, [&#39;version&#39;,</span>
<span class="gd">-    &#39;code&#39;, &#39;reason&#39;])</span>
<span class="gd">-_http_response_line_re = re.compile(&#39;(HTTP/1.[0-9]) ([0-9]+) ([^\\r]*)&#39;)</span>

<span class="gi">+_http_response_line_re = re.compile(r&quot;(HTTP/1.[0-9]) ([0-9]+) ([^\r]*)&quot;)</span>

<span class="gd">-def parse_response_start_line(line: str) -&gt;ResponseStartLine:</span>
<span class="gi">+</span>
<span class="gi">+def parse_response_start_line(line: str) -&gt; ResponseStartLine:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a (version, code, reason) tuple for an HTTP 1.x response line.

<span class="w"> </span>    The response is a `collections.namedtuple`.
<span class="gu">@@ -616,84 +921,198 @@ def parse_response_start_line(line: str) -&gt;ResponseStartLine:</span>
<span class="w"> </span>    &gt;&gt;&gt; parse_response_start_line(&quot;HTTP/1.1 200 OK&quot;)
<span class="w"> </span>    ResponseStartLine(version=&#39;HTTP/1.1&#39;, code=200, reason=&#39;OK&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    line = native_str(line)</span>
<span class="gi">+    match = _http_response_line_re.match(line)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise HTTPInputError(&quot;Error parsing response start line&quot;)</span>
<span class="gi">+    return ResponseStartLine(match.group(1), int(match.group(2)), match.group(3))</span>


<span class="gd">-def _parse_header(line: str) -&gt;Tuple[str, Dict[str, str]]:</span>
<span class="gd">-    &quot;&quot;&quot;Parse a Content-type like header.</span>
<span class="gi">+# _parseparam and _parse_header are copied and modified from python2.7&#39;s cgi.py</span>
<span class="gi">+# The original 2.7 version of this code did not correctly support some</span>
<span class="gi">+# combinations of semicolons and double quotes.</span>
<span class="gi">+# It has also been modified to support valueless parameters as seen in</span>
<span class="gi">+# websocket extension negotiations, and to support non-ascii values in</span>
<span class="gi">+# RFC 2231/5987 format.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parseparam(s: str) -&gt; Generator[str, None, None]:</span>
<span class="gi">+    while s[:1] == &quot;;&quot;:</span>
<span class="gi">+        s = s[1:]</span>
<span class="gi">+        end = s.find(&quot;;&quot;)</span>
<span class="gi">+        while end &gt; 0 and (s.count(&#39;&quot;&#39;, 0, end) - s.count(&#39;\\&quot;&#39;, 0, end)) % 2:</span>
<span class="gi">+            end = s.find(&quot;;&quot;, end + 1)</span>
<span class="gi">+        if end &lt; 0:</span>
<span class="gi">+            end = len(s)</span>
<span class="gi">+        f = s[:end]</span>
<span class="gi">+        yield f.strip()</span>
<span class="gi">+        s = s[end:]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_header(line: str) -&gt; Tuple[str, Dict[str, str]]:</span>
<span class="gi">+    r&quot;&quot;&quot;Parse a Content-type like header.</span>

<span class="w"> </span>    Return the main content-type and a dictionary of options.

<span class="gd">-    &gt;&gt;&gt; d = &quot;form-data; foo=\\&quot;b\\\\\\\\a\\\\\\&quot;r\\&quot;; file*=utf-8&#39;&#39;T%C3%A4st&quot;</span>
<span class="gi">+    &gt;&gt;&gt; d = &quot;form-data; foo=\&quot;b\\\\a\\\&quot;r\&quot;; file*=utf-8&#39;&#39;T%C3%A4st&quot;</span>
<span class="w"> </span>    &gt;&gt;&gt; ct, d = _parse_header(d)
<span class="w"> </span>    &gt;&gt;&gt; ct
<span class="w"> </span>    &#39;form-data&#39;
<span class="gd">-    &gt;&gt;&gt; d[&#39;file&#39;] == r&#39;T\\u00e4st&#39;.encode(&#39;ascii&#39;).decode(&#39;unicode_escape&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; d[&#39;file&#39;] == r&#39;T\u00e4st&#39;.encode(&#39;ascii&#39;).decode(&#39;unicode_escape&#39;)</span>
<span class="w"> </span>    True
<span class="w"> </span>    &gt;&gt;&gt; d[&#39;foo&#39;]
<span class="gd">-    &#39;b\\\\a&quot;r&#39;</span>
<span class="gi">+    &#39;b\\a&quot;r&#39;</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _encode_header(key: str, pdict: Dict[str, str]) -&gt;str:</span>
<span class="gi">+    parts = _parseparam(&quot;;&quot; + line)</span>
<span class="gi">+    key = next(parts)</span>
<span class="gi">+    # decode_params treats first argument special, but we already stripped key</span>
<span class="gi">+    params = [(&quot;Dummy&quot;, &quot;value&quot;)]</span>
<span class="gi">+    for p in parts:</span>
<span class="gi">+        i = p.find(&quot;=&quot;)</span>
<span class="gi">+        if i &gt;= 0:</span>
<span class="gi">+            name = p[:i].strip().lower()</span>
<span class="gi">+            value = p[i + 1 :].strip()</span>
<span class="gi">+            params.append((name, native_str(value)))</span>
<span class="gi">+    decoded_params = email.utils.decode_params(params)</span>
<span class="gi">+    decoded_params.pop(0)  # get rid of the dummy again</span>
<span class="gi">+    pdict = {}</span>
<span class="gi">+    for name, decoded_value in decoded_params:</span>
<span class="gi">+        value = email.utils.collapse_rfc2231_value(decoded_value)</span>
<span class="gi">+        if len(value) &gt;= 2 and value[0] == &#39;&quot;&#39; and value[-1] == &#39;&quot;&#39;:</span>
<span class="gi">+            value = value[1:-1]</span>
<span class="gi">+        pdict[name] = value</span>
<span class="gi">+    return key, pdict</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _encode_header(key: str, pdict: Dict[str, str]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Inverse of _parse_header.

<span class="w"> </span>    &gt;&gt;&gt; _encode_header(&#39;permessage-deflate&#39;,
<span class="w"> </span>    ...     {&#39;client_max_window_bits&#39;: 15, &#39;client_no_context_takeover&#39;: None})
<span class="w"> </span>    &#39;permessage-deflate; client_max_window_bits=15; client_no_context_takeover&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not pdict:</span>
<span class="gi">+        return key</span>
<span class="gi">+    out = [key]</span>
<span class="gi">+    # Sort the parameters just to make it easy to test.</span>
<span class="gi">+    for k, v in sorted(pdict.items()):</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            out.append(k)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # TODO: quote if necessary.</span>
<span class="gi">+            out.append(&quot;%s=%s&quot; % (k, v))</span>
<span class="gi">+    return &quot;; &quot;.join(out)</span>


<span class="gd">-def encode_username_password(username: Union[str, bytes], password: Union[</span>
<span class="gd">-    str, bytes]) -&gt;bytes:</span>
<span class="gi">+def encode_username_password(</span>
<span class="gi">+    username: Union[str, bytes], password: Union[str, bytes]</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Encodes a username/password pair in the format used by HTTP auth.

<span class="w"> </span>    The return value is a byte string in the form ``username:password``.

<span class="w"> </span>    .. versionadded:: 5.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(username, unicode_type):</span>
<span class="gi">+        username = unicodedata.normalize(&quot;NFC&quot;, username)</span>
<span class="gi">+    if isinstance(password, unicode_type):</span>
<span class="gi">+        password = unicodedata.normalize(&quot;NFC&quot;, password)</span>
<span class="gi">+    return utf8(username) + b&quot;:&quot; + utf8(password)</span>


<span class="gd">-_netloc_re = re.compile(&#39;^(.+):(\\d+)$&#39;)</span>
<span class="gi">+def doctests():</span>
<span class="gi">+    # type: () -&gt; unittest.TestSuite</span>
<span class="gi">+    import doctest</span>

<span class="gi">+    return doctest.DocTestSuite()</span>

<span class="gd">-def split_host_and_port(netloc: str) -&gt;Tuple[str, Optional[int]]:</span>
<span class="gi">+</span>
<span class="gi">+_netloc_re = re.compile(r&quot;^(.+):(\d+)$&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def split_host_and_port(netloc: str) -&gt; Tuple[str, Optional[int]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns ``(host, port)`` tuple from ``netloc``.

<span class="w"> </span>    Returned ``port`` will be ``None`` if not present.

<span class="w"> </span>    .. versionadded:: 4.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _netloc_re.match(netloc)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        host = match.group(1)</span>
<span class="gi">+        port = int(match.group(2))  # type: Optional[int]</span>
<span class="gi">+    else:</span>
<span class="gi">+        host = netloc</span>
<span class="gi">+        port = None</span>
<span class="gi">+    return (host, port)</span>


<span class="gd">-def qs_to_qsl(qs: Dict[str, List[AnyStr]]) -&gt;Iterable[Tuple[str, AnyStr]]:</span>
<span class="gi">+def qs_to_qsl(qs: Dict[str, List[AnyStr]]) -&gt; Iterable[Tuple[str, AnyStr]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generator converting a result of ``parse_qs`` back to name-value pairs.

<span class="w"> </span>    .. versionadded:: 5.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for k, vs in qs.items():</span>
<span class="gi">+        for v in vs:</span>
<span class="gi">+            yield (k, v)</span>


<span class="gd">-_OctalPatt = re.compile(&#39;\\\\[0-3][0-7][0-7]&#39;)</span>
<span class="gd">-_QuotePatt = re.compile(&#39;[\\\\].&#39;)</span>
<span class="gd">-_nulljoin = &#39;&#39;.join</span>
<span class="gi">+_OctalPatt = re.compile(r&quot;\\[0-3][0-7][0-7]&quot;)</span>
<span class="gi">+_QuotePatt = re.compile(r&quot;[\\].&quot;)</span>
<span class="gi">+_nulljoin = &quot;&quot;.join</span>


<span class="gd">-def _unquote_cookie(s: str) -&gt;str:</span>
<span class="gi">+def _unquote_cookie(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle double quotes and escaping in cookie values.

<span class="w"> </span>    This method is copied verbatim from the Python 3.5 standard
<span class="w"> </span>    library (http.cookies._unquote) so we don&#39;t have to depend on
<span class="w"> </span>    non-public interfaces.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_cookie(cookie: str) -&gt;Dict[str, str]:</span>
<span class="gi">+    # If there aren&#39;t any doublequotes,</span>
<span class="gi">+    # then there can&#39;t be any special characters.  See RFC 2109.</span>
<span class="gi">+    if s is None or len(s) &lt; 2:</span>
<span class="gi">+        return s</span>
<span class="gi">+    if s[0] != &#39;&quot;&#39; or s[-1] != &#39;&quot;&#39;:</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    # We have to assume that we must decode this string.</span>
<span class="gi">+    # Down to work.</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the &quot;s</span>
<span class="gi">+    s = s[1:-1]</span>
<span class="gi">+</span>
<span class="gi">+    # Check for special sequences.  Examples:</span>
<span class="gi">+    #    \012 --&gt; \n</span>
<span class="gi">+    #    \&quot;   --&gt; &quot;</span>
<span class="gi">+    #</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    n = len(s)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    while 0 &lt;= i &lt; n:</span>
<span class="gi">+        o_match = _OctalPatt.search(s, i)</span>
<span class="gi">+        q_match = _QuotePatt.search(s, i)</span>
<span class="gi">+        if not o_match and not q_match:  # Neither matched</span>
<span class="gi">+            res.append(s[i:])</span>
<span class="gi">+            break</span>
<span class="gi">+        # else:</span>
<span class="gi">+        j = k = -1</span>
<span class="gi">+        if o_match:</span>
<span class="gi">+            j = o_match.start(0)</span>
<span class="gi">+        if q_match:</span>
<span class="gi">+            k = q_match.start(0)</span>
<span class="gi">+        if q_match and (not o_match or k &lt; j):  # QuotePatt matched</span>
<span class="gi">+            res.append(s[i:k])</span>
<span class="gi">+            res.append(s[k + 1])</span>
<span class="gi">+            i = k + 2</span>
<span class="gi">+        else:  # OctalPatt matched</span>
<span class="gi">+            res.append(s[i:j])</span>
<span class="gi">+            res.append(chr(int(s[j + 1 : j + 4], 8)))</span>
<span class="gi">+            i = j + 4</span>
<span class="gi">+    return _nulljoin(res)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_cookie(cookie: str) -&gt; Dict[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a ``Cookie`` HTTP header into a dict of name/value pairs.

<span class="w"> </span>    This function attempts to mimic browser cookie parsing behavior;
<span class="gu">@@ -704,4 +1123,16 @@ def parse_cookie(cookie: str) -&gt;Dict[str, str]:</span>

<span class="w"> </span>    .. versionadded:: 4.4.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cookiedict = {}</span>
<span class="gi">+    for chunk in cookie.split(str(&quot;;&quot;)):</span>
<span class="gi">+        if str(&quot;=&quot;) in chunk:</span>
<span class="gi">+            key, val = chunk.split(str(&quot;=&quot;), 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Assume an empty name per</span>
<span class="gi">+            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091</span>
<span class="gi">+            key, val = str(&quot;&quot;), chunk</span>
<span class="gi">+        key, val = key.strip(), val.strip()</span>
<span class="gi">+        if key or val:</span>
<span class="gi">+            # unquote using Python&#39;s algorithm.</span>
<span class="gi">+            cookiedict[key] = _unquote_cookie(val)</span>
<span class="gi">+    return cookiedict</span>
<span class="gh">diff --git a/tornado/ioloop.py b/tornado/ioloop.py</span>
<span class="gh">index 114f1626..3fb1359a 100644</span>
<span class="gd">--- a/tornado/ioloop.py</span>
<span class="gi">+++ b/tornado/ioloop.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;An I/O event loop for non-blocking sockets.

<span class="w"> </span>In Tornado 6.0, `.IOLoop` is a wrapper around the `asyncio` event loop, with a
<span class="gu">@@ -7,6 +22,7 @@ loop interface directly. The `IOLoop.current` class method provides the</span>
<span class="w"> </span>`IOLoop` instance corresponding to the running `asyncio` event loop.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import concurrent.futures
<span class="w"> </span>import datetime
<span class="gu">@@ -19,24 +35,38 @@ import math</span>
<span class="w"> </span>import random
<span class="w"> </span>import warnings
<span class="w"> </span>from inspect import isawaitable
<span class="gd">-from tornado.concurrent import Future, is_future, chain_future, future_set_exc_info, future_add_done_callback</span>
<span class="gi">+</span>
<span class="gi">+from tornado.concurrent import (</span>
<span class="gi">+    Future,</span>
<span class="gi">+    is_future,</span>
<span class="gi">+    chain_future,</span>
<span class="gi">+    future_set_exc_info,</span>
<span class="gi">+    future_add_done_callback,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.log import app_log
<span class="w"> </span>from tornado.util import Configurable, TimeoutError, import_object
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Union, Any, Type, Optional, Callable, TypeVar, Tuple, Awaitable
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Dict, List, Set</span>
<span class="gi">+    from typing import Dict, List, Set  # noqa: F401</span>
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import Protocol
<span class="w"> </span>else:
<span class="w"> </span>    Protocol = object


<span class="w"> </span>class _Selectable(Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        pass</span>

<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        pass</span>

<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gd">-_S = TypeVar(&#39;_S&#39;, bound=_Selectable)</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+_S = TypeVar(&quot;_S&quot;, bound=_Selectable)</span>


<span class="w"> </span>class IOLoop(Configurable):
<span class="gu">@@ -119,15 +149,42 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>       previously the default was to make the event loop current if there wasn&#39;t
<span class="w"> </span>       already a current one.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # These constants were originally based on constants from the epoll module.</span>
<span class="w"> </span>    NONE = 0
<span class="gd">-    READ = 1</span>
<span class="gd">-    WRITE = 4</span>
<span class="gd">-    ERROR = 24</span>
<span class="gd">-    _ioloop_for_asyncio = dict()</span>
<span class="gd">-    _pending_tasks = set()</span>
<span class="gi">+    READ = 0x001</span>
<span class="gi">+    WRITE = 0x004</span>
<span class="gi">+    ERROR = 0x018</span>
<span class="gi">+</span>
<span class="gi">+    # In Python 3, _ioloop_for_asyncio maps from asyncio loops to IOLoops.</span>
<span class="gi">+    _ioloop_for_asyncio = dict()  # type: Dict[asyncio.AbstractEventLoop, IOLoop]</span>
<span class="gi">+</span>
<span class="gi">+    # Maintain a set of all pending tasks to follow the warning in the docs</span>
<span class="gi">+    # of asyncio.create_tasks:</span>
<span class="gi">+    # https://docs.python.org/3.11/library/asyncio-task.html#asyncio.create_task</span>
<span class="gi">+    # This ensures that all pending tasks have a strong reference so they</span>
<span class="gi">+    # will not be garbage collected before they are finished.</span>
<span class="gi">+    # (Thus avoiding &quot;task was destroyed but it is pending&quot; warnings)</span>
<span class="gi">+    # An analogous change has been proposed in cpython for 3.13:</span>
<span class="gi">+    # https://github.com/python/cpython/issues/91887</span>
<span class="gi">+    # If that change is accepted, this can eventually be removed.</span>
<span class="gi">+    # If it is not, we will consider the rationale and may remove this.</span>
<span class="gi">+    _pending_tasks = set()  # type: Set[Future]</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configure(</span>
<span class="gi">+        cls, impl: &quot;Union[None, str, Type[Configurable]]&quot;, **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        from tornado.platform.asyncio import BaseAsyncIOLoop</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(impl, str):</span>
<span class="gi">+            impl = import_object(impl)</span>
<span class="gi">+        if isinstance(impl, type) and not issubclass(impl, BaseAsyncIOLoop):</span>
<span class="gi">+            raise RuntimeError(&quot;only AsyncIOLoop is allowed when asyncio is available&quot;)</span>
<span class="gi">+        super(IOLoop, cls).configure(impl, **kwargs)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def instance() -&gt;&#39;IOLoop&#39;:</span>
<span class="gi">+    def instance() -&gt; &quot;IOLoop&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deprecated alias for `IOLoop.current()`.

<span class="w"> </span>        .. versionchanged:: 5.0
<span class="gu">@@ -146,9 +203,9 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. deprecated:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return IOLoop.current()</span>

<span class="gd">-    def install(self) -&gt;None:</span>
<span class="gi">+    def install(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deprecated alias for `make_current()`.

<span class="w"> </span>        .. versionchanged:: 5.0
<span class="gu">@@ -160,10 +217,10 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. deprecated:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.make_current()</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def clear_instance() -&gt;None:</span>
<span class="gi">+    def clear_instance() -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deprecated alias for `clear_current()`.

<span class="w"> </span>        .. versionchanged:: 5.0
<span class="gu">@@ -176,10 +233,20 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        .. deprecated:: 5.0

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        IOLoop.clear_current()</span>
<span class="gi">+</span>
<span class="gi">+    @typing.overload</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def current() -&gt; &quot;IOLoop&quot;:</span>
<span class="w"> </span>        pass

<span class="gi">+    @typing.overload</span>
<span class="w"> </span>    @staticmethod
<span class="gd">-    def current(instance: bool=True) -&gt;Optional[&#39;IOLoop&#39;]:</span>
<span class="gi">+    def current(instance: bool = True) -&gt; Optional[&quot;IOLoop&quot;]:  # noqa: F811</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def current(instance: bool = True) -&gt; Optional[&quot;IOLoop&quot;]:  # noqa: F811</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the current thread&#39;s `IOLoop`.

<span class="w"> </span>        If an `IOLoop` is currently running or has been marked as
<span class="gu">@@ -203,9 +270,27 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           It is deprecated to call ``IOLoop.current()`` when no `asyncio`
<span class="w"> </span>           event loop is running.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def make_current(self) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            loop = asyncio.get_event_loop()</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            if not instance:</span>
<span class="gi">+                return None</span>
<span class="gi">+            # Create a new asyncio event loop for this thread.</span>
<span class="gi">+            loop = asyncio.new_event_loop()</span>
<span class="gi">+            asyncio.set_event_loop(loop)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IOLoop._ioloop_for_asyncio[loop]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if instance:</span>
<span class="gi">+                from tornado.platform.asyncio import AsyncIOMainLoop</span>
<span class="gi">+</span>
<span class="gi">+                current = AsyncIOMainLoop()  # type: Optional[IOLoop]</span>
<span class="gi">+            else:</span>
<span class="gi">+                current = None</span>
<span class="gi">+        return current</span>
<span class="gi">+</span>
<span class="gi">+    def make_current(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Makes this the `IOLoop` for the current thread.

<span class="w"> </span>        An `IOLoop` automatically becomes current for its thread
<span class="gu">@@ -225,10 +310,19 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           Setting and clearing the current event loop through Tornado is
<span class="w"> </span>           deprecated. Use ``asyncio.set_event_loop`` instead if you need this.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;make_current is deprecated; start the event loop first&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._make_current()</span>
<span class="gi">+</span>
<span class="gi">+    def _make_current(self) -&gt; None:</span>
<span class="gi">+        # The asyncio event loops override this method.</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def clear_current() -&gt;None:</span>
<span class="gi">+    def clear_current() -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clears the `IOLoop` for the current thread.

<span class="w"> </span>        Intended primarily for use by test frameworks in between tests.
<span class="gu">@@ -237,16 +331,41 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           This method also clears the current `asyncio` event loop.
<span class="w"> </span>        .. deprecated:: 6.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;clear_current is deprecated&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        IOLoop._clear_current()</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _clear_current() -&gt; None:</span>
<span class="gi">+        old = IOLoop.current(instance=False)</span>
<span class="gi">+        if old is not None:</span>
<span class="gi">+            old._clear_current_hook()</span>

<span class="gd">-    def _clear_current_hook(self) -&gt;None:</span>
<span class="gi">+    def _clear_current_hook(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Instance method called when an IOLoop ceases to be current.

<span class="w"> </span>        May be overridden by subclasses as a counterpart to make_current.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def close(self, all_fds: bool=False) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_base(cls) -&gt; Type[Configurable]:</span>
<span class="gi">+        return IOLoop</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_default(cls) -&gt; Type[Configurable]:</span>
<span class="gi">+        from tornado.platform.asyncio import AsyncIOLoop</span>
<span class="gi">+</span>
<span class="gi">+        return AsyncIOLoop</span>
<span class="gi">+</span>
<span class="gi">+    def initialize(self, make_current: bool = True) -&gt; None:</span>
<span class="gi">+        if make_current:</span>
<span class="gi">+            self._make_current()</span>
<span class="gi">+</span>
<span class="gi">+    def close(self, all_fds: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the `IOLoop`, freeing any resources used.

<span class="w"> </span>        If ``all_fds`` is true, all file descriptors registered on the
<span class="gu">@@ -271,10 +390,23 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           for &quot;file descriptors&quot;, those objects will have their
<span class="w"> </span>           ``close`` method when ``all_fds`` is true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @typing.overload</span>
<span class="gi">+    def add_handler(</span>
<span class="gi">+        self, fd: int, handler: Callable[[int, int], None], events: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def add_handler(self, fd: Union[int, _Selectable], handler: Callable[</span>
<span class="gd">-        ..., None], events: int) -&gt;None:</span>
<span class="gi">+    @typing.overload  # noqa: F811</span>
<span class="gi">+    def add_handler(</span>
<span class="gi">+        self, fd: _S, handler: Callable[[_S, int], None], events: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def add_handler(  # noqa: F811</span>
<span class="gi">+        self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers the given handler to receive the given events for ``fd``.

<span class="w"> </span>        The ``fd`` argument may either be an integer file descriptor or
<span class="gu">@@ -289,35 +421,35 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           Added the ability to pass file-like objects in addition to
<span class="w"> </span>           raw file descriptors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def update_handler(self, fd: Union[int, _Selectable], events: int) -&gt;None:</span>
<span class="gi">+    def update_handler(self, fd: Union[int, _Selectable], events: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Changes the events we listen for ``fd``.

<span class="w"> </span>        .. versionchanged:: 4.0
<span class="w"> </span>           Added the ability to pass file-like objects in addition to
<span class="w"> </span>           raw file descriptors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def remove_handler(self, fd: Union[int, _Selectable]) -&gt;None:</span>
<span class="gi">+    def remove_handler(self, fd: Union[int, _Selectable]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop listening for events on ``fd``.

<span class="w"> </span>        .. versionchanged:: 4.0
<span class="w"> </span>           Added the ability to pass file-like objects in addition to
<span class="w"> </span>           raw file descriptors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def start(self) -&gt;None:</span>
<span class="gi">+    def start(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts the I/O loop.

<span class="w"> </span>        The loop will run until one of the callbacks calls `stop()`, which
<span class="w"> </span>        will make the loop stop after the current event iteration completes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def stop(self) -&gt;None:</span>
<span class="gi">+    def stop(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop the I/O loop.

<span class="w"> </span>        If the event loop is not currently running, the next call to `start()`
<span class="gu">@@ -328,9 +460,9 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        Some work that was scheduled before the call to `stop` may still
<span class="w"> </span>        be run before the `IOLoop` shuts down.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def run_sync(self, func: Callable, timeout: Optional[float]=None) -&gt;Any:</span>
<span class="gi">+    def run_sync(self, func: Callable, timeout: Optional[float] = None) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts the `IOLoop`, runs the given function, and stops the loop.

<span class="w"> </span>        The function must return either an awaitable object or
<span class="gu">@@ -362,9 +494,51 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        .. versionchanged:: 6.2
<span class="w"> </span>           ``tornado.util.TimeoutError`` is now an alias to ``asyncio.TimeoutError``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def time(self) -&gt;float:</span>
<span class="gi">+        future_cell = [None]  # type: List[Optional[Future]]</span>
<span class="gi">+</span>
<span class="gi">+        def run() -&gt; None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                result = func()</span>
<span class="gi">+                if result is not None:</span>
<span class="gi">+                    from tornado.gen import convert_yielded</span>
<span class="gi">+</span>
<span class="gi">+                    result = convert_yielded(result)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                fut = Future()  # type: Future[Any]</span>
<span class="gi">+                future_cell[0] = fut</span>
<span class="gi">+                future_set_exc_info(fut, sys.exc_info())</span>
<span class="gi">+            else:</span>
<span class="gi">+                if is_future(result):</span>
<span class="gi">+                    future_cell[0] = result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    fut = Future()</span>
<span class="gi">+                    future_cell[0] = fut</span>
<span class="gi">+                    fut.set_result(result)</span>
<span class="gi">+            assert future_cell[0] is not None</span>
<span class="gi">+            self.add_future(future_cell[0], lambda future: self.stop())</span>
<span class="gi">+</span>
<span class="gi">+        self.add_callback(run)</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+</span>
<span class="gi">+            def timeout_callback() -&gt; None:</span>
<span class="gi">+                # If we can cancel the future, do so and wait on it. If not,</span>
<span class="gi">+                # Just stop the loop and return with the task still pending.</span>
<span class="gi">+                # (If we neither cancel nor wait for the task, a warning</span>
<span class="gi">+                # will be logged).</span>
<span class="gi">+                assert future_cell[0] is not None</span>
<span class="gi">+                if not future_cell[0].cancel():</span>
<span class="gi">+                    self.stop()</span>
<span class="gi">+</span>
<span class="gi">+            timeout_handle = self.add_timeout(self.time() + timeout, timeout_callback)</span>
<span class="gi">+        self.start()</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            self.remove_timeout(timeout_handle)</span>
<span class="gi">+        assert future_cell[0] is not None</span>
<span class="gi">+        if future_cell[0].cancelled() or not future_cell[0].done():</span>
<span class="gi">+            raise TimeoutError(&quot;Operation timed out after %s seconds&quot; % timeout)</span>
<span class="gi">+        return future_cell[0].result()</span>
<span class="gi">+</span>
<span class="gi">+    def time(self) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the current time according to the `IOLoop`&#39;s clock.

<span class="w"> </span>        The return value is a floating-point number relative to an
<span class="gu">@@ -376,10 +550,15 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        `time.time`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_timeout(self, deadline: Union[float, datetime.timedelta],</span>
<span class="gd">-        callback: Callable, *args: Any, **kwargs: Any) -&gt;object:</span>
<span class="gi">+        return time.time()</span>
<span class="gi">+</span>
<span class="gi">+    def add_timeout(</span>
<span class="gi">+        self,</span>
<span class="gi">+        deadline: Union[float, datetime.timedelta],</span>
<span class="gi">+        callback: Callable,</span>
<span class="gi">+        *args: Any,</span>
<span class="gi">+        **kwargs: Any</span>
<span class="gi">+    ) -&gt; object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs the ``callback`` at the time ``deadline`` from the I/O loop.

<span class="w"> </span>        Returns an opaque handle that may be passed to
<span class="gu">@@ -405,10 +584,18 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        .. versionchanged:: 4.0
<span class="w"> </span>           Now passes through ``*args`` and ``**kwargs`` to the callback.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(deadline, numbers.Real):</span>
<span class="gi">+            return self.call_at(deadline, callback, *args, **kwargs)</span>
<span class="gi">+        elif isinstance(deadline, datetime.timedelta):</span>
<span class="gi">+            return self.call_at(</span>
<span class="gi">+                self.time() + deadline.total_seconds(), callback, *args, **kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;Unsupported deadline %r&quot; % deadline)</span>

<span class="gd">-    def call_later(self, delay: float, callback: Callable, *args: Any, **</span>
<span class="gd">-        kwargs: Any) -&gt;object:</span>
<span class="gi">+    def call_later(</span>
<span class="gi">+        self, delay: float, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs the ``callback`` after ``delay`` seconds have passed.

<span class="w"> </span>        Returns an opaque handle that may be passed to `remove_timeout`
<span class="gu">@@ -419,10 +606,11 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. versionadded:: 4.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.call_at(self.time() + delay, callback, *args, **kwargs)</span>

<span class="gd">-    def call_at(self, when: float, callback: Callable, *args: Any, **kwargs:</span>
<span class="gd">-        Any) -&gt;object:</span>
<span class="gi">+    def call_at(</span>
<span class="gi">+        self, when: float, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; object:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs the ``callback`` at the absolute time designated by ``when``.

<span class="w"> </span>        ``when`` must be a number using the same reference point as
<span class="gu">@@ -436,19 +624,18 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. versionadded:: 4.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.add_timeout(when, callback, *args, **kwargs)</span>

<span class="gd">-    def remove_timeout(self, timeout: object) -&gt;None:</span>
<span class="gi">+    def remove_timeout(self, timeout: object) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Cancels a pending timeout.

<span class="w"> </span>        The argument is a handle as returned by `add_timeout`.  It is
<span class="w"> </span>        safe to call `remove_timeout` even if the callback has already
<span class="w"> </span>        been run.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def add_callback(self, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_callback(self, callback: Callable, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.

<span class="w"> </span>        It is safe to call this method from any thread at any time,
<span class="gu">@@ -458,10 +645,11 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        `IOLoop`&#39;s thread.  `add_callback()` may be used to transfer
<span class="w"> </span>        control from other threads to the `IOLoop`&#39;s thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def add_callback_from_signal(self, callback: Callable, *args: Any, **</span>
<span class="gd">-        kwargs: Any) -&gt;None:</span>
<span class="gi">+    def add_callback_from_signal(</span>
<span class="gi">+        self, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.

<span class="w"> </span>        Intended to be afe for use from a Python signal handler; should not be
<span class="gu">@@ -472,21 +660,22 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>           This method is suspected to have been broken since Tornado 5.0 and
<span class="w"> </span>           will be removed in version 7.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def spawn_callback(self, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def spawn_callback(self, callback: Callable, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Calls the given callback on the next IOLoop iteration.

<span class="w"> </span>        As of Tornado 6.0, this method is equivalent to `add_callback`.

<span class="w"> </span>        .. versionadded:: 4.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_callback(callback, *args, **kwargs)</span>

<span class="gd">-    def add_future(self, future:</span>
<span class="gd">-        &#39;Union[Future[_T], concurrent.futures.Future[_T]]&#39;, callback:</span>
<span class="gd">-        Callable[[&#39;Future[_T]&#39;], None]) -&gt;None:</span>
<span class="gi">+    def add_future(</span>
<span class="gi">+        self,</span>
<span class="gi">+        future: &quot;Union[Future[_T], concurrent.futures.Future[_T]]&quot;,</span>
<span class="gi">+        callback: Callable[[&quot;Future[_T]&quot;], None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Schedules a callback on the ``IOLoop`` when the given
<span class="w"> </span>        `.Future` is finished.

<span class="gu">@@ -497,10 +686,30 @@ class IOLoop(Configurable):</span>
<span class="w"> </span>        awaitables (unlike most of Tornado where the two are
<span class="w"> </span>        interchangeable).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def run_in_executor(self, executor: Optional[concurrent.futures.</span>
<span class="gd">-        Executor], func: Callable[..., _T], *args: Any) -&gt;&#39;Future[_T]&#39;:</span>
<span class="gi">+        if isinstance(future, Future):</span>
<span class="gi">+            # Note that we specifically do not want the inline behavior of</span>
<span class="gi">+            # tornado.concurrent.future_add_done_callback. We always want</span>
<span class="gi">+            # this callback scheduled on the next IOLoop iteration (which</span>
<span class="gi">+            # asyncio.Future always does).</span>
<span class="gi">+            #</span>
<span class="gi">+            # Wrap the callback in self._run_callback so we control</span>
<span class="gi">+            # the error logging (i.e. it goes to tornado.log.app_log</span>
<span class="gi">+            # instead of asyncio&#39;s log).</span>
<span class="gi">+            future.add_done_callback(</span>
<span class="gi">+                lambda f: self._run_callback(functools.partial(callback, f))</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert is_future(future)</span>
<span class="gi">+            # For concurrent futures, we use self.add_callback, so</span>
<span class="gi">+            # it&#39;s fine if future_add_done_callback inlines that call.</span>
<span class="gi">+            future_add_done_callback(future, lambda f: self.add_callback(callback, f))</span>
<span class="gi">+</span>
<span class="gi">+    def run_in_executor(</span>
<span class="gi">+        self,</span>
<span class="gi">+        executor: Optional[concurrent.futures.Executor],</span>
<span class="gi">+        func: Callable[..., _T],</span>
<span class="gi">+        *args: Any</span>
<span class="gi">+    ) -&gt; &quot;Future[_T]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs a function in a ``concurrent.futures.Executor``. If
<span class="w"> </span>        ``executor`` is ``None``, the IO loop&#39;s default executor will be used.

<span class="gu">@@ -508,46 +717,137 @@ class IOLoop(Configurable):</span>

<span class="w"> </span>        .. versionadded:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_default_executor(self, executor: concurrent.futures.Executor</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if executor is None:</span>
<span class="gi">+            if not hasattr(self, &quot;_executor&quot;):</span>
<span class="gi">+                from tornado.process import cpu_count</span>
<span class="gi">+</span>
<span class="gi">+                self._executor = concurrent.futures.ThreadPoolExecutor(</span>
<span class="gi">+                    max_workers=(cpu_count() * 5)</span>
<span class="gi">+                )  # type: concurrent.futures.Executor</span>
<span class="gi">+            executor = self._executor</span>
<span class="gi">+        c_future = executor.submit(func, *args)</span>
<span class="gi">+        # Concurrent Futures are not usable with await. Wrap this in a</span>
<span class="gi">+        # Tornado Future instead, using self.add_future for thread-safety.</span>
<span class="gi">+        t_future = Future()  # type: Future[_T]</span>
<span class="gi">+        self.add_future(c_future, lambda f: chain_future(f, t_future))</span>
<span class="gi">+        return t_future</span>
<span class="gi">+</span>
<span class="gi">+    def set_default_executor(self, executor: concurrent.futures.Executor) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the default executor to use with :meth:`run_in_executor`.

<span class="w"> </span>        .. versionadded:: 5.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._executor = executor</span>

<span class="gd">-    def _run_callback(self, callback: Callable[[], Any]) -&gt;None:</span>
<span class="gi">+    def _run_callback(self, callback: Callable[[], Any]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs a callback with error handling.

<span class="w"> </span>        .. versionchanged:: 6.0

<span class="w"> </span>           CancelledErrors are no longer logged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _discard_future_result(self, future: Future) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            ret = callback()</span>
<span class="gi">+            if ret is not None:</span>
<span class="gi">+                from tornado import gen</span>
<span class="gi">+</span>
<span class="gi">+                # Functions that return Futures typically swallow all</span>
<span class="gi">+                # exceptions and store them in the Future.  If a Future</span>
<span class="gi">+                # makes it out to the IOLoop, ensure its exception (if any)</span>
<span class="gi">+                # gets logged too.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    ret = gen.convert_yielded(ret)</span>
<span class="gi">+                except gen.BadYieldError:</span>
<span class="gi">+                    # It&#39;s not unusual for add_callback to be used with</span>
<span class="gi">+                    # methods returning a non-None and non-yieldable</span>
<span class="gi">+                    # result, which should just be ignored.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_future(ret, self._discard_future_result)</span>
<span class="gi">+        except asyncio.CancelledError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            app_log.error(&quot;Exception in callback %r&quot;, callback, exc_info=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _discard_future_result(self, future: Future) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Avoid unhandled-exception warnings from spawned coroutines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future.result()</span>
<span class="gi">+</span>
<span class="gi">+    def split_fd(</span>
<span class="gi">+        self, fd: Union[int, _Selectable]</span>
<span class="gi">+    ) -&gt; Tuple[int, Union[int, _Selectable]]:</span>
<span class="gi">+        # &quot;&quot;&quot;Returns an (fd, obj) pair from an ``fd`` parameter.</span>
<span class="gi">+</span>
<span class="gi">+        # We accept both raw file descriptors and file-like objects as</span>
<span class="gi">+        # input to `add_handler` and related methods.  When a file-like</span>
<span class="gi">+        # object is passed, we must retain the object itself so we can</span>
<span class="gi">+        # close it correctly when the `IOLoop` shuts down, but the</span>
<span class="gi">+        # poller interfaces favor file descriptors (they will accept</span>
<span class="gi">+        # file-like objects and call ``fileno()`` for you, but they</span>
<span class="gi">+        # always return the descriptor itself).</span>
<span class="gi">+</span>
<span class="gi">+        # This method is provided for use by `IOLoop` subclasses and should</span>
<span class="gi">+        # not generally be used by application code.</span>
<span class="gi">+</span>
<span class="gi">+        # .. versionadded:: 4.0</span>
<span class="gi">+        # &quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(fd, int):</span>
<span class="gi">+            return fd, fd</span>
<span class="gi">+        return fd.fileno(), fd</span>
<span class="gi">+</span>
<span class="gi">+    def close_fd(self, fd: Union[int, _Selectable]) -&gt; None:</span>
<span class="gi">+        # &quot;&quot;&quot;Utility method to close an ``fd``.</span>
<span class="gi">+</span>
<span class="gi">+        # If ``fd`` is a file-like object, we close it directly; otherwise</span>
<span class="gi">+        # we use `os.close`.</span>
<span class="gi">+</span>
<span class="gi">+        # This method is provided for use by `IOLoop` subclasses (in</span>
<span class="gi">+        # implementations of ``IOLoop.close(all_fds=True)`` and should</span>
<span class="gi">+        # not generally be used by application code.</span>
<span class="gi">+</span>
<span class="gi">+        # .. versionadded:: 4.0</span>
<span class="gi">+        # &quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(fd, int):</span>
<span class="gi">+                os.close(fd)</span>
<span class="gi">+            else:</span>
<span class="gi">+                fd.close()</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def _register_task(self, f: Future) -&gt; None:</span>
<span class="gi">+        self._pending_tasks.add(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _unregister_task(self, f: Future) -&gt; None:</span>
<span class="gi">+        self._pending_tasks.discard(f)</span>


<span class="w"> </span>class _Timeout(object):
<span class="w"> </span>    &quot;&quot;&quot;An IOLoop timeout, a UNIX timestamp and a callback&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;deadline&#39;, &#39;callback&#39;, &#39;tdeadline&#39;]</span>

<span class="gd">-    def __init__(self, deadline: float, callback: Callable[[], None],</span>
<span class="gd">-        io_loop: IOLoop) -&gt;None:</span>
<span class="gi">+    # Reduce memory overhead when there are lots of pending callbacks</span>
<span class="gi">+    __slots__ = [&quot;deadline&quot;, &quot;callback&quot;, &quot;tdeadline&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, deadline: float, callback: Callable[[], None], io_loop: IOLoop</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if not isinstance(deadline, numbers.Real):
<span class="gd">-            raise TypeError(&#39;Unsupported deadline %r&#39; % deadline)</span>
<span class="gi">+            raise TypeError(&quot;Unsupported deadline %r&quot; % deadline)</span>
<span class="w"> </span>        self.deadline = deadline
<span class="w"> </span>        self.callback = callback
<span class="gd">-        self.tdeadline = deadline, next(io_loop._timeout_counter)</span>
<span class="gd">-</span>
<span class="gd">-    def __lt__(self, other: &#39;_Timeout&#39;) -&gt;bool:</span>
<span class="gi">+        self.tdeadline = (</span>
<span class="gi">+            deadline,</span>
<span class="gi">+            next(io_loop._timeout_counter),</span>
<span class="gi">+        )  # type: Tuple[float, int]</span>
<span class="gi">+</span>
<span class="gi">+    # Comparison methods to sort by deadline, with object id as a tiebreaker</span>
<span class="gi">+    # to guarantee a consistent ordering.  The heapq module uses __le__</span>
<span class="gi">+    # in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons</span>
<span class="gi">+    # use __lt__).</span>
<span class="gi">+    def __lt__(self, other: &quot;_Timeout&quot;) -&gt; bool:</span>
<span class="w"> </span>        return self.tdeadline &lt; other.tdeadline

<span class="gd">-    def __le__(self, other: &#39;_Timeout&#39;) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: &quot;_Timeout&quot;) -&gt; bool:</span>
<span class="w"> </span>        return self.tdeadline &lt;= other.tdeadline


<span class="gu">@@ -589,33 +889,90 @@ class PeriodicCallback(object):</span>
<span class="w"> </span>       in addition to the previous numeric milliseconds.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, callback: Callable[[], Optional[Awaitable]],</span>
<span class="gd">-        callback_time: Union[datetime.timedelta, float], jitter: float=0</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        callback: Callable[[], Optional[Awaitable]],</span>
<span class="gi">+        callback_time: Union[datetime.timedelta, float],</span>
<span class="gi">+        jitter: float = 0,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.callback = callback
<span class="w"> </span>        if isinstance(callback_time, datetime.timedelta):
<span class="gd">-            self.callback_time = callback_time / datetime.timedelta(</span>
<span class="gd">-                milliseconds=1)</span>
<span class="gi">+            self.callback_time = callback_time / datetime.timedelta(milliseconds=1)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            if callback_time &lt;= 0:
<span class="gd">-                raise ValueError(</span>
<span class="gd">-                    &#39;Periodic callback must have a positive callback_time&#39;)</span>
<span class="gi">+                raise ValueError(&quot;Periodic callback must have a positive callback_time&quot;)</span>
<span class="w"> </span>            self.callback_time = callback_time
<span class="w"> </span>        self.jitter = jitter
<span class="w"> </span>        self._running = False
<span class="gd">-        self._timeout = None</span>
<span class="gi">+        self._timeout = None  # type: object</span>

<span class="gd">-    def start(self) -&gt;None:</span>
<span class="gi">+    def start(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts the timer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def stop(self) -&gt;None:</span>
<span class="gi">+        # Looking up the IOLoop here allows to first instantiate the</span>
<span class="gi">+        # PeriodicCallback in another thread, then start it using</span>
<span class="gi">+        # IOLoop.add_callback().</span>
<span class="gi">+        self.io_loop = IOLoop.current()</span>
<span class="gi">+        self._running = True</span>
<span class="gi">+        self._next_timeout = self.io_loop.time()</span>
<span class="gi">+        self._schedule_next()</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stops the timer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._running = False</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self._timeout)</span>
<span class="gi">+            self._timeout = None</span>

<span class="gd">-    def is_running(self) -&gt;bool:</span>
<span class="gi">+    def is_running(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this `.PeriodicCallback` has been started.

<span class="w"> </span>        .. versionadded:: 4.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._running</span>
<span class="gi">+</span>
<span class="gi">+    async def _run(self) -&gt; None:</span>
<span class="gi">+        if not self._running:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            val = self.callback()</span>
<span class="gi">+            if val is not None and isawaitable(val):</span>
<span class="gi">+                await val</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            app_log.error(&quot;Exception in callback %r&quot;, self.callback, exc_info=True)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._schedule_next()</span>
<span class="gi">+</span>
<span class="gi">+    def _schedule_next(self) -&gt; None:</span>
<span class="gi">+        if self._running:</span>
<span class="gi">+            self._update_next(self.io_loop.time())</span>
<span class="gi">+            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_next(self, current_time: float) -&gt; None:</span>
<span class="gi">+        callback_time_sec = self.callback_time / 1000.0</span>
<span class="gi">+        if self.jitter:</span>
<span class="gi">+            # apply jitter fraction</span>
<span class="gi">+            callback_time_sec *= 1 + (self.jitter * (random.random() - 0.5))</span>
<span class="gi">+        if self._next_timeout &lt;= current_time:</span>
<span class="gi">+            # The period should be measured from the start of one call</span>
<span class="gi">+            # to the start of the next. If one call takes too long,</span>
<span class="gi">+            # skip cycles to get back to a multiple of the original</span>
<span class="gi">+            # schedule.</span>
<span class="gi">+            self._next_timeout += (</span>
<span class="gi">+                math.floor((current_time - self._next_timeout) / callback_time_sec) + 1</span>
<span class="gi">+            ) * callback_time_sec</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If the clock moved backwards, ensure we advance the next</span>
<span class="gi">+            # timeout instead of recomputing the same value again.</span>
<span class="gi">+            # This may result in long gaps between callbacks if the</span>
<span class="gi">+            # clock jumps backwards by a lot, but the far more common</span>
<span class="gi">+            # scenario is a small NTP adjustment that should just be</span>
<span class="gi">+            # ignored.</span>
<span class="gi">+            #</span>
<span class="gi">+            # Note that on some systems if time.time() runs slower</span>
<span class="gi">+            # than time.monotonic() (most common on windows), we</span>
<span class="gi">+            # effectively experience a small backwards time jump on</span>
<span class="gi">+            # every iteration because PeriodicCallback uses</span>
<span class="gi">+            # time.time() while asyncio schedules callbacks using</span>
<span class="gi">+            # time.monotonic().</span>
<span class="gi">+            # https://github.com/tornadoweb/tornado/issues/2333</span>
<span class="gi">+            self._next_timeout += callback_time_sec</span>
<span class="gh">diff --git a/tornado/iostream.py b/tornado/iostream.py</span>
<span class="gh">index 1f9c2e76..ee577593 100644</span>
<span class="gd">--- a/tornado/iostream.py</span>
<span class="gi">+++ b/tornado/iostream.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utility classes to write to and read from non-blocking files and sockets.

<span class="w"> </span>Contents:
<span class="gu">@@ -7,6 +22,7 @@ Contents:</span>
<span class="w"> </span>* `SSLIOStream`: SSL-aware version of IOStream.
<span class="w"> </span>* `PipeIOStream`: Pipe-based IOStream implementation.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import collections
<span class="w"> </span>import errno
<span class="gu">@@ -17,25 +33,52 @@ import socket</span>
<span class="w"> </span>import ssl
<span class="w"> </span>import sys
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import Future, future_set_result_unless_cancelled
<span class="w"> </span>from tornado import ioloop
<span class="w"> </span>from tornado.log import gen_log
<span class="w"> </span>from tornado.netutil import ssl_wrap_socket, _client_ssl_defaults, _server_ssl_defaults
<span class="w"> </span>from tornado.util import errno_from_exception
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gd">-from typing import Union, Optional, Awaitable, Callable, Pattern, Any, Dict, TypeVar, Tuple</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Union,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Awaitable,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+)</span>
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Deque, List, Type</span>
<span class="gd">-_IOStreamType = TypeVar(&#39;_IOStreamType&#39;, bound=&#39;IOStream&#39;)</span>
<span class="gd">-_ERRNO_CONNRESET = (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE,</span>
<span class="gd">-    errno.ETIMEDOUT)</span>
<span class="gd">-if hasattr(errno, &#39;WSAECONNRESET&#39;):</span>
<span class="gd">-    _ERRNO_CONNRESET += (errno.WSAECONNRESET, errno.WSAECONNABORTED, errno.</span>
<span class="gd">-        WSAETIMEDOUT)</span>
<span class="gd">-if sys.platform == &#39;darwin&#39;:</span>
<span class="gd">-    _ERRNO_CONNRESET += errno.EPROTOTYPE,</span>
<span class="gd">-_WINDOWS = sys.platform.startswith(&#39;win&#39;)</span>
<span class="gi">+    from typing import Deque, List, Type  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+_IOStreamType = TypeVar(&quot;_IOStreamType&quot;, bound=&quot;IOStream&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# These errnos indicate that a connection has been abruptly terminated.</span>
<span class="gi">+# They should be caught and handled less noisily than other errors.</span>
<span class="gi">+_ERRNO_CONNRESET = (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE, errno.ETIMEDOUT)</span>
<span class="gi">+</span>
<span class="gi">+if hasattr(errno, &quot;WSAECONNRESET&quot;):</span>
<span class="gi">+    _ERRNO_CONNRESET += (  # type: ignore</span>
<span class="gi">+        errno.WSAECONNRESET,  # type: ignore</span>
<span class="gi">+        errno.WSAECONNABORTED,  # type: ignore</span>
<span class="gi">+        errno.WSAETIMEDOUT,  # type: ignore</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+if sys.platform == &quot;darwin&quot;:</span>
<span class="gi">+    # OSX appears to have a race condition that causes send(2) to return</span>
<span class="gi">+    # EPROTOTYPE if called while a socket is being torn down:</span>
<span class="gi">+    # http://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/</span>
<span class="gi">+    # Since the socket is being closed anyway, treat this as an ECONNRESET</span>
<span class="gi">+    # instead of an unexpected error.</span>
<span class="gi">+    _ERRNO_CONNRESET += (errno.EPROTOTYPE,)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+_WINDOWS = sys.platform.startswith(&quot;win&quot;)</span>


<span class="w"> </span>class StreamClosedError(IOError):
<span class="gu">@@ -52,8 +95,8 @@ class StreamClosedError(IOError):</span>
<span class="w"> </span>       Added the ``real_error`` attribute.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, real_error: Optional[BaseException]=None) -&gt;None:</span>
<span class="gd">-        super().__init__(&#39;Stream is closed&#39;)</span>
<span class="gi">+    def __init__(self, real_error: Optional[BaseException] = None) -&gt; None:</span>
<span class="gi">+        super().__init__(&quot;Stream is closed&quot;)</span>
<span class="w"> </span>        self.real_error = real_error


<span class="gu">@@ -63,6 +106,7 @@ class UnsatisfiableReadError(Exception):</span>
<span class="w"> </span>    Raised by ``read_until`` and ``read_until_regex`` with a ``max_bytes``
<span class="w"> </span>    argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -76,33 +120,88 @@ class _StreamBuffer(object):</span>
<span class="w"> </span>    of data are encountered.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self._buffers = collections.deque()</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # A sequence of (False, bytearray) and (True, memoryview) objects</span>
<span class="gi">+        self._buffers = (</span>
<span class="gi">+            collections.deque()</span>
<span class="gi">+        )  # type: Deque[Tuple[bool, Union[bytearray, memoryview]]]</span>
<span class="gi">+        # Position in the first buffer</span>
<span class="w"> </span>        self._first_pos = 0
<span class="w"> </span>        self._size = 0

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self._size
<span class="gi">+</span>
<span class="gi">+    # Data above this size will be appended separately instead</span>
<span class="gi">+    # of extending an existing bytearray</span>
<span class="w"> </span>    _large_buf_threshold = 2048

<span class="gd">-    def append(self, data: Union[bytes, bytearray, memoryview]) -&gt;None:</span>
<span class="gi">+    def append(self, data: Union[bytes, bytearray, memoryview]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Append the given piece of data (should be a buffer-compatible object).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def peek(self, size: int) -&gt;memoryview:</span>
<span class="gi">+        size = len(data)</span>
<span class="gi">+        if size &gt; self._large_buf_threshold:</span>
<span class="gi">+            if not isinstance(data, memoryview):</span>
<span class="gi">+                data = memoryview(data)</span>
<span class="gi">+            self._buffers.append((True, data))</span>
<span class="gi">+        elif size &gt; 0:</span>
<span class="gi">+            if self._buffers:</span>
<span class="gi">+                is_memview, b = self._buffers[-1]</span>
<span class="gi">+                new_buf = is_memview or len(b) &gt;= self._large_buf_threshold</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_buf = True</span>
<span class="gi">+            if new_buf:</span>
<span class="gi">+                self._buffers.append((False, bytearray(data)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                b += data  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        self._size += size</span>
<span class="gi">+</span>
<span class="gi">+    def peek(self, size: int) -&gt; memoryview:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get a view over at most ``size`` bytes (possibly fewer) at the
<span class="w"> </span>        current buffer position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert size &gt; 0</span>
<span class="gi">+        try:</span>
<span class="gi">+            is_memview, b = self._buffers[0]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return memoryview(b&quot;&quot;)</span>

<span class="gd">-    def advance(self, size: int) -&gt;None:</span>
<span class="gi">+        pos = self._first_pos</span>
<span class="gi">+        if is_memview:</span>
<span class="gi">+            return typing.cast(memoryview, b[pos : pos + size])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return memoryview(b)[pos : pos + size]</span>
<span class="gi">+</span>
<span class="gi">+    def advance(self, size: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Advance the current buffer position by ``size`` bytes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt; size &lt;= self._size</span>
<span class="gi">+        self._size -= size</span>
<span class="gi">+        pos = self._first_pos</span>
<span class="gi">+</span>
<span class="gi">+        buffers = self._buffers</span>
<span class="gi">+        while buffers and size &gt; 0:</span>
<span class="gi">+            is_large, b = buffers[0]</span>
<span class="gi">+            b_remain = len(b) - size - pos</span>
<span class="gi">+            if b_remain &lt;= 0:</span>
<span class="gi">+                buffers.popleft()</span>
<span class="gi">+                size -= len(b) - pos</span>
<span class="gi">+                pos = 0</span>
<span class="gi">+            elif is_large:</span>
<span class="gi">+                pos += size</span>
<span class="gi">+                size = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                pos += size</span>
<span class="gi">+                del typing.cast(bytearray, b)[:pos]</span>
<span class="gi">+                pos = 0</span>
<span class="gi">+                size = 0</span>
<span class="gi">+</span>
<span class="gi">+        assert size == 0</span>
<span class="gi">+        self._first_pos = pos</span>


<span class="w"> </span>class BaseIOStream(object):
<span class="gu">@@ -123,8 +222,12 @@ class BaseIOStream(object):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, max_buffer_size: Optional[int]=None, read_chunk_size:</span>
<span class="gd">-        Optional[int]=None, max_write_buffer_size: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        max_buffer_size: Optional[int] = None,</span>
<span class="gi">+        read_chunk_size: Optional[int] = None,</span>
<span class="gi">+        max_write_buffer_size: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;`BaseIOStream` constructor.

<span class="w"> </span>        :arg max_buffer_size: Maximum amount of incoming data to buffer;
<span class="gu">@@ -143,52 +246,59 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.io_loop = ioloop.IOLoop.current()
<span class="w"> </span>        self.max_buffer_size = max_buffer_size or 104857600
<span class="gd">-        self.read_chunk_size = min(read_chunk_size or 65536, self.</span>
<span class="gd">-            max_buffer_size // 2)</span>
<span class="gi">+        # A chunk size that is too close to max_buffer_size can cause</span>
<span class="gi">+        # spurious failures.</span>
<span class="gi">+        self.read_chunk_size = min(read_chunk_size or 65536, self.max_buffer_size // 2)</span>
<span class="w"> </span>        self.max_write_buffer_size = max_write_buffer_size
<span class="gd">-        self.error = None</span>
<span class="gi">+        self.error = None  # type: Optional[BaseException]</span>
<span class="w"> </span>        self._read_buffer = bytearray()
<span class="w"> </span>        self._read_buffer_size = 0
<span class="w"> </span>        self._user_read_buffer = False
<span class="gd">-        self._after_user_read_buffer = None</span>
<span class="gi">+        self._after_user_read_buffer = None  # type: Optional[bytearray]</span>
<span class="w"> </span>        self._write_buffer = _StreamBuffer()
<span class="w"> </span>        self._total_write_index = 0
<span class="w"> </span>        self._total_write_done_index = 0
<span class="gd">-        self._read_delimiter = None</span>
<span class="gd">-        self._read_regex = None</span>
<span class="gd">-        self._read_max_bytes = None</span>
<span class="gd">-        self._read_bytes = None</span>
<span class="gi">+        self._read_delimiter = None  # type: Optional[bytes]</span>
<span class="gi">+        self._read_regex = None  # type: Optional[Pattern]</span>
<span class="gi">+        self._read_max_bytes = None  # type: Optional[int]</span>
<span class="gi">+        self._read_bytes = None  # type: Optional[int]</span>
<span class="w"> </span>        self._read_partial = False
<span class="w"> </span>        self._read_until_close = False
<span class="gd">-        self._read_future = None</span>
<span class="gd">-        self._write_futures = collections.deque()</span>
<span class="gd">-        self._close_callback = None</span>
<span class="gd">-        self._connect_future = None</span>
<span class="gd">-        self._ssl_connect_future = None</span>
<span class="gi">+        self._read_future = None  # type: Optional[Future]</span>
<span class="gi">+        self._write_futures = (</span>
<span class="gi">+            collections.deque()</span>
<span class="gi">+        )  # type: Deque[Tuple[int, Future[None]]]</span>
<span class="gi">+        self._close_callback = None  # type: Optional[Callable[[], None]]</span>
<span class="gi">+        self._connect_future = None  # type: Optional[Future[IOStream]]</span>
<span class="gi">+        # _ssl_connect_future should be defined in SSLIOStream</span>
<span class="gi">+        # but it&#39;s here so we can clean it up in _signal_closed</span>
<span class="gi">+        # TODO: refactor that so subclasses can add additional futures</span>
<span class="gi">+        # to be cancelled.</span>
<span class="gi">+        self._ssl_connect_future = None  # type: Optional[Future[SSLIOStream]]</span>
<span class="w"> </span>        self._connecting = False
<span class="gd">-        self._state = None</span>
<span class="gi">+        self._state = None  # type: Optional[int]</span>
<span class="w"> </span>        self._closed = False

<span class="gd">-    def fileno(self) -&gt;Union[int, ioloop._Selectable]:</span>
<span class="gi">+    def fileno(self) -&gt; Union[int, ioloop._Selectable]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the file descriptor for this stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def close_fd(self) -&gt;None:</span>
<span class="gi">+    def close_fd(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the file underlying this stream.

<span class="w"> </span>        ``close_fd`` is called by `BaseIOStream` and should not be called
<span class="w"> </span>        elsewhere; other users should call `close` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def write_to_fd(self, data: memoryview) -&gt;int:</span>
<span class="gi">+    def write_to_fd(self, data: memoryview) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempts to write ``data`` to the underlying file.

<span class="w"> </span>        Returns the number of bytes written.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def read_from_fd(self, buf: Union[bytearray, memoryview]) -&gt;Optional[int]:</span>
<span class="gi">+    def read_from_fd(self, buf: Union[bytearray, memoryview]) -&gt; Optional[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempts to read from the underlying file.

<span class="w"> </span>        Reads up to ``len(buf)`` bytes, storing them in the buffer.
<span class="gu">@@ -201,9 +311,9 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           Interface redesigned to take a buffer and return a number
<span class="w"> </span>           of bytes instead of a freshly-allocated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def get_fd_error(self) -&gt;Optional[Exception]:</span>
<span class="gi">+    def get_fd_error(self) -&gt; Optional[Exception]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns information about any error on the underlying file.

<span class="w"> </span>        This method is called after the `.IOLoop` has signaled an error on the
<span class="gu">@@ -211,10 +321,11 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        with additional information, or None if no such information is
<span class="w"> </span>        available.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def read_until_regex(self, regex: bytes, max_bytes: Optional[int]=None</span>
<span class="gd">-        ) -&gt;Awaitable[bytes]:</span>
<span class="gi">+    def read_until_regex(</span>
<span class="gi">+        self, regex: bytes, max_bytes: Optional[int] = None</span>
<span class="gi">+    ) -&gt; Awaitable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Asynchronously read until we have matched the given regex.

<span class="w"> </span>        The result includes the data that matches the regex and anything
<span class="gu">@@ -234,10 +345,26 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           `.Future` instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def read_until(self, delimiter: bytes, max_bytes: Optional[int]=None</span>
<span class="gd">-        ) -&gt;Awaitable[bytes]:</span>
<span class="gi">+        future = self._start_read()</span>
<span class="gi">+        self._read_regex = re.compile(regex)</span>
<span class="gi">+        self._read_max_bytes = max_bytes</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._try_inline_read()</span>
<span class="gi">+        except UnsatisfiableReadError as e:</span>
<span class="gi">+            # Handle this the same way as in _handle_events.</span>
<span class="gi">+            gen_log.info(&quot;Unsatisfiable read, closing connection: %s&quot; % e)</span>
<span class="gi">+            self.close(exc_info=e)</span>
<span class="gi">+            return future</span>
<span class="gi">+        except:</span>
<span class="gi">+            # Ensure that the future doesn&#39;t log an error because its</span>
<span class="gi">+            # failure was never examined.</span>
<span class="gi">+            future.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+            raise</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def read_until(</span>
<span class="gi">+        self, delimiter: bytes, max_bytes: Optional[int] = None</span>
<span class="gi">+    ) -&gt; Awaitable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Asynchronously read until we have found the given delimiter.

<span class="w"> </span>        The result includes all the data read including the delimiter.
<span class="gu">@@ -255,10 +382,22 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           The ``callback`` argument was removed. Use the returned
<span class="w"> </span>           `.Future` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def read_bytes(self, num_bytes: int, partial: bool=False) -&gt;Awaitable[bytes</span>
<span class="gd">-        ]:</span>
<span class="gi">+        future = self._start_read()</span>
<span class="gi">+        self._read_delimiter = delimiter</span>
<span class="gi">+        self._read_max_bytes = max_bytes</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._try_inline_read()</span>
<span class="gi">+        except UnsatisfiableReadError as e:</span>
<span class="gi">+            # Handle this the same way as in _handle_events.</span>
<span class="gi">+            gen_log.info(&quot;Unsatisfiable read, closing connection: %s&quot; % e)</span>
<span class="gi">+            self.close(exc_info=e)</span>
<span class="gi">+            return future</span>
<span class="gi">+        except:</span>
<span class="gi">+            future.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+            raise</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def read_bytes(self, num_bytes: int, partial: bool = False) -&gt; Awaitable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Asynchronously read a number of bytes.

<span class="w"> </span>        If ``partial`` is true, data is returned as soon as we have
<span class="gu">@@ -275,9 +414,18 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           ``partial=True`` for ``streaming_callback``) instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = self._start_read()</span>
<span class="gi">+        assert isinstance(num_bytes, numbers.Integral)</span>
<span class="gi">+        self._read_bytes = num_bytes</span>
<span class="gi">+        self._read_partial = partial</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._try_inline_read()</span>
<span class="gi">+        except:</span>
<span class="gi">+            future.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+            raise</span>
<span class="gi">+        return future</span>

<span class="gd">-    def read_into(self, buf: bytearray, partial: bool=False) -&gt;Awaitable[int]:</span>
<span class="gi">+    def read_into(self, buf: bytearray, partial: bool = False) -&gt; Awaitable[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Asynchronously read a number of bytes.

<span class="w"> </span>        ``buf`` must be a writable buffer into which data will be read.
<span class="gu">@@ -294,9 +442,35 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           `.Future` instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = self._start_read()</span>
<span class="gi">+</span>
<span class="gi">+        # First copy data already in read buffer</span>
<span class="gi">+        available_bytes = self._read_buffer_size</span>
<span class="gi">+        n = len(buf)</span>
<span class="gi">+        if available_bytes &gt;= n:</span>
<span class="gi">+            buf[:] = memoryview(self._read_buffer)[:n]</span>
<span class="gi">+            del self._read_buffer[:n]</span>
<span class="gi">+            self._after_user_read_buffer = self._read_buffer</span>
<span class="gi">+        elif available_bytes &gt; 0:</span>
<span class="gi">+            buf[:available_bytes] = memoryview(self._read_buffer)[:]</span>
<span class="gi">+</span>
<span class="gi">+        # Set up the supplied buffer as our temporary read buffer.</span>
<span class="gi">+        # The original (if it had any data remaining) has been</span>
<span class="gi">+        # saved for later.</span>
<span class="gi">+        self._user_read_buffer = True</span>
<span class="gi">+        self._read_buffer = buf</span>
<span class="gi">+        self._read_buffer_size = available_bytes</span>
<span class="gi">+        self._read_bytes = n</span>
<span class="gi">+        self._read_partial = partial</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._try_inline_read()</span>
<span class="gi">+        except:</span>
<span class="gi">+            future.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+            raise</span>
<span class="gi">+        return future</span>

<span class="gd">-    def read_until_close(self) -&gt;Awaitable[bytes]:</span>
<span class="gi">+    def read_until_close(self) -&gt; Awaitable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Asynchronously reads all data from the socket until it is closed.

<span class="w"> </span>        This will buffer all available data until ``max_buffer_size``
<span class="gu">@@ -314,9 +488,19 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           with ``partial=True`` for ``streaming_callback``) instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = self._start_read()</span>
<span class="gi">+        if self.closed():</span>
<span class="gi">+            self._finish_read(self._read_buffer_size)</span>
<span class="gi">+            return future</span>
<span class="gi">+        self._read_until_close = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._try_inline_read()</span>
<span class="gi">+        except:</span>
<span class="gi">+            future.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+            raise</span>
<span class="gi">+        return future</span>

<span class="gd">-    def write(self, data: Union[bytes, memoryview]) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    def write(self, data: Union[bytes, memoryview]) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Asynchronously write the given data to this stream.

<span class="w"> </span>        This method returns a `.Future` that resolves (with a result
<span class="gu">@@ -336,10 +520,29 @@ class BaseIOStream(object):</span>
<span class="w"> </span>           `.Future` instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_close_callback(self, callback: Optional[Callable[[], None]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        self._check_closed()</span>
<span class="gi">+        if data:</span>
<span class="gi">+            if isinstance(data, memoryview):</span>
<span class="gi">+                # Make sure that ``len(data) == data.nbytes``</span>
<span class="gi">+                data = memoryview(data).cast(&quot;B&quot;)</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.max_write_buffer_size is not None</span>
<span class="gi">+                and len(self._write_buffer) + len(data) &gt; self.max_write_buffer_size</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise StreamBufferFullError(&quot;Reached maximum write buffer size&quot;)</span>
<span class="gi">+            self._write_buffer.append(data)</span>
<span class="gi">+            self._total_write_index += len(data)</span>
<span class="gi">+        future = Future()  # type: Future[None]</span>
<span class="gi">+        future.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+        self._write_futures.append((self._total_write_index, future))</span>
<span class="gi">+        if not self._connecting:</span>
<span class="gi">+            self._handle_write()</span>
<span class="gi">+            if self._write_buffer:</span>
<span class="gi">+                self._add_io_state(self.io_loop.WRITE)</span>
<span class="gi">+            self._maybe_add_error_listener()</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def set_close_callback(self, callback: Optional[Callable[[], None]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call the given callback when the stream is closed.

<span class="w"> </span>        This mostly is not necessary for applications that use the
<span class="gu">@@ -351,32 +554,109 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        Unlike other callback-based interfaces, ``set_close_callback``
<span class="w"> </span>        was not removed in Tornado 6.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def close(self, exc_info: Union[None, bool, BaseException, Tuple[</span>
<span class="gd">-        &#39;Optional[Type[BaseException]]&#39;, Optional[BaseException], Optional[</span>
<span class="gd">-        TracebackType]]]=False) -&gt;None:</span>
<span class="gi">+        self._close_callback = callback</span>
<span class="gi">+        self._maybe_add_error_listener()</span>
<span class="gi">+</span>
<span class="gi">+    def close(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_info: Union[</span>
<span class="gi">+            None,</span>
<span class="gi">+            bool,</span>
<span class="gi">+            BaseException,</span>
<span class="gi">+            Tuple[</span>
<span class="gi">+                &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+                Optional[BaseException],</span>
<span class="gi">+                Optional[TracebackType],</span>
<span class="gi">+            ],</span>
<span class="gi">+        ] = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Close this stream.

<span class="w"> </span>        If ``exc_info`` is true, set the ``error`` attribute to the current
<span class="w"> </span>        exception from `sys.exc_info` (or if ``exc_info`` is a tuple,
<span class="w"> </span>        use that instead of `sys.exc_info`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def reading(self) -&gt;bool:</span>
<span class="gi">+        if not self.closed():</span>
<span class="gi">+            if exc_info:</span>
<span class="gi">+                if isinstance(exc_info, tuple):</span>
<span class="gi">+                    self.error = exc_info[1]</span>
<span class="gi">+                elif isinstance(exc_info, BaseException):</span>
<span class="gi">+                    self.error = exc_info</span>
<span class="gi">+                else:</span>
<span class="gi">+                    exc_info = sys.exc_info()</span>
<span class="gi">+                    if any(exc_info):</span>
<span class="gi">+                        self.error = exc_info[1]</span>
<span class="gi">+            if self._read_until_close:</span>
<span class="gi">+                self._read_until_close = False</span>
<span class="gi">+                self._finish_read(self._read_buffer_size)</span>
<span class="gi">+            elif self._read_future is not None:</span>
<span class="gi">+                # resolve reads that are pending and ready to complete</span>
<span class="gi">+                try:</span>
<span class="gi">+                    pos = self._find_read_pos()</span>
<span class="gi">+                except UnsatisfiableReadError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if pos is not None:</span>
<span class="gi">+                        self._read_from_buffer(pos)</span>
<span class="gi">+            if self._state is not None:</span>
<span class="gi">+                self.io_loop.remove_handler(self.fileno())</span>
<span class="gi">+                self._state = None</span>
<span class="gi">+            self.close_fd()</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+        self._signal_closed()</span>
<span class="gi">+</span>
<span class="gi">+    def _signal_closed(self) -&gt; None:</span>
<span class="gi">+        futures = []  # type: List[Future]</span>
<span class="gi">+        if self._read_future is not None:</span>
<span class="gi">+            futures.append(self._read_future)</span>
<span class="gi">+            self._read_future = None</span>
<span class="gi">+        futures += [future for _, future in self._write_futures]</span>
<span class="gi">+        self._write_futures.clear()</span>
<span class="gi">+        if self._connect_future is not None:</span>
<span class="gi">+            futures.append(self._connect_future)</span>
<span class="gi">+            self._connect_future = None</span>
<span class="gi">+        for future in futures:</span>
<span class="gi">+            if not future.done():</span>
<span class="gi">+                future.set_exception(StreamClosedError(real_error=self.error))</span>
<span class="gi">+            # Reference the exception to silence warnings. Annoyingly,</span>
<span class="gi">+            # this raises if the future was cancelled, but just</span>
<span class="gi">+            # returns any other error.</span>
<span class="gi">+            try:</span>
<span class="gi">+                future.exception()</span>
<span class="gi">+            except asyncio.CancelledError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        if self._ssl_connect_future is not None:</span>
<span class="gi">+            # _ssl_connect_future expects to see the real exception (typically</span>
<span class="gi">+            # an ssl.SSLError), not just StreamClosedError.</span>
<span class="gi">+            if not self._ssl_connect_future.done():</span>
<span class="gi">+                if self.error is not None:</span>
<span class="gi">+                    self._ssl_connect_future.set_exception(self.error)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._ssl_connect_future.set_exception(StreamClosedError())</span>
<span class="gi">+            self._ssl_connect_future.exception()</span>
<span class="gi">+            self._ssl_connect_future = None</span>
<span class="gi">+        if self._close_callback is not None:</span>
<span class="gi">+            cb = self._close_callback</span>
<span class="gi">+            self._close_callback = None</span>
<span class="gi">+            self.io_loop.add_callback(cb)</span>
<span class="gi">+        # Clear the buffers so they can be cleared immediately even</span>
<span class="gi">+        # if the IOStream object is kept alive by a reference cycle.</span>
<span class="gi">+        # TODO: Clear the read buffer too; it currently breaks some tests.</span>
<span class="gi">+        self._write_buffer = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def reading(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if we are currently reading from the stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._read_future is not None</span>

<span class="gd">-    def writing(self) -&gt;bool:</span>
<span class="gi">+    def writing(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if we are currently writing to the stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self._write_buffer)</span>

<span class="gd">-    def closed(self) -&gt;bool:</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if the stream has been closed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._closed</span>

<span class="gd">-    def set_nodelay(self, value: bool) -&gt;None:</span>
<span class="gi">+    def set_nodelay(self, value: bool) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the no-delay flag for this stream.

<span class="w"> </span>        By default, data written to TCP streams may be held for a time
<span class="gu">@@ -391,42 +671,348 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def _try_inline_read(self) -&gt;None:</span>
<span class="gi">+    def _handle_connect(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_events(self, fd: Union[int, ioloop._Selectable], events: int) -&gt; None:</span>
<span class="gi">+        if self.closed():</span>
<span class="gi">+            gen_log.warning(&quot;Got events for closed stream %s&quot;, fd)</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self._connecting:</span>
<span class="gi">+                # Most IOLoops will report a write failed connect</span>
<span class="gi">+                # with the WRITE event, but SelectIOLoop reports a</span>
<span class="gi">+                # READ as well so we must check for connecting before</span>
<span class="gi">+                # either.</span>
<span class="gi">+                self._handle_connect()</span>
<span class="gi">+            if self.closed():</span>
<span class="gi">+                return</span>
<span class="gi">+            if events &amp; self.io_loop.READ:</span>
<span class="gi">+                self._handle_read()</span>
<span class="gi">+            if self.closed():</span>
<span class="gi">+                return</span>
<span class="gi">+            if events &amp; self.io_loop.WRITE:</span>
<span class="gi">+                self._handle_write()</span>
<span class="gi">+            if self.closed():</span>
<span class="gi">+                return</span>
<span class="gi">+            if events &amp; self.io_loop.ERROR:</span>
<span class="gi">+                self.error = self.get_fd_error()</span>
<span class="gi">+                # We may have queued up a user callback in _handle_read or</span>
<span class="gi">+                # _handle_write, so don&#39;t close the IOStream until those</span>
<span class="gi">+                # callbacks have had a chance to run.</span>
<span class="gi">+                self.io_loop.add_callback(self.close)</span>
<span class="gi">+                return</span>
<span class="gi">+            state = self.io_loop.ERROR</span>
<span class="gi">+            if self.reading():</span>
<span class="gi">+                state |= self.io_loop.READ</span>
<span class="gi">+            if self.writing():</span>
<span class="gi">+                state |= self.io_loop.WRITE</span>
<span class="gi">+            if state == self.io_loop.ERROR and self._read_buffer_size == 0:</span>
<span class="gi">+                # If the connection is idle, listen for reads too so</span>
<span class="gi">+                # we can tell if the connection is closed.  If there is</span>
<span class="gi">+                # data in the read buffer we won&#39;t run the close callback</span>
<span class="gi">+                # yet anyway, so we don&#39;t need to listen in this case.</span>
<span class="gi">+                state |= self.io_loop.READ</span>
<span class="gi">+            if state != self._state:</span>
<span class="gi">+                assert (</span>
<span class="gi">+                    self._state is not None</span>
<span class="gi">+                ), &quot;shouldn&#39;t happen: _handle_events without self._state&quot;</span>
<span class="gi">+                self._state = state</span>
<span class="gi">+                self.io_loop.update_handler(self.fileno(), self._state)</span>
<span class="gi">+        except UnsatisfiableReadError as e:</span>
<span class="gi">+            gen_log.info(&quot;Unsatisfiable read, closing connection: %s&quot; % e)</span>
<span class="gi">+            self.close(exc_info=e)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            gen_log.error(&quot;Uncaught exception, closing connection.&quot;, exc_info=True)</span>
<span class="gi">+            self.close(exc_info=e)</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _read_to_buffer_loop(self) -&gt; Optional[int]:</span>
<span class="gi">+        # This method is called from _handle_read and _try_inline_read.</span>
<span class="gi">+        if self._read_bytes is not None:</span>
<span class="gi">+            target_bytes = self._read_bytes  # type: Optional[int]</span>
<span class="gi">+        elif self._read_max_bytes is not None:</span>
<span class="gi">+            target_bytes = self._read_max_bytes</span>
<span class="gi">+        elif self.reading():</span>
<span class="gi">+            # For read_until without max_bytes, or</span>
<span class="gi">+            # read_until_close, read as much as we can before</span>
<span class="gi">+            # scanning for the delimiter.</span>
<span class="gi">+            target_bytes = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            target_bytes = 0</span>
<span class="gi">+        next_find_pos = 0</span>
<span class="gi">+        while not self.closed():</span>
<span class="gi">+            # Read from the socket until we get EWOULDBLOCK or equivalent.</span>
<span class="gi">+            # SSL sockets do some internal buffering, and if the data is</span>
<span class="gi">+            # sitting in the SSL object&#39;s buffer select() and friends</span>
<span class="gi">+            # can&#39;t see it; the only way to find out if it&#39;s there is to</span>
<span class="gi">+            # try to read it.</span>
<span class="gi">+            if self._read_to_buffer() == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # If we&#39;ve read all the bytes we can use, break out of</span>
<span class="gi">+            # this loop.</span>
<span class="gi">+</span>
<span class="gi">+            # If we&#39;ve reached target_bytes, we know we&#39;re done.</span>
<span class="gi">+            if target_bytes is not None and self._read_buffer_size &gt;= target_bytes:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise, we need to call the more expensive find_read_pos.</span>
<span class="gi">+            # It&#39;s inefficient to do this on every read, so instead</span>
<span class="gi">+            # do it on the first read and whenever the read buffer</span>
<span class="gi">+            # size has doubled.</span>
<span class="gi">+            if self._read_buffer_size &gt;= next_find_pos:</span>
<span class="gi">+                pos = self._find_read_pos()</span>
<span class="gi">+                if pos is not None:</span>
<span class="gi">+                    return pos</span>
<span class="gi">+                next_find_pos = self._read_buffer_size * 2</span>
<span class="gi">+        return self._find_read_pos()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_read(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            pos = self._read_to_buffer_loop()</span>
<span class="gi">+        except UnsatisfiableReadError:</span>
<span class="gi">+            raise</span>
<span class="gi">+        except asyncio.CancelledError:</span>
<span class="gi">+            raise</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            gen_log.warning(&quot;error on read: %s&quot; % e)</span>
<span class="gi">+            self.close(exc_info=e)</span>
<span class="gi">+            return</span>
<span class="gi">+        if pos is not None:</span>
<span class="gi">+            self._read_from_buffer(pos)</span>
<span class="gi">+</span>
<span class="gi">+    def _start_read(self) -&gt; Future:</span>
<span class="gi">+        if self._read_future is not None:</span>
<span class="gi">+            # It is an error to start a read while a prior read is unresolved.</span>
<span class="gi">+            # However, if the prior read is unresolved because the stream was</span>
<span class="gi">+            # closed without satisfying it, it&#39;s better to raise</span>
<span class="gi">+            # StreamClosedError instead of AssertionError. In particular, this</span>
<span class="gi">+            # situation occurs in harmless situations in http1connection.py and</span>
<span class="gi">+            # an AssertionError would be logged noisily.</span>
<span class="gi">+            #</span>
<span class="gi">+            # On the other hand, it is legal to start a new read while the</span>
<span class="gi">+            # stream is closed, in case the read can be satisfied from the</span>
<span class="gi">+            # read buffer. So we only want to check the closed status of the</span>
<span class="gi">+            # stream if we need to decide what kind of error to raise for</span>
<span class="gi">+            # &quot;already reading&quot;.</span>
<span class="gi">+            #</span>
<span class="gi">+            # These conditions have proven difficult to test; we have no</span>
<span class="gi">+            # unittests that reliably verify this behavior so be careful</span>
<span class="gi">+            # when making changes here. See #2651 and #2719.</span>
<span class="gi">+            self._check_closed()</span>
<span class="gi">+            assert self._read_future is None, &quot;Already reading&quot;</span>
<span class="gi">+        self._read_future = Future()</span>
<span class="gi">+        return self._read_future</span>
<span class="gi">+</span>
<span class="gi">+    def _finish_read(self, size: int) -&gt; None:</span>
<span class="gi">+        if self._user_read_buffer:</span>
<span class="gi">+            self._read_buffer = self._after_user_read_buffer or bytearray()</span>
<span class="gi">+            self._after_user_read_buffer = None</span>
<span class="gi">+            self._read_buffer_size = len(self._read_buffer)</span>
<span class="gi">+            self._user_read_buffer = False</span>
<span class="gi">+            result = size  # type: Union[int, bytes]</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = self._consume(size)</span>
<span class="gi">+        if self._read_future is not None:</span>
<span class="gi">+            future = self._read_future</span>
<span class="gi">+            self._read_future = None</span>
<span class="gi">+            future_set_result_unless_cancelled(future, result)</span>
<span class="gi">+        self._maybe_add_error_listener()</span>
<span class="gi">+</span>
<span class="gi">+    def _try_inline_read(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempt to complete the current read operation from buffered data.

<span class="w"> </span>        If the read can be completed without blocking, schedules the
<span class="w"> </span>        read callback on the next IOLoop iteration; otherwise starts
<span class="w"> </span>        listening for reads on the socket.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _read_to_buffer(self) -&gt;Optional[int]:</span>
<span class="gi">+        # See if we&#39;ve already got the data from a previous read</span>
<span class="gi">+        pos = self._find_read_pos()</span>
<span class="gi">+        if pos is not None:</span>
<span class="gi">+            self._read_from_buffer(pos)</span>
<span class="gi">+            return</span>
<span class="gi">+        self._check_closed()</span>
<span class="gi">+        pos = self._read_to_buffer_loop()</span>
<span class="gi">+        if pos is not None:</span>
<span class="gi">+            self._read_from_buffer(pos)</span>
<span class="gi">+            return</span>
<span class="gi">+        # We couldn&#39;t satisfy the read inline, so make sure we&#39;re</span>
<span class="gi">+        # listening for new data unless the stream is closed.</span>
<span class="gi">+        if not self.closed():</span>
<span class="gi">+            self._add_io_state(ioloop.IOLoop.READ)</span>
<span class="gi">+</span>
<span class="gi">+    def _read_to_buffer(self) -&gt; Optional[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reads from the socket and appends the result to the read buffer.

<span class="w"> </span>        Returns the number of bytes read.  Returns 0 if there is nothing
<span class="w"> </span>        to read (i.e. the read returns EWOULDBLOCK or equivalent).  On
<span class="w"> </span>        error closes the socket and raises an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _read_from_buffer(self, pos: int) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    if self._user_read_buffer:</span>
<span class="gi">+                        buf = memoryview(self._read_buffer)[</span>
<span class="gi">+                            self._read_buffer_size :</span>
<span class="gi">+                        ]  # type: Union[memoryview, bytearray]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        buf = bytearray(self.read_chunk_size)</span>
<span class="gi">+                    bytes_read = self.read_from_fd(buf)</span>
<span class="gi">+                except (socket.error, IOError, OSError) as e:</span>
<span class="gi">+                    # ssl.SSLError is a subclass of socket.error</span>
<span class="gi">+                    if self._is_connreset(e):</span>
<span class="gi">+                        # Treat ECONNRESET as a connection close rather than</span>
<span class="gi">+                        # an error to minimize log spam  (the exception will</span>
<span class="gi">+                        # be available on self.error for apps that care).</span>
<span class="gi">+                        self.close(exc_info=e)</span>
<span class="gi">+                        return None</span>
<span class="gi">+                    self.close(exc_info=e)</span>
<span class="gi">+                    raise</span>
<span class="gi">+                break</span>
<span class="gi">+            if bytes_read is None:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            elif bytes_read == 0:</span>
<span class="gi">+                self.close()</span>
<span class="gi">+                return 0</span>
<span class="gi">+            if not self._user_read_buffer:</span>
<span class="gi">+                self._read_buffer += memoryview(buf)[:bytes_read]</span>
<span class="gi">+            self._read_buffer_size += bytes_read</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Break the reference to buf so we don&#39;t waste a chunk&#39;s worth of</span>
<span class="gi">+            # memory in case an exception hangs on to our stack frame.</span>
<span class="gi">+            del buf</span>
<span class="gi">+        if self._read_buffer_size &gt; self.max_buffer_size:</span>
<span class="gi">+            gen_log.error(&quot;Reached maximum read buffer size&quot;)</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise StreamBufferFullError(&quot;Reached maximum read buffer size&quot;)</span>
<span class="gi">+        return bytes_read</span>
<span class="gi">+</span>
<span class="gi">+    def _read_from_buffer(self, pos: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempts to complete the currently-pending read from the buffer.

<span class="w"> </span>        The argument is either a position in the read buffer or None,
<span class="w"> </span>        as returned by _find_read_pos.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._read_bytes = self._read_delimiter = self._read_regex = None</span>
<span class="gi">+        self._read_partial = False</span>
<span class="gi">+        self._finish_read(pos)</span>

<span class="gd">-    def _find_read_pos(self) -&gt;Optional[int]:</span>
<span class="gi">+    def _find_read_pos(self) -&gt; Optional[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempts to find a position in the read buffer that satisfies
<span class="w"> </span>        the currently-pending read.

<span class="w"> </span>        Returns a position in the buffer if the current read can be satisfied,
<span class="w"> </span>        or None if it cannot.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _add_io_state(self, state: int) -&gt;None:</span>
<span class="gi">+        if self._read_bytes is not None and (</span>
<span class="gi">+            self._read_buffer_size &gt;= self._read_bytes</span>
<span class="gi">+            or (self._read_partial and self._read_buffer_size &gt; 0)</span>
<span class="gi">+        ):</span>
<span class="gi">+            num_bytes = min(self._read_bytes, self._read_buffer_size)</span>
<span class="gi">+            return num_bytes</span>
<span class="gi">+        elif self._read_delimiter is not None:</span>
<span class="gi">+            # Multi-byte delimiters (e.g. &#39;\r\n&#39;) may straddle two</span>
<span class="gi">+            # chunks in the read buffer, so we can&#39;t easily find them</span>
<span class="gi">+            # without collapsing the buffer.  However, since protocols</span>
<span class="gi">+            # using delimited reads (as opposed to reads of a known</span>
<span class="gi">+            # length) tend to be &quot;line&quot; oriented, the delimiter is likely</span>
<span class="gi">+            # to be in the first few chunks.  Merge the buffer gradually</span>
<span class="gi">+            # since large merges are relatively expensive and get undone in</span>
<span class="gi">+            # _consume().</span>
<span class="gi">+            if self._read_buffer:</span>
<span class="gi">+                loc = self._read_buffer.find(self._read_delimiter)</span>
<span class="gi">+                if loc != -1:</span>
<span class="gi">+                    delimiter_len = len(self._read_delimiter)</span>
<span class="gi">+                    self._check_max_bytes(self._read_delimiter, loc + delimiter_len)</span>
<span class="gi">+                    return loc + delimiter_len</span>
<span class="gi">+                self._check_max_bytes(self._read_delimiter, self._read_buffer_size)</span>
<span class="gi">+        elif self._read_regex is not None:</span>
<span class="gi">+            if self._read_buffer:</span>
<span class="gi">+                m = self._read_regex.search(self._read_buffer)</span>
<span class="gi">+                if m is not None:</span>
<span class="gi">+                    loc = m.end()</span>
<span class="gi">+                    self._check_max_bytes(self._read_regex, loc)</span>
<span class="gi">+                    return loc</span>
<span class="gi">+                self._check_max_bytes(self._read_regex, self._read_buffer_size)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _check_max_bytes(self, delimiter: Union[bytes, Pattern], size: int) -&gt; None:</span>
<span class="gi">+        if self._read_max_bytes is not None and size &gt; self._read_max_bytes:</span>
<span class="gi">+            raise UnsatisfiableReadError(</span>
<span class="gi">+                &quot;delimiter %r not found within %d bytes&quot;</span>
<span class="gi">+                % (delimiter, self._read_max_bytes)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_write(self) -&gt; None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            size = len(self._write_buffer)</span>
<span class="gi">+            if not size:</span>
<span class="gi">+                break</span>
<span class="gi">+            assert size &gt; 0</span>
<span class="gi">+            try:</span>
<span class="gi">+                if _WINDOWS:</span>
<span class="gi">+                    # On windows, socket.send blows up if given a</span>
<span class="gi">+                    # write buffer that&#39;s too large, instead of just</span>
<span class="gi">+                    # returning the number of bytes it was able to</span>
<span class="gi">+                    # process.  Therefore we must not call socket.send</span>
<span class="gi">+                    # with more than 128KB at a time.</span>
<span class="gi">+                    size = 128 * 1024</span>
<span class="gi">+</span>
<span class="gi">+                num_bytes = self.write_to_fd(self._write_buffer.peek(size))</span>
<span class="gi">+                if num_bytes == 0:</span>
<span class="gi">+                    break</span>
<span class="gi">+                self._write_buffer.advance(num_bytes)</span>
<span class="gi">+                self._total_write_done_index += num_bytes</span>
<span class="gi">+            except BlockingIOError:</span>
<span class="gi">+                break</span>
<span class="gi">+            except (socket.error, IOError, OSError) as e:</span>
<span class="gi">+                if not self._is_connreset(e):</span>
<span class="gi">+                    # Broken pipe errors are usually caused by connection</span>
<span class="gi">+                    # reset, and its better to not log EPIPE errors to</span>
<span class="gi">+                    # minimize log spam</span>
<span class="gi">+                    gen_log.warning(&quot;Write error on %s: %s&quot;, self.fileno(), e)</span>
<span class="gi">+                self.close(exc_info=e)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        while self._write_futures:</span>
<span class="gi">+            index, future = self._write_futures[0]</span>
<span class="gi">+            if index &gt; self._total_write_done_index:</span>
<span class="gi">+                break</span>
<span class="gi">+            self._write_futures.popleft()</span>
<span class="gi">+            future_set_result_unless_cancelled(future, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _consume(self, loc: int) -&gt; bytes:</span>
<span class="gi">+        # Consume loc bytes from the read buffer and return them</span>
<span class="gi">+        if loc == 0:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        assert loc &lt;= self._read_buffer_size</span>
<span class="gi">+        # Slice the bytearray buffer into bytes, without intermediate copying</span>
<span class="gi">+        b = (memoryview(self._read_buffer)[:loc]).tobytes()</span>
<span class="gi">+        self._read_buffer_size -= loc</span>
<span class="gi">+        del self._read_buffer[:loc]</span>
<span class="gi">+        return b</span>
<span class="gi">+</span>
<span class="gi">+    def _check_closed(self) -&gt; None:</span>
<span class="gi">+        if self.closed():</span>
<span class="gi">+            raise StreamClosedError(real_error=self.error)</span>
<span class="gi">+</span>
<span class="gi">+    def _maybe_add_error_listener(self) -&gt; None:</span>
<span class="gi">+        # This method is part of an optimization: to detect a connection that</span>
<span class="gi">+        # is closed when we&#39;re not actively reading or writing, we must listen</span>
<span class="gi">+        # for read events.  However, it is inefficient to do this when the</span>
<span class="gi">+        # connection is first established because we are going to read or write</span>
<span class="gi">+        # immediately anyway.  Instead, we insert checks at various times to</span>
<span class="gi">+        # see if the connection is idle and add the read listener then.</span>
<span class="gi">+        if self._state is None or self._state == ioloop.IOLoop.ERROR:</span>
<span class="gi">+            if (</span>
<span class="gi">+                not self.closed()</span>
<span class="gi">+                and self._read_buffer_size == 0</span>
<span class="gi">+                and self._close_callback is not None</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._add_io_state(ioloop.IOLoop.READ)</span>
<span class="gi">+</span>
<span class="gi">+    def _add_io_state(self, state: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.

<span class="w"> </span>        Implementation notes: Reads and writes have a fast path and a
<span class="gu">@@ -445,18 +1031,29 @@ class BaseIOStream(object):</span>
<span class="w"> </span>        TODO: reevaluate this now that callbacks are gone.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _is_connreset(self, exc: BaseException) -&gt;bool:</span>
<span class="gi">+        if self.closed():</span>
<span class="gi">+            # connection has been closed, so there can be no future events</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._state is None:</span>
<span class="gi">+            self._state = ioloop.IOLoop.ERROR | state</span>
<span class="gi">+            self.io_loop.add_handler(self.fileno(), self._handle_events, self._state)</span>
<span class="gi">+        elif not self._state &amp; state:</span>
<span class="gi">+            self._state = self._state | state</span>
<span class="gi">+            self.io_loop.update_handler(self.fileno(), self._state)</span>
<span class="gi">+</span>
<span class="gi">+    def _is_connreset(self, exc: BaseException) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if exc is ECONNRESET or equivalent.

<span class="w"> </span>        May be overridden in subclasses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(exc, (socket.error, IOError))</span>
<span class="gi">+            and errno_from_exception(exc) in _ERRNO_CONNRESET</span>
<span class="gi">+        )</span>


<span class="w"> </span>class IOStream(BaseIOStream):
<span class="gd">-    &quot;&quot;&quot;Socket-based `IOStream` implementation.</span>
<span class="gi">+    r&quot;&quot;&quot;Socket-based `IOStream` implementation.</span>

<span class="w"> </span>    This class supports the read and write methods from `BaseIOStream`
<span class="w"> </span>    plus a `connect` method.
<span class="gu">@@ -479,10 +1076,10 @@ class IOStream(BaseIOStream):</span>
<span class="w"> </span>            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
<span class="w"> </span>            stream = tornado.iostream.IOStream(s)
<span class="w"> </span>            await stream.connect((&quot;friendfeed.com&quot;, 80))
<span class="gd">-            await stream.write(b&quot;GET / HTTP/1.0\\r\\nHost: friendfeed.com\\r\\n\\r\\n&quot;)</span>
<span class="gd">-            header_data = await stream.read_until(b&quot;\\r\\n\\r\\n&quot;)</span>
<span class="gi">+            await stream.write(b&quot;GET / HTTP/1.0\r\nHost: friendfeed.com\r\n\r\n&quot;)</span>
<span class="gi">+            header_data = await stream.read_until(b&quot;\r\n\r\n&quot;)</span>
<span class="w"> </span>            headers = {}
<span class="gd">-            for line in header_data.split(b&quot;\\r\\n&quot;):</span>
<span class="gi">+            for line in header_data.split(b&quot;\r\n&quot;):</span>
<span class="w"> </span>                parts = line.split(b&quot;:&quot;)
<span class="w"> </span>                if len(parts) == 2:
<span class="w"> </span>                    headers[parts[0].strip()] = parts[1].strip()
<span class="gu">@@ -498,14 +1095,41 @@ class IOStream(BaseIOStream):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, socket: socket.socket, *args: Any, **kwargs: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, socket: socket.socket, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.socket = socket
<span class="w"> </span>        self.socket.setblocking(False)
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gd">-    def connect(self: _IOStreamType, address: Any, server_hostname:</span>
<span class="gd">-        Optional[str]=None) -&gt;&#39;Future[_IOStreamType]&#39;:</span>
<span class="gi">+    def fileno(self) -&gt; Union[int, ioloop._Selectable]:</span>
<span class="gi">+        return self.socket</span>
<span class="gi">+</span>
<span class="gi">+    def close_fd(self) -&gt; None:</span>
<span class="gi">+        self.socket.close()</span>
<span class="gi">+        self.socket = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def get_fd_error(self) -&gt; Optional[Exception]:</span>
<span class="gi">+        errno = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)</span>
<span class="gi">+        return socket.error(errno, os.strerror(errno))</span>
<span class="gi">+</span>
<span class="gi">+    def read_from_fd(self, buf: Union[bytearray, memoryview]) -&gt; Optional[int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.socket.recv_into(buf, len(buf))</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            return None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            del buf</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_fd(self, data: memoryview) -&gt; int:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.socket.send(data)  # type: ignore</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Avoid keeping to data, which can be a memoryview.</span>
<span class="gi">+            # See https://github.com/tornadoweb/tornado/pull/2008</span>
<span class="gi">+            del data</span>
<span class="gi">+</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self: _IOStreamType, address: Any, server_hostname: Optional[str] = None</span>
<span class="gi">+    ) -&gt; &quot;Future[_IOStreamType]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Connects the socket to a remote address without blocking.

<span class="w"> </span>        May only be called if the socket passed to the constructor was
<span class="gu">@@ -550,11 +1174,33 @@ class IOStream(BaseIOStream):</span>
<span class="w"> </span>           `.Future` instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def start_tls(self, server_side: bool, ssl_options: Optional[Union[Dict</span>
<span class="gd">-        [str, Any], ssl.SSLContext]]=None, server_hostname: Optional[str]=None</span>
<span class="gd">-        ) -&gt;Awaitable[&#39;SSLIOStream&#39;]:</span>
<span class="gi">+        self._connecting = True</span>
<span class="gi">+        future = Future()  # type: Future[_IOStreamType]</span>
<span class="gi">+        self._connect_future = typing.cast(&quot;Future[IOStream]&quot;, future)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.socket.connect(address)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            # In non-blocking mode we expect connect() to raise an</span>
<span class="gi">+            # exception with EINPROGRESS or EWOULDBLOCK.</span>
<span class="gi">+            pass</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            # On freebsd, other errors such as ECONNREFUSED may be</span>
<span class="gi">+            # returned immediately when attempting to connect to</span>
<span class="gi">+            # localhost, so handle them the same way as an error</span>
<span class="gi">+            # reported later in _handle_connect.</span>
<span class="gi">+            if future is None:</span>
<span class="gi">+                gen_log.warning(&quot;Connect error on fd %s: %s&quot;, self.socket.fileno(), e)</span>
<span class="gi">+            self.close(exc_info=e)</span>
<span class="gi">+            return future</span>
<span class="gi">+        self._add_io_state(self.io_loop.WRITE)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def start_tls(</span>
<span class="gi">+        self,</span>
<span class="gi">+        server_side: bool,</span>
<span class="gi">+        ssl_options: Optional[Union[Dict[str, Any], ssl.SSLContext]] = None,</span>
<span class="gi">+        server_hostname: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; Awaitable[&quot;SSLIOStream&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert this `IOStream` to an `SSLIOStream`.

<span class="w"> </span>        This enables protocols that begin in clear-text mode and
<span class="gu">@@ -589,7 +1235,85 @@ class IOStream(BaseIOStream):</span>
<span class="w"> </span>           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a
<span class="w"> </span>           suitably-configured `ssl.SSLContext` to disable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._read_future</span>
<span class="gi">+            or self._write_futures</span>
<span class="gi">+            or self._connect_future</span>
<span class="gi">+            or self._closed</span>
<span class="gi">+            or self._read_buffer</span>
<span class="gi">+            or self._write_buffer</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise ValueError(&quot;IOStream is not idle; cannot convert to SSL&quot;)</span>
<span class="gi">+        if ssl_options is None:</span>
<span class="gi">+            if server_side:</span>
<span class="gi">+                ssl_options = _server_ssl_defaults</span>
<span class="gi">+            else:</span>
<span class="gi">+                ssl_options = _client_ssl_defaults</span>
<span class="gi">+</span>
<span class="gi">+        socket = self.socket</span>
<span class="gi">+        self.io_loop.remove_handler(socket)</span>
<span class="gi">+        self.socket = None  # type: ignore</span>
<span class="gi">+        socket = ssl_wrap_socket(</span>
<span class="gi">+            socket,</span>
<span class="gi">+            ssl_options,</span>
<span class="gi">+            server_hostname=server_hostname,</span>
<span class="gi">+            server_side=server_side,</span>
<span class="gi">+            do_handshake_on_connect=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        orig_close_callback = self._close_callback</span>
<span class="gi">+        self._close_callback = None</span>
<span class="gi">+</span>
<span class="gi">+        future = Future()  # type: Future[SSLIOStream]</span>
<span class="gi">+        ssl_stream = SSLIOStream(socket, ssl_options=ssl_options)</span>
<span class="gi">+        ssl_stream.set_close_callback(orig_close_callback)</span>
<span class="gi">+        ssl_stream._ssl_connect_future = future</span>
<span class="gi">+        ssl_stream.max_buffer_size = self.max_buffer_size</span>
<span class="gi">+        ssl_stream.read_chunk_size = self.read_chunk_size</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_connect(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            # Hurd doesn&#39;t allow SO_ERROR for loopback sockets because all</span>
<span class="gi">+            # errors for such sockets are reported synchronously.</span>
<span class="gi">+            if errno_from_exception(e) == errno.ENOPROTOOPT:</span>
<span class="gi">+                err = 0</span>
<span class="gi">+        if err != 0:</span>
<span class="gi">+            self.error = socket.error(err, os.strerror(err))</span>
<span class="gi">+            # IOLoop implementations may vary: some of them return</span>
<span class="gi">+            # an error state before the socket becomes writable, so</span>
<span class="gi">+            # in that case a connection failure would be handled by the</span>
<span class="gi">+            # error path in _handle_events instead of here.</span>
<span class="gi">+            if self._connect_future is None:</span>
<span class="gi">+                gen_log.warning(</span>
<span class="gi">+                    &quot;Connect error on fd %s: %s&quot;,</span>
<span class="gi">+                    self.socket.fileno(),</span>
<span class="gi">+                    errno.errorcode[err],</span>
<span class="gi">+                )</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._connect_future is not None:</span>
<span class="gi">+            future = self._connect_future</span>
<span class="gi">+            self._connect_future = None</span>
<span class="gi">+            future_set_result_unless_cancelled(future, self)</span>
<span class="gi">+        self._connecting = False</span>
<span class="gi">+</span>
<span class="gi">+    def set_nodelay(self, value: bool) -&gt; None:</span>
<span class="gi">+        if self.socket is not None and self.socket.family in (</span>
<span class="gi">+            socket.AF_INET,</span>
<span class="gi">+            socket.AF_INET6,</span>
<span class="gi">+        ):</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.socket.setsockopt(</span>
<span class="gi">+                    socket.IPPROTO_TCP, socket.TCP_NODELAY, 1 if value else 0</span>
<span class="gi">+                )</span>
<span class="gi">+            except socket.error as e:</span>
<span class="gi">+                # Sometimes setsockopt will fail if the socket is closed</span>
<span class="gi">+                # at the wrong time.  This can happen with HTTPServer</span>
<span class="gi">+                # resetting the value to ``False`` between requests.</span>
<span class="gi">+                if e.errno != errno.EINVAL and not self._is_connreset(e):</span>
<span class="gi">+                    raise</span>


<span class="w"> </span>class SSLIOStream(IOStream):
<span class="gu">@@ -603,27 +1327,161 @@ class SSLIOStream(IOStream):</span>
<span class="w"> </span>    before constructing the `SSLIOStream`.  Unconnected sockets will be
<span class="w"> </span>    wrapped when `IOStream.connect` is finished.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    socket = None</span>

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    socket = None  # type: ssl.SSLSocket</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The ``ssl_options`` keyword argument may either be an
<span class="w"> </span>        `ssl.SSLContext` object or a dictionary of keywords arguments
<span class="w"> </span>        for `ssl.SSLContext.wrap_socket`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self._ssl_options = kwargs.pop(&#39;ssl_options&#39;, _client_ssl_defaults)</span>
<span class="gi">+        self._ssl_options = kwargs.pop(&quot;ssl_options&quot;, _client_ssl_defaults)</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self._ssl_accepting = True
<span class="w"> </span>        self._handshake_reading = False
<span class="w"> </span>        self._handshake_writing = False
<span class="gd">-        self._server_hostname = None</span>
<span class="gi">+        self._server_hostname = None  # type: Optional[str]</span>
<span class="gi">+</span>
<span class="gi">+        # If the socket is already connected, attempt to start the handshake.</span>
<span class="w"> </span>        try:
<span class="w"> </span>            self.socket.getpeername()
<span class="w"> </span>        except socket.error:
<span class="w"> </span>            pass
<span class="w"> </span>        else:
<span class="gi">+            # Indirectly start the handshake, which will run on the next</span>
<span class="gi">+            # IOLoop iteration and then the real IO state will be set in</span>
<span class="gi">+            # _handle_events.</span>
<span class="w"> </span>            self._add_io_state(self.io_loop.WRITE)

<span class="gd">-    def wait_for_handshake(self) -&gt;&#39;Future[SSLIOStream]&#39;:</span>
<span class="gi">+    def reading(self) -&gt; bool:</span>
<span class="gi">+        return self._handshake_reading or super().reading()</span>
<span class="gi">+</span>
<span class="gi">+    def writing(self) -&gt; bool:</span>
<span class="gi">+        return self._handshake_writing or super().writing()</span>
<span class="gi">+</span>
<span class="gi">+    def _do_ssl_handshake(self) -&gt; None:</span>
<span class="gi">+        # Based on code from test_ssl.py in the python stdlib</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._handshake_reading = False</span>
<span class="gi">+            self._handshake_writing = False</span>
<span class="gi">+            self.socket.do_handshake()</span>
<span class="gi">+        except ssl.SSLError as err:</span>
<span class="gi">+            if err.args[0] == ssl.SSL_ERROR_WANT_READ:</span>
<span class="gi">+                self._handshake_reading = True</span>
<span class="gi">+                return</span>
<span class="gi">+            elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:</span>
<span class="gi">+                self._handshake_writing = True</span>
<span class="gi">+                return</span>
<span class="gi">+            elif err.args[0] in (ssl.SSL_ERROR_EOF, ssl.SSL_ERROR_ZERO_RETURN):</span>
<span class="gi">+                return self.close(exc_info=err)</span>
<span class="gi">+            elif err.args[0] in (ssl.SSL_ERROR_SSL, ssl.SSL_ERROR_SYSCALL):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    peer = self.socket.getpeername()</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    peer = &quot;(not connected)&quot;</span>
<span class="gi">+                gen_log.warning(</span>
<span class="gi">+                    &quot;SSL Error on %s %s: %s&quot;, self.socket.fileno(), peer, err</span>
<span class="gi">+                )</span>
<span class="gi">+                return self.close(exc_info=err)</span>
<span class="gi">+            raise</span>
<span class="gi">+        except ssl.CertificateError as err:</span>
<span class="gi">+            # CertificateError can happen during handshake (hostname</span>
<span class="gi">+            # verification) and should be passed to user. Starting</span>
<span class="gi">+            # in Python 3.7, this error is a subclass of SSLError</span>
<span class="gi">+            # and will be handled by the previous block instead.</span>
<span class="gi">+            return self.close(exc_info=err)</span>
<span class="gi">+        except socket.error as err:</span>
<span class="gi">+            # Some port scans (e.g. nmap in -sT mode) have been known</span>
<span class="gi">+            # to cause do_handshake to raise EBADF and ENOTCONN, so make</span>
<span class="gi">+            # those errors quiet as well.</span>
<span class="gi">+            # https://groups.google.com/forum/?fromgroups#!topic/python-tornado/ApucKJat1_0</span>
<span class="gi">+            # Errno 0 is also possible in some cases (nc -z).</span>
<span class="gi">+            # https://github.com/tornadoweb/tornado/issues/2504</span>
<span class="gi">+            if self._is_connreset(err) or err.args[0] in (</span>
<span class="gi">+                0,</span>
<span class="gi">+                errno.EBADF,</span>
<span class="gi">+                errno.ENOTCONN,</span>
<span class="gi">+            ):</span>
<span class="gi">+                return self.close(exc_info=err)</span>
<span class="gi">+            raise</span>
<span class="gi">+        except AttributeError as err:</span>
<span class="gi">+            # On Linux, if the connection was reset before the call to</span>
<span class="gi">+            # wrap_socket, do_handshake will fail with an</span>
<span class="gi">+            # AttributeError.</span>
<span class="gi">+            return self.close(exc_info=err)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._ssl_accepting = False</span>
<span class="gi">+            # Prior to the introduction of SNI, this is where we would check</span>
<span class="gi">+            # the server&#39;s claimed hostname.</span>
<span class="gi">+            assert ssl.HAS_SNI</span>
<span class="gi">+            self._finish_ssl_connect()</span>
<span class="gi">+</span>
<span class="gi">+    def _finish_ssl_connect(self) -&gt; None:</span>
<span class="gi">+        if self._ssl_connect_future is not None:</span>
<span class="gi">+            future = self._ssl_connect_future</span>
<span class="gi">+            self._ssl_connect_future = None</span>
<span class="gi">+            future_set_result_unless_cancelled(future, self)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_read(self) -&gt; None:</span>
<span class="gi">+        if self._ssl_accepting:</span>
<span class="gi">+            self._do_ssl_handshake()</span>
<span class="gi">+            return</span>
<span class="gi">+        super()._handle_read()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_write(self) -&gt; None:</span>
<span class="gi">+        if self._ssl_accepting:</span>
<span class="gi">+            self._do_ssl_handshake()</span>
<span class="gi">+            return</span>
<span class="gi">+        super()._handle_write()</span>
<span class="gi">+</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self, address: Tuple, server_hostname: Optional[str] = None</span>
<span class="gi">+    ) -&gt; &quot;Future[SSLIOStream]&quot;:</span>
<span class="gi">+        self._server_hostname = server_hostname</span>
<span class="gi">+        # Ignore the result of connect(). If it fails,</span>
<span class="gi">+        # wait_for_handshake will raise an error too. This is</span>
<span class="gi">+        # necessary for the old semantics of the connect callback</span>
<span class="gi">+        # (which takes no arguments). In 6.0 this can be refactored to</span>
<span class="gi">+        # be a regular coroutine.</span>
<span class="gi">+        # TODO: This is trickier than it looks, since if write()</span>
<span class="gi">+        # is called with a connect() pending, we want the connect</span>
<span class="gi">+        # to resolve before the write. Or do we care about this?</span>
<span class="gi">+        # (There&#39;s a test for it, but I think in practice users</span>
<span class="gi">+        # either wait for the connect before performing a write or</span>
<span class="gi">+        # they don&#39;t care about the connect Future at all)</span>
<span class="gi">+        fut = super().connect(address)</span>
<span class="gi">+        fut.add_done_callback(lambda f: f.exception())</span>
<span class="gi">+        return self.wait_for_handshake()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_connect(self) -&gt; None:</span>
<span class="gi">+        # Call the superclass method to check for errors.</span>
<span class="gi">+        super()._handle_connect()</span>
<span class="gi">+        if self.closed():</span>
<span class="gi">+            return</span>
<span class="gi">+        # When the connection is complete, wrap the socket for SSL</span>
<span class="gi">+        # traffic.  Note that we do this by overriding _handle_connect</span>
<span class="gi">+        # instead of by passing a callback to super().connect because</span>
<span class="gi">+        # user callbacks are enqueued asynchronously on the IOLoop,</span>
<span class="gi">+        # but since _handle_events calls _handle_connect immediately</span>
<span class="gi">+        # followed by _handle_write we need this to be synchronous.</span>
<span class="gi">+        #</span>
<span class="gi">+        # The IOLoop will get confused if we swap out self.socket while the</span>
<span class="gi">+        # fd is registered, so remove it now and re-register after</span>
<span class="gi">+        # wrap_socket().</span>
<span class="gi">+        self.io_loop.remove_handler(self.socket)</span>
<span class="gi">+        old_state = self._state</span>
<span class="gi">+        assert old_state is not None</span>
<span class="gi">+        self._state = None</span>
<span class="gi">+        self.socket = ssl_wrap_socket(</span>
<span class="gi">+            self.socket,</span>
<span class="gi">+            self._ssl_options,</span>
<span class="gi">+            server_hostname=self._server_hostname,</span>
<span class="gi">+            do_handshake_on_connect=False,</span>
<span class="gi">+            server_side=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._add_io_state(old_state)</span>
<span class="gi">+</span>
<span class="gi">+    def wait_for_handshake(self) -&gt; &quot;Future[SSLIOStream]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Wait for the initial SSL handshake to complete.

<span class="w"> </span>        If a ``callback`` is given, it will be called with no
<span class="gu">@@ -648,7 +1506,66 @@ class SSLIOStream(IOStream):</span>
<span class="w"> </span>           `.Future` instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._ssl_connect_future is not None:</span>
<span class="gi">+            raise RuntimeError(&quot;Already waiting&quot;)</span>
<span class="gi">+        future = self._ssl_connect_future = Future()</span>
<span class="gi">+        if not self._ssl_accepting:</span>
<span class="gi">+            self._finish_ssl_connect()</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_fd(self, data: memoryview) -&gt; int:</span>
<span class="gi">+        # clip buffer size at 1GB since SSL sockets only support upto 2GB</span>
<span class="gi">+        # this change in behaviour is transparent, since the function is</span>
<span class="gi">+        # already expected to (possibly) write less than the provided buffer</span>
<span class="gi">+        if len(data) &gt;&gt; 30:</span>
<span class="gi">+            data = memoryview(data)[: 1 &lt;&lt; 30]</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.socket.send(data)  # type: ignore</span>
<span class="gi">+        except ssl.SSLError as e:</span>
<span class="gi">+            if e.args[0] == ssl.SSL_ERROR_WANT_WRITE:</span>
<span class="gi">+                # In Python 3.5+, SSLSocket.send raises a WANT_WRITE error if</span>
<span class="gi">+                # the socket is not writeable; we need to transform this into</span>
<span class="gi">+                # an EWOULDBLOCK socket.error or a zero return value,</span>
<span class="gi">+                # either of which will be recognized by the caller of this</span>
<span class="gi">+                # method. Prior to Python 3.5, an unwriteable socket would</span>
<span class="gi">+                # simply return 0 bytes written.</span>
<span class="gi">+                return 0</span>
<span class="gi">+            raise</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Avoid keeping to data, which can be a memoryview.</span>
<span class="gi">+            # See https://github.com/tornadoweb/tornado/pull/2008</span>
<span class="gi">+            del data</span>
<span class="gi">+</span>
<span class="gi">+    def read_from_fd(self, buf: Union[bytearray, memoryview]) -&gt; Optional[int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self._ssl_accepting:</span>
<span class="gi">+                # If the handshake hasn&#39;t finished yet, there can&#39;t be anything</span>
<span class="gi">+                # to read (attempting to read may or may not raise an exception</span>
<span class="gi">+                # depending on the SSL version)</span>
<span class="gi">+                return None</span>
<span class="gi">+            # clip buffer size at 1GB since SSL sockets only support upto 2GB</span>
<span class="gi">+            # this change in behaviour is transparent, since the function is</span>
<span class="gi">+            # already expected to (possibly) read less than the provided buffer</span>
<span class="gi">+            if len(buf) &gt;&gt; 30:</span>
<span class="gi">+                buf = memoryview(buf)[: 1 &lt;&lt; 30]</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.socket.recv_into(buf, len(buf))</span>
<span class="gi">+            except ssl.SSLError as e:</span>
<span class="gi">+                # SSLError is a subclass of socket.error, so this except</span>
<span class="gi">+                # block must come first.</span>
<span class="gi">+                if e.args[0] == ssl.SSL_ERROR_WANT_READ:</span>
<span class="gi">+                    return None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+            except BlockingIOError:</span>
<span class="gi">+                return None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            del buf</span>
<span class="gi">+</span>
<span class="gi">+    def _is_connreset(self, e: BaseException) -&gt; bool:</span>
<span class="gi">+        if isinstance(e, ssl.SSLError) and e.args[0] == ssl.SSL_ERROR_EOF:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return super()._is_connreset(e)</span>


<span class="w"> </span>class PipeIOStream(BaseIOStream):
<span class="gu">@@ -662,10 +1579,49 @@ class PipeIOStream(BaseIOStream):</span>
<span class="w"> </span>    ``PipeIOStream`` is only available on Unix-based platforms.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, fd: int, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, fd: int, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.fd = fd
<span class="gd">-        self._fio = io.FileIO(self.fd, &#39;r+&#39;)</span>
<span class="gd">-        if sys.platform == &#39;win32&#39;:</span>
<span class="gd">-            raise AssertionError(&#39;PipeIOStream is not supported on Windows&#39;)</span>
<span class="gi">+        self._fio = io.FileIO(self.fd, &quot;r+&quot;)</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # The form and placement of this assertion is important to mypy.</span>
<span class="gi">+            # A plain assert statement isn&#39;t recognized here. If the assertion</span>
<span class="gi">+            # were earlier it would worry that the attributes of self aren&#39;t</span>
<span class="gi">+            # set on windows. If it were missing it would complain about</span>
<span class="gi">+            # the absence of the set_blocking function.</span>
<span class="gi">+            raise AssertionError(&quot;PipeIOStream is not supported on Windows&quot;)</span>
<span class="w"> </span>        os.set_blocking(fd, False)
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return self.fd</span>
<span class="gi">+</span>
<span class="gi">+    def close_fd(self) -&gt; None:</span>
<span class="gi">+        self._fio.close()</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_fd(self, data: memoryview) -&gt; int:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return os.write(self.fd, data)  # type: ignore</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Avoid keeping to data, which can be a memoryview.</span>
<span class="gi">+            # See https://github.com/tornadoweb/tornado/pull/2008</span>
<span class="gi">+            del data</span>
<span class="gi">+</span>
<span class="gi">+    def read_from_fd(self, buf: Union[bytearray, memoryview]) -&gt; Optional[int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._fio.readinto(buf)  # type: ignore</span>
<span class="gi">+        except (IOError, OSError) as e:</span>
<span class="gi">+            if errno_from_exception(e) == errno.EBADF:</span>
<span class="gi">+                # If the writing half of a pipe is closed, select will</span>
<span class="gi">+                # report it as readable but reads will fail with EBADF.</span>
<span class="gi">+                self.close(exc_info=e)</span>
<span class="gi">+                return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        finally:</span>
<span class="gi">+            del buf</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def doctests() -&gt; Any:</span>
<span class="gi">+    import doctest</span>
<span class="gi">+</span>
<span class="gi">+    return doctest.DocTestSuite()</span>
<span class="gh">diff --git a/tornado/locale.py b/tornado/locale.py</span>
<span class="gh">index 201f720a..c5526703 100644</span>
<span class="gd">--- a/tornado/locale.py</span>
<span class="gi">+++ b/tornado/locale.py</span>
<span class="gu">@@ -1,3 +1,17 @@</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Translation methods for generating localized strings.

<span class="w"> </span>To load a locale and generate a translated string::
<span class="gu">@@ -22,6 +36,7 @@ CSV format) or `load_gettext_translations` (which uses the ``.mo`` format</span>
<span class="w"> </span>supported by `gettext` and related tools).  If neither method is called,
<span class="w"> </span>the `Locale.translate` method will simply return the original string.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import csv
<span class="w"> </span>import datetime
<span class="gu">@@ -29,18 +44,22 @@ import gettext</span>
<span class="w"> </span>import glob
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from tornado import escape
<span class="w"> </span>from tornado.log import gen_log
<span class="gi">+</span>
<span class="w"> </span>from tornado._locale_data import LOCALE_NAMES
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterable, Any, Union, Dict, Optional
<span class="gd">-_default_locale = &#39;en_US&#39;</span>
<span class="gd">-_translations = {}</span>
<span class="gi">+</span>
<span class="gi">+_default_locale = &quot;en_US&quot;</span>
<span class="gi">+_translations = {}  # type: Dict[str, Any]</span>
<span class="w"> </span>_supported_locales = frozenset([_default_locale])
<span class="w"> </span>_use_gettext = False
<span class="gd">-CONTEXT_SEPARATOR = &#39;\x04&#39;</span>
<span class="gi">+CONTEXT_SEPARATOR = &quot;\x04&quot;</span>


<span class="gd">-def get(*locale_codes: str) -&gt;&#39;Locale&#39;:</span>
<span class="gi">+def get(*locale_codes: str) -&gt; &quot;Locale&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the closest match for the given locale codes.

<span class="w"> </span>    We iterate over all given locale codes in order. If we have a tight
<span class="gu">@@ -51,10 +70,10 @@ def get(*locale_codes: str) -&gt;&#39;Locale&#39;:</span>
<span class="w"> </span>    the specified locales. You can change the default locale with
<span class="w"> </span>    `set_default_locale()`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Locale.get_closest(*locale_codes)</span>


<span class="gd">-def set_default_locale(code: str) -&gt;None:</span>
<span class="gi">+def set_default_locale(code: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sets the default locale.

<span class="w"> </span>    The default locale is assumed to be the language used for all strings
<span class="gu">@@ -62,10 +81,13 @@ def set_default_locale(code: str) -&gt;None:</span>
<span class="w"> </span>    the default locale to the destination locale. Consequently, you don&#39;t
<span class="w"> </span>    need to create a translation file for the default locale.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _default_locale</span>
<span class="gi">+    global _supported_locales</span>
<span class="gi">+    _default_locale = code</span>
<span class="gi">+    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])</span>


<span class="gd">-def load_translations(directory: str, encoding: Optional[str]=None) -&gt;None:</span>
<span class="gi">+def load_translations(directory: str, encoding: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Loads translations from CSV files in a directory.

<span class="w"> </span>    Translations are strings with optional Python-style named placeholders
<span class="gu">@@ -100,10 +122,59 @@ def load_translations(directory: str, encoding: Optional[str]=None) -&gt;None:</span>
<span class="w"> </span>       Added ``encoding`` parameter. Added support for BOM-based encoding
<span class="w"> </span>       detection, UTF-16, and UTF-8-with-BOM.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def load_gettext_translations(directory: str, domain: str) -&gt;None:</span>
<span class="gi">+    global _translations</span>
<span class="gi">+    global _supported_locales</span>
<span class="gi">+    _translations = {}</span>
<span class="gi">+    for path in os.listdir(directory):</span>
<span class="gi">+        if not path.endswith(&quot;.csv&quot;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        locale, extension = path.split(&quot;.&quot;)</span>
<span class="gi">+        if not re.match(&quot;[a-z]+(_[A-Z]+)?$&quot;, locale):</span>
<span class="gi">+            gen_log.error(</span>
<span class="gi">+                &quot;Unrecognized locale %r (path: %s)&quot;,</span>
<span class="gi">+                locale,</span>
<span class="gi">+                os.path.join(directory, path),</span>
<span class="gi">+            )</span>
<span class="gi">+            continue</span>
<span class="gi">+        full_path = os.path.join(directory, path)</span>
<span class="gi">+        if encoding is None:</span>
<span class="gi">+            # Try to autodetect encoding based on the BOM.</span>
<span class="gi">+            with open(full_path, &quot;rb&quot;) as bf:</span>
<span class="gi">+                data = bf.read(len(codecs.BOM_UTF16_LE))</span>
<span class="gi">+            if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):</span>
<span class="gi">+                encoding = &quot;utf-16&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                # utf-8-sig is &quot;utf-8 with optional BOM&quot;. It&#39;s discouraged</span>
<span class="gi">+                # in most cases but is common with CSV files because Excel</span>
<span class="gi">+                # cannot read utf-8 files without a BOM.</span>
<span class="gi">+                encoding = &quot;utf-8-sig&quot;</span>
<span class="gi">+        # python 3: csv.reader requires a file open in text mode.</span>
<span class="gi">+        # Specify an encoding to avoid dependence on $LANG environment variable.</span>
<span class="gi">+        with open(full_path, encoding=encoding) as f:</span>
<span class="gi">+            _translations[locale] = {}</span>
<span class="gi">+            for i, row in enumerate(csv.reader(f)):</span>
<span class="gi">+                if not row or len(row) &lt; 2:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                row = [escape.to_unicode(c).strip() for c in row]</span>
<span class="gi">+                english, translation = row[:2]</span>
<span class="gi">+                if len(row) &gt; 2:</span>
<span class="gi">+                    plural = row[2] or &quot;unknown&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    plural = &quot;unknown&quot;</span>
<span class="gi">+                if plural not in (&quot;plural&quot;, &quot;singular&quot;, &quot;unknown&quot;):</span>
<span class="gi">+                    gen_log.error(</span>
<span class="gi">+                        &quot;Unrecognized plural indicator %r in %s line %d&quot;,</span>
<span class="gi">+                        plural,</span>
<span class="gi">+                        path,</span>
<span class="gi">+                        i + 1,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    continue</span>
<span class="gi">+                _translations[locale].setdefault(plural, {})[english] = translation</span>
<span class="gi">+    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])</span>
<span class="gi">+    gen_log.debug(&quot;Supported locales: %s&quot;, sorted(_supported_locales))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_gettext_translations(directory: str, domain: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Loads translations from `gettext`&#39;s locale tree

<span class="w"> </span>    Locale tree is similar to system&#39;s ``/usr/share/locale``, like::
<span class="gu">@@ -124,12 +195,30 @@ def load_gettext_translations(directory: str, domain: str) -&gt;None:</span>

<span class="w"> </span>        msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_supported_locales() -&gt;Iterable[str]:</span>
<span class="gi">+    global _translations</span>
<span class="gi">+    global _supported_locales</span>
<span class="gi">+    global _use_gettext</span>
<span class="gi">+    _translations = {}</span>
<span class="gi">+</span>
<span class="gi">+    for filename in glob.glob(</span>
<span class="gi">+        os.path.join(directory, &quot;*&quot;, &quot;LC_MESSAGES&quot;, domain + &quot;.mo&quot;)</span>
<span class="gi">+    ):</span>
<span class="gi">+        lang = os.path.basename(os.path.dirname(os.path.dirname(filename)))</span>
<span class="gi">+        try:</span>
<span class="gi">+            _translations[lang] = gettext.translation(</span>
<span class="gi">+                domain, directory, languages=[lang]</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            gen_log.error(&quot;Cannot load translation for &#39;%s&#39;: %s&quot;, lang, str(e))</span>
<span class="gi">+            continue</span>
<span class="gi">+    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])</span>
<span class="gi">+    _use_gettext = True</span>
<span class="gi">+    gen_log.debug(&quot;Supported locales: %s&quot;, sorted(_supported_locales))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_supported_locales() -&gt; Iterable[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a list of all the supported locale codes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _supported_locales</span>


<span class="w"> </span>class Locale(object):
<span class="gu">@@ -138,38 +227,86 @@ class Locale(object):</span>
<span class="w"> </span>    After calling one of `load_translations` or `load_gettext_translations`,
<span class="w"> </span>    call `get` or `get_closest` to get a Locale object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _cache = {}</span>
<span class="gi">+</span>
<span class="gi">+    _cache = {}  # type: Dict[str, Locale]</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_closest(cls, *locale_codes: str) -&gt;&#39;Locale&#39;:</span>
<span class="gi">+    def get_closest(cls, *locale_codes: str) -&gt; &quot;Locale&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the closest match for the given locale code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for code in locale_codes:</span>
<span class="gi">+            if not code:</span>
<span class="gi">+                continue</span>
<span class="gi">+            code = code.replace(&quot;-&quot;, &quot;_&quot;)</span>
<span class="gi">+            parts = code.split(&quot;_&quot;)</span>
<span class="gi">+            if len(parts) &gt; 2:</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif len(parts) == 2:</span>
<span class="gi">+                code = parts[0].lower() + &quot;_&quot; + parts[1].upper()</span>
<span class="gi">+            if code in _supported_locales:</span>
<span class="gi">+                return cls.get(code)</span>
<span class="gi">+            if parts[0].lower() in _supported_locales:</span>
<span class="gi">+                return cls.get(parts[0].lower())</span>
<span class="gi">+        return cls.get(_default_locale)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get(cls, code: str) -&gt;&#39;Locale&#39;:</span>
<span class="gi">+    def get(cls, code: str) -&gt; &quot;Locale&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the Locale for the given locale code.

<span class="w"> </span>        If it is not supported, we raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, code: str) -&gt;None:</span>
<span class="gi">+        if code not in cls._cache:</span>
<span class="gi">+            assert code in _supported_locales</span>
<span class="gi">+            translations = _translations.get(code, None)</span>
<span class="gi">+            if translations is None:</span>
<span class="gi">+                locale = CSVLocale(code, {})  # type: Locale</span>
<span class="gi">+            elif _use_gettext:</span>
<span class="gi">+                locale = GettextLocale(code, translations)</span>
<span class="gi">+            else:</span>
<span class="gi">+                locale = CSVLocale(code, translations)</span>
<span class="gi">+            cls._cache[code] = locale</span>
<span class="gi">+        return cls._cache[code]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, code: str) -&gt; None:</span>
<span class="w"> </span>        self.code = code
<span class="gd">-        self.name = LOCALE_NAMES.get(code, {}).get(&#39;name&#39;, &#39;Unknown&#39;)</span>
<span class="gi">+        self.name = LOCALE_NAMES.get(code, {}).get(&quot;name&quot;, &quot;Unknown&quot;)</span>
<span class="w"> </span>        self.rtl = False
<span class="gd">-        for prefix in [&#39;fa&#39;, &#39;ar&#39;, &#39;he&#39;]:</span>
<span class="gi">+        for prefix in [&quot;fa&quot;, &quot;ar&quot;, &quot;he&quot;]:</span>
<span class="w"> </span>            if self.code.startswith(prefix):
<span class="w"> </span>                self.rtl = True
<span class="w"> </span>                break
<span class="gi">+</span>
<span class="gi">+        # Initialize strings for date formatting</span>
<span class="w"> </span>        _ = self.translate
<span class="gd">-        self._months = [_(&#39;January&#39;), _(&#39;February&#39;), _(&#39;March&#39;), _(&#39;April&#39;),</span>
<span class="gd">-            _(&#39;May&#39;), _(&#39;June&#39;), _(&#39;July&#39;), _(&#39;August&#39;), _(&#39;September&#39;), _(</span>
<span class="gd">-            &#39;October&#39;), _(&#39;November&#39;), _(&#39;December&#39;)]</span>
<span class="gd">-        self._weekdays = [_(&#39;Monday&#39;), _(&#39;Tuesday&#39;), _(&#39;Wednesday&#39;), _(</span>
<span class="gd">-            &#39;Thursday&#39;), _(&#39;Friday&#39;), _(&#39;Saturday&#39;), _(&#39;Sunday&#39;)]</span>
<span class="gd">-</span>
<span class="gd">-    def translate(self, message: str, plural_message: Optional[str]=None,</span>
<span class="gd">-        count: Optional[int]=None) -&gt;str:</span>
<span class="gi">+        self._months = [</span>
<span class="gi">+            _(&quot;January&quot;),</span>
<span class="gi">+            _(&quot;February&quot;),</span>
<span class="gi">+            _(&quot;March&quot;),</span>
<span class="gi">+            _(&quot;April&quot;),</span>
<span class="gi">+            _(&quot;May&quot;),</span>
<span class="gi">+            _(&quot;June&quot;),</span>
<span class="gi">+            _(&quot;July&quot;),</span>
<span class="gi">+            _(&quot;August&quot;),</span>
<span class="gi">+            _(&quot;September&quot;),</span>
<span class="gi">+            _(&quot;October&quot;),</span>
<span class="gi">+            _(&quot;November&quot;),</span>
<span class="gi">+            _(&quot;December&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+        self._weekdays = [</span>
<span class="gi">+            _(&quot;Monday&quot;),</span>
<span class="gi">+            _(&quot;Tuesday&quot;),</span>
<span class="gi">+            _(&quot;Wednesday&quot;),</span>
<span class="gi">+            _(&quot;Thursday&quot;),</span>
<span class="gi">+            _(&quot;Friday&quot;),</span>
<span class="gi">+            _(&quot;Saturday&quot;),</span>
<span class="gi">+            _(&quot;Sunday&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def translate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        plural_message: Optional[str] = None,</span>
<span class="gi">+        count: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the translation for the given message for this locale.

<span class="w"> </span>        If ``plural_message`` is given, you must also provide
<span class="gu">@@ -177,11 +314,25 @@ class Locale(object):</span>
<span class="w"> </span>        and we return the singular form for the given message when
<span class="w"> </span>        ``count == 1``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def format_date(self, date: Union[int, float, datetime.datetime],</span>
<span class="gd">-        gmt_offset: int=0, relative: bool=True, shorter: bool=False,</span>
<span class="gd">-        full_format: bool=False) -&gt;str:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def pgettext(</span>
<span class="gi">+        self,</span>
<span class="gi">+        context: str,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        plural_message: Optional[str] = None,</span>
<span class="gi">+        count: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def format_date(</span>
<span class="gi">+        self,</span>
<span class="gi">+        date: Union[int, float, datetime.datetime],</span>
<span class="gi">+        gmt_offset: int = 0,</span>
<span class="gi">+        relative: bool = True,</span>
<span class="gi">+        shorter: bool = False,</span>
<span class="gi">+        full_format: bool = False,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Formats the given date.

<span class="w"> </span>        By default, we return a relative time (e.g., &quot;2 minutes ago&quot;). You
<span class="gu">@@ -197,50 +348,205 @@ class Locale(object):</span>
<span class="w"> </span>           Aware `datetime.datetime` objects are now supported (naive
<span class="w"> </span>           datetimes are still assumed to be UTC).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(date, (int, float)):</span>
<span class="gi">+            date = datetime.datetime.fromtimestamp(date, datetime.timezone.utc)</span>
<span class="gi">+        if date.tzinfo is None:</span>
<span class="gi">+            date = date.replace(tzinfo=datetime.timezone.utc)</span>
<span class="gi">+        now = datetime.datetime.now(datetime.timezone.utc)</span>
<span class="gi">+        if date &gt; now:</span>
<span class="gi">+            if relative and (date - now).seconds &lt; 60:</span>
<span class="gi">+                # Due to click skew, things are some things slightly</span>
<span class="gi">+                # in the future. Round timestamps in the immediate</span>
<span class="gi">+                # future down to now in relative mode.</span>
<span class="gi">+                date = now</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Otherwise, future dates always use the full format.</span>
<span class="gi">+                full_format = True</span>
<span class="gi">+        local_date = date - datetime.timedelta(minutes=gmt_offset)</span>
<span class="gi">+        local_now = now - datetime.timedelta(minutes=gmt_offset)</span>
<span class="gi">+        local_yesterday = local_now - datetime.timedelta(hours=24)</span>
<span class="gi">+        difference = now - date</span>
<span class="gi">+        seconds = difference.seconds</span>
<span class="gi">+        days = difference.days</span>

<span class="gd">-    def format_day(self, date: datetime.datetime, gmt_offset: int=0, dow:</span>
<span class="gd">-        bool=True) -&gt;bool:</span>
<span class="gi">+        _ = self.translate</span>
<span class="gi">+        format = None</span>
<span class="gi">+        if not full_format:</span>
<span class="gi">+            if relative and days == 0:</span>
<span class="gi">+                if seconds &lt; 50:</span>
<span class="gi">+                    return _(&quot;1 second ago&quot;, &quot;%(seconds)d seconds ago&quot;, seconds) % {</span>
<span class="gi">+                        &quot;seconds&quot;: seconds</span>
<span class="gi">+                    }</span>
<span class="gi">+</span>
<span class="gi">+                if seconds &lt; 50 * 60:</span>
<span class="gi">+                    minutes = round(seconds / 60.0)</span>
<span class="gi">+                    return _(&quot;1 minute ago&quot;, &quot;%(minutes)d minutes ago&quot;, minutes) % {</span>
<span class="gi">+                        &quot;minutes&quot;: minutes</span>
<span class="gi">+                    }</span>
<span class="gi">+</span>
<span class="gi">+                hours = round(seconds / (60.0 * 60))</span>
<span class="gi">+                return _(&quot;1 hour ago&quot;, &quot;%(hours)d hours ago&quot;, hours) % {&quot;hours&quot;: hours}</span>
<span class="gi">+</span>
<span class="gi">+            if days == 0:</span>
<span class="gi">+                format = _(&quot;%(time)s&quot;)</span>
<span class="gi">+            elif days == 1 and local_date.day == local_yesterday.day and relative:</span>
<span class="gi">+                format = _(&quot;yesterday&quot;) if shorter else _(&quot;yesterday at %(time)s&quot;)</span>
<span class="gi">+            elif days &lt; 5:</span>
<span class="gi">+                format = _(&quot;%(weekday)s&quot;) if shorter else _(&quot;%(weekday)s at %(time)s&quot;)</span>
<span class="gi">+            elif days &lt; 334:  # 11mo, since confusing for same month last year</span>
<span class="gi">+                format = (</span>
<span class="gi">+                    _(&quot;%(month_name)s %(day)s&quot;)</span>
<span class="gi">+                    if shorter</span>
<span class="gi">+                    else _(&quot;%(month_name)s %(day)s at %(time)s&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if format is None:</span>
<span class="gi">+            format = (</span>
<span class="gi">+                _(&quot;%(month_name)s %(day)s, %(year)s&quot;)</span>
<span class="gi">+                if shorter</span>
<span class="gi">+                else _(&quot;%(month_name)s %(day)s, %(year)s at %(time)s&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        tfhour_clock = self.code not in (&quot;en&quot;, &quot;en_US&quot;, &quot;zh_CN&quot;)</span>
<span class="gi">+        if tfhour_clock:</span>
<span class="gi">+            str_time = &quot;%d:%02d&quot; % (local_date.hour, local_date.minute)</span>
<span class="gi">+        elif self.code == &quot;zh_CN&quot;:</span>
<span class="gi">+            str_time = &quot;%s%d:%02d&quot; % (</span>
<span class="gi">+                (&quot;\u4e0a\u5348&quot;, &quot;\u4e0b\u5348&quot;)[local_date.hour &gt;= 12],</span>
<span class="gi">+                local_date.hour % 12 or 12,</span>
<span class="gi">+                local_date.minute,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            str_time = &quot;%d:%02d %s&quot; % (</span>
<span class="gi">+                local_date.hour % 12 or 12,</span>
<span class="gi">+                local_date.minute,</span>
<span class="gi">+                (&quot;am&quot;, &quot;pm&quot;)[local_date.hour &gt;= 12],</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return format % {</span>
<span class="gi">+            &quot;month_name&quot;: self._months[local_date.month - 1],</span>
<span class="gi">+            &quot;weekday&quot;: self._weekdays[local_date.weekday()],</span>
<span class="gi">+            &quot;day&quot;: str(local_date.day),</span>
<span class="gi">+            &quot;year&quot;: str(local_date.year),</span>
<span class="gi">+            &quot;time&quot;: str_time,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def format_day(</span>
<span class="gi">+        self, date: datetime.datetime, gmt_offset: int = 0, dow: bool = True</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Formats the given date as a day of week.

<span class="w"> </span>        Example: &quot;Monday, January 22&quot;. You can remove the day of week with
<span class="w"> </span>        ``dow=False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def list(self, parts: Any) -&gt;str:</span>
<span class="gi">+        local_date = date - datetime.timedelta(minutes=gmt_offset)</span>
<span class="gi">+        _ = self.translate</span>
<span class="gi">+        if dow:</span>
<span class="gi">+            return _(&quot;%(weekday)s, %(month_name)s %(day)s&quot;) % {</span>
<span class="gi">+                &quot;month_name&quot;: self._months[local_date.month - 1],</span>
<span class="gi">+                &quot;weekday&quot;: self._weekdays[local_date.weekday()],</span>
<span class="gi">+                &quot;day&quot;: str(local_date.day),</span>
<span class="gi">+            }</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _(&quot;%(month_name)s %(day)s&quot;) % {</span>
<span class="gi">+                &quot;month_name&quot;: self._months[local_date.month - 1],</span>
<span class="gi">+                &quot;day&quot;: str(local_date.day),</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+    def list(self, parts: Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a comma-separated list for the given list of parts.

<span class="w"> </span>        The format is, e.g., &quot;A, B and C&quot;, &quot;A and B&quot; or just &quot;A&quot; for lists
<span class="w"> </span>        of size 1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def friendly_number(self, value: int) -&gt;str:</span>
<span class="gi">+        _ = self.translate</span>
<span class="gi">+        if len(parts) == 0:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        if len(parts) == 1:</span>
<span class="gi">+            return parts[0]</span>
<span class="gi">+        comma = &quot; \u0648 &quot; if self.code.startswith(&quot;fa&quot;) else &quot;, &quot;</span>
<span class="gi">+        return _(&quot;%(commas)s and %(last)s&quot;) % {</span>
<span class="gi">+            &quot;commas&quot;: comma.join(parts[:-1]),</span>
<span class="gi">+            &quot;last&quot;: parts[len(parts) - 1],</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def friendly_number(self, value: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a comma-separated number for the given integer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.code not in (&quot;en&quot;, &quot;en_US&quot;):</span>
<span class="gi">+            return str(value)</span>
<span class="gi">+        s = str(value)</span>
<span class="gi">+        parts = []</span>
<span class="gi">+        while s:</span>
<span class="gi">+            parts.append(s[-3:])</span>
<span class="gi">+            s = s[:-3]</span>
<span class="gi">+        return &quot;,&quot;.join(reversed(parts))</span>


<span class="w"> </span>class CSVLocale(Locale):
<span class="w"> </span>    &quot;&quot;&quot;Locale implementation using tornado&#39;s CSV translation format.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, code: str, translations: Dict[str, Dict[str, str]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, code: str, translations: Dict[str, Dict[str, str]]) -&gt; None:</span>
<span class="w"> </span>        self.translations = translations
<span class="w"> </span>        super().__init__(code)

<span class="gi">+    def translate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        plural_message: Optional[str] = None,</span>
<span class="gi">+        count: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        if plural_message is not None:</span>
<span class="gi">+            assert count is not None</span>
<span class="gi">+            if count != 1:</span>
<span class="gi">+                message = plural_message</span>
<span class="gi">+                message_dict = self.translations.get(&quot;plural&quot;, {})</span>
<span class="gi">+            else:</span>
<span class="gi">+                message_dict = self.translations.get(&quot;singular&quot;, {})</span>
<span class="gi">+        else:</span>
<span class="gi">+            message_dict = self.translations.get(&quot;unknown&quot;, {})</span>
<span class="gi">+        return message_dict.get(message, message)</span>
<span class="gi">+</span>
<span class="gi">+    def pgettext(</span>
<span class="gi">+        self,</span>
<span class="gi">+        context: str,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        plural_message: Optional[str] = None,</span>
<span class="gi">+        count: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        if self.translations:</span>
<span class="gi">+            gen_log.warning(&quot;pgettext is not supported by CSVLocale&quot;)</span>
<span class="gi">+        return self.translate(message, plural_message, count)</span>
<span class="gi">+</span>

<span class="w"> </span>class GettextLocale(Locale):
<span class="w"> </span>    &quot;&quot;&quot;Locale implementation using the `gettext` module.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, code: str, translations: gettext.NullTranslations</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, code: str, translations: gettext.NullTranslations) -&gt; None:</span>
<span class="w"> </span>        self.ngettext = translations.ngettext
<span class="w"> </span>        self.gettext = translations.gettext
<span class="gi">+        # self.gettext must exist before __init__ is called, since it</span>
<span class="gi">+        # calls into self.translate</span>
<span class="w"> </span>        super().__init__(code)

<span class="gd">-    def pgettext(self, context: str, message: str, plural_message: Optional</span>
<span class="gd">-        [str]=None, count: Optional[int]=None) -&gt;str:</span>
<span class="gi">+    def translate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        plural_message: Optional[str] = None,</span>
<span class="gi">+        count: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        if plural_message is not None:</span>
<span class="gi">+            assert count is not None</span>
<span class="gi">+            return self.ngettext(message, plural_message, count)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.gettext(message)</span>
<span class="gi">+</span>
<span class="gi">+    def pgettext(</span>
<span class="gi">+        self,</span>
<span class="gi">+        context: str,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        plural_message: Optional[str] = None,</span>
<span class="gi">+        count: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Allows to set context for translation, accepts plural forms.

<span class="w"> </span>        Usage example::
<span class="gu">@@ -260,4 +566,22 @@ class GettextLocale(Locale):</span>

<span class="w"> </span>        .. versionadded:: 4.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if plural_message is not None:</span>
<span class="gi">+            assert count is not None</span>
<span class="gi">+            msgs_with_ctxt = (</span>
<span class="gi">+                &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, message),</span>
<span class="gi">+                &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, plural_message),</span>
<span class="gi">+                count,</span>
<span class="gi">+            )</span>
<span class="gi">+            result = self.ngettext(*msgs_with_ctxt)</span>
<span class="gi">+            if CONTEXT_SEPARATOR in result:</span>
<span class="gi">+                # Translation not found</span>
<span class="gi">+                result = self.ngettext(message, plural_message, count)</span>
<span class="gi">+            return result</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg_with_ctxt = &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, message)</span>
<span class="gi">+            result = self.gettext(msg_with_ctxt)</span>
<span class="gi">+            if CONTEXT_SEPARATOR in result:</span>
<span class="gi">+                # Translation not found</span>
<span class="gi">+                result = message</span>
<span class="gi">+            return result</span>
<span class="gh">diff --git a/tornado/locks.py b/tornado/locks.py</span>
<span class="gh">index bacc3ebe..1bcec1b3 100644</span>
<span class="gd">--- a/tornado/locks.py</span>
<span class="gi">+++ b/tornado/locks.py</span>
<span class="gu">@@ -1,13 +1,31 @@</span>
<span class="gi">+# Copyright 2015 The Tornado Authors</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import datetime
<span class="w"> </span>import types
<span class="gi">+</span>
<span class="w"> </span>from tornado import gen, ioloop
<span class="w"> </span>from tornado.concurrent import Future, future_set_result_unless_cancelled
<span class="gi">+</span>
<span class="w"> </span>from typing import Union, Optional, Type, Any, Awaitable
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Deque, Set</span>
<span class="gd">-__all__ = [&#39;Condition&#39;, &#39;Event&#39;, &#39;Semaphore&#39;, &#39;BoundedSemaphore&#39;, &#39;Lock&#39;]</span>
<span class="gi">+    from typing import Deque, Set  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;Condition&quot;, &quot;Event&quot;, &quot;Semaphore&quot;, &quot;BoundedSemaphore&quot;, &quot;Lock&quot;]</span>


<span class="w"> </span>class _TimeoutGarbageCollector(object):
<span class="gu">@@ -20,10 +38,17 @@ class _TimeoutGarbageCollector(object):</span>
<span class="w"> </span>            print(&#39;looping....&#39;)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self._waiters = collections.deque()</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self._waiters = collections.deque()  # type: Deque[Future]</span>
<span class="w"> </span>        self._timeouts = 0

<span class="gi">+    def _garbage_collect(self) -&gt; None:</span>
<span class="gi">+        # Occasionally clear timed-out waiters.</span>
<span class="gi">+        self._timeouts += 1</span>
<span class="gi">+        if self._timeouts &gt; 100:</span>
<span class="gi">+            self._timeouts = 0</span>
<span class="gi">+            self._waiters = collections.deque(w for w in self._waiters if not w.done())</span>
<span class="gi">+</span>

<span class="w"> </span>class Condition(_TimeoutGarbageCollector):
<span class="w"> </span>    &quot;&quot;&quot;A condition allows one or more coroutines to wait until notified.
<span class="gu">@@ -85,28 +110,49 @@ class Condition(_TimeoutGarbageCollector):</span>
<span class="w"> </span>       next iteration of the `.IOLoop`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        result = &#39;&lt;%s&#39; % (self.__class__.__name__,)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        result = &quot;&lt;%s&quot; % (self.__class__.__name__,)</span>
<span class="w"> </span>        if self._waiters:
<span class="gd">-            result += &#39; waiters[%s]&#39; % len(self._waiters)</span>
<span class="gd">-        return result + &#39;&gt;&#39;</span>
<span class="gi">+            result += &quot; waiters[%s]&quot; % len(self._waiters)</span>
<span class="gi">+        return result + &quot;&gt;&quot;</span>

<span class="gd">-    def wait(self, timeout: Optional[Union[float, datetime.timedelta]]=None</span>
<span class="gd">-        ) -&gt;Awaitable[bool]:</span>
<span class="gi">+    def wait(</span>
<span class="gi">+        self, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; Awaitable[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Wait for `.notify`.

<span class="w"> </span>        Returns a `.Future` that resolves ``True`` if the condition is notified,
<span class="w"> </span>        or ``False`` after a timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        waiter = Future()  # type: Future[bool]</span>
<span class="gi">+        self._waiters.append(waiter)</span>
<span class="gi">+        if timeout:</span>

<span class="gd">-    def notify(self, n: int=1) -&gt;None:</span>
<span class="gi">+            def on_timeout() -&gt; None:</span>
<span class="gi">+                if not waiter.done():</span>
<span class="gi">+                    future_set_result_unless_cancelled(waiter, False)</span>
<span class="gi">+                self._garbage_collect()</span>
<span class="gi">+</span>
<span class="gi">+            io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+            timeout_handle = io_loop.add_timeout(timeout, on_timeout)</span>
<span class="gi">+            waiter.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))</span>
<span class="gi">+        return waiter</span>
<span class="gi">+</span>
<span class="gi">+    def notify(self, n: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Wake ``n`` waiters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        waiters = []  # Waiters we plan to run right now.</span>
<span class="gi">+        while n and self._waiters:</span>
<span class="gi">+            waiter = self._waiters.popleft()</span>
<span class="gi">+            if not waiter.done():  # Might have timed out.</span>
<span class="gi">+                n -= 1</span>
<span class="gi">+                waiters.append(waiter)</span>
<span class="gi">+</span>
<span class="gi">+        for waiter in waiters:</span>
<span class="gi">+            future_set_result_unless_cancelled(waiter, True)</span>

<span class="gd">-    def notify_all(self) -&gt;None:</span>
<span class="gi">+    def notify_all(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Wake all waiters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.notify(len(self._waiters))</span>


<span class="w"> </span>class Event(object):
<span class="gu">@@ -149,40 +195,64 @@ class Event(object):</span>
<span class="w"> </span>        Done
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._value = False
<span class="gd">-        self._waiters = set()</span>
<span class="gi">+        self._waiters = set()  # type: Set[Future[None]]</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;&lt;%s %s&gt;&#39; % (self.__class__.__name__, &#39;set&#39; if self.is_set()</span>
<span class="gd">-             else &#39;clear&#39;)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;&lt;%s %s&gt;&quot; % (</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            &quot;set&quot; if self.is_set() else &quot;clear&quot;,</span>
<span class="gi">+        )</span>

<span class="gd">-    def is_set(self) -&gt;bool:</span>
<span class="gi">+    def is_set(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if the internal flag is true.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value</span>

<span class="gd">-    def set(self) -&gt;None:</span>
<span class="gi">+    def set(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the internal flag to ``True``. All waiters are awakened.

<span class="w"> </span>        Calling `.wait` once the flag is set will not block.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._value:</span>
<span class="gi">+            self._value = True</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+            for fut in self._waiters:</span>
<span class="gi">+                if not fut.done():</span>
<span class="gi">+                    fut.set_result(None)</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the internal flag to ``False``.

<span class="w"> </span>        Calls to `.wait` will block until `.set` is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._value = False</span>

<span class="gd">-    def wait(self, timeout: Optional[Union[float, datetime.timedelta]]=None</span>
<span class="gd">-        ) -&gt;Awaitable[None]:</span>
<span class="gi">+    def wait(</span>
<span class="gi">+        self, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; Awaitable[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Block until the internal flag is true.

<span class="w"> </span>        Returns an awaitable, which raises `tornado.util.TimeoutError` after a
<span class="w"> </span>        timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fut = Future()  # type: Future[None]</span>
<span class="gi">+        if self._value:</span>
<span class="gi">+            fut.set_result(None)</span>
<span class="gi">+            return fut</span>
<span class="gi">+        self._waiters.add(fut)</span>
<span class="gi">+        fut.add_done_callback(lambda fut: self._waiters.remove(fut))</span>
<span class="gi">+        if timeout is None:</span>
<span class="gi">+            return fut</span>
<span class="gi">+        else:</span>
<span class="gi">+            timeout_fut = gen.with_timeout(timeout, fut)</span>
<span class="gi">+            # This is a slightly clumsy workaround for the fact that</span>
<span class="gi">+            # gen.with_timeout doesn&#39;t cancel its futures. Cancelling</span>
<span class="gi">+            # fut will remove it from the waiters list.</span>
<span class="gi">+            timeout_fut.add_done_callback(</span>
<span class="gi">+                lambda tf: fut.cancel() if not fut.done() else None</span>
<span class="gi">+            )</span>
<span class="gi">+            return timeout_fut</span>


<span class="w"> </span>class _ReleasingContextManager(object):
<span class="gu">@@ -194,14 +264,18 @@ class _ReleasingContextManager(object):</span>
<span class="w"> </span>    # Now semaphore.release() has been called.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, obj: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, obj: Any) -&gt; None:</span>
<span class="w"> </span>        self._obj = obj

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def __exit__(self, exc_type: &#39;Optional[Type[BaseException]]&#39;, exc_val:</span>
<span class="gd">-        Optional[BaseException], exc_tb: Optional[types.TracebackType]) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        exc_val: Optional[BaseException],</span>
<span class="gi">+        exc_tb: Optional[types.TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._obj.release()


<span class="gu">@@ -306,46 +380,87 @@ class Semaphore(_TimeoutGarbageCollector):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, value: int=1) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: int = 1) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        if value &lt; 0:
<span class="gd">-            raise ValueError(&#39;semaphore initial value must be &gt;= 0&#39;)</span>
<span class="gi">+            raise ValueError(&quot;semaphore initial value must be &gt;= 0&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._value = value

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        res = super().__repr__()
<span class="gd">-        extra = &#39;locked&#39; if self._value == 0 else &#39;unlocked,value:{0}&#39;.format(</span>
<span class="gd">-            self._value)</span>
<span class="gi">+        extra = (</span>
<span class="gi">+            &quot;locked&quot; if self._value == 0 else &quot;unlocked,value:{0}&quot;.format(self._value)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if self._waiters:
<span class="gd">-            extra = &#39;{0},waiters:{1}&#39;.format(extra, len(self._waiters))</span>
<span class="gd">-        return &#39;&lt;{0} [{1}]&gt;&#39;.format(res[1:-1], extra)</span>
<span class="gi">+            extra = &quot;{0},waiters:{1}&quot;.format(extra, len(self._waiters))</span>
<span class="gi">+        return &quot;&lt;{0} [{1}]&gt;&quot;.format(res[1:-1], extra)</span>

<span class="gd">-    def release(self) -&gt;None:</span>
<span class="gi">+    def release(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increment the counter and wake one waiter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def acquire(self, timeout: Optional[Union[float, datetime.timedelta]]=None</span>
<span class="gd">-        ) -&gt;Awaitable[_ReleasingContextManager]:</span>
<span class="gi">+        self._value += 1</span>
<span class="gi">+        while self._waiters:</span>
<span class="gi">+            waiter = self._waiters.popleft()</span>
<span class="gi">+            if not waiter.done():</span>
<span class="gi">+                self._value -= 1</span>
<span class="gi">+</span>
<span class="gi">+                # If the waiter is a coroutine paused at</span>
<span class="gi">+                #</span>
<span class="gi">+                #     with (yield semaphore.acquire()):</span>
<span class="gi">+                #</span>
<span class="gi">+                # then the context manager&#39;s __exit__ calls release() at the end</span>
<span class="gi">+                # of the &quot;with&quot; block.</span>
<span class="gi">+                waiter.set_result(_ReleasingContextManager(self))</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def acquire(</span>
<span class="gi">+        self, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; Awaitable[_ReleasingContextManager]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decrement the counter. Returns an awaitable.

<span class="w"> </span>        Block if the counter is zero and wait for a `.release`. The awaitable
<span class="w"> </span>        raises `.TimeoutError` after the deadline.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+        waiter = Future()  # type: Future[_ReleasingContextManager]</span>
<span class="gi">+        if self._value &gt; 0:</span>
<span class="gi">+            self._value -= 1</span>
<span class="gi">+            waiter.set_result(_ReleasingContextManager(self))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._waiters.append(waiter)</span>
<span class="gi">+            if timeout:</span>
<span class="gi">+</span>
<span class="gi">+                def on_timeout() -&gt; None:</span>
<span class="gi">+                    if not waiter.done():</span>
<span class="gi">+                        waiter.set_exception(gen.TimeoutError())</span>
<span class="gi">+                    self._garbage_collect()</span>
<span class="gi">+</span>
<span class="gi">+                io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+                timeout_handle = io_loop.add_timeout(timeout, on_timeout)</span>
<span class="gi">+                waiter.add_done_callback(</span>
<span class="gi">+                    lambda _: io_loop.remove_timeout(timeout_handle)</span>
<span class="gi">+                )</span>
<span class="gi">+        return waiter</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        raise RuntimeError(&quot;Use &#39;async with&#39; instead of &#39;with&#39; for Semaphore&quot;)

<span class="gd">-    def __exit__(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], traceback: Optional[types.TracebackType]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        traceback: Optional[types.TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.__enter__()

<span class="gd">-    async def __aenter__(self) -&gt;None:</span>
<span class="gi">+    async def __aenter__(self) -&gt; None:</span>
<span class="w"> </span>        await self.acquire()

<span class="gd">-    async def __aexit__(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], tb: Optional[types.TracebackType]) -&gt;None:</span>
<span class="gi">+    async def __aexit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[types.TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.release()


<span class="gu">@@ -358,13 +473,15 @@ class BoundedSemaphore(Semaphore):</span>
<span class="w"> </span>    is a sign of a bug.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, value: int=1) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: int = 1) -&gt; None:</span>
<span class="w"> </span>        super().__init__(value=value)
<span class="w"> </span>        self._initial_value = value

<span class="gd">-    def release(self) -&gt;None:</span>
<span class="gi">+    def release(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increment the counter and wake one waiter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value &gt;= self._initial_value:</span>
<span class="gi">+            raise ValueError(&quot;Semaphore released too many times&quot;)</span>
<span class="gi">+        super().release()</span>


<span class="w"> </span>class Lock(object):
<span class="gu">@@ -404,40 +521,52 @@ class Lock(object):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._block = BoundedSemaphore(value=1)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;&lt;%s _block=%s&gt;&#39; % (self.__class__.__name__, self._block)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;&lt;%s _block=%s&gt;&quot; % (self.__class__.__name__, self._block)</span>

<span class="gd">-    def acquire(self, timeout: Optional[Union[float, datetime.timedelta]]=None</span>
<span class="gd">-        ) -&gt;Awaitable[_ReleasingContextManager]:</span>
<span class="gi">+    def acquire(</span>
<span class="gi">+        self, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; Awaitable[_ReleasingContextManager]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempt to lock. Returns an awaitable.

<span class="w"> </span>        Returns an awaitable, which raises `tornado.util.TimeoutError` after a
<span class="w"> </span>        timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._block.acquire(timeout)</span>

<span class="gd">-    def release(self) -&gt;None:</span>
<span class="gi">+    def release(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unlock.

<span class="w"> </span>        The first coroutine in line waiting for `acquire` gets the lock.

<span class="w"> </span>        If not locked, raise a `RuntimeError`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gd">-        raise RuntimeError(&#39;Use `async with` instead of `with` for Lock&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def __exit__(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], tb: Optional[types.TracebackType]) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._block.release()</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise RuntimeError(&quot;release unlocked lock&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="gi">+        raise RuntimeError(&quot;Use `async with` instead of `with` for Lock&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[types.TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.__enter__()

<span class="gd">-    async def __aenter__(self) -&gt;None:</span>
<span class="gi">+    async def __aenter__(self) -&gt; None:</span>
<span class="w"> </span>        await self.acquire()

<span class="gd">-    async def __aexit__(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], tb: Optional[types.TracebackType]) -&gt;None:</span>
<span class="gi">+    async def __aexit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[types.TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.release()
<span class="gh">diff --git a/tornado/log.py b/tornado/log.py</span>
<span class="gh">index 6e3e6e4d..86998961 100644</span>
<span class="gd">--- a/tornado/log.py</span>
<span class="gi">+++ b/tornado/log.py</span>
<span class="gu">@@ -1,3 +1,17 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2012 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="w"> </span>&quot;&quot;&quot;Logging support for Tornado.

<span class="w"> </span>Tornado uses three logger streams:
<span class="gu">@@ -16,20 +30,52 @@ to a separate file for analysis.</span>
<span class="w"> </span>import logging
<span class="w"> </span>import logging.handlers
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from tornado.escape import _unicode
<span class="w"> </span>from tornado.util import unicode_type, basestring_type
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import colorama</span>
<span class="gi">+    import colorama  # type: ignore</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    colorama = None
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import curses
<span class="w"> </span>except ImportError:
<span class="gd">-    curses = None</span>
<span class="gi">+    curses = None  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict, Any, cast, Optional
<span class="gd">-access_log = logging.getLogger(&#39;tornado.access&#39;)</span>
<span class="gd">-app_log = logging.getLogger(&#39;tornado.application&#39;)</span>
<span class="gd">-gen_log = logging.getLogger(&#39;tornado.general&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# Logger objects for internal tornado use</span>
<span class="gi">+access_log = logging.getLogger(&quot;tornado.access&quot;)</span>
<span class="gi">+app_log = logging.getLogger(&quot;tornado.application&quot;)</span>
<span class="gi">+gen_log = logging.getLogger(&quot;tornado.general&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _stderr_supports_color() -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if hasattr(sys.stderr, &quot;isatty&quot;) and sys.stderr.isatty():</span>
<span class="gi">+            if curses:</span>
<span class="gi">+                curses.setupterm()</span>
<span class="gi">+                if curses.tigetnum(&quot;colors&quot;) &gt; 0:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif colorama:</span>
<span class="gi">+                if sys.stderr is getattr(</span>
<span class="gi">+                    colorama.initialise, &quot;wrapped_stderr&quot;, object()</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return True</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        # Very broad exception handling because it&#39;s always better to</span>
<span class="gi">+        # fall back to non-colored logs than to break at startup.</span>
<span class="gi">+        pass</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _safe_unicode(s: Any) -&gt; str:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _unicode(s)</span>
<span class="gi">+    except UnicodeDecodeError:</span>
<span class="gi">+        return repr(s)</span>


<span class="w"> </span>class LogFormatter(logging.Formatter):
<span class="gu">@@ -56,17 +102,26 @@ class LogFormatter(logging.Formatter):</span>
<span class="w"> </span>       Added support for ``colorama``. Changed the constructor
<span class="w"> </span>       signature to be compatible with `logging.config.dictConfig`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    DEFAULT_FORMAT = (</span>
<span class="gd">-        &#39;%(color)s[%(levelname)1.1s %(asctime)s %(module)s:%(lineno)d]%(end_color)s %(message)s&#39;</span>
<span class="gd">-        )</span>
<span class="gd">-    DEFAULT_DATE_FORMAT = &#39;%y%m%d %H:%M:%S&#39;</span>
<span class="gd">-    DEFAULT_COLORS = {logging.DEBUG: 4, logging.INFO: 2, logging.WARNING: 3,</span>
<span class="gd">-        logging.ERROR: 1, logging.CRITICAL: 5}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, fmt: str=DEFAULT_FORMAT, datefmt: str=</span>
<span class="gd">-        DEFAULT_DATE_FORMAT, style: str=&#39;%&#39;, color: bool=True, colors: Dict</span>
<span class="gd">-        [int, int]=DEFAULT_COLORS) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    DEFAULT_FORMAT = &quot;%(color)s[%(levelname)1.1s %(asctime)s %(module)s:%(lineno)d]%(end_color)s %(message)s&quot;  # noqa: E501</span>
<span class="gi">+    DEFAULT_DATE_FORMAT = &quot;%y%m%d %H:%M:%S&quot;</span>
<span class="gi">+    DEFAULT_COLORS = {</span>
<span class="gi">+        logging.DEBUG: 4,  # Blue</span>
<span class="gi">+        logging.INFO: 2,  # Green</span>
<span class="gi">+        logging.WARNING: 3,  # Yellow</span>
<span class="gi">+        logging.ERROR: 1,  # Red</span>
<span class="gi">+        logging.CRITICAL: 5,  # Magenta</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fmt: str = DEFAULT_FORMAT,</span>
<span class="gi">+        datefmt: str = DEFAULT_DATE_FORMAT,</span>
<span class="gi">+        style: str = &quot;%&quot;,</span>
<span class="gi">+        color: bool = True,</span>
<span class="gi">+        colors: Dict[int, int] = DEFAULT_COLORS,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        r&quot;&quot;&quot;</span>
<span class="w"> </span>        :arg bool color: Enables color support.
<span class="w"> </span>        :arg str fmt: Log message format.
<span class="w"> </span>          It will be applied to the attributes dict of log records. The
<span class="gu">@@ -83,38 +138,131 @@ class LogFormatter(logging.Formatter):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        logging.Formatter.__init__(self, datefmt=datefmt)
<span class="w"> </span>        self._fmt = fmt
<span class="gd">-        self._colors = {}</span>
<span class="gi">+</span>
<span class="gi">+        self._colors = {}  # type: Dict[int, str]</span>
<span class="w"> </span>        if color and _stderr_supports_color():
<span class="w"> </span>            if curses is not None:
<span class="gd">-                fg_color = curses.tigetstr(&#39;setaf&#39;) or curses.tigetstr(&#39;setf&#39;</span>
<span class="gd">-                    ) or b&#39;&#39;</span>
<span class="gi">+                fg_color = curses.tigetstr(&quot;setaf&quot;) or curses.tigetstr(&quot;setf&quot;) or b&quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>                for levelno, code in colors.items():
<span class="gd">-                    self._colors[levelno] = unicode_type(curses.tparm(</span>
<span class="gd">-                        fg_color, code), &#39;ascii&#39;)</span>
<span class="gd">-                normal = curses.tigetstr(&#39;sgr0&#39;)</span>
<span class="gi">+                    # Convert the terminal control characters from</span>
<span class="gi">+                    # bytes to unicode strings for easier use with the</span>
<span class="gi">+                    # logging module.</span>
<span class="gi">+                    self._colors[levelno] = unicode_type(</span>
<span class="gi">+                        curses.tparm(fg_color, code), &quot;ascii&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                normal = curses.tigetstr(&quot;sgr0&quot;)</span>
<span class="w"> </span>                if normal is not None:
<span class="gd">-                    self._normal = unicode_type(normal, &#39;ascii&#39;)</span>
<span class="gi">+                    self._normal = unicode_type(normal, &quot;ascii&quot;)</span>
<span class="w"> </span>                else:
<span class="gd">-                    self._normal = &#39;&#39;</span>
<span class="gi">+                    self._normal = &quot;&quot;</span>
<span class="w"> </span>            else:
<span class="gi">+                # If curses is not present (currently we&#39;ll only get here for</span>
<span class="gi">+                # colorama on windows), assume hard-coded ANSI color codes.</span>
<span class="w"> </span>                for levelno, code in colors.items():
<span class="gd">-                    self._colors[levelno] = &#39;\x1b[2;3%dm&#39; % code</span>
<span class="gd">-                self._normal = &#39;\x1b[0m&#39;</span>
<span class="gi">+                    self._colors[levelno] = &quot;\033[2;3%dm&quot; % code</span>
<span class="gi">+                self._normal = &quot;\033[0m&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            self._normal = &#39;&#39;</span>
<span class="gi">+            self._normal = &quot;&quot;</span>

<span class="gi">+    def format(self, record: Any) -&gt; str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            message = record.getMessage()</span>
<span class="gi">+            assert isinstance(message, basestring_type)  # guaranteed by logging</span>
<span class="gi">+            # Encoding notes:  The logging module prefers to work with character</span>
<span class="gi">+            # strings, but only enforces that log messages are instances of</span>
<span class="gi">+            # basestring.  In python 2, non-ascii bytestrings will make</span>
<span class="gi">+            # their way through the logging framework until they blow up with</span>
<span class="gi">+            # an unhelpful decoding error (with this formatter it happens</span>
<span class="gi">+            # when we attach the prefix, but there are other opportunities for</span>
<span class="gi">+            # exceptions further along in the framework).</span>
<span class="gi">+            #</span>
<span class="gi">+            # If a byte string makes it this far, convert it to unicode to</span>
<span class="gi">+            # ensure it will make it out to the logs.  Use repr() as a fallback</span>
<span class="gi">+            # to ensure that all byte strings can be converted successfully,</span>
<span class="gi">+            # but don&#39;t do it by default so we don&#39;t add extra quotes to ascii</span>
<span class="gi">+            # bytestrings.  This is a bit of a hacky place to do this, but</span>
<span class="gi">+            # it&#39;s worth it since the encoding errors that would otherwise</span>
<span class="gi">+            # result are so useless (and tornado is fond of using utf8-encoded</span>
<span class="gi">+            # byte strings wherever possible).</span>
<span class="gi">+            record.message = _safe_unicode(message)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            record.message = &quot;Bad message (%r): %r&quot; % (e, record.__dict__)</span>

<span class="gd">-def enable_pretty_logging(options: Any=None, logger: Optional[logging.</span>
<span class="gd">-    Logger]=None) -&gt;None:</span>
<span class="gi">+        record.asctime = self.formatTime(record, cast(str, self.datefmt))</span>
<span class="gi">+</span>
<span class="gi">+        if record.levelno in self._colors:</span>
<span class="gi">+            record.color = self._colors[record.levelno]</span>
<span class="gi">+            record.end_color = self._normal</span>
<span class="gi">+        else:</span>
<span class="gi">+            record.color = record.end_color = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        formatted = self._fmt % record.__dict__</span>
<span class="gi">+</span>
<span class="gi">+        if record.exc_info:</span>
<span class="gi">+            if not record.exc_text:</span>
<span class="gi">+                record.exc_text = self.formatException(record.exc_info)</span>
<span class="gi">+        if record.exc_text:</span>
<span class="gi">+            # exc_text contains multiple lines.  We need to _safe_unicode</span>
<span class="gi">+            # each line separately so that non-utf8 bytes don&#39;t cause</span>
<span class="gi">+            # all the newlines to turn into &#39;\n&#39;.</span>
<span class="gi">+            lines = [formatted.rstrip()]</span>
<span class="gi">+            lines.extend(_safe_unicode(ln) for ln in record.exc_text.split(&quot;\n&quot;))</span>
<span class="gi">+            formatted = &quot;\n&quot;.join(lines)</span>
<span class="gi">+        return formatted.replace(&quot;\n&quot;, &quot;\n    &quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def enable_pretty_logging(</span>
<span class="gi">+    options: Any = None, logger: Optional[logging.Logger] = None</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Turns on formatted logging output as configured.

<span class="w"> </span>    This is called automatically by `tornado.options.parse_command_line`
<span class="w"> </span>    and `tornado.options.parse_config_file`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if options is None:</span>
<span class="gi">+        import tornado.options</span>

<span class="gi">+        options = tornado.options.options</span>
<span class="gi">+    if options.logging is None or options.logging.lower() == &quot;none&quot;:</span>
<span class="gi">+        return</span>
<span class="gi">+    if logger is None:</span>
<span class="gi">+        logger = logging.getLogger()</span>
<span class="gi">+    logger.setLevel(getattr(logging, options.logging.upper()))</span>
<span class="gi">+    if options.log_file_prefix:</span>
<span class="gi">+        rotate_mode = options.log_rotate_mode</span>
<span class="gi">+        if rotate_mode == &quot;size&quot;:</span>
<span class="gi">+            channel = logging.handlers.RotatingFileHandler(</span>
<span class="gi">+                filename=options.log_file_prefix,</span>
<span class="gi">+                maxBytes=options.log_file_max_size,</span>
<span class="gi">+                backupCount=options.log_file_num_backups,</span>
<span class="gi">+                encoding=&quot;utf-8&quot;,</span>
<span class="gi">+            )  # type: logging.Handler</span>
<span class="gi">+        elif rotate_mode == &quot;time&quot;:</span>
<span class="gi">+            channel = logging.handlers.TimedRotatingFileHandler(</span>
<span class="gi">+                filename=options.log_file_prefix,</span>
<span class="gi">+                when=options.log_rotate_when,</span>
<span class="gi">+                interval=options.log_rotate_interval,</span>
<span class="gi">+                backupCount=options.log_file_num_backups,</span>
<span class="gi">+                encoding=&quot;utf-8&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            error_message = (</span>
<span class="gi">+                &quot;The value of log_rotate_mode option should be &quot;</span>
<span class="gi">+                + &#39;&quot;size&quot; or &quot;time&quot;, not &quot;%s&quot;.&#39; % rotate_mode</span>
<span class="gi">+            )</span>
<span class="gi">+            raise ValueError(error_message)</span>
<span class="gi">+        channel.setFormatter(LogFormatter(color=False))</span>
<span class="gi">+        logger.addHandler(channel)</span>

<span class="gd">-def define_logging_options(options: Any=None) -&gt;None:</span>
<span class="gi">+    if options.log_to_stderr or (options.log_to_stderr is None and not logger.handlers):</span>
<span class="gi">+        # Set up color if we are in a tty and curses is installed</span>
<span class="gi">+        channel = logging.StreamHandler()</span>
<span class="gi">+        channel.setFormatter(LogFormatter())</span>
<span class="gi">+        logger.addHandler(channel)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def define_logging_options(options: Any = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add logging-related flags to ``options``.

<span class="w"> </span>    These options are present automatically on the default options instance;
<span class="gu">@@ -123,4 +271,73 @@ def define_logging_options(options: Any=None) -&gt;None:</span>
<span class="w"> </span>    .. versionadded:: 4.2
<span class="w"> </span>        This function existed in prior versions but was broken and undocumented until 4.2.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if options is None:</span>
<span class="gi">+        # late import to prevent cycle</span>
<span class="gi">+        import tornado.options</span>
<span class="gi">+</span>
<span class="gi">+        options = tornado.options.options</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;logging&quot;,</span>
<span class="gi">+        default=&quot;info&quot;,</span>
<span class="gi">+        help=(</span>
<span class="gi">+            &quot;Set the Python log level. If &#39;none&#39;, tornado won&#39;t touch the &quot;</span>
<span class="gi">+            &quot;logging configuration.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        metavar=&quot;debug|info|warning|error|none&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_to_stderr&quot;,</span>
<span class="gi">+        type=bool,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        help=(</span>
<span class="gi">+            &quot;Send log output to stderr (colorized if possible). &quot;</span>
<span class="gi">+            &quot;By default use stderr if --log_file_prefix is not set and &quot;</span>
<span class="gi">+            &quot;no other logging is configured.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_file_prefix&quot;,</span>
<span class="gi">+        type=str,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        metavar=&quot;PATH&quot;,</span>
<span class="gi">+        help=(</span>
<span class="gi">+            &quot;Path prefix for log files. &quot;</span>
<span class="gi">+            &quot;Note that if you are running multiple tornado processes, &quot;</span>
<span class="gi">+            &quot;log_file_prefix must be different for each of them (e.g. &quot;</span>
<span class="gi">+            &quot;include the port number)&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_file_max_size&quot;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=100 * 1000 * 1000,</span>
<span class="gi">+        help=&quot;max size of log files before rollover&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_file_num_backups&quot;, type=int, default=10, help=&quot;number of log files to keep&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_rotate_when&quot;,</span>
<span class="gi">+        type=str,</span>
<span class="gi">+        default=&quot;midnight&quot;,</span>
<span class="gi">+        help=(</span>
<span class="gi">+            &quot;specify the type of TimedRotatingFileHandler interval &quot;</span>
<span class="gi">+            &quot;other options:(&#39;S&#39;, &#39;M&#39;, &#39;H&#39;, &#39;D&#39;, &#39;W0&#39;-&#39;W6&#39;)&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_rotate_interval&quot;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=1,</span>
<span class="gi">+        help=&quot;The interval value of timed rotating&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    options.define(</span>
<span class="gi">+        &quot;log_rotate_mode&quot;,</span>
<span class="gi">+        type=str,</span>
<span class="gi">+        default=&quot;size&quot;,</span>
<span class="gi">+        help=&quot;The mode of rotating files(time or size)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    options.add_parse_callback(lambda: enable_pretty_logging(options))</span>
<span class="gh">diff --git a/tornado/netutil.py b/tornado/netutil.py</span>
<span class="gh">index 5afa2659..18c91e67 100644</span>
<span class="gd">--- a/tornado/netutil.py</span>
<span class="gi">+++ b/tornado/netutil.py</span>
<span class="gu">@@ -1,4 +1,20 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2011 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Miscellaneous network utility code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import concurrent.futures
<span class="w"> </span>import errno
<span class="gu">@@ -7,23 +23,44 @@ import sys</span>
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="w"> </span>import stat
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import dummy_executor, run_on_executor
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.util import Configurable, errno_from_exception
<span class="gi">+</span>
<span class="w"> </span>from typing import List, Callable, Any, Type, Dict, Union, Tuple, Awaitable, Optional
<span class="gi">+</span>
<span class="gi">+# Note that the naming of ssl.Purpose is confusing; the purpose</span>
<span class="gi">+# of a context is to authenticate the opposite side of the connection.</span>
<span class="w"> </span>_client_ssl_defaults = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
<span class="w"> </span>_server_ssl_defaults = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
<span class="gd">-if hasattr(ssl, &#39;OP_NO_COMPRESSION&#39;):</span>
<span class="gi">+if hasattr(ssl, &quot;OP_NO_COMPRESSION&quot;):</span>
<span class="gi">+    # See netutil.ssl_options_to_context</span>
<span class="w"> </span>    _client_ssl_defaults.options |= ssl.OP_NO_COMPRESSION
<span class="w"> </span>    _server_ssl_defaults.options |= ssl.OP_NO_COMPRESSION
<span class="gd">-&quot;&quot;&quot;foo&quot;&quot;&quot;.encode(&#39;idna&#39;)</span>
<span class="gd">-&quot;&quot;&quot;foo&quot;&quot;&quot;.encode(&#39;latin1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# ThreadedResolver runs getaddrinfo on a thread. If the hostname is unicode,</span>
<span class="gi">+# getaddrinfo attempts to import encodings.idna. If this is done at</span>
<span class="gi">+# module-import time, the import lock is already held by the main thread,</span>
<span class="gi">+# leading to deadlock. Avoid it by caching the idna encoder on the main</span>
<span class="gi">+# thread now.</span>
<span class="gi">+&quot;foo&quot;.encode(&quot;idna&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# For undiagnosed reasons, &#39;latin1&#39; codec may also need to be preloaded.</span>
<span class="gi">+&quot;foo&quot;.encode(&quot;latin1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# Default backlog used when calling sock.listen()</span>
<span class="w"> </span>_DEFAULT_BACKLOG = 128


<span class="gd">-def bind_sockets(port: int, address: Optional[str]=None, family: socket.</span>
<span class="gd">-    AddressFamily=socket.AF_UNSPEC, backlog: int=_DEFAULT_BACKLOG, flags:</span>
<span class="gd">-    Optional[int]=None, reuse_port: bool=False) -&gt;List[socket.socket]:</span>
<span class="gi">+def bind_sockets(</span>
<span class="gi">+    port: int,</span>
<span class="gi">+    address: Optional[str] = None,</span>
<span class="gi">+    family: socket.AddressFamily = socket.AF_UNSPEC,</span>
<span class="gi">+    backlog: int = _DEFAULT_BACKLOG,</span>
<span class="gi">+    flags: Optional[int] = None,</span>
<span class="gi">+    reuse_port: bool = False,</span>
<span class="gi">+) -&gt; List[socket.socket]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates listening sockets bound to the given port and address.

<span class="w"> </span>    Returns a list of socket objects (multiple sockets are returned if
<span class="gu">@@ -47,13 +84,114 @@ def bind_sockets(port: int, address: Optional[str]=None, family: socket.</span>
<span class="w"> </span>    in the list. If your platform doesn&#39;t support this option ValueError will
<span class="w"> </span>    be raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if hasattr(socket, &#39;AF_UNIX&#39;):</span>
<span class="gd">-</span>
<span class="gd">-    def bind_unix_socket(file: str, mode: int=384, backlog: int=</span>
<span class="gd">-        _DEFAULT_BACKLOG) -&gt;socket.socket:</span>
<span class="gi">+    if reuse_port and not hasattr(socket, &quot;SO_REUSEPORT&quot;):</span>
<span class="gi">+        raise ValueError(&quot;the platform doesn&#39;t support SO_REUSEPORT&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    sockets = []</span>
<span class="gi">+    if address == &quot;&quot;:</span>
<span class="gi">+        address = None</span>
<span class="gi">+    if not socket.has_ipv6 and family == socket.AF_UNSPEC:</span>
<span class="gi">+        # Python can be compiled with --disable-ipv6, which causes</span>
<span class="gi">+        # operations on AF_INET6 sockets to fail, but does not</span>
<span class="gi">+        # automatically exclude those results from getaddrinfo</span>
<span class="gi">+        # results.</span>
<span class="gi">+        # http://bugs.python.org/issue16208</span>
<span class="gi">+        family = socket.AF_INET</span>
<span class="gi">+    if flags is None:</span>
<span class="gi">+        flags = socket.AI_PASSIVE</span>
<span class="gi">+    bound_port = None</span>
<span class="gi">+    unique_addresses = set()  # type: set</span>
<span class="gi">+    for res in sorted(</span>
<span class="gi">+        socket.getaddrinfo(address, port, family, socket.SOCK_STREAM, 0, flags),</span>
<span class="gi">+        key=lambda x: x[0],</span>
<span class="gi">+    ):</span>
<span class="gi">+        if res in unique_addresses:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        unique_addresses.add(res)</span>
<span class="gi">+</span>
<span class="gi">+        af, socktype, proto, canonname, sockaddr = res</span>
<span class="gi">+        if (</span>
<span class="gi">+            sys.platform == &quot;darwin&quot;</span>
<span class="gi">+            and address == &quot;localhost&quot;</span>
<span class="gi">+            and af == socket.AF_INET6</span>
<span class="gi">+            and sockaddr[3] != 0  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Mac OS X includes a link-local address fe80::1%lo0 in the</span>
<span class="gi">+            # getaddrinfo results for &#39;localhost&#39;.  However, the firewall</span>
<span class="gi">+            # doesn&#39;t understand that this is a local address and will</span>
<span class="gi">+            # prompt for access (often repeatedly, due to an apparent</span>
<span class="gi">+            # bug in its ability to remember granting access to an</span>
<span class="gi">+            # application). Skip these addresses.</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            sock = socket.socket(af, socktype, proto)</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            if errno_from_exception(e) == errno.EAFNOSUPPORT:</span>
<span class="gi">+                continue</span>
<span class="gi">+            raise</span>
<span class="gi">+        if os.name != &quot;nt&quot;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="gi">+            except socket.error as e:</span>
<span class="gi">+                if errno_from_exception(e) != errno.ENOPROTOOPT:</span>
<span class="gi">+                    # Hurd doesn&#39;t support SO_REUSEADDR.</span>
<span class="gi">+                    raise</span>
<span class="gi">+        if reuse_port:</span>
<span class="gi">+            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)</span>
<span class="gi">+        if af == socket.AF_INET6:</span>
<span class="gi">+            # On linux, ipv6 sockets accept ipv4 too by default,</span>
<span class="gi">+            # but this makes it impossible to bind to both</span>
<span class="gi">+            # 0.0.0.0 in ipv4 and :: in ipv6.  On other systems,</span>
<span class="gi">+            # separate sockets *must* be used to listen for both ipv4</span>
<span class="gi">+            # and ipv6.  For consistency, always disable ipv4 on our</span>
<span class="gi">+            # ipv6 sockets and use a separate ipv4 socket when needed.</span>
<span class="gi">+            #</span>
<span class="gi">+            # Python 2.x on windows doesn&#39;t have IPPROTO_IPV6.</span>
<span class="gi">+            if hasattr(socket, &quot;IPPROTO_IPV6&quot;):</span>
<span class="gi">+                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1)</span>
<span class="gi">+</span>
<span class="gi">+        # automatic port allocation with port=None</span>
<span class="gi">+        # should bind on the same port on IPv4 and IPv6</span>
<span class="gi">+        host, requested_port = sockaddr[:2]</span>
<span class="gi">+        if requested_port == 0 and bound_port is not None:</span>
<span class="gi">+            sockaddr = tuple([host, bound_port] + list(sockaddr[2:]))</span>
<span class="gi">+</span>
<span class="gi">+        sock.setblocking(False)</span>
<span class="gi">+        try:</span>
<span class="gi">+            sock.bind(sockaddr)</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if (</span>
<span class="gi">+                errno_from_exception(e) == errno.EADDRNOTAVAIL</span>
<span class="gi">+                and address == &quot;localhost&quot;</span>
<span class="gi">+                and sockaddr[0] == &quot;::1&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                # On some systems (most notably docker with default</span>
<span class="gi">+                # configurations), ipv6 is partially disabled:</span>
<span class="gi">+                # socket.has_ipv6 is true, we can create AF_INET6</span>
<span class="gi">+                # sockets, and getaddrinfo(&quot;localhost&quot;, ...,</span>
<span class="gi">+                # AF_PASSIVE) resolves to ::1, but we get an error</span>
<span class="gi">+                # when binding.</span>
<span class="gi">+                #</span>
<span class="gi">+                # Swallow the error, but only for this specific case.</span>
<span class="gi">+                # If EADDRNOTAVAIL occurs in other situations, it</span>
<span class="gi">+                # might be a real problem like a typo in a</span>
<span class="gi">+                # configuration.</span>
<span class="gi">+                sock.close()</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        bound_port = sock.getsockname()[1]</span>
<span class="gi">+        sock.listen(backlog)</span>
<span class="gi">+        sockets.append(sock)</span>
<span class="gi">+    return sockets</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if hasattr(socket, &quot;AF_UNIX&quot;):</span>
<span class="gi">+</span>
<span class="gi">+    def bind_unix_socket(</span>
<span class="gi">+        file: str, mode: int = 0o600, backlog: int = _DEFAULT_BACKLOG</span>
<span class="gi">+    ) -&gt; socket.socket:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a listening unix socket.

<span class="w"> </span>        If a socket with the given name already exists, it will be deleted.
<span class="gu">@@ -63,11 +201,32 @@ if hasattr(socket, &#39;AF_UNIX&#39;):</span>
<span class="w"> </span>        Returns a socket object (not a list of socket objects like
<span class="w"> </span>        `bind_sockets`)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def add_accept_handler(sock: socket.socket, callback: Callable[[socket.</span>
<span class="gd">-    socket, Any], None]) -&gt;Callable[[], None]:</span>
<span class="gi">+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+        try:</span>
<span class="gi">+            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            if errno_from_exception(e) != errno.ENOPROTOOPT:</span>
<span class="gi">+                # Hurd doesn&#39;t support SO_REUSEADDR</span>
<span class="gi">+                raise</span>
<span class="gi">+        sock.setblocking(False)</span>
<span class="gi">+        try:</span>
<span class="gi">+            st = os.stat(file)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if stat.S_ISSOCK(st.st_mode):</span>
<span class="gi">+                os.remove(file)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;File %s exists and is not a socket&quot;, file)</span>
<span class="gi">+        sock.bind(file)</span>
<span class="gi">+        os.chmod(file, mode)</span>
<span class="gi">+        sock.listen(backlog)</span>
<span class="gi">+        return sock</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_accept_handler(</span>
<span class="gi">+    sock: socket.socket, callback: Callable[[socket.socket, Any], None]</span>
<span class="gi">+) -&gt; Callable[[], None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Adds an `.IOLoop` event handler to accept new connections on ``sock``.

<span class="w"> </span>    When a connection is accepted, ``callback(connection, address)`` will
<span class="gu">@@ -85,15 +244,71 @@ def add_accept_handler(sock: socket.socket, callback: Callable[[socket.</span>
<span class="w"> </span>    .. versionchanged:: 5.0
<span class="w"> </span>       A callable is returned (``None`` was returned before).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_valid_ip(ip: str) -&gt;bool:</span>
<span class="gi">+    io_loop = IOLoop.current()</span>
<span class="gi">+    removed = [False]</span>
<span class="gi">+</span>
<span class="gi">+    def accept_handler(fd: socket.socket, events: int) -&gt; None:</span>
<span class="gi">+        # More connections may come in while we&#39;re handling callbacks;</span>
<span class="gi">+        # to prevent starvation of other tasks we must limit the number</span>
<span class="gi">+        # of connections we accept at a time.  Ideally we would accept</span>
<span class="gi">+        # up to the number of connections that were waiting when we</span>
<span class="gi">+        # entered this method, but this information is not available</span>
<span class="gi">+        # (and rearranging this method to call accept() as many times</span>
<span class="gi">+        # as possible before running any callbacks would have adverse</span>
<span class="gi">+        # effects on load balancing in multiprocess configurations).</span>
<span class="gi">+        # Instead, we use the (default) listen backlog as a rough</span>
<span class="gi">+        # heuristic for the number of connections we can reasonably</span>
<span class="gi">+        # accept at once.</span>
<span class="gi">+        for i in range(_DEFAULT_BACKLOG):</span>
<span class="gi">+            if removed[0]:</span>
<span class="gi">+                # The socket was probably closed</span>
<span class="gi">+                return</span>
<span class="gi">+            try:</span>
<span class="gi">+                connection, address = sock.accept()</span>
<span class="gi">+            except BlockingIOError:</span>
<span class="gi">+                # EWOULDBLOCK indicates we have accepted every</span>
<span class="gi">+                # connection that is available.</span>
<span class="gi">+                return</span>
<span class="gi">+            except ConnectionAbortedError:</span>
<span class="gi">+                # ECONNABORTED indicates that there was a connection</span>
<span class="gi">+                # but it was closed while still in the accept queue.</span>
<span class="gi">+                # (observed on FreeBSD).</span>
<span class="gi">+                continue</span>
<span class="gi">+            callback(connection, address)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_handler() -&gt; None:</span>
<span class="gi">+        io_loop.remove_handler(sock)</span>
<span class="gi">+        removed[0] = True</span>
<span class="gi">+</span>
<span class="gi">+    io_loop.add_handler(sock, accept_handler, IOLoop.READ)</span>
<span class="gi">+    return remove_handler</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_valid_ip(ip: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns ``True`` if the given string is a well-formed IP address.

<span class="w"> </span>    Supports IPv4 and IPv6.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not ip or &quot;\x00&quot; in ip:</span>
<span class="gi">+        # getaddrinfo resolves empty strings to localhost, and truncates</span>
<span class="gi">+        # on zero bytes.</span>
<span class="gi">+        return False</span>
<span class="gi">+    try:</span>
<span class="gi">+        res = socket.getaddrinfo(</span>
<span class="gi">+            ip, 0, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_NUMERICHOST</span>
<span class="gi">+        )</span>
<span class="gi">+        return bool(res)</span>
<span class="gi">+    except socket.gaierror as e:</span>
<span class="gi">+        if e.args[0] == socket.EAI_NONAME:</span>
<span class="gi">+            return False</span>
<span class="gi">+        raise</span>
<span class="gi">+    except UnicodeError:</span>
<span class="gi">+        # `socket.getaddrinfo` will raise a UnicodeError from the</span>
<span class="gi">+        # `idna` decoder if the input is longer than 63 characters,</span>
<span class="gi">+        # even for socket.AI_NUMERICHOST.  See</span>
<span class="gi">+        # https://bugs.python.org/issue32958 for discussion</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class Resolver(Configurable):
<span class="gu">@@ -125,8 +340,17 @@ class Resolver(Configurable):</span>
<span class="w"> </span>       `DefaultLoopResolver`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def resolve(self, host: str, port: int, family: socket.AddressFamily=</span>
<span class="gd">-        socket.AF_UNSPEC) -&gt;Awaitable[List[Tuple[int, Any]]]:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_base(cls) -&gt; Type[&quot;Resolver&quot;]:</span>
<span class="gi">+        return Resolver</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def configurable_default(cls) -&gt; Type[&quot;Resolver&quot;]:</span>
<span class="gi">+        return DefaultLoopResolver</span>
<span class="gi">+</span>
<span class="gi">+    def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC</span>
<span class="gi">+    ) -&gt; Awaitable[List[Tuple[int, Any]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolves an address.

<span class="w"> </span>        The ``host`` argument is a string which may be a hostname or a
<span class="gu">@@ -148,9 +372,9 @@ class Resolver(Configurable):</span>
<span class="w"> </span>           Use the returned awaitable object instead.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the `Resolver`, freeing any resources used.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="gu">@@ -159,6 +383,21 @@ class Resolver(Configurable):</span>
<span class="w"> </span>        pass


<span class="gi">+def _resolve_addr(</span>
<span class="gi">+    host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC</span>
<span class="gi">+) -&gt; List[Tuple[int, Any]]:</span>
<span class="gi">+    # On Solaris, getaddrinfo fails if the given port is not found</span>
<span class="gi">+    # in /etc/services and no socket type is given, so we must pass</span>
<span class="gi">+    # one here.  The socket type used here doesn&#39;t seem to actually</span>
<span class="gi">+    # matter (we discard the one we get back in the results),</span>
<span class="gi">+    # so the addresses we return should still be usable with SOCK_DGRAM.</span>
<span class="gi">+    addrinfo = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM)</span>
<span class="gi">+    results = []</span>
<span class="gi">+    for fam, socktype, proto, canonname, address in addrinfo:</span>
<span class="gi">+        results.append((fam, address))</span>
<span class="gi">+    return results  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class DefaultExecutorResolver(Resolver):
<span class="w"> </span>    &quot;&quot;&quot;Resolver implementation using `.IOLoop.run_in_executor`.

<span class="gu">@@ -169,10 +408,33 @@ class DefaultExecutorResolver(Resolver):</span>
<span class="w"> </span>       Use `DefaultLoopResolver` instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    async def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC</span>
<span class="gi">+    ) -&gt; List[Tuple[int, Any]]:</span>
<span class="gi">+        result = await IOLoop.current().run_in_executor(</span>
<span class="gi">+            None, _resolve_addr, host, port, family</span>
<span class="gi">+        )</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class DefaultLoopResolver(Resolver):
<span class="w"> </span>    &quot;&quot;&quot;Resolver implementation using `asyncio.loop.getaddrinfo`.&quot;&quot;&quot;

<span class="gi">+    async def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC</span>
<span class="gi">+    ) -&gt; List[Tuple[int, Any]]:</span>
<span class="gi">+        # On Solaris, getaddrinfo fails if the given port is not found</span>
<span class="gi">+        # in /etc/services and no socket type is given, so we must pass</span>
<span class="gi">+        # one here.  The socket type used here doesn&#39;t seem to actually</span>
<span class="gi">+        # matter (we discard the one we get back in the results),</span>
<span class="gi">+        # so the addresses we return should still be usable with SOCK_DGRAM.</span>
<span class="gi">+        return [</span>
<span class="gi">+            (fam, address)</span>
<span class="gi">+            for fam, _, _, _, address in await asyncio.get_running_loop().getaddrinfo(</span>
<span class="gi">+                host, port, family=family, type=socket.SOCK_STREAM</span>
<span class="gi">+            )</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>

<span class="w"> </span>class ExecutorResolver(Resolver):
<span class="w"> </span>    &quot;&quot;&quot;Resolver implementation using a `concurrent.futures.Executor`.
<span class="gu">@@ -192,6 +454,29 @@ class ExecutorResolver(Resolver):</span>
<span class="w"> </span>       use that instead of this class.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def initialize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        executor: Optional[concurrent.futures.Executor] = None,</span>
<span class="gi">+        close_executor: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if executor is not None:</span>
<span class="gi">+            self.executor = executor</span>
<span class="gi">+            self.close_executor = close_executor</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.executor = dummy_executor</span>
<span class="gi">+            self.close_executor = False</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        if self.close_executor:</span>
<span class="gi">+            self.executor.shutdown()</span>
<span class="gi">+        self.executor = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    @run_on_executor</span>
<span class="gi">+    def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC</span>
<span class="gi">+    ) -&gt; List[Tuple[int, Any]]:</span>
<span class="gi">+        return _resolve_addr(host, port, family)</span>
<span class="gi">+</span>

<span class="w"> </span>class BlockingResolver(ExecutorResolver):
<span class="w"> </span>    &quot;&quot;&quot;Default `Resolver` implementation, using `socket.getaddrinfo`.
<span class="gu">@@ -204,6 +489,9 @@ class BlockingResolver(ExecutorResolver):</span>
<span class="w"> </span>       of this class.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def initialize(self) -&gt; None:  # type: ignore</span>
<span class="gi">+        super().initialize()</span>
<span class="gi">+</span>

<span class="w"> </span>class ThreadedResolver(ExecutorResolver):
<span class="w"> </span>    &quot;&quot;&quot;Multithreaded non-blocking `Resolver` implementation.
<span class="gu">@@ -225,8 +513,27 @@ class ThreadedResolver(ExecutorResolver):</span>
<span class="w"> </span>       The default `Resolver` now uses `.IOLoop.run_in_executor`; use that instead
<span class="w"> </span>       of this class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _threadpool = None</span>
<span class="gd">-    _threadpool_pid = None</span>
<span class="gi">+</span>
<span class="gi">+    _threadpool = None  # type: ignore</span>
<span class="gi">+    _threadpool_pid = None  # type: int</span>
<span class="gi">+</span>
<span class="gi">+    def initialize(self, num_threads: int = 10) -&gt; None:  # type: ignore</span>
<span class="gi">+        threadpool = ThreadedResolver._create_threadpool(num_threads)</span>
<span class="gi">+        super().initialize(executor=threadpool, close_executor=False)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _create_threadpool(</span>
<span class="gi">+        cls, num_threads: int</span>
<span class="gi">+    ) -&gt; concurrent.futures.ThreadPoolExecutor:</span>
<span class="gi">+        pid = os.getpid()</span>
<span class="gi">+        if cls._threadpool_pid != pid:</span>
<span class="gi">+            # Threads cannot survive after a fork, so if our pid isn&#39;t what it</span>
<span class="gi">+            # was when we created the pool then delete it.</span>
<span class="gi">+            cls._threadpool = None</span>
<span class="gi">+        if cls._threadpool is None:</span>
<span class="gi">+            cls._threadpool = concurrent.futures.ThreadPoolExecutor(num_threads)</span>
<span class="gi">+            cls._threadpool_pid = pid</span>
<span class="gi">+        return cls._threadpool</span>


<span class="w"> </span>class OverrideResolver(Resolver):
<span class="gu">@@ -252,13 +559,37 @@ class OverrideResolver(Resolver):</span>
<span class="w"> </span>       Added support for host-port-family triplets.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="gd">-_SSL_CONTEXT_KEYWORDS = frozenset([&#39;ssl_version&#39;, &#39;certfile&#39;, &#39;keyfile&#39;,</span>
<span class="gd">-    &#39;cert_reqs&#39;, &#39;ca_certs&#39;, &#39;ciphers&#39;])</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def ssl_options_to_context(ssl_options: Union[Dict[str, Any], ssl.</span>
<span class="gd">-    SSLContext], server_side: Optional[bool]=None) -&gt;ssl.SSLContext:</span>
<span class="gi">+    def initialize(self, resolver: Resolver, mapping: dict) -&gt; None:</span>
<span class="gi">+        self.resolver = resolver</span>
<span class="gi">+        self.mapping = mapping</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self.resolver.close()</span>
<span class="gi">+</span>
<span class="gi">+    def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC</span>
<span class="gi">+    ) -&gt; Awaitable[List[Tuple[int, Any]]]:</span>
<span class="gi">+        if (host, port, family) in self.mapping:</span>
<span class="gi">+            host, port = self.mapping[(host, port, family)]</span>
<span class="gi">+        elif (host, port) in self.mapping:</span>
<span class="gi">+            host, port = self.mapping[(host, port)]</span>
<span class="gi">+        elif host in self.mapping:</span>
<span class="gi">+            host = self.mapping[host]</span>
<span class="gi">+        return self.resolver.resolve(host, port, family)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# These are the keyword arguments to ssl.wrap_socket that must be translated</span>
<span class="gi">+# to their SSLContext equivalents (the other arguments are still passed</span>
<span class="gi">+# to SSLContext.wrap_socket).</span>
<span class="gi">+_SSL_CONTEXT_KEYWORDS = frozenset(</span>
<span class="gi">+    [&quot;ssl_version&quot;, &quot;certfile&quot;, &quot;keyfile&quot;, &quot;cert_reqs&quot;, &quot;ca_certs&quot;, &quot;ciphers&quot;]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ssl_options_to_context(</span>
<span class="gi">+    ssl_options: Union[Dict[str, Any], ssl.SSLContext],</span>
<span class="gi">+    server_side: Optional[bool] = None,</span>
<span class="gi">+) -&gt; ssl.SSLContext:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to convert an ``ssl_options`` dictionary to an
<span class="w"> </span>    `~ssl.SSLContext` object.

<span class="gu">@@ -275,12 +606,48 @@ def ssl_options_to_context(ssl_options: Union[Dict[str, Any], ssl.</span>
<span class="w"> </span>       result in a DeprecationWarning on Python 3.10.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def ssl_wrap_socket(socket: socket.socket, ssl_options: Union[Dict[str, Any</span>
<span class="gd">-    ], ssl.SSLContext], server_hostname: Optional[str]=None, server_side:</span>
<span class="gd">-    Optional[bool]=None, **kwargs: Any) -&gt;ssl.SSLSocket:</span>
<span class="gi">+    if isinstance(ssl_options, ssl.SSLContext):</span>
<span class="gi">+        return ssl_options</span>
<span class="gi">+    assert isinstance(ssl_options, dict)</span>
<span class="gi">+    assert all(k in _SSL_CONTEXT_KEYWORDS for k in ssl_options), ssl_options</span>
<span class="gi">+    # TODO: Now that we have the server_side argument, can we switch to</span>
<span class="gi">+    # create_default_context or would that change behavior?</span>
<span class="gi">+    default_version = ssl.PROTOCOL_TLS</span>
<span class="gi">+    if server_side:</span>
<span class="gi">+        default_version = ssl.PROTOCOL_TLS_SERVER</span>
<span class="gi">+    elif server_side is not None:</span>
<span class="gi">+        default_version = ssl.PROTOCOL_TLS_CLIENT</span>
<span class="gi">+    context = ssl.SSLContext(ssl_options.get(&quot;ssl_version&quot;, default_version))</span>
<span class="gi">+    if &quot;certfile&quot; in ssl_options:</span>
<span class="gi">+        context.load_cert_chain(</span>
<span class="gi">+            ssl_options[&quot;certfile&quot;], ssl_options.get(&quot;keyfile&quot;, None)</span>
<span class="gi">+        )</span>
<span class="gi">+    if &quot;cert_reqs&quot; in ssl_options:</span>
<span class="gi">+        if ssl_options[&quot;cert_reqs&quot;] == ssl.CERT_NONE:</span>
<span class="gi">+            # This may have been set automatically by PROTOCOL_TLS_CLIENT but is</span>
<span class="gi">+            # incompatible with CERT_NONE so we must manually clear it.</span>
<span class="gi">+            context.check_hostname = False</span>
<span class="gi">+        context.verify_mode = ssl_options[&quot;cert_reqs&quot;]</span>
<span class="gi">+    if &quot;ca_certs&quot; in ssl_options:</span>
<span class="gi">+        context.load_verify_locations(ssl_options[&quot;ca_certs&quot;])</span>
<span class="gi">+    if &quot;ciphers&quot; in ssl_options:</span>
<span class="gi">+        context.set_ciphers(ssl_options[&quot;ciphers&quot;])</span>
<span class="gi">+    if hasattr(ssl, &quot;OP_NO_COMPRESSION&quot;):</span>
<span class="gi">+        # Disable TLS compression to avoid CRIME and related attacks.</span>
<span class="gi">+        # This constant depends on openssl version 1.0.</span>
<span class="gi">+        # TODO: Do we need to do this ourselves or can we trust</span>
<span class="gi">+        # the defaults?</span>
<span class="gi">+        context.options |= ssl.OP_NO_COMPRESSION</span>
<span class="gi">+    return context</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ssl_wrap_socket(</span>
<span class="gi">+    socket: socket.socket,</span>
<span class="gi">+    ssl_options: Union[Dict[str, Any], ssl.SSLContext],</span>
<span class="gi">+    server_hostname: Optional[str] = None,</span>
<span class="gi">+    server_side: Optional[bool] = None,</span>
<span class="gi">+    **kwargs: Any</span>
<span class="gi">+) -&gt; ssl.SSLSocket:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns an ``ssl.SSLSocket`` wrapping the given socket.

<span class="w"> </span>    ``ssl_options`` may be either an `ssl.SSLContext` object or a
<span class="gu">@@ -292,4 +659,13 @@ def ssl_wrap_socket(socket: socket.socket, ssl_options: Union[Dict[str, Any</span>
<span class="w"> </span>       Added server_side argument. Omitting this argument will
<span class="w"> </span>       result in a DeprecationWarning on Python 3.10.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = ssl_options_to_context(ssl_options, server_side=server_side)</span>
<span class="gi">+    if server_side is None:</span>
<span class="gi">+        server_side = False</span>
<span class="gi">+    assert ssl.HAS_SNI</span>
<span class="gi">+    # TODO: add a unittest for hostname validation (python added server-side SNI support in 3.4)</span>
<span class="gi">+    # In the meantime it can be manually tested with</span>
<span class="gi">+    # python3 -m tornado.httpclient https://sni.velox.ch</span>
<span class="gi">+    return context.wrap_socket(</span>
<span class="gi">+        socket, server_hostname=server_hostname, server_side=server_side, **kwargs</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/tornado/options.py b/tornado/options.py</span>
<span class="gh">index 9356e4bd..b8296691 100644</span>
<span class="gd">--- a/tornado/options.py</span>
<span class="gi">+++ b/tornado/options.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A command line parsing module that lets modules define their own options.

<span class="w"> </span>This module is inspired by Google&#39;s `gflags
<span class="gu">@@ -83,20 +98,35 @@ instances to define isolated sets of options, such as for subcommands.</span>
<span class="w"> </span>   Dashes are typical for command-line usage while config files require
<span class="w"> </span>   underscores.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import numbers
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>import os
<span class="w"> </span>import textwrap
<span class="gi">+</span>
<span class="w"> </span>from tornado.escape import _unicode, native_str
<span class="w"> </span>from tornado.log import define_logging_options
<span class="w"> </span>from tornado.util import basestring_type, exec_in
<span class="gd">-from typing import Any, Iterator, Iterable, Tuple, Set, Dict, Callable, List, TextIO, Optional</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    TextIO,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+)</span>


<span class="w"> </span>class Error(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Exception raised by errors in the options module.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -107,52 +137,60 @@ class OptionParser(object):</span>
<span class="w"> </span>    which reference a global instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.__dict__[&#39;_options&#39;] = {}</span>
<span class="gd">-        self.__dict__[&#39;_parse_callbacks&#39;] = []</span>
<span class="gd">-        self.define(&#39;help&#39;, type=bool, help=&#39;show this help information&#39;,</span>
<span class="gd">-            callback=self._help_callback)</span>
<span class="gd">-</span>
<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # we have to use self.__dict__ because we override setattr.</span>
<span class="gi">+        self.__dict__[&quot;_options&quot;] = {}</span>
<span class="gi">+        self.__dict__[&quot;_parse_callbacks&quot;] = []</span>
<span class="gi">+        self.define(</span>
<span class="gi">+            &quot;help&quot;,</span>
<span class="gi">+            type=bool,</span>
<span class="gi">+            help=&quot;show this help information&quot;,</span>
<span class="gi">+            callback=self._help_callback,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _normalize_name(self, name: str) -&gt; str:</span>
<span class="gi">+        return name.replace(&quot;_&quot;, &quot;-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        name = self._normalize_name(name)
<span class="w"> </span>        if isinstance(self._options.get(name), _Option):
<span class="w"> </span>            return self._options[name].value()
<span class="gd">-        raise AttributeError(&#39;Unrecognized option %r&#39; % name)</span>
<span class="gi">+        raise AttributeError(&quot;Unrecognized option %r&quot; % name)</span>

<span class="gd">-    def __setattr__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        name = self._normalize_name(name)
<span class="w"> </span>        if isinstance(self._options.get(name), _Option):
<span class="w"> </span>            return self._options[name].set(value)
<span class="gd">-        raise AttributeError(&#39;Unrecognized option %r&#39; % name)</span>
<span class="gi">+        raise AttributeError(&quot;Unrecognized option %r&quot; % name)</span>

<span class="gd">-    def __iter__(self) -&gt;Iterator:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator:</span>
<span class="w"> </span>        return (opt.name for opt in self._options.values())

<span class="gd">-    def __contains__(self, name: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, name: str) -&gt; bool:</span>
<span class="w"> </span>        name = self._normalize_name(name)
<span class="w"> </span>        return name in self._options

<span class="gd">-    def __getitem__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        return self.__getattr__(name)

<span class="gd">-    def __setitem__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        return self.__setattr__(name, value)

<span class="gd">-    def items(self) -&gt;Iterable[Tuple[str, Any]]:</span>
<span class="gi">+    def items(self) -&gt; Iterable[Tuple[str, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;An iterable of (name, value) pairs.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [(opt.name, opt.value()) for name, opt in self._options.items()]</span>

<span class="gd">-    def groups(self) -&gt;Set[str]:</span>
<span class="gi">+    def groups(self) -&gt; Set[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The set of option-groups created by ``define``.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return set(opt.group_name for opt in self._options.values())</span>

<span class="gd">-    def group_dict(self, group: str) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def group_dict(self, group: str) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The names and values of options in a group.

<span class="w"> </span>        Useful for copying options into Application settings::
<span class="gu">@@ -169,19 +207,30 @@ class OptionParser(object):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dict(</span>
<span class="gi">+            (opt.name, opt.value())</span>
<span class="gi">+            for name, opt in self._options.items()</span>
<span class="gi">+            if not group or group == opt.group_name</span>
<span class="gi">+        )</span>

<span class="gd">-    def as_dict(self) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def as_dict(self) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The names and values of all options.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def define(self, name: str, default: Any=None, type: Optional[type]=</span>
<span class="gd">-        None, help: Optional[str]=None, metavar: Optional[str]=None,</span>
<span class="gd">-        multiple: bool=False, group: Optional[str]=None, callback: Optional</span>
<span class="gd">-        [Callable[[Any], None]]=None) -&gt;None:</span>
<span class="gi">+        return dict((opt.name, opt.value()) for name, opt in self._options.items())</span>
<span class="gi">+</span>
<span class="gi">+    def define(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        default: Any = None,</span>
<span class="gi">+        type: Optional[type] = None,</span>
<span class="gi">+        help: Optional[str] = None,</span>
<span class="gi">+        metavar: Optional[str] = None,</span>
<span class="gi">+        multiple: bool = False,</span>
<span class="gi">+        group: Optional[str] = None,</span>
<span class="gi">+        callback: Optional[Callable[[Any], None]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Defines a new command line option.

<span class="w"> </span>        ``type`` can be any of `str`, `int`, `float`, `bool`,
<span class="gu">@@ -216,10 +265,56 @@ class OptionParser(object):</span>
<span class="w"> </span>        by later flags.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_command_line(self, args: Optional[List[str]]=None, final:</span>
<span class="gd">-        bool=True) -&gt;List[str]:</span>
<span class="gi">+        normalized = self._normalize_name(name)</span>
<span class="gi">+        if normalized in self._options:</span>
<span class="gi">+            raise Error(</span>
<span class="gi">+                &quot;Option %r already defined in %s&quot;</span>
<span class="gi">+                % (normalized, self._options[normalized].file_name)</span>
<span class="gi">+            )</span>
<span class="gi">+        frame = sys._getframe(0)</span>
<span class="gi">+        if frame is not None:</span>
<span class="gi">+            options_file = frame.f_code.co_filename</span>
<span class="gi">+</span>
<span class="gi">+            # Can be called directly, or through top level define() fn, in which</span>
<span class="gi">+            # case, step up above that frame to look for real caller.</span>
<span class="gi">+            if (</span>
<span class="gi">+                frame.f_back is not None</span>
<span class="gi">+                and frame.f_back.f_code.co_filename == options_file</span>
<span class="gi">+                and frame.f_back.f_code.co_name == &quot;define&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                frame = frame.f_back</span>
<span class="gi">+</span>
<span class="gi">+            assert frame.f_back is not None</span>
<span class="gi">+            file_name = frame.f_back.f_code.co_filename</span>
<span class="gi">+        else:</span>
<span class="gi">+            file_name = &quot;&lt;unknown&gt;&quot;</span>
<span class="gi">+        if file_name == options_file:</span>
<span class="gi">+            file_name = &quot;&quot;</span>
<span class="gi">+        if type is None:</span>
<span class="gi">+            if not multiple and default is not None:</span>
<span class="gi">+                type = default.__class__</span>
<span class="gi">+            else:</span>
<span class="gi">+                type = str</span>
<span class="gi">+        if group:</span>
<span class="gi">+            group_name = group  # type: Optional[str]</span>
<span class="gi">+        else:</span>
<span class="gi">+            group_name = file_name</span>
<span class="gi">+        option = _Option(</span>
<span class="gi">+            name,</span>
<span class="gi">+            file_name=file_name,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            type=type,</span>
<span class="gi">+            help=help,</span>
<span class="gi">+            metavar=metavar,</span>
<span class="gi">+            multiple=multiple,</span>
<span class="gi">+            group_name=group_name,</span>
<span class="gi">+            callback=callback,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._options[normalized] = option</span>
<span class="gi">+</span>
<span class="gi">+    def parse_command_line(</span>
<span class="gi">+        self, args: Optional[List[str]] = None, final: bool = True</span>
<span class="gi">+    ) -&gt; List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parses all options given on the command line (defaults to
<span class="w"> </span>        `sys.argv`).

<span class="gu">@@ -241,9 +336,37 @@ class OptionParser(object):</span>
<span class="w"> </span>        from multiple sources.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_config_file(self, path: str, final: bool=True) -&gt;None:</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            args = sys.argv</span>
<span class="gi">+        remaining = []  # type: List[str]</span>
<span class="gi">+        for i in range(1, len(args)):</span>
<span class="gi">+            # All things after the last option are command line arguments</span>
<span class="gi">+            if not args[i].startswith(&quot;-&quot;):</span>
<span class="gi">+                remaining = args[i:]</span>
<span class="gi">+                break</span>
<span class="gi">+            if args[i] == &quot;--&quot;:</span>
<span class="gi">+                remaining = args[i + 1 :]</span>
<span class="gi">+                break</span>
<span class="gi">+            arg = args[i].lstrip(&quot;-&quot;)</span>
<span class="gi">+            name, equals, value = arg.partition(&quot;=&quot;)</span>
<span class="gi">+            name = self._normalize_name(name)</span>
<span class="gi">+            if name not in self._options:</span>
<span class="gi">+                self.print_help()</span>
<span class="gi">+                raise Error(&quot;Unrecognized command line option: %r&quot; % name)</span>
<span class="gi">+            option = self._options[name]</span>
<span class="gi">+            if not equals:</span>
<span class="gi">+                if option.type == bool:</span>
<span class="gi">+                    value = &quot;true&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise Error(&quot;Option %r requires a value&quot; % name)</span>
<span class="gi">+            option.parse(value)</span>
<span class="gi">+</span>
<span class="gi">+        if final:</span>
<span class="gi">+            self.run_parse_callbacks()</span>
<span class="gi">+</span>
<span class="gi">+        return remaining</span>
<span class="gi">+</span>
<span class="gi">+    def parse_config_file(self, path: str, final: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parses and loads the config file at the given path.

<span class="w"> </span>        The config file contains Python code that will be executed (so
<span class="gu">@@ -289,17 +412,75 @@ class OptionParser(object):</span>
<span class="w"> </span>           Added the ability to set options via strings in config files.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def print_help(self, file: Optional[TextIO]=None) -&gt;None:</span>
<span class="gi">+        config = {&quot;__file__&quot;: os.path.abspath(path)}</span>
<span class="gi">+        with open(path, &quot;rb&quot;) as f:</span>
<span class="gi">+            exec_in(native_str(f.read()), config, config)</span>
<span class="gi">+        for name in config:</span>
<span class="gi">+            normalized = self._normalize_name(name)</span>
<span class="gi">+            if normalized in self._options:</span>
<span class="gi">+                option = self._options[normalized]</span>
<span class="gi">+                if option.multiple:</span>
<span class="gi">+                    if not isinstance(config[name], (list, str)):</span>
<span class="gi">+                        raise Error(</span>
<span class="gi">+                            &quot;Option %r is required to be a list of %s &quot;</span>
<span class="gi">+                            &quot;or a comma-separated string&quot;</span>
<span class="gi">+                            % (option.name, option.type.__name__)</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+                if type(config[name]) == str and (</span>
<span class="gi">+                    option.type != str or option.multiple</span>
<span class="gi">+                ):</span>
<span class="gi">+                    option.parse(config[name])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    option.set(config[name])</span>
<span class="gi">+</span>
<span class="gi">+        if final:</span>
<span class="gi">+            self.run_parse_callbacks()</span>
<span class="gi">+</span>
<span class="gi">+    def print_help(self, file: Optional[TextIO] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prints all the command line options to stderr (or another file).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_parse_callback(self, callback: Callable[[], None]) -&gt;None:</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            file = sys.stderr</span>
<span class="gi">+        print(&quot;Usage: %s [OPTIONS]&quot; % sys.argv[0], file=file)</span>
<span class="gi">+        print(&quot;\nOptions:\n&quot;, file=file)</span>
<span class="gi">+        by_group = {}  # type: Dict[str, List[_Option]]</span>
<span class="gi">+        for option in self._options.values():</span>
<span class="gi">+            by_group.setdefault(option.group_name, []).append(option)</span>
<span class="gi">+</span>
<span class="gi">+        for filename, o in sorted(by_group.items()):</span>
<span class="gi">+            if filename:</span>
<span class="gi">+                print(&quot;\n%s options:\n&quot; % os.path.normpath(filename), file=file)</span>
<span class="gi">+            o.sort(key=lambda option: option.name)</span>
<span class="gi">+            for option in o:</span>
<span class="gi">+                # Always print names with dashes in a CLI context.</span>
<span class="gi">+                prefix = self._normalize_name(option.name)</span>
<span class="gi">+                if option.metavar:</span>
<span class="gi">+                    prefix += &quot;=&quot; + option.metavar</span>
<span class="gi">+                description = option.help or &quot;&quot;</span>
<span class="gi">+                if option.default is not None and option.default != &quot;&quot;:</span>
<span class="gi">+                    description += &quot; (default %s)&quot; % option.default</span>
<span class="gi">+                lines = textwrap.wrap(description, 79 - 35)</span>
<span class="gi">+                if len(prefix) &gt; 30 or len(lines) == 0:</span>
<span class="gi">+                    lines.insert(0, &quot;&quot;)</span>
<span class="gi">+                print(&quot;  --%-30s %s&quot; % (prefix, lines[0]), file=file)</span>
<span class="gi">+                for line in lines[1:]:</span>
<span class="gi">+                    print(&quot;%-34s %s&quot; % (&quot; &quot;, line), file=file)</span>
<span class="gi">+        print(file=file)</span>
<span class="gi">+</span>
<span class="gi">+    def _help_callback(self, value: bool) -&gt; None:</span>
<span class="gi">+        if value:</span>
<span class="gi">+            self.print_help()</span>
<span class="gi">+            sys.exit(0)</span>
<span class="gi">+</span>
<span class="gi">+    def add_parse_callback(self, callback: Callable[[], None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a parse callback, to be invoked when option parsing is done.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._parse_callbacks.append(callback)</span>
<span class="gi">+</span>
<span class="gi">+    def run_parse_callbacks(self) -&gt; None:</span>
<span class="gi">+        for callback in self._parse_callbacks:</span>
<span class="gi">+            callback()</span>

<span class="gd">-    def mockable(self) -&gt;&#39;_Mockable&#39;:</span>
<span class="gi">+    def mockable(self) -&gt; &quot;_Mockable&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a wrapper around self that is compatible with
<span class="w"> </span>        `mock.patch &lt;unittest.mock.patch&gt;`.

<span class="gu">@@ -314,7 +495,7 @@ class OptionParser(object):</span>
<span class="w"> </span>            with mock.patch.object(options.mockable(), &#39;name&#39;, value):
<span class="w"> </span>                assert options.name == value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Mockable(self)</span>


<span class="w"> </span>class _Mockable(object):
<span class="gu">@@ -330,35 +511,46 @@ class _Mockable(object):</span>
<span class="w"> </span>    OptionParser, and delattr undoes the effect of a previous setattr.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, options: OptionParser) -&gt;None:</span>
<span class="gd">-        self.__dict__[&#39;_options&#39;] = options</span>
<span class="gd">-        self.__dict__[&#39;_originals&#39;] = {}</span>
<span class="gi">+    def __init__(self, options: OptionParser) -&gt; None:</span>
<span class="gi">+        # Modify __dict__ directly to bypass __setattr__</span>
<span class="gi">+        self.__dict__[&quot;_options&quot;] = options</span>
<span class="gi">+        self.__dict__[&quot;_originals&quot;] = {}</span>

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        return getattr(self._options, name)

<span class="gd">-    def __setattr__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        assert name not in self._originals, &quot;don&#39;t reuse mockable objects&quot;
<span class="w"> </span>        self._originals[name] = getattr(self._options, name)
<span class="w"> </span>        setattr(self._options, name, value)

<span class="gd">-    def __delattr__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __delattr__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        setattr(self._options, name, self._originals.pop(name))


<span class="w"> </span>class _Option(object):
<span class="gi">+    # This class could almost be made generic, but the way the types</span>
<span class="gi">+    # interact with the multiple argument makes this tricky. (default</span>
<span class="gi">+    # and the callback use List[T], but type is still Type[T]).</span>
<span class="w"> </span>    UNSET = object()

<span class="gd">-    def __init__(self, name: str, default: Any=None, type: Optional[type]=</span>
<span class="gd">-        None, help: Optional[str]=None, metavar: Optional[str]=None,</span>
<span class="gd">-        multiple: bool=False, file_name: Optional[str]=None, group_name:</span>
<span class="gd">-        Optional[str]=None, callback: Optional[Callable[[Any], None]]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        default: Any = None,</span>
<span class="gi">+        type: Optional[type] = None,</span>
<span class="gi">+        help: Optional[str] = None,</span>
<span class="gi">+        metavar: Optional[str] = None,</span>
<span class="gi">+        multiple: bool = False,</span>
<span class="gi">+        file_name: Optional[str] = None,</span>
<span class="gi">+        group_name: Optional[str] = None,</span>
<span class="gi">+        callback: Optional[Callable[[Any], None]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if default is None and multiple:
<span class="w"> </span>            default = []
<span class="w"> </span>        self.name = name
<span class="w"> </span>        if type is None:
<span class="gd">-            raise ValueError(&#39;type must not be None&#39;)</span>
<span class="gi">+            raise ValueError(&quot;type must not be None&quot;)</span>
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.help = help
<span class="w"> </span>        self.metavar = metavar
<span class="gu">@@ -367,16 +559,124 @@ class _Option(object):</span>
<span class="w"> </span>        self.group_name = group_name
<span class="w"> </span>        self.callback = callback
<span class="w"> </span>        self.default = default
<span class="gd">-        self._value = _Option.UNSET</span>
<span class="gd">-    _DATETIME_FORMATS = [&#39;%a %b %d %H:%M:%S %Y&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;,</span>
<span class="gd">-        &#39;%Y-%m-%d %H:%M&#39;, &#39;%Y-%m-%dT%H:%M&#39;, &#39;%Y%m%d %H:%M:%S&#39;,</span>
<span class="gd">-        &#39;%Y%m%d %H:%M&#39;, &#39;%Y-%m-%d&#39;, &#39;%Y%m%d&#39;, &#39;%H:%M:%S&#39;, &#39;%H:%M&#39;]</span>
<span class="gd">-    _TIMEDELTA_ABBREV_DICT = {&#39;h&#39;: &#39;hours&#39;, &#39;m&#39;: &#39;minutes&#39;, &#39;min&#39;:</span>
<span class="gd">-        &#39;minutes&#39;, &#39;s&#39;: &#39;seconds&#39;, &#39;sec&#39;: &#39;seconds&#39;, &#39;ms&#39;: &#39;milliseconds&#39;,</span>
<span class="gd">-        &#39;us&#39;: &#39;microseconds&#39;, &#39;d&#39;: &#39;days&#39;, &#39;w&#39;: &#39;weeks&#39;}</span>
<span class="gd">-    _FLOAT_PATTERN = &#39;[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?&#39;</span>
<span class="gd">-    _TIMEDELTA_PATTERN = re.compile(&#39;\\s*(%s)\\s*(\\w*)\\s*&#39; %</span>
<span class="gd">-        _FLOAT_PATTERN, re.IGNORECASE)</span>
<span class="gi">+        self._value = _Option.UNSET  # type: Any</span>
<span class="gi">+</span>
<span class="gi">+    def value(self) -&gt; Any:</span>
<span class="gi">+        return self.default if self._value is _Option.UNSET else self._value</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, value: str) -&gt; Any:</span>
<span class="gi">+        _parse = {</span>
<span class="gi">+            datetime.datetime: self._parse_datetime,</span>
<span class="gi">+            datetime.timedelta: self._parse_timedelta,</span>
<span class="gi">+            bool: self._parse_bool,</span>
<span class="gi">+            basestring_type: self._parse_string,</span>
<span class="gi">+        }.get(</span>
<span class="gi">+            self.type, self.type</span>
<span class="gi">+        )  # type: Callable[[str], Any]</span>
<span class="gi">+        if self.multiple:</span>
<span class="gi">+            self._value = []</span>
<span class="gi">+            for part in value.split(&quot;,&quot;):</span>
<span class="gi">+                if issubclass(self.type, numbers.Integral):</span>
<span class="gi">+                    # allow ranges of the form X:Y (inclusive at both ends)</span>
<span class="gi">+                    lo_str, _, hi_str = part.partition(&quot;:&quot;)</span>
<span class="gi">+                    lo = _parse(lo_str)</span>
<span class="gi">+                    hi = _parse(hi_str) if hi_str else lo</span>
<span class="gi">+                    self._value.extend(range(lo, hi + 1))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._value.append(_parse(part))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._value = _parse(value)</span>
<span class="gi">+        if self.callback is not None:</span>
<span class="gi">+            self.callback(self._value)</span>
<span class="gi">+        return self.value()</span>
<span class="gi">+</span>
<span class="gi">+    def set(self, value: Any) -&gt; None:</span>
<span class="gi">+        if self.multiple:</span>
<span class="gi">+            if not isinstance(value, list):</span>
<span class="gi">+                raise Error(</span>
<span class="gi">+                    &quot;Option %r is required to be a list of %s&quot;</span>
<span class="gi">+                    % (self.name, self.type.__name__)</span>
<span class="gi">+                )</span>
<span class="gi">+            for item in value:</span>
<span class="gi">+                if item is not None and not isinstance(item, self.type):</span>
<span class="gi">+                    raise Error(</span>
<span class="gi">+                        &quot;Option %r is required to be a list of %s&quot;</span>
<span class="gi">+                        % (self.name, self.type.__name__)</span>
<span class="gi">+                    )</span>
<span class="gi">+        else:</span>
<span class="gi">+            if value is not None and not isinstance(value, self.type):</span>
<span class="gi">+                raise Error(</span>
<span class="gi">+                    &quot;Option %r is required to be a %s (%s given)&quot;</span>
<span class="gi">+                    % (self.name, self.type.__name__, type(value))</span>
<span class="gi">+                )</span>
<span class="gi">+        self._value = value</span>
<span class="gi">+        if self.callback is not None:</span>
<span class="gi">+            self.callback(self._value)</span>
<span class="gi">+</span>
<span class="gi">+    # Supported date/time formats in our options</span>
<span class="gi">+    _DATETIME_FORMATS = [</span>
<span class="gi">+        &quot;%a %b %d %H:%M:%S %Y&quot;,</span>
<span class="gi">+        &quot;%Y-%m-%d %H:%M:%S&quot;,</span>
<span class="gi">+        &quot;%Y-%m-%d %H:%M&quot;,</span>
<span class="gi">+        &quot;%Y-%m-%dT%H:%M&quot;,</span>
<span class="gi">+        &quot;%Y%m%d %H:%M:%S&quot;,</span>
<span class="gi">+        &quot;%Y%m%d %H:%M&quot;,</span>
<span class="gi">+        &quot;%Y-%m-%d&quot;,</span>
<span class="gi">+        &quot;%Y%m%d&quot;,</span>
<span class="gi">+        &quot;%H:%M:%S&quot;,</span>
<span class="gi">+        &quot;%H:%M&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_datetime(self, value: str) -&gt; datetime.datetime:</span>
<span class="gi">+        for format in self._DATETIME_FORMATS:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return datetime.datetime.strptime(value, format)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise Error(&quot;Unrecognized date/time format: %r&quot; % value)</span>
<span class="gi">+</span>
<span class="gi">+    _TIMEDELTA_ABBREV_DICT = {</span>
<span class="gi">+        &quot;h&quot;: &quot;hours&quot;,</span>
<span class="gi">+        &quot;m&quot;: &quot;minutes&quot;,</span>
<span class="gi">+        &quot;min&quot;: &quot;minutes&quot;,</span>
<span class="gi">+        &quot;s&quot;: &quot;seconds&quot;,</span>
<span class="gi">+        &quot;sec&quot;: &quot;seconds&quot;,</span>
<span class="gi">+        &quot;ms&quot;: &quot;milliseconds&quot;,</span>
<span class="gi">+        &quot;us&quot;: &quot;microseconds&quot;,</span>
<span class="gi">+        &quot;d&quot;: &quot;days&quot;,</span>
<span class="gi">+        &quot;w&quot;: &quot;weeks&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    _FLOAT_PATTERN = r&quot;[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?&quot;</span>
<span class="gi">+</span>
<span class="gi">+    _TIMEDELTA_PATTERN = re.compile(</span>
<span class="gi">+        r&quot;\s*(%s)\s*(\w*)\s*&quot; % _FLOAT_PATTERN, re.IGNORECASE</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_timedelta(self, value: str) -&gt; datetime.timedelta:</span>
<span class="gi">+        try:</span>
<span class="gi">+            sum = datetime.timedelta()</span>
<span class="gi">+            start = 0</span>
<span class="gi">+            while start &lt; len(value):</span>
<span class="gi">+                m = self._TIMEDELTA_PATTERN.match(value, start)</span>
<span class="gi">+                if not m:</span>
<span class="gi">+                    raise Exception()</span>
<span class="gi">+                num = float(m.group(1))</span>
<span class="gi">+                units = m.group(2) or &quot;seconds&quot;</span>
<span class="gi">+                units = self._TIMEDELTA_ABBREV_DICT.get(units, units)</span>
<span class="gi">+                # This line confuses mypy when setup.py sets python_version=3.6</span>
<span class="gi">+                # https://github.com/python/mypy/issues/9676</span>
<span class="gi">+                sum += datetime.timedelta(**{units: num})  # type: ignore</span>
<span class="gi">+                start = m.end()</span>
<span class="gi">+            return sum</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_bool(self, value: str) -&gt; bool:</span>
<span class="gi">+        return value.lower() not in (&quot;false&quot;, &quot;0&quot;, &quot;f&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_string(self, value: str) -&gt; str:</span>
<span class="gi">+        return _unicode(value)</span>


<span class="w"> </span>options = OptionParser()
<span class="gu">@@ -386,48 +686,65 @@ All defined options are available as attributes on this object.</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def define(name: str, default: Any=None, type: Optional[type]=None, help:</span>
<span class="gd">-    Optional[str]=None, metavar: Optional[str]=None, multiple: bool=False,</span>
<span class="gd">-    group: Optional[str]=None, callback: Optional[Callable[[Any], None]]=None</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+def define(</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    default: Any = None,</span>
<span class="gi">+    type: Optional[type] = None,</span>
<span class="gi">+    help: Optional[str] = None,</span>
<span class="gi">+    metavar: Optional[str] = None,</span>
<span class="gi">+    multiple: bool = False,</span>
<span class="gi">+    group: Optional[str] = None,</span>
<span class="gi">+    callback: Optional[Callable[[Any], None]] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Defines an option in the global namespace.

<span class="w"> </span>    See `OptionParser.define`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_command_line(args: Optional[List[str]]=None, final: bool=True</span>
<span class="gd">-    ) -&gt;List[str]:</span>
<span class="gi">+    return options.define(</span>
<span class="gi">+        name,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+        type=type,</span>
<span class="gi">+        help=help,</span>
<span class="gi">+        metavar=metavar,</span>
<span class="gi">+        multiple=multiple,</span>
<span class="gi">+        group=group,</span>
<span class="gi">+        callback=callback,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_command_line(</span>
<span class="gi">+    args: Optional[List[str]] = None, final: bool = True</span>
<span class="gi">+) -&gt; List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses global options from the command line.

<span class="w"> </span>    See `OptionParser.parse_command_line`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return options.parse_command_line(args, final=final)</span>


<span class="gd">-def parse_config_file(path: str, final: bool=True) -&gt;None:</span>
<span class="gi">+def parse_config_file(path: str, final: bool = True) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses global options from a config file.

<span class="w"> </span>    See `OptionParser.parse_config_file`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return options.parse_config_file(path, final=final)</span>


<span class="gd">-def print_help(file: Optional[TextIO]=None) -&gt;None:</span>
<span class="gi">+def print_help(file: Optional[TextIO] = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Prints all the command line options to stderr (or another file).

<span class="w"> </span>    See `OptionParser.print_help`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return options.print_help(file)</span>


<span class="gd">-def add_parse_callback(callback: Callable[[], None]) -&gt;None:</span>
<span class="gi">+def add_parse_callback(callback: Callable[[], None]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Adds a parse callback, to be invoked when option parsing is done.

<span class="w"> </span>    See `OptionParser.add_parse_callback`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    options.add_parse_callback(callback)</span>


<span class="gi">+# Default options</span>
<span class="w"> </span>define_logging_options(options)
<span class="gh">diff --git a/tornado/platform/asyncio.py b/tornado/platform/asyncio.py</span>
<span class="gh">index e67cf2ca..79e60848 100644</span>
<span class="gd">--- a/tornado/platform/asyncio.py</span>
<span class="gi">+++ b/tornado/platform/asyncio.py</span>
<span class="gu">@@ -21,6 +21,7 @@ the same event loop.</span>
<span class="w"> </span>   of Tornado (but may reduce performance of other ``asyncio``-based libraries
<span class="w"> </span>   in the same process).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import atexit
<span class="w"> </span>import concurrent.futures
<span class="gu">@@ -34,21 +35,238 @@ import typing</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from tornado.gen import convert_yielded
<span class="w"> </span>from tornado.ioloop import IOLoop, _Selectable
<span class="gd">-from typing import Any, Callable, Dict, List, Optional, Protocol, Set, Tuple, TypeVar, Union</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Protocol,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>


<span class="w"> </span>class _HasFileno(Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>_FileDescriptorLike = Union[int, _HasFileno]
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gd">-_selector_loops: Set[&#39;SelectorThread&#39;] = set()</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Collection of selector thread event loops to shut down on exit.</span>
<span class="gi">+_selector_loops: Set[&quot;SelectorThread&quot;] = set()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _atexit_callback() -&gt; None:</span>
<span class="gi">+    for loop in _selector_loops:</span>
<span class="gi">+        with loop._select_cond:</span>
<span class="gi">+            loop._closing_selector = True</span>
<span class="gi">+            loop._select_cond.notify()</span>
<span class="gi">+        try:</span>
<span class="gi">+            loop._waker_w.send(b&quot;a&quot;)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        if loop._thread is not None:</span>
<span class="gi">+            # If we don&#39;t join our (daemon) thread here, we may get a deadlock</span>
<span class="gi">+            # during interpreter shutdown. I don&#39;t really understand why. This</span>
<span class="gi">+            # deadlock happens every time in CI (both travis and appveyor) but</span>
<span class="gi">+            # I&#39;ve never been able to reproduce locally.</span>
<span class="gi">+            loop._thread.join()</span>
<span class="gi">+    _selector_loops.clear()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>atexit.register(_atexit_callback)


<span class="w"> </span>class BaseAsyncIOLoop(IOLoop):
<span class="gd">-    pass</span>
<span class="gi">+    def initialize(  # type: ignore</span>
<span class="gi">+        self, asyncio_loop: asyncio.AbstractEventLoop, **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # asyncio_loop is always the real underlying IOLoop. This is used in</span>
<span class="gi">+        # ioloop.py to maintain the asyncio-to-ioloop mappings.</span>
<span class="gi">+        self.asyncio_loop = asyncio_loop</span>
<span class="gi">+        # selector_loop is an event loop that implements the add_reader family of</span>
<span class="gi">+        # methods. Usually the same as asyncio_loop but differs on platforms such</span>
<span class="gi">+        # as windows where the default event loop does not implement these methods.</span>
<span class="gi">+        self.selector_loop = asyncio_loop</span>
<span class="gi">+        if hasattr(asyncio, &quot;ProactorEventLoop&quot;) and isinstance(</span>
<span class="gi">+            asyncio_loop, asyncio.ProactorEventLoop</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Ignore this line for mypy because the abstract method checker</span>
<span class="gi">+            # doesn&#39;t understand dynamic proxies.</span>
<span class="gi">+            self.selector_loop = AddThreadSelectorEventLoop(asyncio_loop)  # type: ignore</span>
<span class="gi">+        # Maps fd to (fileobj, handler function) pair (as in IOLoop.add_handler)</span>
<span class="gi">+        self.handlers: Dict[int, Tuple[Union[int, _Selectable], Callable]] = {}</span>
<span class="gi">+        # Set of fds listening for reads/writes</span>
<span class="gi">+        self.readers: Set[int] = set()</span>
<span class="gi">+        self.writers: Set[int] = set()</span>
<span class="gi">+        self.closing = False</span>
<span class="gi">+        # If an asyncio loop was closed through an asyncio interface</span>
<span class="gi">+        # instead of IOLoop.close(), we&#39;d never hear about it and may</span>
<span class="gi">+        # have left a dangling reference in our map. In case an</span>
<span class="gi">+        # application (or, more likely, a test suite) creates and</span>
<span class="gi">+        # destroys a lot of event loops in this way, check here to</span>
<span class="gi">+        # ensure that we don&#39;t have a lot of dead loops building up in</span>
<span class="gi">+        # the map.</span>
<span class="gi">+        #</span>
<span class="gi">+        # TODO(bdarnell): consider making self.asyncio_loop a weakref</span>
<span class="gi">+        # for AsyncIOMainLoop and make _ioloop_for_asyncio a</span>
<span class="gi">+        # WeakKeyDictionary.</span>
<span class="gi">+        for loop in IOLoop._ioloop_for_asyncio.copy():</span>
<span class="gi">+            if loop.is_closed():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    del IOLoop._ioloop_for_asyncio[loop]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure we don&#39;t already have an IOLoop for this asyncio loop</span>
<span class="gi">+        existing_loop = IOLoop._ioloop_for_asyncio.setdefault(asyncio_loop, self)</span>
<span class="gi">+        if existing_loop is not self:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                f&quot;IOLoop {existing_loop} already associated with asyncio loop {asyncio_loop}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        super().initialize(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self, all_fds: bool = False) -&gt; None:</span>
<span class="gi">+        self.closing = True</span>
<span class="gi">+        for fd in list(self.handlers):</span>
<span class="gi">+            fileobj, handler_func = self.handlers[fd]</span>
<span class="gi">+            self.remove_handler(fd)</span>
<span class="gi">+            if all_fds:</span>
<span class="gi">+                self.close_fd(fileobj)</span>
<span class="gi">+        # Remove the mapping before closing the asyncio loop. If this</span>
<span class="gi">+        # happened in the other order, we could race against another</span>
<span class="gi">+        # initialize() call which would see the closed asyncio loop,</span>
<span class="gi">+        # assume it was closed from the asyncio side, and do this</span>
<span class="gi">+        # cleanup for us, leading to a KeyError.</span>
<span class="gi">+        del IOLoop._ioloop_for_asyncio[self.asyncio_loop]</span>
<span class="gi">+        if self.selector_loop is not self.asyncio_loop:</span>
<span class="gi">+            self.selector_loop.close()</span>
<span class="gi">+        self.asyncio_loop.close()</span>
<span class="gi">+</span>
<span class="gi">+    def add_handler(</span>
<span class="gi">+        self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        fd, fileobj = self.split_fd(fd)</span>
<span class="gi">+        if fd in self.handlers:</span>
<span class="gi">+            raise ValueError(&quot;fd %s added twice&quot; % fd)</span>
<span class="gi">+        self.handlers[fd] = (fileobj, handler)</span>
<span class="gi">+        if events &amp; IOLoop.READ:</span>
<span class="gi">+            self.selector_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ)</span>
<span class="gi">+            self.readers.add(fd)</span>
<span class="gi">+        if events &amp; IOLoop.WRITE:</span>
<span class="gi">+            self.selector_loop.add_writer(fd, self._handle_events, fd, IOLoop.WRITE)</span>
<span class="gi">+            self.writers.add(fd)</span>
<span class="gi">+</span>
<span class="gi">+    def update_handler(self, fd: Union[int, _Selectable], events: int) -&gt; None:</span>
<span class="gi">+        fd, fileobj = self.split_fd(fd)</span>
<span class="gi">+        if events &amp; IOLoop.READ:</span>
<span class="gi">+            if fd not in self.readers:</span>
<span class="gi">+                self.selector_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ)</span>
<span class="gi">+                self.readers.add(fd)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if fd in self.readers:</span>
<span class="gi">+                self.selector_loop.remove_reader(fd)</span>
<span class="gi">+                self.readers.remove(fd)</span>
<span class="gi">+        if events &amp; IOLoop.WRITE:</span>
<span class="gi">+            if fd not in self.writers:</span>
<span class="gi">+                self.selector_loop.add_writer(fd, self._handle_events, fd, IOLoop.WRITE)</span>
<span class="gi">+                self.writers.add(fd)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if fd in self.writers:</span>
<span class="gi">+                self.selector_loop.remove_writer(fd)</span>
<span class="gi">+                self.writers.remove(fd)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_handler(self, fd: Union[int, _Selectable]) -&gt; None:</span>
<span class="gi">+        fd, fileobj = self.split_fd(fd)</span>
<span class="gi">+        if fd not in self.handlers:</span>
<span class="gi">+            return</span>
<span class="gi">+        if fd in self.readers:</span>
<span class="gi">+            self.selector_loop.remove_reader(fd)</span>
<span class="gi">+            self.readers.remove(fd)</span>
<span class="gi">+        if fd in self.writers:</span>
<span class="gi">+            self.selector_loop.remove_writer(fd)</span>
<span class="gi">+            self.writers.remove(fd)</span>
<span class="gi">+        del self.handlers[fd]</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_events(self, fd: int, events: int) -&gt; None:</span>
<span class="gi">+        fileobj, handler_func = self.handlers[fd]</span>
<span class="gi">+        handler_func(fileobj, events)</span>
<span class="gi">+</span>
<span class="gi">+    def start(self) -&gt; None:</span>
<span class="gi">+        self.asyncio_loop.run_forever()</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self) -&gt; None:</span>
<span class="gi">+        self.asyncio_loop.stop()</span>
<span class="gi">+</span>
<span class="gi">+    def call_at(</span>
<span class="gi">+        self, when: float, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; object:</span>
<span class="gi">+        # asyncio.call_at supports *args but not **kwargs, so bind them here.</span>
<span class="gi">+        # We do not synchronize self.time and asyncio_loop.time, so</span>
<span class="gi">+        # convert from absolute to relative.</span>
<span class="gi">+        return self.asyncio_loop.call_later(</span>
<span class="gi">+            max(0, when - self.time()),</span>
<span class="gi">+            self._run_callback,</span>
<span class="gi">+            functools.partial(callback, *args, **kwargs),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def remove_timeout(self, timeout: object) -&gt; None:</span>
<span class="gi">+        timeout.cancel()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def add_callback(self, callback: Callable, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if asyncio.get_running_loop() is self.asyncio_loop:</span>
<span class="gi">+                call_soon = self.asyncio_loop.call_soon</span>
<span class="gi">+            else:</span>
<span class="gi">+                call_soon = self.asyncio_loop.call_soon_threadsafe</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            call_soon = self.asyncio_loop.call_soon_threadsafe</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            call_soon(self._run_callback, functools.partial(callback, *args, **kwargs))</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            # &quot;Event loop is closed&quot;. Swallow the exception for</span>
<span class="gi">+            # consistency with PollIOLoop (and logical consistency</span>
<span class="gi">+            # with the fact that we can&#39;t guarantee that an</span>
<span class="gi">+            # add_callback that completes without error will</span>
<span class="gi">+            # eventually execute).</span>
<span class="gi">+            pass</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # ProactorEventLoop may raise this instead of RuntimeError</span>
<span class="gi">+            # if call_soon_threadsafe races with a call to close().</span>
<span class="gi">+            # Swallow it too for consistency.</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def add_callback_from_signal(</span>
<span class="gi">+        self, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        warnings.warn(&quot;add_callback_from_signal is deprecated&quot;, DeprecationWarning)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.asyncio_loop.call_soon_threadsafe(</span>
<span class="gi">+                self._run_callback, functools.partial(callback, *args, **kwargs)</span>
<span class="gi">+            )</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def run_in_executor(</span>
<span class="gi">+        self,</span>
<span class="gi">+        executor: Optional[concurrent.futures.Executor],</span>
<span class="gi">+        func: Callable[..., _T],</span>
<span class="gi">+        *args: Any,</span>
<span class="gi">+    ) -&gt; &quot;asyncio.Future[_T]&quot;:</span>
<span class="gi">+        return self.asyncio_loop.run_in_executor(executor, func, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def set_default_executor(self, executor: concurrent.futures.Executor) -&gt; None:</span>
<span class="gi">+        return self.asyncio_loop.set_default_executor(executor)</span>


<span class="w"> </span>class AsyncIOMainLoop(BaseAsyncIOLoop):
<span class="gu">@@ -66,6 +284,14 @@ class AsyncIOMainLoop(BaseAsyncIOLoop):</span>
<span class="w"> </span>       Closing an `AsyncIOMainLoop` now closes the underlying asyncio loop.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def initialize(self, **kwargs: Any) -&gt; None:  # type: ignore</span>
<span class="gi">+        super().initialize(asyncio.get_event_loop(), **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _make_current(self) -&gt; None:</span>
<span class="gi">+        # AsyncIOMainLoop already refers to the current asyncio loop so</span>
<span class="gi">+        # nothing to do here.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class AsyncIOLoop(BaseAsyncIOLoop):
<span class="w"> </span>    &quot;&quot;&quot;``AsyncIOLoop`` is an `.IOLoop` that runs on an ``asyncio`` event loop.
<span class="gu">@@ -93,8 +319,41 @@ class AsyncIOLoop(BaseAsyncIOLoop):</span>
<span class="w"> </span>       to refer to this class directly.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="gd">-def to_tornado_future(asyncio_future: asyncio.Future) -&gt;asyncio.Future:</span>
<span class="gi">+    def initialize(self, **kwargs: Any) -&gt; None:  # type: ignore</span>
<span class="gi">+        self.is_current = False</span>
<span class="gi">+        loop = None</span>
<span class="gi">+        if &quot;asyncio_loop&quot; not in kwargs:</span>
<span class="gi">+            kwargs[&quot;asyncio_loop&quot;] = loop = asyncio.new_event_loop()</span>
<span class="gi">+        try:</span>
<span class="gi">+            super().initialize(**kwargs)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # If initialize() does not succeed (taking ownership of the loop),</span>
<span class="gi">+            # we have to close it.</span>
<span class="gi">+            if loop is not None:</span>
<span class="gi">+                loop.close()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def close(self, all_fds: bool = False) -&gt; None:</span>
<span class="gi">+        if self.is_current:</span>
<span class="gi">+            self._clear_current()</span>
<span class="gi">+        super().close(all_fds=all_fds)</span>
<span class="gi">+</span>
<span class="gi">+    def _make_current(self) -&gt; None:</span>
<span class="gi">+        if not self.is_current:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.old_asyncio = asyncio.get_event_loop()</span>
<span class="gi">+            except (RuntimeError, AssertionError):</span>
<span class="gi">+                self.old_asyncio = None  # type: ignore</span>
<span class="gi">+            self.is_current = True</span>
<span class="gi">+        asyncio.set_event_loop(self.asyncio_loop)</span>
<span class="gi">+</span>
<span class="gi">+    def _clear_current_hook(self) -&gt; None:</span>
<span class="gi">+        if self.is_current:</span>
<span class="gi">+            asyncio.set_event_loop(self.old_asyncio)</span>
<span class="gi">+            self.is_current = False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_tornado_future(asyncio_future: asyncio.Future) -&gt; asyncio.Future:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an `asyncio.Future` to a `tornado.concurrent.Future`.

<span class="w"> </span>    .. versionadded:: 4.1
<span class="gu">@@ -103,10 +362,10 @@ def to_tornado_future(asyncio_future: asyncio.Future) -&gt;asyncio.Future:</span>
<span class="w"> </span>       Tornado ``Futures`` have been merged with `asyncio.Future`,
<span class="w"> </span>       so this method is now a no-op.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return asyncio_future</span>


<span class="gd">-def to_asyncio_future(tornado_future: asyncio.Future) -&gt;asyncio.Future:</span>
<span class="gi">+def to_asyncio_future(tornado_future: asyncio.Future) -&gt; asyncio.Future:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a Tornado yieldable object to an `asyncio.Future`.

<span class="w"> </span>    .. versionadded:: 4.1
<span class="gu">@@ -119,17 +378,18 @@ def to_asyncio_future(tornado_future: asyncio.Future) -&gt;asyncio.Future:</span>
<span class="w"> </span>       Tornado ``Futures`` have been merged with `asyncio.Future`,
<span class="w"> </span>       so this method is now equivalent to `tornado.gen.convert_yielded`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return convert_yielded(tornado_future)</span>


<span class="gd">-if sys.platform == &#39;win32&#39; and hasattr(asyncio,</span>
<span class="gd">-    &#39;WindowsSelectorEventLoopPolicy&#39;):</span>
<span class="gd">-    _BasePolicy = asyncio.WindowsSelectorEventLoopPolicy</span>
<span class="gi">+if sys.platform == &quot;win32&quot; and hasattr(asyncio, &quot;WindowsSelectorEventLoopPolicy&quot;):</span>
<span class="gi">+    # &quot;Any thread&quot; and &quot;selector&quot; should be orthogonal, but there&#39;s not a clean</span>
<span class="gi">+    # interface for composing policies so pick the right base.</span>
<span class="gi">+    _BasePolicy = asyncio.WindowsSelectorEventLoopPolicy  # type: ignore</span>
<span class="w"> </span>else:
<span class="w"> </span>    _BasePolicy = asyncio.DefaultEventLoopPolicy


<span class="gd">-class AnyThreadEventLoopPolicy(_BasePolicy):</span>
<span class="gi">+class AnyThreadEventLoopPolicy(_BasePolicy):  # type: ignore</span>
<span class="w"> </span>    &quot;&quot;&quot;Event loop policy that allows loop creation on any thread.

<span class="w"> </span>    The default `asyncio` event loop policy only automatically creates
<span class="gu">@@ -156,11 +416,23 @@ class AnyThreadEventLoopPolicy(_BasePolicy):</span>
<span class="w"> </span>        need event loops.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        warnings.warn(
<span class="gd">-            &#39;AnyThreadEventLoopPolicy is deprecated, use asyncio.run or asyncio.new_event_loop instead&#39;</span>
<span class="gd">-            , DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            &quot;AnyThreadEventLoopPolicy is deprecated, use asyncio.run &quot;</span>
<span class="gi">+            &quot;or asyncio.new_event_loop instead&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_event_loop(self) -&gt; asyncio.AbstractEventLoop:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return super().get_event_loop()</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            # &quot;There is no current event loop in thread %r&quot;</span>
<span class="gi">+            loop = self.new_event_loop()</span>
<span class="gi">+            self.set_event_loop(loop)</span>
<span class="gi">+            return loop</span>


<span class="w"> </span>class SelectorThread:
<span class="gu">@@ -173,29 +445,218 @@ class SelectorThread:</span>
<span class="w"> </span>    Typically used via ``AddThreadSelectorEventLoop``,
<span class="w"> </span>    but can be attached to a running asyncio loop.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _closed = False

<span class="gd">-    def __init__(self, real_loop: asyncio.AbstractEventLoop) -&gt;None:</span>
<span class="gi">+    def __init__(self, real_loop: asyncio.AbstractEventLoop) -&gt; None:</span>
<span class="w"> </span>        self._real_loop = real_loop
<span class="gi">+</span>
<span class="w"> </span>        self._select_cond = threading.Condition()
<span class="gd">-        self._select_args: Optional[Tuple[List[_FileDescriptorLike], List[</span>
<span class="gd">-            _FileDescriptorLike]]] = None</span>
<span class="gi">+        self._select_args: Optional[</span>
<span class="gi">+            Tuple[List[_FileDescriptorLike], List[_FileDescriptorLike]]</span>
<span class="gi">+        ] = None</span>
<span class="w"> </span>        self._closing_selector = False
<span class="w"> </span>        self._thread: Optional[threading.Thread] = None
<span class="w"> </span>        self._thread_manager_handle = self._thread_manager()

<span class="gd">-        async def thread_manager_anext() -&gt;None:</span>
<span class="gi">+        async def thread_manager_anext() -&gt; None:</span>
<span class="gi">+            # the anext builtin wasn&#39;t added until 3.10. We just need to iterate</span>
<span class="gi">+            # this generator one step.</span>
<span class="w"> </span>            await self._thread_manager_handle.__anext__()
<span class="gd">-        self._real_loop.call_soon(lambda : self._real_loop.create_task(</span>
<span class="gd">-            thread_manager_anext()))</span>
<span class="gi">+</span>
<span class="gi">+        # When the loop starts, start the thread. Not too soon because we can&#39;t</span>
<span class="gi">+        # clean up if we get to this point but the event loop is closed without</span>
<span class="gi">+        # starting.</span>
<span class="gi">+        self._real_loop.call_soon(</span>
<span class="gi">+            lambda: self._real_loop.create_task(thread_manager_anext())</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._readers: Dict[_FileDescriptorLike, Callable] = {}
<span class="w"> </span>        self._writers: Dict[_FileDescriptorLike, Callable] = {}
<span class="gi">+</span>
<span class="gi">+        # Writing to _waker_w will wake up the selector thread, which</span>
<span class="gi">+        # watches for _waker_r to be readable.</span>
<span class="w"> </span>        self._waker_r, self._waker_w = socket.socketpair()
<span class="w"> </span>        self._waker_r.setblocking(False)
<span class="w"> </span>        self._waker_w.setblocking(False)
<span class="w"> </span>        _selector_loops.add(self)
<span class="w"> </span>        self.add_reader(self._waker_r, self._consume_waker)

<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        with self._select_cond:</span>
<span class="gi">+            self._closing_selector = True</span>
<span class="gi">+            self._select_cond.notify()</span>
<span class="gi">+        self._wake_selector()</span>
<span class="gi">+        if self._thread is not None:</span>
<span class="gi">+            self._thread.join()</span>
<span class="gi">+        _selector_loops.discard(self)</span>
<span class="gi">+        self.remove_reader(self._waker_r)</span>
<span class="gi">+        self._waker_r.close()</span>
<span class="gi">+        self._waker_w.close()</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+</span>
<span class="gi">+    async def _thread_manager(self) -&gt; typing.AsyncGenerator[None, None]:</span>
<span class="gi">+        # Create a thread to run the select system call. We manage this thread</span>
<span class="gi">+        # manually so we can trigger a clean shutdown from an atexit hook. Note</span>
<span class="gi">+        # that due to the order of operations at shutdown, only daemon threads</span>
<span class="gi">+        # can be shut down in this way (non-daemon threads would require the</span>
<span class="gi">+        # introduction of a new hook: https://bugs.python.org/issue41962)</span>
<span class="gi">+        self._thread = threading.Thread(</span>
<span class="gi">+            name=&quot;Tornado selector&quot;,</span>
<span class="gi">+            daemon=True,</span>
<span class="gi">+            target=self._run_select,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._thread.start()</span>
<span class="gi">+        self._start_select()</span>
<span class="gi">+        try:</span>
<span class="gi">+            # The presense of this yield statement means that this coroutine</span>
<span class="gi">+            # is actually an asynchronous generator, which has a special</span>
<span class="gi">+            # shutdown protocol. We wait at this yield point until the</span>
<span class="gi">+            # event loop&#39;s shutdown_asyncgens method is called, at which point</span>
<span class="gi">+            # we will get a GeneratorExit exception and can shut down the</span>
<span class="gi">+            # selector thread.</span>
<span class="gi">+            yield</span>
<span class="gi">+        except GeneratorExit:</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _wake_selector(self) -&gt; None:</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._waker_w.send(b&quot;a&quot;)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_waker(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._waker_r.recv(1024)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def _start_select(self) -&gt; None:</span>
<span class="gi">+        # Capture reader and writer sets here in the event loop</span>
<span class="gi">+        # thread to avoid any problems with concurrent</span>
<span class="gi">+        # modification while the select loop uses them.</span>
<span class="gi">+        with self._select_cond:</span>
<span class="gi">+            assert self._select_args is None</span>
<span class="gi">+            self._select_args = (list(self._readers.keys()), list(self._writers.keys()))</span>
<span class="gi">+            self._select_cond.notify()</span>
<span class="gi">+</span>
<span class="gi">+    def _run_select(self) -&gt; None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            with self._select_cond:</span>
<span class="gi">+                while self._select_args is None and not self._closing_selector:</span>
<span class="gi">+                    self._select_cond.wait()</span>
<span class="gi">+                if self._closing_selector:</span>
<span class="gi">+                    return</span>
<span class="gi">+                assert self._select_args is not None</span>
<span class="gi">+                to_read, to_write = self._select_args</span>
<span class="gi">+                self._select_args = None</span>
<span class="gi">+</span>
<span class="gi">+            # We use the simpler interface of the select module instead of</span>
<span class="gi">+            # the more stateful interface in the selectors module because</span>
<span class="gi">+            # this class is only intended for use on windows, where</span>
<span class="gi">+            # select.select is the only option. The selector interface</span>
<span class="gi">+            # does not have well-documented thread-safety semantics that</span>
<span class="gi">+            # we can rely on so ensuring proper synchronization would be</span>
<span class="gi">+            # tricky.</span>
<span class="gi">+            try:</span>
<span class="gi">+                # On windows, selecting on a socket for write will not</span>
<span class="gi">+                # return the socket when there is an error (but selecting</span>
<span class="gi">+                # for reads works). Also select for errors when selecting</span>
<span class="gi">+                # for writes, and merge the results.</span>
<span class="gi">+                #</span>
<span class="gi">+                # This pattern is also used in</span>
<span class="gi">+                # https://github.com/python/cpython/blob/v3.8.0/Lib/selectors.py#L312-L317</span>
<span class="gi">+                rs, ws, xs = select.select(to_read, to_write, to_write)</span>
<span class="gi">+                ws = ws + xs</span>
<span class="gi">+            except OSError as e:</span>
<span class="gi">+                # After remove_reader or remove_writer is called, the file</span>
<span class="gi">+                # descriptor may subsequently be closed on the event loop</span>
<span class="gi">+                # thread. It&#39;s possible that this select thread hasn&#39;t</span>
<span class="gi">+                # gotten into the select system call by the time that</span>
<span class="gi">+                # happens in which case (at least on macOS), select may</span>
<span class="gi">+                # raise a &quot;bad file descriptor&quot; error. If we get that</span>
<span class="gi">+                # error, check and see if we&#39;re also being woken up by</span>
<span class="gi">+                # polling the waker alone. If we are, just return to the</span>
<span class="gi">+                # event loop and we&#39;ll get the updated set of file</span>
<span class="gi">+                # descriptors on the next iteration. Otherwise, raise the</span>
<span class="gi">+                # original error.</span>
<span class="gi">+                if e.errno == getattr(errno, &quot;WSAENOTSOCK&quot;, errno.EBADF):</span>
<span class="gi">+                    rs, _, _ = select.select([self._waker_r.fileno()], [], [], 0)</span>
<span class="gi">+                    if rs:</span>
<span class="gi">+                        ws = []</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._real_loop.call_soon_threadsafe(self._handle_select, rs, ws)</span>
<span class="gi">+            except RuntimeError:</span>
<span class="gi">+                # &quot;Event loop is closed&quot;. Swallow the exception for</span>
<span class="gi">+                # consistency with PollIOLoop (and logical consistency</span>
<span class="gi">+                # with the fact that we can&#39;t guarantee that an</span>
<span class="gi">+                # add_callback that completes without error will</span>
<span class="gi">+                # eventually execute).</span>
<span class="gi">+                pass</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                # ProactorEventLoop may raise this instead of RuntimeError</span>
<span class="gi">+                # if call_soon_threadsafe races with a call to close().</span>
<span class="gi">+                # Swallow it too for consistency.</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_select(</span>
<span class="gi">+        self, rs: List[_FileDescriptorLike], ws: List[_FileDescriptorLike]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for r in rs:</span>
<span class="gi">+            self._handle_event(r, self._readers)</span>
<span class="gi">+        for w in ws:</span>
<span class="gi">+            self._handle_event(w, self._writers)</span>
<span class="gi">+        self._start_select()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_event(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fd: _FileDescriptorLike,</span>
<span class="gi">+        cb_map: Dict[_FileDescriptorLike, Callable],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            callback = cb_map[fd]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return</span>
<span class="gi">+        callback()</span>
<span class="gi">+</span>
<span class="gi">+    def add_reader(</span>
<span class="gi">+        self, fd: _FileDescriptorLike, callback: Callable[..., None], *args: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._readers[fd] = functools.partial(callback, *args)</span>
<span class="gi">+        self._wake_selector()</span>
<span class="gi">+</span>
<span class="gi">+    def add_writer(</span>
<span class="gi">+        self, fd: _FileDescriptorLike, callback: Callable[..., None], *args: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._writers[fd] = functools.partial(callback, *args)</span>
<span class="gi">+        self._wake_selector()</span>
<span class="gi">+</span>
<span class="gi">+    def remove_reader(self, fd: _FileDescriptorLike) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._readers[fd]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        self._wake_selector()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def remove_writer(self, fd: _FileDescriptorLike) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._writers[fd]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        self._wake_selector()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class AddThreadSelectorEventLoop(asyncio.AbstractEventLoop):
<span class="w"> </span>    &quot;&quot;&quot;Wrap an event loop to add implementations of the ``add_reader`` method family.
<span class="gu">@@ -214,14 +675,44 @@ class AddThreadSelectorEventLoop(asyncio.AbstractEventLoop):</span>
<span class="w"> </span>    Closing the ``AddThreadSelectorEventLoop`` also closes the wrapped event loop.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    MY_ATTRIBUTES = {&#39;_real_loop&#39;, &#39;_selector&#39;, &#39;add_reader&#39;, &#39;add_writer&#39;,</span>
<span class="gd">-        &#39;close&#39;, &#39;remove_reader&#39;, &#39;remove_writer&#39;}</span>

<span class="gd">-    def __getattribute__(self, name: str) -&gt;Any:</span>
<span class="gi">+    # This class is a __getattribute__-based proxy. All attributes other than those</span>
<span class="gi">+    # in this set are proxied through to the underlying loop.</span>
<span class="gi">+    MY_ATTRIBUTES = {</span>
<span class="gi">+        &quot;_real_loop&quot;,</span>
<span class="gi">+        &quot;_selector&quot;,</span>
<span class="gi">+        &quot;add_reader&quot;,</span>
<span class="gi">+        &quot;add_writer&quot;,</span>
<span class="gi">+        &quot;close&quot;,</span>
<span class="gi">+        &quot;remove_reader&quot;,</span>
<span class="gi">+        &quot;remove_writer&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __getattribute__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        if name in AddThreadSelectorEventLoop.MY_ATTRIBUTES:
<span class="w"> </span>            return super().__getattribute__(name)
<span class="w"> </span>        return getattr(self._real_loop, name)

<span class="gd">-    def __init__(self, real_loop: asyncio.AbstractEventLoop) -&gt;None:</span>
<span class="gi">+    def __init__(self, real_loop: asyncio.AbstractEventLoop) -&gt; None:</span>
<span class="w"> </span>        self._real_loop = real_loop
<span class="w"> </span>        self._selector = SelectorThread(real_loop)
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self._selector.close()</span>
<span class="gi">+        self._real_loop.close()</span>
<span class="gi">+</span>
<span class="gi">+    def add_reader(</span>
<span class="gi">+        self, fd: &quot;_FileDescriptorLike&quot;, callback: Callable[..., None], *args: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        return self._selector.add_reader(fd, callback, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def add_writer(</span>
<span class="gi">+        self, fd: &quot;_FileDescriptorLike&quot;, callback: Callable[..., None], *args: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        return self._selector.add_writer(fd, callback, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_reader(self, fd: &quot;_FileDescriptorLike&quot;) -&gt; bool:</span>
<span class="gi">+        return self._selector.remove_reader(fd)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_writer(self, fd: &quot;_FileDescriptorLike&quot;) -&gt; bool:</span>
<span class="gi">+        return self._selector.remove_writer(fd)</span>
<span class="gh">diff --git a/tornado/platform/caresresolver.py b/tornado/platform/caresresolver.py</span>
<span class="gh">index 379ad0a2..1ba45c9a 100644</span>
<span class="gd">--- a/tornado/platform/caresresolver.py</span>
<span class="gi">+++ b/tornado/platform/caresresolver.py</span>
<span class="gu">@@ -1,12 +1,15 @@</span>
<span class="gd">-import pycares</span>
<span class="gi">+import pycares  # type: ignore</span>
<span class="w"> </span>import socket
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import Future
<span class="w"> </span>from tornado import gen
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.netutil import Resolver, is_valid_ip
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Generator, Any, List, Tuple, Dict</span>
<span class="gi">+    from typing import Generator, Any, List, Tuple, Dict  # noqa: F401</span>


<span class="w"> </span>class CaresResolver(Resolver):
<span class="gu">@@ -29,3 +32,63 @@ class CaresResolver(Resolver):</span>
<span class="w"> </span>       This class is deprecated and will be removed in Tornado 7.0. Use the default
<span class="w"> </span>       thread-based resolver instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def initialize(self) -&gt; None:</span>
<span class="gi">+        self.io_loop = IOLoop.current()</span>
<span class="gi">+        self.channel = pycares.Channel(sock_state_cb=self._sock_state_cb)</span>
<span class="gi">+        self.fds = {}  # type: Dict[int, int]</span>
<span class="gi">+</span>
<span class="gi">+    def _sock_state_cb(self, fd: int, readable: bool, writable: bool) -&gt; None:</span>
<span class="gi">+        state = (IOLoop.READ if readable else 0) | (IOLoop.WRITE if writable else 0)</span>
<span class="gi">+        if not state:</span>
<span class="gi">+            self.io_loop.remove_handler(fd)</span>
<span class="gi">+            del self.fds[fd]</span>
<span class="gi">+        elif fd in self.fds:</span>
<span class="gi">+            self.io_loop.update_handler(fd, state)</span>
<span class="gi">+            self.fds[fd] = state</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.io_loop.add_handler(fd, self._handle_events, state)</span>
<span class="gi">+            self.fds[fd] = state</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_events(self, fd: int, events: int) -&gt; None:</span>
<span class="gi">+        read_fd = pycares.ARES_SOCKET_BAD</span>
<span class="gi">+        write_fd = pycares.ARES_SOCKET_BAD</span>
<span class="gi">+        if events &amp; IOLoop.READ:</span>
<span class="gi">+            read_fd = fd</span>
<span class="gi">+        if events &amp; IOLoop.WRITE:</span>
<span class="gi">+            write_fd = fd</span>
<span class="gi">+        self.channel.process_fd(read_fd, write_fd)</span>
<span class="gi">+</span>
<span class="gi">+    @gen.coroutine</span>
<span class="gi">+    def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: int = 0</span>
<span class="gi">+    ) -&gt; &quot;Generator[Any, Any, List[Tuple[int, Any]]]&quot;:</span>
<span class="gi">+        if is_valid_ip(host):</span>
<span class="gi">+            addresses = [host]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # gethostbyname doesn&#39;t take callback as a kwarg</span>
<span class="gi">+            fut = Future()  # type: Future[Tuple[Any, Any]]</span>
<span class="gi">+            self.channel.gethostbyname(</span>
<span class="gi">+                host, family, lambda result, error: fut.set_result((result, error))</span>
<span class="gi">+            )</span>
<span class="gi">+            result, error = yield fut</span>
<span class="gi">+            if error:</span>
<span class="gi">+                raise IOError(</span>
<span class="gi">+                    &quot;C-Ares returned error %s: %s while resolving %s&quot;</span>
<span class="gi">+                    % (error, pycares.errno.strerror(error), host)</span>
<span class="gi">+                )</span>
<span class="gi">+            addresses = result.addresses</span>
<span class="gi">+        addrinfo = []</span>
<span class="gi">+        for address in addresses:</span>
<span class="gi">+            if &quot;.&quot; in address:</span>
<span class="gi">+                address_family = socket.AF_INET</span>
<span class="gi">+            elif &quot;:&quot; in address:</span>
<span class="gi">+                address_family = socket.AF_INET6</span>
<span class="gi">+            else:</span>
<span class="gi">+                address_family = socket.AF_UNSPEC</span>
<span class="gi">+            if family != socket.AF_UNSPEC and family != address_family:</span>
<span class="gi">+                raise IOError(</span>
<span class="gi">+                    &quot;Requested socket family %d but got %d&quot; % (family, address_family)</span>
<span class="gi">+                )</span>
<span class="gi">+            addrinfo.append((typing.cast(int, address_family), (address, port)))</span>
<span class="gi">+        return addrinfo</span>
<span class="gh">diff --git a/tornado/platform/twisted.py b/tornado/platform/twisted.py</span>
<span class="gh">index 4546b24f..153fe436 100644</span>
<span class="gd">--- a/tornado/platform/twisted.py</span>
<span class="gi">+++ b/tornado/platform/twisted.py</span>
<span class="gu">@@ -1,22 +1,39 @@</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="w"> </span>&quot;&quot;&quot;Bridges between the Twisted package and Tornado.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import sys
<span class="gd">-import twisted.internet.abstract</span>
<span class="gd">-import twisted.internet.asyncioreactor</span>
<span class="gd">-from twisted.internet.defer import Deferred</span>
<span class="gd">-from twisted.python import failure</span>
<span class="gd">-import twisted.names.cache</span>
<span class="gd">-import twisted.names.client</span>
<span class="gd">-import twisted.names.hosts</span>
<span class="gd">-import twisted.names.resolve</span>
<span class="gi">+</span>
<span class="gi">+import twisted.internet.abstract  # type: ignore</span>
<span class="gi">+import twisted.internet.asyncioreactor  # type: ignore</span>
<span class="gi">+from twisted.internet.defer import Deferred  # type: ignore</span>
<span class="gi">+from twisted.python import failure  # type: ignore</span>
<span class="gi">+import twisted.names.cache  # type: ignore</span>
<span class="gi">+import twisted.names.client  # type: ignore</span>
<span class="gi">+import twisted.names.hosts  # type: ignore</span>
<span class="gi">+import twisted.names.resolve  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import Future, future_set_exc_info
<span class="w"> </span>from tornado.escape import utf8
<span class="w"> </span>from tornado import gen
<span class="w"> </span>from tornado.netutil import Resolver
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Generator, Any, List, Tuple</span>
<span class="gi">+    from typing import Generator, Any, List, Tuple  # noqa: F401</span>


<span class="w"> </span>class TwistedResolver(Resolver):
<span class="gu">@@ -41,8 +58,57 @@ class TwistedResolver(Resolver):</span>
<span class="w"> </span>       thread-based resolver instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def initialize(self) -&gt; None:</span>
<span class="gi">+        # partial copy of twisted.names.client.createResolver, which doesn&#39;t</span>
<span class="gi">+        # allow for a reactor to be passed in.</span>
<span class="gi">+        self.reactor = twisted.internet.asyncioreactor.AsyncioSelectorReactor()</span>
<span class="gi">+</span>
<span class="gi">+        host_resolver = twisted.names.hosts.Resolver(&quot;/etc/hosts&quot;)</span>
<span class="gi">+        cache_resolver = twisted.names.cache.CacheResolver(reactor=self.reactor)</span>
<span class="gi">+        real_resolver = twisted.names.client.Resolver(</span>
<span class="gi">+            &quot;/etc/resolv.conf&quot;, reactor=self.reactor</span>
<span class="gi">+        )</span>
<span class="gi">+        self.resolver = twisted.names.resolve.ResolverChain(</span>
<span class="gi">+            [host_resolver, cache_resolver, real_resolver]</span>
<span class="gi">+        )</span>

<span class="gd">-def install() -&gt;None:</span>
<span class="gi">+    @gen.coroutine</span>
<span class="gi">+    def resolve(</span>
<span class="gi">+        self, host: str, port: int, family: int = 0</span>
<span class="gi">+    ) -&gt; &quot;Generator[Any, Any, List[Tuple[int, Any]]]&quot;:</span>
<span class="gi">+        # getHostByName doesn&#39;t accept IP addresses, so if the input</span>
<span class="gi">+        # looks like an IP address just return it immediately.</span>
<span class="gi">+        if twisted.internet.abstract.isIPAddress(host):</span>
<span class="gi">+            resolved = host</span>
<span class="gi">+            resolved_family = socket.AF_INET</span>
<span class="gi">+        elif twisted.internet.abstract.isIPv6Address(host):</span>
<span class="gi">+            resolved = host</span>
<span class="gi">+            resolved_family = socket.AF_INET6</span>
<span class="gi">+        else:</span>
<span class="gi">+            deferred = self.resolver.getHostByName(utf8(host))</span>
<span class="gi">+            fut = Future()  # type: Future[Any]</span>
<span class="gi">+            deferred.addBoth(fut.set_result)</span>
<span class="gi">+            resolved = yield fut</span>
<span class="gi">+            if isinstance(resolved, failure.Failure):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    resolved.raiseException()</span>
<span class="gi">+                except twisted.names.error.DomainError as e:</span>
<span class="gi">+                    raise IOError(e)</span>
<span class="gi">+            elif twisted.internet.abstract.isIPAddress(resolved):</span>
<span class="gi">+                resolved_family = socket.AF_INET</span>
<span class="gi">+            elif twisted.internet.abstract.isIPv6Address(resolved):</span>
<span class="gi">+                resolved_family = socket.AF_INET6</span>
<span class="gi">+            else:</span>
<span class="gi">+                resolved_family = socket.AF_UNSPEC</span>
<span class="gi">+        if family != socket.AF_UNSPEC and family != resolved_family:</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                &quot;Requested socket family %d but got %d&quot; % (family, resolved_family)</span>
<span class="gi">+            )</span>
<span class="gi">+        result = [(typing.cast(int, resolved_family), (resolved, port))]</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def install() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Install ``AsyncioSelectorReactor`` as the default Twisted reactor.

<span class="w"> </span>    .. deprecated:: 5.1
<span class="gu">@@ -61,7 +127,24 @@ def install() -&gt;None:</span>
<span class="w"> </span>       ``asyncio`` reactor instead.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from twisted.internet.asyncioreactor import install</span>
<span class="gi">+</span>
<span class="gi">+    install()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if hasattr(gen.convert_yielded, &quot;register&quot;):</span>
<span class="gi">+</span>
<span class="gi">+    @gen.convert_yielded.register(Deferred)  # type: ignore</span>
<span class="gi">+    def _(d: Deferred) -&gt; Future:</span>
<span class="gi">+        f = Future()  # type: Future[Any]</span>

<span class="gi">+        def errback(failure: failure.Failure) -&gt; None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                failure.raiseException()</span>
<span class="gi">+                # Should never happen, but just in case</span>
<span class="gi">+                raise Exception(&quot;errback called without error&quot;)</span>
<span class="gi">+            except:</span>
<span class="gi">+                future_set_exc_info(f, sys.exc_info())</span>

<span class="gd">-if hasattr(gen.convert_yielded, &#39;register&#39;):</span>
<span class="gi">+        d.addCallbacks(f.set_result, errback)</span>
<span class="gi">+        return f</span>
<span class="gh">diff --git a/tornado/process.py b/tornado/process.py</span>
<span class="gh">index 3afe7dc4..12e3eb64 100644</span>
<span class="gd">--- a/tornado/process.py</span>
<span class="gi">+++ b/tornado/process.py</span>
<span class="gu">@@ -1,6 +1,22 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2011 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for working with multiple processes, including both forking
<span class="w"> </span>the server into multiple processes and managing subprocesses.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import os
<span class="w"> </span>import multiprocessing
<span class="gu">@@ -8,28 +24,65 @@ import signal</span>
<span class="w"> </span>import subprocess
<span class="w"> </span>import sys
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>from binascii import hexlify
<span class="gd">-from tornado.concurrent import Future, future_set_result_unless_cancelled, future_set_exception_unless_cancelled</span>
<span class="gi">+</span>
<span class="gi">+from tornado.concurrent import (</span>
<span class="gi">+    Future,</span>
<span class="gi">+    future_set_result_unless_cancelled,</span>
<span class="gi">+    future_set_exception_unless_cancelled,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado import ioloop
<span class="w"> </span>from tornado.iostream import PipeIOStream
<span class="w"> </span>from tornado.log import gen_log
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Optional, Any, Callable
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import List</span>
<span class="gi">+    from typing import List  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+# Re-export this exception for convenience.</span>
<span class="w"> </span>CalledProcessError = subprocess.CalledProcessError


<span class="gd">-def cpu_count() -&gt;int:</span>
<span class="gi">+def cpu_count() -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the number of processors on this machine.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if multiprocessing is None:</span>
<span class="gi">+        return 1</span>
<span class="gi">+    try:</span>
<span class="gi">+        return multiprocessing.cpu_count()</span>
<span class="gi">+    except NotImplementedError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return os.sysconf(&quot;SC_NPROCESSORS_CONF&quot;)  # type: ignore</span>
<span class="gi">+    except (AttributeError, ValueError):</span>
<span class="gi">+        pass</span>
<span class="gi">+    gen_log.error(&quot;Could not detect number of processors; assuming 1&quot;)</span>
<span class="gi">+    return 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _reseed_random() -&gt; None:</span>
<span class="gi">+    if &quot;random&quot; not in sys.modules:</span>
<span class="gi">+        return</span>
<span class="gi">+    import random</span>
<span class="gi">+</span>
<span class="gi">+    # If os.urandom is available, this method does the same thing as</span>
<span class="gi">+    # random.seed (at least as of python 2.6).  If os.urandom is not</span>
<span class="gi">+    # available, we mix in the pid in addition to a timestamp.</span>
<span class="gi">+    try:</span>
<span class="gi">+        seed = int(hexlify(os.urandom(16)), 16)</span>
<span class="gi">+    except NotImplementedError:</span>
<span class="gi">+        seed = int(time.time() * 1000) ^ os.getpid()</span>
<span class="gi">+    random.seed(seed)</span>


<span class="w"> </span>_task_id = None


<span class="gd">-def fork_processes(num_processes: Optional[int], max_restarts: Optional[int</span>
<span class="gd">-    ]=None) -&gt;int:</span>
<span class="gi">+def fork_processes(</span>
<span class="gi">+    num_processes: Optional[int], max_restarts: Optional[int] = None</span>
<span class="gi">+) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Starts multiple worker processes.

<span class="w"> </span>    If ``num_processes`` is None or &lt;= 0, we detect the number of cores
<span class="gu">@@ -57,15 +110,79 @@ def fork_processes(num_processes: Optional[int], max_restarts: Optional[int</span>

<span class="w"> </span>    Availability: Unix
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def task_id() -&gt;Optional[int]:</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        # The exact form of this condition matters to mypy; it understands</span>
<span class="gi">+        # if but not assert in this context.</span>
<span class="gi">+        raise Exception(&quot;fork not available on windows&quot;)</span>
<span class="gi">+    if max_restarts is None:</span>
<span class="gi">+        max_restarts = 100</span>
<span class="gi">+</span>
<span class="gi">+    global _task_id</span>
<span class="gi">+    assert _task_id is None</span>
<span class="gi">+    if num_processes is None or num_processes &lt;= 0:</span>
<span class="gi">+        num_processes = cpu_count()</span>
<span class="gi">+    gen_log.info(&quot;Starting %d processes&quot;, num_processes)</span>
<span class="gi">+    children = {}</span>
<span class="gi">+</span>
<span class="gi">+    def start_child(i: int) -&gt; Optional[int]:</span>
<span class="gi">+        pid = os.fork()</span>
<span class="gi">+        if pid == 0:</span>
<span class="gi">+            # child process</span>
<span class="gi">+            _reseed_random()</span>
<span class="gi">+            global _task_id</span>
<span class="gi">+            _task_id = i</span>
<span class="gi">+            return i</span>
<span class="gi">+        else:</span>
<span class="gi">+            children[pid] = i</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(num_processes):</span>
<span class="gi">+        id = start_child(i)</span>
<span class="gi">+        if id is not None:</span>
<span class="gi">+            return id</span>
<span class="gi">+    num_restarts = 0</span>
<span class="gi">+    while children:</span>
<span class="gi">+        pid, status = os.wait()</span>
<span class="gi">+        if pid not in children:</span>
<span class="gi">+            continue</span>
<span class="gi">+        id = children.pop(pid)</span>
<span class="gi">+        if os.WIFSIGNALED(status):</span>
<span class="gi">+            gen_log.warning(</span>
<span class="gi">+                &quot;child %d (pid %d) killed by signal %d, restarting&quot;,</span>
<span class="gi">+                id,</span>
<span class="gi">+                pid,</span>
<span class="gi">+                os.WTERMSIG(status),</span>
<span class="gi">+            )</span>
<span class="gi">+        elif os.WEXITSTATUS(status) != 0:</span>
<span class="gi">+            gen_log.warning(</span>
<span class="gi">+                &quot;child %d (pid %d) exited with status %d, restarting&quot;,</span>
<span class="gi">+                id,</span>
<span class="gi">+                pid,</span>
<span class="gi">+                os.WEXITSTATUS(status),</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            gen_log.info(&quot;child %d (pid %d) exited normally&quot;, id, pid)</span>
<span class="gi">+            continue</span>
<span class="gi">+        num_restarts += 1</span>
<span class="gi">+        if num_restarts &gt; max_restarts:</span>
<span class="gi">+            raise RuntimeError(&quot;Too many child restarts, giving up&quot;)</span>
<span class="gi">+        new_id = start_child(id)</span>
<span class="gi">+        if new_id is not None:</span>
<span class="gi">+            return new_id</span>
<span class="gi">+    # All child processes exited cleanly, so exit the master process</span>
<span class="gi">+    # instead of just returning to right after the call to</span>
<span class="gi">+    # fork_processes (which will probably just start up another IOLoop</span>
<span class="gi">+    # unless the caller checks the return value).</span>
<span class="gi">+    sys.exit(0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def task_id() -&gt; Optional[int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the current task id, if any.

<span class="w"> </span>    Returns None if this process was not created by `fork_processes`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _task_id</span>
<span class="gi">+    return _task_id</span>


<span class="w"> </span>class Subprocess(object):
<span class="gu">@@ -89,29 +206,33 @@ class Subprocess(object):</span>
<span class="w"> </span>       The ``io_loop`` argument (deprecated since version 4.1) has been removed.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    STREAM = object()
<span class="gi">+</span>
<span class="w"> </span>    _initialized = False
<span class="gd">-    _waiting = {}</span>
<span class="gi">+    _waiting = {}  # type: ignore</span>

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.io_loop = ioloop.IOLoop.current()
<span class="gd">-        pipe_fds = []</span>
<span class="gd">-        to_close = []</span>
<span class="gd">-        if kwargs.get(&#39;stdin&#39;) is Subprocess.STREAM:</span>
<span class="gi">+        # All FDs we create should be closed on error; those in to_close</span>
<span class="gi">+        # should be closed in the parent process on success.</span>
<span class="gi">+        pipe_fds = []  # type: List[int]</span>
<span class="gi">+        to_close = []  # type: List[int]</span>
<span class="gi">+        if kwargs.get(&quot;stdin&quot;) is Subprocess.STREAM:</span>
<span class="w"> </span>            in_r, in_w = os.pipe()
<span class="gd">-            kwargs[&#39;stdin&#39;] = in_r</span>
<span class="gi">+            kwargs[&quot;stdin&quot;] = in_r</span>
<span class="w"> </span>            pipe_fds.extend((in_r, in_w))
<span class="w"> </span>            to_close.append(in_r)
<span class="w"> </span>            self.stdin = PipeIOStream(in_w)
<span class="gd">-        if kwargs.get(&#39;stdout&#39;) is Subprocess.STREAM:</span>
<span class="gi">+        if kwargs.get(&quot;stdout&quot;) is Subprocess.STREAM:</span>
<span class="w"> </span>            out_r, out_w = os.pipe()
<span class="gd">-            kwargs[&#39;stdout&#39;] = out_w</span>
<span class="gi">+            kwargs[&quot;stdout&quot;] = out_w</span>
<span class="w"> </span>            pipe_fds.extend((out_r, out_w))
<span class="w"> </span>            to_close.append(out_w)
<span class="w"> </span>            self.stdout = PipeIOStream(out_r)
<span class="gd">-        if kwargs.get(&#39;stderr&#39;) is Subprocess.STREAM:</span>
<span class="gi">+        if kwargs.get(&quot;stderr&quot;) is Subprocess.STREAM:</span>
<span class="w"> </span>            err_r, err_w = os.pipe()
<span class="gd">-            kwargs[&#39;stderr&#39;] = err_w</span>
<span class="gi">+            kwargs[&quot;stderr&quot;] = err_w</span>
<span class="w"> </span>            pipe_fds.extend((err_r, err_w))
<span class="w"> </span>            to_close.append(err_w)
<span class="w"> </span>            self.stderr = PipeIOStream(err_r)
<span class="gu">@@ -124,13 +245,13 @@ class Subprocess(object):</span>
<span class="w"> </span>        for fd in to_close:
<span class="w"> </span>            os.close(fd)
<span class="w"> </span>        self.pid = self.proc.pid
<span class="gd">-        for attr in [&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]:</span>
<span class="gd">-            if not hasattr(self, attr):</span>
<span class="gi">+        for attr in [&quot;stdin&quot;, &quot;stdout&quot;, &quot;stderr&quot;]:</span>
<span class="gi">+            if not hasattr(self, attr):  # don&#39;t clobber streams set above</span>
<span class="w"> </span>                setattr(self, attr, getattr(self.proc, attr))
<span class="gd">-        self._exit_callback = None</span>
<span class="gd">-        self.returncode = None</span>
<span class="gi">+        self._exit_callback = None  # type: Optional[Callable[[int], None]]</span>
<span class="gi">+        self.returncode = None  # type: Optional[int]</span>

<span class="gd">-    def set_exit_callback(self, callback: Callable[[int], None]) -&gt;None:</span>
<span class="gi">+    def set_exit_callback(self, callback: Callable[[int], None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs ``callback`` when this process exits.

<span class="w"> </span>        The callback takes one argument, the return code of the process.
<span class="gu">@@ -147,9 +268,12 @@ class Subprocess(object):</span>

<span class="w"> </span>        Availability: Unix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._exit_callback = callback</span>
<span class="gi">+        Subprocess.initialize()</span>
<span class="gi">+        Subprocess._waiting[self.pid] = self</span>
<span class="gi">+        Subprocess._try_cleanup_process(self.pid)</span>

<span class="gd">-    def wait_for_exit(self, raise_error: bool=True) -&gt;&#39;Future[int]&#39;:</span>
<span class="gi">+    def wait_for_exit(self, raise_error: bool = True) -&gt; &quot;Future[int]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a `.Future` which resolves when the process exits.

<span class="w"> </span>        Usage::
<span class="gu">@@ -167,10 +291,22 @@ class Subprocess(object):</span>

<span class="w"> </span>        Availability: Unix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        future = Future()  # type: Future[int]</span>
<span class="gi">+</span>
<span class="gi">+        def callback(ret: int) -&gt; None:</span>
<span class="gi">+            if ret != 0 and raise_error:</span>
<span class="gi">+                # Unfortunately we don&#39;t have the original args any more.</span>
<span class="gi">+                future_set_exception_unless_cancelled(</span>
<span class="gi">+                    future, CalledProcessError(ret, &quot;unknown&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                future_set_result_unless_cancelled(future, ret)</span>
<span class="gi">+</span>
<span class="gi">+        self.set_exit_callback(callback)</span>
<span class="gi">+        return future</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def initialize(cls) -&gt;None:</span>
<span class="gi">+    def initialize(cls) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initializes the ``SIGCHLD`` handler.

<span class="w"> </span>        The signal handler is run on an `.IOLoop` to avoid locking issues.
<span class="gu">@@ -184,9 +320,52 @@ class Subprocess(object):</span>

<span class="w"> </span>        Availability: Unix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls._initialized:</span>
<span class="gi">+            return</span>
<span class="gi">+        loop = asyncio.get_event_loop()</span>
<span class="gi">+        loop.add_signal_handler(signal.SIGCHLD, cls._cleanup)</span>
<span class="gi">+        cls._initialized = True</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def uninitialize(cls) -&gt;None:</span>
<span class="gi">+    def uninitialize(cls) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Removes the ``SIGCHLD`` handler.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not cls._initialized:</span>
<span class="gi">+            return</span>
<span class="gi">+        loop = asyncio.get_event_loop()</span>
<span class="gi">+        loop.remove_signal_handler(signal.SIGCHLD)</span>
<span class="gi">+        cls._initialized = False</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _cleanup(cls) -&gt; None:</span>
<span class="gi">+        for pid in list(cls._waiting.keys()):  # make a copy</span>
<span class="gi">+            cls._try_cleanup_process(pid)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _try_cleanup_process(cls, pid: int) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            ret_pid, status = os.waitpid(pid, os.WNOHANG)  # type: ignore</span>
<span class="gi">+        except ChildProcessError:</span>
<span class="gi">+            return</span>
<span class="gi">+        if ret_pid == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        assert ret_pid == pid</span>
<span class="gi">+        subproc = cls._waiting.pop(pid)</span>
<span class="gi">+        subproc.io_loop.add_callback(subproc._set_returncode, status)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_returncode(self, status: int) -&gt; None:</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            self.returncode = -1</span>
<span class="gi">+        else:</span>
<span class="gi">+            if os.WIFSIGNALED(status):</span>
<span class="gi">+                self.returncode = -os.WTERMSIG(status)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert os.WIFEXITED(status)</span>
<span class="gi">+                self.returncode = os.WEXITSTATUS(status)</span>
<span class="gi">+        # We&#39;ve taken over wait() duty from the subprocess.Popen</span>
<span class="gi">+        # object. If we don&#39;t inform it of the process&#39;s return code,</span>
<span class="gi">+        # it will log a warning at destruction in python 3.6+.</span>
<span class="gi">+        self.proc.returncode = self.returncode</span>
<span class="gi">+        if self._exit_callback:</span>
<span class="gi">+            callback = self._exit_callback</span>
<span class="gi">+            self._exit_callback = None</span>
<span class="gi">+            callback(self.returncode)</span>
<span class="gh">diff --git a/tornado/queues.py b/tornado/queues.py</span>
<span class="gh">index fde4734a..1358d0ec 100644</span>
<span class="gd">--- a/tornado/queues.py</span>
<span class="gi">+++ b/tornado/queues.py</span>
<span class="gu">@@ -1,3 +1,17 @@</span>
<span class="gi">+# Copyright 2015 The Tornado Authors</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Asynchronous queues for coroutines. These classes are very similar
<span class="w"> </span>to those provided in the standard library&#39;s `asyncio package
<span class="w"> </span>&lt;https://docs.python.org/3/library/asyncio-queue.html&gt;`_.
<span class="gu">@@ -10,36 +24,57 @@ to those provided in the standard library&#39;s `asyncio package</span>
<span class="w"> </span>   before calling any queue methods.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import datetime
<span class="w"> </span>import heapq
<span class="gi">+</span>
<span class="w"> </span>from tornado import gen, ioloop
<span class="w"> </span>from tornado.concurrent import Future, future_set_result_unless_cancelled
<span class="w"> </span>from tornado.locks import Event
<span class="gi">+</span>
<span class="w"> </span>from typing import Union, TypeVar, Generic, Awaitable, Optional
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Deque, Tuple, Any</span>
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gd">-__all__ = [&#39;Queue&#39;, &#39;PriorityQueue&#39;, &#39;LifoQueue&#39;, &#39;QueueFull&#39;, &#39;QueueEmpty&#39;]</span>
<span class="gi">+    from typing import Deque, Tuple, Any  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;Queue&quot;, &quot;PriorityQueue&quot;, &quot;LifoQueue&quot;, &quot;QueueFull&quot;, &quot;QueueEmpty&quot;]</span>


<span class="w"> </span>class QueueEmpty(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised by `.Queue.get_nowait` when the queue has no items.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class QueueFull(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised by `.Queue.put_nowait` when a queue is at its maximum size.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gd">-class _QueueIterator(Generic[_T]):</span>
<span class="gi">+def _set_timeout(</span>
<span class="gi">+    future: Future, timeout: Union[None, float, datetime.timedelta]</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    if timeout:</span>

<span class="gd">-    def __init__(self, q: &#39;Queue[_T]&#39;) -&gt;None:</span>
<span class="gi">+        def on_timeout() -&gt; None:</span>
<span class="gi">+            if not future.done():</span>
<span class="gi">+                future.set_exception(gen.TimeoutError())</span>
<span class="gi">+</span>
<span class="gi">+        io_loop = ioloop.IOLoop.current()</span>
<span class="gi">+        timeout_handle = io_loop.add_timeout(timeout, on_timeout)</span>
<span class="gi">+        future.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _QueueIterator(Generic[_T]):</span>
<span class="gi">+    def __init__(self, q: &quot;Queue[_T]&quot;) -&gt; None:</span>
<span class="w"> </span>        self.q = q

<span class="gd">-    def __anext__(self) -&gt;Awaitable[_T]:</span>
<span class="gi">+    def __anext__(self) -&gt; Awaitable[_T]:</span>
<span class="w"> </span>        return self.q.get()


<span class="gu">@@ -110,32 +145,47 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>       Added ``async for`` support in Python 3.5.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _queue = None</span>

<span class="gd">-    def __init__(self, maxsize: int=0) -&gt;None:</span>
<span class="gi">+    # Exact type depends on subclass. Could be another generic</span>
<span class="gi">+    # parameter and use protocols to be more precise here.</span>
<span class="gi">+    _queue = None  # type: Any</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, maxsize: int = 0) -&gt; None:</span>
<span class="w"> </span>        if maxsize is None:
<span class="w"> </span>            raise TypeError(&quot;maxsize can&#39;t be None&quot;)
<span class="gi">+</span>
<span class="w"> </span>        if maxsize &lt; 0:
<span class="w"> </span>            raise ValueError(&quot;maxsize can&#39;t be negative&quot;)
<span class="gi">+</span>
<span class="w"> </span>        self._maxsize = maxsize
<span class="w"> </span>        self._init()
<span class="gd">-        self._getters = collections.deque([])</span>
<span class="gd">-        self._putters = collections.deque([])</span>
<span class="gi">+        self._getters = collections.deque([])  # type: Deque[Future[_T]]</span>
<span class="gi">+        self._putters = collections.deque([])  # type: Deque[Tuple[_T, Future[None]]]</span>
<span class="w"> </span>        self._unfinished_tasks = 0
<span class="w"> </span>        self._finished = Event()
<span class="w"> </span>        self._finished.set()

<span class="w"> </span>    @property
<span class="gd">-    def maxsize(self) -&gt;int:</span>
<span class="gi">+    def maxsize(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of items allowed in the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._maxsize</span>

<span class="gd">-    def qsize(self) -&gt;int:</span>
<span class="gi">+    def qsize(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of items in the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._queue)</span>
<span class="gi">+</span>
<span class="gi">+    def empty(self) -&gt; bool:</span>
<span class="gi">+        return not self._queue</span>
<span class="gi">+</span>
<span class="gi">+    def full(self) -&gt; bool:</span>
<span class="gi">+        if self.maxsize == 0:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.qsize() &gt;= self.maxsize</span>

<span class="gd">-    def put(self, item: _T, timeout: Optional[Union[float, datetime.</span>
<span class="gd">-        timedelta]]=None) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    def put(</span>
<span class="gi">+        self, item: _T, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Put an item into the queue, perhaps waiting until there is room.

<span class="w"> </span>        Returns a Future, which raises `tornado.util.TimeoutError` after a
<span class="gu">@@ -146,17 +196,35 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>        `datetime.timedelta` object for a deadline relative to the
<span class="w"> </span>        current time.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def put_nowait(self, item: _T) -&gt;None:</span>
<span class="gi">+        future = Future()  # type: Future[None]</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.put_nowait(item)</span>
<span class="gi">+        except QueueFull:</span>
<span class="gi">+            self._putters.append((item, future))</span>
<span class="gi">+            _set_timeout(future, timeout)</span>
<span class="gi">+        else:</span>
<span class="gi">+            future.set_result(None)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def put_nowait(self, item: _T) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Put an item into the queue without blocking.

<span class="w"> </span>        If no free slot is immediately available, raise `QueueFull`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get(self, timeout: Optional[Union[float, datetime.timedelta]]=None</span>
<span class="gd">-        ) -&gt;Awaitable[_T]:</span>
<span class="gi">+        self._consume_expired()</span>
<span class="gi">+        if self._getters:</span>
<span class="gi">+            assert self.empty(), &quot;queue non-empty, why are getters waiting?&quot;</span>
<span class="gi">+            getter = self._getters.popleft()</span>
<span class="gi">+            self.__put_internal(item)</span>
<span class="gi">+            future_set_result_unless_cancelled(getter, self._get())</span>
<span class="gi">+        elif self.full():</span>
<span class="gi">+            raise QueueFull</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.__put_internal(item)</span>
<span class="gi">+</span>
<span class="gi">+    def get(</span>
<span class="gi">+        self, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; Awaitable[_T]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove and return an item from the queue.

<span class="w"> </span>        Returns an awaitable which resolves once an item is available, or raises
<span class="gu">@@ -177,17 +245,33 @@ class Queue(Generic[_T]):</span>
<span class="w"> </span>           with other timeouts in Tornado).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_nowait(self) -&gt;_T:</span>
<span class="gi">+        future = Future()  # type: Future[_T]</span>
<span class="gi">+        try:</span>
<span class="gi">+            future.set_result(self.get_nowait())</span>
<span class="gi">+        except QueueEmpty:</span>
<span class="gi">+            self._getters.append(future)</span>
<span class="gi">+            _set_timeout(future, timeout)</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def get_nowait(self) -&gt; _T:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove and return an item from the queue without blocking.

<span class="w"> </span>        Return an item if one is immediately available, else raise
<span class="w"> </span>        `QueueEmpty`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def task_done(self) -&gt;None:</span>
<span class="gi">+        self._consume_expired()</span>
<span class="gi">+        if self._putters:</span>
<span class="gi">+            assert self.full(), &quot;queue not full, why are putters waiting?&quot;</span>
<span class="gi">+            item, putter = self._putters.popleft()</span>
<span class="gi">+            self.__put_internal(item)</span>
<span class="gi">+            future_set_result_unless_cancelled(putter, None)</span>
<span class="gi">+            return self._get()</span>
<span class="gi">+        elif self.qsize():</span>
<span class="gi">+            return self._get()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise QueueEmpty</span>
<span class="gi">+</span>
<span class="gi">+    def task_done(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Indicate that a formerly enqueued task is complete.

<span class="w"> </span>        Used by queue consumers. For each `.get` used to fetch a task, a
<span class="gu">@@ -199,26 +283,67 @@ class Queue(Generic[_T]):</span>

<span class="w"> </span>        Raises `ValueError` if called more times than `.put`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def join(self, timeout: Optional[Union[float, datetime.timedelta]]=None</span>
<span class="gd">-        ) -&gt;Awaitable[None]:</span>
<span class="gi">+        if self._unfinished_tasks &lt;= 0:</span>
<span class="gi">+            raise ValueError(&quot;task_done() called too many times&quot;)</span>
<span class="gi">+        self._unfinished_tasks -= 1</span>
<span class="gi">+        if self._unfinished_tasks == 0:</span>
<span class="gi">+            self._finished.set()</span>
<span class="gi">+</span>
<span class="gi">+    def join(</span>
<span class="gi">+        self, timeout: Optional[Union[float, datetime.timedelta]] = None</span>
<span class="gi">+    ) -&gt; Awaitable[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Block until all items in the queue are processed.

<span class="w"> </span>        Returns an awaitable, which raises `tornado.util.TimeoutError` after a
<span class="w"> </span>        timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._finished.wait(timeout)</span>

<span class="gd">-    def __aiter__(self) -&gt;_QueueIterator[_T]:</span>
<span class="gi">+    def __aiter__(self) -&gt; _QueueIterator[_T]:</span>
<span class="w"> </span>        return _QueueIterator(self)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;&lt;%s at %s %s&gt;&#39; % (type(self).__name__, hex(id(self)), self.</span>
<span class="gd">-            _format())</span>
<span class="gi">+    # These three are overridable in subclasses.</span>
<span class="gi">+    def _init(self) -&gt; None:</span>
<span class="gi">+        self._queue = collections.deque()</span>
<span class="gi">+</span>
<span class="gi">+    def _get(self) -&gt; _T:</span>
<span class="gi">+        return self._queue.popleft()</span>
<span class="gi">+</span>
<span class="gi">+    def _put(self, item: _T) -&gt; None:</span>
<span class="gi">+        self._queue.append(item)</span>
<span class="gi">+</span>
<span class="gi">+    # End of the overridable methods.</span>
<span class="gi">+</span>
<span class="gi">+    def __put_internal(self, item: _T) -&gt; None:</span>
<span class="gi">+        self._unfinished_tasks += 1</span>
<span class="gi">+        self._finished.clear()</span>
<span class="gi">+        self._put(item)</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_expired(self) -&gt; None:</span>
<span class="gi">+        # Remove timed-out waiters.</span>
<span class="gi">+        while self._putters and self._putters[0][1].done():</span>
<span class="gi">+            self._putters.popleft()</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;&lt;%s %s&gt;&#39; % (type(self).__name__, self._format())</span>
<span class="gi">+        while self._getters and self._getters[0].done():</span>
<span class="gi">+            self._getters.popleft()</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;&lt;%s at %s %s&gt;&quot; % (type(self).__name__, hex(id(self)), self._format())</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;&lt;%s %s&gt;&quot; % (type(self).__name__, self._format())</span>
<span class="gi">+</span>
<span class="gi">+    def _format(self) -&gt; str:</span>
<span class="gi">+        result = &quot;maxsize=%r&quot; % (self.maxsize,)</span>
<span class="gi">+        if getattr(self, &quot;_queue&quot;, None):</span>
<span class="gi">+            result += &quot; queue=%r&quot; % self._queue</span>
<span class="gi">+        if self._getters:</span>
<span class="gi">+            result += &quot; getters[%s]&quot; % len(self._getters)</span>
<span class="gi">+        if self._putters:</span>
<span class="gi">+            result += &quot; putters[%s]&quot; % len(self._putters)</span>
<span class="gi">+        if self._unfinished_tasks:</span>
<span class="gi">+            result += &quot; tasks=%s&quot; % self._unfinished_tasks</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class PriorityQueue(Queue):
<span class="gu">@@ -250,6 +375,15 @@ class PriorityQueue(Queue):</span>
<span class="w"> </span>        (10, &#39;low-priority item&#39;)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _init(self) -&gt; None:</span>
<span class="gi">+        self._queue = []</span>
<span class="gi">+</span>
<span class="gi">+    def _put(self, item: _T) -&gt; None:</span>
<span class="gi">+        heapq.heappush(self._queue, item)</span>
<span class="gi">+</span>
<span class="gi">+    def _get(self) -&gt; _T:  # type: ignore[type-var]</span>
<span class="gi">+        return heapq.heappop(self._queue)</span>
<span class="gi">+</span>

<span class="w"> </span>class LifoQueue(Queue):
<span class="w"> </span>    &quot;&quot;&quot;A `.Queue` that retrieves the most recently put items first.
<span class="gu">@@ -277,3 +411,12 @@ class LifoQueue(Queue):</span>
<span class="w"> </span>        2
<span class="w"> </span>        3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _init(self) -&gt; None:</span>
<span class="gi">+        self._queue = []</span>
<span class="gi">+</span>
<span class="gi">+    def _put(self, item: _T) -&gt; None:</span>
<span class="gi">+        self._queue.append(item)</span>
<span class="gi">+</span>
<span class="gi">+    def _get(self) -&gt; _T:  # type: ignore[type-var]</span>
<span class="gi">+        return self._queue.pop()</span>
<span class="gh">diff --git a/tornado/routing.py b/tornado/routing.py</span>
<span class="gh">index 111cbaaa..a145d719 100644</span>
<span class="gd">--- a/tornado/routing.py</span>
<span class="gi">+++ b/tornado/routing.py</span>
<span class="gu">@@ -1,3 +1,17 @@</span>
<span class="gi">+# Copyright 2015 The Tornado Authors</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Flexible routing implementation.

<span class="w"> </span>Tornado routes HTTP requests to appropriate handlers using `Router`
<span class="gu">@@ -160,21 +174,25 @@ For more information on application-level routing see docs for `~.web.Applicatio</span>
<span class="w"> </span>.. versionadded:: 4.5

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>from tornado import httputil
<span class="w"> </span>from tornado.httpserver import _CallableAdapter
<span class="w"> </span>from tornado.escape import url_escape, url_unescape, utf8
<span class="w"> </span>from tornado.log import app_log
<span class="w"> </span>from tornado.util import basestring_type, import_object, re_unescape, unicode_type
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Union, Optional, Awaitable, List, Dict, Pattern, Tuple, overload


<span class="w"> </span>class Router(httputil.HTTPServerConnectionDelegate):
<span class="w"> </span>    &quot;&quot;&quot;Abstract router interface.&quot;&quot;&quot;

<span class="gd">-    def find_handler(self, request: httputil.HTTPServerRequest, **kwargs: Any</span>
<span class="gd">-        ) -&gt;Optional[httputil.HTTPMessageDelegate]:</span>
<span class="gi">+    def find_handler(</span>
<span class="gi">+        self, request: httputil.HTTPServerRequest, **kwargs: Any</span>
<span class="gi">+    ) -&gt; Optional[httputil.HTTPMessageDelegate]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Must be implemented to return an appropriate instance of `~.httputil.HTTPMessageDelegate`
<span class="w"> </span>        that can serve the request.
<span class="w"> </span>        Routing implementations may pass additional kwargs to extend the routing logic.
<span class="gu">@@ -184,7 +202,12 @@ class Router(httputil.HTTPServerConnectionDelegate):</span>
<span class="w"> </span>        :returns: an instance of `~.httputil.HTTPMessageDelegate` that will be used to
<span class="w"> </span>            process the request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def start_request(</span>
<span class="gi">+        self, server_conn: object, request_conn: httputil.HTTPConnection</span>
<span class="gi">+    ) -&gt; httputil.HTTPMessageDelegate:</span>
<span class="gi">+        return _RoutingDelegate(self, server_conn, request_conn)</span>


<span class="w"> </span>class ReversibleRouter(Router):
<span class="gu">@@ -192,7 +215,7 @@ class ReversibleRouter(Router):</span>
<span class="w"> </span>    and support reversing them to original urls.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def reverse_url(self, name: str, *args: Any) -&gt;Optional[str]:</span>
<span class="gi">+    def reverse_url(self, name: str, *args: Any) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns url string for a given route name and arguments
<span class="w"> </span>        or ``None`` if no match is found.

<span class="gu">@@ -200,34 +223,84 @@ class ReversibleRouter(Router):</span>
<span class="w"> </span>        :arg args: url parameters.
<span class="w"> </span>        :returns: parametrized url string for a given route name (or ``None``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>


<span class="w"> </span>class _RoutingDelegate(httputil.HTTPMessageDelegate):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, router: Router, server_conn: object, request_conn:</span>
<span class="gd">-        httputil.HTTPConnection) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, router: Router, server_conn: object, request_conn: httputil.HTTPConnection</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.server_conn = server_conn
<span class="w"> </span>        self.request_conn = request_conn
<span class="gd">-        self.delegate = None</span>
<span class="gd">-        self.router = router</span>
<span class="gi">+        self.delegate = None  # type: Optional[httputil.HTTPMessageDelegate]</span>
<span class="gi">+        self.router = router  # type: Router</span>
<span class="gi">+</span>
<span class="gi">+    def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        assert isinstance(start_line, httputil.RequestStartLine)</span>
<span class="gi">+        request = httputil.HTTPServerRequest(</span>
<span class="gi">+            connection=self.request_conn,</span>
<span class="gi">+            server_connection=self.server_conn,</span>
<span class="gi">+            start_line=start_line,</span>
<span class="gi">+            headers=headers,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.delegate = self.router.find_handler(request)</span>
<span class="gi">+        if self.delegate is None:</span>
<span class="gi">+            app_log.debug(</span>
<span class="gi">+                &quot;Delegate for %s %s request not found&quot;,</span>
<span class="gi">+                start_line.method,</span>
<span class="gi">+                start_line.path,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.delegate = _DefaultMessageDelegate(self.request_conn)</span>
<span class="gi">+</span>
<span class="gi">+        return self.delegate.headers_received(start_line, headers)</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, chunk: bytes) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        assert self.delegate is not None</span>
<span class="gi">+        return self.delegate.data_received(chunk)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        assert self.delegate is not None</span>
<span class="gi">+        self.delegate.finish()</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        assert self.delegate is not None</span>
<span class="gi">+        self.delegate.on_connection_close()</span>


<span class="w"> </span>class _DefaultMessageDelegate(httputil.HTTPMessageDelegate):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, connection: httputil.HTTPConnection) -&gt;None:</span>
<span class="gi">+    def __init__(self, connection: httputil.HTTPConnection) -&gt; None:</span>
<span class="w"> </span>        self.connection = connection

<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        self.connection.write_headers(</span>
<span class="gi">+            httputil.ResponseStartLine(&quot;HTTP/1.1&quot;, 404, &quot;Not Found&quot;),</span>
<span class="gi">+            httputil.HTTPHeaders(),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.connection.finish()</span>
<span class="gi">+</span>

<span class="gd">-_RuleList = List[Union[&#39;Rule&#39;, List[Any], Tuple[Union[str, &#39;Matcher&#39;], Any],</span>
<span class="gd">-    Tuple[Union[str, &#39;Matcher&#39;], Any, Dict[str, Any]], Tuple[Union[str,</span>
<span class="gd">-    &#39;Matcher&#39;], Any, Dict[str, Any], str]]]</span>
<span class="gi">+# _RuleList can either contain pre-constructed Rules or a sequence of</span>
<span class="gi">+# arguments to be passed to the Rule constructor.</span>
<span class="gi">+_RuleList = List[</span>
<span class="gi">+    Union[</span>
<span class="gi">+        &quot;Rule&quot;,</span>
<span class="gi">+        List[Any],  # Can&#39;t do detailed typechecking of lists.</span>
<span class="gi">+        Tuple[Union[str, &quot;Matcher&quot;], Any],</span>
<span class="gi">+        Tuple[Union[str, &quot;Matcher&quot;], Any, Dict[str, Any]],</span>
<span class="gi">+        Tuple[Union[str, &quot;Matcher&quot;], Any, Dict[str, Any], str],</span>
<span class="gi">+    ]</span>
<span class="gi">+]</span>


<span class="w"> </span>class RuleRouter(Router):
<span class="w"> </span>    &quot;&quot;&quot;Rule-based router implementation.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, rules: Optional[_RuleList]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, rules: Optional[_RuleList] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constructs a router from an ordered list of rules::

<span class="w"> </span>            RuleRouter([
<span class="gu">@@ -254,29 +327,55 @@ class RuleRouter(Router):</span>
<span class="w"> </span>        :arg rules: a list of `Rule` instances or tuples of `Rule`
<span class="w"> </span>            constructor arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.rules = []</span>
<span class="gi">+        self.rules = []  # type: List[Rule]</span>
<span class="w"> </span>        if rules:
<span class="w"> </span>            self.add_rules(rules)

<span class="gd">-    def add_rules(self, rules: _RuleList) -&gt;None:</span>
<span class="gi">+    def add_rules(self, rules: _RuleList) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Appends new rules to the router.

<span class="w"> </span>        :arg rules: a list of Rule instances (or tuples of arguments, which are
<span class="w"> </span>            passed to Rule constructor).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rule in rules:</span>
<span class="gi">+            if isinstance(rule, (tuple, list)):</span>
<span class="gi">+                assert len(rule) in (2, 3, 4)</span>
<span class="gi">+                if isinstance(rule[0], basestring_type):</span>
<span class="gi">+                    rule = Rule(PathMatches(rule[0]), *rule[1:])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    rule = Rule(*rule)</span>

<span class="gd">-    def process_rule(self, rule: &#39;Rule&#39;) -&gt;&#39;Rule&#39;:</span>
<span class="gi">+            self.rules.append(self.process_rule(rule))</span>
<span class="gi">+</span>
<span class="gi">+    def process_rule(self, rule: &quot;Rule&quot;) -&gt; &quot;Rule&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override this method for additional preprocessing of each rule.

<span class="w"> </span>        :arg Rule rule: a rule to be processed.
<span class="w"> </span>        :returns: the same or modified Rule instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return rule</span>
<span class="gi">+</span>
<span class="gi">+    def find_handler(</span>
<span class="gi">+        self, request: httputil.HTTPServerRequest, **kwargs: Any</span>
<span class="gi">+    ) -&gt; Optional[httputil.HTTPMessageDelegate]:</span>
<span class="gi">+        for rule in self.rules:</span>
<span class="gi">+            target_params = rule.matcher.match(request)</span>
<span class="gi">+            if target_params is not None:</span>
<span class="gi">+                if rule.target_kwargs:</span>
<span class="gi">+                    target_params[&quot;target_kwargs&quot;] = rule.target_kwargs</span>

<span class="gd">-    def get_target_delegate(self, target: Any, request: httputil.</span>
<span class="gd">-        HTTPServerRequest, **target_params: Any) -&gt;Optional[httputil.</span>
<span class="gd">-        HTTPMessageDelegate]:</span>
<span class="gi">+                delegate = self.get_target_delegate(</span>
<span class="gi">+                    rule.target, request, **target_params</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if delegate is not None:</span>
<span class="gi">+                    return delegate</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_delegate(</span>
<span class="gi">+        self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any</span>
<span class="gi">+    ) -&gt; Optional[httputil.HTTPMessageDelegate]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns an instance of `~.httputil.HTTPMessageDelegate` for a
<span class="w"> </span>        Rule&#39;s target. This method is called by `~.find_handler` and can be
<span class="w"> </span>        extended to provide additional target types.
<span class="gu">@@ -286,7 +385,20 @@ class RuleRouter(Router):</span>
<span class="w"> </span>        :arg target_params: additional parameters that can be useful
<span class="w"> </span>            for `~.httputil.HTTPMessageDelegate` creation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(target, Router):</span>
<span class="gi">+            return target.find_handler(request, **target_params)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(target, httputil.HTTPServerConnectionDelegate):</span>
<span class="gi">+            assert request.connection is not None</span>
<span class="gi">+            return target.start_request(request.server_connection, request.connection)</span>
<span class="gi">+</span>
<span class="gi">+        elif callable(target):</span>
<span class="gi">+            assert request.connection is not None</span>
<span class="gi">+            return _CallableAdapter(</span>
<span class="gi">+                partial(target, **target_params), request.connection</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class ReversibleRuleRouter(ReversibleRouter, RuleRouter):
<span class="gu">@@ -297,16 +409,45 @@ class ReversibleRuleRouter(ReversibleRouter, RuleRouter):</span>
<span class="w"> </span>    in a rule&#39;s matcher (see `Matcher.reverse`).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, rules: Optional[_RuleList]=None) -&gt;None:</span>
<span class="gd">-        self.named_rules = {}</span>
<span class="gi">+    def __init__(self, rules: Optional[_RuleList] = None) -&gt; None:</span>
<span class="gi">+        self.named_rules = {}  # type: Dict[str, Any]</span>
<span class="w"> </span>        super().__init__(rules)

<span class="gi">+    def process_rule(self, rule: &quot;Rule&quot;) -&gt; &quot;Rule&quot;:</span>
<span class="gi">+        rule = super().process_rule(rule)</span>
<span class="gi">+</span>
<span class="gi">+        if rule.name:</span>
<span class="gi">+            if rule.name in self.named_rules:</span>
<span class="gi">+                app_log.warning(</span>
<span class="gi">+                    &quot;Multiple handlers named %s; replacing previous value&quot;, rule.name</span>
<span class="gi">+                )</span>
<span class="gi">+            self.named_rules[rule.name] = rule</span>
<span class="gi">+</span>
<span class="gi">+        return rule</span>
<span class="gi">+</span>
<span class="gi">+    def reverse_url(self, name: str, *args: Any) -&gt; Optional[str]:</span>
<span class="gi">+        if name in self.named_rules:</span>
<span class="gi">+            return self.named_rules[name].matcher.reverse(*args)</span>
<span class="gi">+</span>
<span class="gi">+        for rule in self.rules:</span>
<span class="gi">+            if isinstance(rule.target, ReversibleRouter):</span>
<span class="gi">+                reversed_url = rule.target.reverse_url(name, *args)</span>
<span class="gi">+                if reversed_url is not None:</span>
<span class="gi">+                    return reversed_url</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class Rule(object):
<span class="w"> </span>    &quot;&quot;&quot;A routing rule.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, matcher: &#39;Matcher&#39;, target: Any, target_kwargs:</span>
<span class="gd">-        Optional[Dict[str, Any]]=None, name: Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        matcher: &quot;Matcher&quot;,</span>
<span class="gi">+        target: Any,</span>
<span class="gi">+        target_kwargs: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        name: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constructs a Rule instance.

<span class="w"> </span>        :arg Matcher matcher: a `Matcher` instance used for determining
<span class="gu">@@ -324,22 +465,32 @@ class Rule(object):</span>
<span class="w"> </span>            in `ReversibleRouter.reverse_url` implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if isinstance(target, str):
<span class="gi">+            # import the Module and instantiate the class</span>
<span class="gi">+            # Must be a fully qualified name (module.ClassName)</span>
<span class="w"> </span>            target = import_object(target)
<span class="gd">-        self.matcher = matcher</span>
<span class="gi">+</span>
<span class="gi">+        self.matcher = matcher  # type: Matcher</span>
<span class="w"> </span>        self.target = target
<span class="w"> </span>        self.target_kwargs = target_kwargs if target_kwargs else {}
<span class="w"> </span>        self.name = name

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;%s(%r, %s, kwargs=%r, name=%r)&#39; % (self.__class__.__name__,</span>
<span class="gd">-            self.matcher, self.target, self.target_kwargs, self.name)</span>
<span class="gi">+    def reverse(self, *args: Any) -&gt; Optional[str]:</span>
<span class="gi">+        return self.matcher.reverse(*args)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;%s(%r, %s, kwargs=%r, name=%r)&quot; % (</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.matcher,</span>
<span class="gi">+            self.target,</span>
<span class="gi">+            self.target_kwargs,</span>
<span class="gi">+            self.name,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class Matcher(object):
<span class="w"> </span>    &quot;&quot;&quot;Represents a matcher for request features.&quot;&quot;&quot;

<span class="gd">-    def match(self, request: httputil.HTTPServerRequest) -&gt;Optional[Dict[</span>
<span class="gd">-        str, Any]]:</span>
<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt; Optional[Dict[str, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Matches current instance against the request.

<span class="w"> </span>        :arg httputil.HTTPServerRequest request: current HTTP request
<span class="gu">@@ -349,60 +500,150 @@ class Matcher(object):</span>
<span class="w"> </span>            An empty dict is a valid (and common) return value to indicate a match
<span class="w"> </span>            when the argument-passing features are not used.
<span class="w"> </span>            ``None`` must be returned to indicate that there is no match.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def reverse(self, *args: Any) -&gt;Optional[str]:</span>
<span class="gi">+    def reverse(self, *args: Any) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reconstructs full url from matcher instance and additional arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class AnyMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches any request.&quot;&quot;&quot;

<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>

<span class="w"> </span>class HostMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches requests from hosts specified by ``host_pattern`` regex.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, host_pattern: Union[str, Pattern]) -&gt;None:</span>
<span class="gi">+    def __init__(self, host_pattern: Union[str, Pattern]) -&gt; None:</span>
<span class="w"> </span>        if isinstance(host_pattern, basestring_type):
<span class="gd">-            if not host_pattern.endswith(&#39;$&#39;):</span>
<span class="gd">-                host_pattern += &#39;$&#39;</span>
<span class="gi">+            if not host_pattern.endswith(&quot;$&quot;):</span>
<span class="gi">+                host_pattern += &quot;$&quot;</span>
<span class="w"> </span>            self.host_pattern = re.compile(host_pattern)
<span class="w"> </span>        else:
<span class="w"> </span>            self.host_pattern = host_pattern

<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+        if self.host_pattern.match(request.host_name):</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class DefaultHostMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches requests from host that is equal to application&#39;s default_host.
<span class="w"> </span>    Always returns no match if ``X-Real-Ip`` header is present.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, application: Any, host_pattern: Pattern) -&gt;None:</span>
<span class="gi">+    def __init__(self, application: Any, host_pattern: Pattern) -&gt; None:</span>
<span class="w"> </span>        self.application = application
<span class="w"> </span>        self.host_pattern = host_pattern

<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+        # Look for default host if not behind load balancer (for debugging)</span>
<span class="gi">+        if &quot;X-Real-Ip&quot; not in request.headers:</span>
<span class="gi">+            if self.host_pattern.match(self.application.default_host):</span>
<span class="gi">+                return {}</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class PathMatches(Matcher):
<span class="w"> </span>    &quot;&quot;&quot;Matches requests with paths specified by ``path_pattern`` regex.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, path_pattern: Union[str, Pattern]) -&gt;None:</span>
<span class="gi">+    def __init__(self, path_pattern: Union[str, Pattern]) -&gt; None:</span>
<span class="w"> </span>        if isinstance(path_pattern, basestring_type):
<span class="gd">-            if not path_pattern.endswith(&#39;$&#39;):</span>
<span class="gd">-                path_pattern += &#39;$&#39;</span>
<span class="gi">+            if not path_pattern.endswith(&quot;$&quot;):</span>
<span class="gi">+                path_pattern += &quot;$&quot;</span>
<span class="w"> </span>            self.regex = re.compile(path_pattern)
<span class="w"> </span>        else:
<span class="w"> </span>            self.regex = path_pattern
<span class="gd">-        assert len(self.regex.groupindex) in (0, self.regex.groups</span>
<span class="gd">-            ), &#39;groups in url regexes must either be all named or all positional: %r&#39; % self.regex.pattern</span>
<span class="gi">+</span>
<span class="gi">+        assert len(self.regex.groupindex) in (0, self.regex.groups), (</span>
<span class="gi">+            &quot;groups in url regexes must either be all named or all &quot;</span>
<span class="gi">+            &quot;positional: %r&quot; % self.regex.pattern</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._path, self._group_count = self._find_groups()

<span class="gd">-    def _find_groups(self) -&gt;Tuple[Optional[str], Optional[int]]:</span>
<span class="gi">+    def match(self, request: httputil.HTTPServerRequest) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+        match = self.regex.match(request.path)</span>
<span class="gi">+        if match is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if not self.regex.groups:</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        path_args = []  # type: List[bytes]</span>
<span class="gi">+        path_kwargs = {}  # type: Dict[str, bytes]</span>
<span class="gi">+</span>
<span class="gi">+        # Pass matched groups to the handler.  Since</span>
<span class="gi">+        # match.groups() includes both named and</span>
<span class="gi">+        # unnamed groups, we want to use either groups</span>
<span class="gi">+        # or groupdict but not both.</span>
<span class="gi">+        if self.regex.groupindex:</span>
<span class="gi">+            path_kwargs = dict(</span>
<span class="gi">+                (str(k), _unquote_or_none(v)) for (k, v) in match.groupdict().items()</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            path_args = [_unquote_or_none(s) for s in match.groups()]</span>
<span class="gi">+</span>
<span class="gi">+        return dict(path_args=path_args, path_kwargs=path_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def reverse(self, *args: Any) -&gt; Optional[str]:</span>
<span class="gi">+        if self._path is None:</span>
<span class="gi">+            raise ValueError(&quot;Cannot reverse url regex &quot; + self.regex.pattern)</span>
<span class="gi">+        assert len(args) == self._group_count, (</span>
<span class="gi">+            &quot;required number of arguments &quot; &quot;not found&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if not len(args):</span>
<span class="gi">+            return self._path</span>
<span class="gi">+        converted_args = []</span>
<span class="gi">+        for a in args:</span>
<span class="gi">+            if not isinstance(a, (unicode_type, bytes)):</span>
<span class="gi">+                a = str(a)</span>
<span class="gi">+            converted_args.append(url_escape(utf8(a), plus=False))</span>
<span class="gi">+        return self._path % tuple(converted_args)</span>
<span class="gi">+</span>
<span class="gi">+    def _find_groups(self) -&gt; Tuple[Optional[str], Optional[int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a tuple (reverse string, group count) for a url.

<span class="w"> </span>        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method
<span class="w"> </span>        would return (&#39;/%s/%s/&#39;, 2).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pattern = self.regex.pattern</span>
<span class="gi">+        if pattern.startswith(&quot;^&quot;):</span>
<span class="gi">+            pattern = pattern[1:]</span>
<span class="gi">+        if pattern.endswith(&quot;$&quot;):</span>
<span class="gi">+            pattern = pattern[:-1]</span>
<span class="gi">+</span>
<span class="gi">+        if self.regex.groups != pattern.count(&quot;(&quot;):</span>
<span class="gi">+            # The pattern is too complicated for our simplistic matching,</span>
<span class="gi">+            # so we can&#39;t support reversing it.</span>
<span class="gi">+            return None, None</span>
<span class="gi">+</span>
<span class="gi">+        pieces = []</span>
<span class="gi">+        for fragment in pattern.split(&quot;(&quot;):</span>
<span class="gi">+            if &quot;)&quot; in fragment:</span>
<span class="gi">+                paren_loc = fragment.index(&quot;)&quot;)</span>
<span class="gi">+                if paren_loc &gt;= 0:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        unescaped_fragment = re_unescape(fragment[paren_loc + 1 :])</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        # If we can&#39;t unescape part of it, we can&#39;t</span>
<span class="gi">+                        # reverse this url.</span>
<span class="gi">+                        return (None, None)</span>
<span class="gi">+                    pieces.append(&quot;%s&quot; + unescaped_fragment)</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    unescaped_fragment = re_unescape(fragment)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    # If we can&#39;t unescape part of it, we can&#39;t</span>
<span class="gi">+                    # reverse this url.</span>
<span class="gi">+                    return (None, None)</span>
<span class="gi">+                pieces.append(unescaped_fragment)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;&quot;.join(pieces), self.regex.groups</span>


<span class="w"> </span>class URLSpec(Rule):
<span class="gu">@@ -413,8 +654,13 @@ class URLSpec(Rule):</span>
<span class="w"> </span>       backwards compatibility.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, pattern: Union[str, Pattern], handler: Any, kwargs:</span>
<span class="gd">-        Optional[Dict[str, Any]]=None, name: Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pattern: Union[str, Pattern],</span>
<span class="gi">+        handler: Any,</span>
<span class="gi">+        kwargs: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        name: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parameters:

<span class="w"> </span>        * ``pattern``: Regular expression to be matched. Any capturing
<span class="gu">@@ -434,20 +680,38 @@ class URLSpec(Rule):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        matcher = PathMatches(pattern)
<span class="w"> </span>        super().__init__(matcher, handler, kwargs, name)
<span class="gi">+</span>
<span class="w"> </span>        self.regex = matcher.regex
<span class="w"> </span>        self.handler_class = self.target
<span class="w"> </span>        self.kwargs = kwargs

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;%s(%r, %s, kwargs=%r, name=%r)&#39; % (self.__class__.__name__,</span>
<span class="gd">-            self.regex.pattern, self.handler_class, self.kwargs, self.name)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;%s(%r, %s, kwargs=%r, name=%r)&quot; % (</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.regex.pattern,</span>
<span class="gi">+            self.handler_class,</span>
<span class="gi">+            self.kwargs,</span>
<span class="gi">+            self.name,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def _unquote_or_none(s: str) -&gt; bytes:</span>
<span class="gi">+    pass</span>


<span class="gd">-def _unquote_or_none(s: Optional[str]) -&gt;Optional[bytes]:</span>
<span class="gi">+@overload  # noqa: F811</span>
<span class="gi">+def _unquote_or_none(s: None) -&gt; None:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _unquote_or_none(s: Optional[str]) -&gt; Optional[bytes]:  # noqa: F811</span>
<span class="w"> </span>    &quot;&quot;&quot;None-safe wrapper around url_unescape to handle unmatched optional
<span class="w"> </span>    groups correctly.

<span class="w"> </span>    Note that args are passed as bytes so the handler can decide what
<span class="w"> </span>    encoding to use.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        return s</span>
<span class="gi">+    return url_unescape(s, encoding=None, plus=False)</span>
<span class="gh">diff --git a/tornado/simple_httpclient.py b/tornado/simple_httpclient.py</span>
<span class="gh">index 5ce89b18..5b2d4dcd 100644</span>
<span class="gd">--- a/tornado/simple_httpclient.py</span>
<span class="gi">+++ b/tornado/simple_httpclient.py</span>
<span class="gu">@@ -1,13 +1,26 @@</span>
<span class="w"> </span>from tornado.escape import _unicode
<span class="w"> </span>from tornado import gen, version
<span class="gd">-from tornado.httpclient import HTTPResponse, HTTPError, AsyncHTTPClient, main, _RequestProxy, HTTPRequest</span>
<span class="gi">+from tornado.httpclient import (</span>
<span class="gi">+    HTTPResponse,</span>
<span class="gi">+    HTTPError,</span>
<span class="gi">+    AsyncHTTPClient,</span>
<span class="gi">+    main,</span>
<span class="gi">+    _RequestProxy,</span>
<span class="gi">+    HTTPRequest,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado import httputil
<span class="w"> </span>from tornado.http1connection import HTTP1Connection, HTTP1ConnectionParameters
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.iostream import StreamClosedError, IOStream
<span class="gd">-from tornado.netutil import Resolver, OverrideResolver, _client_ssl_defaults, is_valid_ip</span>
<span class="gi">+from tornado.netutil import (</span>
<span class="gi">+    Resolver,</span>
<span class="gi">+    OverrideResolver,</span>
<span class="gi">+    _client_ssl_defaults,</span>
<span class="gi">+    is_valid_ip,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.log import gen_log
<span class="w"> </span>from tornado.tcpclient import TCPClient
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import collections
<span class="w"> </span>import copy
<span class="gu">@@ -19,11 +32,13 @@ import sys</span>
<span class="w"> </span>import time
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>import urllib.parse
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict, Any, Callable, Optional, Type, Union
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Deque, Tuple, List</span>
<span class="gi">+    from typing import Deque, Tuple, List  # noqa: F401</span>


<span class="w"> </span>class HTTPTimeoutError(HTTPError):
<span class="gu">@@ -35,11 +50,11 @@ class HTTPTimeoutError(HTTPError):</span>
<span class="w"> </span>    .. versionadded:: 5.1
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(599, message=message)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return self.message or &#39;Timeout&#39;</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return self.message or &quot;Timeout&quot;</span>


<span class="w"> </span>class HTTPStreamClosedError(HTTPError):
<span class="gu">@@ -54,11 +69,11 @@ class HTTPStreamClosedError(HTTPError):</span>
<span class="w"> </span>    .. versionadded:: 5.1
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(599, message=message)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return self.message or &#39;Stream closed&#39;</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return self.message or &quot;Stream closed&quot;</span>


<span class="w"> </span>class SimpleAsyncHTTPClient(AsyncHTTPClient):
<span class="gu">@@ -100,7 +115,119 @@ class SimpleAsyncHTTPClient(AsyncHTTPClient):</span>
<span class="w"> </span>        Added the ``max_body_size`` argument.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def _on_timeout(self, key: object, info: Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def initialize(  # type: ignore</span>
<span class="gi">+        self,</span>
<span class="gi">+        max_clients: int = 10,</span>
<span class="gi">+        hostname_mapping: Optional[Dict[str, str]] = None,</span>
<span class="gi">+        max_buffer_size: int = 104857600,</span>
<span class="gi">+        resolver: Optional[Resolver] = None,</span>
<span class="gi">+        defaults: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        max_header_size: Optional[int] = None,</span>
<span class="gi">+        max_body_size: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().initialize(defaults=defaults)</span>
<span class="gi">+        self.max_clients = max_clients</span>
<span class="gi">+        self.queue = (</span>
<span class="gi">+            collections.deque()</span>
<span class="gi">+        )  # type: Deque[Tuple[object, HTTPRequest, Callable[[HTTPResponse], None]]]</span>
<span class="gi">+        self.active = (</span>
<span class="gi">+            {}</span>
<span class="gi">+        )  # type: Dict[object, Tuple[HTTPRequest, Callable[[HTTPResponse], None]]]</span>
<span class="gi">+        self.waiting = (</span>
<span class="gi">+            {}</span>
<span class="gi">+        )  # type: Dict[object, Tuple[HTTPRequest, Callable[[HTTPResponse], None], object]]</span>
<span class="gi">+        self.max_buffer_size = max_buffer_size</span>
<span class="gi">+        self.max_header_size = max_header_size</span>
<span class="gi">+        self.max_body_size = max_body_size</span>
<span class="gi">+        # TCPClient could create a Resolver for us, but we have to do it</span>
<span class="gi">+        # ourselves to support hostname_mapping.</span>
<span class="gi">+        if resolver:</span>
<span class="gi">+            self.resolver = resolver</span>
<span class="gi">+            self.own_resolver = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.resolver = Resolver()</span>
<span class="gi">+            self.own_resolver = True</span>
<span class="gi">+        if hostname_mapping is not None:</span>
<span class="gi">+            self.resolver = OverrideResolver(</span>
<span class="gi">+                resolver=self.resolver, mapping=hostname_mapping</span>
<span class="gi">+            )</span>
<span class="gi">+        self.tcp_client = TCPClient(resolver=self.resolver)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        super().close()</span>
<span class="gi">+        if self.own_resolver:</span>
<span class="gi">+            self.resolver.close()</span>
<span class="gi">+        self.tcp_client.close()</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_impl(</span>
<span class="gi">+        self, request: HTTPRequest, callback: Callable[[HTTPResponse], None]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        key = object()</span>
<span class="gi">+        self.queue.append((key, request, callback))</span>
<span class="gi">+        assert request.connect_timeout is not None</span>
<span class="gi">+        assert request.request_timeout is not None</span>
<span class="gi">+        timeout_handle = None</span>
<span class="gi">+        if len(self.active) &gt;= self.max_clients:</span>
<span class="gi">+            timeout = (</span>
<span class="gi">+                min(request.connect_timeout, request.request_timeout)</span>
<span class="gi">+                or request.connect_timeout</span>
<span class="gi">+                or request.request_timeout</span>
<span class="gi">+            )  # min but skip zero</span>
<span class="gi">+            if timeout:</span>
<span class="gi">+                timeout_handle = self.io_loop.add_timeout(</span>
<span class="gi">+                    self.io_loop.time() + timeout,</span>
<span class="gi">+                    functools.partial(self._on_timeout, key, &quot;in request queue&quot;),</span>
<span class="gi">+                )</span>
<span class="gi">+        self.waiting[key] = (request, callback, timeout_handle)</span>
<span class="gi">+        self._process_queue()</span>
<span class="gi">+        if self.queue:</span>
<span class="gi">+            gen_log.debug(</span>
<span class="gi">+                &quot;max_clients limit reached, request queued. &quot;</span>
<span class="gi">+                &quot;%d active, %d queued requests.&quot; % (len(self.active), len(self.queue))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _process_queue(self) -&gt; None:</span>
<span class="gi">+        while self.queue and len(self.active) &lt; self.max_clients:</span>
<span class="gi">+            key, request, callback = self.queue.popleft()</span>
<span class="gi">+            if key not in self.waiting:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._remove_timeout(key)</span>
<span class="gi">+            self.active[key] = (request, callback)</span>
<span class="gi">+            release_callback = functools.partial(self._release_fetch, key)</span>
<span class="gi">+            self._handle_request(request, release_callback, callback)</span>
<span class="gi">+</span>
<span class="gi">+    def _connection_class(self) -&gt; type:</span>
<span class="gi">+        return _HTTPConnection</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: HTTPRequest,</span>
<span class="gi">+        release_callback: Callable[[], None],</span>
<span class="gi">+        final_callback: Callable[[HTTPResponse], None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._connection_class()(</span>
<span class="gi">+            self,</span>
<span class="gi">+            request,</span>
<span class="gi">+            release_callback,</span>
<span class="gi">+            final_callback,</span>
<span class="gi">+            self.max_buffer_size,</span>
<span class="gi">+            self.tcp_client,</span>
<span class="gi">+            self.max_header_size,</span>
<span class="gi">+            self.max_body_size,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _release_fetch(self, key: object) -&gt; None:</span>
<span class="gi">+        del self.active[key]</span>
<span class="gi">+        self._process_queue()</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_timeout(self, key: object) -&gt; None:</span>
<span class="gi">+        if key in self.waiting:</span>
<span class="gi">+            request, callback, timeout_handle = self.waiting[key]</span>
<span class="gi">+            if timeout_handle is not None:</span>
<span class="gi">+                self.io_loop.remove_timeout(timeout_handle)</span>
<span class="gi">+            del self.waiting[key]</span>
<span class="gi">+</span>
<span class="gi">+    def _on_timeout(self, key: object, info: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Timeout callback of request.

<span class="w"> </span>        Construct a timeout HTTPResponse when a timeout occurs.
<span class="gu">@@ -108,17 +235,36 @@ class SimpleAsyncHTTPClient(AsyncHTTPClient):</span>
<span class="w"> </span>        :arg object key: A simple object to mark the request.
<span class="w"> </span>        :info string key: More detailed timeout information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        request, callback, timeout_handle = self.waiting[key]</span>
<span class="gi">+        self.queue.remove((key, request, callback))</span>

<span class="gi">+        error_message = &quot;Timeout {0}&quot;.format(info) if info else &quot;Timeout&quot;</span>
<span class="gi">+        timeout_response = HTTPResponse(</span>
<span class="gi">+            request,</span>
<span class="gi">+            599,</span>
<span class="gi">+            error=HTTPTimeoutError(error_message),</span>
<span class="gi">+            request_time=self.io_loop.time() - request.start_time,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.io_loop.add_callback(callback, timeout_response)</span>
<span class="gi">+        del self.waiting[key]</span>

<span class="gd">-class _HTTPConnection(httputil.HTTPMessageDelegate):</span>
<span class="gd">-    _SUPPORTED_METHODS = set([&#39;GET&#39;, &#39;HEAD&#39;, &#39;POST&#39;, &#39;PUT&#39;, &#39;DELETE&#39;,</span>
<span class="gd">-        &#39;PATCH&#39;, &#39;OPTIONS&#39;])</span>

<span class="gd">-    def __init__(self, client: Optional[SimpleAsyncHTTPClient], request:</span>
<span class="gd">-        HTTPRequest, release_callback: Callable[[], None], final_callback:</span>
<span class="gd">-        Callable[[HTTPResponse], None], max_buffer_size: int, tcp_client:</span>
<span class="gd">-        TCPClient, max_header_size: int, max_body_size: int) -&gt;None:</span>
<span class="gi">+class _HTTPConnection(httputil.HTTPMessageDelegate):</span>
<span class="gi">+    _SUPPORTED_METHODS = set(</span>
<span class="gi">+        [&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;, &quot;OPTIONS&quot;]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        client: Optional[SimpleAsyncHTTPClient],</span>
<span class="gi">+        request: HTTPRequest,</span>
<span class="gi">+        release_callback: Callable[[], None],</span>
<span class="gi">+        final_callback: Callable[[HTTPResponse], None],</span>
<span class="gi">+        max_buffer_size: int,</span>
<span class="gi">+        tcp_client: TCPClient,</span>
<span class="gi">+        max_header_size: int,</span>
<span class="gi">+        max_body_size: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.io_loop = IOLoop.current()
<span class="w"> </span>        self.start_time = self.io_loop.time()
<span class="w"> </span>        self.start_wall_time = time.time()
<span class="gu">@@ -130,25 +276,429 @@ class _HTTPConnection(httputil.HTTPMessageDelegate):</span>
<span class="w"> </span>        self.tcp_client = tcp_client
<span class="w"> </span>        self.max_header_size = max_header_size
<span class="w"> </span>        self.max_body_size = max_body_size
<span class="gd">-        self.code = None</span>
<span class="gd">-        self.headers = None</span>
<span class="gd">-        self.chunks = []</span>
<span class="gi">+        self.code = None  # type: Optional[int]</span>
<span class="gi">+        self.headers = None  # type: Optional[httputil.HTTPHeaders]</span>
<span class="gi">+        self.chunks = []  # type: List[bytes]</span>
<span class="w"> </span>        self._decompressor = None
<span class="gd">-        self._timeout = None</span>
<span class="gi">+        # Timeout handle returned by IOLoop.add_timeout</span>
<span class="gi">+        self._timeout = None  # type: object</span>
<span class="w"> </span>        self._sockaddr = None
<span class="gd">-        IOLoop.current().add_future(gen.convert_yielded(self.run()), lambda</span>
<span class="gd">-            f: f.result())</span>
<span class="gd">-</span>
<span class="gd">-    def _on_timeout(self, info: Optional[str]=None) -&gt;None:</span>
<span class="gi">+        IOLoop.current().add_future(</span>
<span class="gi">+            gen.convert_yielded(self.run()), lambda f: f.result()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async def run(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.parsed = urllib.parse.urlsplit(_unicode(self.request.url))</span>
<span class="gi">+            if self.parsed.scheme not in (&quot;http&quot;, &quot;https&quot;):</span>
<span class="gi">+                raise ValueError(&quot;Unsupported url scheme: %s&quot; % self.request.url)</span>
<span class="gi">+            # urlsplit results have hostname and port results, but they</span>
<span class="gi">+            # didn&#39;t support ipv6 literals until python 2.7.</span>
<span class="gi">+            netloc = self.parsed.netloc</span>
<span class="gi">+            if &quot;@&quot; in netloc:</span>
<span class="gi">+                userpass, _, netloc = netloc.rpartition(&quot;@&quot;)</span>
<span class="gi">+            host, port = httputil.split_host_and_port(netloc)</span>
<span class="gi">+            if port is None:</span>
<span class="gi">+                port = 443 if self.parsed.scheme == &quot;https&quot; else 80</span>
<span class="gi">+            if re.match(r&quot;^\[.*\]$&quot;, host):</span>
<span class="gi">+                # raw ipv6 addresses in urls are enclosed in brackets</span>
<span class="gi">+                host = host[1:-1]</span>
<span class="gi">+            self.parsed_hostname = host  # save final host for _on_connect</span>
<span class="gi">+</span>
<span class="gi">+            if self.request.allow_ipv6 is False:</span>
<span class="gi">+                af = socket.AF_INET</span>
<span class="gi">+            else:</span>
<span class="gi">+                af = socket.AF_UNSPEC</span>
<span class="gi">+</span>
<span class="gi">+            ssl_options = self._get_ssl_options(self.parsed.scheme)</span>
<span class="gi">+</span>
<span class="gi">+            source_ip = None</span>
<span class="gi">+            if self.request.network_interface:</span>
<span class="gi">+                if is_valid_ip(self.request.network_interface):</span>
<span class="gi">+                    source_ip = self.request.network_interface</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;Unrecognized IPv4 or IPv6 address for network_interface, got %r&quot;</span>
<span class="gi">+                        % (self.request.network_interface,)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            if self.request.connect_timeout and self.request.request_timeout:</span>
<span class="gi">+                timeout = min(</span>
<span class="gi">+                    self.request.connect_timeout, self.request.request_timeout</span>
<span class="gi">+                )</span>
<span class="gi">+            elif self.request.connect_timeout:</span>
<span class="gi">+                timeout = self.request.connect_timeout</span>
<span class="gi">+            elif self.request.request_timeout:</span>
<span class="gi">+                timeout = self.request.request_timeout</span>
<span class="gi">+            else:</span>
<span class="gi">+                timeout = 0</span>
<span class="gi">+            if timeout:</span>
<span class="gi">+                self._timeout = self.io_loop.add_timeout(</span>
<span class="gi">+                    self.start_time + timeout,</span>
<span class="gi">+                    functools.partial(self._on_timeout, &quot;while connecting&quot;),</span>
<span class="gi">+                )</span>
<span class="gi">+            stream = await self.tcp_client.connect(</span>
<span class="gi">+                host,</span>
<span class="gi">+                port,</span>
<span class="gi">+                af=af,</span>
<span class="gi">+                ssl_options=ssl_options,</span>
<span class="gi">+                max_buffer_size=self.max_buffer_size,</span>
<span class="gi">+                source_ip=source_ip,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if self.final_callback is None:</span>
<span class="gi">+                # final_callback is cleared if we&#39;ve hit our timeout.</span>
<span class="gi">+                stream.close()</span>
<span class="gi">+                return</span>
<span class="gi">+            self.stream = stream</span>
<span class="gi">+            self.stream.set_close_callback(self.on_connection_close)</span>
<span class="gi">+            self._remove_timeout()</span>
<span class="gi">+            if self.final_callback is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            if self.request.request_timeout:</span>
<span class="gi">+                self._timeout = self.io_loop.add_timeout(</span>
<span class="gi">+                    self.start_time + self.request.request_timeout,</span>
<span class="gi">+                    functools.partial(self._on_timeout, &quot;during request&quot;),</span>
<span class="gi">+                )</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.request.method not in self._SUPPORTED_METHODS</span>
<span class="gi">+                and not self.request.allow_nonstandard_methods</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise KeyError(&quot;unknown method %s&quot; % self.request.method)</span>
<span class="gi">+            for key in (</span>
<span class="gi">+                &quot;proxy_host&quot;,</span>
<span class="gi">+                &quot;proxy_port&quot;,</span>
<span class="gi">+                &quot;proxy_username&quot;,</span>
<span class="gi">+                &quot;proxy_password&quot;,</span>
<span class="gi">+                &quot;proxy_auth_mode&quot;,</span>
<span class="gi">+            ):</span>
<span class="gi">+                if getattr(self.request, key, None):</span>
<span class="gi">+                    raise NotImplementedError(&quot;%s not supported&quot; % key)</span>
<span class="gi">+            if &quot;Connection&quot; not in self.request.headers:</span>
<span class="gi">+                self.request.headers[&quot;Connection&quot;] = &quot;close&quot;</span>
<span class="gi">+            if &quot;Host&quot; not in self.request.headers:</span>
<span class="gi">+                if &quot;@&quot; in self.parsed.netloc:</span>
<span class="gi">+                    self.request.headers[&quot;Host&quot;] = self.parsed.netloc.rpartition(&quot;@&quot;)[</span>
<span class="gi">+                        -1</span>
<span class="gi">+                    ]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.request.headers[&quot;Host&quot;] = self.parsed.netloc</span>
<span class="gi">+            username, password = None, None</span>
<span class="gi">+            if self.parsed.username is not None:</span>
<span class="gi">+                username, password = self.parsed.username, self.parsed.password</span>
<span class="gi">+            elif self.request.auth_username is not None:</span>
<span class="gi">+                username = self.request.auth_username</span>
<span class="gi">+                password = self.request.auth_password or &quot;&quot;</span>
<span class="gi">+            if username is not None:</span>
<span class="gi">+                assert password is not None</span>
<span class="gi">+                if self.request.auth_mode not in (None, &quot;basic&quot;):</span>
<span class="gi">+                    raise ValueError(&quot;unsupported auth_mode %s&quot;, self.request.auth_mode)</span>
<span class="gi">+                self.request.headers[&quot;Authorization&quot;] = &quot;Basic &quot; + _unicode(</span>
<span class="gi">+                    base64.b64encode(</span>
<span class="gi">+                        httputil.encode_username_password(username, password)</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            if self.request.user_agent:</span>
<span class="gi">+                self.request.headers[&quot;User-Agent&quot;] = self.request.user_agent</span>
<span class="gi">+            elif self.request.headers.get(&quot;User-Agent&quot;) is None:</span>
<span class="gi">+                self.request.headers[&quot;User-Agent&quot;] = &quot;Tornado/{}&quot;.format(version)</span>
<span class="gi">+            if not self.request.allow_nonstandard_methods:</span>
<span class="gi">+                # Some HTTP methods nearly always have bodies while others</span>
<span class="gi">+                # almost never do. Fail in this case unless the user has</span>
<span class="gi">+                # opted out of sanity checks with allow_nonstandard_methods.</span>
<span class="gi">+                body_expected = self.request.method in (&quot;POST&quot;, &quot;PATCH&quot;, &quot;PUT&quot;)</span>
<span class="gi">+                body_present = (</span>
<span class="gi">+                    self.request.body is not None</span>
<span class="gi">+                    or self.request.body_producer is not None</span>
<span class="gi">+                )</span>
<span class="gi">+                if (body_expected and not body_present) or (</span>
<span class="gi">+                    body_present and not body_expected</span>
<span class="gi">+                ):</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;Body must %sbe None for method %s (unless &quot;</span>
<span class="gi">+                        &quot;allow_nonstandard_methods is true)&quot;</span>
<span class="gi">+                        % (&quot;not &quot; if body_expected else &quot;&quot;, self.request.method)</span>
<span class="gi">+                    )</span>
<span class="gi">+            if self.request.expect_100_continue:</span>
<span class="gi">+                self.request.headers[&quot;Expect&quot;] = &quot;100-continue&quot;</span>
<span class="gi">+            if self.request.body is not None:</span>
<span class="gi">+                # When body_producer is used the caller is responsible for</span>
<span class="gi">+                # setting Content-Length (or else chunked encoding will be used).</span>
<span class="gi">+                self.request.headers[&quot;Content-Length&quot;] = str(len(self.request.body))</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.request.method == &quot;POST&quot;</span>
<span class="gi">+                and &quot;Content-Type&quot; not in self.request.headers</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.request.headers[&quot;Content-Type&quot;] = (</span>
<span class="gi">+                    &quot;application/x-www-form-urlencoded&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if self.request.decompress_response:</span>
<span class="gi">+                self.request.headers[&quot;Accept-Encoding&quot;] = &quot;gzip&quot;</span>
<span class="gi">+            req_path = (self.parsed.path or &quot;/&quot;) + (</span>
<span class="gi">+                (&quot;?&quot; + self.parsed.query) if self.parsed.query else &quot;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.connection = self._create_connection(stream)</span>
<span class="gi">+            start_line = httputil.RequestStartLine(self.request.method, req_path, &quot;&quot;)</span>
<span class="gi">+            self.connection.write_headers(start_line, self.request.headers)</span>
<span class="gi">+            if self.request.expect_100_continue:</span>
<span class="gi">+                await self.connection.read_response(self)</span>
<span class="gi">+            else:</span>
<span class="gi">+                await self._write_body(True)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self._handle_exception(*sys.exc_info()):</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    def _get_ssl_options(</span>
<span class="gi">+        self, scheme: str</span>
<span class="gi">+    ) -&gt; Union[None, Dict[str, Any], ssl.SSLContext]:</span>
<span class="gi">+        if scheme == &quot;https&quot;:</span>
<span class="gi">+            if self.request.ssl_options is not None:</span>
<span class="gi">+                return self.request.ssl_options</span>
<span class="gi">+            # If we are using the defaults, don&#39;t construct a</span>
<span class="gi">+            # new SSLContext.</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.request.validate_cert</span>
<span class="gi">+                and self.request.ca_certs is None</span>
<span class="gi">+                and self.request.client_cert is None</span>
<span class="gi">+                and self.request.client_key is None</span>
<span class="gi">+            ):</span>
<span class="gi">+                return _client_ssl_defaults</span>
<span class="gi">+            ssl_ctx = ssl.create_default_context(</span>
<span class="gi">+                ssl.Purpose.SERVER_AUTH, cafile=self.request.ca_certs</span>
<span class="gi">+            )</span>
<span class="gi">+            if not self.request.validate_cert:</span>
<span class="gi">+                ssl_ctx.check_hostname = False</span>
<span class="gi">+                ssl_ctx.verify_mode = ssl.CERT_NONE</span>
<span class="gi">+            if self.request.client_cert is not None:</span>
<span class="gi">+                ssl_ctx.load_cert_chain(</span>
<span class="gi">+                    self.request.client_cert, self.request.client_key</span>
<span class="gi">+                )</span>
<span class="gi">+            if hasattr(ssl, &quot;OP_NO_COMPRESSION&quot;):</span>
<span class="gi">+                # See netutil.ssl_options_to_context</span>
<span class="gi">+                ssl_ctx.options |= ssl.OP_NO_COMPRESSION</span>
<span class="gi">+            return ssl_ctx</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _on_timeout(self, info: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Timeout callback of _HTTPConnection instance.

<span class="w"> </span>        Raise a `HTTPTimeoutError` when a timeout occurs.

<span class="w"> </span>        :info string key: More detailed timeout information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+        self._timeout = None</span>
<span class="gi">+        error_message = &quot;Timeout {0}&quot;.format(info) if info else &quot;Timeout&quot;</span>
<span class="gi">+        if self.final_callback is not None:</span>
<span class="gi">+            self._handle_exception(</span>
<span class="gi">+                HTTPTimeoutError, HTTPTimeoutError(error_message), None</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_timeout(self) -&gt; None:</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self._timeout)</span>
<span class="gi">+            self._timeout = None</span>
<span class="gi">+</span>
<span class="gi">+    def _create_connection(self, stream: IOStream) -&gt; HTTP1Connection:</span>
<span class="gi">+        stream.set_nodelay(True)</span>
<span class="gi">+        connection = HTTP1Connection(</span>
<span class="gi">+            stream,</span>
<span class="gi">+            True,</span>
<span class="gi">+            HTTP1ConnectionParameters(</span>
<span class="gi">+                no_keep_alive=True,</span>
<span class="gi">+                max_header_size=self.max_header_size,</span>
<span class="gi">+                max_body_size=self.max_body_size,</span>
<span class="gi">+                decompress=bool(self.request.decompress_response),</span>
<span class="gi">+            ),</span>
<span class="gi">+            self._sockaddr,</span>
<span class="gi">+        )</span>
<span class="gi">+        return connection</span>
<span class="gi">+</span>
<span class="gi">+    async def _write_body(self, start_read: bool) -&gt; None:</span>
<span class="gi">+        if self.request.body is not None:</span>
<span class="gi">+            self.connection.write(self.request.body)</span>
<span class="gi">+        elif self.request.body_producer is not None:</span>
<span class="gi">+            fut = self.request.body_producer(self.connection.write)</span>
<span class="gi">+            if fut is not None:</span>
<span class="gi">+                await fut</span>
<span class="gi">+        self.connection.finish()</span>
<span class="gi">+        if start_read:</span>
<span class="gi">+            try:</span>
<span class="gi">+                await self.connection.read_response(self)</span>
<span class="gi">+            except StreamClosedError:</span>
<span class="gi">+                if not self._handle_exception(*sys.exc_info()):</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+    def _release(self) -&gt; None:</span>
<span class="gi">+        if self.release_callback is not None:</span>
<span class="gi">+            release_callback = self.release_callback</span>
<span class="gi">+            self.release_callback = None  # type: ignore</span>
<span class="gi">+            release_callback()</span>
<span class="gi">+</span>
<span class="gi">+    def _run_callback(self, response: HTTPResponse) -&gt; None:</span>
<span class="gi">+        self._release()</span>
<span class="gi">+        if self.final_callback is not None:</span>
<span class="gi">+            final_callback = self.final_callback</span>
<span class="gi">+            self.final_callback = None  # type: ignore</span>
<span class="gi">+            self.io_loop.add_callback(final_callback, response)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_exception(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if self.final_callback is not None:</span>
<span class="gi">+            self._remove_timeout()</span>
<span class="gi">+            if isinstance(value, StreamClosedError):</span>
<span class="gi">+                if value.real_error is None:</span>
<span class="gi">+                    value = HTTPStreamClosedError(&quot;Stream closed&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    value = value.real_error</span>
<span class="gi">+            self._run_callback(</span>
<span class="gi">+                HTTPResponse(</span>
<span class="gi">+                    self.request,</span>
<span class="gi">+                    599,</span>
<span class="gi">+                    error=value,</span>
<span class="gi">+                    request_time=self.io_loop.time() - self.start_time,</span>
<span class="gi">+                    start_time=self.start_wall_time,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if hasattr(self, &quot;stream&quot;):</span>
<span class="gi">+                # TODO: this may cause a StreamClosedError to be raised</span>
<span class="gi">+                # by the connection&#39;s Future.  Should we cancel the</span>
<span class="gi">+                # connection more gracefully?</span>
<span class="gi">+                self.stream.close()</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If our callback has already been called, we are probably</span>
<span class="gi">+            # catching an exception that is not caused by us but rather</span>
<span class="gi">+            # some child of our callback. Rather than drop it on the floor,</span>
<span class="gi">+            # pass it along, unless it&#39;s just the stream being closed.</span>
<span class="gi">+            return isinstance(value, StreamClosedError)</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        if self.final_callback is not None:</span>
<span class="gi">+            message = &quot;Connection closed&quot;</span>
<span class="gi">+            if self.stream.error:</span>
<span class="gi">+                raise self.stream.error</span>
<span class="gi">+            try:</span>
<span class="gi">+                raise HTTPStreamClosedError(message)</span>
<span class="gi">+            except HTTPStreamClosedError:</span>
<span class="gi">+                self._handle_exception(*sys.exc_info())</span>
<span class="gi">+</span>
<span class="gi">+    async def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        first_line: Union[httputil.ResponseStartLine, httputil.RequestStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert isinstance(first_line, httputil.ResponseStartLine)</span>
<span class="gi">+        if self.request.expect_100_continue and first_line.code == 100:</span>
<span class="gi">+            await self._write_body(False)</span>
<span class="gi">+            return</span>
<span class="gi">+        self.code = first_line.code</span>
<span class="gi">+        self.reason = first_line.reason</span>
<span class="gi">+        self.headers = headers</span>
<span class="gi">+</span>
<span class="gi">+        if self._should_follow_redirect():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.request.header_callback is not None:</span>
<span class="gi">+            # Reassemble the start line.</span>
<span class="gi">+            self.request.header_callback(&quot;%s %s %s\r\n&quot; % first_line)</span>
<span class="gi">+            for k, v in self.headers.get_all():</span>
<span class="gi">+                self.request.header_callback(&quot;%s: %s\r\n&quot; % (k, v))</span>
<span class="gi">+            self.request.header_callback(&quot;\r\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _should_follow_redirect(self) -&gt; bool:</span>
<span class="gi">+        if self.request.follow_redirects:</span>
<span class="gi">+            assert self.request.max_redirects is not None</span>
<span class="gi">+            return (</span>
<span class="gi">+                self.code in (301, 302, 303, 307, 308)</span>
<span class="gi">+                and self.request.max_redirects &gt; 0</span>
<span class="gi">+                and self.headers is not None</span>
<span class="gi">+                and self.headers.get(&quot;Location&quot;) is not None</span>
<span class="gi">+            )</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        assert self.code is not None</span>
<span class="gi">+        data = b&quot;&quot;.join(self.chunks)</span>
<span class="gi">+        self._remove_timeout()</span>
<span class="gi">+        original_request = getattr(self.request, &quot;original_request&quot;, self.request)</span>
<span class="gi">+        if self._should_follow_redirect():</span>
<span class="gi">+            assert isinstance(self.request, _RequestProxy)</span>
<span class="gi">+            assert self.headers is not None</span>
<span class="gi">+            new_request = copy.copy(self.request.request)</span>
<span class="gi">+            new_request.url = urllib.parse.urljoin(</span>
<span class="gi">+                self.request.url, self.headers[&quot;Location&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+            assert self.request.max_redirects is not None</span>
<span class="gi">+            new_request.max_redirects = self.request.max_redirects - 1</span>
<span class="gi">+            del new_request.headers[&quot;Host&quot;]</span>
<span class="gi">+            # https://tools.ietf.org/html/rfc7231#section-6.4</span>
<span class="gi">+            #</span>
<span class="gi">+            # The original HTTP spec said that after a 301 or 302</span>
<span class="gi">+            # redirect, the request method should be preserved.</span>
<span class="gi">+            # However, browsers implemented this by changing the</span>
<span class="gi">+            # method to GET, and the behavior stuck. 303 redirects</span>
<span class="gi">+            # always specified this POST-to-GET behavior, arguably</span>
<span class="gi">+            # for *all* methods, but libcurl &lt; 7.70 only does this</span>
<span class="gi">+            # for POST, while libcurl &gt;= 7.70 does it for other methods.</span>
<span class="gi">+            if (self.code == 303 and self.request.method != &quot;HEAD&quot;) or (</span>
<span class="gi">+                self.code in (301, 302) and self.request.method == &quot;POST&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                new_request.method = &quot;GET&quot;</span>
<span class="gi">+                new_request.body = None  # type: ignore</span>
<span class="gi">+                for h in [</span>
<span class="gi">+                    &quot;Content-Length&quot;,</span>
<span class="gi">+                    &quot;Content-Type&quot;,</span>
<span class="gi">+                    &quot;Content-Encoding&quot;,</span>
<span class="gi">+                    &quot;Transfer-Encoding&quot;,</span>
<span class="gi">+                ]:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        del self.request.headers[h]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            new_request.original_request = original_request  # type: ignore</span>
<span class="gi">+            final_callback = self.final_callback</span>
<span class="gi">+            self.final_callback = None  # type: ignore</span>
<span class="gi">+            self._release()</span>
<span class="gi">+            assert self.client is not None</span>
<span class="gi">+            fut = self.client.fetch(new_request, raise_error=False)</span>
<span class="gi">+            fut.add_done_callback(lambda f: final_callback(f.result()))</span>
<span class="gi">+            self._on_end_request()</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.request.streaming_callback:</span>
<span class="gi">+            buffer = BytesIO()</span>
<span class="gi">+        else:</span>
<span class="gi">+            buffer = BytesIO(data)  # TODO: don&#39;t require one big string?</span>
<span class="gi">+        response = HTTPResponse(</span>
<span class="gi">+            original_request,</span>
<span class="gi">+            self.code,</span>
<span class="gi">+            reason=getattr(self, &quot;reason&quot;, None),</span>
<span class="gi">+            headers=self.headers,</span>
<span class="gi">+            request_time=self.io_loop.time() - self.start_time,</span>
<span class="gi">+            start_time=self.start_wall_time,</span>
<span class="gi">+            buffer=buffer,</span>
<span class="gi">+            effective_url=self.request.url,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._run_callback(response)</span>
<span class="gi">+        self._on_end_request()</span>
<span class="gi">+</span>
<span class="gi">+    def _on_end_request(self) -&gt; None:</span>
<span class="gi">+        self.stream.close()</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, chunk: bytes) -&gt; None:</span>
<span class="gi">+        if self._should_follow_redirect():</span>
<span class="gi">+            # We&#39;re going to follow a redirect so just discard the body.</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.request.streaming_callback is not None:</span>
<span class="gi">+            self.request.streaming_callback(chunk)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.chunks.append(chunk)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
<span class="w"> </span>    main()
<span class="gh">diff --git a/tornado/tcpclient.py b/tornado/tcpclient.py</span>
<span class="gh">index 4e4fcdf6..0a829062 100644</span>
<span class="gd">--- a/tornado/tcpclient.py</span>
<span class="gi">+++ b/tornado/tcpclient.py</span>
<span class="gu">@@ -1,20 +1,40 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2014 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A non-blocking TCP connection factory.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>import socket
<span class="w"> </span>import numbers
<span class="w"> </span>import datetime
<span class="w"> </span>import ssl
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import Future, future_add_done_callback
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.iostream import IOStream
<span class="w"> </span>from tornado import gen
<span class="w"> </span>from tornado.netutil import Resolver
<span class="w"> </span>from tornado.gen import TimeoutError
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Union, Dict, Tuple, List, Callable, Iterator, Optional
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Set</span>
<span class="gi">+    from typing import Set  # noqa(F401)</span>
<span class="gi">+</span>
<span class="w"> </span>_INITIAL_CONNECT_TIMEOUT = 0.3


<span class="gu">@@ -36,21 +56,33 @@ class _Connector(object):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, addrinfo: List[Tuple], connect: Callable[[socket.</span>
<span class="gd">-        AddressFamily, Tuple], Tuple[IOStream, &#39;Future[IOStream]&#39;]]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        addrinfo: List[Tuple],</span>
<span class="gi">+        connect: Callable[</span>
<span class="gi">+            [socket.AddressFamily, Tuple], Tuple[IOStream, &quot;Future[IOStream]&quot;]</span>
<span class="gi">+        ],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.io_loop = IOLoop.current()
<span class="w"> </span>        self.connect = connect
<span class="gd">-        self.future = Future()</span>
<span class="gd">-        self.timeout = None</span>
<span class="gd">-        self.connect_timeout = None</span>
<span class="gd">-        self.last_error = None</span>
<span class="gi">+</span>
<span class="gi">+        self.future = (</span>
<span class="gi">+            Future()</span>
<span class="gi">+        )  # type: Future[Tuple[socket.AddressFamily, Any, IOStream]]</span>
<span class="gi">+        self.timeout = None  # type: Optional[object]</span>
<span class="gi">+        self.connect_timeout = None  # type: Optional[object]</span>
<span class="gi">+        self.last_error = None  # type: Optional[Exception]</span>
<span class="w"> </span>        self.remaining = len(addrinfo)
<span class="w"> </span>        self.primary_addrs, self.secondary_addrs = self.split(addrinfo)
<span class="gd">-        self.streams = set()</span>
<span class="gi">+        self.streams = set()  # type: Set[IOStream]</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def split(addrinfo: List[Tuple]) -&gt;Tuple[List[Tuple[socket.</span>
<span class="gd">-        AddressFamily, Tuple]], List[Tuple[socket.AddressFamily, Tuple]]]:</span>
<span class="gi">+    def split(</span>
<span class="gi">+        addrinfo: List[Tuple],</span>
<span class="gi">+    ) -&gt; Tuple[</span>
<span class="gi">+        List[Tuple[socket.AddressFamily, Tuple]],</span>
<span class="gi">+        List[Tuple[socket.AddressFamily, Tuple]],</span>
<span class="gi">+    ]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Partition the ``addrinfo`` list by address family.

<span class="w"> </span>        Returns two lists.  The first list contains the first entry from
<span class="gu">@@ -59,7 +91,112 @@ class _Connector(object):</span>
<span class="w"> </span>        be AF_INET and the other AF_INET6, although non-standard resolvers
<span class="w"> </span>        may return additional families).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        primary = []</span>
<span class="gi">+        secondary = []</span>
<span class="gi">+        primary_af = addrinfo[0][0]</span>
<span class="gi">+        for af, addr in addrinfo:</span>
<span class="gi">+            if af == primary_af:</span>
<span class="gi">+                primary.append((af, addr))</span>
<span class="gi">+            else:</span>
<span class="gi">+                secondary.append((af, addr))</span>
<span class="gi">+        return primary, secondary</span>
<span class="gi">+</span>
<span class="gi">+    def start(</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: float = _INITIAL_CONNECT_TIMEOUT,</span>
<span class="gi">+        connect_timeout: Optional[Union[float, datetime.timedelta]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Future[Tuple[socket.AddressFamily, Any, IOStream]]&quot;:</span>
<span class="gi">+        self.try_connect(iter(self.primary_addrs))</span>
<span class="gi">+        self.set_timeout(timeout)</span>
<span class="gi">+        if connect_timeout is not None:</span>
<span class="gi">+            self.set_connect_timeout(connect_timeout)</span>
<span class="gi">+        return self.future</span>
<span class="gi">+</span>
<span class="gi">+    def try_connect(self, addrs: Iterator[Tuple[socket.AddressFamily, Tuple]]) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            af, addr = next(addrs)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            # We&#39;ve reached the end of our queue, but the other queue</span>
<span class="gi">+            # might still be working.  Send a final error on the future</span>
<span class="gi">+            # only when both queues are finished.</span>
<span class="gi">+            if self.remaining == 0 and not self.future.done():</span>
<span class="gi">+                self.future.set_exception(</span>
<span class="gi">+                    self.last_error or IOError(&quot;connection failed&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>
<span class="gi">+        stream, future = self.connect(af, addr)</span>
<span class="gi">+        self.streams.add(stream)</span>
<span class="gi">+        future_add_done_callback(</span>
<span class="gi">+            future, functools.partial(self.on_connect_done, addrs, af, addr)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def on_connect_done(</span>
<span class="gi">+        self,</span>
<span class="gi">+        addrs: Iterator[Tuple[socket.AddressFamily, Tuple]],</span>
<span class="gi">+        af: socket.AddressFamily,</span>
<span class="gi">+        addr: Tuple,</span>
<span class="gi">+        future: &quot;Future[IOStream]&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.remaining -= 1</span>
<span class="gi">+        try:</span>
<span class="gi">+            stream = future.result()</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            if self.future.done():</span>
<span class="gi">+                return</span>
<span class="gi">+            # Error: try again (but remember what happened so we have an</span>
<span class="gi">+            # error to raise in the end)</span>
<span class="gi">+            self.last_error = e</span>
<span class="gi">+            self.try_connect(addrs)</span>
<span class="gi">+            if self.timeout is not None:</span>
<span class="gi">+                # If the first attempt failed, don&#39;t wait for the</span>
<span class="gi">+                # timeout to try an address from the secondary queue.</span>
<span class="gi">+                self.io_loop.remove_timeout(self.timeout)</span>
<span class="gi">+                self.on_timeout()</span>
<span class="gi">+            return</span>
<span class="gi">+        self.clear_timeouts()</span>
<span class="gi">+        if self.future.done():</span>
<span class="gi">+            # This is a late arrival; just drop it.</span>
<span class="gi">+            stream.close()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.streams.discard(stream)</span>
<span class="gi">+            self.future.set_result((af, addr, stream))</span>
<span class="gi">+            self.close_streams()</span>
<span class="gi">+</span>
<span class="gi">+    def set_timeout(self, timeout: float) -&gt; None:</span>
<span class="gi">+        self.timeout = self.io_loop.add_timeout(</span>
<span class="gi">+            self.io_loop.time() + timeout, self.on_timeout</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def on_timeout(self) -&gt; None:</span>
<span class="gi">+        self.timeout = None</span>
<span class="gi">+        if not self.future.done():</span>
<span class="gi">+            self.try_connect(iter(self.secondary_addrs))</span>
<span class="gi">+</span>
<span class="gi">+    def clear_timeout(self) -&gt; None:</span>
<span class="gi">+        if self.timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self.timeout)</span>
<span class="gi">+</span>
<span class="gi">+    def set_connect_timeout(</span>
<span class="gi">+        self, connect_timeout: Union[float, datetime.timedelta]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.connect_timeout = self.io_loop.add_timeout(</span>
<span class="gi">+            connect_timeout, self.on_connect_timeout</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def on_connect_timeout(self) -&gt; None:</span>
<span class="gi">+        if not self.future.done():</span>
<span class="gi">+            self.future.set_exception(TimeoutError())</span>
<span class="gi">+        self.close_streams()</span>
<span class="gi">+</span>
<span class="gi">+    def clear_timeouts(self) -&gt; None:</span>
<span class="gi">+        if self.timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self.timeout)</span>
<span class="gi">+        if self.connect_timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self.connect_timeout)</span>
<span class="gi">+</span>
<span class="gi">+    def close_streams(self) -&gt; None:</span>
<span class="gi">+        for stream in self.streams:</span>
<span class="gi">+            stream.close()</span>


<span class="w"> </span>class TCPClient(object):
<span class="gu">@@ -69,7 +206,7 @@ class TCPClient(object):</span>
<span class="w"> </span>       The ``io_loop`` argument (deprecated since version 4.1) has been removed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, resolver: Optional[Resolver]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, resolver: Optional[Resolver] = None) -&gt; None:</span>
<span class="w"> </span>        if resolver is not None:
<span class="w"> </span>            self.resolver = resolver
<span class="w"> </span>            self._own_resolver = False
<span class="gu">@@ -77,11 +214,21 @@ class TCPClient(object):</span>
<span class="w"> </span>            self.resolver = Resolver()
<span class="w"> </span>            self._own_resolver = True

<span class="gd">-    async def connect(self, host: str, port: int, af: socket.AddressFamily=</span>
<span class="gd">-        socket.AF_UNSPEC, ssl_options: Optional[Union[Dict[str, Any], ssl.</span>
<span class="gd">-        SSLContext]]=None, max_buffer_size: Optional[int]=None, source_ip:</span>
<span class="gd">-        Optional[str]=None, source_port: Optional[int]=None, timeout:</span>
<span class="gd">-        Optional[Union[float, datetime.timedelta]]=None) -&gt;IOStream:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        if self._own_resolver:</span>
<span class="gi">+            self.resolver.close()</span>
<span class="gi">+</span>
<span class="gi">+    async def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host: str,</span>
<span class="gi">+        port: int,</span>
<span class="gi">+        af: socket.AddressFamily = socket.AF_UNSPEC,</span>
<span class="gi">+        ssl_options: Optional[Union[Dict[str, Any], ssl.SSLContext]] = None,</span>
<span class="gi">+        max_buffer_size: Optional[int] = None,</span>
<span class="gi">+        source_ip: Optional[str] = None,</span>
<span class="gi">+        source_port: Optional[int] = None,</span>
<span class="gi">+        timeout: Optional[Union[float, datetime.timedelta]] = None,</span>
<span class="gi">+    ) -&gt; IOStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Connect to the given host and port.

<span class="w"> </span>        Asynchronously returns an `.IOStream` (or `.SSLIOStream` if
<span class="gu">@@ -107,4 +254,79 @@ class TCPClient(object):</span>
<span class="w"> </span>        .. versionchanged:: 5.0
<span class="w"> </span>           Added the ``timeout`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            if isinstance(timeout, numbers.Real):</span>
<span class="gi">+                timeout = IOLoop.current().time() + timeout</span>
<span class="gi">+            elif isinstance(timeout, datetime.timedelta):</span>
<span class="gi">+                timeout = IOLoop.current().time() + timeout.total_seconds()</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(&quot;Unsupported timeout %r&quot; % timeout)</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            addrinfo = await gen.with_timeout(</span>
<span class="gi">+                timeout, self.resolver.resolve(host, port, af)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            addrinfo = await self.resolver.resolve(host, port, af)</span>
<span class="gi">+        connector = _Connector(</span>
<span class="gi">+            addrinfo,</span>
<span class="gi">+            functools.partial(</span>
<span class="gi">+                self._create_stream,</span>
<span class="gi">+                max_buffer_size,</span>
<span class="gi">+                source_ip=source_ip,</span>
<span class="gi">+                source_port=source_port,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        af, addr, stream = await connector.start(connect_timeout=timeout)</span>
<span class="gi">+        # TODO: For better performance we could cache the (af, addr)</span>
<span class="gi">+        # information here and re-use it on subsequent connections to</span>
<span class="gi">+        # the same host. (http://tools.ietf.org/html/rfc6555#section-4.2)</span>
<span class="gi">+        if ssl_options is not None:</span>
<span class="gi">+            if timeout is not None:</span>
<span class="gi">+                stream = await gen.with_timeout(</span>
<span class="gi">+                    timeout,</span>
<span class="gi">+                    stream.start_tls(</span>
<span class="gi">+                        False, ssl_options=ssl_options, server_hostname=host</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                stream = await stream.start_tls(</span>
<span class="gi">+                    False, ssl_options=ssl_options, server_hostname=host</span>
<span class="gi">+                )</span>
<span class="gi">+        return stream</span>
<span class="gi">+</span>
<span class="gi">+    def _create_stream(</span>
<span class="gi">+        self,</span>
<span class="gi">+        max_buffer_size: int,</span>
<span class="gi">+        af: socket.AddressFamily,</span>
<span class="gi">+        addr: Tuple,</span>
<span class="gi">+        source_ip: Optional[str] = None,</span>
<span class="gi">+        source_port: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; Tuple[IOStream, &quot;Future[IOStream]&quot;]:</span>
<span class="gi">+        # Always connect in plaintext; we&#39;ll convert to ssl if necessary</span>
<span class="gi">+        # after one connection has completed.</span>
<span class="gi">+        source_port_bind = source_port if isinstance(source_port, int) else 0</span>
<span class="gi">+        source_ip_bind = source_ip</span>
<span class="gi">+        if source_port_bind and not source_ip:</span>
<span class="gi">+            # User required a specific port, but did not specify</span>
<span class="gi">+            # a certain source IP, will bind to the default loopback.</span>
<span class="gi">+            source_ip_bind = &quot;::1&quot; if af == socket.AF_INET6 else &quot;127.0.0.1&quot;</span>
<span class="gi">+            # Trying to use the same address family as the requested af socket:</span>
<span class="gi">+            # - 127.0.0.1 for IPv4</span>
<span class="gi">+            # - ::1 for IPv6</span>
<span class="gi">+        socket_obj = socket.socket(af)</span>
<span class="gi">+        if source_port_bind or source_ip_bind:</span>
<span class="gi">+            # If the user requires binding also to a specific IP/port.</span>
<span class="gi">+            try:</span>
<span class="gi">+                socket_obj.bind((source_ip_bind, source_port_bind))</span>
<span class="gi">+            except socket.error:</span>
<span class="gi">+                socket_obj.close()</span>
<span class="gi">+                # Fail loudly if unable to use the IP/port.</span>
<span class="gi">+                raise</span>
<span class="gi">+        try:</span>
<span class="gi">+            stream = IOStream(socket_obj, max_buffer_size=max_buffer_size)</span>
<span class="gi">+        except socket.error as e:</span>
<span class="gi">+            fu = Future()  # type: Future[IOStream]</span>
<span class="gi">+            fu.set_exception(e)</span>
<span class="gi">+            return stream, fu</span>
<span class="gi">+        else:</span>
<span class="gi">+            return stream, stream.connect(addr)</span>
<span class="gh">diff --git a/tornado/tcpserver.py b/tornado/tcpserver.py</span>
<span class="gh">index be5dca18..02c0ca0c 100644</span>
<span class="gd">--- a/tornado/tcpserver.py</span>
<span class="gi">+++ b/tornado/tcpserver.py</span>
<span class="gu">@@ -1,23 +1,47 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2011 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A non-blocking, single-threaded TCP server.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import errno
<span class="w"> </span>import os
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="gi">+</span>
<span class="w"> </span>from tornado import gen
<span class="w"> </span>from tornado.log import app_log
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.iostream import IOStream, SSLIOStream
<span class="gd">-from tornado.netutil import bind_sockets, add_accept_handler, ssl_wrap_socket, _DEFAULT_BACKLOG</span>
<span class="gi">+from tornado.netutil import (</span>
<span class="gi">+    bind_sockets,</span>
<span class="gi">+    add_accept_handler,</span>
<span class="gi">+    ssl_wrap_socket,</span>
<span class="gi">+    _DEFAULT_BACKLOG,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado import process
<span class="w"> </span>from tornado.util import errno_from_exception
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Union, Dict, Any, Iterable, Optional, Awaitable
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Callable, List</span>
<span class="gi">+    from typing import Callable, List  # noqa: F401</span>


<span class="w"> </span>class TCPServer(object):
<span class="gd">-    &quot;&quot;&quot;A non-blocking, single-threaded TCP server.</span>
<span class="gi">+    r&quot;&quot;&quot;A non-blocking, single-threaded TCP server.</span>

<span class="w"> </span>    To use `TCPServer`, define a subclass which overrides the `handle_stream`
<span class="w"> </span>    method. For example, a simple echo server could be defined like this::
<span class="gu">@@ -29,7 +53,7 @@ class TCPServer(object):</span>
<span class="w"> </span>          async def handle_stream(self, stream, address):
<span class="w"> </span>              while True:
<span class="w"> </span>                  try:
<span class="gd">-                      data = await stream.read_until(b&quot;\\n&quot;) await</span>
<span class="gi">+                      data = await stream.read_until(b&quot;\n&quot;) await</span>
<span class="w"> </span>                      stream.write(data)
<span class="w"> </span>                  except StreamClosedError:
<span class="w"> </span>                      break
<span class="gu">@@ -97,31 +121,50 @@ class TCPServer(object):</span>
<span class="w"> </span>       The ``io_loop`` argument has been removed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, ssl_options: Optional[Union[Dict[str, Any], ssl.</span>
<span class="gd">-        SSLContext]]=None, max_buffer_size: Optional[int]=None,</span>
<span class="gd">-        read_chunk_size: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ssl_options: Optional[Union[Dict[str, Any], ssl.SSLContext]] = None,</span>
<span class="gi">+        max_buffer_size: Optional[int] = None,</span>
<span class="gi">+        read_chunk_size: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.ssl_options = ssl_options
<span class="gd">-        self._sockets = {}</span>
<span class="gd">-        self._handlers = {}</span>
<span class="gd">-        self._pending_sockets = []</span>
<span class="gi">+        self._sockets = {}  # type: Dict[int, socket.socket]</span>
<span class="gi">+        self._handlers = {}  # type: Dict[int, Callable[[], None]]</span>
<span class="gi">+        self._pending_sockets = []  # type: List[socket.socket]</span>
<span class="w"> </span>        self._started = False
<span class="w"> </span>        self._stopped = False
<span class="w"> </span>        self.max_buffer_size = max_buffer_size
<span class="w"> </span>        self.read_chunk_size = read_chunk_size
<span class="gi">+</span>
<span class="gi">+        # Verify the SSL options. Otherwise we don&#39;t get errors until clients</span>
<span class="gi">+        # connect. This doesn&#39;t verify that the keys are legitimate, but</span>
<span class="gi">+        # the SSL module doesn&#39;t do that until there is a connected socket</span>
<span class="gi">+        # which seems like too much work</span>
<span class="w"> </span>        if self.ssl_options is not None and isinstance(self.ssl_options, dict):
<span class="gd">-            if &#39;certfile&#39; not in self.ssl_options:</span>
<span class="gi">+            # Only certfile is required: it can contain both keys</span>
<span class="gi">+            if &quot;certfile&quot; not in self.ssl_options:</span>
<span class="w"> </span>                raise KeyError(&#39;missing key &quot;certfile&quot; in ssl_options&#39;)
<span class="gd">-            if not os.path.exists(self.ssl_options[&#39;certfile&#39;]):</span>
<span class="gd">-                raise ValueError(&#39;certfile &quot;%s&quot; does not exist&#39; % self.</span>
<span class="gd">-                    ssl_options[&#39;certfile&#39;])</span>
<span class="gd">-            if &#39;keyfile&#39; in self.ssl_options and not os.path.exists(self.</span>
<span class="gd">-                ssl_options[&#39;keyfile&#39;]):</span>
<span class="gd">-                raise ValueError(&#39;keyfile &quot;%s&quot; does not exist&#39; % self.</span>
<span class="gd">-                    ssl_options[&#39;keyfile&#39;])</span>
<span class="gd">-</span>
<span class="gd">-    def listen(self, port: int, address: Optional[str]=None, family: socket</span>
<span class="gd">-        .AddressFamily=socket.AF_UNSPEC, backlog: int=_DEFAULT_BACKLOG,</span>
<span class="gd">-        flags: Optional[int]=None, reuse_port: bool=False) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+            if not os.path.exists(self.ssl_options[&quot;certfile&quot;]):</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &#39;certfile &quot;%s&quot; does not exist&#39; % self.ssl_options[&quot;certfile&quot;]</span>
<span class="gi">+                )</span>
<span class="gi">+            if &quot;keyfile&quot; in self.ssl_options and not os.path.exists(</span>
<span class="gi">+                self.ssl_options[&quot;keyfile&quot;]</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &#39;keyfile &quot;%s&quot; does not exist&#39; % self.ssl_options[&quot;keyfile&quot;]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def listen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        port: int,</span>
<span class="gi">+        address: Optional[str] = None,</span>
<span class="gi">+        family: socket.AddressFamily = socket.AF_UNSPEC,</span>
<span class="gi">+        backlog: int = _DEFAULT_BACKLOG,</span>
<span class="gi">+        flags: Optional[int] = None,</span>
<span class="gi">+        reuse_port: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts accepting connections on the given port.

<span class="w"> </span>        This method may be called more than once to listen on multiple ports.
<span class="gu">@@ -137,9 +180,17 @@ class TCPServer(object):</span>
<span class="w"> </span>           Added ``family``, ``backlog``, ``flags``, and ``reuse_port``
<span class="w"> </span>           arguments to match `tornado.netutil.bind_sockets`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_sockets(self, sockets: Iterable[socket.socket]) -&gt;None:</span>
<span class="gi">+        sockets = bind_sockets(</span>
<span class="gi">+            port,</span>
<span class="gi">+            address=address,</span>
<span class="gi">+            family=family,</span>
<span class="gi">+            backlog=backlog,</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            reuse_port=reuse_port,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.add_sockets(sockets)</span>
<span class="gi">+</span>
<span class="gi">+    def add_sockets(self, sockets: Iterable[socket.socket]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Makes this server start accepting connections on the given sockets.

<span class="w"> </span>        The ``sockets`` parameter is a list of socket objects such as
<span class="gu">@@ -148,15 +199,25 @@ class TCPServer(object):</span>
<span class="w"> </span>        method and `tornado.process.fork_processes` to provide greater
<span class="w"> </span>        control over the initialization of a multi-process server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for sock in sockets:</span>
<span class="gi">+            self._sockets[sock.fileno()] = sock</span>
<span class="gi">+            self._handlers[sock.fileno()] = add_accept_handler(</span>
<span class="gi">+                sock, self._handle_connection</span>
<span class="gi">+            )</span>

<span class="gd">-    def add_socket(self, socket: socket.socket) -&gt;None:</span>
<span class="gi">+    def add_socket(self, socket: socket.socket) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Singular version of `add_sockets`.  Takes a single socket object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def bind(self, port: int, address: Optional[str]=None, family: socket.</span>
<span class="gd">-        AddressFamily=socket.AF_UNSPEC, backlog: int=_DEFAULT_BACKLOG,</span>
<span class="gd">-        flags: Optional[int]=None, reuse_port: bool=False) -&gt;None:</span>
<span class="gi">+        self.add_sockets([socket])</span>
<span class="gi">+</span>
<span class="gi">+    def bind(</span>
<span class="gi">+        self,</span>
<span class="gi">+        port: int,</span>
<span class="gi">+        address: Optional[str] = None,</span>
<span class="gi">+        family: socket.AddressFamily = socket.AF_UNSPEC,</span>
<span class="gi">+        backlog: int = _DEFAULT_BACKLOG,</span>
<span class="gi">+        flags: Optional[int] = None,</span>
<span class="gi">+        reuse_port: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Binds this server to the given port on the given address.

<span class="w"> </span>        To start the server, call `start`. If you want to run this server in a
<span class="gu">@@ -187,10 +248,22 @@ class TCPServer(object):</span>
<span class="w"> </span>           Use either ``listen()`` or ``add_sockets()`` instead of ``bind()``
<span class="w"> </span>           and ``start()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def start(self, num_processes: Optional[int]=1, max_restarts: Optional[</span>
<span class="gd">-        int]=None) -&gt;None:</span>
<span class="gi">+        sockets = bind_sockets(</span>
<span class="gi">+            port,</span>
<span class="gi">+            address=address,</span>
<span class="gi">+            family=family,</span>
<span class="gi">+            backlog=backlog,</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            reuse_port=reuse_port,</span>
<span class="gi">+        )</span>
<span class="gi">+        if self._started:</span>
<span class="gi">+            self.add_sockets(sockets)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._pending_sockets.extend(sockets)</span>
<span class="gi">+</span>
<span class="gi">+    def start(</span>
<span class="gi">+        self, num_processes: Optional[int] = 1, max_restarts: Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts this server in the `.IOLoop`.

<span class="w"> </span>        By default, we run the server in this process and do not fork any
<span class="gu">@@ -222,18 +295,32 @@ class TCPServer(object):</span>
<span class="w"> </span>           Use either ``listen()`` or ``add_sockets()`` instead of ``bind()``
<span class="w"> </span>           and ``start()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert not self._started</span>
<span class="gi">+        self._started = True</span>
<span class="gi">+        if num_processes != 1:</span>
<span class="gi">+            process.fork_processes(num_processes, max_restarts)</span>
<span class="gi">+        sockets = self._pending_sockets</span>
<span class="gi">+        self._pending_sockets = []</span>
<span class="gi">+        self.add_sockets(sockets)</span>

<span class="gd">-    def stop(self) -&gt;None:</span>
<span class="gi">+    def stop(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stops listening for new connections.

<span class="w"> </span>        Requests currently in progress may still continue after the
<span class="w"> </span>        server is stopped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def handle_stream(self, stream: IOStream, address: tuple) -&gt;Optional[</span>
<span class="gd">-        Awaitable[None]]:</span>
<span class="gi">+        if self._stopped:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._stopped = True</span>
<span class="gi">+        for fd, sock in self._sockets.items():</span>
<span class="gi">+            assert sock.fileno() == fd</span>
<span class="gi">+            # Unregister socket from IOLoop</span>
<span class="gi">+            self._handlers.pop(fd)()</span>
<span class="gi">+            sock.close()</span>
<span class="gi">+</span>
<span class="gi">+    def handle_stream(</span>
<span class="gi">+        self, stream: IOStream, address: tuple</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to handle a new `.IOStream` from an incoming connection.

<span class="w"> </span>        This method may be a coroutine; if so any exceptions it raises
<span class="gu">@@ -248,4 +335,56 @@ class TCPServer(object):</span>
<span class="w"> </span>        .. versionchanged:: 4.2
<span class="w"> </span>           Added the option for this method to be a coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_connection(self, connection: socket.socket, address: Any) -&gt; None:</span>
<span class="gi">+        if self.ssl_options is not None:</span>
<span class="gi">+            assert ssl, &quot;Python 2.6+ and OpenSSL required for SSL&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                connection = ssl_wrap_socket(</span>
<span class="gi">+                    connection,</span>
<span class="gi">+                    self.ssl_options,</span>
<span class="gi">+                    server_side=True,</span>
<span class="gi">+                    do_handshake_on_connect=False,</span>
<span class="gi">+                )</span>
<span class="gi">+            except ssl.SSLError as err:</span>
<span class="gi">+                if err.args[0] == ssl.SSL_ERROR_EOF:</span>
<span class="gi">+                    return connection.close()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+            except socket.error as err:</span>
<span class="gi">+                # If the connection is closed immediately after it is created</span>
<span class="gi">+                # (as in a port scan), we can get one of several errors.</span>
<span class="gi">+                # wrap_socket makes an internal call to getpeername,</span>
<span class="gi">+                # which may return either EINVAL (Mac OS X) or ENOTCONN</span>
<span class="gi">+                # (Linux).  If it returns ENOTCONN, this error is</span>
<span class="gi">+                # silently swallowed by the ssl module, so we need to</span>
<span class="gi">+                # catch another error later on (AttributeError in</span>
<span class="gi">+                # SSLIOStream._do_ssl_handshake).</span>
<span class="gi">+                # To test this behavior, try nmap with the -sT flag.</span>
<span class="gi">+                # https://github.com/tornadoweb/tornado/pull/750</span>
<span class="gi">+                if errno_from_exception(err) in (errno.ECONNABORTED, errno.EINVAL):</span>
<span class="gi">+                    return connection.close()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.ssl_options is not None:</span>
<span class="gi">+                stream = SSLIOStream(</span>
<span class="gi">+                    connection,</span>
<span class="gi">+                    max_buffer_size=self.max_buffer_size,</span>
<span class="gi">+                    read_chunk_size=self.read_chunk_size,</span>
<span class="gi">+                )  # type: IOStream</span>
<span class="gi">+            else:</span>
<span class="gi">+                stream = IOStream(</span>
<span class="gi">+                    connection,</span>
<span class="gi">+                    max_buffer_size=self.max_buffer_size,</span>
<span class="gi">+                    read_chunk_size=self.read_chunk_size,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            future = self.handle_stream(stream, address)</span>
<span class="gi">+            if future is not None:</span>
<span class="gi">+                IOLoop.current().add_future(</span>
<span class="gi">+                    gen.convert_yielded(future), lambda f: f.result()</span>
<span class="gi">+                )</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            app_log.error(&quot;Error in connection callback&quot;, exc_info=True)</span>
<span class="gh">diff --git a/tornado/template.py b/tornado/template.py</span>
<span class="gh">index 1f082087..d53e977c 100644</span>
<span class="gd">--- a/tornado/template.py</span>
<span class="gi">+++ b/tornado/template.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A simple template system that compiles templates to Python code.

<span class="w"> </span>Basic usage looks like::
<span class="gu">@@ -180,6 +195,7 @@ To include a literal ``{{``, ``{%``, or ``{#`` in the output, escape them as</span>
<span class="w"> </span>    (or until the next ``{% whitespace %}`` directive). See
<span class="w"> </span>    `filter_whitespace` for available options. New in Tornado 4.3.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>from io import StringIO
<span class="w"> </span>import linecache
<span class="gu">@@ -187,14 +203,18 @@ import os.path</span>
<span class="w"> </span>import posixpath
<span class="w"> </span>import re
<span class="w"> </span>import threading
<span class="gi">+</span>
<span class="w"> </span>from tornado import escape
<span class="w"> </span>from tornado.log import app_log
<span class="w"> </span>from tornado.util import ObjectDict, exec_in, unicode_type
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Union, Callable, List, Dict, Iterable, Optional, TextIO
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Tuple, ContextManager</span>
<span class="gd">-_DEFAULT_AUTOESCAPE = &#39;xhtml_escape&#39;</span>
<span class="gi">+    from typing import Tuple, ContextManager  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+_DEFAULT_AUTOESCAPE = &quot;xhtml_escape&quot;</span>


<span class="w"> </span>class _UnsetMarker:
<span class="gu">@@ -204,7 +224,7 @@ class _UnsetMarker:</span>
<span class="w"> </span>_UNSET = _UnsetMarker()


<span class="gd">-def filter_whitespace(mode: str, text: str) -&gt;str:</span>
<span class="gi">+def filter_whitespace(mode: str, text: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transform whitespace in ``text`` according to ``mode``.

<span class="w"> </span>    Available modes are:
<span class="gu">@@ -217,7 +237,16 @@ def filter_whitespace(mode: str, text: str) -&gt;str:</span>

<span class="w"> </span>    .. versionadded:: 4.3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mode == &quot;all&quot;:</span>
<span class="gi">+        return text</span>
<span class="gi">+    elif mode == &quot;single&quot;:</span>
<span class="gi">+        text = re.sub(r&quot;([\t ]+)&quot;, &quot; &quot;, text)</span>
<span class="gi">+        text = re.sub(r&quot;(\s*\n\s*)&quot;, &quot;\n&quot;, text)</span>
<span class="gi">+        return text</span>
<span class="gi">+    elif mode == &quot;oneline&quot;:</span>
<span class="gi">+        return re.sub(r&quot;(\s+)&quot;, &quot; &quot;, text)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise Exception(&quot;invalid whitespace mode %s&quot; % mode)</span>


<span class="w"> </span>class Template(object):
<span class="gu">@@ -227,11 +256,18 @@ class Template(object):</span>
<span class="w"> </span>    the template from variables with generate().
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, template_string: Union[str, bytes], name: str=</span>
<span class="gd">-        &#39;&lt;string&gt;&#39;, loader: Optional[&#39;BaseLoader&#39;]=None,</span>
<span class="gd">-        compress_whitespace: Union[bool, _UnsetMarker]=_UNSET, autoescape:</span>
<span class="gd">-        Optional[Union[str, _UnsetMarker]]=_UNSET, whitespace: Optional[str</span>
<span class="gd">-        ]=None) -&gt;None:</span>
<span class="gi">+    # note that the constructor&#39;s signature is not extracted with</span>
<span class="gi">+    # autodoc because _UNSET looks like garbage.  When changing</span>
<span class="gi">+    # this signature update website/sphinx/template.rst too.</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        template_string: Union[str, bytes],</span>
<span class="gi">+        name: str = &quot;&lt;string&gt;&quot;,</span>
<span class="gi">+        loader: Optional[&quot;BaseLoader&quot;] = None,</span>
<span class="gi">+        compress_whitespace: Union[bool, _UnsetMarker] = _UNSET,</span>
<span class="gi">+        autoescape: Optional[Union[str, _UnsetMarker]] = _UNSET,</span>
<span class="gi">+        whitespace: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Construct a Template.

<span class="w"> </span>        :arg str template_string: the contents of the template file.
<span class="gu">@@ -251,44 +287,106 @@ class Template(object):</span>
<span class="w"> </span>           Added ``whitespace`` parameter; deprecated ``compress_whitespace``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.name = escape.native_str(name)
<span class="gi">+</span>
<span class="w"> </span>        if compress_whitespace is not _UNSET:
<span class="gi">+            # Convert deprecated compress_whitespace (bool) to whitespace (str).</span>
<span class="w"> </span>            if whitespace is not None:
<span class="gd">-                raise Exception(</span>
<span class="gd">-                    &#39;cannot set both whitespace and compress_whitespace&#39;)</span>
<span class="gd">-            whitespace = &#39;single&#39; if compress_whitespace else &#39;all&#39;</span>
<span class="gi">+                raise Exception(&quot;cannot set both whitespace and compress_whitespace&quot;)</span>
<span class="gi">+            whitespace = &quot;single&quot; if compress_whitespace else &quot;all&quot;</span>
<span class="w"> </span>        if whitespace is None:
<span class="w"> </span>            if loader and loader.whitespace:
<span class="w"> </span>                whitespace = loader.whitespace
<span class="gd">-            elif name.endswith(&#39;.html&#39;) or name.endswith(&#39;.js&#39;):</span>
<span class="gd">-                whitespace = &#39;single&#39;</span>
<span class="w"> </span>            else:
<span class="gd">-                whitespace = &#39;all&#39;</span>
<span class="gi">+                # Whitespace defaults by filename.</span>
<span class="gi">+                if name.endswith(&quot;.html&quot;) or name.endswith(&quot;.js&quot;):</span>
<span class="gi">+                    whitespace = &quot;single&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    whitespace = &quot;all&quot;</span>
<span class="gi">+        # Validate the whitespace setting.</span>
<span class="w"> </span>        assert whitespace is not None
<span class="gd">-        filter_whitespace(whitespace, &#39;&#39;)</span>
<span class="gi">+        filter_whitespace(whitespace, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if not isinstance(autoescape, _UnsetMarker):
<span class="gd">-            self.autoescape = autoescape</span>
<span class="gi">+            self.autoescape = autoescape  # type: Optional[str]</span>
<span class="w"> </span>        elif loader:
<span class="w"> </span>            self.autoescape = loader.autoescape
<span class="w"> </span>        else:
<span class="w"> </span>            self.autoescape = _DEFAULT_AUTOESCAPE
<span class="gi">+</span>
<span class="w"> </span>        self.namespace = loader.namespace if loader else {}
<span class="gd">-        reader = _TemplateReader(name, escape.native_str(template_string),</span>
<span class="gd">-            whitespace)</span>
<span class="gi">+        reader = _TemplateReader(name, escape.native_str(template_string), whitespace)</span>
<span class="w"> </span>        self.file = _File(self, _parse(reader, self))
<span class="w"> </span>        self.code = self._generate_python(loader)
<span class="w"> </span>        self.loader = loader
<span class="w"> </span>        try:
<span class="gd">-            self.compiled = compile(escape.to_unicode(self.code), </span>
<span class="gd">-                &#39;%s.generated.py&#39; % self.name.replace(&#39;.&#39;, &#39;_&#39;), &#39;exec&#39;,</span>
<span class="gd">-                dont_inherit=True)</span>
<span class="gi">+            # Under python2.5, the fake filename used here must match</span>
<span class="gi">+            # the module name used in __name__ below.</span>
<span class="gi">+            # The dont_inherit flag prevents template.py&#39;s future imports</span>
<span class="gi">+            # from being applied to the generated code.</span>
<span class="gi">+            self.compiled = compile(</span>
<span class="gi">+                escape.to_unicode(self.code),</span>
<span class="gi">+                &quot;%s.generated.py&quot; % self.name.replace(&quot;.&quot;, &quot;_&quot;),</span>
<span class="gi">+                &quot;exec&quot;,</span>
<span class="gi">+                dont_inherit=True,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except Exception:
<span class="w"> </span>            formatted_code = _format_code(self.code).rstrip()
<span class="gd">-            app_log.error(&#39;%s code:\n%s&#39;, self.name, formatted_code)</span>
<span class="gi">+            app_log.error(&quot;%s code:\n%s&quot;, self.name, formatted_code)</span>
<span class="w"> </span>            raise

<span class="gd">-    def generate(self, **kwargs: Any) -&gt;bytes:</span>
<span class="gi">+    def generate(self, **kwargs: Any) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate this template with the given arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        namespace = {</span>
<span class="gi">+            &quot;escape&quot;: escape.xhtml_escape,</span>
<span class="gi">+            &quot;xhtml_escape&quot;: escape.xhtml_escape,</span>
<span class="gi">+            &quot;url_escape&quot;: escape.url_escape,</span>
<span class="gi">+            &quot;json_encode&quot;: escape.json_encode,</span>
<span class="gi">+            &quot;squeeze&quot;: escape.squeeze,</span>
<span class="gi">+            &quot;linkify&quot;: escape.linkify,</span>
<span class="gi">+            &quot;datetime&quot;: datetime,</span>
<span class="gi">+            &quot;_tt_utf8&quot;: escape.utf8,  # for internal use</span>
<span class="gi">+            &quot;_tt_string_types&quot;: (unicode_type, bytes),</span>
<span class="gi">+            # __name__ and __loader__ allow the traceback mechanism to find</span>
<span class="gi">+            # the generated source code.</span>
<span class="gi">+            &quot;__name__&quot;: self.name.replace(&quot;.&quot;, &quot;_&quot;),</span>
<span class="gi">+            &quot;__loader__&quot;: ObjectDict(get_source=lambda name: self.code),</span>
<span class="gi">+        }</span>
<span class="gi">+        namespace.update(self.namespace)</span>
<span class="gi">+        namespace.update(kwargs)</span>
<span class="gi">+        exec_in(self.compiled, namespace)</span>
<span class="gi">+        execute = typing.cast(Callable[[], bytes], namespace[&quot;_tt_execute&quot;])</span>
<span class="gi">+        # Clear the traceback module&#39;s cache of source data now that</span>
<span class="gi">+        # we&#39;ve generated a new template (mainly for this module&#39;s</span>
<span class="gi">+        # unittests, where different tests reuse the same name).</span>
<span class="gi">+        linecache.clearcache()</span>
<span class="gi">+        return execute()</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_python(self, loader: Optional[&quot;BaseLoader&quot;]) -&gt; str:</span>
<span class="gi">+        buffer = StringIO()</span>
<span class="gi">+        try:</span>
<span class="gi">+            # named_blocks maps from names to _NamedBlock objects</span>
<span class="gi">+            named_blocks = {}  # type: Dict[str, _NamedBlock]</span>
<span class="gi">+            ancestors = self._get_ancestors(loader)</span>
<span class="gi">+            ancestors.reverse()</span>
<span class="gi">+            for ancestor in ancestors:</span>
<span class="gi">+                ancestor.find_named_blocks(loader, named_blocks)</span>
<span class="gi">+            writer = _CodeWriter(buffer, named_blocks, loader, ancestors[0].template)</span>
<span class="gi">+            ancestors[0].generate(writer)</span>
<span class="gi">+            return buffer.getvalue()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            buffer.close()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_ancestors(self, loader: Optional[&quot;BaseLoader&quot;]) -&gt; List[&quot;_File&quot;]:</span>
<span class="gi">+        ancestors = [self.file]</span>
<span class="gi">+        for chunk in self.file.body.chunks:</span>
<span class="gi">+            if isinstance(chunk, _ExtendsBlock):</span>
<span class="gi">+                if not loader:</span>
<span class="gi">+                    raise ParseError(</span>
<span class="gi">+                        &quot;{% extends %} block found, but no &quot; &quot;template loader&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                template = loader.load(chunk.name, self.name)</span>
<span class="gi">+                ancestors.extend(template._get_ancestors(loader))</span>
<span class="gi">+        return ancestors</span>


<span class="w"> </span>class BaseLoader(object):
<span class="gu">@@ -299,8 +397,12 @@ class BaseLoader(object):</span>
<span class="w"> </span>    templates after they are loaded the first time.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, autoescape: str=_DEFAULT_AUTOESCAPE, namespace:</span>
<span class="gd">-        Optional[Dict[str, Any]]=None, whitespace: Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        autoescape: str = _DEFAULT_AUTOESCAPE,</span>
<span class="gi">+        namespace: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        whitespace: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Construct a template loader.

<span class="w"> </span>        :arg str autoescape: The name of a function in the template
<span class="gu">@@ -319,131 +421,281 @@ class BaseLoader(object):</span>
<span class="w"> </span>        self.autoescape = autoescape
<span class="w"> </span>        self.namespace = namespace or {}
<span class="w"> </span>        self.whitespace = whitespace
<span class="gd">-        self.templates = {}</span>
<span class="gi">+        self.templates = {}  # type: Dict[str, Template]</span>
<span class="gi">+        # self.lock protects self.templates.  It&#39;s a reentrant lock</span>
<span class="gi">+        # because templates may load other templates via `include` or</span>
<span class="gi">+        # `extends`.  Note that thanks to the GIL this code would be safe</span>
<span class="gi">+        # even without the lock, but could lead to wasted work as multiple</span>
<span class="gi">+        # threads tried to compile the same template simultaneously.</span>
<span class="w"> </span>        self.lock = threading.RLock()

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the cache of compiled templates.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self.templates = {}</span>

<span class="gd">-    def resolve_path(self, name: str, parent_path: Optional[str]=None) -&gt;str:</span>
<span class="gi">+    def resolve_path(self, name: str, parent_path: Optional[str] = None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a possibly-relative path to absolute (used internally).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def load(self, name: str, parent_path: Optional[str]=None) -&gt;Template:</span>
<span class="gi">+    def load(self, name: str, parent_path: Optional[str] = None) -&gt; Template:</span>
<span class="w"> </span>        &quot;&quot;&quot;Loads a template.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self.resolve_path(name, parent_path=parent_path)</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if name not in self.templates:</span>
<span class="gi">+                self.templates[name] = self._create_template(name)</span>
<span class="gi">+            return self.templates[name]</span>
<span class="gi">+</span>
<span class="gi">+    def _create_template(self, name: str) -&gt; Template:</span>
<span class="gi">+        raise NotImplementedError()</span>


<span class="w"> </span>class Loader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;A template loader that loads from a single root directory.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, root_directory: str, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, root_directory: str, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.root = os.path.abspath(root_directory)

<span class="gi">+    def resolve_path(self, name: str, parent_path: Optional[str] = None) -&gt; str:</span>
<span class="gi">+        if (</span>
<span class="gi">+            parent_path</span>
<span class="gi">+            and not parent_path.startswith(&quot;&lt;&quot;)</span>
<span class="gi">+            and not parent_path.startswith(&quot;/&quot;)</span>
<span class="gi">+            and not name.startswith(&quot;/&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            current_path = os.path.join(self.root, parent_path)</span>
<span class="gi">+            file_dir = os.path.dirname(os.path.abspath(current_path))</span>
<span class="gi">+            relative_path = os.path.abspath(os.path.join(file_dir, name))</span>
<span class="gi">+            if relative_path.startswith(self.root):</span>
<span class="gi">+                name = relative_path[len(self.root) + 1 :]</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def _create_template(self, name: str) -&gt; Template:</span>
<span class="gi">+        path = os.path.join(self.root, name)</span>
<span class="gi">+        with open(path, &quot;rb&quot;) as f:</span>
<span class="gi">+            template = Template(f.read(), name=name, loader=self)</span>
<span class="gi">+            return template</span>
<span class="gi">+</span>

<span class="w"> </span>class DictLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;A template loader that loads from a dictionary.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, dict: Dict[str, str], **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, dict: Dict[str, str], **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.dict = dict

<span class="gi">+    def resolve_path(self, name: str, parent_path: Optional[str] = None) -&gt; str:</span>
<span class="gi">+        if (</span>
<span class="gi">+            parent_path</span>
<span class="gi">+            and not parent_path.startswith(&quot;&lt;&quot;)</span>
<span class="gi">+            and not parent_path.startswith(&quot;/&quot;)</span>
<span class="gi">+            and not name.startswith(&quot;/&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            file_dir = posixpath.dirname(parent_path)</span>
<span class="gi">+            name = posixpath.normpath(posixpath.join(file_dir, name))</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def _create_template(self, name: str) -&gt; Template:</span>
<span class="gi">+        return Template(self.dict[name], name=name, loader=self)</span>
<span class="gi">+</span>

<span class="w"> </span>class _Node(object):
<span class="gd">-    pass</span>
<span class="gi">+    def each_child(self) -&gt; Iterable[&quot;_Node&quot;]:</span>
<span class="gi">+        return ()</span>

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-class _File(_Node):</span>
<span class="gi">+    def find_named_blocks(</span>
<span class="gi">+        self, loader: Optional[BaseLoader], named_blocks: Dict[str, &quot;_NamedBlock&quot;]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for child in self.each_child():</span>
<span class="gi">+            child.find_named_blocks(loader, named_blocks)</span>

<span class="gd">-    def __init__(self, template: Template, body: &#39;_ChunkList&#39;) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class _File(_Node):</span>
<span class="gi">+    def __init__(self, template: Template, body: &quot;_ChunkList&quot;) -&gt; None:</span>
<span class="w"> </span>        self.template = template
<span class="w"> </span>        self.body = body
<span class="w"> </span>        self.line = 0

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        writer.write_line(&quot;def _tt_execute():&quot;, self.line)</span>
<span class="gi">+        with writer.indent():</span>
<span class="gi">+            writer.write_line(&quot;_tt_buffer = []&quot;, self.line)</span>
<span class="gi">+            writer.write_line(&quot;_tt_append = _tt_buffer.append&quot;, self.line)</span>
<span class="gi">+            self.body.generate(writer)</span>
<span class="gi">+            writer.write_line(&quot;return _tt_utf8(&#39;&#39;).join(_tt_buffer)&quot;, self.line)</span>
<span class="gi">+</span>
<span class="gi">+    def each_child(self) -&gt; Iterable[&quot;_Node&quot;]:</span>
<span class="gi">+        return (self.body,)</span>

<span class="gd">-class _ChunkList(_Node):</span>

<span class="gd">-    def __init__(self, chunks: List[_Node]) -&gt;None:</span>
<span class="gi">+class _ChunkList(_Node):</span>
<span class="gi">+    def __init__(self, chunks: List[_Node]) -&gt; None:</span>
<span class="w"> </span>        self.chunks = chunks

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        for chunk in self.chunks:</span>
<span class="gi">+            chunk.generate(writer)</span>

<span class="gd">-class _NamedBlock(_Node):</span>
<span class="gi">+    def each_child(self) -&gt; Iterable[&quot;_Node&quot;]:</span>
<span class="gi">+        return self.chunks</span>

<span class="gd">-    def __init__(self, name: str, body: _Node, template: Template, line: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class _NamedBlock(_Node):</span>
<span class="gi">+    def __init__(self, name: str, body: _Node, template: Template, line: int) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.body = body
<span class="w"> </span>        self.template = template
<span class="w"> </span>        self.line = line

<span class="gi">+    def each_child(self) -&gt; Iterable[&quot;_Node&quot;]:</span>
<span class="gi">+        return (self.body,)</span>

<span class="gd">-class _ExtendsBlock(_Node):</span>
<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        block = writer.named_blocks[self.name]</span>
<span class="gi">+        with writer.include(block.template, self.line):</span>
<span class="gi">+            block.body.generate(writer)</span>
<span class="gi">+</span>
<span class="gi">+    def find_named_blocks(</span>
<span class="gi">+        self, loader: Optional[BaseLoader], named_blocks: Dict[str, &quot;_NamedBlock&quot;]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        named_blocks[self.name] = self</span>
<span class="gi">+        _Node.find_named_blocks(self, loader, named_blocks)</span>

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class _ExtendsBlock(_Node):</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name


<span class="w"> </span>class _IncludeBlock(_Node):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name: str, reader: &#39;_TemplateReader&#39;, line: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str, reader: &quot;_TemplateReader&quot;, line: int) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.template_name = reader.name
<span class="w"> </span>        self.line = line

<span class="gi">+    def find_named_blocks(</span>
<span class="gi">+        self, loader: Optional[BaseLoader], named_blocks: Dict[str, _NamedBlock]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert loader is not None</span>
<span class="gi">+        included = loader.load(self.name, self.template_name)</span>
<span class="gi">+        included.file.find_named_blocks(loader, named_blocks)</span>

<span class="gd">-class _ApplyBlock(_Node):</span>
<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        assert writer.loader is not None</span>
<span class="gi">+        included = writer.loader.load(self.name, self.template_name)</span>
<span class="gi">+        with writer.include(included, self.line):</span>
<span class="gi">+            included.file.body.generate(writer)</span>

<span class="gd">-    def __init__(self, method: str, line: int, body: _Node) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class _ApplyBlock(_Node):</span>
<span class="gi">+    def __init__(self, method: str, line: int, body: _Node) -&gt; None:</span>
<span class="w"> </span>        self.method = method
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.body = body

<span class="gi">+    def each_child(self) -&gt; Iterable[&quot;_Node&quot;]:</span>
<span class="gi">+        return (self.body,)</span>
<span class="gi">+</span>
<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        method_name = &quot;_tt_apply%d&quot; % writer.apply_counter</span>
<span class="gi">+        writer.apply_counter += 1</span>
<span class="gi">+        writer.write_line(&quot;def %s():&quot; % method_name, self.line)</span>
<span class="gi">+        with writer.indent():</span>
<span class="gi">+            writer.write_line(&quot;_tt_buffer = []&quot;, self.line)</span>
<span class="gi">+            writer.write_line(&quot;_tt_append = _tt_buffer.append&quot;, self.line)</span>
<span class="gi">+            self.body.generate(writer)</span>
<span class="gi">+            writer.write_line(&quot;return _tt_utf8(&#39;&#39;).join(_tt_buffer)&quot;, self.line)</span>
<span class="gi">+        writer.write_line(</span>
<span class="gi">+            &quot;_tt_append(_tt_utf8(%s(%s())))&quot; % (self.method, method_name), self.line</span>
<span class="gi">+        )</span>

<span class="gd">-class _ControlBlock(_Node):</span>

<span class="gd">-    def __init__(self, statement: str, line: int, body: _Node) -&gt;None:</span>
<span class="gi">+class _ControlBlock(_Node):</span>
<span class="gi">+    def __init__(self, statement: str, line: int, body: _Node) -&gt; None:</span>
<span class="w"> </span>        self.statement = statement
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.body = body

<span class="gi">+    def each_child(self) -&gt; Iterable[_Node]:</span>
<span class="gi">+        return (self.body,)</span>

<span class="gd">-class _IntermediateControlBlock(_Node):</span>
<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        writer.write_line(&quot;%s:&quot; % self.statement, self.line)</span>
<span class="gi">+        with writer.indent():</span>
<span class="gi">+            self.body.generate(writer)</span>
<span class="gi">+            # Just in case the body was empty</span>
<span class="gi">+            writer.write_line(&quot;pass&quot;, self.line)</span>

<span class="gd">-    def __init__(self, statement: str, line: int) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class _IntermediateControlBlock(_Node):</span>
<span class="gi">+    def __init__(self, statement: str, line: int) -&gt; None:</span>
<span class="w"> </span>        self.statement = statement
<span class="w"> </span>        self.line = line

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        # In case the previous block was empty</span>
<span class="gi">+        writer.write_line(&quot;pass&quot;, self.line)</span>
<span class="gi">+        writer.write_line(&quot;%s:&quot; % self.statement, self.line, writer.indent_size() - 1)</span>

<span class="gd">-class _Statement(_Node):</span>

<span class="gd">-    def __init__(self, statement: str, line: int) -&gt;None:</span>
<span class="gi">+class _Statement(_Node):</span>
<span class="gi">+    def __init__(self, statement: str, line: int) -&gt; None:</span>
<span class="w"> </span>        self.statement = statement
<span class="w"> </span>        self.line = line

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        writer.write_line(self.statement, self.line)</span>

<span class="gd">-class _Expression(_Node):</span>

<span class="gd">-    def __init__(self, expression: str, line: int, raw: bool=False) -&gt;None:</span>
<span class="gi">+class _Expression(_Node):</span>
<span class="gi">+    def __init__(self, expression: str, line: int, raw: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.expression = expression
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.raw = raw

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        writer.write_line(&quot;_tt_tmp = %s&quot; % self.expression, self.line)</span>
<span class="gi">+        writer.write_line(</span>
<span class="gi">+            &quot;if isinstance(_tt_tmp, _tt_string_types):&quot; &quot; _tt_tmp = _tt_utf8(_tt_tmp)&quot;,</span>
<span class="gi">+            self.line,</span>
<span class="gi">+        )</span>
<span class="gi">+        writer.write_line(&quot;else: _tt_tmp = _tt_utf8(str(_tt_tmp))&quot;, self.line)</span>
<span class="gi">+        if not self.raw and writer.current_template.autoescape is not None:</span>
<span class="gi">+            # In python3 functions like xhtml_escape return unicode,</span>
<span class="gi">+            # so we have to convert to utf8 again.</span>
<span class="gi">+            writer.write_line(</span>
<span class="gi">+                &quot;_tt_tmp = _tt_utf8(%s(_tt_tmp))&quot; % writer.current_template.autoescape,</span>
<span class="gi">+                self.line,</span>
<span class="gi">+            )</span>
<span class="gi">+        writer.write_line(&quot;_tt_append(_tt_tmp)&quot;, self.line)</span>

<span class="gd">-class _Module(_Expression):</span>

<span class="gd">-    def __init__(self, expression: str, line: int) -&gt;None:</span>
<span class="gd">-        super().__init__(&#39;_tt_modules.&#39; + expression, line, raw=True)</span>
<span class="gi">+class _Module(_Expression):</span>
<span class="gi">+    def __init__(self, expression: str, line: int) -&gt; None:</span>
<span class="gi">+        super().__init__(&quot;_tt_modules.&quot; + expression, line, raw=True)</span>


<span class="w"> </span>class _Text(_Node):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, value: str, line: int, whitespace: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: str, line: int, whitespace: str) -&gt; None:</span>
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.whitespace = whitespace

<span class="gi">+    def generate(self, writer: &quot;_CodeWriter&quot;) -&gt; None:</span>
<span class="gi">+        value = self.value</span>
<span class="gi">+</span>
<span class="gi">+        # Compress whitespace if requested, with a crude heuristic to avoid</span>
<span class="gi">+        # altering preformatted whitespace.</span>
<span class="gi">+        if &quot;&lt;pre&gt;&quot; not in value:</span>
<span class="gi">+            value = filter_whitespace(self.whitespace, value)</span>
<span class="gi">+</span>
<span class="gi">+        if value:</span>
<span class="gi">+            writer.write_line(&quot;_tt_append(%r)&quot; % escape.utf8(value), self.line)</span>
<span class="gi">+</span>

<span class="w"> </span>class ParseError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised for template syntax errors.
<span class="gu">@@ -455,42 +707,115 @@ class ParseError(Exception):</span>
<span class="w"> </span>       Added ``filename`` and ``lineno`` attributes.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, filename: Optional[str]=None, lineno:</span>
<span class="gd">-        int=0) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, message: str, filename: Optional[str] = None, lineno: int = 0</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.message = message
<span class="gi">+        # The names &quot;filename&quot; and &quot;lineno&quot; are chosen for consistency</span>
<span class="gi">+        # with python SyntaxError.</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.lineno = lineno

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;%s at %s:%d&#39; % (self.message, self.filename, self.lineno)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;%s at %s:%d&quot; % (self.message, self.filename, self.lineno)</span>


<span class="w"> </span>class _CodeWriter(object):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, file: TextIO, named_blocks: Dict[str, _NamedBlock],</span>
<span class="gd">-        loader: Optional[BaseLoader], current_template: Template) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        file: TextIO,</span>
<span class="gi">+        named_blocks: Dict[str, _NamedBlock],</span>
<span class="gi">+        loader: Optional[BaseLoader],</span>
<span class="gi">+        current_template: Template,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.file = file
<span class="w"> </span>        self.named_blocks = named_blocks
<span class="w"> </span>        self.loader = loader
<span class="w"> </span>        self.current_template = current_template
<span class="w"> </span>        self.apply_counter = 0
<span class="gd">-        self.include_stack = []</span>
<span class="gi">+        self.include_stack = []  # type: List[Tuple[Template, int]]</span>
<span class="w"> </span>        self._indent = 0

<span class="gi">+    def indent_size(self) -&gt; int:</span>
<span class="gi">+        return self._indent</span>

<span class="gd">-class _TemplateReader(object):</span>
<span class="gi">+    def indent(self) -&gt; &quot;ContextManager&quot;:</span>
<span class="gi">+        class Indenter(object):</span>
<span class="gi">+            def __enter__(_) -&gt; &quot;_CodeWriter&quot;:</span>
<span class="gi">+                self._indent += 1</span>
<span class="gi">+                return self</span>
<span class="gi">+</span>
<span class="gi">+            def __exit__(_, *args: Any) -&gt; None:</span>
<span class="gi">+                assert self._indent &gt; 0</span>
<span class="gi">+                self._indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+        return Indenter()</span>
<span class="gi">+</span>
<span class="gi">+    def include(self, template: Template, line: int) -&gt; &quot;ContextManager&quot;:</span>
<span class="gi">+        self.include_stack.append((self.current_template, line))</span>
<span class="gi">+        self.current_template = template</span>
<span class="gi">+</span>
<span class="gi">+        class IncludeTemplate(object):</span>
<span class="gi">+            def __enter__(_) -&gt; &quot;_CodeWriter&quot;:</span>
<span class="gi">+                return self</span>
<span class="gi">+</span>
<span class="gi">+            def __exit__(_, *args: Any) -&gt; None:</span>
<span class="gi">+                self.current_template = self.include_stack.pop()[0]</span>
<span class="gi">+</span>
<span class="gi">+        return IncludeTemplate()</span>

<span class="gd">-    def __init__(self, name: str, text: str, whitespace: str) -&gt;None:</span>
<span class="gi">+    def write_line(</span>
<span class="gi">+        self, line: str, line_number: int, indent: Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if indent is None:</span>
<span class="gi">+            indent = self._indent</span>
<span class="gi">+        line_comment = &quot;  # %s:%d&quot; % (self.current_template.name, line_number)</span>
<span class="gi">+        if self.include_stack:</span>
<span class="gi">+            ancestors = [</span>
<span class="gi">+                &quot;%s:%d&quot; % (tmpl.name, lineno) for (tmpl, lineno) in self.include_stack</span>
<span class="gi">+            ]</span>
<span class="gi">+            line_comment += &quot; (via %s)&quot; % &quot;, &quot;.join(reversed(ancestors))</span>
<span class="gi">+        print(&quot;    &quot; * indent + line + line_comment, file=self.file)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _TemplateReader(object):</span>
<span class="gi">+    def __init__(self, name: str, text: str, whitespace: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.whitespace = whitespace
<span class="w"> </span>        self.line = 1
<span class="w"> </span>        self.pos = 0

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def find(self, needle: str, start: int = 0, end: Optional[int] = None) -&gt; int:</span>
<span class="gi">+        assert start &gt;= 0, start</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        start += pos</span>
<span class="gi">+        if end is None:</span>
<span class="gi">+            index = self.text.find(needle, start)</span>
<span class="gi">+        else:</span>
<span class="gi">+            end += pos</span>
<span class="gi">+            assert end &gt;= start</span>
<span class="gi">+            index = self.text.find(needle, start, end)</span>
<span class="gi">+        if index != -1:</span>
<span class="gi">+            index -= pos</span>
<span class="gi">+        return index</span>
<span class="gi">+</span>
<span class="gi">+    def consume(self, count: Optional[int] = None) -&gt; str:</span>
<span class="gi">+        if count is None:</span>
<span class="gi">+            count = len(self.text) - self.pos</span>
<span class="gi">+        newpos = self.pos + count</span>
<span class="gi">+        self.line += self.text.count(&quot;\n&quot;, self.pos, newpos)</span>
<span class="gi">+        s = self.text[self.pos : newpos]</span>
<span class="gi">+        self.pos = newpos</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def remaining(self) -&gt; int:</span>
<span class="gi">+        return len(self.text) - self.pos</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self.remaining()

<span class="gd">-    def __getitem__(self, key: Union[int, slice]) -&gt;str:</span>
<span class="gi">+    def __getitem__(self, key: Union[int, slice]) -&gt; str:</span>
<span class="w"> </span>        if isinstance(key, slice):
<span class="w"> </span>            size = len(self)
<span class="w"> </span>            start, stop, step = key.indices(size)
<span class="gu">@@ -506,5 +831,217 @@ class _TemplateReader(object):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return self.text[self.pos + key]

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return self.text[self.pos:]</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return self.text[self.pos :]</span>
<span class="gi">+</span>
<span class="gi">+    def raise_parse_error(self, msg: str) -&gt; None:</span>
<span class="gi">+        raise ParseError(msg, self.name, self.line)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_code(code: str) -&gt; str:</span>
<span class="gi">+    lines = code.splitlines()</span>
<span class="gi">+    format = &quot;%%%dd  %%s\n&quot; % len(repr(len(lines) + 1))</span>
<span class="gi">+    return &quot;&quot;.join([format % (i + 1, line) for (i, line) in enumerate(lines)])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse(</span>
<span class="gi">+    reader: _TemplateReader,</span>
<span class="gi">+    template: Template,</span>
<span class="gi">+    in_block: Optional[str] = None,</span>
<span class="gi">+    in_loop: Optional[str] = None,</span>
<span class="gi">+) -&gt; _ChunkList:</span>
<span class="gi">+    body = _ChunkList([])</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # Find next template directive</span>
<span class="gi">+        curly = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            curly = reader.find(&quot;{&quot;, curly)</span>
<span class="gi">+            if curly == -1 or curly + 1 == reader.remaining():</span>
<span class="gi">+                # EOF</span>
<span class="gi">+                if in_block:</span>
<span class="gi">+                    reader.raise_parse_error(</span>
<span class="gi">+                        &quot;Missing {%% end %%} block for %s&quot; % in_block</span>
<span class="gi">+                    )</span>
<span class="gi">+                body.chunks.append(</span>
<span class="gi">+                    _Text(reader.consume(), reader.line, reader.whitespace)</span>
<span class="gi">+                )</span>
<span class="gi">+                return body</span>
<span class="gi">+            # If the first curly brace is not the start of a special token,</span>
<span class="gi">+            # start searching from the character after it</span>
<span class="gi">+            if reader[curly + 1] not in (&quot;{&quot;, &quot;%&quot;, &quot;#&quot;):</span>
<span class="gi">+                curly += 1</span>
<span class="gi">+                continue</span>
<span class="gi">+            # When there are more than 2 curlies in a row, use the</span>
<span class="gi">+            # innermost ones.  This is useful when generating languages</span>
<span class="gi">+            # like latex where curlies are also meaningful</span>
<span class="gi">+            if (</span>
<span class="gi">+                curly + 2 &lt; reader.remaining()</span>
<span class="gi">+                and reader[curly + 1] == &quot;{&quot;</span>
<span class="gi">+                and reader[curly + 2] == &quot;{&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                curly += 1</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        # Append any text before the special token</span>
<span class="gi">+        if curly &gt; 0:</span>
<span class="gi">+            cons = reader.consume(curly)</span>
<span class="gi">+            body.chunks.append(_Text(cons, reader.line, reader.whitespace))</span>
<span class="gi">+</span>
<span class="gi">+        start_brace = reader.consume(2)</span>
<span class="gi">+        line = reader.line</span>
<span class="gi">+</span>
<span class="gi">+        # Template directives may be escaped as &quot;{{!&quot; or &quot;{%!&quot;.</span>
<span class="gi">+        # In this case output the braces and consume the &quot;!&quot;.</span>
<span class="gi">+        # This is especially useful in conjunction with jquery templates,</span>
<span class="gi">+        # which also use double braces.</span>
<span class="gi">+        if reader.remaining() and reader[0] == &quot;!&quot;:</span>
<span class="gi">+            reader.consume(1)</span>
<span class="gi">+            body.chunks.append(_Text(start_brace, line, reader.whitespace))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # Comment</span>
<span class="gi">+        if start_brace == &quot;{#&quot;:</span>
<span class="gi">+            end = reader.find(&quot;#}&quot;)</span>
<span class="gi">+            if end == -1:</span>
<span class="gi">+                reader.raise_parse_error(&quot;Missing end comment #}&quot;)</span>
<span class="gi">+            contents = reader.consume(end).strip()</span>
<span class="gi">+            reader.consume(2)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # Expression</span>
<span class="gi">+        if start_brace == &quot;{{&quot;:</span>
<span class="gi">+            end = reader.find(&quot;}}&quot;)</span>
<span class="gi">+            if end == -1:</span>
<span class="gi">+                reader.raise_parse_error(&quot;Missing end expression }}&quot;)</span>
<span class="gi">+            contents = reader.consume(end).strip()</span>
<span class="gi">+            reader.consume(2)</span>
<span class="gi">+            if not contents:</span>
<span class="gi">+                reader.raise_parse_error(&quot;Empty expression&quot;)</span>
<span class="gi">+            body.chunks.append(_Expression(contents, line))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # Block</span>
<span class="gi">+        assert start_brace == &quot;{%&quot;, start_brace</span>
<span class="gi">+        end = reader.find(&quot;%}&quot;)</span>
<span class="gi">+        if end == -1:</span>
<span class="gi">+            reader.raise_parse_error(&quot;Missing end block %}&quot;)</span>
<span class="gi">+        contents = reader.consume(end).strip()</span>
<span class="gi">+        reader.consume(2)</span>
<span class="gi">+        if not contents:</span>
<span class="gi">+            reader.raise_parse_error(&quot;Empty block tag ({% %})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        operator, space, suffix = contents.partition(&quot; &quot;)</span>
<span class="gi">+        suffix = suffix.strip()</span>
<span class="gi">+</span>
<span class="gi">+        # Intermediate (&quot;else&quot;, &quot;elif&quot;, etc) blocks</span>
<span class="gi">+        intermediate_blocks = {</span>
<span class="gi">+            &quot;else&quot;: set([&quot;if&quot;, &quot;for&quot;, &quot;while&quot;, &quot;try&quot;]),</span>
<span class="gi">+            &quot;elif&quot;: set([&quot;if&quot;]),</span>
<span class="gi">+            &quot;except&quot;: set([&quot;try&quot;]),</span>
<span class="gi">+            &quot;finally&quot;: set([&quot;try&quot;]),</span>
<span class="gi">+        }</span>
<span class="gi">+        allowed_parents = intermediate_blocks.get(operator)</span>
<span class="gi">+        if allowed_parents is not None:</span>
<span class="gi">+            if not in_block:</span>
<span class="gi">+                reader.raise_parse_error(</span>
<span class="gi">+                    &quot;%s outside %s block&quot; % (operator, allowed_parents)</span>
<span class="gi">+                )</span>
<span class="gi">+            if in_block not in allowed_parents:</span>
<span class="gi">+                reader.raise_parse_error(</span>
<span class="gi">+                    &quot;%s block cannot be attached to %s block&quot; % (operator, in_block)</span>
<span class="gi">+                )</span>
<span class="gi">+            body.chunks.append(_IntermediateControlBlock(contents, line))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # End tag</span>
<span class="gi">+        elif operator == &quot;end&quot;:</span>
<span class="gi">+            if not in_block:</span>
<span class="gi">+                reader.raise_parse_error(&quot;Extra {% end %} block&quot;)</span>
<span class="gi">+            return body</span>
<span class="gi">+</span>
<span class="gi">+        elif operator in (</span>
<span class="gi">+            &quot;extends&quot;,</span>
<span class="gi">+            &quot;include&quot;,</span>
<span class="gi">+            &quot;set&quot;,</span>
<span class="gi">+            &quot;import&quot;,</span>
<span class="gi">+            &quot;from&quot;,</span>
<span class="gi">+            &quot;comment&quot;,</span>
<span class="gi">+            &quot;autoescape&quot;,</span>
<span class="gi">+            &quot;whitespace&quot;,</span>
<span class="gi">+            &quot;raw&quot;,</span>
<span class="gi">+            &quot;module&quot;,</span>
<span class="gi">+        ):</span>
<span class="gi">+            if operator == &quot;comment&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if operator == &quot;extends&quot;:</span>
<span class="gi">+                suffix = suffix.strip(&#39;&quot;&#39;).strip(&quot;&#39;&quot;)</span>
<span class="gi">+                if not suffix:</span>
<span class="gi">+                    reader.raise_parse_error(&quot;extends missing file path&quot;)</span>
<span class="gi">+                block = _ExtendsBlock(suffix)  # type: _Node</span>
<span class="gi">+            elif operator in (&quot;import&quot;, &quot;from&quot;):</span>
<span class="gi">+                if not suffix:</span>
<span class="gi">+                    reader.raise_parse_error(&quot;import missing statement&quot;)</span>
<span class="gi">+                block = _Statement(contents, line)</span>
<span class="gi">+            elif operator == &quot;include&quot;:</span>
<span class="gi">+                suffix = suffix.strip(&#39;&quot;&#39;).strip(&quot;&#39;&quot;)</span>
<span class="gi">+                if not suffix:</span>
<span class="gi">+                    reader.raise_parse_error(&quot;include missing file path&quot;)</span>
<span class="gi">+                block = _IncludeBlock(suffix, reader, line)</span>
<span class="gi">+            elif operator == &quot;set&quot;:</span>
<span class="gi">+                if not suffix:</span>
<span class="gi">+                    reader.raise_parse_error(&quot;set missing statement&quot;)</span>
<span class="gi">+                block = _Statement(suffix, line)</span>
<span class="gi">+            elif operator == &quot;autoescape&quot;:</span>
<span class="gi">+                fn = suffix.strip()  # type: Optional[str]</span>
<span class="gi">+                if fn == &quot;None&quot;:</span>
<span class="gi">+                    fn = None</span>
<span class="gi">+                template.autoescape = fn</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif operator == &quot;whitespace&quot;:</span>
<span class="gi">+                mode = suffix.strip()</span>
<span class="gi">+                # Validate the selected mode</span>
<span class="gi">+                filter_whitespace(mode, &quot;&quot;)</span>
<span class="gi">+                reader.whitespace = mode</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif operator == &quot;raw&quot;:</span>
<span class="gi">+                block = _Expression(suffix, line, raw=True)</span>
<span class="gi">+            elif operator == &quot;module&quot;:</span>
<span class="gi">+                block = _Module(suffix, line)</span>
<span class="gi">+            body.chunks.append(block)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        elif operator in (&quot;apply&quot;, &quot;block&quot;, &quot;try&quot;, &quot;if&quot;, &quot;for&quot;, &quot;while&quot;):</span>
<span class="gi">+            # parse inner body recursively</span>
<span class="gi">+            if operator in (&quot;for&quot;, &quot;while&quot;):</span>
<span class="gi">+                block_body = _parse(reader, template, operator, operator)</span>
<span class="gi">+            elif operator == &quot;apply&quot;:</span>
<span class="gi">+                # apply creates a nested function so syntactically it&#39;s not</span>
<span class="gi">+                # in the loop.</span>
<span class="gi">+                block_body = _parse(reader, template, operator, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                block_body = _parse(reader, template, operator, in_loop)</span>
<span class="gi">+</span>
<span class="gi">+            if operator == &quot;apply&quot;:</span>
<span class="gi">+                if not suffix:</span>
<span class="gi">+                    reader.raise_parse_error(&quot;apply missing method name&quot;)</span>
<span class="gi">+                block = _ApplyBlock(suffix, line, block_body)</span>
<span class="gi">+            elif operator == &quot;block&quot;:</span>
<span class="gi">+                if not suffix:</span>
<span class="gi">+                    reader.raise_parse_error(&quot;block missing name&quot;)</span>
<span class="gi">+                block = _NamedBlock(suffix, block_body, template, line)</span>
<span class="gi">+            else:</span>
<span class="gi">+                block = _ControlBlock(contents, line, block_body)</span>
<span class="gi">+            body.chunks.append(block)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        elif operator in (&quot;break&quot;, &quot;continue&quot;):</span>
<span class="gi">+            if not in_loop:</span>
<span class="gi">+                reader.raise_parse_error(</span>
<span class="gi">+                    &quot;%s outside %s block&quot; % (operator, set([&quot;for&quot;, &quot;while&quot;]))</span>
<span class="gi">+                )</span>
<span class="gi">+            body.chunks.append(_Statement(contents, line))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            reader.raise_parse_error(&quot;unknown operator: %r&quot; % operator)</span>
<span class="gh">diff --git a/tornado/testing.py b/tornado/testing.py</span>
<span class="gh">index 0dea2c63..4c33b3e2 100644</span>
<span class="gd">--- a/tornado/testing.py</span>
<span class="gi">+++ b/tornado/testing.py</span>
<span class="gu">@@ -8,6 +8,7 @@</span>
<span class="w"> </span>* `main()`: A simple test runner (wrapper around unittest.main()) with support
<span class="w"> </span>  for the tornado.autoreload module to rerun the tests when code changes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>from collections.abc import Generator
<span class="w"> </span>import functools
<span class="gu">@@ -20,6 +21,7 @@ import socket</span>
<span class="w"> </span>import sys
<span class="w"> </span>import unittest
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from tornado import gen
<span class="w"> </span>from tornado.httpclient import AsyncHTTPClient, HTTPResponse
<span class="w"> </span>from tornado.httpserver import HTTPServer
<span class="gu">@@ -30,17 +32,23 @@ from tornado.process import Subprocess</span>
<span class="w"> </span>from tornado.log import app_log
<span class="w"> </span>from tornado.util import raise_exc_info, basestring_type
<span class="w"> </span>from tornado.web import Application
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Tuple, Any, Callable, Type, Dict, Union, Optional, Coroutine
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    _ExcInfoTuple = Tuple[Optional[Type[BaseException]], Optional[</span>
<span class="gd">-        BaseException], Optional[TracebackType]]</span>
<span class="gi">+    _ExcInfoTuple = Tuple[</span>
<span class="gi">+        Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_NON_OWNED_IOLOOPS = AsyncIOMainLoop


<span class="gd">-def bind_unused_port(reuse_port: bool=False, address: str=&#39;127.0.0.1&#39;) -&gt;Tuple[</span>
<span class="gd">-    socket.socket, int]:</span>
<span class="gi">+def bind_unused_port(</span>
<span class="gi">+    reuse_port: bool = False, address: str = &quot;127.0.0.1&quot;</span>
<span class="gi">+) -&gt; Tuple[socket.socket, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Binds a server socket to an available port on localhost.

<span class="w"> </span>    Returns a tuple (socket, port).
<span class="gu">@@ -53,17 +61,27 @@ def bind_unused_port(reuse_port: bool=False, address: str=&#39;127.0.0.1&#39;) -&gt;Tuple[</span>
<span class="w"> </span>       Added optional ``address`` argument to
<span class="w"> </span>       override the default &quot;127.0.0.1&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sock = netutil.bind_sockets(</span>
<span class="gi">+        0, address, family=socket.AF_INET, reuse_port=reuse_port</span>
<span class="gi">+    )[0]</span>
<span class="gi">+    port = sock.getsockname()[1]</span>
<span class="gi">+    return sock, port</span>


<span class="gd">-def get_async_test_timeout() -&gt;float:</span>
<span class="gi">+def get_async_test_timeout() -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the global timeout setting for async tests.

<span class="w"> </span>    Returns a float, the timeout in seconds.

<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    env = os.environ.get(&quot;ASYNC_TEST_TIMEOUT&quot;)</span>
<span class="gi">+    if env is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return float(env)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return 5</span>


<span class="w"> </span>class AsyncTestCase(unittest.TestCase):
<span class="gu">@@ -114,16 +132,80 @@ class AsyncTestCase(unittest.TestCase):</span>
<span class="w"> </span>                self.assertIn(&quot;FriendFeed&quot;, response.body)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, methodName: str=&#39;runTest&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, methodName: str = &quot;runTest&quot;) -&gt; None:</span>
<span class="w"> </span>        super().__init__(methodName)
<span class="w"> </span>        self.__stopped = False
<span class="w"> </span>        self.__running = False
<span class="gd">-        self.__failure = None</span>
<span class="gd">-        self.__stop_args = None</span>
<span class="gd">-        self.__timeout = None</span>
<span class="gd">-        self._test_generator = None</span>
<span class="gd">-</span>
<span class="gd">-    def get_new_ioloop(self) -&gt;IOLoop:</span>
<span class="gi">+        self.__failure = None  # type: Optional[_ExcInfoTuple]</span>
<span class="gi">+        self.__stop_args = None  # type: Any</span>
<span class="gi">+        self.__timeout = None  # type: Optional[object]</span>
<span class="gi">+</span>
<span class="gi">+        # Not used in this class itself, but used by @gen_test</span>
<span class="gi">+        self._test_generator = None  # type: Optional[Union[Generator, Coroutine]]</span>
<span class="gi">+</span>
<span class="gi">+    def setUp(self) -&gt; None:</span>
<span class="gi">+        py_ver = sys.version_info</span>
<span class="gi">+        if ((3, 10, 0) &lt;= py_ver &lt; (3, 10, 9)) or ((3, 11, 0) &lt;= py_ver &lt;= (3, 11, 1)):</span>
<span class="gi">+            # Early releases in the Python 3.10 and 3.1 series had deprecation</span>
<span class="gi">+            # warnings that were later reverted; we must suppress them here.</span>
<span class="gi">+            setup_with_context_manager(self, warnings.catch_warnings())</span>
<span class="gi">+            warnings.filterwarnings(</span>
<span class="gi">+                &quot;ignore&quot;,</span>
<span class="gi">+                message=&quot;There is no current event loop&quot;,</span>
<span class="gi">+                category=DeprecationWarning,</span>
<span class="gi">+                module=r&quot;tornado\..*&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+        super().setUp()</span>
<span class="gi">+        if type(self).get_new_ioloop is not AsyncTestCase.get_new_ioloop:</span>
<span class="gi">+            warnings.warn(&quot;get_new_ioloop is deprecated&quot;, DeprecationWarning)</span>
<span class="gi">+        self.io_loop = self.get_new_ioloop()</span>
<span class="gi">+        asyncio.set_event_loop(self.io_loop.asyncio_loop)  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def tearDown(self) -&gt; None:</span>
<span class="gi">+        # Native coroutines tend to produce warnings if they&#39;re not</span>
<span class="gi">+        # allowed to run to completion. It&#39;s difficult to ensure that</span>
<span class="gi">+        # this always happens in tests, so cancel any tasks that are</span>
<span class="gi">+        # still pending by the time we get here.</span>
<span class="gi">+        asyncio_loop = self.io_loop.asyncio_loop  # type: ignore</span>
<span class="gi">+        tasks = asyncio.all_tasks(asyncio_loop)</span>
<span class="gi">+        # Tasks that are done may still appear here and may contain</span>
<span class="gi">+        # non-cancellation exceptions, so filter them out.</span>
<span class="gi">+        tasks = [t for t in tasks if not t.done()]  # type: ignore</span>
<span class="gi">+        for t in tasks:</span>
<span class="gi">+            t.cancel()</span>
<span class="gi">+        # Allow the tasks to run and finalize themselves (which means</span>
<span class="gi">+        # raising a CancelledError inside the coroutine). This may</span>
<span class="gi">+        # just transform the &quot;task was destroyed but it is pending&quot;</span>
<span class="gi">+        # warning into a &quot;uncaught CancelledError&quot; warning, but</span>
<span class="gi">+        # catching CancelledErrors in coroutines that may leak is</span>
<span class="gi">+        # simpler than ensuring that no coroutines leak.</span>
<span class="gi">+        if tasks:</span>
<span class="gi">+            done, pending = self.io_loop.run_sync(lambda: asyncio.wait(tasks))</span>
<span class="gi">+            assert not pending</span>
<span class="gi">+            # If any task failed with anything but a CancelledError, raise it.</span>
<span class="gi">+            for f in done:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    f.result()</span>
<span class="gi">+                except asyncio.CancelledError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+        # Clean up Subprocess, so it can be used again with a new ioloop.</span>
<span class="gi">+        Subprocess.uninitialize()</span>
<span class="gi">+        asyncio.set_event_loop(None)</span>
<span class="gi">+        if not isinstance(self.io_loop, _NON_OWNED_IOLOOPS):</span>
<span class="gi">+            # Try to clean up any file descriptors left open in the ioloop.</span>
<span class="gi">+            # This avoids leaks, especially when tests are run repeatedly</span>
<span class="gi">+            # in the same process with autoreload (because curl does not</span>
<span class="gi">+            # set FD_CLOEXEC on its file descriptors)</span>
<span class="gi">+            self.io_loop.close(all_fds=True)</span>
<span class="gi">+        super().tearDown()</span>
<span class="gi">+        # In case an exception escaped or the StackContext caught an exception</span>
<span class="gi">+        # when there wasn&#39;t a wait() to re-raise it, do so here.</span>
<span class="gi">+        # This is our last chance to raise an exception in a way that the</span>
<span class="gi">+        # unittest machinery understands.</span>
<span class="gi">+        self.__rethrow()</span>
<span class="gi">+</span>
<span class="gi">+    def get_new_ioloop(self) -&gt; IOLoop:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the `.IOLoop` to use for this test.

<span class="w"> </span>        By default, a new `.IOLoop` is created for each test.
<span class="gu">@@ -137,9 +219,38 @@ class AsyncTestCase(unittest.TestCase):</span>
<span class="w"> </span>        .. deprecated:: 6.3
<span class="w"> </span>           This method will be removed in Tornado 7.0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _callTestMethod(self, method: Callable) -&gt;None:</span>
<span class="gi">+        return IOLoop(make_current=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_exception(</span>
<span class="gi">+        self, typ: Type[Exception], value: Exception, tb: TracebackType</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if self.__failure is None:</span>
<span class="gi">+            self.__failure = (typ, value, tb)</span>
<span class="gi">+        else:</span>
<span class="gi">+            app_log.error(</span>
<span class="gi">+                &quot;multiple unhandled exceptions in test&quot;, exc_info=(typ, value, tb)</span>
<span class="gi">+            )</span>
<span class="gi">+        self.stop()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def __rethrow(self) -&gt; None:</span>
<span class="gi">+        if self.__failure is not None:</span>
<span class="gi">+            failure = self.__failure</span>
<span class="gi">+            self.__failure = None</span>
<span class="gi">+            raise_exc_info(failure)</span>
<span class="gi">+</span>
<span class="gi">+    def run(</span>
<span class="gi">+        self, result: Optional[unittest.TestResult] = None</span>
<span class="gi">+    ) -&gt; Optional[unittest.TestResult]:</span>
<span class="gi">+        ret = super().run(result)</span>
<span class="gi">+        # As a last resort, if an exception escaped super.run() and wasn&#39;t</span>
<span class="gi">+        # re-raised in tearDown, raise it here.  This will cause the</span>
<span class="gi">+        # unittest run to fail messily, but that&#39;s better than silently</span>
<span class="gi">+        # ignoring an error.</span>
<span class="gi">+        self.__rethrow()</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def _callTestMethod(self, method: Callable) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Run the given test method, raising an error if it returns non-None.

<span class="w"> </span>        Failure to decorate asynchronous test methods with ``@gen_test`` can lead to tests
<span class="gu">@@ -152,9 +263,18 @@ class AsyncTestCase(unittest.TestCase):</span>
<span class="w"> </span>        present in all supported versions of Python (3.8+), and if it goes away in the future that&#39;s
<span class="w"> </span>        OK because we can just remove this override as noted above.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def stop(self, _arg: Any=None, **kwargs: Any) -&gt;None:</span>
<span class="gi">+        # Calling super()._callTestMethod would hide the return value, even in python 3.8-3.10</span>
<span class="gi">+        # where the check isn&#39;t being done for us.</span>
<span class="gi">+        result = method()</span>
<span class="gi">+        if isinstance(result, Generator) or inspect.iscoroutine(result):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Generator and coroutine test methods should be&quot;</span>
<span class="gi">+                &quot; decorated with tornado.testing.gen_test&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        elif result is not None:</span>
<span class="gi">+            raise ValueError(&quot;Return value from test method ignored: %r&quot; % result)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self, _arg: Any = None, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stops the `.IOLoop`, causing one pending (or future) call to `wait()`
<span class="w"> </span>        to return.

<span class="gu">@@ -165,10 +285,18 @@ class AsyncTestCase(unittest.TestCase):</span>

<span class="w"> </span>           `stop` and `wait` are deprecated; use ``@gen_test`` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def wait(self, condition: Optional[Callable[..., bool]]=None, timeout:</span>
<span class="gd">-        Optional[float]=None) -&gt;Any:</span>
<span class="gi">+        assert _arg is None or not kwargs</span>
<span class="gi">+        self.__stop_args = kwargs or _arg</span>
<span class="gi">+        if self.__running:</span>
<span class="gi">+            self.io_loop.stop()</span>
<span class="gi">+            self.__running = False</span>
<span class="gi">+        self.__stopped = True</span>
<span class="gi">+</span>
<span class="gi">+    def wait(</span>
<span class="gi">+        self,</span>
<span class="gi">+        condition: Optional[Callable[..., bool]] = None,</span>
<span class="gi">+        timeout: Optional[float] = None,</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs the `.IOLoop` until stop is called or timeout has passed.

<span class="w"> </span>        In the event of a timeout, an exception will be thrown. The
<span class="gu">@@ -186,7 +314,38 @@ class AsyncTestCase(unittest.TestCase):</span>

<span class="w"> </span>           `stop` and `wait` are deprecated; use ``@gen_test`` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if timeout is None:</span>
<span class="gi">+            timeout = get_async_test_timeout()</span>
<span class="gi">+</span>
<span class="gi">+        if not self.__stopped:</span>
<span class="gi">+            if timeout:</span>
<span class="gi">+</span>
<span class="gi">+                def timeout_func() -&gt; None:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        raise self.failureException(</span>
<span class="gi">+                            &quot;Async operation timed out after %s seconds&quot; % timeout</span>
<span class="gi">+                        )</span>
<span class="gi">+                    except Exception:</span>
<span class="gi">+                        self.__failure = sys.exc_info()</span>
<span class="gi">+                    self.stop()</span>
<span class="gi">+</span>
<span class="gi">+                self.__timeout = self.io_loop.add_timeout(</span>
<span class="gi">+                    self.io_loop.time() + timeout, timeout_func</span>
<span class="gi">+                )</span>
<span class="gi">+            while True:</span>
<span class="gi">+                self.__running = True</span>
<span class="gi">+                self.io_loop.start()</span>
<span class="gi">+                if self.__failure is not None or condition is None or condition():</span>
<span class="gi">+                    break</span>
<span class="gi">+            if self.__timeout is not None:</span>
<span class="gi">+                self.io_loop.remove_timeout(self.__timeout)</span>
<span class="gi">+                self.__timeout = None</span>
<span class="gi">+        assert self.__stopped</span>
<span class="gi">+        self.__stopped = False</span>
<span class="gi">+        self.__rethrow()</span>
<span class="gi">+        result = self.__stop_args</span>
<span class="gi">+        self.__stop_args = None</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class AsyncHTTPTestCase(AsyncTestCase):
<span class="gu">@@ -222,14 +381,31 @@ class AsyncHTTPTestCase(AsyncTestCase):</span>
<span class="w"> </span>    ``stop()`` and ``wait()`` yourself.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def get_app(self) -&gt;Application:</span>
<span class="gi">+    def setUp(self) -&gt; None:</span>
<span class="gi">+        super().setUp()</span>
<span class="gi">+        sock, port = bind_unused_port()</span>
<span class="gi">+        self.__port = port</span>
<span class="gi">+</span>
<span class="gi">+        self.http_client = self.get_http_client()</span>
<span class="gi">+        self._app = self.get_app()</span>
<span class="gi">+        self.http_server = self.get_http_server()</span>
<span class="gi">+        self.http_server.add_sockets([sock])</span>
<span class="gi">+</span>
<span class="gi">+    def get_http_client(self) -&gt; AsyncHTTPClient:</span>
<span class="gi">+        return AsyncHTTPClient()</span>
<span class="gi">+</span>
<span class="gi">+    def get_http_server(self) -&gt; HTTPServer:</span>
<span class="gi">+        return HTTPServer(self._app, **self.get_httpserver_options())</span>
<span class="gi">+</span>
<span class="gi">+    def get_app(self) -&gt; Application:</span>
<span class="w"> </span>        &quot;&quot;&quot;Should be overridden by subclasses to return a
<span class="w"> </span>        `tornado.web.Application` or other `.HTTPServer` callback.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def fetch(self, path: str, raise_error: bool=False, **kwargs: Any</span>
<span class="gd">-        ) -&gt;HTTPResponse:</span>
<span class="gi">+    def fetch(</span>
<span class="gi">+        self, path: str, raise_error: bool = False, **kwargs: Any</span>
<span class="gi">+    ) -&gt; HTTPResponse:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convenience method to synchronously fetch a URL.

<span class="w"> </span>        The given path will be appended to the local server&#39;s host and
<span class="gu">@@ -263,24 +439,44 @@ class AsyncHTTPTestCase(AsyncTestCase):</span>
<span class="w"> </span>           response codes.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_httpserver_options(self) -&gt;Dict[str, Any]:</span>
<span class="gi">+        if path.lower().startswith((&quot;http://&quot;, &quot;https://&quot;)):</span>
<span class="gi">+            url = path</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = self.get_url(path)</span>
<span class="gi">+        return self.io_loop.run_sync(</span>
<span class="gi">+            lambda: self.http_client.fetch(url, raise_error=raise_error, **kwargs),</span>
<span class="gi">+            timeout=get_async_test_timeout(),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_httpserver_options(self) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;May be overridden by subclasses to return additional
<span class="w"> </span>        keyword arguments for the server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {}</span>

<span class="gd">-    def get_http_port(self) -&gt;int:</span>
<span class="gi">+    def get_http_port(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the port used by the server.

<span class="w"> </span>        A new port is chosen for each test.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__port</span>
<span class="gi">+</span>
<span class="gi">+    def get_protocol(self) -&gt; str:</span>
<span class="gi">+        return &quot;http&quot;</span>

<span class="gd">-    def get_url(self, path: str) -&gt;str:</span>
<span class="gi">+    def get_url(self, path: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns an absolute url for the given path on the test server.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;%s://127.0.0.1:%s%s&quot; % (self.get_protocol(), self.get_http_port(), path)</span>
<span class="gi">+</span>
<span class="gi">+    def tearDown(self) -&gt; None:</span>
<span class="gi">+        self.http_server.stop()</span>
<span class="gi">+        self.io_loop.run_sync(</span>
<span class="gi">+            self.http_server.close_all_connections, timeout=get_async_test_timeout()</span>
<span class="gi">+        )</span>
<span class="gi">+        self.http_client.close()</span>
<span class="gi">+        del self.http_server</span>
<span class="gi">+        del self._app</span>
<span class="gi">+        super().tearDown()</span>


<span class="w"> </span>class AsyncHTTPSTestCase(AsyncHTTPTestCase):
<span class="gu">@@ -289,18 +485,55 @@ class AsyncHTTPSTestCase(AsyncHTTPTestCase):</span>
<span class="w"> </span>    Interface is generally the same as `AsyncHTTPTestCase`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def get_ssl_options(self) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def get_http_client(self) -&gt; AsyncHTTPClient:</span>
<span class="gi">+        return AsyncHTTPClient(force_instance=True, defaults=dict(validate_cert=False))</span>
<span class="gi">+</span>
<span class="gi">+    def get_httpserver_options(self) -&gt; Dict[str, Any]:</span>
<span class="gi">+        return dict(ssl_options=self.get_ssl_options())</span>
<span class="gi">+</span>
<span class="gi">+    def get_ssl_options(self) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;May be overridden by subclasses to select SSL options.

<span class="w"> </span>        By default includes a self-signed testing certificate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AsyncHTTPSTestCase.default_ssl_options()</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def default_ssl_options() -&gt; Dict[str, Any]:</span>
<span class="gi">+        # Testing keys were generated with:</span>
<span class="gi">+        # openssl req -new -keyout tornado/test/test.key \</span>
<span class="gi">+        #     -out tornado/test/test.crt \</span>
<span class="gi">+        #     -nodes -days 3650 -x509 \</span>
<span class="gi">+        #     -subj &quot;/CN=foo.example.com&quot; -addext &quot;subjectAltName = DNS:foo.example.com&quot;</span>
<span class="gi">+        module_dir = os.path.dirname(__file__)</span>
<span class="gi">+        return dict(</span>
<span class="gi">+            certfile=os.path.join(module_dir, &quot;test&quot;, &quot;test.crt&quot;),</span>
<span class="gi">+            keyfile=os.path.join(module_dir, &quot;test&quot;, &quot;test.key&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_protocol(self) -&gt; str:</span>
<span class="gi">+        return &quot;https&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def gen_test(</span>
<span class="gi">+    *, timeout: Optional[float] = None</span>
<span class="gi">+) -&gt; Callable[[Callable[..., Union[Generator, &quot;Coroutine&quot;]]], Callable[..., None]]:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload  # noqa: F811</span>
<span class="gi">+def gen_test(func: Callable[..., Union[Generator, &quot;Coroutine&quot;]]) -&gt; Callable[..., None]:</span>
<span class="gi">+    pass</span>


<span class="gd">-def gen_test(func: Optional[Callable[..., Union[Generator, &#39;Coroutine&#39;]]]=</span>
<span class="gd">-    None, timeout: Optional[float]=None) -&gt;Union[Callable[..., None],</span>
<span class="gd">-    Callable[[Callable[..., Union[Generator, &#39;Coroutine&#39;]]], Callable[...,</span>
<span class="gd">-    None]]]:</span>
<span class="gi">+def gen_test(  # noqa: F811</span>
<span class="gi">+    func: Optional[Callable[..., Union[Generator, &quot;Coroutine&quot;]]] = None,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+) -&gt; Union[</span>
<span class="gi">+    Callable[..., None],</span>
<span class="gi">+    Callable[[Callable[..., Union[Generator, &quot;Coroutine&quot;]]], Callable[..., None]],</span>
<span class="gi">+]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Testing equivalent of ``@gen.coroutine``, to be applied to test methods.

<span class="w"> </span>    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not
<span class="gu">@@ -336,10 +569,74 @@ def gen_test(func: Optional[Callable[..., Union[Generator, &#39;Coroutine&#39;]]]=</span>
<span class="w"> </span>       on functions with arguments.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-gen_test.__test__ = False</span>
<span class="gi">+    if timeout is None:</span>
<span class="gi">+        timeout = get_async_test_timeout()</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(f: Callable[..., Union[Generator, &quot;Coroutine&quot;]]) -&gt; Callable[..., None]:</span>
<span class="gi">+        # Stack up several decorators to allow us to access the generator</span>
<span class="gi">+        # object itself.  In the innermost wrapper, we capture the generator</span>
<span class="gi">+        # and save it in an attribute of self.  Next, we run the wrapped</span>
<span class="gi">+        # function through @gen.coroutine.  Finally, the coroutine is</span>
<span class="gi">+        # wrapped again to make it synchronous with run_sync.</span>
<span class="gi">+        #</span>
<span class="gi">+        # This is a good case study arguing for either some sort of</span>
<span class="gi">+        # extensibility in the gen decorators or cancellation support.</span>
<span class="gi">+        @functools.wraps(f)</span>
<span class="gi">+        def pre_coroutine(self, *args, **kwargs):</span>
<span class="gi">+            # type: (AsyncTestCase, *Any, **Any) -&gt; Union[Generator, Coroutine]</span>
<span class="gi">+            # Type comments used to avoid pypy3 bug.</span>
<span class="gi">+            result = f(self, *args, **kwargs)</span>
<span class="gi">+            if isinstance(result, Generator) or inspect.iscoroutine(result):</span>
<span class="gi">+                self._test_generator = result</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._test_generator = None</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        if inspect.iscoroutinefunction(f):</span>
<span class="gi">+            coro = pre_coroutine</span>
<span class="gi">+        else:</span>
<span class="gi">+            coro = gen.coroutine(pre_coroutine)  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(coro)</span>
<span class="gi">+        def post_coroutine(self, *args, **kwargs):</span>
<span class="gi">+            # type: (AsyncTestCase, *Any, **Any) -&gt; None</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.io_loop.run_sync(</span>
<span class="gi">+                    functools.partial(coro, self, *args, **kwargs), timeout=timeout</span>
<span class="gi">+                )</span>
<span class="gi">+            except TimeoutError as e:</span>
<span class="gi">+                # run_sync raises an error with an unhelpful traceback.</span>
<span class="gi">+                # If the underlying generator is still running, we can throw the</span>
<span class="gi">+                # exception back into it so the stack trace is replaced by the</span>
<span class="gi">+                # point where the test is stopped. The only reason the generator</span>
<span class="gi">+                # would not be running would be if it were cancelled, which means</span>
<span class="gi">+                # a native coroutine, so we can rely on the cr_running attribute.</span>
<span class="gi">+                if self._test_generator is not None and getattr(</span>
<span class="gi">+                    self._test_generator, &quot;cr_running&quot;, True</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self._test_generator.throw(e)</span>
<span class="gi">+                    # In case the test contains an overly broad except</span>
<span class="gi">+                    # clause, we may get back here.</span>
<span class="gi">+                # Coroutine was stopped or didn&#39;t raise a useful stack trace,</span>
<span class="gi">+                # so re-raise the original exception which is better than nothing.</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+        return post_coroutine</span>
<span class="gi">+</span>
<span class="gi">+    if func is not None:</span>
<span class="gi">+        # Used like:</span>
<span class="gi">+        #     @gen_test</span>
<span class="gi">+        #     def f(self):</span>
<span class="gi">+        #         pass</span>
<span class="gi">+        return wrap(func)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Used like @gen_test(timeout=10)</span>
<span class="gi">+        return wrap</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Without this attribute, nosetests will try to run gen_test as a test</span>
<span class="gi">+# anywhere it is imported.</span>
<span class="gi">+gen_test.__test__ = False  # type: ignore</span>


<span class="w"> </span>class ExpectLog(logging.Filter):
<span class="gu">@@ -360,8 +657,13 @@ class ExpectLog(logging.Filter):</span>
<span class="w"> </span>       Added the ``logged_stack`` attribute.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, logger: Union[logging.Logger, basestring_type],</span>
<span class="gd">-        regex: str, required: bool=True, level: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        logger: Union[logging.Logger, basestring_type],</span>
<span class="gi">+        regex: str,</span>
<span class="gi">+        required: bool = True,</span>
<span class="gi">+        level: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constructs an ExpectLog context manager.

<span class="w"> </span>        :param logger: Logger object (or name of logger) to watch.  Pass an
<span class="gu">@@ -392,40 +694,73 @@ class ExpectLog(logging.Filter):</span>
<span class="w"> </span>        self.logger = logger
<span class="w"> </span>        self.regex = re.compile(regex)
<span class="w"> </span>        self.required = required
<span class="gi">+        # matched and deprecated_level_matched are a counter for the respective event.</span>
<span class="w"> </span>        self.matched = 0
<span class="w"> </span>        self.deprecated_level_matched = 0
<span class="w"> </span>        self.logged_stack = False
<span class="w"> </span>        self.level = level
<span class="gd">-        self.orig_level = None</span>
<span class="gd">-</span>
<span class="gd">-    def __enter__(self) -&gt;&#39;ExpectLog&#39;:</span>
<span class="gd">-        if (self.level is not None and self.level &lt; self.logger.</span>
<span class="gd">-            getEffectiveLevel()):</span>
<span class="gi">+        self.orig_level = None  # type: Optional[int]</span>
<span class="gi">+</span>
<span class="gi">+    def filter(self, record: logging.LogRecord) -&gt; bool:</span>
<span class="gi">+        if record.exc_info:</span>
<span class="gi">+            self.logged_stack = True</span>
<span class="gi">+        message = record.getMessage()</span>
<span class="gi">+        if self.regex.match(message):</span>
<span class="gi">+            if self.level is None and record.levelno &lt; logging.WARNING:</span>
<span class="gi">+                # We&#39;re inside the logging machinery here so generating a DeprecationWarning</span>
<span class="gi">+                # here won&#39;t be reported cleanly (if warnings-as-errors is enabled, the error</span>
<span class="gi">+                # just gets swallowed by the logging module), and even if it were it would</span>
<span class="gi">+                # have the wrong stack trace. Just remember this fact and report it in</span>
<span class="gi">+                # __exit__ instead.</span>
<span class="gi">+                self.deprecated_level_matched += 1</span>
<span class="gi">+            if self.level is not None and record.levelno != self.level:</span>
<span class="gi">+                app_log.warning(</span>
<span class="gi">+                    &quot;Got expected log message %r at unexpected level (%s vs %s)&quot;</span>
<span class="gi">+                    % (message, logging.getLevelName(self.level), record.levelname)</span>
<span class="gi">+                )</span>
<span class="gi">+                return True</span>
<span class="gi">+            self.matched += 1</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; &quot;ExpectLog&quot;:</span>
<span class="gi">+        if self.level is not None and self.level &lt; self.logger.getEffectiveLevel():</span>
<span class="w"> </span>            self.orig_level = self.logger.level
<span class="w"> </span>            self.logger.setLevel(self.level)
<span class="w"> </span>        self.logger.addFilter(self)
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], tb: Optional[TracebackType]) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if self.orig_level is not None:
<span class="w"> </span>            self.logger.setLevel(self.orig_level)
<span class="w"> </span>        self.logger.removeFilter(self)
<span class="w"> </span>        if not typ and self.required and not self.matched:
<span class="gd">-            raise Exception(&#39;did not get expected log message&#39;)</span>
<span class="gd">-        if (not typ and self.required and self.deprecated_level_matched &gt;=</span>
<span class="gd">-            self.matched):</span>
<span class="gi">+            raise Exception(&quot;did not get expected log message&quot;)</span>
<span class="gi">+        if (</span>
<span class="gi">+            not typ</span>
<span class="gi">+            and self.required</span>
<span class="gi">+            and (self.deprecated_level_matched &gt;= self.matched)</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &#39;ExpectLog matched at INFO or below without level argument&#39;,</span>
<span class="gd">-                DeprecationWarning)</span>
<span class="gi">+                &quot;ExpectLog matched at INFO or below without level argument&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+            )</span>


<span class="gd">-def setup_with_context_manager(testcase: unittest.TestCase, cm: Any) -&gt;Any:</span>
<span class="gi">+# From https://nedbatchelder.com/blog/201508/using_context_managers_in_test_setup.html</span>
<span class="gi">+def setup_with_context_manager(testcase: unittest.TestCase, cm: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use a contextmanager to setUp a test case.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val = cm.__enter__()</span>
<span class="gi">+    testcase.addCleanup(cm.__exit__, None, None, None)</span>
<span class="gi">+    return val</span>


<span class="gd">-def main(**kwargs: Any) -&gt;None:</span>
<span class="gi">+def main(**kwargs: Any) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;A simple test runner.

<span class="w"> </span>    This test runner is essentially equivalent to `unittest.main` from
<span class="gu">@@ -465,8 +800,57 @@ def main(**kwargs: Any) -&gt;None:</span>
<span class="w"> </span>       by the `unittest` module (previously it would add a PASS or FAIL
<span class="w"> </span>       log message).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    from tornado.options import define, options, parse_command_line</span>
<span class="gi">+</span>
<span class="gi">+    define(</span>
<span class="gi">+        &quot;exception_on_interrupt&quot;,</span>
<span class="gi">+        type=bool,</span>
<span class="gi">+        default=True,</span>
<span class="gi">+        help=(</span>
<span class="gi">+            &quot;If true (default), ctrl-c raises a KeyboardInterrupt &quot;</span>
<span class="gi">+            &quot;exception.  This prints a stack trace but cannot interrupt &quot;</span>
<span class="gi">+            &quot;certain operations.  If false, the process is more reliably &quot;</span>
<span class="gi">+            &quot;killed, but does not print a stack trace.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # support the same options as unittest&#39;s command-line interface</span>
<span class="gi">+    define(&quot;verbose&quot;, type=bool)</span>
<span class="gi">+    define(&quot;quiet&quot;, type=bool)</span>
<span class="gi">+    define(&quot;failfast&quot;, type=bool)</span>
<span class="gi">+    define(&quot;catch&quot;, type=bool)</span>
<span class="gi">+    define(&quot;buffer&quot;, type=bool)</span>
<span class="gi">+</span>
<span class="gi">+    argv = [sys.argv[0]] + parse_command_line(sys.argv)</span>
<span class="gi">+</span>
<span class="gi">+    if not options.exception_on_interrupt:</span>
<span class="gi">+        signal.signal(signal.SIGINT, signal.SIG_DFL)</span>
<span class="gi">+</span>
<span class="gi">+    if options.verbose is not None:</span>
<span class="gi">+        kwargs[&quot;verbosity&quot;] = 2</span>
<span class="gi">+    if options.quiet is not None:</span>
<span class="gi">+        kwargs[&quot;verbosity&quot;] = 0</span>
<span class="gi">+    if options.failfast is not None:</span>
<span class="gi">+        kwargs[&quot;failfast&quot;] = True</span>
<span class="gi">+    if options.catch is not None:</span>
<span class="gi">+        kwargs[&quot;catchbreak&quot;] = True</span>
<span class="gi">+    if options.buffer is not None:</span>
<span class="gi">+        kwargs[&quot;buffer&quot;] = True</span>
<span class="gi">+</span>
<span class="gi">+    if __name__ == &quot;__main__&quot; and len(argv) == 1:</span>
<span class="gi">+        print(&quot;No tests specified&quot;, file=sys.stderr)</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+    # In order to be able to run tests by their fully-qualified name</span>
<span class="gi">+    # on the command line without importing all tests here,</span>
<span class="gi">+    # module must be set to None.  Python 3.2&#39;s unittest.main ignores</span>
<span class="gi">+    # defaultTest if no module is given (it tries to do its own</span>
<span class="gi">+    # test discovery, which is incompatible with auto2to3), so don&#39;t</span>
<span class="gi">+    # set module if we&#39;re not asking for a specific test.</span>
<span class="gi">+    if len(argv) &gt; 1:</span>
<span class="gi">+        unittest.main(module=None, argv=argv, **kwargs)  # type: ignore</span>
<span class="gi">+    else:</span>
<span class="gi">+        unittest.main(defaultTest=&quot;all&quot;, argv=argv, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/tornado/util.py b/tornado/util.py</span>
<span class="gh">index 182c7dcd..3a3a52f1 100644</span>
<span class="gd">--- a/tornado/util.py</span>
<span class="gi">+++ b/tornado/util.py</span>
<span class="gu">@@ -9,6 +9,7 @@ and its `~Configurable.configure` method, which becomes a part of the</span>
<span class="w"> </span>interface of its subclasses, including `.AsyncHTTPClient`, `.IOLoop`,
<span class="w"> </span>and `.Resolver`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import array
<span class="w"> </span>import asyncio
<span class="w"> </span>import atexit
<span class="gu">@@ -17,32 +18,67 @@ import os</span>
<span class="w"> </span>import re
<span class="w"> </span>import typing
<span class="w"> </span>import zlib
<span class="gd">-from typing import Any, Optional, Dict, Mapping, List, Tuple, Match, Callable, Type, Sequence</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Match,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    import datetime</span>
<span class="gd">-    from types import TracebackType</span>
<span class="gd">-    from typing import Union</span>
<span class="gd">-    import unittest</span>
<span class="gi">+    # Additional imports only used in type comments.</span>
<span class="gi">+    # This lets us make these imports lazy.</span>
<span class="gi">+    import datetime  # noqa: F401</span>
<span class="gi">+    from types import TracebackType  # noqa: F401</span>
<span class="gi">+    from typing import Union  # noqa: F401</span>
<span class="gi">+    import unittest  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+# Aliases for types that are spelled differently in different Python</span>
<span class="gi">+# versions. bytes_type is deprecated and no longer used in Tornado</span>
<span class="gi">+# itself but is left in case anyone outside Tornado is using it.</span>
<span class="w"> </span>bytes_type = bytes
<span class="w"> </span>unicode_type = str
<span class="w"> </span>basestring_type = str
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from sys import is_finalizing
<span class="w"> </span>except ImportError:
<span class="gi">+    # Emulate it</span>
<span class="gi">+    def _get_emulated_is_finalizing() -&gt; Callable[[], bool]:</span>
<span class="gi">+        L = []  # type: List[None]</span>
<span class="gi">+        atexit.register(lambda: L.append(None))</span>
<span class="gi">+</span>
<span class="gi">+        def is_finalizing() -&gt; bool:</span>
<span class="gi">+            # Not referencing any globals here</span>
<span class="gi">+            return L != []</span>
<span class="gi">+</span>
<span class="gi">+        return is_finalizing</span>
<span class="gi">+</span>
<span class="w"> </span>    is_finalizing = _get_emulated_is_finalizing()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# versionchanged:: 6.2</span>
<span class="gi">+# no longer our own TimeoutError, use standard asyncio class</span>
<span class="w"> </span>TimeoutError = asyncio.TimeoutError


<span class="w"> </span>class ObjectDict(Dict[str, Any]):
<span class="w"> </span>    &quot;&quot;&quot;Makes a dictionary behave like an object, with attribute-style access.&quot;&quot;&quot;

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return self[name]
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            raise AttributeError(name)

<span class="gd">-    def __setattr__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        self[name] = value


<span class="gu">@@ -53,10 +89,13 @@ class GzipDecompressor(object):</span>
<span class="w"> </span>    optional arguments, but it understands gzip headers and checksums.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # Magic parameter makes zlib module understand gzip header</span>
<span class="gi">+        # http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib</span>
<span class="gi">+        # This works on cpython and pypy, but not jython.</span>
<span class="w"> </span>        self.decompressobj = zlib.decompressobj(16 + zlib.MAX_WBITS)

<span class="gd">-    def decompress(self, value: bytes, max_length: int=0) -&gt;bytes:</span>
<span class="gi">+    def decompress(self, value: bytes, max_length: int = 0) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decompress a chunk, returning newly-available data.

<span class="w"> </span>        Some data may be buffered for later processing; `flush` must
<span class="gu">@@ -67,23 +106,23 @@ class GzipDecompressor(object):</span>
<span class="w"> </span>        in ``unconsumed_tail``; you must retrieve this value and pass
<span class="w"> </span>        it back to a future call to `decompress` if it is not empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.decompressobj.decompress(value, max_length)</span>

<span class="w"> </span>    @property
<span class="gd">-    def unconsumed_tail(self) -&gt;bytes:</span>
<span class="gi">+    def unconsumed_tail(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the unconsumed portion left over&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.decompressobj.unconsumed_tail</span>

<span class="gd">-    def flush(self) -&gt;bytes:</span>
<span class="gi">+    def flush(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return any remaining buffered data not yet returned by decompress.

<span class="w"> </span>        Also checks for errors such as truncated input.
<span class="w"> </span>        No other methods may be called on this object after `flush`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.decompressobj.flush()</span>


<span class="gd">-def import_object(name: str) -&gt;Any:</span>
<span class="gi">+def import_object(name: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Imports an object by name.

<span class="w"> </span>    ``import_object(&#39;x&#39;)`` is equivalent to ``import x``.
<span class="gu">@@ -101,10 +140,42 @@ def import_object(name: str) -&gt;Any:</span>
<span class="w"> </span>        ...
<span class="w"> </span>    ImportError: No module named missing_module
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name.count(&quot;.&quot;) == 0:</span>
<span class="gi">+        return __import__(name)</span>

<span class="gi">+    parts = name.split(&quot;.&quot;)</span>
<span class="gi">+    obj = __import__(&quot;.&quot;.join(parts[:-1]), fromlist=[parts[-1]])</span>
<span class="gi">+    try:</span>
<span class="gi">+        return getattr(obj, parts[-1])</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise ImportError(&quot;No module named %s&quot; % parts[-1])</span>

<span class="gd">-def errno_from_exception(e: BaseException) -&gt;Optional[int]:</span>
<span class="gi">+</span>
<span class="gi">+def exec_in(</span>
<span class="gi">+    code: Any, glob: Dict[str, Any], loc: Optional[Optional[Mapping[str, Any]]] = None</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    if isinstance(code, str):</span>
<span class="gi">+        # exec(string) inherits the caller&#39;s future imports; compile</span>
<span class="gi">+        # the string first to prevent that.</span>
<span class="gi">+        code = compile(code, &quot;&lt;string&gt;&quot;, &quot;exec&quot;, dont_inherit=True)</span>
<span class="gi">+    exec(code, glob, loc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def raise_exc_info(</span>
<span class="gi">+    exc_info: Tuple[Optional[type], Optional[BaseException], Optional[&quot;TracebackType&quot;]]</span>
<span class="gi">+) -&gt; typing.NoReturn:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if exc_info[1] is not None:</span>
<span class="gi">+            raise exc_info[1].with_traceback(exc_info[2])</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;raise_exc_info called with no exception&quot;)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Clear the traceback reference from our stack frame to</span>
<span class="gi">+        # minimize circular references that slow down GC.</span>
<span class="gi">+        exc_info = (None, None, None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def errno_from_exception(e: BaseException) -&gt; Optional[int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Provides the errno from an Exception object.

<span class="w"> </span>    There are cases that the errno attribute was not set so we pull
<span class="gu">@@ -113,24 +184,38 @@ def errno_from_exception(e: BaseException) -&gt;Optional[int]:</span>
<span class="w"> </span>    abstracts all that behavior to give you a safe way to get the
<span class="w"> </span>    errno.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(e, &quot;errno&quot;):</span>
<span class="gi">+        return e.errno  # type: ignore</span>
<span class="gi">+    elif e.args:</span>
<span class="gi">+        return e.args[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_alphanum = frozenset(&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _re_unescape_replacement(match: Match[str]) -&gt; str:</span>
<span class="gi">+    group = match.group(1)</span>
<span class="gi">+    if group[0] in _alphanum:</span>
<span class="gi">+        raise ValueError(&quot;cannot unescape &#39;\\\\%s&#39;&quot; % group[0])</span>
<span class="gi">+    return group</span>


<span class="gd">-_alphanum = frozenset(</span>
<span class="gd">-    &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;)</span>
<span class="gd">-_re_unescape_pattern = re.compile(&#39;\\\\(.)&#39;, re.DOTALL)</span>
<span class="gi">+_re_unescape_pattern = re.compile(r&quot;\\(.)&quot;, re.DOTALL)</span>


<span class="gd">-def re_unescape(s: str) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Unescape a string escaped by `re.escape`.</span>
<span class="gi">+def re_unescape(s: str) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Unescape a string escaped by `re.escape`.</span>

<span class="w"> </span>    May raise ``ValueError`` for regular expressions which could not
<span class="w"> </span>    have been produced by `re.escape` (for example, strings containing
<span class="gd">-    ``\\d`` cannot be unescaped).</span>
<span class="gi">+    ``\d`` cannot be unescaped).</span>

<span class="w"> </span>    .. versionadded:: 4.4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _re_unescape_pattern.sub(_re_unescape_replacement, s)</span>


<span class="w"> </span>class Configurable(object):
<span class="gu">@@ -159,12 +244,21 @@ class Configurable(object):</span>
<span class="w"> </span>       multiple levels of a class hierarchy.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __impl_class = None</span>
<span class="gd">-    __impl_kwargs = None</span>

<span class="gd">-    def __new__(cls, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+    # Type annotations on this class are mostly done with comments</span>
<span class="gi">+    # because they need to refer to Configurable, which isn&#39;t defined</span>
<span class="gi">+    # until after the class definition block. These can use regular</span>
<span class="gi">+    # annotations when our minimum python version is 3.7.</span>
<span class="gi">+    #</span>
<span class="gi">+    # There may be a clever way to use generics here to get more</span>
<span class="gi">+    # precise types (i.e. for a particular Configurable subclass T,</span>
<span class="gi">+    # all the types are subclasses of T, not just Configurable).</span>
<span class="gi">+    __impl_class = None  # type: Optional[Type[Configurable]]</span>
<span class="gi">+    __impl_kwargs = None  # type: Dict[str, Any]</span>
<span class="gi">+</span>
<span class="gi">+    def __new__(cls, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="w"> </span>        base = cls.configurable_base()
<span class="gd">-        init_kwargs = {}</span>
<span class="gi">+        init_kwargs = {}  # type: Dict[str, Any]</span>
<span class="w"> </span>        if cls is base:
<span class="w"> </span>            impl = cls.configured_class()
<span class="w"> </span>            if base.__impl_kwargs:
<span class="gu">@@ -173,13 +267,18 @@ class Configurable(object):</span>
<span class="w"> </span>            impl = cls
<span class="w"> </span>        init_kwargs.update(kwargs)
<span class="w"> </span>        if impl.configurable_base() is not base:
<span class="gi">+            # The impl class is itself configurable, so recurse.</span>
<span class="w"> </span>            return impl(*args, **init_kwargs)
<span class="w"> </span>        instance = super(Configurable, cls).__new__(impl)
<span class="gi">+        # initialize vs __init__ chosen for compatibility with AsyncHTTPClient</span>
<span class="gi">+        # singleton magic.  If we get rid of that we can switch to __init__</span>
<span class="gi">+        # here too.</span>
<span class="w"> </span>        instance.initialize(*args, **init_kwargs)
<span class="w"> </span>        return instance

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configurable_base(cls):
<span class="gi">+        # type: () -&gt; Type[Configurable]</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the base class of a configurable hierarchy.

<span class="w"> </span>        This will normally return the class in which it is defined.
<span class="gu">@@ -187,13 +286,18 @@ class Configurable(object):</span>
<span class="w"> </span>        parameter).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configurable_default(cls):
<span class="gi">+        # type: () -&gt; Type[Configurable]</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the implementation class to be used if none is configured.&quot;&quot;&quot;
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _initialize(self) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gd">-    initialize = _initialize</span>
<span class="gi">+</span>
<span class="gi">+    initialize = _initialize  # type: Callable[..., None]</span>
<span class="w"> </span>    &quot;&quot;&quot;Initialize a `Configurable` subclass instance.

<span class="w"> </span>    Configurable classes should use `initialize` instead of ``__init__``.
<span class="gu">@@ -204,18 +308,49 @@ class Configurable(object):</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configure(cls, impl, **kwargs):
<span class="gi">+        # type: (Union[None, str, Type[Configurable]], Any) -&gt; None</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the class to use when the base class is instantiated.

<span class="w"> </span>        Keyword arguments will be saved and added to the arguments passed
<span class="w"> </span>        to the constructor.  This can be used to set global defaults for
<span class="w"> </span>        some parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = cls.configurable_base()</span>
<span class="gi">+        if isinstance(impl, str):</span>
<span class="gi">+            impl = typing.cast(Type[Configurable], import_object(impl))</span>
<span class="gi">+        if impl is not None and not issubclass(impl, cls):</span>
<span class="gi">+            raise ValueError(&quot;Invalid subclass of %s&quot; % cls)</span>
<span class="gi">+        base.__impl_class = impl</span>
<span class="gi">+        base.__impl_kwargs = kwargs</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def configured_class(cls):
<span class="gi">+        # type: () -&gt; Type[Configurable]</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the currently configured class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = cls.configurable_base()</span>
<span class="gi">+        # Manually mangle the private name to see whether this base</span>
<span class="gi">+        # has been configured (and not another base higher in the</span>
<span class="gi">+        # hierarchy).</span>
<span class="gi">+        if base.__dict__.get(&quot;_Configurable__impl_class&quot;) is None:</span>
<span class="gi">+            base.__impl_class = cls.configurable_default()</span>
<span class="gi">+        if base.__impl_class is not None:</span>
<span class="gi">+            return base.__impl_class</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Should be impossible, but mypy wants an explicit check.</span>
<span class="gi">+            raise ValueError(&quot;configured class not found&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _save_configuration(cls):</span>
<span class="gi">+        # type: () -&gt; Tuple[Optional[Type[Configurable]], Dict[str, Any]]</span>
<span class="gi">+        base = cls.configurable_base()</span>
<span class="gi">+        return (base.__impl_class, base.__impl_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _restore_configuration(cls, saved):</span>
<span class="gi">+        # type: (Tuple[Optional[Type[Configurable]], Dict[str, Any]]) -&gt; None</span>
<span class="gi">+        base = cls.configurable_base()</span>
<span class="gi">+        base.__impl_class = saved[0]</span>
<span class="gi">+        base.__impl_kwargs = saved[1]</span>


<span class="w"> </span>class ArgReplacer(object):
<span class="gu">@@ -226,23 +361,44 @@ class ArgReplacer(object):</span>
<span class="w"> </span>    and similar wrappers.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, func: Callable, name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, func: Callable, name: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        try:
<span class="gd">-            self.arg_pos = self._getargnames(func).index(name)</span>
<span class="gi">+            self.arg_pos = self._getargnames(func).index(name)  # type: Optional[int]</span>
<span class="w"> </span>        except ValueError:
<span class="gi">+            # Not a positional parameter</span>
<span class="w"> </span>            self.arg_pos = None

<span class="gd">-    def get_old_value(self, args: Sequence[Any], kwargs: Dict[str, Any],</span>
<span class="gd">-        default: Any=None) -&gt;Any:</span>
<span class="gi">+    def _getargnames(self, func: Callable) -&gt; List[str]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return getfullargspec(func).args</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            if hasattr(func, &quot;func_code&quot;):</span>
<span class="gi">+                # Cython-generated code has all the attributes needed</span>
<span class="gi">+                # by inspect.getfullargspec, but the inspect module only</span>
<span class="gi">+                # works with ordinary functions. Inline the portion of</span>
<span class="gi">+                # getfullargspec that we need here. Note that for static</span>
<span class="gi">+                # functions the @cython.binding(True) decorator must</span>
<span class="gi">+                # be used (for methods it works out of the box).</span>
<span class="gi">+                code = func.func_code  # type: ignore</span>
<span class="gi">+                return code.co_varnames[: code.co_argcount]</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def get_old_value(</span>
<span class="gi">+        self, args: Sequence[Any], kwargs: Dict[str, Any], default: Any = None</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the old value of the named argument without replacing it.

<span class="w"> </span>        Returns ``default`` if the argument is not present.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.arg_pos is not None and len(args) &gt; self.arg_pos:</span>
<span class="gi">+            return args[self.arg_pos]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return kwargs.get(self.name, default)</span>

<span class="gd">-    def replace(self, new_value: Any, args: Sequence[Any], kwargs: Dict[str,</span>
<span class="gd">-        Any]) -&gt;Tuple[Any, Sequence[Any], Dict[str, Any]]:</span>
<span class="gi">+    def replace(</span>
<span class="gi">+        self, new_value: Any, args: Sequence[Any], kwargs: Dict[str, Any]</span>
<span class="gi">+    ) -&gt; Tuple[Any, Sequence[Any], Dict[str, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace the named argument in ``args, kwargs`` with ``new_value``.

<span class="w"> </span>        Returns ``(old_value, args, kwargs)``.  The returned ``args`` and
<span class="gu">@@ -252,15 +408,25 @@ class ArgReplacer(object):</span>
<span class="w"> </span>        If the named argument was not found, ``new_value`` will be added
<span class="w"> </span>        to ``kwargs`` and None will be returned as ``old_value``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.arg_pos is not None and len(args) &gt; self.arg_pos:</span>
<span class="gi">+            # The arg to replace is passed positionally</span>
<span class="gi">+            old_value = args[self.arg_pos]</span>
<span class="gi">+            args = list(args)  # *args is normally a tuple</span>
<span class="gi">+            args[self.arg_pos] = new_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The arg to replace is either omitted or passed by keyword.</span>
<span class="gi">+            old_value = kwargs.get(self.name)</span>
<span class="gi">+            kwargs[self.name] = new_value</span>
<span class="gi">+        return old_value, args, kwargs</span>


<span class="w"> </span>def timedelta_to_seconds(td):
<span class="gi">+    # type: (datetime.timedelta) -&gt; float</span>
<span class="w"> </span>    &quot;&quot;&quot;Equivalent to ``td.total_seconds()`` (introduced in Python 2.7).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return td.total_seconds()</span>


<span class="gd">-def _websocket_mask_python(mask: bytes, data: bytes) -&gt;bytes:</span>
<span class="gi">+def _websocket_mask_python(mask: bytes, data: bytes) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Websocket masking function.

<span class="w"> </span>    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.
<span class="gu">@@ -269,16 +435,28 @@ def _websocket_mask_python(mask: bytes, data: bytes) -&gt;bytes:</span>

<span class="w"> </span>    This pure-python implementation may be replaced by an optimized version when available.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mask_arr = array.array(&quot;B&quot;, mask)</span>
<span class="gi">+    unmasked_arr = array.array(&quot;B&quot;, data)</span>
<span class="gi">+    for i in range(len(data)):</span>
<span class="gi">+        unmasked_arr[i] = unmasked_arr[i] ^ mask_arr[i % 4]</span>
<span class="gi">+    return unmasked_arr.tobytes()</span>


<span class="gd">-if os.environ.get(&#39;TORNADO_NO_EXTENSION&#39;) or os.environ.get(&#39;TORNADO_EXTENSION&#39;</span>
<span class="gd">-    ) == &#39;0&#39;:</span>
<span class="gi">+if os.environ.get(&quot;TORNADO_NO_EXTENSION&quot;) or os.environ.get(&quot;TORNADO_EXTENSION&quot;) == &quot;0&quot;:</span>
<span class="gi">+    # These environment variables exist to make it easier to do performance</span>
<span class="gi">+    # comparisons; they are not guaranteed to remain supported in the future.</span>
<span class="w"> </span>    _websocket_mask = _websocket_mask_python
<span class="w"> </span>else:
<span class="w"> </span>    try:
<span class="w"> </span>        from tornado.speedups import websocket_mask as _websocket_mask
<span class="w"> </span>    except ImportError:
<span class="gd">-        if os.environ.get(&#39;TORNADO_EXTENSION&#39;) == &#39;1&#39;:</span>
<span class="gi">+        if os.environ.get(&quot;TORNADO_EXTENSION&quot;) == &quot;1&quot;:</span>
<span class="w"> </span>            raise
<span class="w"> </span>        _websocket_mask = _websocket_mask_python
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def doctests():</span>
<span class="gi">+    # type: () -&gt; unittest.TestSuite</span>
<span class="gi">+    import doctest</span>
<span class="gi">+</span>
<span class="gi">+    return doctest.DocTestSuite()</span>
<span class="gh">diff --git a/tornado/web.py b/tornado/web.py</span>
<span class="gh">index 7c62397d..03939647 100644</span>
<span class="gd">--- a/tornado/web.py</span>
<span class="gi">+++ b/tornado/web.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;``tornado.web`` provides a simple web framework with asynchronous
<span class="w"> </span>features that allow it to scale to large numbers of open connections,
<span class="w"> </span>making it ideal for `long polling
<span class="gu">@@ -44,6 +59,7 @@ request, or to limit your use of other threads to</span>
<span class="w"> </span>the executor do not refer to Tornado objects.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import binascii
<span class="w"> </span>import datetime
<span class="gu">@@ -69,6 +85,7 @@ import traceback</span>
<span class="w"> </span>import types
<span class="w"> </span>import urllib.parse
<span class="w"> </span>from urllib.parse import urlencode
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import Future, future_set_result_unless_cancelled
<span class="w"> </span>from tornado import escape
<span class="w"> </span>from tornado import gen
<span class="gu">@@ -79,17 +96,50 @@ from tornado import locale</span>
<span class="w"> </span>from tornado.log import access_log, app_log, gen_log
<span class="w"> </span>from tornado import template
<span class="w"> </span>from tornado.escape import utf8, _unicode
<span class="gd">-from tornado.routing import AnyMatches, DefaultHostMatches, HostMatches, ReversibleRouter, Rule, ReversibleRuleRouter, URLSpec, _RuleList</span>
<span class="gi">+from tornado.routing import (</span>
<span class="gi">+    AnyMatches,</span>
<span class="gi">+    DefaultHostMatches,</span>
<span class="gi">+    HostMatches,</span>
<span class="gi">+    ReversibleRouter,</span>
<span class="gi">+    Rule,</span>
<span class="gi">+    ReversibleRuleRouter,</span>
<span class="gi">+    URLSpec,</span>
<span class="gi">+    _RuleList,</span>
<span class="gi">+)</span>
<span class="w"> </span>from tornado.util import ObjectDict, unicode_type, _websocket_mask
<span class="gi">+</span>
<span class="w"> </span>url = URLSpec
<span class="gd">-from typing import Dict, Any, Union, Optional, Awaitable, Tuple, List, Callable, Iterable, Generator, Type, TypeVar, cast, overload</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Awaitable,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Set</span>
<span class="gd">-_HeaderTypes = Union[bytes, unicode_type, int, numbers.Integral, datetime.</span>
<span class="gd">-    datetime]</span>
<span class="gi">+    from typing import Set  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The following types are accepted by RequestHandler.set_header</span>
<span class="gi">+# and related methods.</span>
<span class="gi">+_HeaderTypes = Union[bytes, unicode_type, int, numbers.Integral, datetime.datetime]</span>
<span class="gi">+</span>
<span class="w"> </span>_CookieSecretTypes = Union[str, bytes, Dict[int, str], Dict[int, bytes]]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>MIN_SUPPORTED_SIGNED_VALUE_VERSION = 1
<span class="w"> </span>&quot;&quot;&quot;The oldest signed value version supported by this version of Tornado.

<span class="gu">@@ -97,6 +147,7 @@ Signed values older than this version cannot be decoded.</span>

<span class="w"> </span>.. versionadded:: 3.2.1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>MAX_SUPPORTED_SIGNED_VALUE_VERSION = 2
<span class="w"> </span>&quot;&quot;&quot;The newest signed value version supported by this version of Tornado.

<span class="gu">@@ -104,6 +155,7 @@ Signed values newer than this version cannot be decoded.</span>

<span class="w"> </span>.. versionadded:: 3.2.1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_SIGNED_VALUE_VERSION = 2
<span class="w"> </span>&quot;&quot;&quot;The signed value version produced by `.RequestHandler.create_signed_value`.

<span class="gu">@@ -111,6 +163,7 @@ May be overridden by passing a ``version`` keyword argument.</span>

<span class="w"> </span>.. versionadded:: 3.2.1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_SIGNED_VALUE_MIN_VERSION = 1
<span class="w"> </span>&quot;&quot;&quot;The oldest signed value accepted by `.RequestHandler.get_signed_cookie`.

<span class="gu">@@ -138,35 +191,56 @@ class RequestHandler(object):</span>
<span class="w"> </span>    `~RequestHandler.initialize` instead).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    SUPPORTED_METHODS = (&#39;GET&#39;, &#39;HEAD&#39;, &#39;POST&#39;, &#39;DELETE&#39;, &#39;PATCH&#39;, &#39;PUT&#39;,</span>
<span class="gd">-        &#39;OPTIONS&#39;)</span>
<span class="gd">-    _template_loaders = {}</span>
<span class="gi">+</span>
<span class="gi">+    SUPPORTED_METHODS = (&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;, &quot;PUT&quot;, &quot;OPTIONS&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    _template_loaders = {}  # type: Dict[str, template.BaseLoader]</span>
<span class="w"> </span>    _template_loader_lock = threading.Lock()
<span class="gd">-    _remove_control_chars_regex = re.compile(&#39;[\\x00-\\x08\\x0e-\\x1f]&#39;)</span>
<span class="gi">+    _remove_control_chars_regex = re.compile(r&quot;[\x00-\x08\x0e-\x1f]&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    _stream_request_body = False
<span class="gd">-    _transforms = None</span>
<span class="gd">-    path_args = None</span>
<span class="gd">-    path_kwargs = None</span>

<span class="gd">-    def __init__(self, application: &#39;Application&#39;, request: httputil.</span>
<span class="gd">-        HTTPServerRequest, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    # Will be set in _execute.</span>
<span class="gi">+    _transforms = None  # type: List[OutputTransform]</span>
<span class="gi">+    path_args = None  # type: List[str]</span>
<span class="gi">+    path_kwargs = None  # type: Dict[str, str]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        application: &quot;Application&quot;,</span>
<span class="gi">+        request: httputil.HTTPServerRequest,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="w"> </span>        self.application = application
<span class="w"> </span>        self.request = request
<span class="w"> </span>        self._headers_written = False
<span class="w"> </span>        self._finished = False
<span class="w"> </span>        self._auto_finish = True
<span class="w"> </span>        self._prepared_future = None
<span class="gd">-        self.ui = ObjectDict((n, self._ui_method(m)) for n, m in</span>
<span class="gd">-            application.ui_methods.items())</span>
<span class="gd">-        self.ui[&#39;_tt_modules&#39;] = _UIModuleNamespace(self, application.</span>
<span class="gd">-            ui_modules)</span>
<span class="gd">-        self.ui[&#39;modules&#39;] = self.ui[&#39;_tt_modules&#39;]</span>
<span class="gi">+        self.ui = ObjectDict(</span>
<span class="gi">+            (n, self._ui_method(m)) for n, m in application.ui_methods.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        # UIModules are available as both `modules` and `_tt_modules` in the</span>
<span class="gi">+        # template namespace.  Historically only `modules` was available</span>
<span class="gi">+        # but could be clobbered by user additions to the namespace.</span>
<span class="gi">+        # The template {% module %} directive looks in `_tt_modules` to avoid</span>
<span class="gi">+        # possible conflicts.</span>
<span class="gi">+        self.ui[&quot;_tt_modules&quot;] = _UIModuleNamespace(self, application.ui_modules)</span>
<span class="gi">+        self.ui[&quot;modules&quot;] = self.ui[&quot;_tt_modules&quot;]</span>
<span class="w"> </span>        self.clear()
<span class="w"> </span>        assert self.request.connection is not None
<span class="gd">-        self.request.connection.set_close_callback(self.on_connection_close)</span>
<span class="gd">-        self.initialize(**kwargs)</span>
<span class="gd">-    initialize = _initialize</span>
<span class="gi">+        # TODO: need to add set_close_callback to HTTPConnection interface</span>
<span class="gi">+        self.request.connection.set_close_callback(  # type: ignore</span>
<span class="gi">+            self.on_connection_close</span>
<span class="gi">+        )</span>
<span class="gi">+        self.initialize(**kwargs)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _initialize(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    initialize = _initialize  # type: Callable[..., None]</span>
<span class="w"> </span>    &quot;&quot;&quot;Hook for subclass initialization. Called for each request.

<span class="w"> </span>    A dictionary passed as the third argument of a ``URLSpec`` will be
<span class="gu">@@ -187,18 +261,22 @@ class RequestHandler(object):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @property
<span class="gd">-    def settings(self) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def settings(self) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;An alias for `self.application.settings &lt;Application.settings&gt;`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    head = _unimplemented_method</span>
<span class="gd">-    get = _unimplemented_method</span>
<span class="gd">-    post = _unimplemented_method</span>
<span class="gd">-    delete = _unimplemented_method</span>
<span class="gd">-    patch = _unimplemented_method</span>
<span class="gd">-    put = _unimplemented_method</span>
<span class="gd">-    options = _unimplemented_method</span>
<span class="gd">-</span>
<span class="gd">-    def prepare(self) -&gt;Optional[Awaitable[None]]:</span>
<span class="gi">+        return self.application.settings</span>
<span class="gi">+</span>
<span class="gi">+    def _unimplemented_method(self, *args: str, **kwargs: str) -&gt; None:</span>
<span class="gi">+        raise HTTPError(405)</span>
<span class="gi">+</span>
<span class="gi">+    head = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+    get = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+    post = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+    delete = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+    patch = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+    put = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+    options = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+</span>
<span class="gi">+    def prepare(self) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called at the beginning of a request before  `get`/`post`/etc.

<span class="w"> </span>        Override this method to perform common initialization regardless
<span class="gu">@@ -214,7 +292,7 @@ class RequestHandler(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def on_finish(self) -&gt;None:</span>
<span class="gi">+    def on_finish(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called after the end of a request.

<span class="w"> </span>        Override this method to perform cleanup, logging, etc.
<span class="gu">@@ -224,7 +302,7 @@ class RequestHandler(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def on_connection_close(self) -&gt;None:</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called in async handlers if the client closed the connection.

<span class="w"> </span>        Override this to clean up resources associated with
<span class="gu">@@ -238,13 +316,26 @@ class RequestHandler(object):</span>
<span class="w"> </span>        may not be called promptly after the end user closes their
<span class="w"> </span>        connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if _has_stream_request_body(self.__class__):</span>
<span class="gi">+            if not self.request._body_future.done():</span>
<span class="gi">+                self.request._body_future.set_exception(iostream.StreamClosedError())</span>
<span class="gi">+                self.request._body_future.exception()</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets all headers and content for this response.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_default_headers(self) -&gt;None:</span>
<span class="gi">+        self._headers = httputil.HTTPHeaders(</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;Server&quot;: &quot;TornadoServer/%s&quot; % tornado.version,</span>
<span class="gi">+                &quot;Content-Type&quot;: &quot;text/html; charset=UTF-8&quot;,</span>
<span class="gi">+                &quot;Date&quot;: httputil.format_timestamp(time.time()),</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+        self.set_default_headers()</span>
<span class="gi">+        self._write_buffer = []  # type: List[bytes]</span>
<span class="gi">+        self._status_code = 200</span>
<span class="gi">+        self._reason = httputil.responses[200]</span>
<span class="gi">+</span>
<span class="gi">+    def set_default_headers(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override this to set HTTP headers at the beginning of the request.

<span class="w"> </span>        For example, this is the place to set a custom ``Server`` header.
<span class="gu">@@ -254,7 +345,7 @@ class RequestHandler(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def set_status(self, status_code: int, reason: Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def set_status(self, status_code: int, reason: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the status code for our response.

<span class="w"> </span>        :arg int status_code: Response status code.
<span class="gu">@@ -267,13 +358,17 @@ class RequestHandler(object):</span>
<span class="w"> </span>           No longer validates that the response code is in
<span class="w"> </span>           `http.client.responses`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._status_code = status_code</span>
<span class="gi">+        if reason is not None:</span>
<span class="gi">+            self._reason = escape.native_str(reason)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._reason = httputil.responses.get(status_code, &quot;Unknown&quot;)</span>

<span class="gd">-    def get_status(self) -&gt;int:</span>
<span class="gi">+    def get_status(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the status code for our response.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._status_code</span>

<span class="gd">-    def set_header(self, name: str, value: _HeaderTypes) -&gt;None:</span>
<span class="gi">+    def set_header(self, name: str, value: _HeaderTypes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the given response header name and value.

<span class="w"> </span>        All header values are converted to strings (`datetime` objects
<span class="gu">@@ -281,27 +376,73 @@ class RequestHandler(object):</span>
<span class="w"> </span>        ``Date`` header).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._headers[name] = self._convert_header_value(value)</span>

<span class="gd">-    def add_header(self, name: str, value: _HeaderTypes) -&gt;None:</span>
<span class="gi">+    def add_header(self, name: str, value: _HeaderTypes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds the given response header and value.

<span class="w"> </span>        Unlike `set_header`, `add_header` may be called multiple times
<span class="w"> </span>        to return multiple values for the same header.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._headers.add(name, self._convert_header_value(value))</span>

<span class="gd">-    def clear_header(self, name: str) -&gt;None:</span>
<span class="gi">+    def clear_header(self, name: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clears an outgoing header, undoing a previous `set_header` call.

<span class="w"> </span>        Note that this method does not apply to multi-valued headers
<span class="w"> </span>        set by `add_header`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        if name in self._headers:</span>
<span class="gi">+            del self._headers[name]</span>
<span class="gi">+</span>
<span class="gi">+    _INVALID_HEADER_CHAR_RE = re.compile(r&quot;[\x00-\x1f]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_header_value(self, value: _HeaderTypes) -&gt; str:</span>
<span class="gi">+        # Convert the input value to a str. This type check is a bit</span>
<span class="gi">+        # subtle: The bytes case only executes on python 3, and the</span>
<span class="gi">+        # unicode case only executes on python 2, because the other</span>
<span class="gi">+        # cases are covered by the first match for str.</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            retval = value</span>
<span class="gi">+        elif isinstance(value, bytes):</span>
<span class="gi">+            # Non-ascii characters in headers are not well supported,</span>
<span class="gi">+            # but if you pass bytes, use latin1 so they pass through as-is.</span>
<span class="gi">+            retval = value.decode(&quot;latin1&quot;)</span>
<span class="gi">+        elif isinstance(value, numbers.Integral):</span>
<span class="gi">+            # return immediately since we know the converted value will be safe</span>
<span class="gi">+            return str(value)</span>
<span class="gi">+        elif isinstance(value, datetime.datetime):</span>
<span class="gi">+            return httputil.format_timestamp(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;Unsupported header value %r&quot; % value)</span>
<span class="gi">+        # If \n is allowed into the header, it is possible to inject</span>
<span class="gi">+        # additional headers or split the request.</span>
<span class="gi">+        if RequestHandler._INVALID_HEADER_CHAR_RE.search(retval):</span>
<span class="gi">+            raise ValueError(&quot;Unsafe header value %r&quot;, retval)</span>
<span class="gi">+        return retval</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def get_argument(self, name: str, default: str, strip: bool = True) -&gt; str:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def get_argument(  # noqa: F811</span>
<span class="gi">+        self, name: str, default: _ArgDefaultMarker = _ARG_DEFAULT, strip: bool = True</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def get_argument(  # noqa: F811</span>
<span class="gi">+        self, name: str, default: None, strip: bool = True</span>
<span class="gi">+    ) -&gt; Optional[str]:</span>
<span class="w"> </span>        pass
<span class="gd">-    _INVALID_HEADER_CHAR_RE = re.compile(&#39;[\\x00-\\x1f]&#39;)</span>

<span class="gd">-    def get_argument(self, name: str, default: Union[None, str,</span>
<span class="gd">-        _ArgDefaultMarker]=_ARG_DEFAULT, strip: bool=True) -&gt;Optional[str]:</span>
<span class="gi">+    def get_argument(  # noqa: F811</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        default: Union[None, str, _ArgDefaultMarker] = _ARG_DEFAULT,</span>
<span class="gi">+        strip: bool = True,</span>
<span class="gi">+    ) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the value of the argument with the given name.

<span class="w"> </span>        If default is not provided, the argument is considered to be
<span class="gu">@@ -312,19 +453,29 @@ class RequestHandler(object):</span>

<span class="w"> </span>        This method searches both the query and body arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_argument(name, default, self.request.arguments, strip)</span>

<span class="gd">-    def get_arguments(self, name: str, strip: bool=True) -&gt;List[str]:</span>
<span class="gi">+    def get_arguments(self, name: str, strip: bool = True) -&gt; List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a list of the arguments with the given name.

<span class="w"> </span>        If the argument is not present, returns an empty list.

<span class="w"> </span>        This method searches both the query and body arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_body_argument(self, name: str, default: Union[None, str,</span>
<span class="gd">-        _ArgDefaultMarker]=_ARG_DEFAULT, strip: bool=True) -&gt;Optional[str]:</span>
<span class="gi">+        # Make sure `get_arguments` isn&#39;t accidentally being called with a</span>
<span class="gi">+        # positional argument that&#39;s assumed to be a default (like in</span>
<span class="gi">+        # `get_argument`.)</span>
<span class="gi">+        assert isinstance(strip, bool)</span>
<span class="gi">+</span>
<span class="gi">+        return self._get_arguments(name, self.request.arguments, strip)</span>
<span class="gi">+</span>
<span class="gi">+    def get_body_argument(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        default: Union[None, str, _ArgDefaultMarker] = _ARG_DEFAULT,</span>
<span class="gi">+        strip: bool = True,</span>
<span class="gi">+    ) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the value of the argument with the given name
<span class="w"> </span>        from the request body.

<span class="gu">@@ -336,19 +487,23 @@ class RequestHandler(object):</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_argument(name, default, self.request.body_arguments, strip)</span>

<span class="gd">-    def get_body_arguments(self, name: str, strip: bool=True) -&gt;List[str]:</span>
<span class="gi">+    def get_body_arguments(self, name: str, strip: bool = True) -&gt; List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a list of the body arguments with the given name.

<span class="w"> </span>        If the argument is not present, returns an empty list.

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_arguments(name, self.request.body_arguments, strip)</span>

<span class="gd">-    def get_query_argument(self, name: str, default: Union[None, str,</span>
<span class="gd">-        _ArgDefaultMarker]=_ARG_DEFAULT, strip: bool=True) -&gt;Optional[str]:</span>
<span class="gi">+    def get_query_argument(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        default: Union[None, str, _ArgDefaultMarker] = _ARG_DEFAULT,</span>
<span class="gi">+        strip: bool = True,</span>
<span class="gi">+    ) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the value of the argument with the given name
<span class="w"> </span>        from the request query string.

<span class="gu">@@ -360,18 +515,47 @@ class RequestHandler(object):</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_argument(name, default, self.request.query_arguments, strip)</span>

<span class="gd">-    def get_query_arguments(self, name: str, strip: bool=True) -&gt;List[str]:</span>
<span class="gi">+    def get_query_arguments(self, name: str, strip: bool = True) -&gt; List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a list of the query arguments with the given name.

<span class="w"> </span>        If the argument is not present, returns an empty list.

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def decode_argument(self, value: bytes, name: Optional[str]=None) -&gt;str:</span>
<span class="gi">+        return self._get_arguments(name, self.request.query_arguments, strip)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_argument(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        default: Union[None, str, _ArgDefaultMarker],</span>
<span class="gi">+        source: Dict[str, List[bytes]],</span>
<span class="gi">+        strip: bool = True,</span>
<span class="gi">+    ) -&gt; Optional[str]:</span>
<span class="gi">+        args = self._get_arguments(name, source, strip=strip)</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            if isinstance(default, _ArgDefaultMarker):</span>
<span class="gi">+                raise MissingArgumentError(name)</span>
<span class="gi">+            return default</span>
<span class="gi">+        return args[-1]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_arguments(</span>
<span class="gi">+        self, name: str, source: Dict[str, List[bytes]], strip: bool = True</span>
<span class="gi">+    ) -&gt; List[str]:</span>
<span class="gi">+        values = []</span>
<span class="gi">+        for v in source.get(name, []):</span>
<span class="gi">+            s = self.decode_argument(v, name=name)</span>
<span class="gi">+            if isinstance(s, unicode_type):</span>
<span class="gi">+                # Get rid of any weird control chars (unless decoding gave</span>
<span class="gi">+                # us bytes, in which case leave it alone)</span>
<span class="gi">+                s = RequestHandler._remove_control_chars_regex.sub(&quot; &quot;, s)</span>
<span class="gi">+            if strip:</span>
<span class="gi">+                s = s.strip()</span>
<span class="gi">+            values.append(s)</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def decode_argument(self, value: bytes, name: Optional[str] = None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decodes an argument from the request.

<span class="w"> </span>        The argument has been percent-decoded and is now a byte string.
<span class="gu">@@ -384,16 +568,20 @@ class RequestHandler(object):</span>
<span class="w"> </span>        The name of the argument is provided if known, but may be None
<span class="w"> </span>        (e.g. for unnamed groups in the url regex).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _unicode(value)</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            raise HTTPError(</span>
<span class="gi">+                400, &quot;Invalid unicode in %s: %r&quot; % (name or &quot;url&quot;, value[:40])</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @property
<span class="gd">-    def cookies(self) -&gt;Dict[str, http.cookies.Morsel]:</span>
<span class="gi">+    def cookies(self) -&gt; Dict[str, http.cookies.Morsel]:</span>
<span class="w"> </span>        &quot;&quot;&quot;An alias for
<span class="w"> </span>        `self.request.cookies &lt;.httputil.HTTPServerRequest.cookies&gt;`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.request.cookies</span>

<span class="gd">-    def get_cookie(self, name: str, default: Optional[str]=None) -&gt;Optional[str</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def get_cookie(self, name: str, default: Optional[str] = None) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the value of the request cookie with the given name.

<span class="w"> </span>        If the named cookie is not present, returns ``default``.
<span class="gu">@@ -402,13 +590,26 @@ class RequestHandler(object):</span>
<span class="w"> </span>        It does not see the outgoing cookies set by `set_cookie` in this
<span class="w"> </span>        handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_cookie(self, name: str, value: Union[str, bytes], domain:</span>
<span class="gd">-        Optional[str]=None, expires: Optional[Union[float, Tuple, datetime.</span>
<span class="gd">-        datetime]]=None, path: str=&#39;/&#39;, expires_days: Optional[float]=None,</span>
<span class="gd">-        *, max_age: Optional[int]=None, httponly: bool=False, secure: bool=</span>
<span class="gd">-        False, samesite: Optional[str]=None, **kwargs: Any) -&gt;None:</span>
<span class="gi">+        if self.request.cookies is not None and name in self.request.cookies:</span>
<span class="gi">+            return self.request.cookies[name].value</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def set_cookie(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        value: Union[str, bytes],</span>
<span class="gi">+        domain: Optional[str] = None,</span>
<span class="gi">+        expires: Optional[Union[float, Tuple, datetime.datetime]] = None,</span>
<span class="gi">+        path: str = &quot;/&quot;,</span>
<span class="gi">+        expires_days: Optional[float] = None,</span>
<span class="gi">+        # Keyword-only args start here for historical reasons.</span>
<span class="gi">+        *,</span>
<span class="gi">+        max_age: Optional[int] = None,</span>
<span class="gi">+        httponly: bool = False,</span>
<span class="gi">+        secure: bool = False,</span>
<span class="gi">+        samesite: Optional[str] = None,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets an outgoing cookie name/value with the given options.

<span class="w"> </span>        Newly-set cookies are not immediately visible via `get_cookie`;
<span class="gu">@@ -429,9 +630,54 @@ class RequestHandler(object):</span>
<span class="w"> </span>           In Tornado 7.0 this will be changed to only accept lowercase
<span class="w"> </span>           arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def clear_cookie(self, name: str, **kwargs: Any) -&gt;None:</span>
<span class="gi">+        # The cookie library only accepts type str, in both python 2 and 3</span>
<span class="gi">+        name = escape.native_str(name)</span>
<span class="gi">+        value = escape.native_str(value)</span>
<span class="gi">+        if re.search(r&quot;[\x00-\x20]&quot;, name + value):</span>
<span class="gi">+            # Don&#39;t let us accidentally inject bad stuff</span>
<span class="gi">+            raise ValueError(&quot;Invalid cookie %r: %r&quot; % (name, value))</span>
<span class="gi">+        if not hasattr(self, &quot;_new_cookie&quot;):</span>
<span class="gi">+            self._new_cookie = (</span>
<span class="gi">+                http.cookies.SimpleCookie()</span>
<span class="gi">+            )  # type: http.cookies.SimpleCookie</span>
<span class="gi">+        if name in self._new_cookie:</span>
<span class="gi">+            del self._new_cookie[name]</span>
<span class="gi">+        self._new_cookie[name] = value</span>
<span class="gi">+        morsel = self._new_cookie[name]</span>
<span class="gi">+        if domain:</span>
<span class="gi">+            morsel[&quot;domain&quot;] = domain</span>
<span class="gi">+        if expires_days is not None and not expires:</span>
<span class="gi">+            expires = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(</span>
<span class="gi">+                days=expires_days</span>
<span class="gi">+            )</span>
<span class="gi">+        if expires:</span>
<span class="gi">+            morsel[&quot;expires&quot;] = httputil.format_timestamp(expires)</span>
<span class="gi">+        if path:</span>
<span class="gi">+            morsel[&quot;path&quot;] = path</span>
<span class="gi">+        if max_age:</span>
<span class="gi">+            # Note change from _ to -.</span>
<span class="gi">+            morsel[&quot;max-age&quot;] = str(max_age)</span>
<span class="gi">+        if httponly:</span>
<span class="gi">+            # Note that SimpleCookie ignores the value here. The presense of an</span>
<span class="gi">+            # httponly (or secure) key is treated as true.</span>
<span class="gi">+            morsel[&quot;httponly&quot;] = True</span>
<span class="gi">+        if secure:</span>
<span class="gi">+            morsel[&quot;secure&quot;] = True</span>
<span class="gi">+        if samesite:</span>
<span class="gi">+            morsel[&quot;samesite&quot;] = samesite</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            # The setitem interface is case-insensitive, so continue to support</span>
<span class="gi">+            # kwargs for backwards compatibility until we can remove deprecated</span>
<span class="gi">+            # features.</span>
<span class="gi">+            for k, v in kwargs.items():</span>
<span class="gi">+                morsel[k] = v</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&quot;Deprecated arguments to set_cookie: {set(kwargs.keys())} &quot;</span>
<span class="gi">+                &quot;(should be lowercase)&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def clear_cookie(self, name: str, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deletes the cookie with the given name.

<span class="w"> </span>        This method accepts the same arguments as `set_cookie`, except for
<span class="gu">@@ -449,9 +695,17 @@ class RequestHandler(object):</span>
<span class="w"> </span>           The ``samesite`` and ``secure`` flags have recently become
<span class="w"> </span>           required for clearing ``samesite=&quot;none&quot;`` cookies.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def clear_all_cookies(self, **kwargs: Any) -&gt;None:</span>
<span class="gi">+        for excluded_arg in [&quot;expires&quot;, &quot;max_age&quot;]:</span>
<span class="gi">+            if excluded_arg in kwargs:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;clear_cookie() got an unexpected keyword argument &#39;{excluded_arg}&#39;&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        expires = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(</span>
<span class="gi">+            days=365</span>
<span class="gi">+        )</span>
<span class="gi">+        self.set_cookie(name, value=&quot;&quot;, expires=expires, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def clear_all_cookies(self, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempt to delete all the cookies the user sent with this request.

<span class="w"> </span>        See `clear_cookie` for more information on keyword arguments. Due to
<span class="gu">@@ -479,11 +733,17 @@ class RequestHandler(object):</span>
<span class="w"> </span>           since all we know about cookies are their names. Applications
<span class="w"> </span>           should generally use ``clear_cookie`` one at a time instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_signed_cookie(self, name: str, value: Union[str, bytes],</span>
<span class="gd">-        expires_days: Optional[float]=30, version: Optional[int]=None, **</span>
<span class="gd">-        kwargs: Any) -&gt;None:</span>
<span class="gi">+        for name in self.request.cookies:</span>
<span class="gi">+            self.clear_cookie(name, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def set_signed_cookie(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        value: Union[str, bytes],</span>
<span class="gi">+        expires_days: Optional[float] = 30,</span>
<span class="gi">+        version: Optional[int] = None,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Signs and timestamps a cookie so it cannot be forged.

<span class="w"> </span>        You must specify the ``cookie_secret`` setting in your Application
<span class="gu">@@ -514,11 +774,18 @@ class RequestHandler(object):</span>
<span class="w"> </span>           avoid confusion with other uses of &quot;secure&quot; in cookie attributes
<span class="w"> </span>           and prefixes. The old name remains as an alias.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_cookie(</span>
<span class="gi">+            name,</span>
<span class="gi">+            self.create_signed_value(name, value, version=version),</span>
<span class="gi">+            expires_days=expires_days,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    set_secure_cookie = set_signed_cookie

<span class="gd">-    def create_signed_value(self, name: str, value: Union[str, bytes],</span>
<span class="gd">-        version: Optional[int]=None) -&gt;bytes:</span>
<span class="gi">+    def create_signed_value(</span>
<span class="gi">+        self, name: str, value: Union[str, bytes], version: Optional[int] = None</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Signs and timestamps a string so it cannot be forged.

<span class="w"> </span>        Normally used via set_signed_cookie, but provided as a separate
<span class="gu">@@ -530,11 +797,25 @@ class RequestHandler(object):</span>
<span class="w"> </span>           Added the ``version`` argument.  Introduced cookie version 2
<span class="w"> </span>           and made it the default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_signed_cookie(self, name: str, value: Optional[str]=None,</span>
<span class="gd">-        max_age_days: float=31, min_version: Optional[int]=None) -&gt;Optional[</span>
<span class="gd">-        bytes]:</span>
<span class="gi">+        self.require_setting(&quot;cookie_secret&quot;, &quot;secure cookies&quot;)</span>
<span class="gi">+        secret = self.application.settings[&quot;cookie_secret&quot;]</span>
<span class="gi">+        key_version = None</span>
<span class="gi">+        if isinstance(secret, dict):</span>
<span class="gi">+            if self.application.settings.get(&quot;key_version&quot;) is None:</span>
<span class="gi">+                raise Exception(&quot;key_version setting must be used for secret_key dicts&quot;)</span>
<span class="gi">+            key_version = self.application.settings[&quot;key_version&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        return create_signed_value(</span>
<span class="gi">+            secret, name, value, version=version, key_version=key_version</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_signed_cookie(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        value: Optional[str] = None,</span>
<span class="gi">+        max_age_days: float = 31,</span>
<span class="gi">+        min_version: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; Optional[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the given signed cookie if it validates, or None.

<span class="w"> </span>        The decoded cookie value is returned as a byte string (unlike
<span class="gu">@@ -556,11 +837,22 @@ class RequestHandler(object):</span>
<span class="w"> </span>           and prefixes. The old name remains as an alias.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.require_setting(&quot;cookie_secret&quot;, &quot;secure cookies&quot;)</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = self.get_cookie(name)</span>
<span class="gi">+        return decode_signed_value(</span>
<span class="gi">+            self.application.settings[&quot;cookie_secret&quot;],</span>
<span class="gi">+            name,</span>
<span class="gi">+            value,</span>
<span class="gi">+            max_age_days=max_age_days,</span>
<span class="gi">+            min_version=min_version,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    get_secure_cookie = get_signed_cookie

<span class="gd">-    def get_signed_cookie_key_version(self, name: str, value: Optional[str]</span>
<span class="gd">-        =None) -&gt;Optional[int]:</span>
<span class="gi">+    def get_signed_cookie_key_version(</span>
<span class="gi">+        self, name: str, value: Optional[str] = None</span>
<span class="gi">+    ) -&gt; Optional[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the signing key version of the secure cookie.

<span class="w"> </span>        The version is returned as int.
<span class="gu">@@ -573,11 +865,18 @@ class RequestHandler(object):</span>
<span class="w"> </span>           remains as an alias.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.require_setting(&quot;cookie_secret&quot;, &quot;secure cookies&quot;)</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = self.get_cookie(name)</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return get_signature_key_version(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    get_secure_cookie_key_version = get_signed_cookie_key_version

<span class="gd">-    def redirect(self, url: str, permanent: bool=False, status: Optional[</span>
<span class="gd">-        int]=None) -&gt;None:</span>
<span class="gi">+    def redirect(</span>
<span class="gi">+        self, url: str, permanent: bool = False, status: Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends a redirect to the given (optionally relative) URL.

<span class="w"> </span>        If the ``status`` argument is specified, that value is used as the
<span class="gu">@@ -585,9 +884,17 @@ class RequestHandler(object):</span>
<span class="w"> </span>        (temporary) is chosen based on the ``permanent`` argument.
<span class="w"> </span>        The default is 302 (temporary).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._headers_written:</span>
<span class="gi">+            raise Exception(&quot;Cannot redirect after headers have been written&quot;)</span>
<span class="gi">+        if status is None:</span>
<span class="gi">+            status = 301 if permanent else 302</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert isinstance(status, int) and 300 &lt;= status &lt;= 399</span>
<span class="gi">+        self.set_status(status)</span>
<span class="gi">+        self.set_header(&quot;Location&quot;, utf8(url))</span>
<span class="gi">+        self.finish()</span>

<span class="gd">-    def write(self, chunk: Union[str, bytes, dict]) -&gt;None:</span>
<span class="gi">+    def write(self, chunk: Union[str, bytes, dict]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes the given chunk to the output buffer.

<span class="w"> </span>        To write the output to the network, use the `flush()` method below.
<span class="gu">@@ -603,9 +910,23 @@ class RequestHandler(object):</span>
<span class="w"> </span>        http://haacked.com/archive/2009/06/25/json-hijacking.aspx/ and
<span class="w"> </span>        https://github.com/facebook/tornado/issues/1009
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def render(self, template_name: str, **kwargs: Any) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            raise RuntimeError(&quot;Cannot write() after finish()&quot;)</span>
<span class="gi">+        if not isinstance(chunk, (bytes, unicode_type, dict)):</span>
<span class="gi">+            message = &quot;write() only accepts bytes, unicode, and dict objects&quot;</span>
<span class="gi">+            if isinstance(chunk, list):</span>
<span class="gi">+                message += (</span>
<span class="gi">+                    &quot;. Lists not accepted for security reasons; see &quot;</span>
<span class="gi">+                    + &quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write&quot;  # noqa: E501</span>
<span class="gi">+                )</span>
<span class="gi">+            raise TypeError(message)</span>
<span class="gi">+        if isinstance(chunk, dict):</span>
<span class="gi">+            chunk = escape.json_encode(chunk)</span>
<span class="gi">+            self.set_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)</span>
<span class="gi">+        chunk = utf8(chunk)</span>
<span class="gi">+        self._write_buffer.append(chunk)</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, template_name: str, **kwargs: Any) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Renders the template with the given arguments as the response.

<span class="w"> </span>        ``render()`` calls ``finish()``, so no other output methods can be called
<span class="gu">@@ -618,49 +939,160 @@ class RequestHandler(object):</span>

<span class="w"> </span>           Now returns a `.Future` instead of ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def render_linked_js(self, js_files: Iterable[str]) -&gt;str:</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            raise RuntimeError(&quot;Cannot render() after finish()&quot;)</span>
<span class="gi">+        html = self.render_string(template_name, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Insert the additional JS and CSS added by the modules on the page</span>
<span class="gi">+        js_embed = []</span>
<span class="gi">+        js_files = []</span>
<span class="gi">+        css_embed = []</span>
<span class="gi">+        css_files = []</span>
<span class="gi">+        html_heads = []</span>
<span class="gi">+        html_bodies = []</span>
<span class="gi">+        for module in getattr(self, &quot;_active_modules&quot;, {}).values():</span>
<span class="gi">+            embed_part = module.embedded_javascript()</span>
<span class="gi">+            if embed_part:</span>
<span class="gi">+                js_embed.append(utf8(embed_part))</span>
<span class="gi">+            file_part = module.javascript_files()</span>
<span class="gi">+            if file_part:</span>
<span class="gi">+                if isinstance(file_part, (unicode_type, bytes)):</span>
<span class="gi">+                    js_files.append(_unicode(file_part))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    js_files.extend(file_part)</span>
<span class="gi">+            embed_part = module.embedded_css()</span>
<span class="gi">+            if embed_part:</span>
<span class="gi">+                css_embed.append(utf8(embed_part))</span>
<span class="gi">+            file_part = module.css_files()</span>
<span class="gi">+            if file_part:</span>
<span class="gi">+                if isinstance(file_part, (unicode_type, bytes)):</span>
<span class="gi">+                    css_files.append(_unicode(file_part))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    css_files.extend(file_part)</span>
<span class="gi">+            head_part = module.html_head()</span>
<span class="gi">+            if head_part:</span>
<span class="gi">+                html_heads.append(utf8(head_part))</span>
<span class="gi">+            body_part = module.html_body()</span>
<span class="gi">+            if body_part:</span>
<span class="gi">+                html_bodies.append(utf8(body_part))</span>
<span class="gi">+</span>
<span class="gi">+        if js_files:</span>
<span class="gi">+            # Maintain order of JavaScript files given by modules</span>
<span class="gi">+            js = self.render_linked_js(js_files)</span>
<span class="gi">+            sloc = html.rindex(b&quot;&lt;/body&gt;&quot;)</span>
<span class="gi">+            html = html[:sloc] + utf8(js) + b&quot;\n&quot; + html[sloc:]</span>
<span class="gi">+        if js_embed:</span>
<span class="gi">+            js_bytes = self.render_embed_js(js_embed)</span>
<span class="gi">+            sloc = html.rindex(b&quot;&lt;/body&gt;&quot;)</span>
<span class="gi">+            html = html[:sloc] + js_bytes + b&quot;\n&quot; + html[sloc:]</span>
<span class="gi">+        if css_files:</span>
<span class="gi">+            css = self.render_linked_css(css_files)</span>
<span class="gi">+            hloc = html.index(b&quot;&lt;/head&gt;&quot;)</span>
<span class="gi">+            html = html[:hloc] + utf8(css) + b&quot;\n&quot; + html[hloc:]</span>
<span class="gi">+        if css_embed:</span>
<span class="gi">+            css_bytes = self.render_embed_css(css_embed)</span>
<span class="gi">+            hloc = html.index(b&quot;&lt;/head&gt;&quot;)</span>
<span class="gi">+            html = html[:hloc] + css_bytes + b&quot;\n&quot; + html[hloc:]</span>
<span class="gi">+        if html_heads:</span>
<span class="gi">+            hloc = html.index(b&quot;&lt;/head&gt;&quot;)</span>
<span class="gi">+            html = html[:hloc] + b&quot;&quot;.join(html_heads) + b&quot;\n&quot; + html[hloc:]</span>
<span class="gi">+        if html_bodies:</span>
<span class="gi">+            hloc = html.index(b&quot;&lt;/body&gt;&quot;)</span>
<span class="gi">+            html = html[:hloc] + b&quot;&quot;.join(html_bodies) + b&quot;\n&quot; + html[hloc:]</span>
<span class="gi">+        return self.finish(html)</span>
<span class="gi">+</span>
<span class="gi">+    def render_linked_js(self, js_files: Iterable[str]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Default method used to render the final js links for the
<span class="w"> </span>        rendered webpage.

<span class="w"> </span>        Override this method in a sub-classed controller to change the output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        unique_paths = set()  # type: Set[str]</span>
<span class="gi">+</span>
<span class="gi">+        for path in js_files:</span>
<span class="gi">+            if not is_absolute(path):</span>
<span class="gi">+                path = self.static_url(path)</span>
<span class="gi">+            if path not in unique_paths:</span>
<span class="gi">+                paths.append(path)</span>
<span class="gi">+                unique_paths.add(path)</span>

<span class="gd">-    def render_embed_js(self, js_embed: Iterable[bytes]) -&gt;bytes:</span>
<span class="gi">+        return &quot;&quot;.join(</span>
<span class="gi">+            &#39;&lt;script src=&quot;&#39;</span>
<span class="gi">+            + escape.xhtml_escape(p)</span>
<span class="gi">+            + &#39;&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&#39;</span>
<span class="gi">+            for p in paths</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def render_embed_js(self, js_embed: Iterable[bytes]) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Default method used to render the final embedded js for the
<span class="w"> </span>        rendered webpage.

<span class="w"> </span>        Override this method in a sub-classed controller to change the output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            b&#39;&lt;script type=&quot;text/javascript&quot;&gt;\n//&lt;![CDATA[\n&#39;</span>
<span class="gi">+            + b&quot;\n&quot;.join(js_embed)</span>
<span class="gi">+            + b&quot;\n//]]&gt;\n&lt;/script&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-    def render_linked_css(self, css_files: Iterable[str]) -&gt;str:</span>
<span class="gi">+    def render_linked_css(self, css_files: Iterable[str]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Default method used to render the final css links for the
<span class="w"> </span>        rendered webpage.

<span class="w"> </span>        Override this method in a sub-classed controller to change the output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        unique_paths = set()  # type: Set[str]</span>
<span class="gi">+</span>
<span class="gi">+        for path in css_files:</span>
<span class="gi">+            if not is_absolute(path):</span>
<span class="gi">+                path = self.static_url(path)</span>
<span class="gi">+            if path not in unique_paths:</span>
<span class="gi">+                paths.append(path)</span>
<span class="gi">+                unique_paths.add(path)</span>

<span class="gd">-    def render_embed_css(self, css_embed: Iterable[bytes]) -&gt;bytes:</span>
<span class="gi">+        return &quot;&quot;.join(</span>
<span class="gi">+            &#39;&lt;link href=&quot;&#39; + escape.xhtml_escape(p) + &#39;&quot; &#39;</span>
<span class="gi">+            &#39;type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;&#39;</span>
<span class="gi">+            for p in paths</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def render_embed_css(self, css_embed: Iterable[bytes]) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Default method used to render the final embedded css for the
<span class="w"> </span>        rendered webpage.

<span class="w"> </span>        Override this method in a sub-classed controller to change the output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return b&#39;&lt;style type=&quot;text/css&quot;&gt;\n&#39; + b&quot;\n&quot;.join(css_embed) + b&quot;\n&lt;/style&gt;&quot;</span>

<span class="gd">-    def render_string(self, template_name: str, **kwargs: Any) -&gt;bytes:</span>
<span class="gi">+    def render_string(self, template_name: str, **kwargs: Any) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate the given template with the given arguments.

<span class="w"> </span>        We return the generated byte string (in utf8). To generate and
<span class="w"> </span>        write a template as a response, use render() above.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_template_namespace(self) -&gt;Dict[str, Any]:</span>
<span class="gi">+        # If no template_path is specified, use the path of the calling file</span>
<span class="gi">+        template_path = self.get_template_path()</span>
<span class="gi">+        if not template_path:</span>
<span class="gi">+            frame = sys._getframe(0)</span>
<span class="gi">+            web_file = frame.f_code.co_filename</span>
<span class="gi">+            while frame.f_code.co_filename == web_file and frame.f_back is not None:</span>
<span class="gi">+                frame = frame.f_back</span>
<span class="gi">+            assert frame.f_code.co_filename is not None</span>
<span class="gi">+            template_path = os.path.dirname(frame.f_code.co_filename)</span>
<span class="gi">+        with RequestHandler._template_loader_lock:</span>
<span class="gi">+            if template_path not in RequestHandler._template_loaders:</span>
<span class="gi">+                loader = self.create_template_loader(template_path)</span>
<span class="gi">+                RequestHandler._template_loaders[template_path] = loader</span>
<span class="gi">+            else:</span>
<span class="gi">+                loader = RequestHandler._template_loaders[template_path]</span>
<span class="gi">+        t = loader.load(template_name)</span>
<span class="gi">+        namespace = self.get_template_namespace()</span>
<span class="gi">+        namespace.update(kwargs)</span>
<span class="gi">+        return t.generate(**namespace)</span>
<span class="gi">+</span>
<span class="gi">+    def get_template_namespace(self) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a dictionary to be used as the default template namespace.

<span class="w"> </span>        May be overridden by subclasses to add or modify values.
<span class="gu">@@ -669,9 +1101,21 @@ class RequestHandler(object):</span>
<span class="w"> </span>        defaults in the `tornado.template` module and keyword arguments
<span class="w"> </span>        to `render` or `render_string`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def create_template_loader(self, template_path: str) -&gt;template.BaseLoader:</span>
<span class="gi">+        namespace = dict(</span>
<span class="gi">+            handler=self,</span>
<span class="gi">+            request=self.request,</span>
<span class="gi">+            current_user=self.current_user,</span>
<span class="gi">+            locale=self.locale,</span>
<span class="gi">+            _=self.locale.translate,</span>
<span class="gi">+            pgettext=self.locale.pgettext,</span>
<span class="gi">+            static_url=self.static_url,</span>
<span class="gi">+            xsrf_form_html=self.xsrf_form_html,</span>
<span class="gi">+            reverse_url=self.reverse_url,</span>
<span class="gi">+        )</span>
<span class="gi">+        namespace.update(self.ui)</span>
<span class="gi">+        return namespace</span>
<span class="gi">+</span>
<span class="gi">+    def create_template_loader(self, template_path: str) -&gt; template.BaseLoader:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a new template loader for the given path.

<span class="w"> </span>        May be overridden by subclasses.  By default returns a
<span class="gu">@@ -680,9 +1124,19 @@ class RequestHandler(object):</span>
<span class="w"> </span>        settings.  If a ``template_loader`` application setting is
<span class="w"> </span>        supplied, uses that instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def flush(self, include_footers: bool=False) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+        settings = self.application.settings</span>
<span class="gi">+        if &quot;template_loader&quot; in settings:</span>
<span class="gi">+            return settings[&quot;template_loader&quot;]</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+        if &quot;autoescape&quot; in settings:</span>
<span class="gi">+            # autoescape=None means &quot;no escaping&quot;, so we have to be sure</span>
<span class="gi">+            # to only pass this kwarg if the user asked for it.</span>
<span class="gi">+            kwargs[&quot;autoescape&quot;] = settings[&quot;autoescape&quot;]</span>
<span class="gi">+        if &quot;template_whitespace&quot; in settings:</span>
<span class="gi">+            kwargs[&quot;whitespace&quot;] = settings[&quot;template_whitespace&quot;]</span>
<span class="gi">+        return template.Loader(template_path, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self, include_footers: bool = False) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Flushes the current output buffer to the network.

<span class="w"> </span>        .. versionchanged:: 4.0
<span class="gu">@@ -692,10 +1146,47 @@ class RequestHandler(object):</span>

<span class="w"> </span>           The ``callback`` argument was removed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def finish(self, chunk: Optional[Union[str, bytes, dict]]=None</span>
<span class="gd">-        ) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+        assert self.request.connection is not None</span>
<span class="gi">+        chunk = b&quot;&quot;.join(self._write_buffer)</span>
<span class="gi">+        self._write_buffer = []</span>
<span class="gi">+        if not self._headers_written:</span>
<span class="gi">+            self._headers_written = True</span>
<span class="gi">+            for transform in self._transforms:</span>
<span class="gi">+                assert chunk is not None</span>
<span class="gi">+                (</span>
<span class="gi">+                    self._status_code,</span>
<span class="gi">+                    self._headers,</span>
<span class="gi">+                    chunk,</span>
<span class="gi">+                ) = transform.transform_first_chunk(</span>
<span class="gi">+                    self._status_code, self._headers, chunk, include_footers</span>
<span class="gi">+                )</span>
<span class="gi">+            # Ignore the chunk and only write the headers for HEAD requests</span>
<span class="gi">+            if self.request.method == &quot;HEAD&quot;:</span>
<span class="gi">+                chunk = b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # Finalize the cookie headers (which have been stored in a side</span>
<span class="gi">+            # object so an outgoing cookie could be overwritten before it</span>
<span class="gi">+            # is sent).</span>
<span class="gi">+            if hasattr(self, &quot;_new_cookie&quot;):</span>
<span class="gi">+                for cookie in self._new_cookie.values():</span>
<span class="gi">+                    self.add_header(&quot;Set-Cookie&quot;, cookie.OutputString(None))</span>
<span class="gi">+</span>
<span class="gi">+            start_line = httputil.ResponseStartLine(&quot;&quot;, self._status_code, self._reason)</span>
<span class="gi">+            return self.request.connection.write_headers(</span>
<span class="gi">+                start_line, self._headers, chunk</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            for transform in self._transforms:</span>
<span class="gi">+                chunk = transform.transform_chunk(chunk, include_footers)</span>
<span class="gi">+            # Ignore the chunk and only write the headers for HEAD requests</span>
<span class="gi">+            if self.request.method != &quot;HEAD&quot;:</span>
<span class="gi">+                return self.request.connection.write(chunk)</span>
<span class="gi">+            else:</span>
<span class="gi">+                future = Future()  # type: Future[None]</span>
<span class="gi">+                future.set_result(None)</span>
<span class="gi">+                return future</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self, chunk: Optional[Union[str, bytes, dict]] = None) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finishes this response, ending the HTTP request.

<span class="w"> </span>        Passing a ``chunk`` to ``finish()`` is equivalent to passing that
<span class="gu">@@ -710,9 +1201,49 @@ class RequestHandler(object):</span>

<span class="w"> </span>           Now returns a `.Future` instead of ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            raise RuntimeError(&quot;finish() called twice&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if chunk is not None:</span>
<span class="gi">+            self.write(chunk)</span>
<span class="gi">+</span>
<span class="gi">+        # Automatically support ETags and add the Content-Length header if</span>
<span class="gi">+        # we have not flushed any content yet.</span>
<span class="gi">+        if not self._headers_written:</span>
<span class="gi">+            if (</span>
<span class="gi">+                self._status_code == 200</span>
<span class="gi">+                and self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;)</span>
<span class="gi">+                and &quot;Etag&quot; not in self._headers</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.set_etag_header()</span>
<span class="gi">+                if self.check_etag_header():</span>
<span class="gi">+                    self._write_buffer = []</span>
<span class="gi">+                    self.set_status(304)</span>
<span class="gi">+            if self._status_code in (204, 304) or (100 &lt;= self._status_code &lt; 200):</span>
<span class="gi">+                assert not self._write_buffer, (</span>
<span class="gi">+                    &quot;Cannot send body with %s&quot; % self._status_code</span>
<span class="gi">+                )</span>
<span class="gi">+                self._clear_representation_headers()</span>
<span class="gi">+            elif &quot;Content-Length&quot; not in self._headers:</span>
<span class="gi">+                content_length = sum(len(part) for part in self._write_buffer)</span>
<span class="gi">+                self.set_header(&quot;Content-Length&quot;, content_length)</span>

<span class="gd">-    def detach(self) -&gt;iostream.IOStream:</span>
<span class="gi">+        assert self.request.connection is not None</span>
<span class="gi">+        # Now that the request is finished, clear the callback we</span>
<span class="gi">+        # set on the HTTPConnection (which would otherwise prevent the</span>
<span class="gi">+        # garbage collection of the RequestHandler when there</span>
<span class="gi">+        # are keepalive connections)</span>
<span class="gi">+        self.request.connection.set_close_callback(None)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        future = self.flush(include_footers=True)</span>
<span class="gi">+        self.request.connection.finish()</span>
<span class="gi">+        self._log()</span>
<span class="gi">+        self._finished = True</span>
<span class="gi">+        self.on_finish()</span>
<span class="gi">+        self._break_cycles()</span>
<span class="gi">+        return future</span>
<span class="gi">+</span>
<span class="gi">+    def detach(self) -&gt; iostream.IOStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Take control of the underlying stream.

<span class="w"> </span>        Returns the underlying `.IOStream` object and stops all
<span class="gu">@@ -723,9 +1254,16 @@ class RequestHandler(object):</span>

<span class="w"> </span>        .. versionadded:: 5.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._finished = True</span>
<span class="gi">+        # TODO: add detach to HTTPConnection?</span>
<span class="gi">+        return self.request.connection.detach()  # type: ignore</span>

<span class="gd">-    def send_error(self, status_code: int=500, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def _break_cycles(self) -&gt; None:</span>
<span class="gi">+        # Break up a reference cycle between this handler and the</span>
<span class="gi">+        # _ui_module closures to allow for faster GC on CPython.</span>
<span class="gi">+        self.ui = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def send_error(self, status_code: int = 500, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends the given HTTP error code to the browser.

<span class="w"> </span>        If `flush()` has already been called, it is not possible to send
<span class="gu">@@ -736,9 +1274,34 @@ class RequestHandler(object):</span>
<span class="w"> </span>        Override `write_error()` to customize the error page that is returned.
<span class="w"> </span>        Additional keyword arguments are passed through to `write_error`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._headers_written:</span>
<span class="gi">+            gen_log.error(&quot;Cannot send error response after headers written&quot;)</span>
<span class="gi">+            if not self._finished:</span>
<span class="gi">+                # If we get an error between writing headers and finishing,</span>
<span class="gi">+                # we are unlikely to be able to finish due to a</span>
<span class="gi">+                # Content-Length mismatch. Try anyway to release the</span>
<span class="gi">+                # socket.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.finish()</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    gen_log.error(&quot;Failed to flush partial response&quot;, exc_info=True)</span>
<span class="gi">+            return</span>
<span class="gi">+        self.clear()</span>
<span class="gi">+</span>
<span class="gi">+        reason = kwargs.get(&quot;reason&quot;)</span>
<span class="gi">+        if &quot;exc_info&quot; in kwargs:</span>
<span class="gi">+            exception = kwargs[&quot;exc_info&quot;][1]</span>
<span class="gi">+            if isinstance(exception, HTTPError) and exception.reason:</span>
<span class="gi">+                reason = exception.reason</span>
<span class="gi">+        self.set_status(status_code, reason=reason)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.write_error(status_code, **kwargs)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            app_log.error(&quot;Uncaught exception in write_error&quot;, exc_info=True)</span>
<span class="gi">+        if not self._finished:</span>
<span class="gi">+            self.finish()</span>

<span class="gd">-    def write_error(self, status_code: int, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def write_error(self, status_code: int, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to implement custom error pages.

<span class="w"> </span>        ``write_error`` may call `write`, `render`, `set_header`, etc
<span class="gu">@@ -750,10 +1313,21 @@ class RequestHandler(object):</span>
<span class="w"> </span>        the &quot;current&quot; exception for purposes of methods like
<span class="w"> </span>        ``sys.exc_info()`` or ``traceback.format_exc``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.settings.get(&quot;serve_traceback&quot;) and &quot;exc_info&quot; in kwargs:</span>
<span class="gi">+            # in debug mode, try to send a traceback</span>
<span class="gi">+            self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span>
<span class="gi">+            for line in traceback.format_exception(*kwargs[&quot;exc_info&quot;]):</span>
<span class="gi">+                self.write(line)</span>
<span class="gi">+            self.finish()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.finish(</span>
<span class="gi">+                &quot;&lt;html&gt;&lt;title&gt;%(code)d: %(message)s&lt;/title&gt;&quot;</span>
<span class="gi">+                &quot;&lt;body&gt;%(code)d: %(message)s&lt;/body&gt;&lt;/html&gt;&quot;</span>
<span class="gi">+                % {&quot;code&quot;: status_code, &quot;message&quot;: self._reason}</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @property
<span class="gd">-    def locale(self) -&gt;tornado.locale.Locale:</span>
<span class="gi">+    def locale(self) -&gt; tornado.locale.Locale:</span>
<span class="w"> </span>        &quot;&quot;&quot;The locale for the current session.

<span class="w"> </span>        Determined by either `get_user_locale`, which you can override to
<span class="gu">@@ -764,9 +1338,20 @@ class RequestHandler(object):</span>
<span class="w"> </span>        .. versionchanged: 4.1
<span class="w"> </span>           Added a property setter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &quot;_locale&quot;):</span>
<span class="gi">+            loc = self.get_user_locale()</span>
<span class="gi">+            if loc is not None:</span>
<span class="gi">+                self._locale = loc</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._locale = self.get_browser_locale()</span>
<span class="gi">+                assert self._locale</span>
<span class="gi">+        return self._locale</span>

<span class="gd">-    def get_user_locale(self) -&gt;Optional[tornado.locale.Locale]:</span>
<span class="gi">+    @locale.setter</span>
<span class="gi">+    def locale(self, value: tornado.locale.Locale) -&gt; None:</span>
<span class="gi">+        self._locale = value</span>
<span class="gi">+</span>
<span class="gi">+    def get_user_locale(self) -&gt; Optional[tornado.locale.Locale]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to determine the locale from the authenticated user.

<span class="w"> </span>        If None is returned, we fall back to `get_browser_locale()`.
<span class="gu">@@ -774,17 +1359,37 @@ class RequestHandler(object):</span>
<span class="w"> </span>        This method should return a `tornado.locale.Locale` object,
<span class="w"> </span>        most likely obtained via a call like ``tornado.locale.get(&quot;en&quot;)``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_browser_locale(self, default: str=&#39;en_US&#39;) -&gt;tornado.locale.Locale:</span>
<span class="gi">+    def get_browser_locale(self, default: str = &quot;en_US&quot;) -&gt; tornado.locale.Locale:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determines the user&#39;s locale from ``Accept-Language`` header.

<span class="w"> </span>        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;Accept-Language&quot; in self.request.headers:</span>
<span class="gi">+            languages = self.request.headers[&quot;Accept-Language&quot;].split(&quot;,&quot;)</span>
<span class="gi">+            locales = []</span>
<span class="gi">+            for language in languages:</span>
<span class="gi">+                parts = language.strip().split(&quot;;&quot;)</span>
<span class="gi">+                if len(parts) &gt; 1 and parts[1].strip().startswith(&quot;q=&quot;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        score = float(parts[1].strip()[2:])</span>
<span class="gi">+                        if score &lt; 0:</span>
<span class="gi">+                            raise ValueError()</span>
<span class="gi">+                    except (ValueError, TypeError):</span>
<span class="gi">+                        score = 0.0</span>
<span class="gi">+                else:</span>
<span class="gi">+                    score = 1.0</span>
<span class="gi">+                if score &gt; 0:</span>
<span class="gi">+                    locales.append((parts[0], score))</span>
<span class="gi">+            if locales:</span>
<span class="gi">+                locales.sort(key=lambda pair: pair[1], reverse=True)</span>
<span class="gi">+                codes = [loc[0] for loc in locales]</span>
<span class="gi">+                return locale.get(*codes)</span>
<span class="gi">+        return locale.get(default)</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_user(self) -&gt;Any:</span>
<span class="gi">+    def current_user(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;The authenticated user for this request.

<span class="w"> </span>        This is set in one of two ways:
<span class="gu">@@ -815,32 +1420,39 @@ class RequestHandler(object):</span>

<span class="w"> </span>        The user object may be any type of the application&#39;s choosing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &quot;_current_user&quot;):</span>
<span class="gi">+            self._current_user = self.get_current_user()</span>
<span class="gi">+        return self._current_user</span>

<span class="gd">-    def get_current_user(self) -&gt;Any:</span>
<span class="gi">+    @current_user.setter</span>
<span class="gi">+    def current_user(self, value: Any) -&gt; None:</span>
<span class="gi">+        self._current_user = value</span>
<span class="gi">+</span>
<span class="gi">+    def get_current_user(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to determine the current user from, e.g., a cookie.

<span class="w"> </span>        This method may not be a coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_login_url(self) -&gt;str:</span>
<span class="gi">+    def get_login_url(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to customize the login URL based on the request.

<span class="w"> </span>        By default, we use the ``login_url`` application setting.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.require_setting(&quot;login_url&quot;, &quot;@tornado.web.authenticated&quot;)</span>
<span class="gi">+        return self.application.settings[&quot;login_url&quot;]</span>

<span class="gd">-    def get_template_path(self) -&gt;Optional[str]:</span>
<span class="gi">+    def get_template_path(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to customize template path for each handler.

<span class="w"> </span>        By default, we use the ``template_path`` application setting.
<span class="w"> </span>        Return None to load templates relative to the calling file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.application.settings.get(&quot;template_path&quot;)</span>

<span class="w"> </span>    @property
<span class="gd">-    def xsrf_token(self) -&gt;bytes:</span>
<span class="gi">+    def xsrf_token(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;The XSRF-prevention token for the current user/session.

<span class="w"> </span>        To prevent cross-site request forgery, we set an &#39;_xsrf&#39; cookie
<span class="gu">@@ -872,9 +1484,32 @@ class RequestHandler(object):</span>
<span class="w"> </span>           will set the ``secure`` and ``httponly`` flags on the
<span class="w"> </span>           ``_xsrf`` cookie.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_raw_xsrf_token(self) -&gt;Tuple[Optional[int], bytes, float]:</span>
<span class="gi">+        if not hasattr(self, &quot;_xsrf_token&quot;):</span>
<span class="gi">+            version, token, timestamp = self._get_raw_xsrf_token()</span>
<span class="gi">+            output_version = self.settings.get(&quot;xsrf_cookie_version&quot;, 2)</span>
<span class="gi">+            cookie_kwargs = self.settings.get(&quot;xsrf_cookie_kwargs&quot;, {})</span>
<span class="gi">+            if output_version == 1:</span>
<span class="gi">+                self._xsrf_token = binascii.b2a_hex(token)</span>
<span class="gi">+            elif output_version == 2:</span>
<span class="gi">+                mask = os.urandom(4)</span>
<span class="gi">+                self._xsrf_token = b&quot;|&quot;.join(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        b&quot;2&quot;,</span>
<span class="gi">+                        binascii.b2a_hex(mask),</span>
<span class="gi">+                        binascii.b2a_hex(_websocket_mask(mask, token)),</span>
<span class="gi">+                        utf8(str(int(timestamp))),</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;unknown xsrf cookie version %d&quot;, output_version)</span>
<span class="gi">+            if version is None:</span>
<span class="gi">+                if self.current_user and &quot;expires_days&quot; not in cookie_kwargs:</span>
<span class="gi">+                    cookie_kwargs[&quot;expires_days&quot;] = 30</span>
<span class="gi">+                cookie_name = self.settings.get(&quot;xsrf_cookie_name&quot;, &quot;_xsrf&quot;)</span>
<span class="gi">+                self.set_cookie(cookie_name, self._xsrf_token, **cookie_kwargs)</span>
<span class="gi">+        return self._xsrf_token</span>
<span class="gi">+</span>
<span class="gi">+    def _get_raw_xsrf_token(self) -&gt; Tuple[Optional[int], bytes, float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read or generate the xsrf token in its raw form.

<span class="w"> </span>        The raw_xsrf_token is a tuple containing:
<span class="gu">@@ -885,16 +1520,59 @@ class RequestHandler(object):</span>
<span class="w"> </span>        * timestamp: the time this token was generated (will not be accurate
<span class="w"> </span>          for version 1 cookies)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _decode_xsrf_token(self, cookie: str) -&gt;Tuple[Optional[int],</span>
<span class="gd">-        Optional[bytes], Optional[float]]:</span>
<span class="gi">+        if not hasattr(self, &quot;_raw_xsrf_token&quot;):</span>
<span class="gi">+            cookie_name = self.settings.get(&quot;xsrf_cookie_name&quot;, &quot;_xsrf&quot;)</span>
<span class="gi">+            cookie = self.get_cookie(cookie_name)</span>
<span class="gi">+            if cookie:</span>
<span class="gi">+                version, token, timestamp = self._decode_xsrf_token(cookie)</span>
<span class="gi">+            else:</span>
<span class="gi">+                version, token, timestamp = None, None, None</span>
<span class="gi">+            if token is None:</span>
<span class="gi">+                version = None</span>
<span class="gi">+                token = os.urandom(16)</span>
<span class="gi">+                timestamp = time.time()</span>
<span class="gi">+            assert token is not None</span>
<span class="gi">+            assert timestamp is not None</span>
<span class="gi">+            self._raw_xsrf_token = (version, token, timestamp)</span>
<span class="gi">+        return self._raw_xsrf_token</span>
<span class="gi">+</span>
<span class="gi">+    def _decode_xsrf_token(</span>
<span class="gi">+        self, cookie: str</span>
<span class="gi">+    ) -&gt; Tuple[Optional[int], Optional[bytes], Optional[float]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert a cookie string into a the tuple form returned by
<span class="w"> </span>        _get_raw_xsrf_token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def check_xsrf_cookie(self) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            m = _signed_value_version_re.match(utf8(cookie))</span>
<span class="gi">+</span>
<span class="gi">+            if m:</span>
<span class="gi">+                version = int(m.group(1))</span>
<span class="gi">+                if version == 2:</span>
<span class="gi">+                    _, mask_str, masked_token, timestamp_str = cookie.split(&quot;|&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                    mask = binascii.a2b_hex(utf8(mask_str))</span>
<span class="gi">+                    token = _websocket_mask(mask, binascii.a2b_hex(utf8(masked_token)))</span>
<span class="gi">+                    timestamp = int(timestamp_str)</span>
<span class="gi">+                    return version, token, timestamp</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Treat unknown versions as not present instead of failing.</span>
<span class="gi">+                    raise Exception(&quot;Unknown xsrf cookie version&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                version = 1</span>
<span class="gi">+                try:</span>
<span class="gi">+                    token = binascii.a2b_hex(utf8(cookie))</span>
<span class="gi">+                except (binascii.Error, TypeError):</span>
<span class="gi">+                    token = utf8(cookie)</span>
<span class="gi">+                # We don&#39;t have a usable timestamp in older versions.</span>
<span class="gi">+                timestamp = int(time.time())</span>
<span class="gi">+                return (version, token, timestamp)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # Catch exceptions and return nothing instead of failing.</span>
<span class="gi">+            gen_log.debug(&quot;Uncaught exception in _decode_xsrf_token&quot;, exc_info=True)</span>
<span class="gi">+            return None, None, None</span>
<span class="gi">+</span>
<span class="gi">+    def check_xsrf_cookie(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.

<span class="w"> </span>        To prevent cross-site request forgery, we set an ``_xsrf``
<span class="gu">@@ -912,9 +1590,27 @@ class RequestHandler(object):</span>
<span class="w"> </span>           Added support for cookie version 2.  Both versions 1 and 2 are
<span class="w"> </span>           supported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def xsrf_form_html(self) -&gt;str:</span>
<span class="gi">+        # Prior to release 1.1.1, this check was ignored if the HTTP header</span>
<span class="gi">+        # ``X-Requested-With: XMLHTTPRequest`` was present.  This exception</span>
<span class="gi">+        # has been shown to be insecure and has been removed.  For more</span>
<span class="gi">+        # information please see</span>
<span class="gi">+        # http://www.djangoproject.com/weblog/2011/feb/08/security/</span>
<span class="gi">+        # http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails</span>
<span class="gi">+        token = (</span>
<span class="gi">+            self.get_argument(&quot;_xsrf&quot;, None)</span>
<span class="gi">+            or self.request.headers.get(&quot;X-Xsrftoken&quot;)</span>
<span class="gi">+            or self.request.headers.get(&quot;X-Csrftoken&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if not token:</span>
<span class="gi">+            raise HTTPError(403, &quot;&#39;_xsrf&#39; argument missing from POST&quot;)</span>
<span class="gi">+        _, token, _ = self._decode_xsrf_token(token)</span>
<span class="gi">+        _, expected_token, _ = self._get_raw_xsrf_token()</span>
<span class="gi">+        if not token:</span>
<span class="gi">+            raise HTTPError(403, &quot;&#39;_xsrf&#39; argument has invalid format&quot;)</span>
<span class="gi">+        if not hmac.compare_digest(utf8(token), utf8(expected_token)):</span>
<span class="gi">+            raise HTTPError(403, &quot;XSRF cookie does not match POST argument&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def xsrf_form_html(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;An HTML ``&lt;input/&gt;`` element to be included with all POST forms.

<span class="w"> </span>        It defines the ``_xsrf`` input value, which we check on all POST
<span class="gu">@@ -927,10 +1623,15 @@ class RequestHandler(object):</span>

<span class="w"> </span>        See `check_xsrf_cookie()` above for more information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            &#39;&lt;input type=&quot;hidden&quot; name=&quot;_xsrf&quot; value=&quot;&#39;</span>
<span class="gi">+            + escape.xhtml_escape(self.xsrf_token)</span>
<span class="gi">+            + &#39;&quot;/&gt;&#39;</span>
<span class="gi">+        )</span>

<span class="gd">-    def static_url(self, path: str, include_host: Optional[bool]=None, **</span>
<span class="gd">-        kwargs: Any) -&gt;str:</span>
<span class="gi">+    def static_url(</span>
<span class="gi">+        self, path: str, include_host: Optional[bool] = None, **kwargs: Any</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a static URL for the given relative static file path.

<span class="w"> </span>        This method requires you set the ``static_path`` setting in your
<span class="gu">@@ -951,17 +1652,34 @@ class RequestHandler(object):</span>
<span class="w"> </span>        calls that do not pass ``include_host`` as a keyword argument.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.require_setting(&quot;static_path&quot;, &quot;static_url&quot;)</span>
<span class="gi">+        get_url = self.settings.get(</span>
<span class="gi">+            &quot;static_handler_class&quot;, StaticFileHandler</span>
<span class="gi">+        ).make_static_url</span>

<span class="gd">-    def require_setting(self, name: str, feature: str=&#39;this feature&#39;) -&gt;None:</span>
<span class="gi">+        if include_host is None:</span>
<span class="gi">+            include_host = getattr(self, &quot;include_host&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+        if include_host:</span>
<span class="gi">+            base = self.request.protocol + &quot;://&quot; + self.request.host</span>
<span class="gi">+        else:</span>
<span class="gi">+            base = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return base + get_url(self.settings, path, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def require_setting(self, name: str, feature: str = &quot;this feature&quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Raises an exception if the given app setting is not defined.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.application.settings.get(name):</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                &quot;You must define the &#39;%s&#39; setting in your &quot;</span>
<span class="gi">+                &quot;application to use %s&quot; % (name, feature)</span>
<span class="gi">+            )</span>

<span class="gd">-    def reverse_url(self, name: str, *args: Any) -&gt;str:</span>
<span class="gi">+    def reverse_url(self, name: str, *args: Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Alias for `Application.reverse_url`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.application.reverse_url(name, *args)</span>

<span class="gd">-    def compute_etag(self) -&gt;Optional[str]:</span>
<span class="gi">+    def compute_etag(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Computes the etag header to be used for this request.

<span class="w"> </span>        By default uses a hash of the content written so far.
<span class="gu">@@ -969,18 +1687,23 @@ class RequestHandler(object):</span>
<span class="w"> </span>        May be overridden to provide custom etag implementations,
<span class="w"> </span>        or may return None to disable tornado&#39;s default etag support.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hasher = hashlib.sha1()</span>
<span class="gi">+        for part in self._write_buffer:</span>
<span class="gi">+            hasher.update(part)</span>
<span class="gi">+        return &#39;&quot;%s&quot;&#39; % hasher.hexdigest()</span>

<span class="gd">-    def set_etag_header(self) -&gt;None:</span>
<span class="gi">+    def set_etag_header(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the response&#39;s Etag header using ``self.compute_etag()``.

<span class="w"> </span>        Note: no header will be set if ``compute_etag()`` returns ``None``.

<span class="w"> </span>        This method is called automatically when the request is finished.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        etag = self.compute_etag()</span>
<span class="gi">+        if etag is not None:</span>
<span class="gi">+            self.set_header(&quot;Etag&quot;, etag)</span>

<span class="gd">-    def check_etag_header(self) -&gt;bool:</span>
<span class="gi">+    def check_etag_header(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks the ``Etag`` header against requests&#39;s ``If-None-Match``.

<span class="w"> </span>        Returns ``True`` if the request&#39;s Etag matches and a 304 should be
<span class="gu">@@ -997,33 +1720,143 @@ class RequestHandler(object):</span>
<span class="w"> </span>        before completing the request.  The ``Etag`` header should be set
<span class="w"> </span>        (perhaps with `set_etag_header`) before calling this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def _execute(self, transforms: List[&#39;OutputTransform&#39;], *args:</span>
<span class="gd">-        bytes, **kwargs: bytes) -&gt;None:</span>
<span class="gi">+        computed_etag = utf8(self._headers.get(&quot;Etag&quot;, &quot;&quot;))</span>
<span class="gi">+        # Find all weak and strong etag values from If-None-Match header</span>
<span class="gi">+        # because RFC 7232 allows multiple etag values in a single header.</span>
<span class="gi">+        etags = re.findall(</span>
<span class="gi">+            rb&#39;\*|(?:W/)?&quot;[^&quot;]*&quot;&#39;, utf8(self.request.headers.get(&quot;If-None-Match&quot;, &quot;&quot;))</span>
<span class="gi">+        )</span>
<span class="gi">+        if not computed_etag or not etags:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        match = False</span>
<span class="gi">+        if etags[0] == b&quot;*&quot;:</span>
<span class="gi">+            match = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Use a weak comparison when comparing entity-tags.</span>
<span class="gi">+            def val(x: bytes) -&gt; bytes:</span>
<span class="gi">+                return x[2:] if x.startswith(b&quot;W/&quot;) else x</span>
<span class="gi">+</span>
<span class="gi">+            for etag in etags:</span>
<span class="gi">+                if val(etag) == val(computed_etag):</span>
<span class="gi">+                    match = True</span>
<span class="gi">+                    break</span>
<span class="gi">+        return match</span>
<span class="gi">+</span>
<span class="gi">+    async def _execute(</span>
<span class="gi">+        self, transforms: List[&quot;OutputTransform&quot;], *args: bytes, **kwargs: bytes</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Executes this request with the given output transforms.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._transforms = transforms</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.request.method not in self.SUPPORTED_METHODS:</span>
<span class="gi">+                raise HTTPError(405)</span>
<span class="gi">+            self.path_args = [self.decode_argument(arg) for arg in args]</span>
<span class="gi">+            self.path_kwargs = dict(</span>
<span class="gi">+                (k, self.decode_argument(v, name=k)) for (k, v) in kwargs.items()</span>
<span class="gi">+            )</span>
<span class="gi">+            # If XSRF cookies are turned on, reject form submissions without</span>
<span class="gi">+            # the proper cookie</span>
<span class="gi">+            if self.request.method not in (</span>
<span class="gi">+                &quot;GET&quot;,</span>
<span class="gi">+                &quot;HEAD&quot;,</span>
<span class="gi">+                &quot;OPTIONS&quot;,</span>
<span class="gi">+            ) and self.application.settings.get(&quot;xsrf_cookies&quot;):</span>
<span class="gi">+                self.check_xsrf_cookie()</span>
<span class="gi">+</span>
<span class="gi">+            result = self.prepare()</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                result = await result  # type: ignore</span>
<span class="gi">+            if self._prepared_future is not None:</span>
<span class="gi">+                # Tell the Application we&#39;ve finished with prepare()</span>
<span class="gi">+                # and are ready for the body to arrive.</span>
<span class="gi">+                future_set_result_unless_cancelled(self._prepared_future, None)</span>
<span class="gi">+            if self._finished:</span>
<span class="gi">+                return</span>

<span class="gd">-    def data_received(self, chunk: bytes) -&gt;Optional[Awaitable[None]]:</span>
<span class="gi">+            if _has_stream_request_body(self.__class__):</span>
<span class="gi">+                # In streaming mode request.body is a Future that signals</span>
<span class="gi">+                # the body has been completely received.  The Future has no</span>
<span class="gi">+                # result; the data has been passed to self.data_received</span>
<span class="gi">+                # instead.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    await self.request._body_future</span>
<span class="gi">+                except iostream.StreamClosedError:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            method = getattr(self, self.request.method.lower())</span>
<span class="gi">+            result = method(*self.path_args, **self.path_kwargs)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                result = await result</span>
<span class="gi">+            if self._auto_finish and not self._finished:</span>
<span class="gi">+                self.finish()</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._handle_request_exception(e)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                app_log.error(&quot;Exception in exception handler&quot;, exc_info=True)</span>
<span class="gi">+            finally:</span>
<span class="gi">+                # Unset result to avoid circular references</span>
<span class="gi">+                result = None</span>
<span class="gi">+            if self._prepared_future is not None and not self._prepared_future.done():</span>
<span class="gi">+                # In case we failed before setting _prepared_future, do it</span>
<span class="gi">+                # now (to unblock the HTTP server).  Note that this is not</span>
<span class="gi">+                # in a finally block to avoid GC issues prior to Python 3.4.</span>
<span class="gi">+                self._prepared_future.set_result(None)</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, chunk: bytes) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Implement this method to handle streamed request data.

<span class="w"> </span>        Requires the `.stream_request_body` decorator.

<span class="w"> </span>        May be a coroutine for flow control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def _log(self) -&gt;None:</span>
<span class="gi">+    def _log(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Logs the current request.

<span class="w"> </span>        Sort of deprecated since this functionality was moved to the
<span class="w"> </span>        Application, but left in place for the benefit of existing apps
<span class="w"> </span>        that have overridden this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def log_exception(self, typ: &#39;Optional[Type[BaseException]]&#39;, value:</span>
<span class="gd">-        Optional[BaseException], tb: Optional[TracebackType]) -&gt;None:</span>
<span class="gi">+        self.application.log_request(self)</span>
<span class="gi">+</span>
<span class="gi">+    def _request_summary(self) -&gt; str:</span>
<span class="gi">+        return &quot;%s %s (%s)&quot; % (</span>
<span class="gi">+            self.request.method,</span>
<span class="gi">+            self.request.uri,</span>
<span class="gi">+            self.request.remote_ip,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_request_exception(self, e: BaseException) -&gt; None:</span>
<span class="gi">+        if isinstance(e, Finish):</span>
<span class="gi">+            # Not an error; just finish the request without logging.</span>
<span class="gi">+            if not self._finished:</span>
<span class="gi">+                self.finish(*e.args)</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.log_exception(*sys.exc_info())</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # An error here should still get a best-effort send_error()</span>
<span class="gi">+            # to avoid leaking the connection.</span>
<span class="gi">+            app_log.error(&quot;Error in exception logger&quot;, exc_info=True)</span>
<span class="gi">+        if self._finished:</span>
<span class="gi">+            # Extra errors after the request has been finished should</span>
<span class="gi">+            # be logged, but there is no reason to continue to try and</span>
<span class="gi">+            # send a response.</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(e, HTTPError):</span>
<span class="gi">+            self.send_error(e.status_code, exc_info=sys.exc_info())</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.send_error(500, exc_info=sys.exc_info())</span>
<span class="gi">+</span>
<span class="gi">+    def log_exception(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to customize logging of uncaught exceptions.

<span class="w"> </span>        By default logs instances of `HTTPError` as warnings without
<span class="gu">@@ -1033,14 +1866,48 @@ class RequestHandler(object):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_RequestHandlerType = TypeVar(&#39;_RequestHandlerType&#39;, bound=RequestHandler)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def stream_request_body(cls: Type[_RequestHandlerType]) -&gt;Type[</span>
<span class="gd">-    _RequestHandlerType]:</span>
<span class="gi">+        if isinstance(value, HTTPError):</span>
<span class="gi">+            if value.log_message:</span>
<span class="gi">+                format = &quot;%d %s: &quot; + value.log_message</span>
<span class="gi">+                args = [value.status_code, self._request_summary()] + list(value.args)</span>
<span class="gi">+                gen_log.warning(format, *args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            app_log.error(</span>
<span class="gi">+                &quot;Uncaught exception %s\n%r&quot;,</span>
<span class="gi">+                self._request_summary(),</span>
<span class="gi">+                self.request,</span>
<span class="gi">+                exc_info=(typ, value, tb),  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _ui_module(self, name: str, module: Type[&quot;UIModule&quot;]) -&gt; Callable[..., str]:</span>
<span class="gi">+        def render(*args, **kwargs) -&gt; str:  # type: ignore</span>
<span class="gi">+            if not hasattr(self, &quot;_active_modules&quot;):</span>
<span class="gi">+                self._active_modules = {}  # type: Dict[str, UIModule]</span>
<span class="gi">+            if name not in self._active_modules:</span>
<span class="gi">+                self._active_modules[name] = module(self)</span>
<span class="gi">+            rendered = self._active_modules[name].render(*args, **kwargs)</span>
<span class="gi">+            return rendered</span>
<span class="gi">+</span>
<span class="gi">+        return render</span>
<span class="gi">+</span>
<span class="gi">+    def _ui_method(self, method: Callable[..., str]) -&gt; Callable[..., str]:</span>
<span class="gi">+        return lambda *args, **kwargs: method(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _clear_representation_headers(self) -&gt; None:</span>
<span class="gi">+        # 304 responses should not contain representation metadata</span>
<span class="gi">+        # headers (defined in</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc7231#section-3.1)</span>
<span class="gi">+        # not explicitly allowed by</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc7232#section-4.1</span>
<span class="gi">+        headers = [&quot;Content-Encoding&quot;, &quot;Content-Language&quot;, &quot;Content-Type&quot;]</span>
<span class="gi">+        for h in headers:</span>
<span class="gi">+            self.clear_header(h)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_RequestHandlerType = TypeVar(&quot;_RequestHandlerType&quot;, bound=RequestHandler)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def stream_request_body(cls: Type[_RequestHandlerType]) -&gt; Type[_RequestHandlerType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply to `RequestHandler` subclasses to enable streaming body support.

<span class="w"> </span>    This decorator implies the following changes:
<span class="gu">@@ -1060,30 +1927,73 @@ def stream_request_body(cls: Type[_RequestHandlerType]) -&gt;Type[</span>

<span class="w"> </span>    See the `file receiver demo &lt;https://github.com/tornadoweb/tornado/tree/stable/demos/file_upload/&gt;`_
<span class="w"> </span>    for example usage.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: E501</span>
<span class="gi">+    if not issubclass(cls, RequestHandler):</span>
<span class="gi">+        raise TypeError(&quot;expected subclass of RequestHandler, got %r&quot;, cls)</span>
<span class="gi">+    cls._stream_request_body = True</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_stream_request_body(cls: Type[RequestHandler]) -&gt; bool:</span>
<span class="gi">+    if not issubclass(cls, RequestHandler):</span>
<span class="gi">+        raise TypeError(&quot;expected subclass of RequestHandler, got %r&quot;, cls)</span>
<span class="gi">+    return cls._stream_request_body</span>


<span class="gd">-def removeslash(method: Callable[..., Optional[Awaitable[None]]]) -&gt;Callable[</span>
<span class="gd">-    ..., Optional[Awaitable[None]]]:</span>
<span class="gi">+def removeslash(</span>
<span class="gi">+    method: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+) -&gt; Callable[..., Optional[Awaitable[None]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use this decorator to remove trailing slashes from the request path.

<span class="w"> </span>    For example, a request to ``/foo/`` would redirect to ``/foo`` with this
<span class="w"> </span>    decorator. Your request handler mapping should use a regular expression
<span class="w"> </span>    like ``r&#39;/foo/*&#39;`` in conjunction with using the decorator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def addslash(method: Callable[..., Optional[Awaitable[None]]]) -&gt;Callable[</span>
<span class="gd">-    ..., Optional[Awaitable[None]]]:</span>
<span class="gi">+    @functools.wraps(method)</span>
<span class="gi">+    def wrapper(  # type: ignore</span>
<span class="gi">+        self: RequestHandler, *args, **kwargs</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if self.request.path.endswith(&quot;/&quot;):</span>
<span class="gi">+            if self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;):</span>
<span class="gi">+                uri = self.request.path.rstrip(&quot;/&quot;)</span>
<span class="gi">+                if uri:  # don&#39;t try to redirect &#39;/&#39; to &#39;&#39;</span>
<span class="gi">+                    if self.request.query:</span>
<span class="gi">+                        uri += &quot;?&quot; + self.request.query</span>
<span class="gi">+                    self.redirect(uri, permanent=True)</span>
<span class="gi">+                    return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise HTTPError(404)</span>
<span class="gi">+        return method(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def addslash(</span>
<span class="gi">+    method: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+) -&gt; Callable[..., Optional[Awaitable[None]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use this decorator to add a missing trailing slash to the request path.

<span class="w"> </span>    For example, a request to ``/foo`` would redirect to ``/foo/`` with this
<span class="w"> </span>    decorator. Your request handler mapping should use a regular expression
<span class="w"> </span>    like ``r&#39;/foo/?&#39;`` in conjunction with using the decorator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @functools.wraps(method)</span>
<span class="gi">+    def wrapper(  # type: ignore</span>
<span class="gi">+        self: RequestHandler, *args, **kwargs</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if not self.request.path.endswith(&quot;/&quot;):</span>
<span class="gi">+            if self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;):</span>
<span class="gi">+                uri = self.request.path + &quot;/&quot;</span>
<span class="gi">+                if self.request.query:</span>
<span class="gi">+                    uri += &quot;?&quot; + self.request.query</span>
<span class="gi">+                self.redirect(uri, permanent=True)</span>
<span class="gi">+                return None</span>
<span class="gi">+            raise HTTPError(404)</span>
<span class="gi">+        return method(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class _ApplicationRouter(ReversibleRuleRouter):
<span class="gu">@@ -1097,15 +2007,36 @@ class _ApplicationRouter(ReversibleRuleRouter):</span>
<span class="w"> </span>        `_ApplicationRouter` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, application: &#39;Application&#39;, rules: Optional[</span>
<span class="gd">-        _RuleList]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, application: &quot;Application&quot;, rules: Optional[_RuleList] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(application, Application)
<span class="w"> </span>        self.application = application
<span class="w"> </span>        super().__init__(rules)

<span class="gi">+    def process_rule(self, rule: Rule) -&gt; Rule:</span>
<span class="gi">+        rule = super().process_rule(rule)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(rule.target, (list, tuple)):</span>
<span class="gi">+            rule.target = _ApplicationRouter(</span>
<span class="gi">+                self.application, rule.target  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return rule</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_delegate(</span>
<span class="gi">+        self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any</span>
<span class="gi">+    ) -&gt; Optional[httputil.HTTPMessageDelegate]:</span>
<span class="gi">+        if isclass(target) and issubclass(target, RequestHandler):</span>
<span class="gi">+            return self.application.get_handler_delegate(</span>
<span class="gi">+                request, target, **target_params</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return super().get_target_delegate(target, request, **target_params)</span>
<span class="gi">+</span>

<span class="w"> </span>class Application(ReversibleRouter):
<span class="gd">-    &quot;&quot;&quot;A collection of request handlers that make up a web application.</span>
<span class="gi">+    r&quot;&quot;&quot;A collection of request handlers that make up a web application.</span>

<span class="w"> </span>    Instances of this class are callable and can be passed directly to
<span class="w"> </span>    HTTPServer to serve the application::
<span class="gu">@@ -1156,7 +2087,7 @@ class Application(ReversibleRouter):</span>
<span class="w"> </span>    We support virtual hosts with the `add_handlers` method, which takes in
<span class="w"> </span>    a host regular expression as the first argument::

<span class="gd">-        application.add_handlers(r&quot;www\\.myhost\\.com&quot;, [</span>
<span class="gi">+        application.add_handlers(r&quot;www\.myhost\.com&quot;, [</span>
<span class="w"> </span>            (r&quot;/article/([0-9]+)&quot;, ArticleHandler),
<span class="w"> </span>        ])

<span class="gu">@@ -1187,50 +2118,73 @@ class Application(ReversibleRouter):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, handlers: Optional[_RuleList]=None, default_host:</span>
<span class="gd">-        Optional[str]=None, transforms: Optional[List[Type[</span>
<span class="gd">-        &#39;OutputTransform&#39;]]]=None, **settings: Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        handlers: Optional[_RuleList] = None,</span>
<span class="gi">+        default_host: Optional[str] = None,</span>
<span class="gi">+        transforms: Optional[List[Type[&quot;OutputTransform&quot;]]] = None,</span>
<span class="gi">+        **settings: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if transforms is None:
<span class="gd">-            self.transforms = []</span>
<span class="gd">-            if settings.get(&#39;compress_response&#39;) or settings.get(&#39;gzip&#39;):</span>
<span class="gi">+            self.transforms = []  # type: List[Type[OutputTransform]]</span>
<span class="gi">+            if settings.get(&quot;compress_response&quot;) or settings.get(&quot;gzip&quot;):</span>
<span class="w"> </span>                self.transforms.append(GZipContentEncoding)
<span class="w"> </span>        else:
<span class="w"> </span>            self.transforms = transforms
<span class="w"> </span>        self.default_host = default_host
<span class="w"> </span>        self.settings = settings
<span class="gd">-        self.ui_modules = {&#39;linkify&#39;: _linkify, &#39;xsrf_form_html&#39;:</span>
<span class="gd">-            _xsrf_form_html, &#39;Template&#39;: TemplateModule}</span>
<span class="gd">-        self.ui_methods = {}</span>
<span class="gd">-        self._load_ui_modules(settings.get(&#39;ui_modules&#39;, {}))</span>
<span class="gd">-        self._load_ui_methods(settings.get(&#39;ui_methods&#39;, {}))</span>
<span class="gd">-        if self.settings.get(&#39;static_path&#39;):</span>
<span class="gd">-            path = self.settings[&#39;static_path&#39;]</span>
<span class="gi">+        self.ui_modules = {</span>
<span class="gi">+            &quot;linkify&quot;: _linkify,</span>
<span class="gi">+            &quot;xsrf_form_html&quot;: _xsrf_form_html,</span>
<span class="gi">+            &quot;Template&quot;: TemplateModule,</span>
<span class="gi">+        }</span>
<span class="gi">+        self.ui_methods = {}  # type: Dict[str, Callable[..., str]]</span>
<span class="gi">+        self._load_ui_modules(settings.get(&quot;ui_modules&quot;, {}))</span>
<span class="gi">+        self._load_ui_methods(settings.get(&quot;ui_methods&quot;, {}))</span>
<span class="gi">+        if self.settings.get(&quot;static_path&quot;):</span>
<span class="gi">+            path = self.settings[&quot;static_path&quot;]</span>
<span class="w"> </span>            handlers = list(handlers or [])
<span class="gd">-            static_url_prefix = settings.get(&#39;static_url_prefix&#39;, &#39;/static/&#39;)</span>
<span class="gd">-            static_handler_class = settings.get(&#39;static_handler_class&#39;,</span>
<span class="gd">-                StaticFileHandler)</span>
<span class="gd">-            static_handler_args = settings.get(&#39;static_handler_args&#39;, {})</span>
<span class="gd">-            static_handler_args[&#39;path&#39;] = path</span>
<span class="gd">-            for pattern in [re.escape(static_url_prefix) + &#39;(.*)&#39;,</span>
<span class="gd">-                &#39;/(favicon\\.ico)&#39;, &#39;/(robots\\.txt)&#39;]:</span>
<span class="gd">-                handlers.insert(0, (pattern, static_handler_class,</span>
<span class="gd">-                    static_handler_args))</span>
<span class="gd">-        if self.settings.get(&#39;debug&#39;):</span>
<span class="gd">-            self.settings.setdefault(&#39;autoreload&#39;, True)</span>
<span class="gd">-            self.settings.setdefault(&#39;compiled_template_cache&#39;, False)</span>
<span class="gd">-            self.settings.setdefault(&#39;static_hash_cache&#39;, False)</span>
<span class="gd">-            self.settings.setdefault(&#39;serve_traceback&#39;, True)</span>
<span class="gi">+            static_url_prefix = settings.get(&quot;static_url_prefix&quot;, &quot;/static/&quot;)</span>
<span class="gi">+            static_handler_class = settings.get(</span>
<span class="gi">+                &quot;static_handler_class&quot;, StaticFileHandler</span>
<span class="gi">+            )</span>
<span class="gi">+            static_handler_args = settings.get(&quot;static_handler_args&quot;, {})</span>
<span class="gi">+            static_handler_args[&quot;path&quot;] = path</span>
<span class="gi">+            for pattern in [</span>
<span class="gi">+                re.escape(static_url_prefix) + r&quot;(.*)&quot;,</span>
<span class="gi">+                r&quot;/(favicon\.ico)&quot;,</span>
<span class="gi">+                r&quot;/(robots\.txt)&quot;,</span>
<span class="gi">+            ]:</span>
<span class="gi">+                handlers.insert(0, (pattern, static_handler_class, static_handler_args))</span>
<span class="gi">+</span>
<span class="gi">+        if self.settings.get(&quot;debug&quot;):</span>
<span class="gi">+            self.settings.setdefault(&quot;autoreload&quot;, True)</span>
<span class="gi">+            self.settings.setdefault(&quot;compiled_template_cache&quot;, False)</span>
<span class="gi">+            self.settings.setdefault(&quot;static_hash_cache&quot;, False)</span>
<span class="gi">+            self.settings.setdefault(&quot;serve_traceback&quot;, True)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.wildcard_router = _ApplicationRouter(self, handlers)
<span class="gd">-        self.default_router = _ApplicationRouter(self, [Rule(AnyMatches(),</span>
<span class="gd">-            self.wildcard_router)])</span>
<span class="gd">-        if self.settings.get(&#39;autoreload&#39;):</span>
<span class="gi">+        self.default_router = _ApplicationRouter(</span>
<span class="gi">+            self, [Rule(AnyMatches(), self.wildcard_router)]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Automatically reload modified modules</span>
<span class="gi">+        if self.settings.get(&quot;autoreload&quot;):</span>
<span class="w"> </span>            from tornado import autoreload
<span class="gi">+</span>
<span class="w"> </span>            autoreload.start()

<span class="gd">-    def listen(self, port: int, address: Optional[str]=None, *, family:</span>
<span class="gd">-        socket.AddressFamily=socket.AF_UNSPEC, backlog: int=tornado.netutil</span>
<span class="gd">-        ._DEFAULT_BACKLOG, flags: Optional[int]=None, reuse_port: bool=</span>
<span class="gd">-        False, **kwargs: Any) -&gt;HTTPServer:</span>
<span class="gi">+    def listen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        port: int,</span>
<span class="gi">+        address: Optional[str] = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        family: socket.AddressFamily = socket.AF_UNSPEC,</span>
<span class="gi">+        backlog: int = tornado.netutil._DEFAULT_BACKLOG,</span>
<span class="gi">+        flags: Optional[int] = None,</span>
<span class="gi">+        reuse_port: bool = False,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; HTTPServer:</span>
<span class="w"> </span>        &quot;&quot;&quot;Starts an HTTP server for this application on the given port.

<span class="w"> </span>        This is a convenience alias for creating an `.HTTPServer` object and
<span class="gu">@@ -1253,25 +2207,97 @@ class Application(ReversibleRouter):</span>
<span class="w"> </span>           Added support for new keyword arguments in `.TCPServer.listen`,
<span class="w"> </span>           including ``reuse_port``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_handlers(self, host_pattern: str, host_handlers: _RuleList) -&gt;None:</span>
<span class="gi">+        server = HTTPServer(self, **kwargs)</span>
<span class="gi">+        server.listen(</span>
<span class="gi">+            port,</span>
<span class="gi">+            address=address,</span>
<span class="gi">+            family=family,</span>
<span class="gi">+            backlog=backlog,</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            reuse_port=reuse_port,</span>
<span class="gi">+        )</span>
<span class="gi">+        return server</span>
<span class="gi">+</span>
<span class="gi">+    def add_handlers(self, host_pattern: str, host_handlers: _RuleList) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Appends the given handlers to our handler list.

<span class="w"> </span>        Host patterns are processed sequentially in the order they were
<span class="w"> </span>        added. All matching patterns will be considered.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        host_matcher = HostMatches(host_pattern)</span>
<span class="gi">+        rule = Rule(host_matcher, _ApplicationRouter(self, host_handlers))</span>

<span class="gd">-    def __call__(self, request: httputil.HTTPServerRequest) -&gt;Optional[</span>
<span class="gd">-        Awaitable[None]]:</span>
<span class="gi">+        self.default_router.rules.insert(-1, rule)</span>
<span class="gi">+</span>
<span class="gi">+        if self.default_host is not None:</span>
<span class="gi">+            self.wildcard_router.add_rules(</span>
<span class="gi">+                [(DefaultHostMatches(self, host_matcher.host_pattern), host_handlers)]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def add_transform(self, transform_class: Type[&quot;OutputTransform&quot;]) -&gt; None:</span>
<span class="gi">+        self.transforms.append(transform_class)</span>
<span class="gi">+</span>
<span class="gi">+    def _load_ui_methods(self, methods: Any) -&gt; None:</span>
<span class="gi">+        if isinstance(methods, types.ModuleType):</span>
<span class="gi">+            self._load_ui_methods(dict((n, getattr(methods, n)) for n in dir(methods)))</span>
<span class="gi">+        elif isinstance(methods, list):</span>
<span class="gi">+            for m in methods:</span>
<span class="gi">+                self._load_ui_methods(m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for name, fn in methods.items():</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not name.startswith(&quot;_&quot;)</span>
<span class="gi">+                    and hasattr(fn, &quot;__call__&quot;)</span>
<span class="gi">+                    and name[0].lower() == name[0]</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.ui_methods[name] = fn</span>
<span class="gi">+</span>
<span class="gi">+    def _load_ui_modules(self, modules: Any) -&gt; None:</span>
<span class="gi">+        if isinstance(modules, types.ModuleType):</span>
<span class="gi">+            self._load_ui_modules(dict((n, getattr(modules, n)) for n in dir(modules)))</span>
<span class="gi">+        elif isinstance(modules, list):</span>
<span class="gi">+            for m in modules:</span>
<span class="gi">+                self._load_ui_modules(m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert isinstance(modules, dict)</span>
<span class="gi">+            for name, cls in modules.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    if issubclass(cls, UIModule):</span>
<span class="gi">+                        self.ui_modules[name] = cls</span>
<span class="gi">+                except TypeError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, request: httputil.HTTPServerRequest</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        # Legacy HTTPServer interface</span>
<span class="w"> </span>        dispatcher = self.find_handler(request)
<span class="w"> </span>        return dispatcher.execute()

<span class="gd">-    def get_handler_delegate(self, request: httputil.HTTPServerRequest,</span>
<span class="gd">-        target_class: Type[RequestHandler], target_kwargs: Optional[Dict[</span>
<span class="gd">-        str, Any]]=None, path_args: Optional[List[bytes]]=None, path_kwargs:</span>
<span class="gd">-        Optional[Dict[str, bytes]]=None) -&gt;&#39;_HandlerDelegate&#39;:</span>
<span class="gi">+    def find_handler(</span>
<span class="gi">+        self, request: httputil.HTTPServerRequest, **kwargs: Any</span>
<span class="gi">+    ) -&gt; &quot;_HandlerDelegate&quot;:</span>
<span class="gi">+        route = self.default_router.find_handler(request)</span>
<span class="gi">+        if route is not None:</span>
<span class="gi">+            return cast(&quot;_HandlerDelegate&quot;, route)</span>
<span class="gi">+</span>
<span class="gi">+        if self.settings.get(&quot;default_handler_class&quot;):</span>
<span class="gi">+            return self.get_handler_delegate(</span>
<span class="gi">+                request,</span>
<span class="gi">+                self.settings[&quot;default_handler_class&quot;],</span>
<span class="gi">+                self.settings.get(&quot;default_handler_args&quot;, {}),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return self.get_handler_delegate(request, ErrorHandler, {&quot;status_code&quot;: 404})</span>
<span class="gi">+</span>
<span class="gi">+    def get_handler_delegate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: httputil.HTTPServerRequest,</span>
<span class="gi">+        target_class: Type[RequestHandler],</span>
<span class="gi">+        target_kwargs: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        path_args: Optional[List[bytes]] = None,</span>
<span class="gi">+        path_kwargs: Optional[Dict[str, bytes]] = None,</span>
<span class="gi">+    ) -&gt; &quot;_HandlerDelegate&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns `~.httputil.HTTPMessageDelegate` that can serve a request
<span class="w"> </span>        for application and `RequestHandler` subclass.

<span class="gu">@@ -1282,9 +2308,11 @@ class Application(ReversibleRouter):</span>
<span class="w"> </span>            will be executed while handling a request (``get``, ``post`` or any other).
<span class="w"> </span>        :arg dict path_kwargs: keyword arguments for ``target_class`` HTTP method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _HandlerDelegate(</span>
<span class="gi">+            self, request, target_class, target_kwargs, path_args, path_kwargs</span>
<span class="gi">+        )</span>

<span class="gd">-    def reverse_url(self, name: str, *args: Any) -&gt;str:</span>
<span class="gi">+    def reverse_url(self, name: str, *args: Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a URL path for handler named ``name``

<span class="w"> </span>        The handler must be added to the application as a named `URLSpec`.
<span class="gu">@@ -1293,9 +2321,13 @@ class Application(ReversibleRouter):</span>
<span class="w"> </span>        They will be converted to strings if necessary, encoded as utf8,
<span class="w"> </span>        and url-escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        reversed_url = self.default_router.reverse_url(name, *args)</span>
<span class="gi">+        if reversed_url is not None:</span>
<span class="gi">+            return reversed_url</span>
<span class="gi">+</span>
<span class="gi">+        raise KeyError(&quot;%s not found in named urls&quot; % name)</span>

<span class="gd">-    def log_request(self, handler: RequestHandler) -&gt;None:</span>
<span class="gi">+    def log_request(self, handler: RequestHandler) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a completed HTTP request to the logs.

<span class="w"> </span>        By default writes to the python root logger.  To change
<span class="gu">@@ -1303,15 +2335,34 @@ class Application(ReversibleRouter):</span>
<span class="w"> </span>        or pass a function in the application settings dictionary as
<span class="w"> </span>        ``log_function``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;log_function&quot; in self.settings:</span>
<span class="gi">+            self.settings[&quot;log_function&quot;](handler)</span>
<span class="gi">+            return</span>
<span class="gi">+        if handler.get_status() &lt; 400:</span>
<span class="gi">+            log_method = access_log.info</span>
<span class="gi">+        elif handler.get_status() &lt; 500:</span>
<span class="gi">+            log_method = access_log.warning</span>
<span class="gi">+        else:</span>
<span class="gi">+            log_method = access_log.error</span>
<span class="gi">+        request_time = 1000.0 * handler.request.request_time()</span>
<span class="gi">+        log_method(</span>
<span class="gi">+            &quot;%d %s %.2fms&quot;,</span>
<span class="gi">+            handler.get_status(),</span>
<span class="gi">+            handler._request_summary(),</span>
<span class="gi">+            request_time,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class _HandlerDelegate(httputil.HTTPMessageDelegate):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, application: Application, request: httputil.</span>
<span class="gd">-        HTTPServerRequest, handler_class: Type[RequestHandler],</span>
<span class="gd">-        handler_kwargs: Optional[Dict[str, Any]], path_args: Optional[List[</span>
<span class="gd">-        bytes]], path_kwargs: Optional[Dict[str, bytes]]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        application: Application,</span>
<span class="gi">+        request: httputil.HTTPServerRequest,</span>
<span class="gi">+        handler_class: Type[RequestHandler],</span>
<span class="gi">+        handler_kwargs: Optional[Dict[str, Any]],</span>
<span class="gi">+        path_args: Optional[List[bytes]],</span>
<span class="gi">+        path_kwargs: Optional[Dict[str, bytes]],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.application = application
<span class="w"> </span>        self.connection = request.connection
<span class="w"> </span>        self.request = request
<span class="gu">@@ -1319,9 +2370,77 @@ class _HandlerDelegate(httputil.HTTPMessageDelegate):</span>
<span class="w"> </span>        self.handler_kwargs = handler_kwargs or {}
<span class="w"> </span>        self.path_args = path_args or []
<span class="w"> </span>        self.path_kwargs = path_kwargs or {}
<span class="gd">-        self.chunks = []</span>
<span class="gi">+        self.chunks = []  # type: List[bytes]</span>
<span class="w"> </span>        self.stream_request_body = _has_stream_request_body(self.handler_class)

<span class="gi">+    def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if self.stream_request_body:</span>
<span class="gi">+            self.request._body_future = Future()</span>
<span class="gi">+            return self.execute()</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, data: bytes) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if self.stream_request_body:</span>
<span class="gi">+            return self.handler.data_received(data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.chunks.append(data)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        if self.stream_request_body:</span>
<span class="gi">+            future_set_result_unless_cancelled(self.request._body_future, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.request.body = b&quot;&quot;.join(self.chunks)</span>
<span class="gi">+            self.request._parse_body()</span>
<span class="gi">+            self.execute()</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        if self.stream_request_body:</span>
<span class="gi">+            self.handler.on_connection_close()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.chunks = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def execute(self) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        # If template cache is disabled (usually in the debug mode),</span>
<span class="gi">+        # re-compile templates and reload static files on every</span>
<span class="gi">+        # request so you don&#39;t need to restart to see changes</span>
<span class="gi">+        if not self.application.settings.get(&quot;compiled_template_cache&quot;, True):</span>
<span class="gi">+            with RequestHandler._template_loader_lock:</span>
<span class="gi">+                for loader in RequestHandler._template_loaders.values():</span>
<span class="gi">+                    loader.reset()</span>
<span class="gi">+        if not self.application.settings.get(&quot;static_hash_cache&quot;, True):</span>
<span class="gi">+            static_handler_class = self.application.settings.get(</span>
<span class="gi">+                &quot;static_handler_class&quot;, StaticFileHandler</span>
<span class="gi">+            )</span>
<span class="gi">+            static_handler_class.reset()</span>
<span class="gi">+</span>
<span class="gi">+        self.handler = self.handler_class(</span>
<span class="gi">+            self.application, self.request, **self.handler_kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+        transforms = [t(self.request) for t in self.application.transforms]</span>
<span class="gi">+</span>
<span class="gi">+        if self.stream_request_body:</span>
<span class="gi">+            self.handler._prepared_future = Future()</span>
<span class="gi">+        # Note that if an exception escapes handler._execute it will be</span>
<span class="gi">+        # trapped in the Future it returns (which we are ignoring here,</span>
<span class="gi">+        # leaving it to be logged when the Future is GC&#39;d).</span>
<span class="gi">+        # However, that shouldn&#39;t happen because _execute has a blanket</span>
<span class="gi">+        # except handler, and we cannot easily access the IOLoop here to</span>
<span class="gi">+        # call add_future (because of the requirement to remain compatible</span>
<span class="gi">+        # with WSGI)</span>
<span class="gi">+        fut = gen.convert_yielded(</span>
<span class="gi">+            self.handler._execute(transforms, *self.path_args, **self.path_kwargs)</span>
<span class="gi">+        )</span>
<span class="gi">+        fut.add_done_callback(lambda f: f.result())</span>
<span class="gi">+        # If we are streaming the request body, then execute() is finished</span>
<span class="gi">+        # when the handler has prepared to receive the body.  If not,</span>
<span class="gi">+        # it doesn&#39;t matter when execute() finishes (so we return None)</span>
<span class="gi">+        return self.handler._prepared_future</span>
<span class="gi">+</span>

<span class="w"> </span>class HTTPError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;An exception that will turn into an HTTP error response.
<span class="gu">@@ -1346,20 +2465,27 @@ class HTTPError(Exception):</span>
<span class="w"> </span>        to use a non-standard numeric code.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, status_code: int=500, log_message: Optional[str]=</span>
<span class="gd">-        None, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        status_code: int = 500,</span>
<span class="gi">+        log_message: Optional[str] = None,</span>
<span class="gi">+        *args: Any,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.status_code = status_code
<span class="w"> </span>        self.log_message = log_message
<span class="w"> </span>        self.args = args
<span class="gd">-        self.reason = kwargs.get(&#39;reason&#39;, None)</span>
<span class="gi">+        self.reason = kwargs.get(&quot;reason&quot;, None)</span>
<span class="w"> </span>        if log_message and not args:
<span class="gd">-            self.log_message = log_message.replace(&#39;%&#39;, &#39;%%&#39;)</span>
<span class="gi">+            self.log_message = log_message.replace(&quot;%&quot;, &quot;%%&quot;)</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        message = &#39;HTTP %d: %s&#39; % (self.status_code, self.reason or</span>
<span class="gd">-            httputil.responses.get(self.status_code, &#39;Unknown&#39;))</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        message = &quot;HTTP %d: %s&quot; % (</span>
<span class="gi">+            self.status_code,</span>
<span class="gi">+            self.reason or httputil.responses.get(self.status_code, &quot;Unknown&quot;),</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if self.log_message:
<span class="gd">-            return message + &#39; (&#39; + self.log_message % self.args + &#39;)&#39;</span>
<span class="gi">+            return message + &quot; (&quot; + (self.log_message % self.args) + &quot;)&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return message

<span class="gu">@@ -1388,6 +2514,7 @@ class Finish(Exception):</span>
<span class="w"> </span>       Arguments passed to ``Finish()`` will be passed on to
<span class="w"> </span>       `RequestHandler.finish`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -1400,14 +2527,26 @@ class MissingArgumentError(HTTPError):</span>
<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, arg_name: str) -&gt;None:</span>
<span class="gd">-        super().__init__(400, &#39;Missing argument %s&#39; % arg_name)</span>
<span class="gi">+    def __init__(self, arg_name: str) -&gt; None:</span>
<span class="gi">+        super().__init__(400, &quot;Missing argument %s&quot; % arg_name)</span>
<span class="w"> </span>        self.arg_name = arg_name


<span class="w"> </span>class ErrorHandler(RequestHandler):
<span class="w"> </span>    &quot;&quot;&quot;Generates an error response with ``status_code`` for all requests.&quot;&quot;&quot;

<span class="gi">+    def initialize(self, status_code: int) -&gt; None:</span>
<span class="gi">+        self.set_status(status_code)</span>
<span class="gi">+</span>
<span class="gi">+    def prepare(self) -&gt; None:</span>
<span class="gi">+        raise HTTPError(self._status_code)</span>
<span class="gi">+</span>
<span class="gi">+    def check_xsrf_cookie(self) -&gt; None:</span>
<span class="gi">+        # POSTs to an ErrorHandler don&#39;t actually have side effects,</span>
<span class="gi">+        # so we don&#39;t need to check the xsrf token.  This allows POSTs</span>
<span class="gi">+        # to the wrong url to return a 404 instead of 403.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class RedirectHandler(RequestHandler):
<span class="w"> </span>    &quot;&quot;&quot;Redirects the client to the given URL for all GET requests.
<span class="gu">@@ -1442,6 +2581,20 @@ class RedirectHandler(RequestHandler):</span>
<span class="w"> </span>       destination URL.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def initialize(self, url: str, permanent: bool = True) -&gt; None:</span>
<span class="gi">+        self._url = url</span>
<span class="gi">+        self._permanent = permanent</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        to_url = self._url.format(*args, **kwargs)</span>
<span class="gi">+        if self.request.query_arguments:</span>
<span class="gi">+            # TODO: figure out typing for the next line.</span>
<span class="gi">+            to_url = httputil.url_concat(</span>
<span class="gi">+                to_url,</span>
<span class="gi">+                list(httputil.qs_to_qsl(self.request.query_arguments)),  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+        self.redirect(to_url, permanent=self._permanent)</span>
<span class="gi">+</span>

<span class="w"> </span>class StaticFileHandler(RequestHandler):
<span class="w"> </span>    &quot;&quot;&quot;A simple handler that can serve static content from a directory.
<span class="gu">@@ -1509,11 +2662,108 @@ class StaticFileHandler(RequestHandler):</span>
<span class="w"> </span>    .. versionchanged:: 3.1
<span class="w"> </span>       Many of the methods for subclasses were added in Tornado 3.1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    CACHE_MAX_AGE = 86400 * 365 * 10</span>
<span class="gd">-    _static_hashes = {}</span>
<span class="gd">-    _lock = threading.Lock()</span>

<span class="gd">-    def compute_etag(self) -&gt;Optional[str]:</span>
<span class="gi">+    CACHE_MAX_AGE = 86400 * 365 * 10  # 10 years</span>
<span class="gi">+</span>
<span class="gi">+    _static_hashes = {}  # type: Dict[str, Optional[str]]</span>
<span class="gi">+    _lock = threading.Lock()  # protects _static_hashes</span>
<span class="gi">+</span>
<span class="gi">+    def initialize(self, path: str, default_filename: Optional[str] = None) -&gt; None:</span>
<span class="gi">+        self.root = path</span>
<span class="gi">+        self.default_filename = default_filename</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def reset(cls) -&gt; None:</span>
<span class="gi">+        with cls._lock:</span>
<span class="gi">+            cls._static_hashes = {}</span>
<span class="gi">+</span>
<span class="gi">+    def head(self, path: str) -&gt; Awaitable[None]:</span>
<span class="gi">+        return self.get(path, include_body=False)</span>
<span class="gi">+</span>
<span class="gi">+    async def get(self, path: str, include_body: bool = True) -&gt; None:</span>
<span class="gi">+        # Set up our path instance variables.</span>
<span class="gi">+        self.path = self.parse_url_path(path)</span>
<span class="gi">+        del path  # make sure we don&#39;t refer to path instead of self.path again</span>
<span class="gi">+        absolute_path = self.get_absolute_path(self.root, self.path)</span>
<span class="gi">+        self.absolute_path = self.validate_absolute_path(self.root, absolute_path)</span>
<span class="gi">+        if self.absolute_path is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.modified = self.get_modified_time()</span>
<span class="gi">+        self.set_headers()</span>
<span class="gi">+</span>
<span class="gi">+        if self.should_return_304():</span>
<span class="gi">+            self.set_status(304)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        request_range = None</span>
<span class="gi">+        range_header = self.request.headers.get(&quot;Range&quot;)</span>
<span class="gi">+        if range_header:</span>
<span class="gi">+            # As per RFC 2616 14.16, if an invalid Range header is specified,</span>
<span class="gi">+            # the request will be treated as if the header didn&#39;t exist.</span>
<span class="gi">+            request_range = httputil._parse_request_range(range_header)</span>
<span class="gi">+</span>
<span class="gi">+        size = self.get_content_size()</span>
<span class="gi">+        if request_range:</span>
<span class="gi">+            start, end = request_range</span>
<span class="gi">+            if start is not None and start &lt; 0:</span>
<span class="gi">+                start += size</span>
<span class="gi">+                if start &lt; 0:</span>
<span class="gi">+                    start = 0</span>
<span class="gi">+            if (</span>
<span class="gi">+                start is not None</span>
<span class="gi">+                and (start &gt;= size or (end is not None and start &gt;= end))</span>
<span class="gi">+            ) or end == 0:</span>
<span class="gi">+                # As per RFC 2616 14.35.1, a range is not satisfiable only: if</span>
<span class="gi">+                # the first requested byte is equal to or greater than the</span>
<span class="gi">+                # content, or when a suffix with length 0 is specified.</span>
<span class="gi">+                # https://tools.ietf.org/html/rfc7233#section-2.1</span>
<span class="gi">+                # A byte-range-spec is invalid if the last-byte-pos value is present</span>
<span class="gi">+                # and less than the first-byte-pos.</span>
<span class="gi">+                self.set_status(416)  # Range Not Satisfiable</span>
<span class="gi">+                self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span>
<span class="gi">+                self.set_header(&quot;Content-Range&quot;, &quot;bytes */%s&quot; % (size,))</span>
<span class="gi">+                return</span>
<span class="gi">+            if end is not None and end &gt; size:</span>
<span class="gi">+                # Clients sometimes blindly use a large range to limit their</span>
<span class="gi">+                # download size; cap the endpoint at the actual file size.</span>
<span class="gi">+                end = size</span>
<span class="gi">+            # Note: only return HTTP 206 if less than the entire range has been</span>
<span class="gi">+            # requested. Not only is this semantically correct, but Chrome</span>
<span class="gi">+            # refuses to play audio if it gets an HTTP 206 in response to</span>
<span class="gi">+            # ``Range: bytes=0-``.</span>
<span class="gi">+            if size != (end or size) - (start or 0):</span>
<span class="gi">+                self.set_status(206)  # Partial Content</span>
<span class="gi">+                self.set_header(</span>
<span class="gi">+                    &quot;Content-Range&quot;, httputil._get_content_range(start, end, size)</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            start = end = None</span>
<span class="gi">+</span>
<span class="gi">+        if start is not None and end is not None:</span>
<span class="gi">+            content_length = end - start</span>
<span class="gi">+        elif end is not None:</span>
<span class="gi">+            content_length = end</span>
<span class="gi">+        elif start is not None:</span>
<span class="gi">+            content_length = size - start</span>
<span class="gi">+        else:</span>
<span class="gi">+            content_length = size</span>
<span class="gi">+        self.set_header(&quot;Content-Length&quot;, content_length)</span>
<span class="gi">+</span>
<span class="gi">+        if include_body:</span>
<span class="gi">+            content = self.get_content(self.absolute_path, start, end)</span>
<span class="gi">+            if isinstance(content, bytes):</span>
<span class="gi">+                content = [content]</span>
<span class="gi">+            for chunk in content:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.write(chunk)</span>
<span class="gi">+                    await self.flush()</span>
<span class="gi">+                except iostream.StreamClosedError:</span>
<span class="gi">+                    return</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert self.request.method == &quot;HEAD&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def compute_etag(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the ``Etag`` header based on static url version.

<span class="w"> </span>        This allows efficient ``If-None-Match`` checks against cached
<span class="gu">@@ -1522,24 +2772,62 @@ class StaticFileHandler(RequestHandler):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.absolute_path is not None</span>
<span class="gi">+        version_hash = self._get_cached_version(self.absolute_path)</span>
<span class="gi">+        if not version_hash:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return &#39;&quot;%s&quot;&#39; % (version_hash,)</span>

<span class="gd">-    def set_headers(self) -&gt;None:</span>
<span class="gi">+    def set_headers(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the content and caching headers on the response.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_header(&quot;Accept-Ranges&quot;, &quot;bytes&quot;)</span>
<span class="gi">+        self.set_etag_header()</span>
<span class="gi">+</span>
<span class="gi">+        if self.modified is not None:</span>
<span class="gi">+            self.set_header(&quot;Last-Modified&quot;, self.modified)</span>
<span class="gi">+</span>
<span class="gi">+        content_type = self.get_content_type()</span>
<span class="gi">+        if content_type:</span>
<span class="gi">+            self.set_header(&quot;Content-Type&quot;, content_type)</span>
<span class="gi">+</span>
<span class="gi">+        cache_time = self.get_cache_time(self.path, self.modified, content_type)</span>
<span class="gi">+        if cache_time &gt; 0:</span>
<span class="gi">+            self.set_header(</span>
<span class="gi">+                &quot;Expires&quot;,</span>
<span class="gi">+                datetime.datetime.now(datetime.timezone.utc)</span>
<span class="gi">+                + datetime.timedelta(seconds=cache_time),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.set_header(&quot;Cache-Control&quot;, &quot;max-age=&quot; + str(cache_time))</span>
<span class="gi">+</span>
<span class="gi">+        self.set_extra_headers(self.path)</span>

<span class="gd">-    def should_return_304(self) -&gt;bool:</span>
<span class="gi">+    def should_return_304(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns True if the headers indicate that we should return 304.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If client sent If-None-Match, use it, ignore If-Modified-Since</span>
<span class="gi">+        if self.request.headers.get(&quot;If-None-Match&quot;):</span>
<span class="gi">+            return self.check_etag_header()</span>
<span class="gi">+</span>
<span class="gi">+        # Check the If-Modified-Since, and don&#39;t send the result if the</span>
<span class="gi">+        # content has not been modified</span>
<span class="gi">+        ims_value = self.request.headers.get(&quot;If-Modified-Since&quot;)</span>
<span class="gi">+        if ims_value is not None:</span>
<span class="gi">+            if_since = email.utils.parsedate_to_datetime(ims_value)</span>
<span class="gi">+            if if_since.tzinfo is None:</span>
<span class="gi">+                if_since = if_since.replace(tzinfo=datetime.timezone.utc)</span>
<span class="gi">+            assert self.modified is not None</span>
<span class="gi">+            if if_since &gt;= self.modified:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_absolute_path(cls, root: str, path: str) -&gt;str:</span>
<span class="gi">+    def get_absolute_path(cls, root: str, path: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the absolute location of ``path`` relative to ``root``.

<span class="w"> </span>        ``root`` is the path configured for this `StaticFileHandler`
<span class="gu">@@ -1552,10 +2840,10 @@ class StaticFileHandler(RequestHandler):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        abspath = os.path.abspath(os.path.join(root, path))</span>
<span class="gi">+        return abspath</span>

<span class="gd">-    def validate_absolute_path(self, root: str, absolute_path: str) -&gt;Optional[</span>
<span class="gd">-        str]:</span>
<span class="gi">+    def validate_absolute_path(self, root: str, absolute_path: str) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate and return the absolute path.

<span class="w"> </span>        ``root`` is the configured path for the `StaticFileHandler`,
<span class="gu">@@ -1575,11 +2863,49 @@ class StaticFileHandler(RequestHandler):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # os.path.abspath strips a trailing /.</span>
<span class="gi">+        # We must add it back to `root` so that we only match files</span>
<span class="gi">+        # in a directory named `root` instead of files starting with</span>
<span class="gi">+        # that prefix.</span>
<span class="gi">+        root = os.path.abspath(root)</span>
<span class="gi">+        if not root.endswith(os.path.sep):</span>
<span class="gi">+            # abspath always removes a trailing slash, except when</span>
<span class="gi">+            # root is &#39;/&#39;. This is an unusual case, but several projects</span>
<span class="gi">+            # have independently discovered this technique to disable</span>
<span class="gi">+            # Tornado&#39;s path validation and (hopefully) do their own,</span>
<span class="gi">+            # so we need to support it.</span>
<span class="gi">+            root += os.path.sep</span>
<span class="gi">+        # The trailing slash also needs to be temporarily added back</span>
<span class="gi">+        # the requested path so a request to root/ will match.</span>
<span class="gi">+        if not (absolute_path + os.path.sep).startswith(root):</span>
<span class="gi">+            raise HTTPError(403, &quot;%s is not in root static directory&quot;, self.path)</span>
<span class="gi">+        if os.path.isdir(absolute_path) and self.default_filename is not None:</span>
<span class="gi">+            # need to look at the request.path here for when path is empty</span>
<span class="gi">+            # but there is some prefix to the path that was already</span>
<span class="gi">+            # trimmed by the routing</span>
<span class="gi">+            if not self.request.path.endswith(&quot;/&quot;):</span>
<span class="gi">+                if self.request.path.startswith(&quot;//&quot;):</span>
<span class="gi">+                    # A redirect with two initial slashes is a &quot;protocol-relative&quot; URL.</span>
<span class="gi">+                    # This means the next path segment is treated as a hostname instead</span>
<span class="gi">+                    # of a part of the path, making this effectively an open redirect.</span>
<span class="gi">+                    # Reject paths starting with two slashes to prevent this.</span>
<span class="gi">+                    # This is only reachable under certain configurations.</span>
<span class="gi">+                    raise HTTPError(</span>
<span class="gi">+                        403, &quot;cannot redirect path with two initial slashes&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                self.redirect(self.request.path + &quot;/&quot;, permanent=True)</span>
<span class="gi">+                return None</span>
<span class="gi">+            absolute_path = os.path.join(absolute_path, self.default_filename)</span>
<span class="gi">+        if not os.path.exists(absolute_path):</span>
<span class="gi">+            raise HTTPError(404)</span>
<span class="gi">+        if not os.path.isfile(absolute_path):</span>
<span class="gi">+            raise HTTPError(403, &quot;%s is not a file&quot;, self.path)</span>
<span class="gi">+        return absolute_path</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_content(cls, abspath: str, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None) -&gt;Generator[bytes, None, None]:</span>
<span class="gi">+    def get_content(</span>
<span class="gi">+        cls, abspath: str, start: Optional[int] = None, end: Optional[int] = None</span>
<span class="gi">+    ) -&gt; Generator[bytes, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the content of the requested resource which is located
<span class="w"> </span>        at the given absolute path.

<span class="gu">@@ -1594,10 +2920,29 @@ class StaticFileHandler(RequestHandler):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(abspath, &quot;rb&quot;) as file:</span>
<span class="gi">+            if start is not None:</span>
<span class="gi">+                file.seek(start)</span>
<span class="gi">+            if end is not None:</span>
<span class="gi">+                remaining = end - (start or 0)  # type: Optional[int]</span>
<span class="gi">+            else:</span>
<span class="gi">+                remaining = None</span>
<span class="gi">+            while True:</span>
<span class="gi">+                chunk_size = 64 * 1024</span>
<span class="gi">+                if remaining is not None and remaining &lt; chunk_size:</span>
<span class="gi">+                    chunk_size = remaining</span>
<span class="gi">+                chunk = file.read(chunk_size)</span>
<span class="gi">+                if chunk:</span>
<span class="gi">+                    if remaining is not None:</span>
<span class="gi">+                        remaining -= len(chunk)</span>
<span class="gi">+                    yield chunk</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if remaining is not None:</span>
<span class="gi">+                        assert remaining == 0</span>
<span class="gi">+                    return</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_content_version(cls, abspath: str) -&gt;str:</span>
<span class="gi">+    def get_content_version(cls, abspath: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a version string for the resource at the given path.

<span class="w"> </span>        This class method may be overridden by subclasses.  The
<span class="gu">@@ -1605,9 +2950,22 @@ class StaticFileHandler(RequestHandler):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = cls.get_content(abspath)</span>
<span class="gi">+        hasher = hashlib.sha512()</span>
<span class="gi">+        if isinstance(data, bytes):</span>
<span class="gi">+            hasher.update(data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for chunk in data:</span>
<span class="gi">+                hasher.update(chunk)</span>
<span class="gi">+        return hasher.hexdigest()</span>

<span class="gd">-    def get_content_size(self) -&gt;int:</span>
<span class="gi">+    def _stat(self) -&gt; os.stat_result:</span>
<span class="gi">+        assert self.absolute_path is not None</span>
<span class="gi">+        if not hasattr(self, &quot;_stat_result&quot;):</span>
<span class="gi">+            self._stat_result = os.stat(self.absolute_path)</span>
<span class="gi">+        return self._stat_result</span>
<span class="gi">+</span>
<span class="gi">+    def get_content_size(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the total size of the resource at the given path.

<span class="w"> </span>        This method may be overridden by subclasses.
<span class="gu">@@ -1618,9 +2976,10 @@ class StaticFileHandler(RequestHandler):</span>
<span class="w"> </span>           This method is now always called, instead of only when
<span class="w"> </span>           partial results are requested.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stat_result = self._stat()</span>
<span class="gi">+        return stat_result.st_size</span>

<span class="gd">-    def get_modified_time(self) -&gt;Optional[datetime.datetime]:</span>
<span class="gi">+    def get_modified_time(self) -&gt; Optional[datetime.datetime]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the time that ``self.absolute_path`` was last modified.

<span class="w"> </span>        May be overridden in subclasses.  Should return a `~datetime.datetime`
<span class="gu">@@ -1632,21 +2991,48 @@ class StaticFileHandler(RequestHandler):</span>
<span class="w"> </span>           Now returns an aware datetime object instead of a naive one.
<span class="w"> </span>           Subclasses that override this method may return either kind.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_content_type(self) -&gt;str:</span>
<span class="gi">+        stat_result = self._stat()</span>
<span class="gi">+        # NOTE: Historically, this used stat_result[stat.ST_MTIME],</span>
<span class="gi">+        # which truncates the fractional portion of the timestamp. It</span>
<span class="gi">+        # was changed from that form to stat_result.st_mtime to</span>
<span class="gi">+        # satisfy mypy (which disallows the bracket operator), but the</span>
<span class="gi">+        # latter form returns a float instead of an int. For</span>
<span class="gi">+        # consistency with the past (and because we have a unit test</span>
<span class="gi">+        # that relies on this), we truncate the float here, although</span>
<span class="gi">+        # I&#39;m not sure that&#39;s the right thing to do.</span>
<span class="gi">+        modified = datetime.datetime.fromtimestamp(</span>
<span class="gi">+            int(stat_result.st_mtime), datetime.timezone.utc</span>
<span class="gi">+        )</span>
<span class="gi">+        return modified</span>
<span class="gi">+</span>
<span class="gi">+    def get_content_type(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the ``Content-Type`` header to be used for this request.

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.absolute_path is not None</span>
<span class="gi">+        mime_type, encoding = mimetypes.guess_type(self.absolute_path)</span>
<span class="gi">+        # per RFC 6713, use the appropriate type for a gzip compressed file</span>
<span class="gi">+        if encoding == &quot;gzip&quot;:</span>
<span class="gi">+            return &quot;application/gzip&quot;</span>
<span class="gi">+        # As of 2015-07-21 there is no bzip2 encoding defined at</span>
<span class="gi">+        # http://www.iana.org/assignments/media-types/media-types.xhtml</span>
<span class="gi">+        # So for that (and any other encoding), use octet-stream.</span>
<span class="gi">+        elif encoding is not None:</span>
<span class="gi">+            return &quot;application/octet-stream&quot;</span>
<span class="gi">+        elif mime_type is not None:</span>
<span class="gi">+            return mime_type</span>
<span class="gi">+        # if mime_type not detected, use application/octet-stream</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;application/octet-stream&quot;</span>

<span class="gd">-    def set_extra_headers(self, path: str) -&gt;None:</span>
<span class="gi">+    def set_extra_headers(self, path: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;For subclass to add extra headers to the response&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def get_cache_time(self, path: str, modified: Optional[datetime.</span>
<span class="gd">-        datetime], mime_type: str) -&gt;int:</span>
<span class="gi">+    def get_cache_time(</span>
<span class="gi">+        self, path: str, modified: Optional[datetime.datetime], mime_type: str</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to customize cache control behavior.

<span class="w"> </span>        Return a positive number of seconds to make the result
<span class="gu">@@ -1657,11 +3043,12 @@ class StaticFileHandler(RequestHandler):</span>
<span class="w"> </span>        By default returns cache expiry of 10 years for resources requested
<span class="w"> </span>        with ``v`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.CACHE_MAX_AGE if &quot;v&quot; in self.request.arguments else 0</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def make_static_url(cls, settings: Dict[str, Any], path: str,</span>
<span class="gd">-        include_version: bool=True) -&gt;str:</span>
<span class="gi">+    def make_static_url(</span>
<span class="gi">+        cls, settings: Dict[str, Any], path: str, include_version: bool = True</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constructs a versioned url for the given path.

<span class="w"> </span>        This method may be overridden in subclasses (but note that it
<span class="gu">@@ -1680,9 +3067,17 @@ class StaticFileHandler(RequestHandler):</span>
<span class="w"> </span>        file corresponding to the given ``path``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = settings.get(&quot;static_url_prefix&quot;, &quot;/static/&quot;) + path</span>
<span class="gi">+        if not include_version:</span>
<span class="gi">+            return url</span>
<span class="gi">+</span>
<span class="gi">+        version_hash = cls.get_version(settings, path)</span>
<span class="gi">+        if not version_hash:</span>
<span class="gi">+            return url</span>

<span class="gd">-    def parse_url_path(self, url_path: str) -&gt;str:</span>
<span class="gi">+        return &quot;%s?v=%s&quot; % (url, version_hash)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_url_path(self, url_path: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a static URL path into a filesystem path.

<span class="w"> </span>        ``url_path`` is the path component of the URL with
<span class="gu">@@ -1691,10 +3086,12 @@ class StaticFileHandler(RequestHandler):</span>

<span class="w"> </span>        This is the inverse of `make_static_url`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if os.path.sep != &quot;/&quot;:</span>
<span class="gi">+            url_path = url_path.replace(&quot;/&quot;, os.path.sep)</span>
<span class="gi">+        return url_path</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_version(cls, settings: Dict[str, Any], path: str) -&gt;Optional[str]:</span>
<span class="gi">+    def get_version(cls, settings: Dict[str, Any], path: str) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate the version string to be used in static URLs.

<span class="w"> </span>        ``settings`` is the `Application.settings` dictionary and ``path``
<span class="gu">@@ -1707,7 +3104,23 @@ class StaticFileHandler(RequestHandler):</span>
<span class="w"> </span>           `get_content_version` is now preferred as it allows the base
<span class="w"> </span>           class to handle caching of the result.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        abs_path = cls.get_absolute_path(settings[&quot;static_path&quot;], path)</span>
<span class="gi">+        return cls._get_cached_version(abs_path)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _get_cached_version(cls, abs_path: str) -&gt; Optional[str]:</span>
<span class="gi">+        with cls._lock:</span>
<span class="gi">+            hashes = cls._static_hashes</span>
<span class="gi">+            if abs_path not in hashes:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    hashes[abs_path] = cls.get_content_version(abs_path)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    gen_log.error(&quot;Could not open static file %r&quot;, abs_path)</span>
<span class="gi">+                    hashes[abs_path] = None</span>
<span class="gi">+            hsh = hashes.get(abs_path)</span>
<span class="gi">+            if hsh:</span>
<span class="gi">+                return hsh</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class FallbackHandler(RequestHandler):
<span class="gu">@@ -1727,6 +3140,16 @@ class FallbackHandler(RequestHandler):</span>
<span class="w"> </span>        ])
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def initialize(</span>
<span class="gi">+        self, fallback: Callable[[httputil.HTTPServerRequest], None]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.fallback = fallback</span>
<span class="gi">+</span>
<span class="gi">+    def prepare(self) -&gt; None:</span>
<span class="gi">+        self.fallback(self.request)</span>
<span class="gi">+        self._finished = True</span>
<span class="gi">+        self.on_finish()</span>
<span class="gi">+</span>

<span class="w"> </span>class OutputTransform(object):
<span class="w"> </span>    &quot;&quot;&quot;A transform modifies the result of an HTTP request (e.g., GZip encoding)
<span class="gu">@@ -1736,9 +3159,21 @@ class OutputTransform(object):</span>
<span class="w"> </span>    (if any) to apply.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, request: httputil.HTTPServerRequest) -&gt;None:</span>
<span class="gi">+    def __init__(self, request: httputil.HTTPServerRequest) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gi">+    def transform_first_chunk(</span>
<span class="gi">+        self,</span>
<span class="gi">+        status_code: int,</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+        chunk: bytes,</span>
<span class="gi">+        finishing: bool,</span>
<span class="gi">+    ) -&gt; Tuple[int, httputil.HTTPHeaders, bytes]:</span>
<span class="gi">+        return status_code, headers, chunk</span>
<span class="gi">+</span>
<span class="gi">+    def transform_chunk(self, chunk: bytes, finishing: bool) -&gt; bytes:</span>
<span class="gi">+        return chunk</span>
<span class="gi">+</span>

<span class="w"> </span>class GZipContentEncoding(OutputTransform):
<span class="w"> </span>    &quot;&quot;&quot;Applies the gzip content encoding to the response.
<span class="gu">@@ -1750,19 +3185,90 @@ class GZipContentEncoding(OutputTransform):</span>
<span class="w"> </span>        of just a whitelist. (the whitelist is still used for certain
<span class="w"> </span>        non-text mime types).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    CONTENT_TYPES = set([&#39;application/javascript&#39;,</span>
<span class="gd">-        &#39;application/x-javascript&#39;, &#39;application/xml&#39;,</span>
<span class="gd">-        &#39;application/atom+xml&#39;, &#39;application/json&#39;, &#39;application/xhtml+xml&#39;,</span>
<span class="gd">-        &#39;image/svg+xml&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    # Whitelist of compressible mime types (in addition to any types</span>
<span class="gi">+    # beginning with &quot;text/&quot;).</span>
<span class="gi">+    CONTENT_TYPES = set(</span>
<span class="gi">+        [</span>
<span class="gi">+            &quot;application/javascript&quot;,</span>
<span class="gi">+            &quot;application/x-javascript&quot;,</span>
<span class="gi">+            &quot;application/xml&quot;,</span>
<span class="gi">+            &quot;application/atom+xml&quot;,</span>
<span class="gi">+            &quot;application/json&quot;,</span>
<span class="gi">+            &quot;application/xhtml+xml&quot;,</span>
<span class="gi">+            &quot;image/svg+xml&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+    # Python&#39;s GzipFile defaults to level 9, while most other gzip</span>
<span class="gi">+    # tools (including gzip itself) default to 6, which is probably a</span>
<span class="gi">+    # better CPU/size tradeoff.</span>
<span class="w"> </span>    GZIP_LEVEL = 6
<span class="gi">+    # Responses that are too short are unlikely to benefit from gzipping</span>
<span class="gi">+    # after considering the &quot;Content-Encoding: gzip&quot; header and the header</span>
<span class="gi">+    # inside the gzip encoding.</span>
<span class="gi">+    # Note that responses written in multiple chunks will be compressed</span>
<span class="gi">+    # regardless of size.</span>
<span class="w"> </span>    MIN_LENGTH = 1024

<span class="gd">-    def __init__(self, request: httputil.HTTPServerRequest) -&gt;None:</span>
<span class="gd">-        self._gzipping = &#39;gzip&#39; in request.headers.get(&#39;Accept-Encoding&#39;, &#39;&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def authenticated(method: Callable[..., Optional[Awaitable[None]]]) -&gt;Callable[</span>
<span class="gd">-    ..., Optional[Awaitable[None]]]:</span>
<span class="gi">+    def __init__(self, request: httputil.HTTPServerRequest) -&gt; None:</span>
<span class="gi">+        self._gzipping = &quot;gzip&quot; in request.headers.get(&quot;Accept-Encoding&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _compressible_type(self, ctype: str) -&gt; bool:</span>
<span class="gi">+        return ctype.startswith(&quot;text/&quot;) or ctype in self.CONTENT_TYPES</span>
<span class="gi">+</span>
<span class="gi">+    def transform_first_chunk(</span>
<span class="gi">+        self,</span>
<span class="gi">+        status_code: int,</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+        chunk: bytes,</span>
<span class="gi">+        finishing: bool,</span>
<span class="gi">+    ) -&gt; Tuple[int, httputil.HTTPHeaders, bytes]:</span>
<span class="gi">+        # TODO: can/should this type be inherited from the superclass?</span>
<span class="gi">+        if &quot;Vary&quot; in headers:</span>
<span class="gi">+            headers[&quot;Vary&quot;] += &quot;, Accept-Encoding&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            headers[&quot;Vary&quot;] = &quot;Accept-Encoding&quot;</span>
<span class="gi">+        if self._gzipping:</span>
<span class="gi">+            ctype = _unicode(headers.get(&quot;Content-Type&quot;, &quot;&quot;)).split(&quot;;&quot;)[0]</span>
<span class="gi">+            self._gzipping = (</span>
<span class="gi">+                self._compressible_type(ctype)</span>
<span class="gi">+                and (not finishing or len(chunk) &gt;= self.MIN_LENGTH)</span>
<span class="gi">+                and (&quot;Content-Encoding&quot; not in headers)</span>
<span class="gi">+            )</span>
<span class="gi">+        if self._gzipping:</span>
<span class="gi">+            headers[&quot;Content-Encoding&quot;] = &quot;gzip&quot;</span>
<span class="gi">+            self._gzip_value = BytesIO()</span>
<span class="gi">+            self._gzip_file = gzip.GzipFile(</span>
<span class="gi">+                mode=&quot;w&quot;, fileobj=self._gzip_value, compresslevel=self.GZIP_LEVEL</span>
<span class="gi">+            )</span>
<span class="gi">+            chunk = self.transform_chunk(chunk, finishing)</span>
<span class="gi">+            if &quot;Content-Length&quot; in headers:</span>
<span class="gi">+                # The original content length is no longer correct.</span>
<span class="gi">+                # If this is the last (and only) chunk, we can set the new</span>
<span class="gi">+                # content-length; otherwise we remove it and fall back to</span>
<span class="gi">+                # chunked encoding.</span>
<span class="gi">+                if finishing:</span>
<span class="gi">+                    headers[&quot;Content-Length&quot;] = str(len(chunk))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    del headers[&quot;Content-Length&quot;]</span>
<span class="gi">+        return status_code, headers, chunk</span>
<span class="gi">+</span>
<span class="gi">+    def transform_chunk(self, chunk: bytes, finishing: bool) -&gt; bytes:</span>
<span class="gi">+        if self._gzipping:</span>
<span class="gi">+            self._gzip_file.write(chunk)</span>
<span class="gi">+            if finishing:</span>
<span class="gi">+                self._gzip_file.close()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._gzip_file.flush()</span>
<span class="gi">+            chunk = self._gzip_value.getvalue()</span>
<span class="gi">+            self._gzip_value.truncate(0)</span>
<span class="gi">+            self._gzip_value.seek(0)</span>
<span class="gi">+        return chunk</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def authenticated(</span>
<span class="gi">+    method: Callable[..., Optional[Awaitable[None]]]</span>
<span class="gi">+) -&gt; Callable[..., Optional[Awaitable[None]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorate methods with this to require that the user be logged in.

<span class="w"> </span>    If the user is not logged in, they will be redirected to the configured
<span class="gu">@@ -1773,7 +3279,28 @@ def authenticated(method: Callable[..., Optional[Awaitable[None]]]) -&gt;Callable[</span>
<span class="w"> </span>    will add a `next` parameter so the login page knows where to send
<span class="w"> </span>    you once you&#39;re logged in.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @functools.wraps(method)</span>
<span class="gi">+    def wrapper(  # type: ignore</span>
<span class="gi">+        self: RequestHandler, *args, **kwargs</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if not self.current_user:</span>
<span class="gi">+            if self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;):</span>
<span class="gi">+                url = self.get_login_url()</span>
<span class="gi">+                if &quot;?&quot; not in url:</span>
<span class="gi">+                    if urllib.parse.urlsplit(url).scheme:</span>
<span class="gi">+                        # if login url is absolute, make next absolute too</span>
<span class="gi">+                        next_url = self.request.full_url()</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        assert self.request.uri is not None</span>
<span class="gi">+                        next_url = self.request.uri</span>
<span class="gi">+                    url += &quot;?&quot; + urlencode(dict(next=next_url))</span>
<span class="gi">+                self.redirect(url)</span>
<span class="gi">+                return None</span>
<span class="gi">+            raise HTTPError(403)</span>
<span class="gi">+        return method(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class UIModule(object):
<span class="gu">@@ -1786,65 +3313,71 @@ class UIModule(object):</span>
<span class="w"> </span>    Subclasses of UIModule must override the `render` method.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, handler: RequestHandler) -&gt;None:</span>
<span class="gi">+    def __init__(self, handler: RequestHandler) -&gt; None:</span>
<span class="w"> </span>        self.handler = handler
<span class="w"> </span>        self.request = handler.request
<span class="w"> </span>        self.ui = handler.ui
<span class="w"> </span>        self.locale = handler.locale

<span class="gd">-    def render(self, *args: Any, **kwargs: Any) -&gt;str:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def current_user(self) -&gt; Any:</span>
<span class="gi">+        return self.handler.current_user</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, *args: Any, **kwargs: Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override in subclasses to return this module&#39;s output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def embedded_javascript(self) -&gt;Optional[str]:</span>
<span class="gi">+    def embedded_javascript(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to return a JavaScript string
<span class="w"> </span>        to be embedded in the page.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def javascript_files(self) -&gt;Optional[Iterable[str]]:</span>
<span class="gi">+    def javascript_files(self) -&gt; Optional[Iterable[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to return a list of JavaScript files needed by this module.

<span class="w"> </span>        If the return values are relative paths, they will be passed to
<span class="w"> </span>        `RequestHandler.static_url`; otherwise they will be used as-is.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def embedded_css(self) -&gt;Optional[str]:</span>
<span class="gi">+    def embedded_css(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to return a CSS string
<span class="w"> </span>        that will be embedded in the page.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def css_files(self) -&gt;Optional[Iterable[str]]:</span>
<span class="gi">+    def css_files(self) -&gt; Optional[Iterable[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to returns a list of CSS files required by this module.

<span class="w"> </span>        If the return values are relative paths, they will be passed to
<span class="w"> </span>        `RequestHandler.static_url`; otherwise they will be used as-is.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def html_head(self) -&gt;Optional[str]:</span>
<span class="gi">+    def html_head(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to return an HTML string that will be put in the &lt;head/&gt;
<span class="w"> </span>        element.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def html_body(self) -&gt;Optional[str]:</span>
<span class="gi">+    def html_body(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to return an HTML string that will be put at the end of
<span class="w"> </span>        the &lt;body/&gt; element.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def render_string(self, path: str, **kwargs: Any) -&gt;bytes:</span>
<span class="gi">+    def render_string(self, path: str, **kwargs: Any) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Renders a template and returns it as a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.handler.render_string(path, **kwargs)</span>


<span class="w"> </span>class _linkify(UIModule):
<span class="gd">-    pass</span>
<span class="gi">+    def render(self, text: str, **kwargs: Any) -&gt; str:  # type: ignore</span>
<span class="gi">+        return escape.linkify(text, **kwargs)</span>


<span class="w"> </span>class _xsrf_form_html(UIModule):
<span class="gd">-    pass</span>
<span class="gi">+    def render(self) -&gt; str:  # type: ignore</span>
<span class="gi">+        return self.handler.xsrf_form_html()</span>


<span class="w"> </span>class TemplateModule(UIModule):
<span class="gu">@@ -1863,28 +3396,321 @@ class TemplateModule(UIModule):</span>
<span class="w"> </span>    any arguments to the template.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, handler: RequestHandler) -&gt;None:</span>
<span class="gi">+    def __init__(self, handler: RequestHandler) -&gt; None:</span>
<span class="w"> </span>        super().__init__(handler)
<span class="gd">-        self._resource_list = []</span>
<span class="gd">-        self._resource_dict = {}</span>
<span class="gi">+        # keep resources in both a list and a dict to preserve order</span>
<span class="gi">+        self._resource_list = []  # type: List[Dict[str, Any]]</span>
<span class="gi">+        self._resource_dict = {}  # type: Dict[str, Dict[str, Any]]</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, path: str, **kwargs: Any) -&gt; bytes:  # type: ignore</span>
<span class="gi">+        def set_resources(**kwargs) -&gt; str:  # type: ignore</span>
<span class="gi">+            if path not in self._resource_dict:</span>
<span class="gi">+                self._resource_list.append(kwargs)</span>
<span class="gi">+                self._resource_dict[path] = kwargs</span>
<span class="gi">+            else:</span>
<span class="gi">+                if self._resource_dict[path] != kwargs:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;set_resources called with different &quot;</span>
<span class="gi">+                        &quot;resources for the same template&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return self.render_string(path, set_resources=set_resources, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_resources(self, key: str) -&gt; Iterable[str]:</span>
<span class="gi">+        return (r[key] for r in self._resource_list if key in r)</span>
<span class="gi">+</span>
<span class="gi">+    def embedded_javascript(self) -&gt; str:</span>
<span class="gi">+        return &quot;\n&quot;.join(self._get_resources(&quot;embedded_javascript&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def javascript_files(self) -&gt; Iterable[str]:</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for f in self._get_resources(&quot;javascript_files&quot;):</span>
<span class="gi">+            if isinstance(f, (unicode_type, bytes)):</span>
<span class="gi">+                result.append(f)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.extend(f)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def embedded_css(self) -&gt; str:</span>
<span class="gi">+        return &quot;\n&quot;.join(self._get_resources(&quot;embedded_css&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def css_files(self) -&gt; Iterable[str]:</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for f in self._get_resources(&quot;css_files&quot;):</span>
<span class="gi">+            if isinstance(f, (unicode_type, bytes)):</span>
<span class="gi">+                result.append(f)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.extend(f)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def html_head(self) -&gt; str:</span>
<span class="gi">+        return &quot;&quot;.join(self._get_resources(&quot;html_head&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def html_body(self) -&gt; str:</span>
<span class="gi">+        return &quot;&quot;.join(self._get_resources(&quot;html_body&quot;))</span>


<span class="w"> </span>class _UIModuleNamespace(object):
<span class="w"> </span>    &quot;&quot;&quot;Lazy namespace which creates UIModule proxies bound to a handler.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, handler: RequestHandler, ui_modules: Dict[str, Type[</span>
<span class="gd">-        UIModule]]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, handler: RequestHandler, ui_modules: Dict[str, Type[UIModule]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.handler = handler
<span class="w"> </span>        self.ui_modules = ui_modules

<span class="gd">-    def __getitem__(self, key: str) -&gt;Callable[..., str]:</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; Callable[..., str]:</span>
<span class="w"> </span>        return self.handler._ui_module(key, self.ui_modules[key])

<span class="gd">-    def __getattr__(self, key: str) -&gt;Callable[..., str]:</span>
<span class="gi">+    def __getattr__(self, key: str) -&gt; Callable[..., str]:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return self[key]
<span class="w"> </span>        except KeyError as e:
<span class="w"> </span>            raise AttributeError(str(e))


<span class="gd">-_signed_value_version_re = re.compile(b&#39;^([1-9][0-9]*)\\|(.*)$&#39;)</span>
<span class="gi">+def create_signed_value(</span>
<span class="gi">+    secret: _CookieSecretTypes,</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    value: Union[str, bytes],</span>
<span class="gi">+    version: Optional[int] = None,</span>
<span class="gi">+    clock: Optional[Callable[[], float]] = None,</span>
<span class="gi">+    key_version: Optional[int] = None,</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="gi">+    if version is None:</span>
<span class="gi">+        version = DEFAULT_SIGNED_VALUE_VERSION</span>
<span class="gi">+    if clock is None:</span>
<span class="gi">+        clock = time.time</span>
<span class="gi">+</span>
<span class="gi">+    timestamp = utf8(str(int(clock())))</span>
<span class="gi">+    value = base64.b64encode(utf8(value))</span>
<span class="gi">+    if version == 1:</span>
<span class="gi">+        assert not isinstance(secret, dict)</span>
<span class="gi">+        signature = _create_signature_v1(secret, name, value, timestamp)</span>
<span class="gi">+        value = b&quot;|&quot;.join([value, timestamp, signature])</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif version == 2:</span>
<span class="gi">+        # The v2 format consists of a version number and a series of</span>
<span class="gi">+        # length-prefixed fields &quot;%d:%s&quot;, the last of which is a</span>
<span class="gi">+        # signature, all separated by pipes.  All numbers are in</span>
<span class="gi">+        # decimal format with no leading zeros.  The signature is an</span>
<span class="gi">+        # HMAC-SHA256 of the whole string up to that point, including</span>
<span class="gi">+        # the final pipe.</span>
<span class="gi">+        #</span>
<span class="gi">+        # The fields are:</span>
<span class="gi">+        # - format version (i.e. 2; no length prefix)</span>
<span class="gi">+        # - key version (integer, default is 0)</span>
<span class="gi">+        # - timestamp (integer seconds since epoch)</span>
<span class="gi">+        # - name (not encoded; assumed to be ~alphanumeric)</span>
<span class="gi">+        # - value (base64-encoded)</span>
<span class="gi">+        # - signature (hex-encoded; no length prefix)</span>
<span class="gi">+        def format_field(s: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+            return utf8(&quot;%d:&quot; % len(s)) + utf8(s)</span>
<span class="gi">+</span>
<span class="gi">+        to_sign = b&quot;|&quot;.join(</span>
<span class="gi">+            [</span>
<span class="gi">+                b&quot;2&quot;,</span>
<span class="gi">+                format_field(str(key_version or 0)),</span>
<span class="gi">+                format_field(timestamp),</span>
<span class="gi">+                format_field(name),</span>
<span class="gi">+                format_field(value),</span>
<span class="gi">+                b&quot;&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(secret, dict):</span>
<span class="gi">+            assert (</span>
<span class="gi">+                key_version is not None</span>
<span class="gi">+            ), &quot;Key version must be set when sign key dict is used&quot;</span>
<span class="gi">+            assert version &gt;= 2, &quot;Version must be at least 2 for key version support&quot;</span>
<span class="gi">+            secret = secret[key_version]</span>
<span class="gi">+</span>
<span class="gi">+        signature = _create_signature_v2(secret, to_sign)</span>
<span class="gi">+        return to_sign + signature</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Unsupported version %d&quot; % version)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# A leading version number in decimal</span>
<span class="gi">+# with no leading zeros, followed by a pipe.</span>
<span class="gi">+_signed_value_version_re = re.compile(rb&quot;^([1-9][0-9]*)\|(.*)$&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_version(value: bytes) -&gt; int:</span>
<span class="gi">+    # Figures out what version value is.  Version 1 did not include an</span>
<span class="gi">+    # explicit version field and started with arbitrary base64 data,</span>
<span class="gi">+    # which makes this tricky.</span>
<span class="gi">+    m = _signed_value_version_re.match(value)</span>
<span class="gi">+    if m is None:</span>
<span class="gi">+        version = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            version = int(m.group(1))</span>
<span class="gi">+            if version &gt; 999:</span>
<span class="gi">+                # Certain payloads from the version-less v1 format may</span>
<span class="gi">+                # be parsed as valid integers.  Due to base64 padding</span>
<span class="gi">+                # restrictions, this can only happen for numbers whose</span>
<span class="gi">+                # length is a multiple of 4, so we can treat all</span>
<span class="gi">+                # numbers up to 999 as versions, and for the rest we</span>
<span class="gi">+                # fall back to v1 format.</span>
<span class="gi">+                version = 1</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            version = 1</span>
<span class="gi">+    return version</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decode_signed_value(</span>
<span class="gi">+    secret: _CookieSecretTypes,</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    value: Union[None, str, bytes],</span>
<span class="gi">+    max_age_days: float = 31,</span>
<span class="gi">+    clock: Optional[Callable[[], float]] = None,</span>
<span class="gi">+    min_version: Optional[int] = None,</span>
<span class="gi">+) -&gt; Optional[bytes]:</span>
<span class="gi">+    if clock is None:</span>
<span class="gi">+        clock = time.time</span>
<span class="gi">+    if min_version is None:</span>
<span class="gi">+        min_version = DEFAULT_SIGNED_VALUE_MIN_VERSION</span>
<span class="gi">+    if min_version &gt; 2:</span>
<span class="gi">+        raise ValueError(&quot;Unsupported min_version %d&quot; % min_version)</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    value = utf8(value)</span>
<span class="gi">+    version = _get_version(value)</span>
<span class="gi">+</span>
<span class="gi">+    if version &lt; min_version:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if version == 1:</span>
<span class="gi">+        assert not isinstance(secret, dict)</span>
<span class="gi">+        return _decode_signed_value_v1(secret, name, value, max_age_days, clock)</span>
<span class="gi">+    elif version == 2:</span>
<span class="gi">+        return _decode_signed_value_v2(secret, name, value, max_age_days, clock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _decode_signed_value_v1(</span>
<span class="gi">+    secret: Union[str, bytes],</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    value: bytes,</span>
<span class="gi">+    max_age_days: float,</span>
<span class="gi">+    clock: Callable[[], float],</span>
<span class="gi">+) -&gt; Optional[bytes]:</span>
<span class="gi">+    parts = utf8(value).split(b&quot;|&quot;)</span>
<span class="gi">+    if len(parts) != 3:</span>
<span class="gi">+        return None</span>
<span class="gi">+    signature = _create_signature_v1(secret, name, parts[0], parts[1])</span>
<span class="gi">+    if not hmac.compare_digest(parts[2], signature):</span>
<span class="gi">+        gen_log.warning(&quot;Invalid cookie signature %r&quot;, value)</span>
<span class="gi">+        return None</span>
<span class="gi">+    timestamp = int(parts[1])</span>
<span class="gi">+    if timestamp &lt; clock() - max_age_days * 86400:</span>
<span class="gi">+        gen_log.warning(&quot;Expired cookie %r&quot;, value)</span>
<span class="gi">+        return None</span>
<span class="gi">+    if timestamp &gt; clock() + 31 * 86400:</span>
<span class="gi">+        # _cookie_signature does not hash a delimiter between the</span>
<span class="gi">+        # parts of the cookie, so an attacker could transfer trailing</span>
<span class="gi">+        # digits from the payload to the timestamp without altering the</span>
<span class="gi">+        # signature.  For backwards compatibility, sanity-check timestamp</span>
<span class="gi">+        # here instead of modifying _cookie_signature.</span>
<span class="gi">+        gen_log.warning(&quot;Cookie timestamp in future; possible tampering %r&quot;, value)</span>
<span class="gi">+        return None</span>
<span class="gi">+    if parts[1].startswith(b&quot;0&quot;):</span>
<span class="gi">+        gen_log.warning(&quot;Tampered cookie %r&quot;, value)</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        return base64.b64decode(parts[0])</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _decode_fields_v2(value: bytes) -&gt; Tuple[int, bytes, bytes, bytes, bytes]:</span>
<span class="gi">+    def _consume_field(s: bytes) -&gt; Tuple[bytes, bytes]:</span>
<span class="gi">+        length, _, rest = s.partition(b&quot;:&quot;)</span>
<span class="gi">+        n = int(length)</span>
<span class="gi">+        field_value = rest[:n]</span>
<span class="gi">+        # In python 3, indexing bytes returns small integers; we must</span>
<span class="gi">+        # use a slice to get a byte string as in python 2.</span>
<span class="gi">+        if rest[n : n + 1] != b&quot;|&quot;:</span>
<span class="gi">+            raise ValueError(&quot;malformed v2 signed value field&quot;)</span>
<span class="gi">+        rest = rest[n + 1 :]</span>
<span class="gi">+        return field_value, rest</span>
<span class="gi">+</span>
<span class="gi">+    rest = value[2:]  # remove version number</span>
<span class="gi">+    key_version, rest = _consume_field(rest)</span>
<span class="gi">+    timestamp, rest = _consume_field(rest)</span>
<span class="gi">+    name_field, rest = _consume_field(rest)</span>
<span class="gi">+    value_field, passed_sig = _consume_field(rest)</span>
<span class="gi">+    return int(key_version), timestamp, name_field, value_field, passed_sig</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _decode_signed_value_v2(</span>
<span class="gi">+    secret: _CookieSecretTypes,</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    value: bytes,</span>
<span class="gi">+    max_age_days: float,</span>
<span class="gi">+    clock: Callable[[], float],</span>
<span class="gi">+) -&gt; Optional[bytes]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        (</span>
<span class="gi">+            key_version,</span>
<span class="gi">+            timestamp_bytes,</span>
<span class="gi">+            name_field,</span>
<span class="gi">+            value_field,</span>
<span class="gi">+            passed_sig,</span>
<span class="gi">+        ) = _decode_fields_v2(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    signed_string = value[: -len(passed_sig)]</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(secret, dict):</span>
<span class="gi">+        try:</span>
<span class="gi">+            secret = secret[key_version]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    expected_sig = _create_signature_v2(secret, signed_string)</span>
<span class="gi">+    if not hmac.compare_digest(passed_sig, expected_sig):</span>
<span class="gi">+        return None</span>
<span class="gi">+    if name_field != utf8(name):</span>
<span class="gi">+        return None</span>
<span class="gi">+    timestamp = int(timestamp_bytes)</span>
<span class="gi">+    if timestamp &lt; clock() - max_age_days * 86400:</span>
<span class="gi">+        # The signature has expired.</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        return base64.b64decode(value_field)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_signature_key_version(value: Union[str, bytes]) -&gt; Optional[int]:</span>
<span class="gi">+    value = utf8(value)</span>
<span class="gi">+    version = _get_version(value)</span>
<span class="gi">+    if version &lt; 2:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        key_version, _, _, _, _ = _decode_fields_v2(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return key_version</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_signature_v1(secret: Union[str, bytes], *parts: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+    hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)</span>
<span class="gi">+    for part in parts:</span>
<span class="gi">+        hash.update(utf8(part))</span>
<span class="gi">+    return utf8(hash.hexdigest())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_signature_v2(secret: Union[str, bytes], s: bytes) -&gt; bytes:</span>
<span class="gi">+    hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)</span>
<span class="gi">+    hash.update(utf8(s))</span>
<span class="gi">+    return utf8(hash.hexdigest())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_absolute(path: str) -&gt; bool:</span>
<span class="gi">+    return any(path.startswith(x) for x in [&quot;/&quot;, &quot;http:&quot;, &quot;https:&quot;])</span>
<span class="gh">diff --git a/tornado/websocket.py b/tornado/websocket.py</span>
<span class="gh">index 8d336cb2..8f0e0aef 100644</span>
<span class="gd">--- a/tornado/websocket.py</span>
<span class="gi">+++ b/tornado/websocket.py</span>
<span class="gu">@@ -10,6 +10,7 @@ defined in `RFC 6455 &lt;http://tools.ietf.org/html/rfc6455&gt;`_.</span>
<span class="w"> </span>.. versionchanged:: 4.0
<span class="w"> </span>   Removed support for the draft 76 protocol version.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import asyncio
<span class="w"> </span>import base64
<span class="gu">@@ -21,6 +22,7 @@ import tornado</span>
<span class="w"> </span>from urllib.parse import urlparse
<span class="w"> </span>import warnings
<span class="w"> </span>import zlib
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import Future, future_set_result_unless_cancelled
<span class="w"> </span>from tornado.escape import utf8, native_str, to_unicode
<span class="w"> </span>from tornado import gen, httpclient, httputil
<span class="gu">@@ -32,22 +34,67 @@ from tornado import simple_httpclient</span>
<span class="w"> </span>from tornado.queues import Queue
<span class="w"> </span>from tornado.tcpclient import TCPClient
<span class="w"> </span>from tornado.util import _websocket_mask
<span class="gd">-from typing import TYPE_CHECKING, cast, Any, Optional, Dict, Union, List, Awaitable, Callable, Tuple, Type</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Awaitable,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+)</span>
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Protocol

<span class="gd">-</span>
<span class="gi">+    # The zlib compressor types aren&#39;t actually exposed anywhere</span>
<span class="gi">+    # publicly, so declare protocols for the portions we use.</span>
<span class="w"> </span>    class _Compressor(Protocol):
<span class="gd">-        pass</span>
<span class="gi">+        def compress(self, data: bytes) -&gt; bytes:</span>
<span class="gi">+            pass</span>

<span class="gi">+        def flush(self, mode: int) -&gt; bytes:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    class _Decompressor(Protocol):
<span class="gd">-        unconsumed_tail = b&#39;&#39;</span>
<span class="gi">+        unconsumed_tail = b&quot;&quot;  # type: bytes</span>

<span class="gi">+        def decompress(self, data: bytes, max_length: int) -&gt; bytes:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    class _WebSocketDelegate(Protocol):
<span class="gd">-        pass</span>
<span class="gi">+        # The common base interface implemented by WebSocketHandler on</span>
<span class="gi">+        # the server side and WebSocketClientConnection on the client</span>
<span class="gi">+        # side.</span>
<span class="gi">+        def on_ws_connection_close(</span>
<span class="gi">+            self, close_code: Optional[int] = None, close_reason: Optional[str] = None</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        def on_message(self, message: Union[str, bytes]) -&gt; Optional[&quot;Awaitable[None]&quot;]:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        def on_ping(self, data: bytes) -&gt; None:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        def on_pong(self, data: bytes) -&gt; None:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        def log_exception(</span>
<span class="gi">+            self,</span>
<span class="gi">+            typ: Optional[Type[BaseException]],</span>
<span class="gi">+            value: Optional[BaseException],</span>
<span class="gi">+            tb: Optional[TracebackType],</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_default_max_message_size = 10 * 1024 * 1024


<span class="gu">@@ -60,6 +107,7 @@ class WebSocketClosedError(WebSocketError):</span>

<span class="w"> </span>    .. versionadded:: 3.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -68,11 +116,13 @@ class _DecompressTooLargeError(Exception):</span>


<span class="w"> </span>class _WebSocketParams(object):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, ping_interval: Optional[float]=None, ping_timeout:</span>
<span class="gd">-        Optional[float]=None, max_message_size: int=</span>
<span class="gd">-        _default_max_message_size, compression_options: Optional[Dict[str,</span>
<span class="gd">-        Any]]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ping_interval: Optional[float] = None,</span>
<span class="gi">+        ping_timeout: Optional[float] = None,</span>
<span class="gi">+        max_message_size: int = _default_max_message_size,</span>
<span class="gi">+        compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.ping_interval = ping_interval
<span class="w"> </span>        self.ping_timeout = ping_timeout
<span class="w"> </span>        self.max_message_size = max_message_size
<span class="gu">@@ -161,32 +211,88 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>       ``websocket_max_message_size``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, application: tornado.web.Application, request:</span>
<span class="gd">-        httputil.HTTPServerRequest, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        application: tornado.web.Application,</span>
<span class="gi">+        request: httputil.HTTPServerRequest,</span>
<span class="gi">+        **kwargs: Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(application, request, **kwargs)
<span class="gd">-        self.ws_connection = None</span>
<span class="gd">-        self.close_code = None</span>
<span class="gd">-        self.close_reason = None</span>
<span class="gi">+        self.ws_connection = None  # type: Optional[WebSocketProtocol]</span>
<span class="gi">+        self.close_code = None  # type: Optional[int]</span>
<span class="gi">+        self.close_reason = None  # type: Optional[str]</span>
<span class="w"> </span>        self._on_close_called = False

<span class="gi">+    async def get(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        self.open_args = args</span>
<span class="gi">+        self.open_kwargs = kwargs</span>
<span class="gi">+</span>
<span class="gi">+        # Upgrade header should be present and should be equal to WebSocket</span>
<span class="gi">+        if self.request.headers.get(&quot;Upgrade&quot;, &quot;&quot;).lower() != &quot;websocket&quot;:</span>
<span class="gi">+            self.set_status(400)</span>
<span class="gi">+            log_msg = &#39;Can &quot;Upgrade&quot; only to &quot;WebSocket&quot;.&#39;</span>
<span class="gi">+            self.finish(log_msg)</span>
<span class="gi">+            gen_log.debug(log_msg)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Connection header should be upgrade.</span>
<span class="gi">+        # Some proxy servers/load balancers</span>
<span class="gi">+        # might mess with it.</span>
<span class="gi">+        headers = self.request.headers</span>
<span class="gi">+        connection = map(</span>
<span class="gi">+            lambda s: s.strip().lower(), headers.get(&quot;Connection&quot;, &quot;&quot;).split(&quot;,&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if &quot;upgrade&quot; not in connection:</span>
<span class="gi">+            self.set_status(400)</span>
<span class="gi">+            log_msg = &#39;&quot;Connection&quot; must be &quot;Upgrade&quot;.&#39;</span>
<span class="gi">+            self.finish(log_msg)</span>
<span class="gi">+            gen_log.debug(log_msg)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Handle WebSocket Origin naming convention differences</span>
<span class="gi">+        # The difference between version 8 and 13 is that in 8 the</span>
<span class="gi">+        # client sends a &quot;Sec-Websocket-Origin&quot; header and in 13 it&#39;s</span>
<span class="gi">+        # simply &quot;Origin&quot;.</span>
<span class="gi">+        if &quot;Origin&quot; in self.request.headers:</span>
<span class="gi">+            origin = self.request.headers.get(&quot;Origin&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            origin = self.request.headers.get(&quot;Sec-Websocket-Origin&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # If there was an origin header, check to make sure it matches</span>
<span class="gi">+        # according to check_origin. When the origin is None, we assume it</span>
<span class="gi">+        # did not come from a browser and that it can be passed on.</span>
<span class="gi">+        if origin is not None and not self.check_origin(origin):</span>
<span class="gi">+            self.set_status(403)</span>
<span class="gi">+            log_msg = &quot;Cross origin websockets not allowed&quot;</span>
<span class="gi">+            self.finish(log_msg)</span>
<span class="gi">+            gen_log.debug(log_msg)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.ws_connection = self.get_websocket_protocol()</span>
<span class="gi">+        if self.ws_connection:</span>
<span class="gi">+            await self.ws_connection.accept_connection(self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.set_status(426, &quot;Upgrade Required&quot;)</span>
<span class="gi">+            self.set_header(&quot;Sec-WebSocket-Version&quot;, &quot;7, 8, 13&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def ping_interval(self) -&gt;Optional[float]:</span>
<span class="gi">+    def ping_interval(self) -&gt; Optional[float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The interval for websocket keep-alive pings.

<span class="w"> </span>        Set websocket_ping_interval = 0 to disable pings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.settings.get(&quot;websocket_ping_interval&quot;, None)</span>

<span class="w"> </span>    @property
<span class="gd">-    def ping_timeout(self) -&gt;Optional[float]:</span>
<span class="gi">+    def ping_timeout(self) -&gt; Optional[float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;If no ping is received in this many seconds,
<span class="w"> </span>        close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).
<span class="w"> </span>        Default is max of 3 pings or 30 seconds.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.settings.get(&quot;websocket_ping_timeout&quot;, None)</span>

<span class="w"> </span>    @property
<span class="gd">-    def max_message_size(self) -&gt;int:</span>
<span class="gi">+    def max_message_size(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Maximum allowed message size.

<span class="w"> </span>        If the remote peer sends a message larger than this, the connection
<span class="gu">@@ -194,10 +300,13 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>        Default is 10MiB.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.settings.get(</span>
<span class="gi">+            &quot;websocket_max_message_size&quot;, _default_max_message_size</span>
<span class="gi">+        )</span>

<span class="gd">-    def write_message(self, message: Union[bytes, str, Dict[str, Any]],</span>
<span class="gd">-        binary: bool=False) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    def write_message(</span>
<span class="gi">+        self, message: Union[bytes, str, Dict[str, Any]], binary: bool = False</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends the given message to the client of this Web Socket.

<span class="w"> </span>        The message may be either a string or a dict (which will be
<span class="gu">@@ -219,9 +328,13 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>           Consistently raises `WebSocketClosedError`. Previously could
<span class="w"> </span>           sometimes raise `.StreamClosedError`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ws_connection is None or self.ws_connection.is_closing():</span>
<span class="gi">+            raise WebSocketClosedError()</span>
<span class="gi">+        if isinstance(message, dict):</span>
<span class="gi">+            message = tornado.escape.json_encode(message)</span>
<span class="gi">+        return self.ws_connection.write_message(message, binary=binary)</span>

<span class="gd">-    def select_subprotocol(self, subprotocols: List[str]) -&gt;Optional[str]:</span>
<span class="gi">+    def select_subprotocol(self, subprotocols: List[str]) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to implement subprotocol negotiation.

<span class="w"> </span>        ``subprotocols`` is a list of strings identifying the
<span class="gu">@@ -244,17 +357,18 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>           an empty string instead of an empty list if no subprotocols
<span class="w"> </span>           were proposed by the client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="gd">-    def selected_subprotocol(self) -&gt;Optional[str]:</span>
<span class="gi">+    def selected_subprotocol(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The subprotocol returned by `select_subprotocol`.

<span class="w"> </span>        .. versionadded:: 5.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.ws_connection is not None</span>
<span class="gi">+        return self.ws_connection.selected_subprotocol</span>

<span class="gd">-    def get_compression_options(self) -&gt;Optional[Dict[str, Any]]:</span>
<span class="gi">+    def get_compression_options(self) -&gt; Optional[Dict[str, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to return compression options for the connection.

<span class="w"> </span>        If this method returns None (the default), compression will
<span class="gu">@@ -275,9 +389,10 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>           Added ``compression_level`` and ``mem_level``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: Add wbits option.</span>
<span class="gi">+        return None</span>

<span class="gd">-    def open(self, *args: str, **kwargs: str) -&gt;Optional[Awaitable[None]]:</span>
<span class="gi">+    def open(self, *args: str, **kwargs: str) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoked when a new WebSocket is opened.

<span class="w"> </span>        The arguments to `open` are extracted from the `tornado.web.URLSpec`
<span class="gu">@@ -293,8 +408,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def on_message(self, message: Union[str, bytes]) -&gt;Optional[Awaitable[None]</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def on_message(self, message: Union[str, bytes]) -&gt; Optional[Awaitable[None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle incoming messages on the WebSocket

<span class="w"> </span>        This method must be overridden.
<span class="gu">@@ -303,9 +417,9 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>           ``on_message`` can be a coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def ping(self, data: Union[str, bytes]=b&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def ping(self, data: Union[str, bytes] = b&quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Send ping frame to the remote end.

<span class="w"> </span>        The data argument allows a small amount of data (up to 125
<span class="gu">@@ -321,17 +435,20 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>           The data argument is now optional.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = utf8(data)</span>
<span class="gi">+        if self.ws_connection is None or self.ws_connection.is_closing():</span>
<span class="gi">+            raise WebSocketClosedError()</span>
<span class="gi">+        self.ws_connection.write_ping(data)</span>

<span class="gd">-    def on_pong(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def on_pong(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoked when the response to a ping frame is received.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def on_ping(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def on_ping(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoked when the a ping frame is received.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def on_close(self) -&gt;None:</span>
<span class="gi">+    def on_close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoked when the WebSocket is closed.

<span class="w"> </span>        If the connection was closed cleanly and a status code or reason
<span class="gu">@@ -344,8 +461,7 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def close(self, code: Optional[int]=None, reason: Optional[str]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes this Web Socket.

<span class="w"> </span>        Once the close handshake is successful the socket will be closed.
<span class="gu">@@ -361,9 +477,11 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>           Added the ``code`` and ``reason`` arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ws_connection:</span>
<span class="gi">+            self.ws_connection.close(code, reason)</span>
<span class="gi">+            self.ws_connection = None</span>

<span class="gd">-    def check_origin(self, origin: str) -&gt;bool:</span>
<span class="gi">+    def check_origin(self, origin: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override to enable support for allowing alternate origins.

<span class="w"> </span>        The ``origin`` argument is the value of the ``Origin`` HTTP
<span class="gu">@@ -410,9 +528,16 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>
<span class="w"> </span>        .. versionadded:: 4.0

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parsed_origin = urlparse(origin)</span>
<span class="gi">+        origin = parsed_origin.netloc</span>
<span class="gi">+        origin = origin.lower()</span>
<span class="gi">+</span>
<span class="gi">+        host = self.request.headers.get(&quot;Host&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check to see that origin matches host directly, including ports</span>
<span class="gi">+        return origin == host</span>

<span class="gd">-    def set_nodelay(self, value: bool) -&gt;None:</span>
<span class="gi">+    def set_nodelay(self, value: bool) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the no-delay flag for this stream.

<span class="w"> </span>        By default, small messages may be delayed and/or combined to minimize
<span class="gu">@@ -426,76 +551,241 @@ class WebSocketHandler(tornado.web.RequestHandler):</span>

<span class="w"> </span>        .. versionadded:: 3.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.ws_connection is not None</span>
<span class="gi">+        self.ws_connection.set_nodelay(value)</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        if self.ws_connection:</span>
<span class="gi">+            self.ws_connection.on_connection_close()</span>
<span class="gi">+            self.ws_connection = None</span>
<span class="gi">+        if not self._on_close_called:</span>
<span class="gi">+            self._on_close_called = True</span>
<span class="gi">+            self.on_close()</span>
<span class="gi">+            self._break_cycles()</span>
<span class="gi">+</span>
<span class="gi">+    def on_ws_connection_close(</span>
<span class="gi">+        self, close_code: Optional[int] = None, close_reason: Optional[str] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.close_code = close_code</span>
<span class="gi">+        self.close_reason = close_reason</span>
<span class="gi">+        self.on_connection_close()</span>
<span class="gi">+</span>
<span class="gi">+    def _break_cycles(self) -&gt; None:</span>
<span class="gi">+        # WebSocketHandlers call finish() early, but we don&#39;t want to</span>
<span class="gi">+        # break up reference cycles (which makes it impossible to call</span>
<span class="gi">+        # self.render_string) until after we&#39;ve really closed the</span>
<span class="gi">+        # connection (if it was established in the first place,</span>
<span class="gi">+        # indicated by status code 101).</span>
<span class="gi">+        if self.get_status() != 101 or self._on_close_called:</span>
<span class="gi">+            super()._break_cycles()</span>
<span class="gi">+</span>
<span class="gi">+    def get_websocket_protocol(self) -&gt; Optional[&quot;WebSocketProtocol&quot;]:</span>
<span class="gi">+        websocket_version = self.request.headers.get(&quot;Sec-WebSocket-Version&quot;)</span>
<span class="gi">+        if websocket_version in (&quot;7&quot;, &quot;8&quot;, &quot;13&quot;):</span>
<span class="gi">+            params = _WebSocketParams(</span>
<span class="gi">+                ping_interval=self.ping_interval,</span>
<span class="gi">+                ping_timeout=self.ping_timeout,</span>
<span class="gi">+                max_message_size=self.max_message_size,</span>
<span class="gi">+                compression_options=self.get_compression_options(),</span>
<span class="gi">+            )</span>
<span class="gi">+            return WebSocketProtocol13(self, False, params)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _detach_stream(self) -&gt; IOStream:</span>
<span class="gi">+        # disable non-WS methods</span>
<span class="gi">+        for method in [</span>
<span class="gi">+            &quot;write&quot;,</span>
<span class="gi">+            &quot;redirect&quot;,</span>
<span class="gi">+            &quot;set_header&quot;,</span>
<span class="gi">+            &quot;set_cookie&quot;,</span>
<span class="gi">+            &quot;set_status&quot;,</span>
<span class="gi">+            &quot;flush&quot;,</span>
<span class="gi">+            &quot;finish&quot;,</span>
<span class="gi">+        ]:</span>
<span class="gi">+            setattr(self, method, _raise_not_supported_for_websockets)</span>
<span class="gi">+        return self.detach()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _raise_not_supported_for_websockets(*args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+    raise RuntimeError(&quot;Method not supported for Web Sockets&quot;)</span>


<span class="w"> </span>class WebSocketProtocol(abc.ABC):
<span class="w"> </span>    &quot;&quot;&quot;Base class for WebSocket protocol versions.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, handler: &#39;_WebSocketDelegate&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, handler: &quot;_WebSocketDelegate&quot;) -&gt; None:</span>
<span class="w"> </span>        self.handler = handler
<span class="gd">-        self.stream = None</span>
<span class="gi">+        self.stream = None  # type: Optional[IOStream]</span>
<span class="w"> </span>        self.client_terminated = False
<span class="w"> </span>        self.server_terminated = False

<span class="gd">-    def _run_callback(self, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gd">-        ) -&gt;&#39;Optional[Future[Any]]&#39;:</span>
<span class="gi">+    def _run_callback(</span>
<span class="gi">+        self, callback: Callable, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; &quot;Optional[Future[Any]]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs the given callback with exception handling.

<span class="w"> </span>        If the callback is a coroutine, returns its Future. On error, aborts the
<span class="w"> </span>        websocket connection and returns None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = callback(*args, **kwargs)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            self.handler.log_exception(*sys.exc_info())</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                result = gen.convert_yielded(result)</span>
<span class="gi">+                assert self.stream is not None</span>
<span class="gi">+                self.stream.io_loop.add_future(result, lambda f: f.result())</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        self._abort()</span>

<span class="gd">-    def _abort(self) -&gt;None:</span>
<span class="gi">+    def _abort(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Instantly aborts the WebSocket connection by closing the socket&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.client_terminated = True</span>
<span class="gi">+        self.server_terminated = True</span>
<span class="gi">+        if self.stream is not None:</span>
<span class="gi">+            self.stream.close()  # forcibly tear down the connection</span>
<span class="gi">+        self.close()  # let the subclass cleanup</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def is_closing(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    async def accept_connection(self, handler: WebSocketHandler) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def write_message(</span>
<span class="gi">+        self, message: Union[str, bytes, Dict[str, Any]], binary: bool = False</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gi">+    @property</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def selected_subprotocol(self) -&gt; Optional[str]:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-class _PerMessageDeflateCompressor(object):</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def write_ping(self, data: bytes) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def __init__(self, persistent: bool, max_wbits: Optional[int],</span>
<span class="gd">-        compression_options: Optional[Dict[str, Any]]=None) -&gt;None:</span>
<span class="gi">+    # The entry points below are used by WebSocketClientConnection,</span>
<span class="gi">+    # which was introduced after we only supported a single version of</span>
<span class="gi">+    # WebSocketProtocol. The WebSocketProtocol/WebSocketProtocol13</span>
<span class="gi">+    # boundary is currently pretty ad-hoc.</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def _process_server_headers(</span>
<span class="gi">+        self, key: Union[str, bytes], headers: httputil.HTTPHeaders</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def start_pinging(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    async def _receive_frame_loop(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def set_nodelay(self, x: bool) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _PerMessageDeflateCompressor(object):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        persistent: bool,</span>
<span class="gi">+        max_wbits: Optional[int],</span>
<span class="gi">+        compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if max_wbits is None:
<span class="w"> </span>            max_wbits = zlib.MAX_WBITS
<span class="gd">-        if not 8 &lt;= max_wbits &lt;= zlib.MAX_WBITS:</span>
<span class="gd">-            raise ValueError(&#39;Invalid max_wbits value %r; allowed range 8-%d&#39;,</span>
<span class="gd">-                max_wbits, zlib.MAX_WBITS)</span>
<span class="gi">+        # There is no symbolic constant for the minimum wbits value.</span>
<span class="gi">+        if not (8 &lt;= max_wbits &lt;= zlib.MAX_WBITS):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Invalid max_wbits value %r; allowed range 8-%d&quot;,</span>
<span class="gi">+                max_wbits,</span>
<span class="gi">+                zlib.MAX_WBITS,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self._max_wbits = max_wbits
<span class="gd">-        if (compression_options is None or &#39;compression_level&#39; not in</span>
<span class="gd">-            compression_options):</span>
<span class="gd">-            self._compression_level = (tornado.web.GZipContentEncoding.</span>
<span class="gd">-                GZIP_LEVEL)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            compression_options is None</span>
<span class="gi">+            or &quot;compression_level&quot; not in compression_options</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._compression_level = tornado.web.GZipContentEncoding.GZIP_LEVEL</span>
<span class="w"> </span>        else:
<span class="gd">-            self._compression_level = compression_options[&#39;compression_level&#39;]</span>
<span class="gd">-        if (compression_options is None or &#39;mem_level&#39; not in</span>
<span class="gd">-            compression_options):</span>
<span class="gi">+            self._compression_level = compression_options[&quot;compression_level&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if compression_options is None or &quot;mem_level&quot; not in compression_options:</span>
<span class="w"> </span>            self._mem_level = 8
<span class="w"> </span>        else:
<span class="gd">-            self._mem_level = compression_options[&#39;mem_level&#39;]</span>
<span class="gi">+            self._mem_level = compression_options[&quot;mem_level&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>        if persistent:
<span class="gd">-            self._compressor = self._create_compressor()</span>
<span class="gi">+            self._compressor = self._create_compressor()  # type: Optional[_Compressor]</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._compressor = None

<span class="gi">+    def _create_compressor(self) -&gt; &quot;_Compressor&quot;:</span>
<span class="gi">+        return zlib.compressobj(</span>
<span class="gi">+            self._compression_level, zlib.DEFLATED, -self._max_wbits, self._mem_level</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def compress(self, data: bytes) -&gt; bytes:</span>
<span class="gi">+        compressor = self._compressor or self._create_compressor()</span>
<span class="gi">+        data = compressor.compress(data) + compressor.flush(zlib.Z_SYNC_FLUSH)</span>
<span class="gi">+        assert data.endswith(b&quot;\x00\x00\xff\xff&quot;)</span>
<span class="gi">+        return data[:-4]</span>

<span class="gd">-class _PerMessageDeflateDecompressor(object):</span>

<span class="gd">-    def __init__(self, persistent: bool, max_wbits: Optional[int],</span>
<span class="gd">-        max_message_size: int, compression_options: Optional[Dict[str, Any]</span>
<span class="gd">-        ]=None) -&gt;None:</span>
<span class="gi">+class _PerMessageDeflateDecompressor(object):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        persistent: bool,</span>
<span class="gi">+        max_wbits: Optional[int],</span>
<span class="gi">+        max_message_size: int,</span>
<span class="gi">+        compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._max_message_size = max_message_size
<span class="w"> </span>        if max_wbits is None:
<span class="w"> </span>            max_wbits = zlib.MAX_WBITS
<span class="gd">-        if not 8 &lt;= max_wbits &lt;= zlib.MAX_WBITS:</span>
<span class="gd">-            raise ValueError(&#39;Invalid max_wbits value %r; allowed range 8-%d&#39;,</span>
<span class="gd">-                max_wbits, zlib.MAX_WBITS)</span>
<span class="gi">+        if not (8 &lt;= max_wbits &lt;= zlib.MAX_WBITS):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Invalid max_wbits value %r; allowed range 8-%d&quot;,</span>
<span class="gi">+                max_wbits,</span>
<span class="gi">+                zlib.MAX_WBITS,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self._max_wbits = max_wbits
<span class="w"> </span>        if persistent:
<span class="gd">-            self._decompressor = self._create_decompressor()</span>
<span class="gi">+            self._decompressor = (</span>
<span class="gi">+                self._create_decompressor()</span>
<span class="gi">+            )  # type: Optional[_Decompressor]</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._decompressor = None

<span class="gi">+    def _create_decompressor(self) -&gt; &quot;_Decompressor&quot;:</span>
<span class="gi">+        return zlib.decompressobj(-self._max_wbits)</span>
<span class="gi">+</span>
<span class="gi">+    def decompress(self, data: bytes) -&gt; bytes:</span>
<span class="gi">+        decompressor = self._decompressor or self._create_decompressor()</span>
<span class="gi">+        result = decompressor.decompress(</span>
<span class="gi">+            data + b&quot;\x00\x00\xff\xff&quot;, self._max_message_size</span>
<span class="gi">+        )</span>
<span class="gi">+        if decompressor.unconsumed_tail:</span>
<span class="gi">+            raise _DecompressTooLargeError()</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class WebSocketProtocol13(WebSocketProtocol):
<span class="w"> </span>    &quot;&quot;&quot;Implementation of the WebSocket protocol from RFC 6455.
<span class="gu">@@ -503,110 +793,551 @@ class WebSocketProtocol13(WebSocketProtocol):</span>
<span class="w"> </span>    This class supports versions 7 and 8 of the protocol in addition to the
<span class="w"> </span>    final version 13.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    FIN = 128</span>
<span class="gd">-    RSV1 = 64</span>
<span class="gd">-    RSV2 = 32</span>
<span class="gd">-    RSV3 = 16</span>
<span class="gi">+</span>
<span class="gi">+    # Bit masks for the first byte of a frame.</span>
<span class="gi">+    FIN = 0x80</span>
<span class="gi">+    RSV1 = 0x40</span>
<span class="gi">+    RSV2 = 0x20</span>
<span class="gi">+    RSV3 = 0x10</span>
<span class="w"> </span>    RSV_MASK = RSV1 | RSV2 | RSV3
<span class="gd">-    OPCODE_MASK = 15</span>
<span class="gd">-    stream = None</span>
<span class="gi">+    OPCODE_MASK = 0x0F</span>
<span class="gi">+</span>
<span class="gi">+    stream = None  # type: IOStream</span>

<span class="gd">-    def __init__(self, handler: &#39;_WebSocketDelegate&#39;, mask_outgoing: bool,</span>
<span class="gd">-        params: _WebSocketParams) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        handler: &quot;_WebSocketDelegate&quot;,</span>
<span class="gi">+        mask_outgoing: bool,</span>
<span class="gi">+        params: _WebSocketParams,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        WebSocketProtocol.__init__(self, handler)
<span class="w"> </span>        self.mask_outgoing = mask_outgoing
<span class="w"> </span>        self.params = params
<span class="w"> </span>        self._final_frame = False
<span class="w"> </span>        self._frame_opcode = None
<span class="w"> </span>        self._masked_frame = None
<span class="gd">-        self._frame_mask = None</span>
<span class="gi">+        self._frame_mask = None  # type: Optional[bytes]</span>
<span class="w"> </span>        self._frame_length = None
<span class="gd">-        self._fragmented_message_buffer = None</span>
<span class="gi">+        self._fragmented_message_buffer = None  # type: Optional[bytearray]</span>
<span class="w"> </span>        self._fragmented_message_opcode = None
<span class="gd">-        self._waiting = None</span>
<span class="gi">+        self._waiting = None  # type: object</span>
<span class="w"> </span>        self._compression_options = params.compression_options
<span class="gd">-        self._decompressor = None</span>
<span class="gd">-        self._compressor = None</span>
<span class="gd">-        self._frame_compressed = None</span>
<span class="gi">+        self._decompressor = None  # type: Optional[_PerMessageDeflateDecompressor]</span>
<span class="gi">+        self._compressor = None  # type: Optional[_PerMessageDeflateCompressor]</span>
<span class="gi">+        self._frame_compressed = None  # type: Optional[bool]</span>
<span class="gi">+        # The total uncompressed size of all messages received or sent.</span>
<span class="gi">+        # Unicode messages are encoded to utf8.</span>
<span class="gi">+        # Only for testing; subject to change.</span>
<span class="w"> </span>        self._message_bytes_in = 0
<span class="w"> </span>        self._message_bytes_out = 0
<span class="gi">+        # The total size of all packets received or sent.  Includes</span>
<span class="gi">+        # the effect of compression, frame overhead, and control frames.</span>
<span class="w"> </span>        self._wire_bytes_in = 0
<span class="w"> </span>        self._wire_bytes_out = 0
<span class="gd">-        self.ping_callback = None</span>
<span class="gi">+        self.ping_callback = None  # type: Optional[PeriodicCallback]</span>
<span class="w"> </span>        self.last_ping = 0.0
<span class="w"> </span>        self.last_pong = 0.0
<span class="gd">-        self.close_code = None</span>
<span class="gd">-        self.close_reason = None</span>
<span class="gi">+        self.close_code = None  # type: Optional[int]</span>
<span class="gi">+        self.close_reason = None  # type: Optional[str]</span>

<span class="gd">-    def _handle_websocket_headers(self, handler: WebSocketHandler) -&gt;None:</span>
<span class="gi">+    # Use a property for this to satisfy the abc.</span>
<span class="gi">+    @property</span>
<span class="gi">+    def selected_subprotocol(self) -&gt; Optional[str]:</span>
<span class="gi">+        return self._selected_subprotocol</span>
<span class="gi">+</span>
<span class="gi">+    @selected_subprotocol.setter</span>
<span class="gi">+    def selected_subprotocol(self, value: Optional[str]) -&gt; None:</span>
<span class="gi">+        self._selected_subprotocol = value</span>
<span class="gi">+</span>
<span class="gi">+    async def accept_connection(self, handler: WebSocketHandler) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._handle_websocket_headers(handler)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            handler.set_status(400)</span>
<span class="gi">+            log_msg = &quot;Missing/Invalid WebSocket headers&quot;</span>
<span class="gi">+            handler.finish(log_msg)</span>
<span class="gi">+            gen_log.debug(log_msg)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            await self._accept_connection(handler)</span>
<span class="gi">+        except asyncio.CancelledError:</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            gen_log.debug(&quot;Malformed WebSocket request received&quot;, exc_info=True)</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_websocket_headers(self, handler: WebSocketHandler) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Verifies all invariant- and required headers

<span class="w"> </span>        If a header is missing or have an incorrect value ValueError will be
<span class="w"> </span>        raised
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fields = (&quot;Host&quot;, &quot;Sec-Websocket-Key&quot;, &quot;Sec-Websocket-Version&quot;)</span>
<span class="gi">+        if not all(map(lambda f: handler.request.headers.get(f), fields)):</span>
<span class="gi">+            raise ValueError(&quot;Missing/Invalid WebSocket headers&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def compute_accept_value(key: Union[str, bytes]) -&gt;str:</span>
<span class="gi">+    def compute_accept_value(key: Union[str, bytes]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Computes the value for the Sec-WebSocket-Accept header,
<span class="w"> </span>        given the value for Sec-WebSocket-Key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _process_server_headers(self, key: Union[str, bytes], headers:</span>
<span class="gd">-        httputil.HTTPHeaders) -&gt;None:</span>
<span class="gi">+        sha1 = hashlib.sha1()</span>
<span class="gi">+        sha1.update(utf8(key))</span>
<span class="gi">+        sha1.update(b&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;)  # Magic value</span>
<span class="gi">+        return native_str(base64.b64encode(sha1.digest()))</span>
<span class="gi">+</span>
<span class="gi">+    def _challenge_response(self, handler: WebSocketHandler) -&gt; str:</span>
<span class="gi">+        return WebSocketProtocol13.compute_accept_value(</span>
<span class="gi">+            cast(str, handler.request.headers.get(&quot;Sec-Websocket-Key&quot;))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async def _accept_connection(self, handler: WebSocketHandler) -&gt; None:</span>
<span class="gi">+        subprotocol_header = handler.request.headers.get(&quot;Sec-WebSocket-Protocol&quot;)</span>
<span class="gi">+        if subprotocol_header:</span>
<span class="gi">+            subprotocols = [s.strip() for s in subprotocol_header.split(&quot;,&quot;)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            subprotocols = []</span>
<span class="gi">+        self.selected_subprotocol = handler.select_subprotocol(subprotocols)</span>
<span class="gi">+        if self.selected_subprotocol:</span>
<span class="gi">+            assert self.selected_subprotocol in subprotocols</span>
<span class="gi">+            handler.set_header(&quot;Sec-WebSocket-Protocol&quot;, self.selected_subprotocol)</span>
<span class="gi">+</span>
<span class="gi">+        extensions = self._parse_extensions_header(handler.request.headers)</span>
<span class="gi">+        for ext in extensions:</span>
<span class="gi">+            if ext[0] == &quot;permessage-deflate&quot; and self._compression_options is not None:</span>
<span class="gi">+                # TODO: negotiate parameters if compression_options</span>
<span class="gi">+                # specifies limits.</span>
<span class="gi">+                self._create_compressors(&quot;server&quot;, ext[1], self._compression_options)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    &quot;client_max_window_bits&quot; in ext[1]</span>
<span class="gi">+                    and ext[1][&quot;client_max_window_bits&quot;] is None</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Don&#39;t echo an offered client_max_window_bits</span>
<span class="gi">+                    # parameter with no value.</span>
<span class="gi">+                    del ext[1][&quot;client_max_window_bits&quot;]</span>
<span class="gi">+                handler.set_header(</span>
<span class="gi">+                    &quot;Sec-WebSocket-Extensions&quot;,</span>
<span class="gi">+                    httputil._encode_header(&quot;permessage-deflate&quot;, ext[1]),</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        handler.clear_header(&quot;Content-Type&quot;)</span>
<span class="gi">+        handler.set_status(101)</span>
<span class="gi">+        handler.set_header(&quot;Upgrade&quot;, &quot;websocket&quot;)</span>
<span class="gi">+        handler.set_header(&quot;Connection&quot;, &quot;Upgrade&quot;)</span>
<span class="gi">+        handler.set_header(&quot;Sec-WebSocket-Accept&quot;, self._challenge_response(handler))</span>
<span class="gi">+        handler.finish()</span>
<span class="gi">+</span>
<span class="gi">+        self.stream = handler._detach_stream()</span>
<span class="gi">+</span>
<span class="gi">+        self.start_pinging()</span>
<span class="gi">+        try:</span>
<span class="gi">+            open_result = handler.open(*handler.open_args, **handler.open_kwargs)</span>
<span class="gi">+            if open_result is not None:</span>
<span class="gi">+                await open_result</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            handler.log_exception(*sys.exc_info())</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        await self._receive_frame_loop()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_extensions_header(</span>
<span class="gi">+        self, headers: httputil.HTTPHeaders</span>
<span class="gi">+    ) -&gt; List[Tuple[str, Dict[str, str]]]:</span>
<span class="gi">+        extensions = headers.get(&quot;Sec-WebSocket-Extensions&quot;, &quot;&quot;)</span>
<span class="gi">+        if extensions:</span>
<span class="gi">+            return [httputil._parse_header(e.strip()) for e in extensions.split(&quot;,&quot;)]</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def _process_server_headers(</span>
<span class="gi">+        self, key: Union[str, bytes], headers: httputil.HTTPHeaders</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process the headers sent by the server to this client connection.

<span class="w"> </span>        &#39;key&#39; is the websocket handshake challenge/response key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_compressor_options(self, side: str, agreed_parameters: Dict[</span>
<span class="gd">-        str, Any], compression_options: Optional[Dict[str, Any]]=None) -&gt;Dict[</span>
<span class="gd">-        str, Any]:</span>
<span class="gi">+        assert headers[&quot;Upgrade&quot;].lower() == &quot;websocket&quot;</span>
<span class="gi">+        assert headers[&quot;Connection&quot;].lower() == &quot;upgrade&quot;</span>
<span class="gi">+        accept = self.compute_accept_value(key)</span>
<span class="gi">+        assert headers[&quot;Sec-Websocket-Accept&quot;] == accept</span>
<span class="gi">+</span>
<span class="gi">+        extensions = self._parse_extensions_header(headers)</span>
<span class="gi">+        for ext in extensions:</span>
<span class="gi">+            if ext[0] == &quot;permessage-deflate&quot; and self._compression_options is not None:</span>
<span class="gi">+                self._create_compressors(&quot;client&quot;, ext[1])</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;unsupported extension %r&quot;, ext)</span>
<span class="gi">+</span>
<span class="gi">+        self.selected_subprotocol = headers.get(&quot;Sec-WebSocket-Protocol&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_compressor_options(</span>
<span class="gi">+        self,</span>
<span class="gi">+        side: str,</span>
<span class="gi">+        agreed_parameters: Dict[str, Any],</span>
<span class="gi">+        compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a websocket agreed_parameters set to keyword arguments
<span class="w"> </span>        for our compressor objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_message(self, message: Union[str, bytes, Dict[str, Any]],</span>
<span class="gd">-        binary: bool=False) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+        options = dict(</span>
<span class="gi">+            persistent=(side + &quot;_no_context_takeover&quot;) not in agreed_parameters</span>
<span class="gi">+        )  # type: Dict[str, Any]</span>
<span class="gi">+        wbits_header = agreed_parameters.get(side + &quot;_max_window_bits&quot;, None)</span>
<span class="gi">+        if wbits_header is None:</span>
<span class="gi">+            options[&quot;max_wbits&quot;] = zlib.MAX_WBITS</span>
<span class="gi">+        else:</span>
<span class="gi">+            options[&quot;max_wbits&quot;] = int(wbits_header)</span>
<span class="gi">+        options[&quot;compression_options&quot;] = compression_options</span>
<span class="gi">+        return options</span>
<span class="gi">+</span>
<span class="gi">+    def _create_compressors(</span>
<span class="gi">+        self,</span>
<span class="gi">+        side: str,</span>
<span class="gi">+        agreed_parameters: Dict[str, Any],</span>
<span class="gi">+        compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # TODO: handle invalid parameters gracefully</span>
<span class="gi">+        allowed_keys = set(</span>
<span class="gi">+            [</span>
<span class="gi">+                &quot;server_no_context_takeover&quot;,</span>
<span class="gi">+                &quot;client_no_context_takeover&quot;,</span>
<span class="gi">+                &quot;server_max_window_bits&quot;,</span>
<span class="gi">+                &quot;client_max_window_bits&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+        for key in agreed_parameters:</span>
<span class="gi">+            if key not in allowed_keys:</span>
<span class="gi">+                raise ValueError(&quot;unsupported compression parameter %r&quot; % key)</span>
<span class="gi">+        other_side = &quot;client&quot; if (side == &quot;server&quot;) else &quot;server&quot;</span>
<span class="gi">+        self._compressor = _PerMessageDeflateCompressor(</span>
<span class="gi">+            **self._get_compressor_options(side, agreed_parameters, compression_options)</span>
<span class="gi">+        )</span>
<span class="gi">+        self._decompressor = _PerMessageDeflateDecompressor(</span>
<span class="gi">+            max_message_size=self.params.max_message_size,</span>
<span class="gi">+            **self._get_compressor_options(</span>
<span class="gi">+                other_side, agreed_parameters, compression_options</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _write_frame(</span>
<span class="gi">+        self, fin: bool, opcode: int, data: bytes, flags: int = 0</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="gi">+        data_len = len(data)</span>
<span class="gi">+        if opcode &amp; 0x8:</span>
<span class="gi">+            # All control frames MUST have a payload length of 125</span>
<span class="gi">+            # bytes or less and MUST NOT be fragmented.</span>
<span class="gi">+            if not fin:</span>
<span class="gi">+                raise ValueError(&quot;control frames may not be fragmented&quot;)</span>
<span class="gi">+            if data_len &gt; 125:</span>
<span class="gi">+                raise ValueError(&quot;control frame payloads may not exceed 125 bytes&quot;)</span>
<span class="gi">+        if fin:</span>
<span class="gi">+            finbit = self.FIN</span>
<span class="gi">+        else:</span>
<span class="gi">+            finbit = 0</span>
<span class="gi">+        frame = struct.pack(&quot;B&quot;, finbit | opcode | flags)</span>
<span class="gi">+        if self.mask_outgoing:</span>
<span class="gi">+            mask_bit = 0x80</span>
<span class="gi">+        else:</span>
<span class="gi">+            mask_bit = 0</span>
<span class="gi">+        if data_len &lt; 126:</span>
<span class="gi">+            frame += struct.pack(&quot;B&quot;, data_len | mask_bit)</span>
<span class="gi">+        elif data_len &lt;= 0xFFFF:</span>
<span class="gi">+            frame += struct.pack(&quot;!BH&quot;, 126 | mask_bit, data_len)</span>
<span class="gi">+        else:</span>
<span class="gi">+            frame += struct.pack(&quot;!BQ&quot;, 127 | mask_bit, data_len)</span>
<span class="gi">+        if self.mask_outgoing:</span>
<span class="gi">+            mask = os.urandom(4)</span>
<span class="gi">+            data = mask + _websocket_mask(mask, data)</span>
<span class="gi">+        frame += data</span>
<span class="gi">+        self._wire_bytes_out += len(frame)</span>
<span class="gi">+        return self.stream.write(frame)</span>
<span class="gi">+</span>
<span class="gi">+    def write_message(</span>
<span class="gi">+        self, message: Union[str, bytes, Dict[str, Any]], binary: bool = False</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends the given message to the client of this Web Socket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_ping(self, data: bytes) -&gt;None:</span>
<span class="gi">+        if binary:</span>
<span class="gi">+            opcode = 0x2</span>
<span class="gi">+        else:</span>
<span class="gi">+            opcode = 0x1</span>
<span class="gi">+        if isinstance(message, dict):</span>
<span class="gi">+            message = tornado.escape.json_encode(message)</span>
<span class="gi">+        message = tornado.escape.utf8(message)</span>
<span class="gi">+        assert isinstance(message, bytes)</span>
<span class="gi">+        self._message_bytes_out += len(message)</span>
<span class="gi">+        flags = 0</span>
<span class="gi">+        if self._compressor:</span>
<span class="gi">+            message = self._compressor.compress(message)</span>
<span class="gi">+            flags |= self.RSV1</span>
<span class="gi">+        # For historical reasons, write methods in Tornado operate in a semi-synchronous</span>
<span class="gi">+        # mode in which awaiting the Future they return is optional (But errors can</span>
<span class="gi">+        # still be raised). This requires us to go through an awkward dance here</span>
<span class="gi">+        # to transform the errors that may be returned while presenting the same</span>
<span class="gi">+        # semi-synchronous interface.</span>
<span class="gi">+        try:</span>
<span class="gi">+            fut = self._write_frame(True, opcode, message, flags=flags)</span>
<span class="gi">+        except StreamClosedError:</span>
<span class="gi">+            raise WebSocketClosedError()</span>
<span class="gi">+</span>
<span class="gi">+        async def wrapper() -&gt; None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                await fut</span>
<span class="gi">+            except StreamClosedError:</span>
<span class="gi">+                raise WebSocketClosedError()</span>
<span class="gi">+</span>
<span class="gi">+        return asyncio.ensure_future(wrapper())</span>
<span class="gi">+</span>
<span class="gi">+    def write_ping(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Send ping frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _handle_message(self, opcode: int, data: bytes</span>
<span class="gd">-        ) -&gt;&#39;Optional[Future[None]]&#39;:</span>
<span class="gi">+        assert isinstance(data, bytes)</span>
<span class="gi">+        self._write_frame(True, 0x9, data)</span>
<span class="gi">+</span>
<span class="gi">+    async def _receive_frame_loop(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            while not self.client_terminated:</span>
<span class="gi">+                await self._receive_frame()</span>
<span class="gi">+        except StreamClosedError:</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+        self.handler.on_ws_connection_close(self.close_code, self.close_reason)</span>
<span class="gi">+</span>
<span class="gi">+    async def _read_bytes(self, n: int) -&gt; bytes:</span>
<span class="gi">+        data = await self.stream.read_bytes(n)</span>
<span class="gi">+        self._wire_bytes_in += n</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    async def _receive_frame(self) -&gt; None:</span>
<span class="gi">+        # Read the frame header.</span>
<span class="gi">+        data = await self._read_bytes(2)</span>
<span class="gi">+        header, mask_payloadlen = struct.unpack(&quot;BB&quot;, data)</span>
<span class="gi">+        is_final_frame = header &amp; self.FIN</span>
<span class="gi">+        reserved_bits = header &amp; self.RSV_MASK</span>
<span class="gi">+        opcode = header &amp; self.OPCODE_MASK</span>
<span class="gi">+        opcode_is_control = opcode &amp; 0x8</span>
<span class="gi">+        if self._decompressor is not None and opcode != 0:</span>
<span class="gi">+            # Compression flag is present in the first frame&#39;s header,</span>
<span class="gi">+            # but we can&#39;t decompress until we have all the frames of</span>
<span class="gi">+            # the message.</span>
<span class="gi">+            self._frame_compressed = bool(reserved_bits &amp; self.RSV1)</span>
<span class="gi">+            reserved_bits &amp;= ~self.RSV1</span>
<span class="gi">+        if reserved_bits:</span>
<span class="gi">+            # client is using as-yet-undefined extensions; abort</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return</span>
<span class="gi">+        is_masked = bool(mask_payloadlen &amp; 0x80)</span>
<span class="gi">+        payloadlen = mask_payloadlen &amp; 0x7F</span>
<span class="gi">+</span>
<span class="gi">+        # Parse and validate the length.</span>
<span class="gi">+        if opcode_is_control and payloadlen &gt;= 126:</span>
<span class="gi">+            # control frames must have payload &lt; 126</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return</span>
<span class="gi">+        if payloadlen &lt; 126:</span>
<span class="gi">+            self._frame_length = payloadlen</span>
<span class="gi">+        elif payloadlen == 126:</span>
<span class="gi">+            data = await self._read_bytes(2)</span>
<span class="gi">+            payloadlen = struct.unpack(&quot;!H&quot;, data)[0]</span>
<span class="gi">+        elif payloadlen == 127:</span>
<span class="gi">+            data = await self._read_bytes(8)</span>
<span class="gi">+            payloadlen = struct.unpack(&quot;!Q&quot;, data)[0]</span>
<span class="gi">+        new_len = payloadlen</span>
<span class="gi">+        if self._fragmented_message_buffer is not None:</span>
<span class="gi">+            new_len += len(self._fragmented_message_buffer)</span>
<span class="gi">+        if new_len &gt; self.params.max_message_size:</span>
<span class="gi">+            self.close(1009, &quot;message too big&quot;)</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Read the payload, unmasking if necessary.</span>
<span class="gi">+        if is_masked:</span>
<span class="gi">+            self._frame_mask = await self._read_bytes(4)</span>
<span class="gi">+        data = await self._read_bytes(payloadlen)</span>
<span class="gi">+        if is_masked:</span>
<span class="gi">+            assert self._frame_mask is not None</span>
<span class="gi">+            data = _websocket_mask(self._frame_mask, data)</span>
<span class="gi">+</span>
<span class="gi">+        # Decide what to do with this frame.</span>
<span class="gi">+        if opcode_is_control:</span>
<span class="gi">+            # control frames may be interleaved with a series of fragmented</span>
<span class="gi">+            # data frames, so control frames must not interact with</span>
<span class="gi">+            # self._fragmented_*</span>
<span class="gi">+            if not is_final_frame:</span>
<span class="gi">+                # control frames must not be fragmented</span>
<span class="gi">+                self._abort()</span>
<span class="gi">+                return</span>
<span class="gi">+        elif opcode == 0:  # continuation frame</span>
<span class="gi">+            if self._fragmented_message_buffer is None:</span>
<span class="gi">+                # nothing to continue</span>
<span class="gi">+                self._abort()</span>
<span class="gi">+                return</span>
<span class="gi">+            self._fragmented_message_buffer.extend(data)</span>
<span class="gi">+            if is_final_frame:</span>
<span class="gi">+                opcode = self._fragmented_message_opcode</span>
<span class="gi">+                data = bytes(self._fragmented_message_buffer)</span>
<span class="gi">+                self._fragmented_message_buffer = None</span>
<span class="gi">+        else:  # start of new data message</span>
<span class="gi">+            if self._fragmented_message_buffer is not None:</span>
<span class="gi">+                # can&#39;t start new message until the old one is finished</span>
<span class="gi">+                self._abort()</span>
<span class="gi">+                return</span>
<span class="gi">+            if not is_final_frame:</span>
<span class="gi">+                self._fragmented_message_opcode = opcode</span>
<span class="gi">+                self._fragmented_message_buffer = bytearray(data)</span>
<span class="gi">+</span>
<span class="gi">+        if is_final_frame:</span>
<span class="gi">+            handled_future = self._handle_message(opcode, data)</span>
<span class="gi">+            if handled_future is not None:</span>
<span class="gi">+                await handled_future</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_message(self, opcode: int, data: bytes) -&gt; &quot;Optional[Future[None]]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Execute on_message, returning its Future if it is a coroutine.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.client_terminated:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if self._frame_compressed:</span>
<span class="gi">+            assert self._decompressor is not None</span>
<span class="gi">+            try:</span>
<span class="gi">+                data = self._decompressor.decompress(data)</span>
<span class="gi">+            except _DecompressTooLargeError:</span>
<span class="gi">+                self.close(1009, &quot;message too big after decompression&quot;)</span>
<span class="gi">+                self._abort()</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        if opcode == 0x1:</span>
<span class="gi">+            # UTF-8 data</span>
<span class="gi">+            self._message_bytes_in += len(data)</span>
<span class="gi">+            try:</span>
<span class="gi">+                decoded = data.decode(&quot;utf-8&quot;)</span>
<span class="gi">+            except UnicodeDecodeError:</span>
<span class="gi">+                self._abort()</span>
<span class="gi">+                return None</span>
<span class="gi">+            return self._run_callback(self.handler.on_message, decoded)</span>
<span class="gi">+        elif opcode == 0x2:</span>
<span class="gi">+            # Binary data</span>
<span class="gi">+            self._message_bytes_in += len(data)</span>
<span class="gi">+            return self._run_callback(self.handler.on_message, data)</span>
<span class="gi">+        elif opcode == 0x8:</span>
<span class="gi">+            # Close</span>
<span class="gi">+            self.client_terminated = True</span>
<span class="gi">+            if len(data) &gt;= 2:</span>
<span class="gi">+                self.close_code = struct.unpack(&quot;&gt;H&quot;, data[:2])[0]</span>
<span class="gi">+            if len(data) &gt; 2:</span>
<span class="gi">+                self.close_reason = to_unicode(data[2:])</span>
<span class="gi">+            # Echo the received close code, if any (RFC 6455 section 5.5.1).</span>
<span class="gi">+            self.close(self.close_code)</span>
<span class="gi">+        elif opcode == 0x9:</span>
<span class="gi">+            # Ping</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._write_frame(True, 0xA, data)</span>
<span class="gi">+            except StreamClosedError:</span>
<span class="gi">+                self._abort()</span>
<span class="gi">+            self._run_callback(self.handler.on_ping, data)</span>
<span class="gi">+        elif opcode == 0xA:</span>
<span class="gi">+            # Pong</span>
<span class="gi">+            self.last_pong = IOLoop.current().time()</span>
<span class="gi">+            return self._run_callback(self.handler.on_pong, data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._abort()</span>
<span class="gi">+        return None</span>

<span class="gd">-    def close(self, code: Optional[int]=None, reason: Optional[str]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the WebSocket connection.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def is_closing(self) -&gt;bool:</span>
<span class="gi">+        if not self.server_terminated:</span>
<span class="gi">+            if not self.stream.closed():</span>
<span class="gi">+                if code is None and reason is not None:</span>
<span class="gi">+                    code = 1000  # &quot;normal closure&quot; status code</span>
<span class="gi">+                if code is None:</span>
<span class="gi">+                    close_data = b&quot;&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    close_data = struct.pack(&quot;&gt;H&quot;, code)</span>
<span class="gi">+                if reason is not None:</span>
<span class="gi">+                    close_data += utf8(reason)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._write_frame(True, 0x8, close_data)</span>
<span class="gi">+                except StreamClosedError:</span>
<span class="gi">+                    self._abort()</span>
<span class="gi">+            self.server_terminated = True</span>
<span class="gi">+        if self.client_terminated:</span>
<span class="gi">+            if self._waiting is not None:</span>
<span class="gi">+                self.stream.io_loop.remove_timeout(self._waiting)</span>
<span class="gi">+                self._waiting = None</span>
<span class="gi">+            self.stream.close()</span>
<span class="gi">+        elif self._waiting is None:</span>
<span class="gi">+            # Give the client a few seconds to complete a clean shutdown,</span>
<span class="gi">+            # otherwise just close the connection.</span>
<span class="gi">+            self._waiting = self.stream.io_loop.add_timeout(</span>
<span class="gi">+                self.stream.io_loop.time() + 5, self._abort</span>
<span class="gi">+            )</span>
<span class="gi">+        if self.ping_callback:</span>
<span class="gi">+            self.ping_callback.stop()</span>
<span class="gi">+            self.ping_callback = None</span>
<span class="gi">+</span>
<span class="gi">+    def is_closing(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if this connection is closing.

<span class="w"> </span>        The connection is considered closing if either side has
<span class="w"> </span>        initiated its closing handshake or if the stream has been
<span class="w"> </span>        shut down uncleanly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stream.closed() or self.client_terminated or self.server_terminated</span>

<span class="gd">-    def start_pinging(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Start sending periodic pings to keep the connection alive&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    @property</span>
<span class="gi">+    def ping_interval(self) -&gt; Optional[float]:</span>
<span class="gi">+        interval = self.params.ping_interval</span>
<span class="gi">+        if interval is not None:</span>
<span class="gi">+            return interval</span>
<span class="gi">+        return 0</span>

<span class="gd">-    def periodic_ping(self) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def ping_timeout(self) -&gt; Optional[float]:</span>
<span class="gi">+        timeout = self.params.ping_timeout</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            return timeout</span>
<span class="gi">+        assert self.ping_interval is not None</span>
<span class="gi">+        return max(3 * self.ping_interval, 30)</span>
<span class="gi">+</span>
<span class="gi">+    def start_pinging(self) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Start sending periodic pings to keep the connection alive&quot;&quot;&quot;</span>
<span class="gi">+        assert self.ping_interval is not None</span>
<span class="gi">+        if self.ping_interval &gt; 0:</span>
<span class="gi">+            self.last_ping = self.last_pong = IOLoop.current().time()</span>
<span class="gi">+            self.ping_callback = PeriodicCallback(</span>
<span class="gi">+                self.periodic_ping, self.ping_interval * 1000</span>
<span class="gi">+            )</span>
<span class="gi">+            self.ping_callback.start()</span>
<span class="gi">+</span>
<span class="gi">+    def periodic_ping(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Send a ping to keep the websocket alive

<span class="w"> </span>        Called periodically if the websocket_ping_interval is set and non-zero.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.is_closing() and self.ping_callback is not None:</span>
<span class="gi">+            self.ping_callback.stop()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Check for timeout on pong. Make sure that we really have</span>
<span class="gi">+        # sent a recent ping in case the machine with both server and</span>
<span class="gi">+        # client has been suspended since the last ping.</span>
<span class="gi">+        now = IOLoop.current().time()</span>
<span class="gi">+        since_last_pong = now - self.last_pong</span>
<span class="gi">+        since_last_ping = now - self.last_ping</span>
<span class="gi">+        assert self.ping_interval is not None</span>
<span class="gi">+        assert self.ping_timeout is not None</span>
<span class="gi">+        if (</span>
<span class="gi">+            since_last_ping &lt; 2 * self.ping_interval</span>
<span class="gi">+            and since_last_pong &gt; self.ping_timeout</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.write_ping(b&quot;&quot;)</span>
<span class="gi">+        self.last_ping = now</span>
<span class="gi">+</span>
<span class="gi">+    def set_nodelay(self, x: bool) -&gt; None:</span>
<span class="gi">+        self.stream.set_nodelay(x)</span>


<span class="w"> </span>class WebSocketClientConnection(simple_httpclient._HTTPConnection):
<span class="gu">@@ -615,46 +1346,81 @@ class WebSocketClientConnection(simple_httpclient._HTTPConnection):</span>
<span class="w"> </span>    This class should not be instantiated directly; use the
<span class="w"> </span>    `websocket_connect` function instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    protocol = None</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, request: httpclient.HTTPRequest, on_message_callback:</span>
<span class="gd">-        Optional[Callable[[Union[None, str, bytes]], None]]=None,</span>
<span class="gd">-        compression_options: Optional[Dict[str, Any]]=None, ping_interval:</span>
<span class="gd">-        Optional[float]=None, ping_timeout: Optional[float]=None,</span>
<span class="gd">-        max_message_size: int=_default_max_message_size, subprotocols:</span>
<span class="gd">-        Optional[List[str]]=None, resolver: Optional[Resolver]=None) -&gt;None:</span>
<span class="gd">-        self.connect_future = Future()</span>
<span class="gd">-        self.read_queue = Queue(1)</span>
<span class="gi">+</span>
<span class="gi">+    protocol = None  # type: WebSocketProtocol</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: httpclient.HTTPRequest,</span>
<span class="gi">+        on_message_callback: Optional[Callable[[Union[None, str, bytes]], None]] = None,</span>
<span class="gi">+        compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+        ping_interval: Optional[float] = None,</span>
<span class="gi">+        ping_timeout: Optional[float] = None,</span>
<span class="gi">+        max_message_size: int = _default_max_message_size,</span>
<span class="gi">+        subprotocols: Optional[List[str]] = None,</span>
<span class="gi">+        resolver: Optional[Resolver] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.connect_future = Future()  # type: Future[WebSocketClientConnection]</span>
<span class="gi">+        self.read_queue = Queue(1)  # type: Queue[Union[None, str, bytes]]</span>
<span class="w"> </span>        self.key = base64.b64encode(os.urandom(16))
<span class="w"> </span>        self._on_message_callback = on_message_callback
<span class="gd">-        self.close_code = None</span>
<span class="gd">-        self.close_reason = None</span>
<span class="gd">-        self.params = _WebSocketParams(ping_interval=ping_interval,</span>
<span class="gd">-            ping_timeout=ping_timeout, max_message_size=max_message_size,</span>
<span class="gd">-            compression_options=compression_options)</span>
<span class="gd">-        scheme, sep, rest = request.url.partition(&#39;:&#39;)</span>
<span class="gd">-        scheme = {&#39;ws&#39;: &#39;http&#39;, &#39;wss&#39;: &#39;https&#39;}[scheme]</span>
<span class="gi">+        self.close_code = None  # type: Optional[int]</span>
<span class="gi">+        self.close_reason = None  # type: Optional[str]</span>
<span class="gi">+        self.params = _WebSocketParams(</span>
<span class="gi">+            ping_interval=ping_interval,</span>
<span class="gi">+            ping_timeout=ping_timeout,</span>
<span class="gi">+            max_message_size=max_message_size,</span>
<span class="gi">+            compression_options=compression_options,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        scheme, sep, rest = request.url.partition(&quot;:&quot;)</span>
<span class="gi">+        scheme = {&quot;ws&quot;: &quot;http&quot;, &quot;wss&quot;: &quot;https&quot;}[scheme]</span>
<span class="w"> </span>        request.url = scheme + sep + rest
<span class="gd">-        request.headers.update({&#39;Upgrade&#39;: &#39;websocket&#39;, &#39;Connection&#39;:</span>
<span class="gd">-            &#39;Upgrade&#39;, &#39;Sec-WebSocket-Key&#39;: self.key,</span>
<span class="gd">-            &#39;Sec-WebSocket-Version&#39;: &#39;13&#39;})</span>
<span class="gi">+        request.headers.update(</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;Upgrade&quot;: &quot;websocket&quot;,</span>
<span class="gi">+                &quot;Connection&quot;: &quot;Upgrade&quot;,</span>
<span class="gi">+                &quot;Sec-WebSocket-Key&quot;: self.key,</span>
<span class="gi">+                &quot;Sec-WebSocket-Version&quot;: &quot;13&quot;,</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if subprotocols is not None:
<span class="gd">-            request.headers[&#39;Sec-WebSocket-Protocol&#39;] = &#39;,&#39;.join(subprotocols)</span>
<span class="gi">+            request.headers[&quot;Sec-WebSocket-Protocol&quot;] = &quot;,&quot;.join(subprotocols)</span>
<span class="w"> </span>        if compression_options is not None:
<span class="gd">-            request.headers[&#39;Sec-WebSocket-Extensions&#39;</span>
<span class="gd">-                ] = &#39;permessage-deflate; client_max_window_bits&#39;</span>
<span class="gi">+            # Always offer to let the server set our max_wbits (and even though</span>
<span class="gi">+            # we don&#39;t offer it, we will accept a client_no_context_takeover</span>
<span class="gi">+            # from the server).</span>
<span class="gi">+            # TODO: set server parameters for deflate extension</span>
<span class="gi">+            # if requested in self.compression_options.</span>
<span class="gi">+            request.headers[&quot;Sec-WebSocket-Extensions&quot;] = (</span>
<span class="gi">+                &quot;permessage-deflate; client_max_window_bits&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Websocket connection is currently unable to follow redirects</span>
<span class="w"> </span>        request.follow_redirects = False
<span class="gd">-        self.tcp_client = TCPClient(resolver=resolver)</span>
<span class="gd">-        super().__init__(None, request, lambda : None, self.</span>
<span class="gd">-            _on_http_response, 104857600, self.tcp_client, 65536, 104857600)</span>

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+        self.tcp_client = TCPClient(resolver=resolver)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            None,</span>
<span class="gi">+            request,</span>
<span class="gi">+            lambda: None,</span>
<span class="gi">+            self._on_http_response,</span>
<span class="gi">+            104857600,</span>
<span class="gi">+            self.tcp_client,</span>
<span class="gi">+            65536,</span>
<span class="gi">+            104857600,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="w"> </span>        if self.protocol is not None:
<span class="gd">-            warnings.warn(&#39;Unclosed WebSocketClientConnection&#39;, ResourceWarning</span>
<span class="gd">-                )</span>
<span class="gd">-</span>
<span class="gd">-    def close(self, code: Optional[int]=None, reason: Optional[str]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+            # Unclosed client connections can sometimes log &quot;task was destroyed but</span>
<span class="gi">+            # was pending&quot; warnings if shutdown strikes at the wrong time (such as</span>
<span class="gi">+            # while a ping is being processed due to ping_interval). Log our own</span>
<span class="gi">+            # warning to make it a little more deterministic (although it&#39;s still</span>
<span class="gi">+            # dependent on GC timing).</span>
<span class="gi">+            warnings.warn(&quot;Unclosed WebSocketClientConnection&quot;, ResourceWarning)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Closes the websocket connection.

<span class="w"> </span>        ``code`` and ``reason`` are documented under
<span class="gu">@@ -666,10 +1432,66 @@ class WebSocketClientConnection(simple_httpclient._HTTPConnection):</span>

<span class="w"> </span>           Added the ``code`` and ``reason`` arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.protocol is not None:</span>
<span class="gi">+            self.protocol.close(code, reason)</span>
<span class="gi">+            self.protocol = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def on_connection_close(self) -&gt; None:</span>
<span class="gi">+        if not self.connect_future.done():</span>
<span class="gi">+            self.connect_future.set_exception(StreamClosedError())</span>
<span class="gi">+        self._on_message(None)</span>
<span class="gi">+        self.tcp_client.close()</span>
<span class="gi">+        super().on_connection_close()</span>
<span class="gi">+</span>
<span class="gi">+    def on_ws_connection_close(</span>
<span class="gi">+        self, close_code: Optional[int] = None, close_reason: Optional[str] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.close_code = close_code</span>
<span class="gi">+        self.close_reason = close_reason</span>
<span class="gi">+        self.on_connection_close()</span>
<span class="gi">+</span>
<span class="gi">+    def _on_http_response(self, response: httpclient.HTTPResponse) -&gt; None:</span>
<span class="gi">+        if not self.connect_future.done():</span>
<span class="gi">+            if response.error:</span>
<span class="gi">+                self.connect_future.set_exception(response.error)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.connect_future.set_exception(</span>
<span class="gi">+                    WebSocketError(&quot;Non-websocket response&quot;)</span>
<span class="gi">+                )</span>

<span class="gd">-    def write_message(self, message: Union[str, bytes, Dict[str, Any]],</span>
<span class="gd">-        binary: bool=False) -&gt;&#39;Future[None]&#39;:</span>
<span class="gi">+    async def headers_received(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],</span>
<span class="gi">+        headers: httputil.HTTPHeaders,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert isinstance(start_line, httputil.ResponseStartLine)</span>
<span class="gi">+        if start_line.code != 101:</span>
<span class="gi">+            await super().headers_received(start_line, headers)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.io_loop.remove_timeout(self._timeout)</span>
<span class="gi">+            self._timeout = None</span>
<span class="gi">+</span>
<span class="gi">+        self.headers = headers</span>
<span class="gi">+        self.protocol = self.get_websocket_protocol()</span>
<span class="gi">+        self.protocol._process_server_headers(self.key, self.headers)</span>
<span class="gi">+        self.protocol.stream = self.connection.detach()</span>
<span class="gi">+</span>
<span class="gi">+        IOLoop.current().add_callback(self.protocol._receive_frame_loop)</span>
<span class="gi">+        self.protocol.start_pinging()</span>
<span class="gi">+</span>
<span class="gi">+        # Once we&#39;ve taken over the connection, clear the final callback</span>
<span class="gi">+        # we set on the http request.  This deactivates the error handling</span>
<span class="gi">+        # in simple_httpclient that would otherwise interfere with our</span>
<span class="gi">+        # ability to see exceptions.</span>
<span class="gi">+        self.final_callback = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        future_set_result_unless_cancelled(self.connect_future, self)</span>
<span class="gi">+</span>
<span class="gi">+    def write_message(</span>
<span class="gi">+        self, message: Union[str, bytes, Dict[str, Any]], binary: bool = False</span>
<span class="gi">+    ) -&gt; &quot;Future[None]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends a message to the WebSocket server.

<span class="w"> </span>        If the stream is closed, raises `WebSocketClosedError`.
<span class="gu">@@ -679,11 +1501,14 @@ class WebSocketClientConnection(simple_httpclient._HTTPConnection):</span>
<span class="w"> </span>           Exception raised on a closed stream changed from `.StreamClosedError`
<span class="w"> </span>           to `WebSocketClosedError`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def read_message(self, callback: Optional[Callable[[</span>
<span class="gd">-        &#39;Future[Union[None, str, bytes]]&#39;], None]]=None) -&gt;Awaitable[Union[</span>
<span class="gd">-        None, str, bytes]]:</span>
<span class="gi">+        if self.protocol is None:</span>
<span class="gi">+            raise WebSocketClosedError(&quot;Client connection has been closed&quot;)</span>
<span class="gi">+        return self.protocol.write_message(message, binary=binary)</span>
<span class="gi">+</span>
<span class="gi">+    def read_message(</span>
<span class="gi">+        self,</span>
<span class="gi">+        callback: Optional[Callable[[&quot;Future[Union[None, str, bytes]]&quot;], None]] = None,</span>
<span class="gi">+    ) -&gt; Awaitable[Union[None, str, bytes]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reads a message from the WebSocket server.

<span class="w"> </span>        If on_message_callback was specified at WebSocket
<span class="gu">@@ -694,9 +1519,25 @@ class WebSocketClientConnection(simple_httpclient._HTTPConnection):</span>
<span class="w"> </span>        is given it will be called with the future when it is
<span class="w"> </span>        ready.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def ping(self, data: bytes=b&#39;&#39;) -&gt;None:</span>
<span class="gi">+        awaitable = self.read_queue.get()</span>
<span class="gi">+        if callback is not None:</span>
<span class="gi">+            self.io_loop.add_future(asyncio.ensure_future(awaitable), callback)</span>
<span class="gi">+        return awaitable</span>
<span class="gi">+</span>
<span class="gi">+    def on_message(self, message: Union[str, bytes]) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        return self._on_message(message)</span>
<span class="gi">+</span>
<span class="gi">+    def _on_message(</span>
<span class="gi">+        self, message: Union[None, str, bytes]</span>
<span class="gi">+    ) -&gt; Optional[Awaitable[None]]:</span>
<span class="gi">+        if self._on_message_callback:</span>
<span class="gi">+            self._on_message_callback(message)</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.read_queue.put(message)</span>
<span class="gi">+</span>
<span class="gi">+    def ping(self, data: bytes = b&quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Send ping frame to the remote end.

<span class="w"> </span>        The data argument allows a small amount of data (up to 125
<span class="gu">@@ -710,26 +1551,51 @@ class WebSocketClientConnection(simple_httpclient._HTTPConnection):</span>
<span class="w"> </span>        .. versionadded:: 5.1

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        data = utf8(data)</span>
<span class="gi">+        if self.protocol is None:</span>
<span class="gi">+            raise WebSocketClosedError()</span>
<span class="gi">+        self.protocol.write_ping(data)</span>
<span class="gi">+</span>
<span class="gi">+    def on_pong(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gi">+    def on_ping(self, data: bytes) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_websocket_protocol(self) -&gt; WebSocketProtocol:</span>
<span class="gi">+        return WebSocketProtocol13(self, mask_outgoing=True, params=self.params)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def selected_subprotocol(self) -&gt;Optional[str]:</span>
<span class="gi">+    def selected_subprotocol(self) -&gt; Optional[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The subprotocol selected by the server.

<span class="w"> </span>        .. versionadded:: 5.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def websocket_connect(url: Union[str, httpclient.HTTPRequest], callback:</span>
<span class="gd">-    Optional[Callable[[&#39;Future[WebSocketClientConnection]&#39;], None]]=None,</span>
<span class="gd">-    connect_timeout: Optional[float]=None, on_message_callback: Optional[</span>
<span class="gd">-    Callable[[Union[None, str, bytes]], None]]=None, compression_options:</span>
<span class="gd">-    Optional[Dict[str, Any]]=None, ping_interval: Optional[float]=None,</span>
<span class="gd">-    ping_timeout: Optional[float]=None, max_message_size: int=</span>
<span class="gd">-    _default_max_message_size, subprotocols: Optional[List[str]]=None,</span>
<span class="gd">-    resolver: Optional[Resolver]=None</span>
<span class="gd">-    ) -&gt;&#39;Awaitable[WebSocketClientConnection]&#39;:</span>
<span class="gi">+        return self.protocol.selected_subprotocol</span>
<span class="gi">+</span>
<span class="gi">+    def log_exception(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+        value: Optional[BaseException],</span>
<span class="gi">+        tb: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert typ is not None</span>
<span class="gi">+        assert value is not None</span>
<span class="gi">+        app_log.error(&quot;Uncaught exception %s&quot;, value, exc_info=(typ, value, tb))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def websocket_connect(</span>
<span class="gi">+    url: Union[str, httpclient.HTTPRequest],</span>
<span class="gi">+    callback: Optional[Callable[[&quot;Future[WebSocketClientConnection]&quot;], None]] = None,</span>
<span class="gi">+    connect_timeout: Optional[float] = None,</span>
<span class="gi">+    on_message_callback: Optional[Callable[[Union[None, str, bytes]], None]] = None,</span>
<span class="gi">+    compression_options: Optional[Dict[str, Any]] = None,</span>
<span class="gi">+    ping_interval: Optional[float] = None,</span>
<span class="gi">+    ping_timeout: Optional[float] = None,</span>
<span class="gi">+    max_message_size: int = _default_max_message_size,</span>
<span class="gi">+    subprotocols: Optional[List[str]] = None,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+) -&gt; &quot;Awaitable[WebSocketClientConnection]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Client-side websocket support.

<span class="w"> </span>    Takes a url and returns a Future whose result is a
<span class="gu">@@ -776,4 +1642,28 @@ def websocket_connect(url: Union[str, httpclient.HTTPRequest], callback:</span>
<span class="w"> </span>    .. versionchanged:: 6.3
<span class="w"> </span>       Added the ``resolver`` argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(url, httpclient.HTTPRequest):</span>
<span class="gi">+        assert connect_timeout is None</span>
<span class="gi">+        request = url</span>
<span class="gi">+        # Copy and convert the headers dict/object (see comments in</span>
<span class="gi">+        # AsyncHTTPClient.fetch)</span>
<span class="gi">+        request.headers = httputil.HTTPHeaders(request.headers)</span>
<span class="gi">+    else:</span>
<span class="gi">+        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)</span>
<span class="gi">+    request = cast(</span>
<span class="gi">+        httpclient.HTTPRequest,</span>
<span class="gi">+        httpclient._RequestProxy(request, httpclient.HTTPRequest._DEFAULTS),</span>
<span class="gi">+    )</span>
<span class="gi">+    conn = WebSocketClientConnection(</span>
<span class="gi">+        request,</span>
<span class="gi">+        on_message_callback=on_message_callback,</span>
<span class="gi">+        compression_options=compression_options,</span>
<span class="gi">+        ping_interval=ping_interval,</span>
<span class="gi">+        ping_timeout=ping_timeout,</span>
<span class="gi">+        max_message_size=max_message_size,</span>
<span class="gi">+        subprotocols=subprotocols,</span>
<span class="gi">+        resolver=resolver,</span>
<span class="gi">+    )</span>
<span class="gi">+    if callback is not None:</span>
<span class="gi">+        IOLoop.current().add_future(conn.connect_future, callback)</span>
<span class="gi">+    return conn.connect_future</span>
<span class="gh">diff --git a/tornado/wsgi.py b/tornado/wsgi.py</span>
<span class="gh">index 227b0d77..32641be3 100644</span>
<span class="gd">--- a/tornado/wsgi.py</span>
<span class="gi">+++ b/tornado/wsgi.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright 2009 Facebook</span>
<span class="gi">+#</span>
<span class="gi">+# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="gi">+# not use this file except in compliance with the License. You may obtain</span>
<span class="gi">+# a copy of the License at</span>
<span class="gi">+#</span>
<span class="gi">+#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="gi">+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="gi">+# License for the specific language governing permissions and limitations</span>
<span class="gi">+# under the License.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;WSGI support for the Tornado web framework.

<span class="w"> </span>WSGI is the Python standard for web servers, and allows for interoperability
<span class="gu">@@ -11,25 +26,38 @@ the Tornado `.HTTPServer` and cannot be used in a generic WSGI</span>
<span class="w"> </span>container.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import concurrent.futures
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>import tornado
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from tornado.concurrent import dummy_executor
<span class="w"> </span>from tornado import escape
<span class="w"> </span>from tornado import httputil
<span class="w"> </span>from tornado.ioloop import IOLoop
<span class="w"> </span>from tornado.log import access_log
<span class="gi">+</span>
<span class="w"> </span>from typing import List, Tuple, Optional, Callable, Any, Dict, Text
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from typing import Type</span>
<span class="gd">-    from _typeshed.wsgi import WSGIApplication as WSGIAppType</span>
<span class="gi">+    from typing import Type  # noqa: F401</span>
<span class="gi">+    from _typeshed.wsgi import WSGIApplication as WSGIAppType  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# PEP 3333 specifies that WSGI on python 3 generally deals with byte strings</span>
<span class="gi">+# that are smuggled inside objects of type unicode (via the latin1 encoding).</span>
<span class="gi">+# This function is like those in the tornado.escape module, but defined</span>
<span class="gi">+# here to minimize the temptation to use it in non-wsgi contexts.</span>
<span class="gi">+def to_wsgi_str(s: bytes) -&gt; str:</span>
<span class="gi">+    assert isinstance(s, bytes)</span>
<span class="gi">+    return s.decode(&quot;latin1&quot;)</span>


<span class="w"> </span>class WSGIContainer(object):
<span class="gd">-    &quot;&quot;&quot;Makes a WSGI-compatible application runnable on Tornado&#39;s HTTP server.</span>
<span class="gi">+    r&quot;&quot;&quot;Makes a WSGI-compatible application runnable on Tornado&#39;s HTTP server.</span>

<span class="w"> </span>    .. warning::

<span class="gu">@@ -56,7 +84,7 @@ class WSGIContainer(object):</span>
<span class="w"> </span>            status = &quot;200 OK&quot;
<span class="w"> </span>            response_headers = [(&quot;Content-type&quot;, &quot;text/plain&quot;)]
<span class="w"> </span>            start_response(status, response_headers)
<span class="gd">-            return [b&quot;Hello world!\\n&quot;]</span>
<span class="gi">+            return [b&quot;Hello world!\n&quot;]</span>

<span class="w"> </span>        async def main():
<span class="w"> </span>            container = tornado.wsgi.WSGIContainer(simple_app)
<span class="gu">@@ -94,21 +122,147 @@ class WSGIContainer(object):</span>
<span class="w"> </span>       is deprecated and will change in Tornado 7.0 to use a thread pool by default.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, wsgi_application: &#39;WSGIAppType&#39;, executor: Optional[</span>
<span class="gd">-        concurrent.futures.Executor]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        wsgi_application: &quot;WSGIAppType&quot;,</span>
<span class="gi">+        executor: Optional[concurrent.futures.Executor] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.wsgi_application = wsgi_application
<span class="w"> </span>        self.executor = dummy_executor if executor is None else executor

<span class="gd">-    def __call__(self, request: httputil.HTTPServerRequest) -&gt;None:</span>
<span class="gi">+    def __call__(self, request: httputil.HTTPServerRequest) -&gt; None:</span>
<span class="w"> </span>        IOLoop.current().spawn_callback(self.handle_request, request)

<span class="gd">-    def environ(self, request: httputil.HTTPServerRequest) -&gt;Dict[Text, Any]:</span>
<span class="gi">+    async def handle_request(self, request: httputil.HTTPServerRequest) -&gt; None:</span>
<span class="gi">+        data = {}  # type: Dict[str, Any]</span>
<span class="gi">+        response = []  # type: List[bytes]</span>
<span class="gi">+</span>
<span class="gi">+        def start_response(</span>
<span class="gi">+            status: str,</span>
<span class="gi">+            headers: List[Tuple[str, str]],</span>
<span class="gi">+            exc_info: Optional[</span>
<span class="gi">+                Tuple[</span>
<span class="gi">+                    &quot;Optional[Type[BaseException]]&quot;,</span>
<span class="gi">+                    Optional[BaseException],</span>
<span class="gi">+                    Optional[TracebackType],</span>
<span class="gi">+                ]</span>
<span class="gi">+            ] = None,</span>
<span class="gi">+        ) -&gt; Callable[[bytes], Any]:</span>
<span class="gi">+            data[&quot;status&quot;] = status</span>
<span class="gi">+            data[&quot;headers&quot;] = headers</span>
<span class="gi">+            return response.append</span>
<span class="gi">+</span>
<span class="gi">+        loop = IOLoop.current()</span>
<span class="gi">+        app_response = await loop.run_in_executor(</span>
<span class="gi">+            self.executor,</span>
<span class="gi">+            self.wsgi_application,</span>
<span class="gi">+            self.environ(request),</span>
<span class="gi">+            start_response,</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            app_response_iter = iter(app_response)</span>
<span class="gi">+</span>
<span class="gi">+            def next_chunk() -&gt; Optional[bytes]:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return next(app_response_iter)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    # StopIteration is special and is not allowed to pass through</span>
<span class="gi">+                    # coroutines normally.</span>
<span class="gi">+                    return None</span>
<span class="gi">+</span>
<span class="gi">+            while True:</span>
<span class="gi">+                chunk = await loop.run_in_executor(self.executor, next_chunk)</span>
<span class="gi">+                if chunk is None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                response.append(chunk)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if hasattr(app_response, &quot;close&quot;):</span>
<span class="gi">+                app_response.close()  # type: ignore</span>
<span class="gi">+        body = b&quot;&quot;.join(response)</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            raise Exception(&quot;WSGI app did not call start_response&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        status_code_str, reason = data[&quot;status&quot;].split(&quot; &quot;, 1)</span>
<span class="gi">+        status_code = int(status_code_str)</span>
<span class="gi">+        headers = data[&quot;headers&quot;]  # type: List[Tuple[str, str]]</span>
<span class="gi">+        header_set = set(k.lower() for (k, v) in headers)</span>
<span class="gi">+        body = escape.utf8(body)</span>
<span class="gi">+        if status_code != 304:</span>
<span class="gi">+            if &quot;content-length&quot; not in header_set:</span>
<span class="gi">+                headers.append((&quot;Content-Length&quot;, str(len(body))))</span>
<span class="gi">+            if &quot;content-type&quot; not in header_set:</span>
<span class="gi">+                headers.append((&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;))</span>
<span class="gi">+        if &quot;server&quot; not in header_set:</span>
<span class="gi">+            headers.append((&quot;Server&quot;, &quot;TornadoServer/%s&quot; % tornado.version))</span>
<span class="gi">+</span>
<span class="gi">+        start_line = httputil.ResponseStartLine(&quot;HTTP/1.1&quot;, status_code, reason)</span>
<span class="gi">+        header_obj = httputil.HTTPHeaders()</span>
<span class="gi">+        for key, value in headers:</span>
<span class="gi">+            header_obj.add(key, value)</span>
<span class="gi">+        assert request.connection is not None</span>
<span class="gi">+        request.connection.write_headers(start_line, header_obj, chunk=body)</span>
<span class="gi">+        request.connection.finish()</span>
<span class="gi">+        self._log(status_code, request)</span>
<span class="gi">+</span>
<span class="gi">+    def environ(self, request: httputil.HTTPServerRequest) -&gt; Dict[Text, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a `tornado.httputil.HTTPServerRequest` to a WSGI environment.

<span class="w"> </span>        .. versionchanged:: 6.3
<span class="w"> </span>           No longer a static method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hostport = request.host.split(&quot;:&quot;)</span>
<span class="gi">+        if len(hostport) == 2:</span>
<span class="gi">+            host = hostport[0]</span>
<span class="gi">+            port = int(hostport[1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            host = request.host</span>
<span class="gi">+            port = 443 if request.protocol == &quot;https&quot; else 80</span>
<span class="gi">+        environ = {</span>
<span class="gi">+            &quot;REQUEST_METHOD&quot;: request.method,</span>
<span class="gi">+            &quot;SCRIPT_NAME&quot;: &quot;&quot;,</span>
<span class="gi">+            &quot;PATH_INFO&quot;: to_wsgi_str(</span>
<span class="gi">+                escape.url_unescape(request.path, encoding=None, plus=False)</span>
<span class="gi">+            ),</span>
<span class="gi">+            &quot;QUERY_STRING&quot;: request.query,</span>
<span class="gi">+            &quot;REMOTE_ADDR&quot;: request.remote_ip,</span>
<span class="gi">+            &quot;SERVER_NAME&quot;: host,</span>
<span class="gi">+            &quot;SERVER_PORT&quot;: str(port),</span>
<span class="gi">+            &quot;SERVER_PROTOCOL&quot;: request.version,</span>
<span class="gi">+            &quot;wsgi.version&quot;: (1, 0),</span>
<span class="gi">+            &quot;wsgi.url_scheme&quot;: request.protocol,</span>
<span class="gi">+            &quot;wsgi.input&quot;: BytesIO(escape.utf8(request.body)),</span>
<span class="gi">+            &quot;wsgi.errors&quot;: sys.stderr,</span>
<span class="gi">+            &quot;wsgi.multithread&quot;: self.executor is not dummy_executor,</span>
<span class="gi">+            &quot;wsgi.multiprocess&quot;: True,</span>
<span class="gi">+            &quot;wsgi.run_once&quot;: False,</span>
<span class="gi">+        }</span>
<span class="gi">+        if &quot;Content-Type&quot; in request.headers:</span>
<span class="gi">+            environ[&quot;CONTENT_TYPE&quot;] = request.headers.pop(&quot;Content-Type&quot;)</span>
<span class="gi">+        if &quot;Content-Length&quot; in request.headers:</span>
<span class="gi">+            environ[&quot;CONTENT_LENGTH&quot;] = request.headers.pop(&quot;Content-Length&quot;)</span>
<span class="gi">+        for key, value in request.headers.items():</span>
<span class="gi">+            environ[&quot;HTTP_&quot; + key.replace(&quot;-&quot;, &quot;_&quot;).upper()] = value</span>
<span class="gi">+        return environ</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, status_code: int, request: httputil.HTTPServerRequest) -&gt; None:</span>
<span class="gi">+        if status_code &lt; 400:</span>
<span class="gi">+            log_method = access_log.info</span>
<span class="gi">+        elif status_code &lt; 500:</span>
<span class="gi">+            log_method = access_log.warning</span>
<span class="gi">+        else:</span>
<span class="gi">+            log_method = access_log.error</span>
<span class="gi">+        request_time = 1000.0 * request.request_time()</span>
<span class="gi">+        assert request.method is not None</span>
<span class="gi">+        assert request.uri is not None</span>
<span class="gi">+        summary = (</span>
<span class="gi">+            request.method  # type: ignore[operator]</span>
<span class="gi">+            + &quot; &quot;</span>
<span class="gi">+            + request.uri</span>
<span class="gi">+            + &quot; (&quot;</span>
<span class="gi">+            + request.remote_ip</span>
<span class="gi">+            + &quot;)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        log_method(&quot;%d %s %.2fms&quot;, status_code, summary, request_time)</span>


<span class="w"> </span>HTTPRequest = httputil.HTTPServerRequest
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>