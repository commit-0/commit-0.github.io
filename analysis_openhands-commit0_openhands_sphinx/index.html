
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands sphinx - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-sphinx" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands sphinx
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-sphinx"><strong>OpenHands</strong>: sphinx</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:16: in &lt;module&gt;
    from sphinx.testing.util import _clean_up_global_state
E   ImportError: cannot import name &#39;_clean_up_global_state&#39; from &#39;sphinx.testing.util&#39; (/testbed/sphinx/testing/util.py)
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/sphinx/io.py b/sphinx/io.py</span>
<span class="gh">index 7308bfa50..8296dca8b 100644</span>
<span class="gd">--- a/sphinx/io.py</span>
<span class="gi">+++ b/sphinx/io.py</span>
<span class="gu">@@ -43,7 +43,9 @@ class SphinxBaseReader(standalone.Reader):</span>
<span class="w"> </span>        Creates a new document object which has a special reporter object good
<span class="w"> </span>        for logging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        document = super().new_document()</span>
<span class="gi">+        document.reporter = LoggingReporter.from_reporter(document.reporter)</span>
<span class="gi">+        return document</span>

<span class="w"> </span>class SphinxStandaloneReader(SphinxBaseReader):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -52,7 +54,9 @@ class SphinxStandaloneReader(SphinxBaseReader):</span>

<span class="w"> </span>    def read_source(self, env: BuildEnvironment) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Read content from source and do post-process.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self.source, SphinxFileInput):</span>
<span class="gi">+            self.source.set_fs_encoding(env.fs_encoding)</span>
<span class="gi">+        return super().read()</span>

<span class="w"> </span>class SphinxI18nReader(SphinxBaseReader):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -69,11 +73,28 @@ class SphinxDummyWriter(UnfilteredWriter):</span>

<span class="w"> </span>def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -&gt; Any:
<span class="w"> </span>    &quot;&quot;&quot;Bypass source object as is to cheat Publisher.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return source</span>
<span class="gi">+</span>
<span class="gi">+def create_publisher(app: Sphinx | None=None, doctree: nodes.document | None=None) -&gt; Publisher:</span>
<span class="gi">+    &quot;&quot;&quot;Create and return a publisher object.&quot;&quot;&quot;</span>
<span class="gi">+    pub = Publisher(reader=None,</span>
<span class="gi">+                   parser=None,</span>
<span class="gi">+                   writer=SphinxDummyWriter(),</span>
<span class="gi">+                   source_class=SphinxDummySourceClass,</span>
<span class="gi">+                   destination=NullOutput())</span>
<span class="gi">+    pub.reader = SphinxStandaloneReader(app)</span>
<span class="gi">+    pub.parser = app.registry.create_source_parser(app, &#39;restructuredtext&#39;)</span>
<span class="gi">+    pub.document = doctree</span>
<span class="gi">+    pub.settings = pub.get_settings(traceback=True, warning_stream=None)</span>
<span class="gi">+    return pub</span>

<span class="w"> </span>class SphinxFileInput(FileInput):
<span class="w"> </span>    &quot;&quot;&quot;A basic FileInput for Sphinx.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
<span class="w"> </span>        kwargs[&#39;error_handler&#39;] = &#39;sphinx&#39;
<span class="gd">-        super().__init__(*args, **kwargs)</span>
\ No newline at end of file
<span class="gi">+        super().__init__(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def set_fs_encoding(self, fs_encoding: str) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Set the filesystem encoding.&quot;&quot;&quot;</span>
<span class="gi">+        self.fs_encoding = fs_encoding</span>
\ No newline at end of file
<span class="gh">diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py</span>
<span class="gh">index 06661fc3f..3df479e75 100644</span>
<span class="gd">--- a/sphinx/pycode/ast.py</span>
<span class="gi">+++ b/sphinx/pycode/ast.py</span>
<span class="gu">@@ -6,15 +6,26 @@ OPERATORS: dict[type[ast.AST], str] = {ast.Add: &#39;+&#39;, ast.And: &#39;and&#39;, ast.BitAnd:</span>

<span class="w"> </span>def unparse(node: ast.AST | None, code: str=&#39;&#39;) -&gt; str | None:
<span class="w"> </span>    &quot;&quot;&quot;Unparse an AST to string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    visitor = _UnparseVisitor(code)</span>
<span class="gi">+    return visitor.visit(node)</span>

<span class="w"> </span>class _UnparseVisitor(ast.NodeVisitor):

<span class="w"> </span>    def __init__(self, code: str=&#39;&#39;) -&gt; None:
<span class="w"> </span>        self.code = code
<span class="gi">+</span>
<span class="gi">+    def _visit_op(self, node: ast.AST) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Helper for operator nodes.&quot;&quot;&quot;</span>
<span class="gi">+        return OPERATORS[type(node)]</span>
<span class="gi">+</span>
<span class="w"> </span>    for _op in OPERATORS:
<span class="w"> </span>        locals()[f&#39;visit_{_op.__name__}&#39;] = _visit_op

<span class="w"> </span>    def _visit_arg_with_default(self, arg: ast.arg, default: ast.AST | None) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Unparse a single argument to a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        result = arg.arg</span>
<span class="gi">+        if default is not None:</span>
<span class="gi">+            result += &#39;=&#39; + self.visit(default)</span>
<span class="gi">+        return result</span>
\ No newline at end of file
<span class="gh">diff --git a/sphinx/roles.py b/sphinx/roles.py</span>
<span class="gh">index 39797d155..9e7b565c5 100644</span>
<span class="gd">--- a/sphinx/roles.py</span>
<span class="gi">+++ b/sphinx/roles.py</span>
<span class="gu">@@ -60,7 +60,14 @@ class XRefRole(ReferenceRole):</span>
<span class="w"> </span>        reference node and must return a new (or the same) ``(title, target)``
<span class="w"> </span>        tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not has_explicit_title and self.fix_parens:</span>
<span class="gi">+            if target.endswith(&#39;()&#39;):</span>
<span class="gi">+                title = title[:-2]</span>
<span class="gi">+            if target.endswith(&#39;[]&#39;):</span>
<span class="gi">+                title = title[:-2]</span>
<span class="gi">+        if self.lowercase:</span>
<span class="gi">+            target = target.lower()</span>
<span class="gi">+        return title, target</span>

<span class="w"> </span>    def result_nodes(self, document: nodes.document, env: BuildEnvironment, node: Element, is_ref: bool) -&gt; tuple[list[Node], list[system_message]]:
<span class="w"> </span>        &quot;&quot;&quot;Called before returning the finished nodes.  *node* is the reference
<span class="gu">@@ -68,30 +75,164 @@ class XRefRole(ReferenceRole):</span>
<span class="w"> </span>        This method can add other nodes and must return a ``(nodes, messages)``
<span class="w"> </span>        tuple (the usual return value of a role function).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [node], []</span>

<span class="w"> </span>class AnyXRefRole(XRefRole):
<span class="w"> </span>    pass

<span class="w"> </span>class PEP(ReferenceRole):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target_id = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        entries = [(&#39;single&#39;, _(&#39;Python Enhancement Proposals; PEP %s&#39;) % self.target,</span>
<span class="gi">+                   target_id, &#39;&#39;, None)]</span>
<span class="gi">+</span>
<span class="gi">+        index = addnodes.index(entries=entries)</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[target_id])</span>
<span class="gi">+        self.inliner.document.note_explicit_target(target)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            pepnum = int(self.target)</span>
<span class="gi">+            ref = self.inliner.document.settings.pep_base_url + &#39;pep-%04d&#39; % pepnum</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            msg = self.inliner.reporter.error(&#39;invalid PEP number %s&#39; % self.target,</span>
<span class="gi">+                                            line=self.lineno)</span>
<span class="gi">+            prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)</span>
<span class="gi">+            return [prb], [msg]</span>
<span class="gi">+</span>
<span class="gi">+        if not self.has_explicit_title:</span>
<span class="gi">+            title = &quot;PEP &quot; + self.title</span>
<span class="gi">+            self.title = title</span>
<span class="gi">+</span>
<span class="gi">+        reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False, refuri=ref,</span>
<span class="gi">+                                  classes=[&#39;pep&#39;])</span>
<span class="gi">+        if self.has_explicit_title:</span>
<span class="gi">+            reference += nodes.Text(self.title)</span>
<span class="gi">+        else:</span>
<span class="gi">+            reference += nodes.Text(title)</span>
<span class="gi">+</span>
<span class="gi">+        return [index, target, reference], []</span>

<span class="w"> </span>class RFC(ReferenceRole):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target_id = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        entries = [(&#39;single&#39;, &#39;RFC; RFC %s&#39; % self.target, target_id, &#39;&#39;, None)]</span>
<span class="gi">+</span>
<span class="gi">+        index = addnodes.index(entries=entries)</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[target_id])</span>
<span class="gi">+        self.inliner.document.note_explicit_target(target)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            rfcnum = int(self.target)</span>
<span class="gi">+            ref = self.inliner.document.settings.rfc_base_url + &#39;rfc%d.txt&#39; % rfcnum</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            msg = self.inliner.reporter.error(&#39;invalid RFC number %s&#39; % self.target,</span>
<span class="gi">+                                            line=self.lineno)</span>
<span class="gi">+            prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)</span>
<span class="gi">+            return [prb], [msg]</span>
<span class="gi">+</span>
<span class="gi">+        if not self.has_explicit_title:</span>
<span class="gi">+            title = &quot;RFC &quot; + self.title</span>
<span class="gi">+            self.title = title</span>
<span class="gi">+</span>
<span class="gi">+        reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False, refuri=ref,</span>
<span class="gi">+                                  classes=[&#39;rfc&#39;])</span>
<span class="gi">+        if self.has_explicit_title:</span>
<span class="gi">+            reference += nodes.Text(self.title)</span>
<span class="gi">+        else:</span>
<span class="gi">+            reference += nodes.Text(title)</span>
<span class="gi">+</span>
<span class="gi">+        return [index, target, reference], []</span>

<span class="w"> </span>class GUILabel(SphinxRole):
<span class="w"> </span>    amp_re = re.compile(&#39;(?&lt;!&amp;)&amp;(?![&amp;\\s])&#39;)

<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        text = self.text.replace(&#39;&amp;&amp;&#39;, &#39;\x00&#39;)</span>
<span class="gi">+        text = self.amp_re.sub(&#39;&#39;, text)</span>
<span class="gi">+        text = text.replace(&#39;\x00&#39;, &#39;&amp;&#39;)</span>
<span class="gi">+        span = nodes.inline(self.rawtext, text, classes=[&#39;guilabel&#39;])</span>
<span class="gi">+        return [span], []</span>
<span class="gi">+</span>
<span class="w"> </span>class MenuSelection(GUILabel):
<span class="w"> </span>    BULLET_CHARACTER = &#39;‣&#39;

<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        text = self.text.replace(&#39;&amp;&amp;&#39;, &#39;\x00&#39;)</span>
<span class="gi">+        text = self.amp_re.sub(&#39;&#39;, text)</span>
<span class="gi">+        text = text.replace(&#39;\x00&#39;, &#39;&amp;&#39;)</span>
<span class="gi">+        span = nodes.inline(self.rawtext, &#39;&#39;, classes=[&#39;menuselection&#39;])</span>
<span class="gi">+        for item in ws_re.split(text):</span>
<span class="gi">+            span += nodes.Text(item)</span>
<span class="gi">+            span += nodes.Text(self.BULLET_CHARACTER)</span>
<span class="gi">+        span.pop()</span>
<span class="gi">+        return [span], []</span>
<span class="gi">+</span>
<span class="w"> </span>class EmphasizedLiteral(SphinxRole):
<span class="w"> </span>    parens_re = re.compile(&#39;(\\\\\\\\|\\\\{|\\\\}|{|})&#39;)

<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        text = self.text.replace(&#39;\\&#39;, &#39;\\\\&#39;)</span>
<span class="gi">+        text = self.parens_re.sub(r&#39;\\\1&#39;, text)</span>
<span class="gi">+        return [nodes.literal(self.rawtext, text, classes=[&#39;file&#39;])], []</span>
<span class="gi">+</span>
<span class="w"> </span>class Abbreviation(SphinxRole):
<span class="w"> </span>    abbr_re = re.compile(&#39;\\((.*)\\)$&#39;, re.DOTALL)

<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        text = self.text</span>
<span class="gi">+        m = self.abbr_re.search(text)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            text = text[:m.start()].strip()</span>
<span class="gi">+            expl = m.group(1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            expl = None</span>
<span class="gi">+        abbr = nodes.abbreviation(self.rawtext, text)</span>
<span class="gi">+        if expl:</span>
<span class="gi">+            abbr[&#39;explanation&#39;] = expl</span>
<span class="gi">+        return [abbr], []</span>
<span class="gi">+</span>
<span class="gi">+def set_classes(options: dict[str, Any]) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Set &#39;classes&#39; key in options dict.&quot;&quot;&quot;</span>
<span class="gi">+    if &#39;class&#39; in options:</span>
<span class="gi">+        classes = options.get(&#39;classes&#39;, [])</span>
<span class="gi">+        classes.extend(options[&#39;class&#39;])</span>
<span class="gi">+        del options[&#39;class&#39;]</span>
<span class="gi">+        options[&#39;classes&#39;] = classes</span>
<span class="gi">+</span>
<span class="gi">+def code_role(typ: str, rawtext: str, text: str, lineno: int, inliner: docutils.parsers.rst.states.Inliner, options: dict[str, Any]={}, content: Sequence[str]=[]) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+    &quot;&quot;&quot;Role for code samples.&quot;&quot;&quot;</span>
<span class="gi">+    set_classes(options)</span>
<span class="gi">+    classes = [&#39;code&#39;]</span>
<span class="gi">+    if &#39;classes&#39; in options:</span>
<span class="gi">+        classes.extend(options[&#39;classes&#39;])</span>
<span class="gi">+    if &#39;language&#39; in options:</span>
<span class="gi">+        classes.append(&#39;highlight&#39;)</span>
<span class="gi">+        classes.append(options[&#39;language&#39;])</span>
<span class="gi">+    node = nodes.literal(rawtext, utils.unescape(text), classes=classes)</span>
<span class="gi">+    return [node], []</span>
<span class="gi">+</span>
<span class="w"> </span>class Manpage(ReferenceRole):
<span class="w"> </span>    _manpage_re = re.compile(&#39;^(?P&lt;path&gt;(?P&lt;page&gt;.+)[(.](?P&lt;section&gt;[1-9]\\w*)?\\)?)$&#39;)
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        matched = self._manpage_re.match(self.target)</span>
<span class="gi">+        if not matched:</span>
<span class="gi">+            msg = self.inliner.reporter.error(&#39;invalid manpage reference %r&#39; % self.target,</span>
<span class="gi">+                                            line=self.lineno)</span>
<span class="gi">+            prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)</span>
<span class="gi">+            return [prb], [msg]</span>
<span class="gi">+</span>
<span class="gi">+        page = matched.group(&#39;page&#39;)</span>
<span class="gi">+        section = matched.group(&#39;section&#39;)</span>
<span class="gi">+        ref = self.inliner.document.settings.manpages_url % {&#39;page&#39;: page, &#39;section&#39;: section}</span>
<span class="gi">+</span>
<span class="gi">+        if not self.has_explicit_title:</span>
<span class="gi">+            title = matched.group(&#39;path&#39;)</span>
<span class="gi">+            self.title = title</span>
<span class="gi">+</span>
<span class="gi">+        reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False, refuri=ref,</span>
<span class="gi">+                                  classes=[&#39;manpage&#39;])</span>
<span class="gi">+        reference += nodes.Text(self.title)</span>
<span class="gi">+        return [reference], []</span>
<span class="w"> </span>code_role.options = {&#39;class&#39;: docutils.parsers.rst.directives.class_option, &#39;language&#39;: docutils.parsers.rst.directives.unchanged}
<span class="w"> </span>specific_docroles: dict[str, RoleFunction] = {&#39;download&#39;: XRefRole(nodeclass=addnodes.download_reference), &#39;any&#39;: AnyXRefRole(warn_dangling=True), &#39;pep&#39;: PEP(), &#39;rfc&#39;: RFC(), &#39;guilabel&#39;: GUILabel(), &#39;menuselection&#39;: MenuSelection(), &#39;file&#39;: EmphasizedLiteral(), &#39;samp&#39;: EmphasizedLiteral(), &#39;abbr&#39;: Abbreviation(), &#39;manpage&#39;: Manpage()}
\ No newline at end of file
<span class="gh">diff --git a/sphinx/util/console.py b/sphinx/util/console.py</span>
<span class="gh">index 586261b24..d94a62ec9 100644</span>
<span class="gd">--- a/sphinx/util/console.py</span>
<span class="gi">+++ b/sphinx/util/console.py</span>
<span class="gu">@@ -18,13 +18,26 @@ _ansi_re: Final[re.Pattern[str]] = re.compile(_CSI + &quot;\n    (?:\n      (?:\\d+;)</span>
<span class="w"> </span>&#39;Pattern matching ANSI CSI colors (SGR) and erase line (EL) sequences.\n\nSee :func:`strip_escape_sequences` for details.\n&#39;
<span class="w"> </span>codes: dict[str, str] = {}

<span class="gi">+def color_terminal() -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Return True if the terminal supports colors.&quot;&quot;&quot;</span>
<span class="gi">+    if not hasattr(sys.stdout, &#39;isatty&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if not sys.stdout.isatty():</span>
<span class="gi">+        return False</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        return COLORAMA_AVAILABLE</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="w"> </span>def terminal_safe(s: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Safely encode a string for printing to the terminal.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.encode(&#39;ascii&#39;, &#39;replace&#39;).decode(&#39;ascii&#39;)</span>

<span class="w"> </span>def get_terminal_width() -&gt; int:
<span class="w"> </span>    &quot;&quot;&quot;Return the width of the terminal in columns.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return shutil.get_terminal_size().columns</span>
<span class="gi">+    except (AttributeError, ValueError):</span>
<span class="gi">+        return 80</span>
<span class="w"> </span>_tw: int = get_terminal_width()

<span class="w"> </span>def strip_colors(s: str) -&gt; str:
<span class="gu">@@ -37,7 +50,25 @@ def strip_colors(s: str) -&gt; str:</span>

<span class="w"> </span>    .. seealso:: :func:`strip_escape_sequences`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ansi_color_re.sub(&#39;&#39;, s)</span>
<span class="gi">+</span>
<span class="gi">+def colorize(name: str, text: str, input_mode: bool=False) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Return *text* in ANSI colors.&quot;&quot;&quot;</span>
<span class="gi">+    if not sys.stdout.isatty() or not codes:</span>
<span class="gi">+        return text</span>
<span class="gi">+    if input_mode and sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        return text</span>
<span class="gi">+    return codes[name] + text + codes[&#39;reset&#39;]</span>
<span class="gi">+</span>
<span class="gi">+def create_color_func(name: str) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Create a function for colorizing text with the given color name.&quot;&quot;&quot;</span>
<span class="gi">+    def color_func(text: str, input_mode: bool=False) -&gt; str:</span>
<span class="gi">+        if not sys.stdout.isatty() or not codes:</span>
<span class="gi">+            return text</span>
<span class="gi">+        if input_mode and sys.platform == &#39;win32&#39;:</span>
<span class="gi">+            return text</span>
<span class="gi">+        return codes[name] + text + codes[&#39;reset&#39;]</span>
<span class="gi">+    globals()[name] = color_func</span>

<span class="w"> </span>def strip_escape_sequences(text: str, /) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Remove the ANSI CSI colors and &quot;erase in line&quot; sequences.
<span class="gu">@@ -59,7 +90,7 @@ def strip_escape_sequences(text: str, /) -&gt; str:</span>

<span class="w"> </span>    __ https://en.wikipedia.org/wiki/ANSI_escape_code
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ansi_re.sub(&#39;&#39;, text)</span>
<span class="w"> </span>_attrs = {&#39;reset&#39;: &#39;39;49;00m&#39;, &#39;bold&#39;: &#39;01m&#39;, &#39;faint&#39;: &#39;02m&#39;, &#39;standout&#39;: &#39;03m&#39;, &#39;underline&#39;: &#39;04m&#39;, &#39;blink&#39;: &#39;05m&#39;}
<span class="w"> </span>for __name, __value in _attrs.items():
<span class="w"> </span>    codes[__name] = &#39;\x1b[&#39; + __value
<span class="gh">diff --git a/sphinx/util/i18n.py b/sphinx/util/i18n.py</span>
<span class="gh">index 9c55976a6..27c0074bf 100644</span>
<span class="gd">--- a/sphinx/util/i18n.py</span>
<span class="gi">+++ b/sphinx/util/i18n.py</span>
<span class="gu">@@ -55,6 +55,32 @@ class CatalogRepository:</span>

<span class="w"> </span>def docname_to_domain(docname: str, compaction: bool | str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Convert docname to domain for catalogs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not compaction:</span>
<span class="gi">+        return docname</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(compaction, str):</span>
<span class="gi">+        return compaction</span>
<span class="gi">+</span>
<span class="gi">+    parts = [part for part in docname.split(SEP) if part]</span>
<span class="gi">+    if len(parts) &gt; 2:</span>
<span class="gi">+        return &#39;-&#39;.join(parts[:2])</span>
<span class="gi">+    else:</span>
<span class="gi">+        return docname</span>
<span class="gi">+</span>
<span class="gi">+def format_date(date_str: str | None=None, format: str=&#39;%b %d, %Y&#39;, language: str | None=None) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Format a date according to the given format and language.&quot;&quot;&quot;</span>
<span class="gi">+    if date_str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            date = datetime.strptime(date_str, &#39;%Y-%m-%d&#39;).date()</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return date_str</span>
<span class="gi">+    else:</span>
<span class="gi">+        date = datetime.now(timezone.utc).date()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        result = babel.dates.format_date(date, format=format, locale=language)</span>
<span class="gi">+    except (ValueError, babel.core.UnknownLocaleError):</span>
<span class="gi">+        result = babel.dates.format_date(date, format=format)</span>
<span class="gi">+    return result</span>
<span class="w"> </span>date_format_mappings = {&#39;%a&#39;: &#39;EEE&#39;, &#39;%A&#39;: &#39;EEEE&#39;, &#39;%b&#39;: &#39;MMM&#39;, &#39;%B&#39;: &#39;MMMM&#39;, &#39;%c&#39;: &#39;medium&#39;, &#39;%-d&#39;: &#39;d&#39;, &#39;%d&#39;: &#39;dd&#39;, &#39;%-H&#39;: &#39;H&#39;, &#39;%H&#39;: &#39;HH&#39;, &#39;%-I&#39;: &#39;h&#39;, &#39;%I&#39;: &#39;hh&#39;, &#39;%-j&#39;: &#39;D&#39;, &#39;%j&#39;: &#39;DDD&#39;, &#39;%-m&#39;: &#39;M&#39;, &#39;%m&#39;: &#39;MM&#39;, &#39;%-M&#39;: &#39;m&#39;, &#39;%M&#39;: &#39;mm&#39;, &#39;%p&#39;: &#39;a&#39;, &#39;%-S&#39;: &#39;s&#39;, &#39;%S&#39;: &#39;ss&#39;, &#39;%U&#39;: &#39;WW&#39;, &#39;%w&#39;: &#39;e&#39;, &#39;%-W&#39;: &#39;W&#39;, &#39;%W&#39;: &#39;WW&#39;, &#39;%x&#39;: &#39;medium&#39;, &#39;%X&#39;: &#39;medium&#39;, &#39;%y&#39;: &#39;YY&#39;, &#39;%Y&#39;: &#39;yyyy&#39;, &#39;%Z&#39;: &#39;zzz&#39;, &#39;%z&#39;: &#39;ZZZ&#39;, &#39;%%&#39;: &#39;%&#39;}
<span class="w"> </span>date_format_re = re.compile(&#39;(%s)&#39; % &#39;|&#39;.join(date_format_mappings))
\ No newline at end of file
<span class="gh">diff --git a/sphinx/util/index_entries.py b/sphinx/util/index_entries.py</span>
<span class="gh">index 81e63f3cd..35d7ac590 100644</span>
<span class="gd">--- a/sphinx/util/index_entries.py</span>
<span class="gi">+++ b/sphinx/util/index_entries.py</span>
<span class="gu">@@ -2,4 +2,12 @@ from __future__ import annotations</span>

<span class="w"> </span>def _split_into(n: int, type: str, value: str) -&gt; list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Split an index entry into a given number of parts at semicolons.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    parts = [x.strip() for x in value.split(&#39;;&#39;, n - 1)]</span>
<span class="gi">+    if len(parts) &lt; n:</span>
<span class="gi">+        msg = f&#39;index {type} should be separated by {n - 1} semicolons: {value!r}&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+    return parts</span>
<span class="gi">+</span>
<span class="gi">+def split_index_msg(type: str, value: str) -&gt; tuple[str, str, str, str, str]:</span>
<span class="gi">+    &quot;&quot;&quot;Split a node&#39;s index entry into its components.&quot;&quot;&quot;</span>
<span class="gi">+    return tuple(_split_into(5, type, value))  # type: ignore</span>
\ No newline at end of file
<span class="gh">diff --git a/sphinx/util/matching.py b/sphinx/util/matching.py</span>
<span class="gh">index 56cf7ad45..fab095946 100644</span>
<span class="gd">--- a/sphinx/util/matching.py</span>
<span class="gi">+++ b/sphinx/util/matching.py</span>
<span class="gu">@@ -7,13 +7,54 @@ from sphinx.util.osutil import canon_path, path_stabilize</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Iterator

<span class="gi">+def compile_matchers(patterns: list[str]) -&gt; list[Callable[[str], bool]]:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a list of glob patterns to a list of functions that match paths.&quot;&quot;&quot;</span>
<span class="gi">+    return [lambda x, pat=pat: bool(patmatch(x, pat)) for pat in patterns]</span>
<span class="gi">+</span>
<span class="w"> </span>def _translate_pattern(pat: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Translate a shell-style glob pattern to a regular expression.

<span class="w"> </span>    Adapted from the fnmatch module, but enhanced so that single stars don&#39;t
<span class="w"> </span>    match slashes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i, n = 0, len(pat)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    while i &lt; n:</span>
<span class="gi">+        c = pat[i]</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        if c == &#39;*&#39;:</span>
<span class="gi">+            if i &lt; n and pat[i] == &#39;*&#39;:</span>
<span class="gi">+                # double star matches slashes too</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                res.append(&#39;.*&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # single star doesn&#39;t match slashes</span>
<span class="gi">+                res.append(&#39;[^/]*&#39;)</span>
<span class="gi">+        elif c == &#39;?&#39;:</span>
<span class="gi">+            # question mark doesn&#39;t match slashes</span>
<span class="gi">+            res.append(&#39;[^/]&#39;)</span>
<span class="gi">+        elif c == &#39;[&#39;:</span>
<span class="gi">+            j = i</span>
<span class="gi">+            if j &lt; n and pat[j] == &#39;!&#39;:</span>
<span class="gi">+                j += 1</span>
<span class="gi">+            if j &lt; n and pat[j] == &#39;]&#39;:</span>
<span class="gi">+                j += 1</span>
<span class="gi">+            while j &lt; n and pat[j] != &#39;]&#39;:</span>
<span class="gi">+                j += 1</span>
<span class="gi">+            if j &gt;= n:</span>
<span class="gi">+                res.append(&#39;\\[&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                stuff = pat[i:j].replace(&#39;\\&#39;, &#39;\\\\&#39;)</span>
<span class="gi">+                i = j + 1</span>
<span class="gi">+                if stuff[0] == &#39;!&#39;:</span>
<span class="gi">+                    stuff = &#39;^&#39; + stuff[1:]</span>
<span class="gi">+                elif stuff[0] == &#39;^&#39;:</span>
<span class="gi">+                    stuff = &#39;\\&#39; + stuff</span>
<span class="gi">+                res.append(&#39;[%s]&#39; % stuff)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res.append(re.escape(c))</span>
<span class="gi">+    res.append(&#39;$&#39;)</span>
<span class="gi">+    return &#39;&#39;.join(res)</span>

<span class="w"> </span>class Matcher:
<span class="w"> </span>    &quot;&quot;&quot;A pattern matcher for Multiple shell-style glob patterns.
<span class="gu">@@ -28,6 +69,10 @@ class Matcher:</span>

<span class="w"> </span>    def __call__(self, string: str) -&gt; bool:
<span class="w"> </span>        return self.match(string)
<span class="gi">+</span>
<span class="gi">+    def match(self, string: str) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Return if string matches any of the patterns.&quot;&quot;&quot;</span>
<span class="gi">+        return any(pat(string) for pat in self.patterns)</span>
<span class="w"> </span>DOTFILES = Matcher([&#39;**/.*&#39;])
<span class="w"> </span>_pat_cache: dict[str, re.Pattern[str]] = {}

<span class="gu">@@ -35,7 +80,9 @@ def patmatch(name: str, pat: str) -&gt; re.Match[str] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return if name matches the regular expression (pattern)
<span class="w"> </span>    ``pat```. Adapted from fnmatch module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pat not in _pat_cache:</span>
<span class="gi">+        _pat_cache[pat] = re.compile(_translate_pattern(pat))</span>
<span class="gi">+    return _pat_cache[pat].match(name)</span>

<span class="w"> </span>def patfilter(names: Iterable[str], pat: str) -&gt; list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Return the subset of the list ``names`` that match
<span class="gu">@@ -43,7 +90,7 @@ def patfilter(names: Iterable[str], pat: str) -&gt; list[str]:</span>

<span class="w"> </span>    Adapted from fnmatch module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [name for name in names if patmatch(name, pat)]</span>

<span class="w"> </span>def get_matching_files(dirname: str | os.PathLike[str], include_patterns: Iterable[str]=(&#39;**&#39;,), exclude_patterns: Iterable[str]=()) -&gt; Iterator[str]:
<span class="w"> </span>    &quot;&quot;&quot;Get all file names in a directory, recursively.
<span class="gu">@@ -55,4 +102,19 @@ def get_matching_files(dirname: str | os.PathLike[str], include_patterns: Iterab</span>
<span class="w"> </span>    exclusions from *exclude_patterns* take priority over inclusions.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    dirname = os.fspath(dirname)</span>
<span class="gi">+    if not os.path.isdir(dirname):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # normalize patterns</span>
<span class="gi">+    include_patterns = [path_stabilize(pat) for pat in include_patterns]</span>
<span class="gi">+    exclude_patterns = [path_stabilize(pat) for pat in exclude_patterns]</span>
<span class="gi">+</span>
<span class="gi">+    for root, _dirs, files in os.walk(dirname):</span>
<span class="gi">+        reldir = canon_path(os.path.relpath(root, dirname))</span>
<span class="gi">+        for filename in files:</span>
<span class="gi">+            relpath = canon_path(os.path.join(reldir, filename))</span>
<span class="gi">+            if any(patmatch(relpath, pat) for pat in exclude_patterns):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if any(patmatch(relpath, pat) for pat in include_patterns):</span>
<span class="gi">+                yield relpath</span>
\ No newline at end of file
<span class="gh">diff --git a/sphinx/util/nodes.py b/sphinx/util/nodes.py</span>
<span class="gh">index a9f6b1c42..484e5bdeb 100644</span>
<span class="gd">--- a/sphinx/util/nodes.py</span>
<span class="gi">+++ b/sphinx/util/nodes.py</span>
<span class="gu">@@ -58,7 +58,21 @@ class NodeMatcher(Generic[N]):</span>
<span class="w"> </span>        While the `NodeMatcher` object can be used as an argument to `Node.findall`, doing so
<span class="w"> </span>        confounds type checkers&#39; ability to determine the return type of the iterator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (cast(N, found) for found in node.findall(self.match))</span>
<span class="gi">+</span>
<span class="gi">+    def match(self, node: Node) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Return True if the given node matches the criteria.&quot;&quot;&quot;</span>
<span class="gi">+        if not isinstance(node, self.classes):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in self.attrs.items():</span>
<span class="gi">+            if value is Any:</span>
<span class="gi">+                if not hasattr(node, key):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not hasattr(node, key) or getattr(node, key) != value:</span>
<span class="gi">+                    return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>def get_full_module_name(node: Node) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -67,7 +81,9 @@ def get_full_module_name(node: Node) -&gt; str:</span>
<span class="w"> </span>    :param nodes.Node node: target node
<span class="w"> </span>    :return: full module dotted path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module = node.__module__ or &#39;&#39;</span>
<span class="gi">+    module = module.replace(&#39;docutils_&#39;, &#39;docutils.&#39;)  # for apidoc build</span>
<span class="gi">+    return &#39;%s.%s&#39; % (module, node.__class__.__name__)</span>

<span class="w"> </span>def repr_domxml(node: Node, length: int=80) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -80,18 +96,42 @@ def repr_domxml(node: Node, length: int=80) -&gt; str:</span>
<span class="w"> </span>       returns full of DOM XML representation.
<span class="w"> </span>    :return: DOM XML representation
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    xml = node.asdom().toxml()</span>
<span class="gi">+    if length:</span>
<span class="gi">+        return xml[:length] + &#39;...&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return xml</span>
<span class="w"> </span>IGNORED_NODES = (nodes.Invisible, nodes.literal_block, nodes.doctest_block, addnodes.versionmodified)
<span class="w"> </span>LITERAL_TYPE_NODES = (nodes.literal_block, nodes.doctest_block, nodes.math_block, nodes.raw)
<span class="w"> </span>IMAGE_TYPE_NODES = (nodes.image,)

<span class="w"> </span>def extract_messages(doctree: Element) -&gt; Iterable[tuple[Element, str]]:
<span class="w"> </span>    &quot;&quot;&quot;Extract translatable messages from a document tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in doctree.findall(nodes.TextElement):</span>
<span class="gi">+        if not isinstance(node, IGNORED_NODES) and node.get(&#39;translatable&#39;, True):</span>
<span class="gi">+            # extract message from text nodes</span>
<span class="gi">+            if isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                msg = node.astext()</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = node.rawsource or node.astext()</span>
<span class="gi">+            if msg:</span>
<span class="gi">+                yield node, msg</span>
<span class="gi">+</span>
<span class="gi">+            # extract message from image nodes</span>
<span class="gi">+            for img in node.findall(IMAGE_TYPE_NODES):</span>
<span class="gi">+                for attr in (&#39;alt&#39;, &#39;title&#39;):</span>
<span class="gi">+                    val = img.get(attr, &#39;&#39;)</span>
<span class="gi">+                    if val:</span>
<span class="gi">+                        yield img, val</span>

<span class="w"> </span>def traverse_translatable_index(doctree: Element) -&gt; Iterable[tuple[Element, list[tuple[str, str, str, str, str | None]]]]:
<span class="w"> </span>    &quot;&quot;&quot;Traverse translatable index node from a document tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in doctree.findall(addnodes.index):</span>
<span class="gi">+        if &#39;raw_entries&#39; in node:</span>
<span class="gi">+            entries = node[&#39;raw_entries&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            entries = node[&#39;entries&#39;]</span>
<span class="gi">+        yield node, entries</span>

<span class="w"> </span>def nested_parse_with_titles(state: RSTState, content: StringList, node: Node, content_offset: int=0) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Version of state.nested_parse() that allows titles and does not require
<span class="gu">@@ -103,15 +143,23 @@ def nested_parse_with_titles(state: RSTState, content: StringList, node: Node, c</span>
<span class="w"> </span>    This function is retained for compatibility and will be deprecated in
<span class="w"> </span>    Sphinx 8. Prefer ``nested_parse_to_nodes()``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with _fresh_title_style_context(state):</span>
<span class="gi">+        state.nested_parse(content, content_offset, node)</span>
<span class="gi">+    return &#39;&#39;</span>

<span class="w"> </span>def clean_astext(node: Element) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Like node.astext(), but ignore images.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node_copy = node.deepcopy()</span>
<span class="gi">+    for img in node_copy.findall(nodes.image):</span>
<span class="gi">+        img.parent.remove(img)</span>
<span class="gi">+    return node_copy.astext()</span>

<span class="w"> </span>def split_explicit_title(text: str) -&gt; tuple[bool, str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Split role content into title and target, if given.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = explicit_title_re.match(text)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        return True, match.group(1), match.group(2)</span>
<span class="gi">+    return False, text, text</span>
<span class="w"> </span>indextypes = [&#39;single&#39;, &#39;pair&#39;, &#39;double&#39;, &#39;triple&#39;, &#39;see&#39;, &#39;seealso&#39;]

<span class="w"> </span>def inline_all_toctrees(builder: Builder, docnameset: set[str], docname: str, tree: nodes.document, colorfunc: Callable[[str], str], traversed: list[str], indent: str=&#39;&#39;) -&gt; nodes.document:
<span class="gu">@@ -119,7 +167,29 @@ def inline_all_toctrees(builder: Builder, docnameset: set[str], docname: str, tr</span>

<span class="w"> </span>    Record all docnames in *docnameset*, and output docnames with *colorfunc*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tree = tree.deepcopy()</span>
<span class="gi">+    for toctreenode in tree.findall(addnodes.toctree):</span>
<span class="gi">+        newnodes = []</span>
<span class="gi">+        includefiles = map(str, toctreenode[&#39;includefiles&#39;])</span>
<span class="gi">+        for includefile in includefiles:</span>
<span class="gi">+            if includefile not in traversed:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    traversed.append(includefile)</span>
<span class="gi">+                    logger.info(colorfunc(includefile) + indent)</span>
<span class="gi">+                    subtree = inline_all_toctrees(builder, docnameset, includefile,</span>
<span class="gi">+                                                builder.env.get_doctree(includefile),</span>
<span class="gi">+                                                colorfunc, traversed,</span>
<span class="gi">+                                                indent + &#39;   &#39;)</span>
<span class="gi">+                    docnameset.add(includefile)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    logger.warning(__(&#39;toctree contains ref to nonexisting file %r&#39;),</span>
<span class="gi">+                                 includefile, location=docname)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    sof = addnodes.start_of_file(docname=includefile)</span>
<span class="gi">+                    sof.children = subtree.children</span>
<span class="gi">+                    newnodes.append(sof)</span>
<span class="gi">+        toctreenode.parent.replace(toctreenode, newnodes)</span>
<span class="gi">+    return tree</span>

<span class="w"> </span>def _make_id(string: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Convert `string` into an identifier and return it.
<span class="gu">@@ -137,7 +207,12 @@ def _make_id(string: str) -&gt; str:</span>
<span class="w"> </span>    # Maintainer: docutils-develop@lists.sourceforge.net
<span class="w"> </span>    # Copyright: This module has been placed in the public domain.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    id = string.translate(_non_id_translate_digraphs)</span>
<span class="gi">+    id = id.translate(_non_id_translate)</span>
<span class="gi">+    id = unicodedata.normalize(&#39;NFKD&#39;, id).encode(&#39;ascii&#39;, &#39;ignore&#39;).decode(&#39;ascii&#39;)</span>
<span class="gi">+    id = _non_id_chars.sub(&#39;-&#39;, id)</span>
<span class="gi">+    id = _non_id_at_ends.sub(&#39;&#39;, id)</span>
<span class="gi">+    return id</span>
<span class="w"> </span>_non_id_chars = re.compile(&#39;[^a-zA-Z0-9._]+&#39;)
<span class="w"> </span>_non_id_at_ends = re.compile(&#39;^[-0-9._]+|-+$&#39;)
<span class="w"> </span>_non_id_translate = {248: &#39;o&#39;, 273: &#39;d&#39;, 295: &#39;h&#39;, 305: &#39;i&#39;, 322: &#39;l&#39;, 359: &#39;t&#39;, 384: &#39;b&#39;, 387: &#39;b&#39;, 392: &#39;c&#39;, 396: &#39;d&#39;, 402: &#39;f&#39;, 409: &#39;k&#39;, 410: &#39;l&#39;, 414: &#39;n&#39;, 421: &#39;p&#39;, 427: &#39;t&#39;, 429: &#39;t&#39;, 436: &#39;y&#39;, 438: &#39;z&#39;, 485: &#39;g&#39;, 549: &#39;z&#39;, 564: &#39;l&#39;, 565: &#39;n&#39;, 566: &#39;t&#39;, 567: &#39;j&#39;, 572: &#39;c&#39;, 575: &#39;s&#39;, 576: &#39;z&#39;, 583: &#39;e&#39;, 585: &#39;j&#39;, 587: &#39;q&#39;, 589: &#39;r&#39;, 591: &#39;y&#39;}
<span class="gu">@@ -145,28 +220,90 @@ _non_id_translate_digraphs = {223: &#39;sz&#39;, 230: &#39;ae&#39;, 339: &#39;oe&#39;, 568: &#39;db&#39;, 569: &#39;</span>

<span class="w"> </span>def make_id(env: BuildEnvironment, document: nodes.document, prefix: str=&#39;&#39;, term: str | None=None) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Generate an appropriate node_id for given *prefix* and *term*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if prefix:</span>
<span class="gi">+        id_prefix = _make_id(prefix)</span>
<span class="gi">+        if term:</span>
<span class="gi">+            id_suffix = _make_id(term)</span>
<span class="gi">+        else:</span>
<span class="gi">+            id_suffix = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        id_prefix = _make_id(term) if term else &#39;&#39;</span>
<span class="gi">+        id_suffix = None</span>
<span class="gi">+</span>
<span class="gi">+    if id_prefix:</span>
<span class="gi">+        if id_suffix:</span>
<span class="gi">+            new_id = f&#39;{id_prefix}-{id_suffix}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_id = id_prefix</span>
<span class="gi">+    else:</span>
<span class="gi">+        new_id = id_suffix if id_suffix else &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while new_id + (str(i) if i else &#39;&#39;) in document.ids:</span>
<span class="gi">+        i += 1</span>
<span class="gi">+    if i:</span>
<span class="gi">+        new_id += str(i)</span>
<span class="gi">+</span>
<span class="gi">+    document.ids[new_id] = True</span>
<span class="gi">+    return new_id</span>

<span class="w"> </span>def find_pending_xref_condition(node: addnodes.pending_xref, condition: str) -&gt; Element | None:
<span class="w"> </span>    &quot;&quot;&quot;Pick matched pending_xref_condition node up from the pending_xref.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for subnode in node:</span>
<span class="gi">+        if isinstance(subnode, addnodes.pending_xref_condition):</span>
<span class="gi">+            if subnode[&#39;condition&#39;] == condition:</span>
<span class="gi">+                return subnode</span>
<span class="gi">+    return None</span>

<span class="w"> </span>def make_refnode(builder: Builder, fromdocname: str, todocname: str, targetid: str | None, child: Node | list[Node], title: str | None=None) -&gt; nodes.reference:
<span class="w"> </span>    &quot;&quot;&quot;Shortcut to create a reference node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node = nodes.reference(&#39;&#39;, &#39;&#39;, internal=True)</span>
<span class="gi">+    if fromdocname == todocname and targetid:</span>
<span class="gi">+        node[&#39;refid&#39;] = targetid</span>
<span class="gi">+    else:</span>
<span class="gi">+        if targetid:</span>
<span class="gi">+            node[&#39;refuri&#39;] = (builder.get_relative_uri(fromdocname, todocname) +</span>
<span class="gi">+                            &#39;#&#39; + targetid)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node[&#39;refuri&#39;] = builder.get_relative_uri(fromdocname, todocname)</span>
<span class="gi">+    if title:</span>
<span class="gi">+        node[&#39;reftitle&#39;] = title</span>
<span class="gi">+    if isinstance(child, list):</span>
<span class="gi">+        node.extend(child)</span>
<span class="gi">+    else:</span>
<span class="gi">+        node.append(child)</span>
<span class="gi">+    return node</span>
<span class="w"> </span>NON_SMARTQUOTABLE_PARENT_NODES = (nodes.FixedTextElement, nodes.literal, nodes.math, nodes.image, nodes.raw, nodes.problematic, addnodes.not_smartquotable)

<span class="w"> </span>def is_smartquotable(node: Node) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Check whether the node is smart-quotable or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for ancestor in node.traverse(ascending=True, include_self=True):</span>
<span class="gi">+        if isinstance(ancestor, NON_SMARTQUOTABLE_PARENT_NODES):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>

<span class="w"> </span>def process_only_nodes(document: Node, tags: Tags) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Filter ``only`` nodes which do not match *tags*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in document.findall(addnodes.only):</span>
<span class="gi">+        try:</span>
<span class="gi">+            ret = _only_node_keep_children(node, tags)</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            logger.warning(__(&#39;exception while evaluating only directive expression: %s&#39;), err,</span>
<span class="gi">+                         location=node)</span>
<span class="gi">+            node.replace_self(node.children or [])</span>
<span class="gi">+        else:</span>
<span class="gi">+            if ret:</span>
<span class="gi">+                node.replace_self(node.children or [])</span>
<span class="gi">+            else:</span>
<span class="gi">+                # A failing condition removes that node and its children</span>
<span class="gi">+                node.parent.remove(node)</span>

<span class="w"> </span>def _only_node_keep_children(node: addnodes.only, tags: Tags) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Keep children if tags match or error.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.get(&#39;expr&#39;) in (None, &#39;&#39;):</span>
<span class="gi">+        # A blank condition should always fail</span>
<span class="gi">+        return False</span>
<span class="gi">+    return tags.eval_condition(node[&#39;expr&#39;])</span>

<span class="w"> </span>def _copy_except__document(el: Element) -&gt; Element:
<span class="w"> </span>    &quot;&quot;&quot;Monkey-patch ```nodes.Element.copy``` to not copy the ``_document``
<span class="gu">@@ -174,10 +311,52 @@ def _copy_except__document(el: Element) -&gt; Element:</span>

<span class="w"> </span>    xref: https://github.com/sphinx-doc/sphinx/issues/11116#issuecomment-1376767086
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newel = el.__class__()</span>
<span class="gi">+    for attr in el.attlist():</span>
<span class="gi">+        if attr != &#39;_document&#39;:</span>
<span class="gi">+            setattr(newel, attr, getattr(el, attr))</span>
<span class="gi">+    return newel</span>
<span class="w"> </span>nodes.Element.copy = _copy_except__document

<span class="gi">+def get_node_line(node: Node) -&gt; int:</span>
<span class="gi">+    &quot;&quot;&quot;Get the line number of a node.&quot;&quot;&quot;</span>
<span class="gi">+    source = node.get(&#39;source&#39;)</span>
<span class="gi">+    if source and &#39;:&#39; in source:</span>
<span class="gi">+        return int(source.split(&#39;:&#39;, 1)[1])</span>
<span class="gi">+    return 0</span>
<span class="gi">+</span>
<span class="gi">+def is_translatable(node: Node) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check the node is translatable.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(node, nodes.TextElement):</span>
<span class="gi">+        if not node.source:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if isinstance(node, IGNORED_NODES):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not node.get(&#39;translatable&#39;, True):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+def apply_source_workaround(node: Node) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Apply a workaround for source-attributes of nodes.</span>
<span class="gi">+</span>
<span class="gi">+    Docutils appends a line number to the source-attribute of nodes if possible.</span>
<span class="gi">+    Some builders don&#39;t want the line number in the source-attribute.</span>
<span class="gi">+    This function removes the line number.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = node.get(&#39;source&#39;)</span>
<span class="gi">+        if source and &#39;:&#39; in source:</span>
<span class="gi">+            node[&#39;source&#39;] = source.split(&#39;:&#39;, 1)[0]</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="w"> </span>def _deepcopy(el: Element) -&gt; Element:
<span class="w"> </span>    &quot;&quot;&quot;Monkey-patch ```nodes.Element.deepcopy``` for speed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    copy = el.copy()</span>
<span class="gi">+    copy.children = [child.deepcopy() for child in el.children]</span>
<span class="gi">+    for child in copy.children:</span>
<span class="gi">+        child.parent = copy</span>
<span class="gi">+    return copy</span>
<span class="w"> </span>nodes.Element.deepcopy = _deepcopy
\ No newline at end of file
<span class="gh">diff --git a/sphinx/util/osutil.py b/sphinx/util/osutil.py</span>
<span class="gh">index 8fe2fac65..581cf23d5 100644</span>
<span class="gd">--- a/sphinx/util/osutil.py</span>
<span class="gi">+++ b/sphinx/util/osutil.py</span>
<span class="gu">@@ -19,19 +19,36 @@ SEP = &#39;/&#39;</span>

<span class="w"> </span>def canon_path(native_path: str | os.PathLike[str], /) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return path in OS-independent form&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(native_path).replace(os.path.sep, SEP)</span>

<span class="w"> </span>def path_stabilize(filepath: str | os.PathLike[str], /) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Normalize path separator and unicode string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filepath = str(filepath)</span>
<span class="gi">+    filepath = unicodedata.normalize(&#39;NFC&#39;, filepath)</span>
<span class="gi">+    return filepath.replace(os.path.sep, SEP)</span>

<span class="w"> </span>def relative_uri(base: str, to: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return a relative URL from ``base`` to ``to``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not base or not to:</span>
<span class="gi">+        return to</span>
<span class="gi">+    b2 = base.split(SEP)</span>
<span class="gi">+    t2 = to.split(SEP)</span>
<span class="gi">+    # remove common segments</span>
<span class="gi">+    for x, y in zip(b2, t2):</span>
<span class="gi">+        if x != y:</span>
<span class="gi">+            break</span>
<span class="gi">+        b2.pop(0)</span>
<span class="gi">+        t2.pop(0)</span>
<span class="gi">+    if not b2 and not t2:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    return (&#39;../&#39; * (len(b2) - 1) + &#39;./&#39; * bool(b2) +</span>
<span class="gi">+            SEP.join(t2) + (&#39;/&#39; if to.endswith(&#39;/&#39;) else &#39;&#39;))</span>

<span class="w"> </span>def ensuredir(file: str | os.PathLike[str]) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Ensure that a path exists.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = os.path.dirname(os.fspath(file))</span>
<span class="gi">+    if path and not os.path.exists(path):</span>
<span class="gi">+        os.makedirs(path)</span>

<span class="w"> </span>def _last_modified_time(source: str | os.PathLike[str], /) -&gt; int:
<span class="w"> </span>    &quot;&quot;&quot;Return the last modified time of ``filename``.
<span class="gu">@@ -43,11 +60,13 @@ def _last_modified_time(source: str | os.PathLike[str], /) -&gt; int:</span>
<span class="w"> </span>    We prefer to err on the side of re-rendering a file,
<span class="w"> </span>    so we round up to the nearest microsecond.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    st = os.stat(source)</span>
<span class="gi">+    return int(st.st_mtime * 1_000_000)</span>

<span class="w"> </span>def _copy_times(source: str | os.PathLike[str], dest: str | os.PathLike[str]) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Copy a file&#39;s modification times.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    st = os.stat(source)</span>
<span class="gi">+    os.utime(dest, (st.st_atime, st.st_mtime))</span>

<span class="w"> </span>def copyfile(source: str | os.PathLike[str], dest: str | os.PathLike[str], *, force: bool=False) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Copy a file and its modification times, if possible.
<span class="gu">@@ -59,9 +78,31 @@ def copyfile(source: str | os.PathLike[str], dest: str | os.PathLike[str], *, fo</span>

<span class="w"> </span>    .. note:: :func:`copyfile` is a no-op if *source* and *dest* are identical.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    source = os.fspath(source)</span>
<span class="gi">+    dest = os.fspath(dest)</span>
<span class="gi">+</span>
<span class="gi">+    if not os.path.exists(source):</span>
<span class="gi">+        raise FileNotFoundError(source)</span>
<span class="gi">+    if source == dest:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if os.path.exists(dest) and not force:</span>
<span class="gi">+        if filecmp.cmp(source, dest, shallow=True):</span>
<span class="gi">+            return</span>
<span class="gi">+        msg = __(&#39;Cannot copy %r to %r: file exists&#39;) % (source, dest)</span>
<span class="gi">+        raise OSError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        shutil.copyfile(source, dest)</span>
<span class="gi">+        _copy_times(source, dest)</span>
<span class="gi">+    except shutil.SameFileError:</span>
<span class="gi">+        pass</span>
<span class="w"> </span>_no_fn_re = re.compile(&#39;[^a-zA-Z0-9_-]&#39;)

<span class="gi">+def make_filename(string: str) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Convert string to a filename-friendly string.&quot;&quot;&quot;</span>
<span class="gi">+    return _no_fn_re.sub(&#39;&#39;, string)</span>
<span class="gi">+</span>
<span class="w"> </span>def relpath(path: str | os.PathLike[str], start: str | os.PathLike[str] | None=os.curdir) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return a relative filepath to *path* either from the current directory or
<span class="w"> </span>    from an optional *start* directory.
<span class="gu">@@ -69,10 +110,22 @@ def relpath(path: str | os.PathLike[str], start: str | os.PathLike[str] | None=o</span>
<span class="w"> </span>    This is an alternative of ``os.path.relpath()``.  This returns original path
<span class="w"> </span>    if *path* and *start* are on different drives (for Windows platform).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = os.fspath(path)</span>
<span class="gi">+    if start is None:</span>
<span class="gi">+        start = os.curdir</span>
<span class="gi">+    start = os.fspath(start)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return os.path.relpath(path, start)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # if on Windows, and path and start are on different drives, return original path</span>
<span class="gi">+        if os.name == &#39;nt&#39;:</span>
<span class="gi">+            return path</span>
<span class="gi">+        raise</span>
<span class="w"> </span>safe_relpath = relpath
<span class="w"> </span>fs_encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
<span class="w"> </span>abspath = path.abspath
<span class="gi">+os_path = path</span>

<span class="w"> </span>class _chdir:
<span class="w"> </span>    &quot;&quot;&quot;Remove this fall-back once support for Python 3.10 is removed.&quot;&quot;&quot;
<span class="gu">@@ -109,7 +162,23 @@ class FileAvoidWrite:</span>

<span class="w"> </span>    def close(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;Stop accepting writes and write file, if needed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._io:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        content = self._io.getvalue()</span>
<span class="gi">+        self._io.close()</span>
<span class="gi">+        self._io = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(self._path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+                original_content = f.read()</span>
<span class="gi">+                if content == original_content:</span>
<span class="gi">+                    return</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        with open(self._path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            f.write(content)</span>

<span class="w"> </span>    def __enter__(self) -&gt; FileAvoidWrite:
<span class="w"> </span>        return self
<span class="gh">diff --git a/sphinx/util/parsing.py b/sphinx/util/parsing.py</span>
<span class="gh">index c19c62af9..d5b2619a8 100644</span>
<span class="gd">--- a/sphinx/util/parsing.py</span>
<span class="gi">+++ b/sphinx/util/parsing.py</span>
<span class="gu">@@ -8,6 +8,24 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from collections.abc import Iterator
<span class="w"> </span>    from docutils.parsers.rst.states import RSTState

<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _fresh_title_style_context(state: RSTState) -&gt; Iterator[None]:</span>
<span class="gi">+    &quot;&quot;&quot;Context manager that temporarily resets the title style context.</span>
<span class="gi">+</span>
<span class="gi">+    This is used when parsing content that comes from a different context,</span>
<span class="gi">+    such as docstrings, where title decorations (e.g. underlines) do not</span>
<span class="gi">+    need to match the surrounding document.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    old_title_styles = state.memo.title_styles</span>
<span class="gi">+    old_section_level = state.memo.section_level</span>
<span class="gi">+    state.memo.title_styles = []</span>
<span class="gi">+    state.memo.section_level = 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        state.memo.title_styles = old_title_styles</span>
<span class="gi">+        state.memo.section_level = old_section_level</span>
<span class="gi">+</span>
<span class="w"> </span>def nested_parse_to_nodes(state: RSTState, text: str | StringList, *, source: str=&#39;&lt;generated text&gt;&#39;, offset: int=0, allow_section_headings: bool=True, keep_title_context: bool=False) -&gt; list[Node]:
<span class="w"> </span>    &quot;&quot;&quot;Parse *text* into nodes.

<span class="gu">@@ -37,4 +55,22 @@ def nested_parse_to_nodes(state: RSTState, text: str | StringList, *, source: st</span>

<span class="w"> </span>    .. versionadded:: 7.4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if isinstance(text, str):</span>
<span class="gi">+        text = StringList(string2lines(text), source=source)</span>
<span class="gi">+    if offset:</span>
<span class="gi">+        text.parent = text.items[:]</span>
<span class="gi">+        text.items = [(source, i + offset) for i in range(len(text.items))]</span>
<span class="gi">+</span>
<span class="gi">+    node = Element()</span>
<span class="gi">+    if not allow_section_headings:</span>
<span class="gi">+        with state.nested_parse(text, 0, node, match_titles=False):</span>
<span class="gi">+            pass</span>
<span class="gi">+    elif not keep_title_context:</span>
<span class="gi">+        with _fresh_title_style_context(state):</span>
<span class="gi">+            with state.nested_parse(text, 0, node):</span>
<span class="gi">+                pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        with state.nested_parse(text, 0, node):</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    return node.children</span>
\ No newline at end of file
<span class="gh">diff --git a/sphinx/util/tags.py b/sphinx/util/tags.py</span>
<span class="gh">index bd097ec83..6af1c649a 100644</span>
<span class="gd">--- a/sphinx/util/tags.py</span>
<span class="gi">+++ b/sphinx/util/tags.py</span>
<span class="gu">@@ -20,7 +20,7 @@ class Tags:</span>
<span class="w"> </span>        self._condition_cache: dict[str, bool] = {}

<span class="w"> </span>    def __str__(self) -&gt; str:
<span class="gd">-        return f&#39;{self.__class__.__name__}({&#39;, &#39;.join(sorted(self._tags))})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({&#39;, &#39;.join(sorted(self._tags))})&quot;</span>

<span class="w"> </span>    def __repr__(self) -&gt; str:
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({tuple(sorted(self._tags))})&#39;
<span class="gu">@@ -38,4 +38,33 @@ class Tags:</span>
<span class="w"> </span>        are permitted, and operate on tag names, where truthy values mean
<span class="w"> </span>        the tag is present and vice versa.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        # memoization</span>
<span class="gi">+        if condition in self._condition_cache:</span>
<span class="gi">+            return self._condition_cache[condition]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            parser = BooleanParser(_ENV, condition, state=&#39;variable&#39;)</span>
<span class="gi">+            ast = parser.parse()</span>
<span class="gi">+            if not isinstance(ast, jinja2.nodes.Expr):</span>
<span class="gi">+                msg = &#39;only expressions can be used in condtions&#39;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+            result = self.eval_node(ast.node)</span>
<span class="gi">+            self._condition_cache[condition] = result</span>
<span class="gi">+            return result</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            warnings.warn(&#39;invalid condition: %r: %s&#39; % (condition, err),</span>
<span class="gi">+                        RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def eval_node(self, node: jinja2.nodes.Node) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Evaluate a parsed Jinja2 node.&quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(node, jinja2.nodes.Name):</span>
<span class="gi">+            return node.name in self._tags</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Not):</span>
<span class="gi">+            return not self.eval_node(node.node)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.And):</span>
<span class="gi">+            return self.eval_node(node.left) and self.eval_node(node.right)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Or):</span>
<span class="gi">+            return self.eval_node(node.left) or self.eval_node(node.right)</span>
<span class="gi">+        msg = f&#39;invalid node type: {node.__class__.__name__}&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>