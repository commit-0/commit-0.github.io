
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis reference marshmallow - </title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#submission-name-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="" class="md-header__button md-logo" aria-label="" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis reference marshmallow
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="" class="md-nav__button md-logo" aria-label="" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Submission Analysis
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_reference">back to reference summary</a></p>
<h1 id="submission-name-reference">Submission Name: reference</h1>
<h1 id="repository-marshmallow">Repository: marshmallow</h1>
<h2 id="pytest-summary-tests">Pytest Summary: tests</h2>
<div class="highlight"><pre><span></span><code>| status   | count |
|:---------|:-----:|
| passed | 1229 |
</code></pre></div>
<p>| total | 1229 |
| collected | 1229 |</p>
<h2 id="failed-pytest-outputs-tests">Failed pytest outputs: tests</h2>
<h3 id="patch-diff">Patch diff</h3>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/marshmallow/base.py b/src/marshmallow/base.py</span>
<span class="gh">index 5849d2e..e82848d 100644</span>
<span class="gd">--- a/src/marshmallow/base.py</span>
<span class="gi">+++ b/src/marshmallow/base.py</span>
<span class="gu">@@ -7,16 +7,59 @@ These are necessary to avoid circular imports between schema.py and fields.py.</span>
<span class="w"> </span>    This module is treated as private API.
<span class="w"> </span>    Users should not need to use this module directly.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod


<span class="w"> </span>class FieldABC(ABC):
<span class="w"> </span>    &quot;&quot;&quot;Abstract base class from which all Field classes inherit.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    parent = None
<span class="w"> </span>    name = None
<span class="w"> </span>    root = None

<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def serialize(self, attr, obj, accessor=None):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def deserialize(self, value):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class SchemaABC(ABC):
<span class="w"> </span>    &quot;&quot;&quot;Abstract base class from which all Schemas inherit.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def dump(self, obj, *, many: bool | None = None):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def dumps(self, obj, *, many: bool | None = None):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def load(self, data, *, many: bool | None = None, partial=None, unknown=None):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def loads(</span>
<span class="gi">+        self,</span>
<span class="gi">+        json_data,</span>
<span class="gi">+        *,</span>
<span class="gi">+        many: bool | None = None,</span>
<span class="gi">+        partial=None,</span>
<span class="gi">+        unknown=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        pass</span>
<span class="gh">diff --git a/src/marshmallow/class_registry.py b/src/marshmallow/class_registry.py</span>
<span class="gh">index 249b898..810d115 100644</span>
<span class="gd">--- a/src/marshmallow/class_registry.py</span>
<span class="gi">+++ b/src/marshmallow/class_registry.py</span>
<span class="gu">@@ -7,16 +7,26 @@ class:`fields.Nested &lt;marshmallow.fields.Nested&gt;`.</span>
<span class="w"> </span>    This module is treated as private API.
<span class="w"> </span>    Users should not need to use this module directly.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from marshmallow.exceptions import RegistryError
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from marshmallow import Schema
<span class="gi">+</span>
<span class="w"> </span>    SchemaType = typing.Type[Schema]
<span class="gd">-_registry = {}</span>

<span class="gi">+# {</span>
<span class="gi">+#   &lt;class_name&gt;: &lt;list of class objects&gt;</span>
<span class="gi">+#   &lt;module_path_to_class&gt;: &lt;list of class objects&gt;</span>
<span class="gi">+# }</span>
<span class="gi">+_registry = {}  # type: dict[str, list[SchemaType]]</span>

<span class="gd">-def register(classname: str, cls: SchemaType) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def register(classname: str, cls: SchemaType) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a class to the registry of serializer classes. When a class is
<span class="w"> </span>    registered, an entry for both its classname and its full, module-qualified
<span class="w"> </span>    path are added to the registry.
<span class="gu">@@ -35,14 +45,50 @@ def register(classname: str, cls: SchemaType) -&gt;None:</span>
<span class="w"> </span>        # }

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Module where the class is located</span>
<span class="gi">+    module = cls.__module__</span>
<span class="gi">+    # Full module path to the class</span>
<span class="gi">+    # e.g. user.schemas.UserSchema</span>
<span class="gi">+    fullpath = &quot;.&quot;.join([module, classname])</span>
<span class="gi">+    # If the class is already registered; need to check if the entries are</span>
<span class="gi">+    # in the same module as cls to avoid having multiple instances of the same</span>
<span class="gi">+    # class in the registry</span>
<span class="gi">+    if classname in _registry and not any(</span>
<span class="gi">+        each.__module__ == module for each in _registry[classname]</span>
<span class="gi">+    ):</span>
<span class="gi">+        _registry[classname].append(cls)</span>
<span class="gi">+    elif classname not in _registry:</span>
<span class="gi">+        _registry[classname] = [cls]</span>

<span class="gi">+    # Also register the full path</span>
<span class="gi">+    if fullpath not in _registry:</span>
<span class="gi">+        _registry.setdefault(fullpath, []).append(cls)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If fullpath does exist, replace existing entry</span>
<span class="gi">+        _registry[fullpath] = [cls]</span>
<span class="gi">+    return None</span>

<span class="gd">-def get_class(classname: str, all: bool=False) -&gt;(list[SchemaType] | SchemaType</span>
<span class="gd">-    ):</span>
<span class="gi">+</span>
<span class="gi">+def get_class(classname: str, all: bool = False) -&gt; list[SchemaType] | SchemaType:</span>
<span class="w"> </span>    &quot;&quot;&quot;Retrieve a class from the registry.

<span class="w"> </span>    :raises: marshmallow.exceptions.RegistryError if the class cannot be found
<span class="w"> </span>        or if there are multiple entries for the given class name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        classes = _registry[classname]</span>
<span class="gi">+    except KeyError as error:</span>
<span class="gi">+        raise RegistryError(</span>
<span class="gi">+            f&quot;Class with name {classname!r} was not found. You may need &quot;</span>
<span class="gi">+            &quot;to import the class.&quot;</span>
<span class="gi">+        ) from error</span>
<span class="gi">+    if len(classes) &gt; 1:</span>
<span class="gi">+        if all:</span>
<span class="gi">+            return _registry[classname]</span>
<span class="gi">+        raise RegistryError(</span>
<span class="gi">+            f&quot;Multiple classes with name {classname!r} &quot;</span>
<span class="gi">+            &quot;were found. Please use the full, &quot;</span>
<span class="gi">+            &quot;module-qualified path.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _registry[classname][0]</span>
<span class="gh">diff --git a/src/marshmallow/decorators.py b/src/marshmallow/decorators.py</span>
<span class="gh">index d78f5be..dafca95 100644</span>
<span class="gd">--- a/src/marshmallow/decorators.py</span>
<span class="gi">+++ b/src/marshmallow/decorators.py</span>
<span class="gu">@@ -64,32 +64,38 @@ Example: ::</span>
<span class="w"> </span>    If you need to guarantee order of different processing steps, you should put
<span class="w"> </span>    them in the same processing method.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from typing import Any, Callable, cast
<span class="gd">-PRE_DUMP = &#39;pre_dump&#39;</span>
<span class="gd">-POST_DUMP = &#39;post_dump&#39;</span>
<span class="gd">-PRE_LOAD = &#39;pre_load&#39;</span>
<span class="gd">-POST_LOAD = &#39;post_load&#39;</span>
<span class="gd">-VALIDATES = &#39;validates&#39;</span>
<span class="gd">-VALIDATES_SCHEMA = &#39;validates_schema&#39;</span>
<span class="gi">+</span>
<span class="gi">+PRE_DUMP = &quot;pre_dump&quot;</span>
<span class="gi">+POST_DUMP = &quot;post_dump&quot;</span>
<span class="gi">+PRE_LOAD = &quot;pre_load&quot;</span>
<span class="gi">+POST_LOAD = &quot;post_load&quot;</span>
<span class="gi">+VALIDATES = &quot;validates&quot;</span>
<span class="gi">+VALIDATES_SCHEMA = &quot;validates_schema&quot;</span>


<span class="w"> </span>class MarshmallowHook:
<span class="w"> </span>    __marshmallow_hook__: dict[tuple[str, bool] | str, Any] | None = None


<span class="gd">-def validates(field_name: str) -&gt;Callable[..., Any]:</span>
<span class="gi">+def validates(field_name: str) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a field validator.

<span class="w"> </span>    :param str field_name: Name of the field that the method validates.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(None, VALIDATES, field_name=field_name)</span>


<span class="gd">-def validates_schema(fn: (Callable[..., Any] | None)=None, pass_many: bool=</span>
<span class="gd">-    False, pass_original: bool=False, skip_on_field_errors: bool=True</span>
<span class="gd">-    ) -&gt;Callable[..., Any]:</span>
<span class="gi">+def validates_schema(</span>
<span class="gi">+    fn: Callable[..., Any] | None = None,</span>
<span class="gi">+    pass_many: bool = False,</span>
<span class="gi">+    pass_original: bool = False,</span>
<span class="gi">+    skip_on_field_errors: bool = True,</span>
<span class="gi">+) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a schema-level validator.

<span class="w"> </span>    By default it receives a single object at a time, transparently handling the ``many``
<span class="gu">@@ -109,11 +115,17 @@ def validates_schema(fn: (Callable[..., Any] | None)=None, pass_many: bool=</span>
<span class="w"> </span>        ``partial`` and ``many`` are always passed as keyword arguments to
<span class="w"> </span>        the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(</span>
<span class="gi">+        fn,</span>
<span class="gi">+        (VALIDATES_SCHEMA, pass_many),</span>
<span class="gi">+        pass_original=pass_original,</span>
<span class="gi">+        skip_on_field_errors=skip_on_field_errors,</span>
<span class="gi">+    )</span>


<span class="gd">-def pre_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False</span>
<span class="gd">-    ) -&gt;Callable[..., Any]:</span>
<span class="gi">+def pre_dump(</span>
<span class="gi">+    fn: Callable[..., Any] | None = None, pass_many: bool = False</span>
<span class="gi">+) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a method to invoke before serializing an object. The method
<span class="w"> </span>    receives the object to be serialized and returns the processed object.

<span class="gu">@@ -124,11 +136,14 @@ def pre_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0
<span class="w"> </span>        ``many`` is always passed as a keyword arguments to the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (PRE_DUMP, pass_many))</span>


<span class="gd">-def post_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,</span>
<span class="gd">-    pass_original: bool=False) -&gt;Callable[..., Any]:</span>
<span class="gi">+def post_dump(</span>
<span class="gi">+    fn: Callable[..., Any] | None = None,</span>
<span class="gi">+    pass_many: bool = False,</span>
<span class="gi">+    pass_original: bool = False,</span>
<span class="gi">+) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a method to invoke after serializing an object. The method
<span class="w"> </span>    receives the serialized object and returns the processed object.

<span class="gu">@@ -142,11 +157,12 @@ def post_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0
<span class="w"> </span>        ``many`` is always passed as a keyword arguments to the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (POST_DUMP, pass_many), pass_original=pass_original)</span>


<span class="gd">-def pre_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False</span>
<span class="gd">-    ) -&gt;Callable[..., Any]:</span>
<span class="gi">+def pre_load(</span>
<span class="gi">+    fn: Callable[..., Any] | None = None, pass_many: bool = False</span>
<span class="gi">+) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a method to invoke before deserializing an object. The method
<span class="w"> </span>    receives the data to be deserialized and returns the processed data.

<span class="gu">@@ -158,11 +174,14 @@ def pre_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False</span>
<span class="w"> </span>        ``partial`` and ``many`` are always passed as keyword arguments to
<span class="w"> </span>        the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (PRE_LOAD, pass_many))</span>


<span class="gd">-def post_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,</span>
<span class="gd">-    pass_original: bool=False) -&gt;Callable[..., Any]:</span>
<span class="gi">+def post_load(</span>
<span class="gi">+    fn: Callable[..., Any] | None = None,</span>
<span class="gi">+    pass_many: bool = False,</span>
<span class="gi">+    pass_original: bool = False,</span>
<span class="gi">+) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a method to invoke after deserializing an object. The method
<span class="w"> </span>    receives the deserialized data and returns the processed data.

<span class="gu">@@ -177,11 +196,12 @@ def post_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,</span>
<span class="w"> </span>        ``partial`` and ``many`` are always passed as keyword arguments to
<span class="w"> </span>        the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (POST_LOAD, pass_many), pass_original=pass_original)</span>


<span class="gd">-def set_hook(fn: (Callable[..., Any] | None), key: (tuple[str, bool] | str),</span>
<span class="gd">-    **kwargs: Any) -&gt;Callable[..., Any]:</span>
<span class="gi">+def set_hook(</span>
<span class="gi">+    fn: Callable[..., Any] | None, key: tuple[str, bool] | str, **kwargs: Any</span>
<span class="gi">+) -&gt; Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Mark decorated function as a hook to be picked up later.
<span class="w"> </span>    You should not need to use this method directly.

<span class="gu">@@ -192,4 +212,20 @@ def set_hook(fn: (Callable[..., Any] | None), key: (tuple[str, bool] | str),</span>
<span class="w"> </span>    :return: Decorated function if supplied, else this decorator with its args
<span class="w"> </span>        bound.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Allow using this as either a decorator or a decorator factory.</span>
<span class="gi">+    if fn is None:</span>
<span class="gi">+        return functools.partial(set_hook, key=key, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    # Set a __marshmallow_hook__ attribute instead of wrapping in some class,</span>
<span class="gi">+    # because I still want this to end up as a normal (unbound) method.</span>
<span class="gi">+    function = cast(MarshmallowHook, fn)</span>
<span class="gi">+    try:</span>
<span class="gi">+        hook_config = function.__marshmallow_hook__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        function.__marshmallow_hook__ = hook_config = {}</span>
<span class="gi">+    # Also save the kwargs for the tagged function on</span>
<span class="gi">+    # __marshmallow_hook__, keyed by (&lt;tag&gt;, &lt;pass_many&gt;)</span>
<span class="gi">+    if hook_config is not None:</span>
<span class="gi">+        hook_config[key] = kwargs</span>
<span class="gi">+</span>
<span class="gi">+    return fn</span>
<span class="gh">diff --git a/src/marshmallow/error_store.py b/src/marshmallow/error_store.py</span>
<span class="gh">index a659aaf..72b7037 100644</span>
<span class="gd">--- a/src/marshmallow/error_store.py</span>
<span class="gi">+++ b/src/marshmallow/error_store.py</span>
<span class="gu">@@ -5,14 +5,25 @@</span>
<span class="w"> </span>    This module is treated as private API.
<span class="w"> </span>    Users should not need to use this module directly.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from marshmallow.exceptions import SCHEMA


<span class="w"> </span>class ErrorStore:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="gi">+        #: Dictionary of errors stored during serialization</span>
<span class="w"> </span>        self.errors = {}

<span class="gi">+    def store_error(self, messages, field_name=SCHEMA, index=None):</span>
<span class="gi">+        # field error  -&gt; store/merge error messages under field name key</span>
<span class="gi">+        # schema error -&gt; if string or list, store/merge under _schema key</span>
<span class="gi">+        #              -&gt; if dict, store/merge with other top-level keys</span>
<span class="gi">+        if field_name != SCHEMA or not isinstance(messages, dict):</span>
<span class="gi">+            messages = {field_name: messages}</span>
<span class="gi">+        if index is not None:</span>
<span class="gi">+            messages = {index: messages}</span>
<span class="gi">+        self.errors = merge_errors(self.errors, messages)</span>
<span class="gi">+</span>

<span class="w"> </span>def merge_errors(errors1, errors2):
<span class="w"> </span>    &quot;&quot;&quot;Deeply merge two error messages.
<span class="gu">@@ -20,4 +31,30 @@ def merge_errors(errors1, errors2):</span>
<span class="w"> </span>    The format of ``errors1`` and ``errors2`` matches the ``message``
<span class="w"> </span>    parameter of :exc:`marshmallow.exceptions.ValidationError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not errors1:</span>
<span class="gi">+        return errors2</span>
<span class="gi">+    if not errors2:</span>
<span class="gi">+        return errors1</span>
<span class="gi">+    if isinstance(errors1, list):</span>
<span class="gi">+        if isinstance(errors2, list):</span>
<span class="gi">+            return errors1 + errors2</span>
<span class="gi">+        if isinstance(errors2, dict):</span>
<span class="gi">+            return dict(errors2, **{SCHEMA: merge_errors(errors1, errors2.get(SCHEMA))})</span>
<span class="gi">+        return errors1 + [errors2]</span>
<span class="gi">+    if isinstance(errors1, dict):</span>
<span class="gi">+        if isinstance(errors2, list):</span>
<span class="gi">+            return dict(errors1, **{SCHEMA: merge_errors(errors1.get(SCHEMA), errors2)})</span>
<span class="gi">+        if isinstance(errors2, dict):</span>
<span class="gi">+            errors = dict(errors1)</span>
<span class="gi">+            for key, val in errors2.items():</span>
<span class="gi">+                if key in errors:</span>
<span class="gi">+                    errors[key] = merge_errors(errors[key], val)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    errors[key] = val</span>
<span class="gi">+            return errors</span>
<span class="gi">+        return dict(errors1, **{SCHEMA: merge_errors(errors1.get(SCHEMA), errors2)})</span>
<span class="gi">+    if isinstance(errors2, list):</span>
<span class="gi">+        return [errors1] + errors2</span>
<span class="gi">+    if isinstance(errors2, dict):</span>
<span class="gi">+        return dict(errors2, **{SCHEMA: merge_errors(errors1, errors2.get(SCHEMA))})</span>
<span class="gi">+    return [errors1, errors2]</span>
<span class="gh">diff --git a/src/marshmallow/exceptions.py b/src/marshmallow/exceptions.py</span>
<span class="gh">index 52e36c1..096b6bd 100644</span>
<span class="gd">--- a/src/marshmallow/exceptions.py</span>
<span class="gi">+++ b/src/marshmallow/exceptions.py</span>
<span class="gu">@@ -1,7 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Exception classes for marshmallow-related errors.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gd">-SCHEMA = &#39;_schema&#39;</span>
<span class="gi">+</span>
<span class="gi">+# Key used for schema-level validation errors</span>
<span class="gi">+SCHEMA = &quot;_schema&quot;</span>


<span class="w"> </span>class MarshmallowError(Exception):
<span class="gu">@@ -21,18 +25,37 @@ class ValidationError(MarshmallowError):</span>
<span class="w"> </span>    :param valid_data: Valid (de)serialized data.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: (str | list | dict), field_name: str=SCHEMA,</span>
<span class="gd">-        data: (typing.Mapping[str, typing.Any] | typing.Iterable[typing.</span>
<span class="gd">-        Mapping[str, typing.Any]] | None)=None, valid_data: (list[dict[str,</span>
<span class="gd">-        typing.Any]] | dict[str, typing.Any] | None)=None, **kwargs):</span>
<span class="gd">-        self.messages = [message] if isinstance(message, (str, bytes)</span>
<span class="gd">-            ) else message</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str | list | dict,</span>
<span class="gi">+        field_name: str = SCHEMA,</span>
<span class="gi">+        data: typing.Mapping[str, typing.Any]</span>
<span class="gi">+        | typing.Iterable[typing.Mapping[str, typing.Any]]</span>
<span class="gi">+        | None = None,</span>
<span class="gi">+        valid_data: list[dict[str, typing.Any]] | dict[str, typing.Any] | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        self.messages = [message] if isinstance(message, (str, bytes)) else message</span>
<span class="w"> </span>        self.field_name = field_name
<span class="w"> </span>        self.data = data
<span class="w"> </span>        self.valid_data = valid_data
<span class="w"> </span>        self.kwargs = kwargs
<span class="w"> </span>        super().__init__(message)

<span class="gi">+    def normalized_messages(self):</span>
<span class="gi">+        if self.field_name == SCHEMA and isinstance(self.messages, dict):</span>
<span class="gi">+            return self.messages</span>
<span class="gi">+        return {self.field_name: self.messages}</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def messages_dict(self) -&gt; dict[str, typing.Any]:</span>
<span class="gi">+        if not isinstance(self.messages, dict):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;cannot access &#39;messages_dict&#39; when &#39;messages&#39; is of type &quot;</span>
<span class="gi">+                + type(self.messages).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+        return self.messages</span>
<span class="gi">+</span>

<span class="w"> </span>class RegistryError(NameError):
<span class="w"> </span>    &quot;&quot;&quot;Raised when an invalid operation is performed on the serializer
<span class="gh">diff --git a/src/marshmallow/fields.py b/src/marshmallow/fields.py</span>
<span class="gh">index 8656a56..ceb32aa 100644</span>
<span class="gd">--- a/src/marshmallow/fields.py</span>
<span class="gi">+++ b/src/marshmallow/fields.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Field classes for various types of data.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import copy
<span class="w"> </span>import datetime as dt
<span class="gu">@@ -12,20 +14,66 @@ import uuid</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from collections.abc import Mapping as _Mapping
<span class="w"> </span>from enum import Enum as EnumType
<span class="gi">+</span>
<span class="w"> </span>from marshmallow import class_registry, types, utils, validate
<span class="w"> </span>from marshmallow.base import FieldABC, SchemaABC
<span class="gd">-from marshmallow.exceptions import FieldInstanceResolutionError, StringNotCollectionError, ValidationError</span>
<span class="gd">-from marshmallow.utils import is_aware, is_collection, resolve_field_instance</span>
<span class="gd">-from marshmallow.utils import missing as missing_</span>
<span class="gi">+from marshmallow.exceptions import (</span>
<span class="gi">+    FieldInstanceResolutionError,</span>
<span class="gi">+    StringNotCollectionError,</span>
<span class="gi">+    ValidationError,</span>
<span class="gi">+)</span>
<span class="gi">+from marshmallow.utils import (</span>
<span class="gi">+    is_aware,</span>
<span class="gi">+    is_collection,</span>
<span class="gi">+    resolve_field_instance,</span>
<span class="gi">+)</span>
<span class="gi">+from marshmallow.utils import (</span>
<span class="gi">+    missing as missing_,</span>
<span class="gi">+)</span>
<span class="w"> </span>from marshmallow.validate import And, Length
<span class="w"> </span>from marshmallow.warnings import RemovedInMarshmallow4Warning
<span class="gd">-__all__ = [&#39;Field&#39;, &#39;Raw&#39;, &#39;Nested&#39;, &#39;Mapping&#39;, &#39;Dict&#39;, &#39;List&#39;, &#39;Tuple&#39;,</span>
<span class="gd">-    &#39;String&#39;, &#39;UUID&#39;, &#39;Number&#39;, &#39;Integer&#39;, &#39;Decimal&#39;, &#39;Boolean&#39;, &#39;Float&#39;,</span>
<span class="gd">-    &#39;DateTime&#39;, &#39;NaiveDateTime&#39;, &#39;AwareDateTime&#39;, &#39;Time&#39;, &#39;Date&#39;,</span>
<span class="gd">-    &#39;TimeDelta&#39;, &#39;Url&#39;, &#39;URL&#39;, &#39;Email&#39;, &#39;IP&#39;, &#39;IPv4&#39;, &#39;IPv6&#39;, &#39;IPInterface&#39;,</span>
<span class="gd">-    &#39;IPv4Interface&#39;, &#39;IPv6Interface&#39;, &#39;Enum&#39;, &#39;Method&#39;, &#39;Function&#39;, &#39;Str&#39;,</span>
<span class="gd">-    &#39;Bool&#39;, &#39;Int&#39;, &#39;Constant&#39;, &#39;Pluck&#39;]</span>
<span class="gd">-_T = typing.TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Field&quot;,</span>
<span class="gi">+    &quot;Raw&quot;,</span>
<span class="gi">+    &quot;Nested&quot;,</span>
<span class="gi">+    &quot;Mapping&quot;,</span>
<span class="gi">+    &quot;Dict&quot;,</span>
<span class="gi">+    &quot;List&quot;,</span>
<span class="gi">+    &quot;Tuple&quot;,</span>
<span class="gi">+    &quot;String&quot;,</span>
<span class="gi">+    &quot;UUID&quot;,</span>
<span class="gi">+    &quot;Number&quot;,</span>
<span class="gi">+    &quot;Integer&quot;,</span>
<span class="gi">+    &quot;Decimal&quot;,</span>
<span class="gi">+    &quot;Boolean&quot;,</span>
<span class="gi">+    &quot;Float&quot;,</span>
<span class="gi">+    &quot;DateTime&quot;,</span>
<span class="gi">+    &quot;NaiveDateTime&quot;,</span>
<span class="gi">+    &quot;AwareDateTime&quot;,</span>
<span class="gi">+    &quot;Time&quot;,</span>
<span class="gi">+    &quot;Date&quot;,</span>
<span class="gi">+    &quot;TimeDelta&quot;,</span>
<span class="gi">+    &quot;Url&quot;,</span>
<span class="gi">+    &quot;URL&quot;,</span>
<span class="gi">+    &quot;Email&quot;,</span>
<span class="gi">+    &quot;IP&quot;,</span>
<span class="gi">+    &quot;IPv4&quot;,</span>
<span class="gi">+    &quot;IPv6&quot;,</span>
<span class="gi">+    &quot;IPInterface&quot;,</span>
<span class="gi">+    &quot;IPv4Interface&quot;,</span>
<span class="gi">+    &quot;IPv6Interface&quot;,</span>
<span class="gi">+    &quot;Enum&quot;,</span>
<span class="gi">+    &quot;Method&quot;,</span>
<span class="gi">+    &quot;Function&quot;,</span>
<span class="gi">+    &quot;Str&quot;,</span>
<span class="gi">+    &quot;Bool&quot;,</span>
<span class="gi">+    &quot;Int&quot;,</span>
<span class="gi">+    &quot;Constant&quot;,</span>
<span class="gi">+    &quot;Pluck&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T = typing.TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class Field(FieldABC):
<span class="gu">@@ -89,34 +137,65 @@ class Field(FieldABC):</span>
<span class="w"> </span>        Add ``data_key`` parameter for the specifying the key in the input and
<span class="w"> </span>        output data. This parameter replaced both ``load_from`` and ``dump_to``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Some fields, such as Method fields and Function fields, are not expected</span>
<span class="gi">+    #  to exist as attributes on the objects to serialize. Set this to False</span>
<span class="gi">+    #  for those fields</span>
<span class="w"> </span>    _CHECK_ATTRIBUTE = True
<span class="gd">-    default_error_messages = {&#39;required&#39;:</span>
<span class="gd">-        &#39;Missing data for required field.&#39;, &#39;null&#39;:</span>
<span class="gd">-        &#39;Field may not be null.&#39;, &#39;validator_failed&#39;: &#39;Invalid value.&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, load_default: typing.Any=missing_, missing:</span>
<span class="gd">-        typing.Any=missing_, dump_default: typing.Any=missing_, default:</span>
<span class="gd">-        typing.Any=missing_, data_key: (str | None)=None, attribute: (str |</span>
<span class="gd">-        None)=None, validate: (None | typing.Callable[[typing.Any], typing.</span>
<span class="gd">-        Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])=</span>
<span class="gd">-        None, required: bool=False, allow_none: (bool | None)=None,</span>
<span class="gd">-        load_only: bool=False, dump_only: bool=False, error_messages: (dict</span>
<span class="gd">-        [str, str] | None)=None, metadata: (typing.Mapping[str, typing.Any] |</span>
<span class="gd">-        None)=None, **additional_metadata) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages for various kinds of errors. The keys in this dictionary</span>
<span class="gi">+    #: are passed to `Field.make_error`. The values are error messages passed to</span>
<span class="gi">+    #: :exc:`marshmallow.exceptions.ValidationError`.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;required&quot;: &quot;Missing data for required field.&quot;,</span>
<span class="gi">+        &quot;null&quot;: &quot;Field may not be null.&quot;,</span>
<span class="gi">+        &quot;validator_failed&quot;: &quot;Invalid value.&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        load_default: typing.Any = missing_,</span>
<span class="gi">+        missing: typing.Any = missing_,</span>
<span class="gi">+        dump_default: typing.Any = missing_,</span>
<span class="gi">+        default: typing.Any = missing_,</span>
<span class="gi">+        data_key: str | None = None,</span>
<span class="gi">+        attribute: str | None = None,</span>
<span class="gi">+        validate: (</span>
<span class="gi">+            None</span>
<span class="gi">+            | typing.Callable[[typing.Any], typing.Any]</span>
<span class="gi">+            | typing.Iterable[typing.Callable[[typing.Any], typing.Any]]</span>
<span class="gi">+        ) = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        allow_none: bool | None = None,</span>
<span class="gi">+        load_only: bool = False,</span>
<span class="gi">+        dump_only: bool = False,</span>
<span class="gi">+        error_messages: dict[str, str] | None = None,</span>
<span class="gi">+        metadata: typing.Mapping[str, typing.Any] | None = None,</span>
<span class="gi">+        **additional_metadata,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # handle deprecated `default` and `missing` parameters</span>
<span class="w"> </span>        if default is not missing_:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &quot;The &#39;default&#39; argument to fields is deprecated. Use &#39;dump_default&#39; instead.&quot;</span>
<span class="gd">-                , RemovedInMarshmallow4Warning, stacklevel=2)</span>
<span class="gi">+                &quot;The &#39;default&#39; argument to fields is deprecated. &quot;</span>
<span class="gi">+                &quot;Use &#39;dump_default&#39; instead.&quot;,</span>
<span class="gi">+                RemovedInMarshmallow4Warning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if dump_default is missing_:
<span class="w"> </span>                dump_default = default
<span class="w"> </span>        if missing is not missing_:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &quot;The &#39;missing&#39; argument to fields is deprecated. Use &#39;load_default&#39; instead.&quot;</span>
<span class="gd">-                , RemovedInMarshmallow4Warning, stacklevel=2)</span>
<span class="gi">+                &quot;The &#39;missing&#39; argument to fields is deprecated. &quot;</span>
<span class="gi">+                &quot;Use &#39;load_default&#39; instead.&quot;,</span>
<span class="gi">+                RemovedInMarshmallow4Warning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if load_default is missing_:
<span class="w"> </span>                load_default = missing
<span class="w"> </span>        self.dump_default = dump_default
<span class="w"> </span>        self.load_default = load_default
<span class="gi">+</span>
<span class="w"> </span>        self.attribute = attribute
<span class="w"> </span>        self.data_key = data_key
<span class="w"> </span>        self.validate = validate
<span class="gu">@@ -128,32 +207,46 @@ class Field(FieldABC):</span>
<span class="w"> </span>            self.validators = list(validate)
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &quot;The &#39;validate&#39; parameter must be a callable or a collection of callables.&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-        self.allow_none = (load_default is None if allow_none is None else</span>
<span class="gd">-            allow_none)</span>
<span class="gi">+                &quot;The &#39;validate&#39; parameter must be a callable &quot;</span>
<span class="gi">+                &quot;or a collection of callables.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # If allow_none is None and load_default is None</span>
<span class="gi">+        # None should be considered valid by default</span>
<span class="gi">+        self.allow_none = load_default is None if allow_none is None else allow_none</span>
<span class="w"> </span>        self.load_only = load_only
<span class="w"> </span>        self.dump_only = dump_only
<span class="w"> </span>        if required is True and load_default is not missing_:
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &quot;&#39;load_default&#39; must not be set for required fields.&quot;)</span>
<span class="gi">+            raise ValueError(&quot;&#39;load_default&#39; must not be set for required fields.&quot;)</span>
<span class="w"> </span>        self.required = required
<span class="gi">+</span>
<span class="w"> </span>        metadata = metadata or {}
<span class="w"> </span>        self.metadata = {**metadata, **additional_metadata}
<span class="w"> </span>        if additional_metadata:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                f&#39;Passing field metadata as keyword arguments is deprecated. Use the explicit `metadata=...` argument instead. Additional metadata: {additional_metadata}&#39;</span>
<span class="gd">-                , RemovedInMarshmallow4Warning, stacklevel=2)</span>
<span class="gd">-        messages = {}</span>
<span class="gi">+                &quot;Passing field metadata as keyword arguments is deprecated. Use the &quot;</span>
<span class="gi">+                &quot;explicit `metadata=...` argument instead. &quot;</span>
<span class="gi">+                f&quot;Additional metadata: {additional_metadata}&quot;,</span>
<span class="gi">+                RemovedInMarshmallow4Warning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Collect default error message from self and parent classes</span>
<span class="gi">+        messages = {}  # type: dict[str, str]</span>
<span class="w"> </span>        for cls in reversed(self.__class__.__mro__):
<span class="gd">-            messages.update(getattr(cls, &#39;default_error_messages&#39;, {}))</span>
<span class="gi">+            messages.update(getattr(cls, &quot;default_error_messages&quot;, {}))</span>
<span class="w"> </span>        messages.update(error_messages or {})
<span class="w"> </span>        self.error_messages = messages

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;&lt;fields.{self.__class__.__name__}(dump_default={self.dump_default!r}, attribute={self.attribute!r}, validate={self.validate}, required={self.required}, load_only={self.load_only}, dump_only={self.dump_only}, load_default={self.load_default}, allow_none={self.allow_none}, error_messages={self.error_messages})&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;&lt;fields.{self.__class__.__name__}(dump_default={self.dump_default!r}, &quot;</span>
<span class="gi">+            f&quot;attribute={self.attribute!r}, &quot;</span>
<span class="gi">+            f&quot;validate={self.validate}, required={self.required}, &quot;</span>
<span class="gi">+            f&quot;load_only={self.load_only}, dump_only={self.dump_only}, &quot;</span>
<span class="gi">+            f&quot;load_default={self.load_default}, allow_none={self.allow_none}, &quot;</span>
<span class="gi">+            f&quot;error_messages={self.error_messages})&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __deepcopy__(self, memo):
<span class="w"> </span>        return copy.copy(self)
<span class="gu">@@ -166,19 +259,36 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param callable accessor: A callable used to retrieve the value of `attr` from
<span class="w"> </span>            the object `obj`. Defaults to `marshmallow.utils.get_value`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        accessor_func = accessor or utils.get_value</span>
<span class="gi">+        check_key = attr if self.attribute is None else self.attribute</span>
<span class="gi">+        return accessor_func(obj, check_key, default)</span>

<span class="w"> </span>    def _validate(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Perform validation on ``value``. Raise a :exc:`ValidationError` if validation
<span class="w"> </span>        does not succeed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._validate_all(value)</span>

<span class="gd">-    def make_error(self, key: str, **kwargs) -&gt;ValidationError:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _validate_all(self):</span>
<span class="gi">+        return And(*self.validators, error=self.error_messages[&quot;validator_failed&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    def make_error(self, key: str, **kwargs) -&gt; ValidationError:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helper method to make a `ValidationError` with an error message
<span class="w"> </span>        from ``self.error_messages``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            msg = self.error_messages[key]</span>
<span class="gi">+        except KeyError as error:</span>
<span class="gi">+            class_name = self.__class__.__name__</span>
<span class="gi">+            message = (</span>
<span class="gi">+                f&quot;ValidationError raised by `{class_name}`, but error key `{key}` does &quot;</span>
<span class="gi">+                &quot;not exist in the `error_messages` dictionary.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise AssertionError(message) from error</span>
<span class="gi">+        if isinstance(msg, (str, bytes)):</span>
<span class="gi">+            msg = msg.format(**kwargs)</span>
<span class="gi">+        return ValidationError(msg)</span>

<span class="w"> </span>    def fail(self, key: str, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Helper method that raises a `ValidationError` with an error message
<span class="gu">@@ -187,17 +297,30 @@ class Field(FieldABC):</span>
<span class="w"> </span>        .. deprecated:: 3.0.0
<span class="w"> </span>            Use `make_error &lt;marshmallow.fields.Field.make_error&gt;` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            f&#39;`Field.fail` is deprecated. Use `raise self.make_error(&quot;{key}&quot;, ...)` instead.&#39;,</span>
<span class="gi">+            RemovedInMarshmallow4Warning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        raise self.make_error(key=key, **kwargs)</span>

<span class="w"> </span>    def _validate_missing(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Validate missing values. Raise a :exc:`ValidationError` if
<span class="w"> </span>        `value` should be considered missing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def serialize(self, attr: str, obj: typing.Any, accessor: (typing.</span>
<span class="gd">-        Callable[[typing.Any, str, typing.Any], typing.Any] | None)=None,</span>
<span class="gd">-        **kwargs):</span>
<span class="gi">+        if value is missing_ and self.required:</span>
<span class="gi">+            raise self.make_error(&quot;required&quot;)</span>
<span class="gi">+        if value is None and not self.allow_none:</span>
<span class="gi">+            raise self.make_error(&quot;null&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def serialize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        attr: str,</span>
<span class="gi">+        obj: typing.Any,</span>
<span class="gi">+        accessor: typing.Callable[[typing.Any, str, typing.Any], typing.Any]</span>
<span class="gi">+        | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Pulls the value for the given key from the object, applies the
<span class="w"> </span>        field&#39;s formatting and returns the result.

<span class="gu">@@ -206,10 +329,24 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param accessor: Function used to access values from ``obj``.
<span class="w"> </span>        :param kwargs: Field-specific keyword arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def deserialize(self, value: typing.Any, attr: (str | None)=None, data:</span>
<span class="gd">-        (typing.Mapping[str, typing.Any] | None)=None, **kwargs):</span>
<span class="gi">+        if self._CHECK_ATTRIBUTE:</span>
<span class="gi">+            value = self.get_value(obj, attr, accessor=accessor)</span>
<span class="gi">+            if value is missing_:</span>
<span class="gi">+                default = self.dump_default</span>
<span class="gi">+                value = default() if callable(default) else default</span>
<span class="gi">+            if value is missing_:</span>
<span class="gi">+                return value</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = None</span>
<span class="gi">+        return self._serialize(value, attr, obj, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def deserialize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: typing.Any,</span>
<span class="gi">+        attr: str | None = None,</span>
<span class="gi">+        data: typing.Mapping[str, typing.Any] | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize ``value``.

<span class="w"> </span>        :param value: The value to deserialize.
<span class="gu">@@ -219,7 +356,19 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :raise ValidationError: If an invalid value is passed or if a required value
<span class="w"> </span>            is missing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Validate required fields, deserialize, then validate</span>
<span class="gi">+        # deserialized value</span>
<span class="gi">+        self._validate_missing(value)</span>
<span class="gi">+        if value is missing_:</span>
<span class="gi">+            _miss = self.load_default</span>
<span class="gi">+            return _miss() if callable(_miss) else _miss</span>
<span class="gi">+        if self.allow_none and value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        output = self._deserialize(value, attr, data, **kwargs)</span>
<span class="gi">+        self._validate(output)</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    # Methods for concrete classes to override.</span>

<span class="w"> </span>    def _bind_to_schema(self, field_name, schema):
<span class="w"> </span>        &quot;&quot;&quot;Update field with values from its parent schema. Called by
<span class="gu">@@ -228,10 +377,15 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param str field_name: Field name set in schema.
<span class="w"> </span>        :param Schema|Field schema: Parent object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _serialize(self, value: typing.Any, attr: (str | None), obj: typing</span>
<span class="gd">-        .Any, **kwargs):</span>
<span class="gi">+        self.parent = self.parent or schema</span>
<span class="gi">+        self.name = self.name or field_name</span>
<span class="gi">+        self.root = self.root or (</span>
<span class="gi">+            self.parent.root if isinstance(self.parent, FieldABC) else self.parent</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(</span>
<span class="gi">+        self, value: typing.Any, attr: str | None, obj: typing.Any, **kwargs</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Serializes ``value`` to a basic Python datatype. Noop by default.
<span class="w"> </span>        Concrete :class:`Field` classes should implement this method.

<span class="gu">@@ -249,10 +403,15 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param dict kwargs: Field-specific keyword arguments.
<span class="w"> </span>        :return: The serialized value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _deserialize(self, value: typing.Any, attr: (str | None), data: (</span>
<span class="gd">-        typing.Mapping[str, typing.Any] | None), **kwargs):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: typing.Any,</span>
<span class="gi">+        attr: str | None,</span>
<span class="gi">+        data: typing.Mapping[str, typing.Any] | None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize value. Concrete :class:`Field` classes should implement this method.

<span class="w"> </span>        :param value: The value to be deserialized.
<span class="gu">@@ -268,12 +427,56 @@ class Field(FieldABC):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0
<span class="w"> </span>            Added ``**kwargs`` to signature.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    # Properties</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def context(self):
<span class="w"> </span>        &quot;&quot;&quot;The context dictionary for the parent :class:`Schema`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.parent.context</span>
<span class="gi">+</span>
<span class="gi">+    # the default and missing properties are provided for compatibility and</span>
<span class="gi">+    # emit warnings when they are accessed and set</span>
<span class="gi">+    @property</span>
<span class="gi">+    def default(self):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The &#39;default&#39; attribute of fields is deprecated. &quot;</span>
<span class="gi">+            &quot;Use &#39;dump_default&#39; instead.&quot;,</span>
<span class="gi">+            RemovedInMarshmallow4Warning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.dump_default</span>
<span class="gi">+</span>
<span class="gi">+    @default.setter</span>
<span class="gi">+    def default(self, value):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The &#39;default&#39; attribute of fields is deprecated. &quot;</span>
<span class="gi">+            &quot;Use &#39;dump_default&#39; instead.&quot;,</span>
<span class="gi">+            RemovedInMarshmallow4Warning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.dump_default = value</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def missing(self):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The &#39;missing&#39; attribute of fields is deprecated. &quot;</span>
<span class="gi">+            &quot;Use &#39;load_default&#39; instead.&quot;,</span>
<span class="gi">+            RemovedInMarshmallow4Warning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.load_default</span>
<span class="gi">+</span>
<span class="gi">+    @missing.setter</span>
<span class="gi">+    def missing(self, value):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The &#39;missing&#39; attribute of fields is deprecated. &quot;</span>
<span class="gi">+            &quot;Use &#39;load_default&#39; instead.&quot;,</span>
<span class="gi">+            RemovedInMarshmallow4Warning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.load_default = value</span>


<span class="w"> </span>class Raw(Field):
<span class="gu">@@ -325,30 +528,46 @@ class Nested(Field):</span>
<span class="w"> </span>        fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Field` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;type&#39;: &#39;Invalid type.&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, nested: (SchemaABC | type | str | dict[str, Field |</span>
<span class="gd">-        type] | typing.Callable[[], SchemaABC | type | dict[str, Field |</span>
<span class="gd">-        type]]), *, dump_default: typing.Any=missing_, default: typing.Any=</span>
<span class="gd">-        missing_, only: (types.StrSequenceOrSet | None)=None, exclude:</span>
<span class="gd">-        types.StrSequenceOrSet=(), many: bool=False, unknown: (str | None)=</span>
<span class="gd">-        None, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;type&quot;: &quot;Invalid type.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nested: SchemaABC</span>
<span class="gi">+        | type</span>
<span class="gi">+        | str</span>
<span class="gi">+        | dict[str, Field | type]</span>
<span class="gi">+        | typing.Callable[[], SchemaABC | type | dict[str, Field | type]],</span>
<span class="gi">+        *,</span>
<span class="gi">+        dump_default: typing.Any = missing_,</span>
<span class="gi">+        default: typing.Any = missing_,</span>
<span class="gi">+        only: types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        exclude: types.StrSequenceOrSet = (),</span>
<span class="gi">+        many: bool = False,</span>
<span class="gi">+        unknown: str | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Raise error if only or exclude is passed as string, not list of strings</span>
<span class="w"> </span>        if only is not None and not is_collection(only):
<span class="gd">-            raise StringNotCollectionError(</span>
<span class="gd">-                &#39;&quot;only&quot; should be a collection of strings.&#39;)</span>
<span class="gi">+            raise StringNotCollectionError(&#39;&quot;only&quot; should be a collection of strings.&#39;)</span>
<span class="w"> </span>        if not is_collection(exclude):
<span class="w"> </span>            raise StringNotCollectionError(
<span class="gd">-                &#39;&quot;exclude&quot; should be a collection of strings.&#39;)</span>
<span class="gd">-        if nested == &#39;self&#39;:</span>
<span class="gi">+                &#39;&quot;exclude&quot; should be a collection of strings.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        if nested == &quot;self&quot;:</span>
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &quot;Passing &#39;self&#39; to `Nested` is deprecated. Use `Nested(lambda: MySchema(...))` instead.&quot;</span>
<span class="gd">-                , RemovedInMarshmallow4Warning, stacklevel=2)</span>
<span class="gi">+                &quot;Passing &#39;self&#39; to `Nested` is deprecated. &quot;</span>
<span class="gi">+                &quot;Use `Nested(lambda: MySchema(...))` instead.&quot;,</span>
<span class="gi">+                RemovedInMarshmallow4Warning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self.nested = nested
<span class="w"> </span>        self.only = only
<span class="w"> </span>        self.exclude = exclude
<span class="w"> </span>        self.many = many
<span class="w"> </span>        self.unknown = unknown
<span class="gd">-        self._schema = None</span>
<span class="gi">+        self._schema = None  # Cached Schema instance</span>
<span class="w"> </span>        super().__init__(default=default, dump_default=dump_default, **kwargs)

<span class="w"> </span>    @property
<span class="gu">@@ -358,7 +577,86 @@ class Nested(Field):</span>
<span class="w"> </span>        .. versionchanged:: 1.0.0
<span class="w"> </span>            Renamed from `serializer` to `schema`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._schema:</span>
<span class="gi">+            # Inherit context from parent.</span>
<span class="gi">+            context = getattr(self.parent, &quot;context&quot;, {})</span>
<span class="gi">+            if callable(self.nested) and not isinstance(self.nested, type):</span>
<span class="gi">+                nested = self.nested()</span>
<span class="gi">+            else:</span>
<span class="gi">+                nested = self.nested</span>
<span class="gi">+            if isinstance(nested, dict):</span>
<span class="gi">+                # defer the import of `marshmallow.schema` to avoid circular imports</span>
<span class="gi">+                from marshmallow.schema import Schema</span>
<span class="gi">+</span>
<span class="gi">+                nested = Schema.from_dict(nested)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(nested, SchemaABC):</span>
<span class="gi">+                self._schema = copy.copy(nested)</span>
<span class="gi">+                self._schema.context.update(context)</span>
<span class="gi">+                # Respect only and exclude passed from parent and re-initialize fields</span>
<span class="gi">+                set_class = self._schema.set_class</span>
<span class="gi">+                if self.only is not None:</span>
<span class="gi">+                    if self._schema.only is not None:</span>
<span class="gi">+                        original = self._schema.only</span>
<span class="gi">+                    else:  # only=None -&gt; all fields</span>
<span class="gi">+                        original = self._schema.fields.keys()</span>
<span class="gi">+                    self._schema.only = set_class(self.only) &amp; set_class(original)</span>
<span class="gi">+                if self.exclude:</span>
<span class="gi">+                    original = self._schema.exclude</span>
<span class="gi">+                    self._schema.exclude = set_class(self.exclude) | set_class(original)</span>
<span class="gi">+                self._schema._init_fields()</span>
<span class="gi">+            else:</span>
<span class="gi">+                if isinstance(nested, type) and issubclass(nested, SchemaABC):</span>
<span class="gi">+                    schema_class = nested</span>
<span class="gi">+                elif not isinstance(nested, (str, bytes)):</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;`Nested` fields must be passed a &quot;</span>
<span class="gi">+                        f&quot;`Schema`, not {nested.__class__}.&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif nested == &quot;self&quot;:</span>
<span class="gi">+                    schema_class = self.root.__class__</span>
<span class="gi">+                else:</span>
<span class="gi">+                    schema_class = class_registry.get_class(nested)</span>
<span class="gi">+                self._schema = schema_class(</span>
<span class="gi">+                    many=self.many,</span>
<span class="gi">+                    only=self.only,</span>
<span class="gi">+                    exclude=self.exclude,</span>
<span class="gi">+                    context=context,</span>
<span class="gi">+                    load_only=self._nested_normalized_option(&quot;load_only&quot;),</span>
<span class="gi">+                    dump_only=self._nested_normalized_option(&quot;dump_only&quot;),</span>
<span class="gi">+                )</span>
<span class="gi">+        return self._schema</span>
<span class="gi">+</span>
<span class="gi">+    def _nested_normalized_option(self, option_name: str) -&gt; list[str]:</span>
<span class="gi">+        nested_field = f&quot;{self.name}.&quot;</span>
<span class="gi">+        return [</span>
<span class="gi">+            field.split(nested_field, 1)[1]</span>
<span class="gi">+            for field in getattr(self.root, option_name, set())</span>
<span class="gi">+            if field.startswith(nested_field)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, nested_obj, attr, obj, **kwargs):</span>
<span class="gi">+        # Load up the schema first. This allows a RegistryError to be raised</span>
<span class="gi">+        # if an invalid schema name was passed</span>
<span class="gi">+        schema = self.schema</span>
<span class="gi">+        if nested_obj is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        many = schema.many or self.many</span>
<span class="gi">+        return schema.dump(nested_obj, many=many)</span>
<span class="gi">+</span>
<span class="gi">+    def _test_collection(self, value):</span>
<span class="gi">+        many = self.schema.many or self.many</span>
<span class="gi">+        if many and not utils.is_collection(value):</span>
<span class="gi">+            raise self.make_error(&quot;type&quot;, input=value, type=value.__class__.__name__)</span>
<span class="gi">+</span>
<span class="gi">+    def _load(self, value, data, partial=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            valid_data = self.schema.load(value, unknown=self.unknown, partial=partial)</span>
<span class="gi">+        except ValidationError as error:</span>
<span class="gi">+            raise ValidationError(</span>
<span class="gi">+                error.messages, valid_data=error.valid_data</span>
<span class="gi">+            ) from error</span>
<span class="gi">+        return valid_data</span>

<span class="w"> </span>    def _deserialize(self, value, attr, data, partial=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Same as :meth:`Field._deserialize` with additional ``partial`` argument.
<span class="gu">@@ -369,7 +667,8 @@ class Nested(Field):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0
<span class="w"> </span>            Add ``partial`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._test_collection(value)</span>
<span class="gi">+        return self._load(value, data, partial=partial)</span>


<span class="w"> </span>class Pluck(Nested):
<span class="gu">@@ -399,11 +698,36 @@ class Pluck(Nested):</span>
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Nested` receives.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, nested: (SchemaABC | type | str | typing.Callable[[],</span>
<span class="gd">-        SchemaABC]), field_name: str, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nested: SchemaABC | type | str | typing.Callable[[], SchemaABC],</span>
<span class="gi">+        field_name: str,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(nested, only=(field_name,), **kwargs)
<span class="w"> </span>        self.field_name = field_name

<span class="gi">+    @property</span>
<span class="gi">+    def _field_data_key(self):</span>
<span class="gi">+        only_field = self.schema.fields[self.field_name]</span>
<span class="gi">+        return only_field.data_key or self.field_name</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, nested_obj, attr, obj, **kwargs):</span>
<span class="gi">+        ret = super()._serialize(nested_obj, attr, obj, **kwargs)</span>
<span class="gi">+        if ret is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if self.many:</span>
<span class="gi">+            return utils.pluck(ret, key=self._field_data_key)</span>
<span class="gi">+        return ret[self._field_data_key]</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, partial=None, **kwargs):</span>
<span class="gi">+        self._test_collection(value)</span>
<span class="gi">+        if self.many:</span>
<span class="gi">+            value = [{self._field_data_key: v} for v in value]</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = {self._field_data_key: value}</span>
<span class="gi">+        return self._load(value, data, partial=partial)</span>
<span class="gi">+</span>

<span class="w"> </span>class List(Field):
<span class="w"> </span>    &quot;&quot;&quot;A list field, composed with another `Field` class or
<span class="gu">@@ -423,20 +747,53 @@ class List(Field):</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0rc9
<span class="w"> </span>        Does not serialize scalar values to single-item lists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid list.&#39;}</span>

<span class="gd">-    def __init__(self, cls_or_instance: (Field | type), **kwargs):</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid list.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, cls_or_instance: Field | type, **kwargs):</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        try:
<span class="w"> </span>            self.inner = resolve_field_instance(cls_or_instance)
<span class="w"> </span>        except FieldInstanceResolutionError as error:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;The list elements must be a subclass or instance of marshmallow.base.FieldABC.&#39;</span>
<span class="gd">-                ) from error</span>
<span class="gi">+                &quot;The list elements must be a subclass or instance of &quot;</span>
<span class="gi">+                &quot;marshmallow.base.FieldABC.&quot;</span>
<span class="gi">+            ) from error</span>
<span class="w"> </span>        if isinstance(self.inner, Nested):
<span class="w"> </span>            self.only = self.inner.only
<span class="w"> </span>            self.exclude = self.inner.exclude

<span class="gi">+    def _bind_to_schema(self, field_name, schema):</span>
<span class="gi">+        super()._bind_to_schema(field_name, schema)</span>
<span class="gi">+        self.inner = copy.deepcopy(self.inner)</span>
<span class="gi">+        self.inner._bind_to_schema(field_name, self)</span>
<span class="gi">+        if isinstance(self.inner, Nested):</span>
<span class="gi">+            self.inner.only = self.only</span>
<span class="gi">+            self.inner.exclude = self.exclude</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; list[typing.Any] | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return [self.inner._serialize(each, attr, obj, **kwargs) for each in value]</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; list[typing.Any]:</span>
<span class="gi">+        if not utils.is_collection(value):</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        result = []</span>
<span class="gi">+        errors = {}</span>
<span class="gi">+        for idx, each in enumerate(value):</span>
<span class="gi">+            try:</span>
<span class="gi">+                result.append(self.inner.deserialize(each, **kwargs))</span>
<span class="gi">+            except ValidationError as error:</span>
<span class="gi">+                if error.valid_data is not None:</span>
<span class="gi">+                    result.append(error.valid_data)</span>
<span class="gi">+                errors.update({idx: error.messages})</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            raise ValidationError(errors, valid_data=result)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class Tuple(Field):
<span class="w"> </span>    &quot;&quot;&quot;A tuple field, composed of a fixed number of other `Field` classes or
<span class="gu">@@ -457,40 +814,118 @@ class Tuple(Field):</span>

<span class="w"> </span>    .. versionadded:: 3.0.0rc4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid tuple.&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid tuple.&quot;}</span>

<span class="w"> </span>    def __init__(self, tuple_fields, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        if not utils.is_collection(tuple_fields):
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;tuple_fields must be an iterable of Field classes or instances.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;tuple_fields must be an iterable of Field classes or &quot; &quot;instances.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="gd">-            self.tuple_fields = [resolve_field_instance(cls_or_instance) for</span>
<span class="gd">-                cls_or_instance in tuple_fields]</span>
<span class="gi">+            self.tuple_fields = [</span>
<span class="gi">+                resolve_field_instance(cls_or_instance)</span>
<span class="gi">+                for cls_or_instance in tuple_fields</span>
<span class="gi">+            ]</span>
<span class="w"> </span>        except FieldInstanceResolutionError as error:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;Elements of &quot;tuple_fields&quot; must be subclasses or instances of marshmallow.base.FieldABC.&#39;</span>
<span class="gd">-                ) from error</span>
<span class="gi">+                &#39;Elements of &quot;tuple_fields&quot; must be subclasses or &#39;</span>
<span class="gi">+                &quot;instances of marshmallow.base.FieldABC.&quot;</span>
<span class="gi">+            ) from error</span>
<span class="gi">+</span>
<span class="w"> </span>        self.validate_length = Length(equal=len(self.tuple_fields))

<span class="gi">+    def _bind_to_schema(self, field_name, schema):</span>
<span class="gi">+        super()._bind_to_schema(field_name, schema)</span>
<span class="gi">+        new_tuple_fields = []</span>
<span class="gi">+        for field in self.tuple_fields:</span>
<span class="gi">+            field = copy.deepcopy(field)</span>
<span class="gi">+            field._bind_to_schema(field_name, self)</span>
<span class="gi">+            new_tuple_fields.append(field)</span>
<span class="gi">+</span>
<span class="gi">+        self.tuple_fields = new_tuple_fields</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; tuple | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            field._serialize(each, attr, obj, **kwargs)</span>
<span class="gi">+            for field, each in zip(self.tuple_fields, value)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; tuple:</span>
<span class="gi">+        if not utils.is_collection(value):</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.validate_length(value)</span>
<span class="gi">+</span>
<span class="gi">+        result = []</span>
<span class="gi">+        errors = {}</span>
<span class="gi">+</span>
<span class="gi">+        for idx, (field, each) in enumerate(zip(self.tuple_fields, value)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                result.append(field.deserialize(each, **kwargs))</span>
<span class="gi">+            except ValidationError as error:</span>
<span class="gi">+                if error.valid_data is not None:</span>
<span class="gi">+                    result.append(error.valid_data)</span>
<span class="gi">+                errors.update({idx: error.messages})</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            raise ValidationError(errors, valid_data=result)</span>
<span class="gi">+</span>
<span class="gi">+        return tuple(result)</span>
<span class="gi">+</span>

<span class="w"> </span>class String(Field):
<span class="w"> </span>    &quot;&quot;&quot;A string field.

<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Field` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid string.&#39;,</span>
<span class="gd">-        &#39;invalid_utf8&#39;: &#39;Not a valid utf-8 string.&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;invalid&quot;: &quot;Not a valid string.&quot;,</span>
<span class="gi">+        &quot;invalid_utf8&quot;: &quot;Not a valid utf-8 string.&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; str | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return utils.ensure_text_type(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; typing.Any:</span>
<span class="gi">+        if not isinstance(value, (str, bytes)):</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return utils.ensure_text_type(value)</span>
<span class="gi">+        except UnicodeDecodeError as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid_utf8&quot;) from error</span>


<span class="w"> </span>class UUID(String):
<span class="w"> </span>    &quot;&quot;&quot;A UUID field.&quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_uuid&#39;: &#39;Not a valid UUID.&#39;}</span>

<span class="gd">-    def _validated(self, value) -&gt;(uuid.UUID | None):</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid_uuid&quot;: &quot;Not a valid UUID.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def _validated(self, value) -&gt; uuid.UUID | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format the value or raise a :exc:`ValidationError` if an error occurs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if isinstance(value, uuid.UUID):</span>
<span class="gi">+            return value</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(value, bytes) and len(value) == 16:</span>
<span class="gi">+                return uuid.UUID(bytes=value)</span>
<span class="gi">+            return uuid.UUID(value)</span>
<span class="gi">+        except (ValueError, AttributeError, TypeError) as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid_uuid&quot;) from error</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; uuid.UUID | None:</span>
<span class="gi">+        return self._validated(value)</span>


<span class="w"> </span>class Number(Field):
<span class="gu">@@ -499,25 +934,49 @@ class Number(Field):</span>
<span class="w"> </span>    :param bool as_string: If `True`, format the serialized value as a string.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Field` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    num_type = float</span>
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid number.&#39;, &#39;too_large&#39;:</span>
<span class="gd">-        &#39;Number too large.&#39;}</span>

<span class="gd">-    def __init__(self, *, as_string: bool=False, **kwargs):</span>
<span class="gi">+    num_type = float  # type: typing.Type</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;invalid&quot;: &quot;Not a valid number.&quot;,</span>
<span class="gi">+        &quot;too_large&quot;: &quot;Number too large.&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *, as_string: bool = False, **kwargs):</span>
<span class="w"> </span>        self.as_string = as_string
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gd">-    def _format_num(self, value) -&gt;typing.Any:</span>
<span class="gi">+    def _format_num(self, value) -&gt; typing.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the number value for value, given this field&#39;s `num_type`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.num_type(value)</span>

<span class="gd">-    def _validated(self, value) -&gt;(_T | None):</span>
<span class="gi">+    def _validated(self, value) -&gt; _T | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format the value or raise a :exc:`ValidationError` if an error occurs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        # (value is True or value is False) is ~5x faster than isinstance(value, bool)</span>
<span class="gi">+        if value is True or value is False:</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;, input=value)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._format_num(value)</span>
<span class="gi">+        except (TypeError, ValueError) as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;, input=value) from error</span>
<span class="gi">+        except OverflowError as error:</span>
<span class="gi">+            raise self.make_error(&quot;too_large&quot;, input=value) from error</span>

<span class="gd">-    def _serialize(self, value, attr, obj, **kwargs) -&gt;(str | _T | None):</span>
<span class="gi">+    def _to_string(self, value) -&gt; str:</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; str | _T | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string if `self.as_string=True`, otherwise return this field&#39;s `num_type`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        ret = self._format_num(value)  # type: _T</span>
<span class="gi">+        return self._to_string(ret) if self.as_string else ret</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; _T | None:</span>
<span class="gi">+        return self._validated(value)</span>


<span class="w"> </span>class Integer(Number):
<span class="gu">@@ -527,13 +986,22 @@ class Integer(Number):</span>
<span class="w"> </span>        Otherwise, any value castable to `int` is valid.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Number` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    num_type = int
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid integer.&#39;}</span>

<span class="gd">-    def __init__(self, *, strict: bool=False, **kwargs):</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid integer.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *, strict: bool = False, **kwargs):</span>
<span class="w"> </span>        self.strict = strict
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gi">+    # override Number</span>
<span class="gi">+    def _validated(self, value):</span>
<span class="gi">+        if self.strict and not isinstance(value, numbers.Integral):</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;, input=value)</span>
<span class="gi">+        return super()._validated(value)</span>
<span class="gi">+</span>

<span class="w"> </span>class Float(Number):
<span class="w"> </span>    &quot;&quot;&quot;A double as an IEEE-754 double precision string.
<span class="gu">@@ -543,15 +1011,25 @@ class Float(Number):</span>
<span class="w"> </span>    :param bool as_string: If `True`, format the value as a string.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Number` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    num_type = float
<span class="gd">-    default_error_messages = {&#39;special&#39;:</span>
<span class="gd">-        &#39;Special numeric values (nan or infinity) are not permitted.&#39;}</span>

<span class="gd">-    def __init__(self, *, allow_nan: bool=False, as_string: bool=False, **</span>
<span class="gd">-        kwargs):</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;special&quot;: &quot;Special numeric values (nan or infinity) are not permitted.&quot;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *, allow_nan: bool = False, as_string: bool = False, **kwargs):</span>
<span class="w"> </span>        self.allow_nan = allow_nan
<span class="w"> </span>        super().__init__(as_string=as_string, **kwargs)

<span class="gi">+    def _validated(self, value):</span>
<span class="gi">+        num = super()._validated(value)</span>
<span class="gi">+        if self.allow_nan is False:</span>
<span class="gi">+            if math.isnan(num) or num == float(&quot;inf&quot;) or num == float(&quot;-inf&quot;):</span>
<span class="gi">+                raise self.make_error(&quot;special&quot;)</span>
<span class="gi">+        return num</span>
<span class="gi">+</span>

<span class="w"> </span>class Decimal(Number):
<span class="w"> </span>    &quot;&quot;&quot;A field that (de)serializes to the Python ``decimal.Decimal`` type.
<span class="gu">@@ -589,18 +1067,54 @@ class Decimal(Number):</span>

<span class="w"> </span>    .. versionadded:: 1.2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    num_type = decimal.Decimal
<span class="gd">-    default_error_messages = {&#39;special&#39;:</span>
<span class="gd">-        &#39;Special numeric values (nan or infinity) are not permitted.&#39;}</span>

<span class="gd">-    def __init__(self, places: (int | None)=None, rounding: (str | None)=</span>
<span class="gd">-        None, *, allow_nan: bool=False, as_string: bool=False, **kwargs):</span>
<span class="gd">-        self.places = decimal.Decimal((0, (1,), -places)</span>
<span class="gd">-            ) if places is not None else None</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;special&quot;: &quot;Special numeric values (nan or infinity) are not permitted.&quot;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        places: int | None = None,</span>
<span class="gi">+        rounding: str | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        allow_nan: bool = False,</span>
<span class="gi">+        as_string: bool = False,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        self.places = (</span>
<span class="gi">+            decimal.Decimal((0, (1,), -places)) if places is not None else None</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.rounding = rounding
<span class="w"> </span>        self.allow_nan = allow_nan
<span class="w"> </span>        super().__init__(as_string=as_string, **kwargs)

<span class="gi">+    # override Number</span>
<span class="gi">+    def _format_num(self, value):</span>
<span class="gi">+        num = decimal.Decimal(str(value))</span>
<span class="gi">+        if self.allow_nan:</span>
<span class="gi">+            if num.is_nan():</span>
<span class="gi">+                return decimal.Decimal(&quot;NaN&quot;)  # avoid sNaN, -sNaN and -NaN</span>
<span class="gi">+        if self.places is not None and num.is_finite():</span>
<span class="gi">+            num = num.quantize(self.places, rounding=self.rounding)</span>
<span class="gi">+        return num</span>
<span class="gi">+</span>
<span class="gi">+    # override Number</span>
<span class="gi">+    def _validated(self, value):</span>
<span class="gi">+        try:</span>
<span class="gi">+            num = super()._validated(value)</span>
<span class="gi">+        except decimal.InvalidOperation as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;) from error</span>
<span class="gi">+        if not self.allow_nan and (num.is_nan() or num.is_infinite()):</span>
<span class="gi">+            raise self.make_error(&quot;special&quot;)</span>
<span class="gi">+        return num</span>
<span class="gi">+</span>
<span class="gi">+    # override Number</span>
<span class="gi">+    def _to_string(self, value):</span>
<span class="gi">+        return format(value, &quot;f&quot;)</span>
<span class="gi">+</span>

<span class="w"> </span>class Boolean(Field):
<span class="w"> </span>    &quot;&quot;&quot;A boolean field.
<span class="gu">@@ -612,20 +1126,92 @@ class Boolean(Field):</span>
<span class="w"> </span>        `marshmallow.fields.Boolean.falsy` will be used.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Field` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    truthy = {&#39;t&#39;, &#39;T&#39;, &#39;true&#39;, &#39;True&#39;, &#39;TRUE&#39;, &#39;on&#39;, &#39;On&#39;, &#39;ON&#39;, &#39;y&#39;, &#39;Y&#39;,</span>
<span class="gd">-        &#39;yes&#39;, &#39;Yes&#39;, &#39;YES&#39;, &#39;1&#39;, 1}</span>
<span class="gd">-    falsy = {&#39;f&#39;, &#39;F&#39;, &#39;false&#39;, &#39;False&#39;, &#39;FALSE&#39;, &#39;off&#39;, &#39;Off&#39;, &#39;OFF&#39;, &#39;n&#39;,</span>
<span class="gd">-        &#39;N&#39;, &#39;no&#39;, &#39;No&#39;, &#39;NO&#39;, &#39;0&#39;, 0}</span>
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid boolean.&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, truthy: (set | None)=None, falsy: (set | None)=</span>
<span class="gd">-        None, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+    #: Default truthy values.</span>
<span class="gi">+    truthy = {</span>
<span class="gi">+        &quot;t&quot;,</span>
<span class="gi">+        &quot;T&quot;,</span>
<span class="gi">+        &quot;true&quot;,</span>
<span class="gi">+        &quot;True&quot;,</span>
<span class="gi">+        &quot;TRUE&quot;,</span>
<span class="gi">+        &quot;on&quot;,</span>
<span class="gi">+        &quot;On&quot;,</span>
<span class="gi">+        &quot;ON&quot;,</span>
<span class="gi">+        &quot;y&quot;,</span>
<span class="gi">+        &quot;Y&quot;,</span>
<span class="gi">+        &quot;yes&quot;,</span>
<span class="gi">+        &quot;Yes&quot;,</span>
<span class="gi">+        &quot;YES&quot;,</span>
<span class="gi">+        &quot;1&quot;,</span>
<span class="gi">+        1,</span>
<span class="gi">+        # Equal to 1</span>
<span class="gi">+        # True,</span>
<span class="gi">+    }</span>
<span class="gi">+    #: Default falsy values.</span>
<span class="gi">+    falsy = {</span>
<span class="gi">+        &quot;f&quot;,</span>
<span class="gi">+        &quot;F&quot;,</span>
<span class="gi">+        &quot;false&quot;,</span>
<span class="gi">+        &quot;False&quot;,</span>
<span class="gi">+        &quot;FALSE&quot;,</span>
<span class="gi">+        &quot;off&quot;,</span>
<span class="gi">+        &quot;Off&quot;,</span>
<span class="gi">+        &quot;OFF&quot;,</span>
<span class="gi">+        &quot;n&quot;,</span>
<span class="gi">+        &quot;N&quot;,</span>
<span class="gi">+        &quot;no&quot;,</span>
<span class="gi">+        &quot;No&quot;,</span>
<span class="gi">+        &quot;NO&quot;,</span>
<span class="gi">+        &quot;0&quot;,</span>
<span class="gi">+        0,</span>
<span class="gi">+        # Equal to 0</span>
<span class="gi">+        # 0.0,</span>
<span class="gi">+        # False,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid boolean.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        truthy: set | None = None,</span>
<span class="gi">+        falsy: set | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="gi">+</span>
<span class="w"> </span>        if truthy is not None:
<span class="w"> </span>            self.truthy = set(truthy)
<span class="w"> </span>        if falsy is not None:
<span class="w"> </span>            self.falsy = set(falsy)

<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if value in self.truthy:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if value in self.falsy:</span>
<span class="gi">+                return False</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return bool(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        if not self.truthy:</span>
<span class="gi">+            return bool(value)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if value in self.truthy:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if value in self.falsy:</span>
<span class="gi">+                return False</span>
<span class="gi">+        except TypeError as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;, input=value) from error</span>
<span class="gi">+        raise self.make_error(&quot;invalid&quot;, input=value)</span>
<span class="gi">+</span>

<span class="w"> </span>class DateTime(Field):
<span class="w"> </span>    &quot;&quot;&quot;A formatted datetime string.
<span class="gu">@@ -642,24 +1228,78 @@ class DateTime(Field):</span>
<span class="w"> </span>    .. versionchanged:: 3.19
<span class="w"> </span>        Add timestamp as a format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    SERIALIZATION_FUNCS = {&#39;iso&#39;: utils.isoformat, &#39;iso8601&#39;: utils.</span>
<span class="gd">-        isoformat, &#39;rfc&#39;: utils.rfcformat, &#39;rfc822&#39;: utils.rfcformat,</span>
<span class="gd">-        &#39;timestamp&#39;: utils.timestamp, &#39;timestamp_ms&#39;: utils.timestamp_ms}</span>
<span class="gd">-    DESERIALIZATION_FUNCS = {&#39;iso&#39;: utils.from_iso_datetime, &#39;iso8601&#39;:</span>
<span class="gd">-        utils.from_iso_datetime, &#39;rfc&#39;: utils.from_rfc, &#39;rfc822&#39;: utils.</span>
<span class="gd">-        from_rfc, &#39;timestamp&#39;: utils.from_timestamp, &#39;timestamp_ms&#39;: utils.</span>
<span class="gd">-        from_timestamp_ms}</span>
<span class="gd">-    DEFAULT_FORMAT = &#39;iso&#39;</span>
<span class="gd">-    OBJ_TYPE = &#39;datetime&#39;</span>
<span class="gd">-    SCHEMA_OPTS_VAR_NAME = &#39;datetimeformat&#39;</span>
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid {obj_type}.&#39;,</span>
<span class="gd">-        &#39;invalid_awareness&#39;: &#39;Not a valid {awareness} {obj_type}.&#39;,</span>
<span class="gd">-        &#39;format&#39;: &#39;&quot;{input}&quot; cannot be formatted as a {obj_type}.&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, format: (str | None)=None, **kwargs) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    SERIALIZATION_FUNCS = {</span>
<span class="gi">+        &quot;iso&quot;: utils.isoformat,</span>
<span class="gi">+        &quot;iso8601&quot;: utils.isoformat,</span>
<span class="gi">+        &quot;rfc&quot;: utils.rfcformat,</span>
<span class="gi">+        &quot;rfc822&quot;: utils.rfcformat,</span>
<span class="gi">+        &quot;timestamp&quot;: utils.timestamp,</span>
<span class="gi">+        &quot;timestamp_ms&quot;: utils.timestamp_ms,</span>
<span class="gi">+    }  # type: typing.Dict[str, typing.Callable[[typing.Any], str | float]]</span>
<span class="gi">+</span>
<span class="gi">+    DESERIALIZATION_FUNCS = {</span>
<span class="gi">+        &quot;iso&quot;: utils.from_iso_datetime,</span>
<span class="gi">+        &quot;iso8601&quot;: utils.from_iso_datetime,</span>
<span class="gi">+        &quot;rfc&quot;: utils.from_rfc,</span>
<span class="gi">+        &quot;rfc822&quot;: utils.from_rfc,</span>
<span class="gi">+        &quot;timestamp&quot;: utils.from_timestamp,</span>
<span class="gi">+        &quot;timestamp_ms&quot;: utils.from_timestamp_ms,</span>
<span class="gi">+    }  # type: typing.Dict[str, typing.Callable[[str], typing.Any]]</span>
<span class="gi">+</span>
<span class="gi">+    DEFAULT_FORMAT = &quot;iso&quot;</span>
<span class="gi">+</span>
<span class="gi">+    OBJ_TYPE = &quot;datetime&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SCHEMA_OPTS_VAR_NAME = &quot;datetimeformat&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;invalid&quot;: &quot;Not a valid {obj_type}.&quot;,</span>
<span class="gi">+        &quot;invalid_awareness&quot;: &quot;Not a valid {awareness} {obj_type}.&quot;,</span>
<span class="gi">+        &quot;format&quot;: &#39;&quot;{input}&quot; cannot be formatted as a {obj_type}.&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, format: str | None = None, **kwargs) -&gt; None:</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="gi">+        # Allow this to be None. It may be set later in the ``_serialize``</span>
<span class="gi">+        # or ``_deserialize`` methods. This allows a Schema to dynamically set the</span>
<span class="gi">+        # format, e.g. from a Meta option</span>
<span class="w"> </span>        self.format = format

<span class="gi">+    def _bind_to_schema(self, field_name, schema):</span>
<span class="gi">+        super()._bind_to_schema(field_name, schema)</span>
<span class="gi">+        self.format = (</span>
<span class="gi">+            self.format</span>
<span class="gi">+            or getattr(self.root.opts, self.SCHEMA_OPTS_VAR_NAME)</span>
<span class="gi">+            or self.DEFAULT_FORMAT</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; str | float | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        data_format = self.format or self.DEFAULT_FORMAT</span>
<span class="gi">+        format_func = self.SERIALIZATION_FUNCS.get(data_format)</span>
<span class="gi">+        if format_func:</span>
<span class="gi">+            return format_func(value)</span>
<span class="gi">+        return value.strftime(data_format)</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; dt.datetime:</span>
<span class="gi">+        data_format = self.format or self.DEFAULT_FORMAT</span>
<span class="gi">+        func = self.DESERIALIZATION_FUNCS.get(data_format)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if func:</span>
<span class="gi">+                return func(value)</span>
<span class="gi">+            return self._make_object_from_format(value, data_format)</span>
<span class="gi">+        except (TypeError, AttributeError, ValueError) as error:</span>
<span class="gi">+            raise self.make_error(</span>
<span class="gi">+                &quot;invalid&quot;, input=value, obj_type=self.OBJ_TYPE</span>
<span class="gi">+            ) from error</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_object_from_format(value, data_format) -&gt; dt.datetime:</span>
<span class="gi">+        return dt.datetime.strptime(value, data_format)</span>
<span class="gi">+</span>

<span class="w"> </span>class NaiveDateTime(DateTime):
<span class="w"> </span>    &quot;&quot;&quot;A formatted naive datetime string.
<span class="gu">@@ -673,13 +1313,31 @@ class NaiveDateTime(DateTime):</span>

<span class="w"> </span>    .. versionadded:: 3.0.0rc9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    AWARENESS = &#39;naive&#39;</span>

<span class="gd">-    def __init__(self, format: (str | None)=None, *, timezone: (dt.timezone |</span>
<span class="gd">-        None)=None, **kwargs) -&gt;None:</span>
<span class="gi">+    AWARENESS = &quot;naive&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format: str | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        timezone: dt.timezone | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(format=format, **kwargs)
<span class="w"> </span>        self.timezone = timezone

<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; dt.datetime:</span>
<span class="gi">+        ret = super()._deserialize(value, attr, data, **kwargs)</span>
<span class="gi">+        if is_aware(ret):</span>
<span class="gi">+            if self.timezone is None:</span>
<span class="gi">+                raise self.make_error(</span>
<span class="gi">+                    &quot;invalid_awareness&quot;,</span>
<span class="gi">+                    awareness=self.AWARENESS,</span>
<span class="gi">+                    obj_type=self.OBJ_TYPE,</span>
<span class="gi">+                )</span>
<span class="gi">+            ret = ret.astimezone(self.timezone).replace(tzinfo=None)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>

<span class="w"> </span>class AwareDateTime(DateTime):
<span class="w"> </span>    &quot;&quot;&quot;A formatted aware datetime string.
<span class="gu">@@ -692,13 +1350,31 @@ class AwareDateTime(DateTime):</span>

<span class="w"> </span>    .. versionadded:: 3.0.0rc9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    AWARENESS = &#39;aware&#39;</span>

<span class="gd">-    def __init__(self, format: (str | None)=None, *, default_timezone: (dt.</span>
<span class="gd">-        tzinfo | None)=None, **kwargs) -&gt;None:</span>
<span class="gi">+    AWARENESS = &quot;aware&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        format: str | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        default_timezone: dt.tzinfo | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(format=format, **kwargs)
<span class="w"> </span>        self.default_timezone = default_timezone

<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; dt.datetime:</span>
<span class="gi">+        ret = super()._deserialize(value, attr, data, **kwargs)</span>
<span class="gi">+        if not is_aware(ret):</span>
<span class="gi">+            if self.default_timezone is None:</span>
<span class="gi">+                raise self.make_error(</span>
<span class="gi">+                    &quot;invalid_awareness&quot;,</span>
<span class="gi">+                    awareness=self.AWARENESS,</span>
<span class="gi">+                    obj_type=self.OBJ_TYPE,</span>
<span class="gi">+                )</span>
<span class="gi">+            ret = ret.replace(tzinfo=self.default_timezone)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>

<span class="w"> </span>class Time(DateTime):
<span class="w"> </span>    &quot;&quot;&quot;A formatted time string.
<span class="gu">@@ -709,13 +1385,20 @@ class Time(DateTime):</span>
<span class="w"> </span>        If `None`, defaults to &quot;iso&quot;.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Field` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    SERIALIZATION_FUNCS = {&#39;iso&#39;: utils.to_iso_time, &#39;iso8601&#39;: utils.</span>
<span class="gd">-        to_iso_time}</span>
<span class="gd">-    DESERIALIZATION_FUNCS = {&#39;iso&#39;: utils.from_iso_time, &#39;iso8601&#39;: utils.</span>
<span class="gd">-        from_iso_time}</span>
<span class="gd">-    DEFAULT_FORMAT = &#39;iso&#39;</span>
<span class="gd">-    OBJ_TYPE = &#39;time&#39;</span>
<span class="gd">-    SCHEMA_OPTS_VAR_NAME = &#39;timeformat&#39;</span>
<span class="gi">+</span>
<span class="gi">+    SERIALIZATION_FUNCS = {&quot;iso&quot;: utils.to_iso_time, &quot;iso8601&quot;: utils.to_iso_time}</span>
<span class="gi">+</span>
<span class="gi">+    DESERIALIZATION_FUNCS = {&quot;iso&quot;: utils.from_iso_time, &quot;iso8601&quot;: utils.from_iso_time}</span>
<span class="gi">+</span>
<span class="gi">+    DEFAULT_FORMAT = &quot;iso&quot;</span>
<span class="gi">+</span>
<span class="gi">+    OBJ_TYPE = &quot;time&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SCHEMA_OPTS_VAR_NAME = &quot;timeformat&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_object_from_format(value, data_format):</span>
<span class="gi">+        return dt.datetime.strptime(value, data_format).time()</span>


<span class="w"> </span>class Date(DateTime):
<span class="gu">@@ -725,15 +1408,26 @@ class Date(DateTime):</span>
<span class="w"> </span>        If `None`, defaults to &quot;iso&quot;.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`Field` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid date.&#39;, &#39;format&#39;:</span>
<span class="gd">-        &#39;&quot;{input}&quot; cannot be formatted as a date.&#39;}</span>
<span class="gd">-    SERIALIZATION_FUNCS = {&#39;iso&#39;: utils.to_iso_date, &#39;iso8601&#39;: utils.</span>
<span class="gd">-        to_iso_date}</span>
<span class="gd">-    DESERIALIZATION_FUNCS = {&#39;iso&#39;: utils.from_iso_date, &#39;iso8601&#39;: utils.</span>
<span class="gd">-        from_iso_date}</span>
<span class="gd">-    DEFAULT_FORMAT = &#39;iso&#39;</span>
<span class="gd">-    OBJ_TYPE = &#39;date&#39;</span>
<span class="gd">-    SCHEMA_OPTS_VAR_NAME = &#39;dateformat&#39;</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;invalid&quot;: &quot;Not a valid date.&quot;,</span>
<span class="gi">+        &quot;format&quot;: &#39;&quot;{input}&quot; cannot be formatted as a date.&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    SERIALIZATION_FUNCS = {&quot;iso&quot;: utils.to_iso_date, &quot;iso8601&quot;: utils.to_iso_date}</span>
<span class="gi">+</span>
<span class="gi">+    DESERIALIZATION_FUNCS = {&quot;iso&quot;: utils.from_iso_date, &quot;iso8601&quot;: utils.from_iso_date}</span>
<span class="gi">+</span>
<span class="gi">+    DEFAULT_FORMAT = &quot;iso&quot;</span>
<span class="gi">+</span>
<span class="gi">+    OBJ_TYPE = &quot;date&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SCHEMA_OPTS_VAR_NAME = &quot;dateformat&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_object_from_format(value, data_format):</span>
<span class="gi">+        return dt.datetime.strptime(value, data_format).date()</span>


<span class="w"> </span>class TimeDelta(Field):
<span class="gu">@@ -768,32 +1462,77 @@ class TimeDelta(Field):</span>
<span class="w"> </span>        Allow (de)serialization to `float` through use of a new `serialization_type` parameter.
<span class="w"> </span>        `int` is the default to retain previous behaviour.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    DAYS = &#39;days&#39;</span>
<span class="gd">-    SECONDS = &#39;seconds&#39;</span>
<span class="gd">-    MICROSECONDS = &#39;microseconds&#39;</span>
<span class="gd">-    MILLISECONDS = &#39;milliseconds&#39;</span>
<span class="gd">-    MINUTES = &#39;minutes&#39;</span>
<span class="gd">-    HOURS = &#39;hours&#39;</span>
<span class="gd">-    WEEKS = &#39;weeks&#39;</span>
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid period of time.&#39;,</span>
<span class="gd">-        &#39;format&#39;: &#39;{input!r} cannot be formatted as a timedelta.&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, precision: str=SECONDS, serialization_type: type[int |</span>
<span class="gd">-        float]=int, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+    DAYS = &quot;days&quot;</span>
<span class="gi">+    SECONDS = &quot;seconds&quot;</span>
<span class="gi">+    MICROSECONDS = &quot;microseconds&quot;</span>
<span class="gi">+    MILLISECONDS = &quot;milliseconds&quot;</span>
<span class="gi">+    MINUTES = &quot;minutes&quot;</span>
<span class="gi">+    HOURS = &quot;hours&quot;</span>
<span class="gi">+    WEEKS = &quot;weeks&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;invalid&quot;: &quot;Not a valid period of time.&quot;,</span>
<span class="gi">+        &quot;format&quot;: &quot;{input!r} cannot be formatted as a timedelta.&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        precision: str = SECONDS,</span>
<span class="gi">+        serialization_type: type[int | float] = int,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        precision = precision.lower()
<span class="gd">-        units = (self.DAYS, self.SECONDS, self.MICROSECONDS, self.</span>
<span class="gd">-            MILLISECONDS, self.MINUTES, self.HOURS, self.WEEKS)</span>
<span class="gi">+        units = (</span>
<span class="gi">+            self.DAYS,</span>
<span class="gi">+            self.SECONDS,</span>
<span class="gi">+            self.MICROSECONDS,</span>
<span class="gi">+            self.MILLISECONDS,</span>
<span class="gi">+            self.MINUTES,</span>
<span class="gi">+            self.HOURS,</span>
<span class="gi">+            self.WEEKS,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if precision not in units:
<span class="gd">-            msg = &#39;The precision must be {} or &quot;{}&quot;.&#39;.format(&#39;, &#39;.join([</span>
<span class="gd">-                f&#39;&quot;{each}&quot;&#39; for each in units[:-1]]), units[-1])</span>
<span class="gi">+            msg = &#39;The precision must be {} or &quot;{}&quot;.&#39;.format(</span>
<span class="gi">+                &quot;, &quot;.join([f&#39;&quot;{each}&quot;&#39; for each in units[:-1]]), units[-1]</span>
<span class="gi">+            )</span>
<span class="w"> </span>            raise ValueError(msg)
<span class="gi">+</span>
<span class="w"> </span>        if serialization_type not in (int, float):
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &#39;The serialization type must be one of int or float&#39;)</span>
<span class="gi">+            raise ValueError(&quot;The serialization type must be one of int or float&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.precision = precision
<span class="w"> </span>        self.serialization_type = serialization_type
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        base_unit = dt.timedelta(**{self.precision: 1})</span>
<span class="gi">+</span>
<span class="gi">+        if self.serialization_type is int:</span>
<span class="gi">+            delta = utils.timedelta_to_microseconds(value)</span>
<span class="gi">+            unit = utils.timedelta_to_microseconds(base_unit)</span>
<span class="gi">+            return delta // unit</span>
<span class="gi">+        assert self.serialization_type is float</span>
<span class="gi">+        return value.total_seconds() / base_unit.total_seconds()</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = self.serialization_type(value)</span>
<span class="gi">+        except (TypeError, ValueError) as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;) from error</span>
<span class="gi">+</span>
<span class="gi">+        kwargs = {self.precision: value}</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return dt.timedelta(**kwargs)</span>
<span class="gi">+        except OverflowError as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;) from error</span>
<span class="gi">+</span>

<span class="w"> </span>class Mapping(Field):
<span class="w"> </span>    &quot;&quot;&quot;An abstract class for objects with key-value pairs.
<span class="gu">@@ -808,11 +1547,18 @@ class Mapping(Field):</span>

<span class="w"> </span>    .. versionadded:: 3.0.0rc4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    mapping_type = dict
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid mapping type.&#39;}</span>

<span class="gd">-    def __init__(self, keys: (Field | type | None)=None, values: (Field |</span>
<span class="gd">-        type | None)=None, **kwargs):</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid mapping type.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        keys: Field | type | None = None,</span>
<span class="gi">+        values: Field | type | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        if keys is None:
<span class="w"> </span>            self.key_field = None
<span class="gu">@@ -821,8 +1567,10 @@ class Mapping(Field):</span>
<span class="w"> </span>                self.key_field = resolve_field_instance(keys)
<span class="w"> </span>            except FieldInstanceResolutionError as error:
<span class="w"> </span>                raise ValueError(
<span class="gd">-                    &#39;&quot;keys&quot; must be a subclass or instance of marshmallow.base.FieldABC.&#39;</span>
<span class="gd">-                    ) from error</span>
<span class="gi">+                    &#39;&quot;keys&quot; must be a subclass or instance of &#39;</span>
<span class="gi">+                    &quot;marshmallow.base.FieldABC.&quot;</span>
<span class="gi">+                ) from error</span>
<span class="gi">+</span>
<span class="w"> </span>        if values is None:
<span class="w"> </span>            self.value_field = None
<span class="w"> </span>        else:
<span class="gu">@@ -830,12 +1578,94 @@ class Mapping(Field):</span>
<span class="w"> </span>                self.value_field = resolve_field_instance(values)
<span class="w"> </span>            except FieldInstanceResolutionError as error:
<span class="w"> </span>                raise ValueError(
<span class="gd">-                    &#39;&quot;values&quot; must be a subclass or instance of marshmallow.base.FieldABC.&#39;</span>
<span class="gd">-                    ) from error</span>
<span class="gi">+                    &#39;&quot;values&quot; must be a subclass or instance of &#39;</span>
<span class="gi">+                    &quot;marshmallow.base.FieldABC.&quot;</span>
<span class="gi">+                ) from error</span>
<span class="w"> </span>            if isinstance(self.value_field, Nested):
<span class="w"> </span>                self.only = self.value_field.only
<span class="w"> </span>                self.exclude = self.value_field.exclude

<span class="gi">+    def _bind_to_schema(self, field_name, schema):</span>
<span class="gi">+        super()._bind_to_schema(field_name, schema)</span>
<span class="gi">+        if self.value_field:</span>
<span class="gi">+            self.value_field = copy.deepcopy(self.value_field)</span>
<span class="gi">+            self.value_field._bind_to_schema(field_name, self)</span>
<span class="gi">+        if isinstance(self.value_field, Nested):</span>
<span class="gi">+            self.value_field.only = self.only</span>
<span class="gi">+            self.value_field.exclude = self.exclude</span>
<span class="gi">+        if self.key_field:</span>
<span class="gi">+            self.key_field = copy.deepcopy(self.key_field)</span>
<span class="gi">+            self.key_field._bind_to_schema(field_name, self)</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if not self.value_field and not self.key_field:</span>
<span class="gi">+            return self.mapping_type(value)</span>
<span class="gi">+</span>
<span class="gi">+        #  Serialize keys</span>
<span class="gi">+        if self.key_field is None:</span>
<span class="gi">+            keys = {k: k for k in value.keys()}</span>
<span class="gi">+        else:</span>
<span class="gi">+            keys = {</span>
<span class="gi">+                k: self.key_field._serialize(k, None, None, **kwargs)</span>
<span class="gi">+                for k in value.keys()</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        #  Serialize values</span>
<span class="gi">+        result = self.mapping_type()</span>
<span class="gi">+        if self.value_field is None:</span>
<span class="gi">+            for k, v in value.items():</span>
<span class="gi">+                if k in keys:</span>
<span class="gi">+                    result[keys[k]] = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            for k, v in value.items():</span>
<span class="gi">+                result[keys[k]] = self.value_field._serialize(v, None, None, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        if not isinstance(value, _Mapping):</span>
<span class="gi">+            raise self.make_error(&quot;invalid&quot;)</span>
<span class="gi">+        if not self.value_field and not self.key_field:</span>
<span class="gi">+            return self.mapping_type(value)</span>
<span class="gi">+</span>
<span class="gi">+        errors = collections.defaultdict(dict)</span>
<span class="gi">+</span>
<span class="gi">+        #  Deserialize keys</span>
<span class="gi">+        if self.key_field is None:</span>
<span class="gi">+            keys = {k: k for k in value.keys()}</span>
<span class="gi">+        else:</span>
<span class="gi">+            keys = {}</span>
<span class="gi">+            for key in value.keys():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    keys[key] = self.key_field.deserialize(key, **kwargs)</span>
<span class="gi">+                except ValidationError as error:</span>
<span class="gi">+                    errors[key][&quot;key&quot;] = error.messages</span>
<span class="gi">+</span>
<span class="gi">+        #  Deserialize values</span>
<span class="gi">+        result = self.mapping_type()</span>
<span class="gi">+        if self.value_field is None:</span>
<span class="gi">+            for k, v in value.items():</span>
<span class="gi">+                if k in keys:</span>
<span class="gi">+                    result[keys[k]] = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            for key, val in value.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    deser_val = self.value_field.deserialize(val, **kwargs)</span>
<span class="gi">+                except ValidationError as error:</span>
<span class="gi">+                    errors[key][&quot;value&quot;] = error.messages</span>
<span class="gi">+                    if error.valid_data is not None and key in keys:</span>
<span class="gi">+                        result[keys[key]] = error.valid_data</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if key in keys:</span>
<span class="gi">+                        result[keys[key]] = deser_val</span>
<span class="gi">+</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            raise ValidationError(errors, valid_data=result)</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class Dict(Mapping):
<span class="w"> </span>    &quot;&quot;&quot;A dict field. Supports dicts and dict-like objects. Extends
<span class="gu">@@ -849,6 +1679,7 @@ class Dict(Mapping):</span>

<span class="w"> </span>    .. versionadded:: 2.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    mapping_type = dict


<span class="gu">@@ -862,18 +1693,32 @@ class Url(String):</span>
<span class="w"> </span>        ``ftp``, and ``ftps`` are allowed.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`String` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid URL.&#39;}</span>

<span class="gd">-    def __init__(self, *, relative: bool=False, absolute: bool=True,</span>
<span class="gd">-        schemes: (types.StrSequenceOrSet | None)=None, require_tld: bool=</span>
<span class="gd">-        True, **kwargs):</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid URL.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        relative: bool = False,</span>
<span class="gi">+        absolute: bool = True,</span>
<span class="gi">+        schemes: types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        require_tld: bool = True,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="gi">+</span>
<span class="w"> </span>        self.relative = relative
<span class="w"> </span>        self.absolute = absolute
<span class="w"> </span>        self.require_tld = require_tld
<span class="gd">-        validator = validate.URL(relative=self.relative, absolute=self.</span>
<span class="gd">-            absolute, schemes=schemes, require_tld=self.require_tld, error=</span>
<span class="gd">-            self.error_messages[&#39;invalid&#39;])</span>
<span class="gi">+        # Insert validation into self.validators so that multiple errors can be stored.</span>
<span class="gi">+        validator = validate.URL(</span>
<span class="gi">+            relative=self.relative,</span>
<span class="gi">+            absolute=self.absolute,</span>
<span class="gi">+            schemes=schemes,</span>
<span class="gi">+            require_tld=self.require_tld,</span>
<span class="gi">+            error=self.error_messages[&quot;invalid&quot;],</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.validators.insert(0, validator)


<span class="gu">@@ -883,11 +1728,14 @@ class Email(String):</span>
<span class="w"> </span>    :param args: The same positional arguments that :class:`String` receives.
<span class="w"> </span>    :param kwargs: The same keyword arguments that :class:`String` receives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid&#39;: &#39;Not a valid email address.&#39;}</span>

<span class="gd">-    def __init__(self, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    #: Default error messages.</span>
<span class="gi">+    default_error_messages = {&quot;invalid&quot;: &quot;Not a valid email address.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="gd">-        validator = validate.Email(error=self.error_messages[&#39;invalid&#39;])</span>
<span class="gi">+        # Insert validation into self.validators so that multiple errors can be stored.</span>
<span class="gi">+        validator = validate.Email(error=self.error_messages[&quot;invalid&quot;])</span>
<span class="w"> </span>        self.validators.insert(0, validator)


<span class="gu">@@ -899,20 +1747,43 @@ class IP(Field):</span>

<span class="w"> </span>    .. versionadded:: 3.8.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_ip&#39;: &#39;Not a valid IP address.&#39;}</span>
<span class="gd">-    DESERIALIZATION_CLASS = None</span>
<span class="gi">+</span>
<span class="gi">+    default_error_messages = {&quot;invalid_ip&quot;: &quot;Not a valid IP address.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    DESERIALIZATION_CLASS = None  # type: typing.Optional[typing.Type]</span>

<span class="w"> </span>    def __init__(self, *args, exploded=False, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.exploded = exploded

<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; str | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if self.exploded:</span>
<span class="gi">+            return value.exploded</span>
<span class="gi">+        return value.compressed</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(</span>
<span class="gi">+        self, value, attr, data, **kwargs</span>
<span class="gi">+    ) -&gt; ipaddress.IPv4Address | ipaddress.IPv6Address | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        try:</span>
<span class="gi">+            return (self.DESERIALIZATION_CLASS or ipaddress.ip_address)(</span>
<span class="gi">+                utils.ensure_text_type(value)</span>
<span class="gi">+            )</span>
<span class="gi">+        except (ValueError, TypeError) as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid_ip&quot;) from error</span>
<span class="gi">+</span>

<span class="w"> </span>class IPv4(IP):
<span class="w"> </span>    &quot;&quot;&quot;A IPv4 address field.

<span class="w"> </span>    .. versionadded:: 3.8.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_ip&#39;: &#39;Not a valid IPv4 address.&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    default_error_messages = {&quot;invalid_ip&quot;: &quot;Not a valid IPv4 address.&quot;}</span>
<span class="gi">+</span>
<span class="w"> </span>    DESERIALIZATION_CLASS = ipaddress.IPv4Address


<span class="gu">@@ -921,7 +1792,9 @@ class IPv6(IP):</span>

<span class="w"> </span>    .. versionadded:: 3.8.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_ip&#39;: &#39;Not a valid IPv6 address.&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    default_error_messages = {&quot;invalid_ip&quot;: &quot;Not a valid IPv6 address.&quot;}</span>
<span class="gi">+</span>
<span class="w"> </span>    DESERIALIZATION_CLASS = ipaddress.IPv6Address


<span class="gu">@@ -938,26 +1811,48 @@ class IPInterface(Field):</span>
<span class="w"> </span>    :param bool exploded: If `True`, serialize ipv6 interface in long form, ie. with groups
<span class="w"> </span>        consisting entirely of zeros included.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_ip_interface&#39;:</span>
<span class="gd">-        &#39;Not a valid IP interface.&#39;}</span>
<span class="gd">-    DESERIALIZATION_CLASS = None</span>

<span class="gd">-    def __init__(self, *args, exploded: bool=False, **kwargs):</span>
<span class="gi">+    default_error_messages = {&quot;invalid_ip_interface&quot;: &quot;Not a valid IP interface.&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    DESERIALIZATION_CLASS = None  # type: typing.Optional[typing.Type]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *args, exploded: bool = False, **kwargs):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.exploded = exploded

<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs) -&gt; str | None:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if self.exploded:</span>
<span class="gi">+            return value.exploded</span>
<span class="gi">+        return value.compressed</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs) -&gt; None | (</span>
<span class="gi">+        ipaddress.IPv4Interface | ipaddress.IPv6Interface</span>
<span class="gi">+    ):</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        try:</span>
<span class="gi">+            return (self.DESERIALIZATION_CLASS or ipaddress.ip_interface)(</span>
<span class="gi">+                utils.ensure_text_type(value)</span>
<span class="gi">+            )</span>
<span class="gi">+        except (ValueError, TypeError) as error:</span>
<span class="gi">+            raise self.make_error(&quot;invalid_ip_interface&quot;) from error</span>
<span class="gi">+</span>

<span class="w"> </span>class IPv4Interface(IPInterface):
<span class="w"> </span>    &quot;&quot;&quot;A IPv4 Network Interface field.&quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_ip_interface&#39;:</span>
<span class="gd">-        &#39;Not a valid IPv4 interface.&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    default_error_messages = {&quot;invalid_ip_interface&quot;: &quot;Not a valid IPv4 interface.&quot;}</span>
<span class="gi">+</span>
<span class="w"> </span>    DESERIALIZATION_CLASS = ipaddress.IPv4Interface


<span class="w"> </span>class IPv6Interface(IPInterface):
<span class="w"> </span>    &quot;&quot;&quot;A IPv6 Network Interface field.&quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;invalid_ip_interface&#39;:</span>
<span class="gd">-        &#39;Not a valid IPv6 interface.&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    default_error_messages = {&quot;invalid_ip_interface&quot;: &quot;Not a valid IPv6 interface.&quot;}</span>
<span class="gi">+</span>
<span class="w"> </span>    DESERIALIZATION_CLASS = ipaddress.IPv6Interface


<span class="gu">@@ -974,17 +1869,29 @@ class Enum(Field):</span>

<span class="w"> </span>    .. versionadded:: 3.18.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_messages = {&#39;unknown&#39;: &#39;Must be one of: {choices}.&#39;}</span>

<span class="gd">-    def __init__(self, enum: type[EnumType], *, by_value: (bool | Field |</span>
<span class="gd">-        type)=False, **kwargs):</span>
<span class="gi">+    default_error_messages = {</span>
<span class="gi">+        &quot;unknown&quot;: &quot;Must be one of: {choices}.&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        enum: type[EnumType],</span>
<span class="gi">+        *,</span>
<span class="gi">+        by_value: bool | Field | type = False,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.enum = enum
<span class="w"> </span>        self.by_value = by_value
<span class="gi">+</span>
<span class="gi">+        # Serialization by name</span>
<span class="w"> </span>        if by_value is False:
<span class="w"> </span>            self.field: Field = String()
<span class="gd">-            self.choices_text = &#39;, &#39;.join(str(self.field._serialize(m, None,</span>
<span class="gd">-                None)) for m in enum.__members__)</span>
<span class="gi">+            self.choices_text = &quot;, &quot;.join(</span>
<span class="gi">+                str(self.field._serialize(m, None, None)) for m in enum.__members__</span>
<span class="gi">+            )</span>
<span class="gi">+        # Serialization by value</span>
<span class="w"> </span>        else:
<span class="w"> </span>            if by_value is True:
<span class="w"> </span>                self.field = Field()
<span class="gu">@@ -993,10 +1900,33 @@ class Enum(Field):</span>
<span class="w"> </span>                    self.field = resolve_field_instance(by_value)
<span class="w"> </span>                except FieldInstanceResolutionError as error:
<span class="w"> </span>                    raise ValueError(
<span class="gd">-                        &#39;&quot;by_value&quot; must be either a bool or a subclass or instance of marshmallow.base.FieldABC.&#39;</span>
<span class="gd">-                        ) from error</span>
<span class="gd">-            self.choices_text = &#39;, &#39;.join(str(self.field._serialize(m.value,</span>
<span class="gd">-                None, None)) for m in enum)</span>
<span class="gi">+                        &#39;&quot;by_value&quot; must be either a bool or a subclass or instance of &#39;</span>
<span class="gi">+                        &quot;marshmallow.base.FieldABC.&quot;</span>
<span class="gi">+                    ) from error</span>
<span class="gi">+            self.choices_text = &quot;, &quot;.join(</span>
<span class="gi">+                str(self.field._serialize(m.value, None, None)) for m in enum</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if self.by_value:</span>
<span class="gi">+            val = value.value</span>
<span class="gi">+        else:</span>
<span class="gi">+            val = value.name</span>
<span class="gi">+        return self.field._serialize(val, attr, obj, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        val = self.field._deserialize(value, attr, data, **kwargs)</span>
<span class="gi">+        if self.by_value:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.enum(val)</span>
<span class="gi">+            except ValueError as error:</span>
<span class="gi">+                raise self.make_error(&quot;unknown&quot;, choices=self.choices_text) from error</span>
<span class="gi">+        try:</span>
<span class="gi">+            return getattr(self.enum, val)</span>
<span class="gi">+        except AttributeError as error:</span>
<span class="gi">+            raise self.make_error(&quot;unknown&quot;, choices=self.choices_text) from error</span>


<span class="w"> </span>class Method(Field):
<span class="gu">@@ -1019,18 +1949,47 @@ class Method(Field):</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0
<span class="w"> </span>        Removed ``method_name`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _CHECK_ATTRIBUTE = False

<span class="gd">-    def __init__(self, serialize: (str | None)=None, deserialize: (str |</span>
<span class="gd">-        None)=None, **kwargs):</span>
<span class="gd">-        kwargs[&#39;dump_only&#39;] = bool(serialize) and not bool(deserialize)</span>
<span class="gd">-        kwargs[&#39;load_only&#39;] = bool(deserialize) and not bool(serialize)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        serialize: str | None = None,</span>
<span class="gi">+        deserialize: str | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Set dump_only and load_only based on arguments</span>
<span class="gi">+        kwargs[&quot;dump_only&quot;] = bool(serialize) and not bool(deserialize)</span>
<span class="gi">+        kwargs[&quot;load_only&quot;] = bool(deserialize) and not bool(serialize)</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.serialize_method_name = serialize
<span class="w"> </span>        self.deserialize_method_name = deserialize
<span class="w"> </span>        self._serialize_method = None
<span class="w"> </span>        self._deserialize_method = None

<span class="gi">+    def _bind_to_schema(self, field_name, schema):</span>
<span class="gi">+        if self.serialize_method_name:</span>
<span class="gi">+            self._serialize_method = utils.callable_or_raise(</span>
<span class="gi">+                getattr(schema, self.serialize_method_name)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.deserialize_method_name:</span>
<span class="gi">+            self._deserialize_method = utils.callable_or_raise(</span>
<span class="gi">+                getattr(schema, self.deserialize_method_name)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        super()._bind_to_schema(field_name, schema)</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        if self._serialize_method is not None:</span>
<span class="gi">+            return self._serialize_method(obj)</span>
<span class="gi">+        return missing_</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        if self._deserialize_method is not None:</span>
<span class="gi">+            return self._deserialize_method(value)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>

<span class="w"> </span>class Function(Field):
<span class="w"> </span>    &quot;&quot;&quot;A field that takes the value returned by a function.
<span class="gu">@@ -1054,18 +2013,45 @@ class Function(Field):</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0a1
<span class="w"> </span>        Removed ``func`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _CHECK_ATTRIBUTE = False

<span class="gd">-    def __init__(self, serialize: (None | typing.Callable[[typing.Any],</span>
<span class="gd">-        typing.Any] | typing.Callable[[typing.Any, dict], typing.Any])=None,</span>
<span class="gd">-        deserialize: (None | typing.Callable[[typing.Any], typing.Any] |</span>
<span class="gd">-        typing.Callable[[typing.Any, dict], typing.Any])=None, **kwargs):</span>
<span class="gd">-        kwargs[&#39;dump_only&#39;] = bool(serialize) and not bool(deserialize)</span>
<span class="gd">-        kwargs[&#39;load_only&#39;] = bool(deserialize) and not bool(serialize)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        serialize: (</span>
<span class="gi">+            None</span>
<span class="gi">+            | typing.Callable[[typing.Any], typing.Any]</span>
<span class="gi">+            | typing.Callable[[typing.Any, dict], typing.Any]</span>
<span class="gi">+        ) = None,</span>
<span class="gi">+        deserialize: (</span>
<span class="gi">+            None</span>
<span class="gi">+            | typing.Callable[[typing.Any], typing.Any]</span>
<span class="gi">+            | typing.Callable[[typing.Any, dict], typing.Any]</span>
<span class="gi">+        ) = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Set dump_only and load_only based on arguments</span>
<span class="gi">+        kwargs[&quot;dump_only&quot;] = bool(serialize) and not bool(deserialize)</span>
<span class="gi">+        kwargs[&quot;load_only&quot;] = bool(deserialize) and not bool(serialize)</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.serialize_func = serialize and utils.callable_or_raise(serialize)
<span class="gd">-        self.deserialize_func = deserialize and utils.callable_or_raise(</span>
<span class="gd">-            deserialize)</span>
<span class="gi">+        self.deserialize_func = deserialize and utils.callable_or_raise(deserialize)</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        return self._call_or_raise(self.serialize_func, obj, attr)</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, attr, data, **kwargs):</span>
<span class="gi">+        if self.deserialize_func:</span>
<span class="gi">+            return self._call_or_raise(self.deserialize_func, value, attr)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def _call_or_raise(self, func, value, attr):</span>
<span class="gi">+        if len(utils.get_func_args(func)) &gt; 1:</span>
<span class="gi">+            if self.parent.context is None:</span>
<span class="gi">+                msg = f&quot;No context available for Function field {attr!r}&quot;</span>
<span class="gi">+                raise ValidationError(msg)</span>
<span class="gi">+            return func(value, self.parent.context)</span>
<span class="gi">+        return func(value)</span>


<span class="w"> </span>class Constant(Field):
<span class="gu">@@ -1077,6 +2063,7 @@ class Constant(Field):</span>

<span class="w"> </span>    .. versionadded:: 2.0.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _CHECK_ATTRIBUTE = False

<span class="w"> </span>    def __init__(self, constant: typing.Any, **kwargs):
<span class="gu">@@ -1085,6 +2072,12 @@ class Constant(Field):</span>
<span class="w"> </span>        self.load_default = constant
<span class="w"> </span>        self.dump_default = constant

<span class="gi">+    def _serialize(self, value, *args, **kwargs):</span>
<span class="gi">+        return self.constant</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, value, *args, **kwargs):</span>
<span class="gi">+        return self.constant</span>
<span class="gi">+</span>

<span class="w"> </span>class Inferred(Field):
<span class="w"> </span>    &quot;&quot;&quot;A field that infers how to serialize, based on the value type.
<span class="gu">@@ -1097,9 +2090,24 @@ class Inferred(Field):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        super().__init__()
<span class="gi">+        # We memoize the fields to avoid creating and binding new fields</span>
<span class="gi">+        # every time on serialization.</span>
<span class="w"> </span>        self._field_cache = {}

<span class="gi">+    def _serialize(self, value, attr, obj, **kwargs):</span>
<span class="gi">+        field_cls = self.root.TYPE_MAPPING.get(type(value))</span>
<span class="gi">+        if field_cls is None:</span>
<span class="gi">+            field = super()</span>
<span class="gi">+        else:</span>
<span class="gi">+            field = self._field_cache.get(field_cls)</span>
<span class="gi">+            if field is None:</span>
<span class="gi">+                field = field_cls()</span>
<span class="gi">+                field._bind_to_schema(self.name, self.parent)</span>
<span class="gi">+                self._field_cache[field_cls] = field</span>
<span class="gi">+        return field._serialize(value, attr, obj, **kwargs)</span>
<span class="gi">+</span>

<span class="gi">+# Aliases</span>
<span class="w"> </span>URL = Url
<span class="w"> </span>Str = String
<span class="w"> </span>Bool = Boolean
<span class="gh">diff --git a/src/marshmallow/orderedset.py b/src/marshmallow/orderedset.py</span>
<span class="gh">index 35553ec..7ce0723 100644</span>
<span class="gd">--- a/src/marshmallow/orderedset.py</span>
<span class="gi">+++ b/src/marshmallow/orderedset.py</span>
<span class="gu">@@ -1,12 +1,33 @@</span>
<span class="gi">+# OrderedSet</span>
<span class="gi">+# Copyright (c) 2009 Raymond Hettinger</span>
<span class="gi">+#</span>
<span class="gi">+# Permission is hereby granted, free of charge, to any person</span>
<span class="gi">+# obtaining a copy of this software and associated documentation files</span>
<span class="gi">+# (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="gi">+# including without limitation the rights to use, copy, modify, merge,</span>
<span class="gi">+# publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="gi">+# and to permit persons to whom the Software is furnished to do so,</span>
<span class="gi">+# subject to the following conditions:</span>
<span class="gi">+#</span>
<span class="gi">+#     The above copyright notice and this permission notice shall be</span>
<span class="gi">+#     included in all copies or substantial portions of the Software.</span>
<span class="gi">+#</span>
<span class="gi">+#     THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="gi">+#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</span>
<span class="gi">+#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="gi">+#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</span>
<span class="gi">+#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</span>
<span class="gi">+#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="gi">+#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="gi">+#     OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="w"> </span>from collections.abc import MutableSet


<span class="w"> </span>class OrderedSet(MutableSet):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, iterable=None):
<span class="w"> </span>        self.end = end = []
<span class="gd">-        end += [None, end, end]</span>
<span class="gd">-        self.map = {}</span>
<span class="gi">+        end += [None, end, end]  # sentinel node for doubly linked list</span>
<span class="gi">+        self.map = {}  # key --&gt; [key, prev, next]</span>
<span class="w"> </span>        if iterable is not None:
<span class="w"> </span>            self |= iterable

<span class="gu">@@ -16,6 +37,18 @@ class OrderedSet(MutableSet):</span>
<span class="w"> </span>    def __contains__(self, key):
<span class="w"> </span>        return key in self.map

<span class="gi">+    def add(self, key):</span>
<span class="gi">+        if key not in self.map:</span>
<span class="gi">+            end = self.end</span>
<span class="gi">+            curr = end[1]</span>
<span class="gi">+            curr[2] = end[1] = self.map[key] = [key, curr, end]</span>
<span class="gi">+</span>
<span class="gi">+    def discard(self, key):</span>
<span class="gi">+        if key in self.map:</span>
<span class="gi">+            key, prev, next = self.map.pop(key)</span>
<span class="gi">+            prev[2] = next</span>
<span class="gi">+            next[1] = prev</span>
<span class="gi">+</span>
<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        end = self.end
<span class="w"> </span>        curr = end[2]
<span class="gu">@@ -30,10 +63,17 @@ class OrderedSet(MutableSet):</span>
<span class="w"> </span>            yield curr[0]
<span class="w"> </span>            curr = curr[1]

<span class="gi">+    def pop(self, last=True):</span>
<span class="gi">+        if not self:</span>
<span class="gi">+            raise KeyError(&quot;set is empty&quot;)</span>
<span class="gi">+        key = self.end[1][0] if last else self.end[2][0]</span>
<span class="gi">+        self.discard(key)</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if not self:
<span class="gd">-            return f&#39;{self.__class__.__name__}()&#39;</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({list(self)!r})&#39;</span>
<span class="gi">+            return f&quot;{self.__class__.__name__}()&quot;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({list(self)!r})&quot;</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, OrderedSet):
<span class="gu">@@ -41,9 +81,9 @@ class OrderedSet(MutableSet):</span>
<span class="w"> </span>        return set(self) == set(other)


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gd">-    s = OrderedSet(&#39;abracadaba&#39;)</span>
<span class="gd">-    t = OrderedSet(&#39;simsalabim&#39;)</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="gi">+    s = OrderedSet(&quot;abracadaba&quot;)</span>
<span class="gi">+    t = OrderedSet(&quot;simsalabim&quot;)</span>
<span class="w"> </span>    print(s | t)
<span class="w"> </span>    print(s &amp; t)
<span class="w"> </span>    print(s - t)
<span class="gh">diff --git a/src/marshmallow/schema.py b/src/marshmallow/schema.py</span>
<span class="gh">index 1e6eabf..23b43c4 100644</span>
<span class="gd">--- a/src/marshmallow/schema.py</span>
<span class="gi">+++ b/src/marshmallow/schema.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The :class:`Schema` class, including its metaclass and options (class Meta).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="w"> </span>import datetime as dt
<span class="w"> </span>import decimal
<span class="gu">@@ -11,15 +13,34 @@ import warnings</span>
<span class="w"> </span>from abc import ABCMeta
<span class="w"> </span>from collections import OrderedDict, defaultdict
<span class="w"> </span>from collections.abc import Mapping
<span class="gi">+</span>
<span class="w"> </span>from marshmallow import base, class_registry, types
<span class="w"> </span>from marshmallow import fields as ma_fields
<span class="gd">-from marshmallow.decorators import POST_DUMP, POST_LOAD, PRE_DUMP, PRE_LOAD, VALIDATES, VALIDATES_SCHEMA</span>
<span class="gi">+from marshmallow.decorators import (</span>
<span class="gi">+    POST_DUMP,</span>
<span class="gi">+    POST_LOAD,</span>
<span class="gi">+    PRE_DUMP,</span>
<span class="gi">+    PRE_LOAD,</span>
<span class="gi">+    VALIDATES,</span>
<span class="gi">+    VALIDATES_SCHEMA,</span>
<span class="gi">+)</span>
<span class="w"> </span>from marshmallow.error_store import ErrorStore
<span class="w"> </span>from marshmallow.exceptions import StringNotCollectionError, ValidationError
<span class="w"> </span>from marshmallow.orderedset import OrderedSet
<span class="gd">-from marshmallow.utils import EXCLUDE, INCLUDE, RAISE, get_value, is_collection, is_instance_or_subclass, missing, set_value, validate_unknown_parameter_value</span>
<span class="gi">+from marshmallow.utils import (</span>
<span class="gi">+    EXCLUDE,</span>
<span class="gi">+    INCLUDE,</span>
<span class="gi">+    RAISE,</span>
<span class="gi">+    get_value,</span>
<span class="gi">+    is_collection,</span>
<span class="gi">+    is_instance_or_subclass,</span>
<span class="gi">+    missing,</span>
<span class="gi">+    set_value,</span>
<span class="gi">+    validate_unknown_parameter_value,</span>
<span class="gi">+)</span>
<span class="w"> </span>from marshmallow.warnings import RemovedInMarshmallow4Warning
<span class="gd">-_T = typing.TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = typing.TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>def _get_fields(attrs):
<span class="gu">@@ -27,9 +48,15 @@ def _get_fields(attrs):</span>

<span class="w"> </span>    :param attrs: Mapping of class attributes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        (field_name, field_value)</span>
<span class="gi">+        for field_name, field_value in attrs.items()</span>
<span class="gi">+        if is_instance_or_subclass(field_value, base.FieldABC)</span>
<span class="gi">+    ]</span>


<span class="gi">+# This function allows Schemas to inherit from non-Schema classes and ensures</span>
<span class="gi">+#   inheritance according to the MRO</span>
<span class="w"> </span>def _get_fields_by_mro(klass):
<span class="w"> </span>    &quot;&quot;&quot;Collect fields from a class, following its method resolution order. The
<span class="w"> </span>    class itself is excluded from the search; only its parents are checked. Get
<span class="gu">@@ -37,7 +64,17 @@ def _get_fields_by_mro(klass):</span>

<span class="w"> </span>    :param type klass: Class whose fields to retrieve
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mro = inspect.getmro(klass)</span>
<span class="gi">+    # Loop over mro in reverse to maintain correct order of fields</span>
<span class="gi">+    return sum(</span>
<span class="gi">+        (</span>
<span class="gi">+            _get_fields(</span>
<span class="gi">+                getattr(base, &quot;_declared_fields&quot;, base.__dict__),</span>
<span class="gi">+            )</span>
<span class="gi">+            for base in mro[:0:-1]</span>
<span class="gi">+        ),</span>
<span class="gi">+        [],</span>
<span class="gi">+    )</span>


<span class="w"> </span>class SchemaMeta(ABCMeta):
<span class="gu">@@ -48,31 +85,51 @@ class SchemaMeta(ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __new__(mcs, name, bases, attrs):
<span class="gd">-        meta = attrs.get(&#39;Meta&#39;)</span>
<span class="gd">-        ordered = getattr(meta, &#39;ordered&#39;, False)</span>
<span class="gi">+        meta = attrs.get(&quot;Meta&quot;)</span>
<span class="gi">+        ordered = getattr(meta, &quot;ordered&quot;, False)</span>
<span class="w"> </span>        if not ordered:
<span class="gi">+            # Inherit &#39;ordered&#39; option</span>
<span class="gi">+            # Warning: We loop through bases instead of MRO because we don&#39;t</span>
<span class="gi">+            # yet have access to the class object</span>
<span class="gi">+            # (i.e. can&#39;t call super before we have fields)</span>
<span class="w"> </span>            for base_ in bases:
<span class="gd">-                if hasattr(base_, &#39;Meta&#39;) and hasattr(base_.Meta, &#39;ordered&#39;):</span>
<span class="gi">+                if hasattr(base_, &quot;Meta&quot;) and hasattr(base_.Meta, &quot;ordered&quot;):</span>
<span class="w"> </span>                    ordered = base_.Meta.ordered
<span class="w"> </span>                    break
<span class="w"> </span>            else:
<span class="w"> </span>                ordered = False
<span class="w"> </span>        cls_fields = _get_fields(attrs)
<span class="gi">+        # Remove fields from list of class attributes to avoid shadowing</span>
<span class="gi">+        # Schema attributes/methods in case of name conflict</span>
<span class="w"> </span>        for field_name, _ in cls_fields:
<span class="w"> </span>            del attrs[field_name]
<span class="w"> </span>        klass = super().__new__(mcs, name, bases, attrs)
<span class="w"> </span>        inherited_fields = _get_fields_by_mro(klass)
<span class="gi">+</span>
<span class="w"> </span>        meta = klass.Meta
<span class="gi">+        # Set klass.opts in __new__ rather than __init__ so that it is accessible in</span>
<span class="gi">+        # get_declared_fields</span>
<span class="w"> </span>        klass.opts = klass.OPTIONS_CLASS(meta, ordered=ordered)
<span class="gi">+        # Add fields specified in the `include` class Meta option</span>
<span class="w"> </span>        cls_fields += list(klass.opts.include.items())
<span class="gd">-        klass._declared_fields = mcs.get_declared_fields(klass=klass,</span>
<span class="gd">-            cls_fields=cls_fields, inherited_fields=inherited_fields,</span>
<span class="gd">-            dict_cls=dict)</span>
<span class="gi">+</span>
<span class="gi">+        # Assign _declared_fields on class</span>
<span class="gi">+        klass._declared_fields = mcs.get_declared_fields(</span>
<span class="gi">+            klass=klass,</span>
<span class="gi">+            cls_fields=cls_fields,</span>
<span class="gi">+            inherited_fields=inherited_fields,</span>
<span class="gi">+            dict_cls=dict,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return klass

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_declared_fields(mcs, klass: type, cls_fields: list,</span>
<span class="gd">-        inherited_fields: list, dict_cls: type=dict):</span>
<span class="gi">+    def get_declared_fields(</span>
<span class="gi">+        mcs,</span>
<span class="gi">+        klass: type,</span>
<span class="gi">+        cls_fields: list,</span>
<span class="gi">+        inherited_fields: list,</span>
<span class="gi">+        dict_cls: type = dict,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a dictionary of field_name =&gt; `Field` pairs declared on the class.
<span class="w"> </span>        This is exposed mainly so that plugins can add additional fields, e.g. fields
<span class="w"> </span>        computed from class Meta options.
<span class="gu">@@ -83,7 +140,7 @@ class SchemaMeta(ABCMeta):</span>
<span class="w"> </span>        :param inherited_fields: Inherited fields.
<span class="w"> </span>        :param dict_cls: dict-like class to use for dict output Default to ``dict``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dict_cls(inherited_fields + cls_fields)</span>

<span class="w"> </span>    def __init__(cls, name, bases, attrs):
<span class="w"> </span>        super().__init__(name, bases, attrs)
<span class="gu">@@ -91,51 +148,84 @@ class SchemaMeta(ABCMeta):</span>
<span class="w"> </span>            class_registry.register(name, cls)
<span class="w"> </span>        cls._hooks = cls.resolve_hooks()

<span class="gd">-    def resolve_hooks(cls) -&gt;dict[types.Tag, list[str]]:</span>
<span class="gi">+    def resolve_hooks(cls) -&gt; dict[types.Tag, list[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add in the decorated processors

<span class="w"> </span>        By doing this after constructing the class, we let standard inheritance
<span class="w"> </span>        do all the hard work.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mro = inspect.getmro(cls)</span>
<span class="gi">+</span>
<span class="gi">+        hooks = defaultdict(list)  # type: typing.Dict[types.Tag, typing.List[str]]</span>
<span class="gi">+</span>
<span class="gi">+        for attr_name in dir(cls):</span>
<span class="gi">+            # Need to look up the actual descriptor, not whatever might be</span>
<span class="gi">+            # bound to the class. This needs to come from the __dict__ of the</span>
<span class="gi">+            # declaring class.</span>
<span class="gi">+            for parent in mro:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    attr = parent.__dict__[attr_name]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # In case we didn&#39;t find the attribute and didn&#39;t break above.</span>
<span class="gi">+                # We should never hit this - it&#39;s just here for completeness</span>
<span class="gi">+                # to exclude the possibility of attr being undefined.</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                hook_config = attr.__marshmallow_hook__</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                for key in hook_config.keys():</span>
<span class="gi">+                    # Use name here so we can get the bound method later, in</span>
<span class="gi">+                    # case the processor was a descriptor or something.</span>
<span class="gi">+                    hooks[key].append(attr_name)</span>
<span class="gi">+</span>
<span class="gi">+        return hooks</span>


<span class="w"> </span>class SchemaOpts:
<span class="w"> </span>    &quot;&quot;&quot;class Meta options for the :class:`Schema`. Defines defaults.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, meta, ordered: bool=False):</span>
<span class="gd">-        self.fields = getattr(meta, &#39;fields&#39;, ())</span>
<span class="gi">+    def __init__(self, meta, ordered: bool = False):</span>
<span class="gi">+        self.fields = getattr(meta, &quot;fields&quot;, ())</span>
<span class="w"> </span>        if not isinstance(self.fields, (list, tuple)):
<span class="gd">-            raise ValueError(&#39;`fields` option must be a list or tuple.&#39;)</span>
<span class="gd">-        self.additional = getattr(meta, &#39;additional&#39;, ())</span>
<span class="gi">+            raise ValueError(&quot;`fields` option must be a list or tuple.&quot;)</span>
<span class="gi">+        self.additional = getattr(meta, &quot;additional&quot;, ())</span>
<span class="w"> </span>        if not isinstance(self.additional, (list, tuple)):
<span class="gd">-            raise ValueError(&#39;`additional` option must be a list or tuple.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;`additional` option must be a list or tuple.&quot;)</span>
<span class="w"> </span>        if self.fields and self.additional:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;Cannot set both `fields` and `additional` options for the same Schema.&#39;</span>
<span class="gd">-                )</span>
<span class="gd">-        self.exclude = getattr(meta, &#39;exclude&#39;, ())</span>
<span class="gi">+                &quot;Cannot set both `fields` and `additional` options&quot;</span>
<span class="gi">+                &quot; for the same Schema.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        self.exclude = getattr(meta, &quot;exclude&quot;, ())</span>
<span class="w"> </span>        if not isinstance(self.exclude, (list, tuple)):
<span class="gd">-            raise ValueError(&#39;`exclude` must be a list or tuple.&#39;)</span>
<span class="gd">-        self.dateformat = getattr(meta, &#39;dateformat&#39;, None)</span>
<span class="gd">-        self.datetimeformat = getattr(meta, &#39;datetimeformat&#39;, None)</span>
<span class="gd">-        self.timeformat = getattr(meta, &#39;timeformat&#39;, None)</span>
<span class="gd">-        if hasattr(meta, &#39;json_module&#39;):</span>
<span class="gi">+            raise ValueError(&quot;`exclude` must be a list or tuple.&quot;)</span>
<span class="gi">+        self.dateformat = getattr(meta, &quot;dateformat&quot;, None)</span>
<span class="gi">+        self.datetimeformat = getattr(meta, &quot;datetimeformat&quot;, None)</span>
<span class="gi">+        self.timeformat = getattr(meta, &quot;timeformat&quot;, None)</span>
<span class="gi">+        if hasattr(meta, &quot;json_module&quot;):</span>
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &#39;The json_module class Meta option is deprecated. Use render_module instead.&#39;</span>
<span class="gd">-                , RemovedInMarshmallow4Warning, stacklevel=2)</span>
<span class="gd">-            render_module = getattr(meta, &#39;json_module&#39;, json)</span>
<span class="gi">+                &quot;The json_module class Meta option is deprecated. Use render_module instead.&quot;,</span>
<span class="gi">+                RemovedInMarshmallow4Warning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+            render_module = getattr(meta, &quot;json_module&quot;, json)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            render_module = json
<span class="gd">-        self.render_module = getattr(meta, &#39;render_module&#39;, render_module)</span>
<span class="gd">-        self.ordered = getattr(meta, &#39;ordered&#39;, ordered)</span>
<span class="gd">-        self.index_errors = getattr(meta, &#39;index_errors&#39;, True)</span>
<span class="gd">-        self.include = getattr(meta, &#39;include&#39;, {})</span>
<span class="gd">-        self.load_only = getattr(meta, &#39;load_only&#39;, ())</span>
<span class="gd">-        self.dump_only = getattr(meta, &#39;dump_only&#39;, ())</span>
<span class="gd">-        self.unknown = validate_unknown_parameter_value(getattr(meta,</span>
<span class="gd">-            &#39;unknown&#39;, RAISE))</span>
<span class="gd">-        self.register = getattr(meta, &#39;register&#39;, True)</span>
<span class="gi">+        self.render_module = getattr(meta, &quot;render_module&quot;, render_module)</span>
<span class="gi">+        self.ordered = getattr(meta, &quot;ordered&quot;, ordered)</span>
<span class="gi">+        self.index_errors = getattr(meta, &quot;index_errors&quot;, True)</span>
<span class="gi">+        self.include = getattr(meta, &quot;include&quot;, {})</span>
<span class="gi">+        self.load_only = getattr(meta, &quot;load_only&quot;, ())</span>
<span class="gi">+        self.dump_only = getattr(meta, &quot;dump_only&quot;, ())</span>
<span class="gi">+        self.unknown = validate_unknown_parameter_value(getattr(meta, &quot;unknown&quot;, RAISE))</span>
<span class="gi">+        self.register = getattr(meta, &quot;register&quot;, True)</span>


<span class="w"> </span>class Schema(base.SchemaABC, metaclass=SchemaMeta):
<span class="gu">@@ -197,21 +287,39 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        `__accessor__` and `__error_handler__` are deprecated. Implement the
<span class="w"> </span>        `handle_error` and `get_attribute` methods instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    TYPE_MAPPING = {str: ma_fields.String, bytes: ma_fields.String, dt.</span>
<span class="gd">-        datetime: ma_fields.DateTime, float: ma_fields.Float, bool:</span>
<span class="gd">-        ma_fields.Boolean, tuple: ma_fields.Raw, list: ma_fields.Raw, set:</span>
<span class="gd">-        ma_fields.Raw, int: ma_fields.Integer, uuid.UUID: ma_fields.UUID,</span>
<span class="gd">-        dt.time: ma_fields.Time, dt.date: ma_fields.Date, dt.timedelta:</span>
<span class="gd">-        ma_fields.TimeDelta, decimal.Decimal: ma_fields.Decimal}</span>
<span class="gd">-    error_messages = {}</span>
<span class="gd">-    _default_error_messages = {&#39;type&#39;: &#39;Invalid input type.&#39;, &#39;unknown&#39;:</span>
<span class="gd">-        &#39;Unknown field.&#39;}</span>
<span class="gd">-    OPTIONS_CLASS = SchemaOpts</span>
<span class="gi">+</span>
<span class="gi">+    TYPE_MAPPING = {</span>
<span class="gi">+        str: ma_fields.String,</span>
<span class="gi">+        bytes: ma_fields.String,</span>
<span class="gi">+        dt.datetime: ma_fields.DateTime,</span>
<span class="gi">+        float: ma_fields.Float,</span>
<span class="gi">+        bool: ma_fields.Boolean,</span>
<span class="gi">+        tuple: ma_fields.Raw,</span>
<span class="gi">+        list: ma_fields.Raw,</span>
<span class="gi">+        set: ma_fields.Raw,</span>
<span class="gi">+        int: ma_fields.Integer,</span>
<span class="gi">+        uuid.UUID: ma_fields.UUID,</span>
<span class="gi">+        dt.time: ma_fields.Time,</span>
<span class="gi">+        dt.date: ma_fields.Date,</span>
<span class="gi">+        dt.timedelta: ma_fields.TimeDelta,</span>
<span class="gi">+        decimal.Decimal: ma_fields.Decimal,</span>
<span class="gi">+    }  # type: typing.Dict[type, typing.Type[ma_fields.Field]]</span>
<span class="gi">+    #: Overrides for default schema-level error messages</span>
<span class="gi">+    error_messages = {}  # type: typing.Dict[str, str]</span>
<span class="gi">+</span>
<span class="gi">+    _default_error_messages = {</span>
<span class="gi">+        &quot;type&quot;: &quot;Invalid input type.&quot;,</span>
<span class="gi">+        &quot;unknown&quot;: &quot;Unknown field.&quot;,</span>
<span class="gi">+    }  # type: typing.Dict[str, str]</span>
<span class="gi">+</span>
<span class="gi">+    OPTIONS_CLASS = SchemaOpts  # type: type</span>
<span class="gi">+</span>
<span class="w"> </span>    set_class = OrderedSet
<span class="gd">-    opts = None</span>
<span class="gd">-    _declared_fields = {}</span>
<span class="gd">-    _hooks = {}</span>

<span class="gi">+    # These get set by SchemaMeta</span>
<span class="gi">+    opts = None  # type: SchemaOpts</span>
<span class="gi">+    _declared_fields = {}  # type: typing.Dict[str, ma_fields.Field]</span>
<span class="gi">+    _hooks = {}  # type: typing.Dict[types.Tag, typing.List[str]]</span>

<span class="w"> </span>    class Meta:
<span class="w"> </span>        &quot;&quot;&quot;Options object for a Schema.
<span class="gu">@@ -252,47 +360,67 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>            usage is critical. Defaults to `True`.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, only: (types.StrSequenceOrSet | None)=None,</span>
<span class="gd">-        exclude: types.StrSequenceOrSet=(), many: bool=False, context: (</span>
<span class="gd">-        dict | None)=None, load_only: types.StrSequenceOrSet=(), dump_only:</span>
<span class="gd">-        types.StrSequenceOrSet=(), partial: (bool | types.StrSequenceOrSet |</span>
<span class="gd">-        None)=None, unknown: (str | None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        only: types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        exclude: types.StrSequenceOrSet = (),</span>
<span class="gi">+        many: bool = False,</span>
<span class="gi">+        context: dict | None = None,</span>
<span class="gi">+        load_only: types.StrSequenceOrSet = (),</span>
<span class="gi">+        dump_only: types.StrSequenceOrSet = (),</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        unknown: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Raise error if only or exclude is passed as string, not list of strings</span>
<span class="w"> </span>        if only is not None and not is_collection(only):
<span class="gd">-            raise StringNotCollectionError(&#39;&quot;only&quot; should be a list of strings&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise StringNotCollectionError(&#39;&quot;only&quot; should be a list of strings&#39;)</span>
<span class="w"> </span>        if not is_collection(exclude):
<span class="gd">-            raise StringNotCollectionError(</span>
<span class="gd">-                &#39;&quot;exclude&quot; should be a list of strings&#39;)</span>
<span class="gi">+            raise StringNotCollectionError(&#39;&quot;exclude&quot; should be a list of strings&#39;)</span>
<span class="gi">+        # copy declared fields from metaclass</span>
<span class="w"> </span>        self.declared_fields = copy.deepcopy(self._declared_fields)
<span class="w"> </span>        self.many = many
<span class="w"> </span>        self.only = only
<span class="w"> </span>        self.exclude: set[typing.Any] | typing.MutableSet[typing.Any] = set(
<span class="gd">-            self.opts.exclude) | set(exclude)</span>
<span class="gi">+            self.opts.exclude</span>
<span class="gi">+        ) | set(exclude)</span>
<span class="w"> </span>        self.ordered = self.opts.ordered
<span class="w"> </span>        self.load_only = set(load_only) or set(self.opts.load_only)
<span class="w"> </span>        self.dump_only = set(dump_only) or set(self.opts.dump_only)
<span class="w"> </span>        self.partial = partial
<span class="gd">-        self.unknown = (self.opts.unknown if unknown is None else</span>
<span class="gd">-            validate_unknown_parameter_value(unknown))</span>
<span class="gi">+        self.unknown = (</span>
<span class="gi">+            self.opts.unknown</span>
<span class="gi">+            if unknown is None</span>
<span class="gi">+            else validate_unknown_parameter_value(unknown)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.context = context or {}
<span class="w"> </span>        self._normalize_nested_options()
<span class="gd">-        self.fields = {}</span>
<span class="gd">-        self.load_fields = {}</span>
<span class="gd">-        self.dump_fields = {}</span>
<span class="gi">+        #: Dictionary mapping field_names -&gt; :class:`Field` objects</span>
<span class="gi">+        self.fields = {}  # type: typing.Dict[str, ma_fields.Field]</span>
<span class="gi">+        self.load_fields = {}  # type: typing.Dict[str, ma_fields.Field]</span>
<span class="gi">+        self.dump_fields = {}  # type: typing.Dict[str, ma_fields.Field]</span>
<span class="w"> </span>        self._init_fields()
<span class="w"> </span>        messages = {}
<span class="w"> </span>        messages.update(self._default_error_messages)
<span class="w"> </span>        for cls in reversed(self.__class__.__mro__):
<span class="gd">-            messages.update(getattr(cls, &#39;error_messages&#39;, {}))</span>
<span class="gi">+            messages.update(getattr(cls, &quot;error_messages&quot;, {}))</span>
<span class="w"> </span>        messages.update(self.error_messages or {})
<span class="w"> </span>        self.error_messages = messages

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__}(many={self.many})&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__}(many={self.many})&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def dict_class(self) -&gt; type:</span>
<span class="gi">+        return OrderedDict if self.ordered else dict</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_dict(cls, fields: dict[str, ma_fields.Field | type], *, name:</span>
<span class="gd">-        str=&#39;GeneratedSchema&#39;) -&gt;type:</span>
<span class="gi">+    def from_dict(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        fields: dict[str, ma_fields.Field | type],</span>
<span class="gi">+        *,</span>
<span class="gi">+        name: str = &quot;GeneratedSchema&quot;,</span>
<span class="gi">+    ) -&gt; type:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a `Schema` class given a dictionary of fields.

<span class="w"> </span>        .. code-block:: python
<span class="gu">@@ -311,10 +439,18 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>

<span class="w"> </span>        .. versionadded:: 3.0.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def handle_error(self, error: ValidationError, data: typing.Any, *,</span>
<span class="gd">-        many: bool, **kwargs):</span>
<span class="gi">+        attrs = fields.copy()</span>
<span class="gi">+        attrs[&quot;Meta&quot;] = type(</span>
<span class="gi">+            &quot;GeneratedMeta&quot;, (getattr(cls, &quot;Meta&quot;, object),), {&quot;register&quot;: False}</span>
<span class="gi">+        )</span>
<span class="gi">+        schema_cls = type(name, (cls,), attrs)</span>
<span class="gi">+        return schema_cls</span>
<span class="gi">+</span>
<span class="gi">+    ##### Override-able methods #####</span>
<span class="gi">+</span>
<span class="gi">+    def handle_error(</span>
<span class="gi">+        self, error: ValidationError, data: typing.Any, *, many: bool, **kwargs</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Custom error handler function for the schema.

<span class="w"> </span>        :param error: The `ValidationError` raised during (de)serialization.
<span class="gu">@@ -337,11 +473,12 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0a1
<span class="w"> </span>            Changed position of ``obj`` and ``attr``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return get_value(obj, attr, default)</span>
<span class="gi">+</span>
<span class="gi">+    ##### Serialization/Deserialization API #####</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _call_and_store(getter_func, data, *, field_name, error_store,</span>
<span class="gd">-        index=None):</span>
<span class="gi">+    def _call_and_store(getter_func, data, *, field_name, error_store, index=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Call ``getter_func`` with ``data`` as its argument, and store any `ValidationErrors`.

<span class="w"> </span>        :param callable getter_func: Function for getting the serialized/deserialized
<span class="gu">@@ -351,9 +488,16 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        :param int index: Index of the item being validated, if validating a collection,
<span class="w"> </span>            otherwise `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _serialize(self, obj: (_T | typing.Iterable[_T]), *, many: bool=False):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = getter_func(data)</span>
<span class="gi">+        except ValidationError as error:</span>
<span class="gi">+            error_store.store_error(error.messages, field_name, index=index)</span>
<span class="gi">+            # When a Nested field fails validation, the marshalled data is stored</span>
<span class="gi">+            # on the ValidationError&#39;s valid_data attribute</span>
<span class="gi">+            return error.valid_data or missing</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self, obj: _T | typing.Iterable[_T], *, many: bool = False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize ``obj``.

<span class="w"> </span>        :param obj: The object(s) to serialize.
<span class="gu">@@ -363,9 +507,21 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        .. versionchanged:: 1.0.0
<span class="w"> </span>            Renamed from ``marshal``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def dump(self, obj: typing.Any, *, many: (bool | None)=None):</span>
<span class="gi">+        if many and obj is not None:</span>
<span class="gi">+            return [</span>
<span class="gi">+                self._serialize(d, many=False)</span>
<span class="gi">+                for d in typing.cast(typing.Iterable[_T], obj)</span>
<span class="gi">+            ]</span>
<span class="gi">+        ret = self.dict_class()</span>
<span class="gi">+        for attr_name, field_obj in self.dump_fields.items():</span>
<span class="gi">+            value = field_obj.serialize(attr_name, obj, accessor=self.get_attribute)</span>
<span class="gi">+            if value is missing:</span>
<span class="gi">+                continue</span>
<span class="gi">+            key = field_obj.data_key if field_obj.data_key is not None else attr_name</span>
<span class="gi">+            ret[key] = value</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self, obj: typing.Any, *, many: bool | None = None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize an object to native Python data types according to this
<span class="w"> </span>        Schema&#39;s fields.

<span class="gu">@@ -382,10 +538,24 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0rc9
<span class="w"> </span>            Validation no longer occurs upon serialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        many = self.many if many is None else bool(many)</span>
<span class="gi">+        if self._has_processors(PRE_DUMP):</span>
<span class="gi">+            processed_obj = self._invoke_dump_processors(</span>
<span class="gi">+                PRE_DUMP, obj, many=many, original_data=obj</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            processed_obj = obj</span>

<span class="gd">-    def dumps(self, obj: typing.Any, *args, many: (bool | None)=None, **kwargs</span>
<span class="gd">-        ):</span>
<span class="gi">+        result = self._serialize(processed_obj, many=many)</span>
<span class="gi">+</span>
<span class="gi">+        if self._has_processors(POST_DUMP):</span>
<span class="gi">+            result = self._invoke_dump_processors(</span>
<span class="gi">+                POST_DUMP, result, many=many, original_data=obj</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def dumps(self, obj: typing.Any, *args, many: bool | None = None, **kwargs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Same as :meth:`dump`, except return a JSON-encoded string.

<span class="w"> </span>        :param obj: The object to serialize.
<span class="gu">@@ -399,12 +569,22 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
<span class="w"> </span>            if ``obj`` is invalid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _deserialize(self, data: (typing.Mapping[str, typing.Any] | typing.</span>
<span class="gd">-        Iterable[typing.Mapping[str, typing.Any]]), *, error_store:</span>
<span class="gd">-        ErrorStore, many: bool=False, partial=None, unknown=RAISE, index=None</span>
<span class="gd">-        ) -&gt;(_T | list[_T]):</span>
<span class="gi">+        serialized = self.dump(obj, many=many)</span>
<span class="gi">+        return self.opts.render_module.dumps(serialized, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: (</span>
<span class="gi">+            typing.Mapping[str, typing.Any]</span>
<span class="gi">+            | typing.Iterable[typing.Mapping[str, typing.Any]]</span>
<span class="gi">+        ),</span>
<span class="gi">+        *,</span>
<span class="gi">+        error_store: ErrorStore,</span>
<span class="gi">+        many: bool = False,</span>
<span class="gi">+        partial=None,</span>
<span class="gi">+        unknown=RAISE,</span>
<span class="gi">+        index=None,</span>
<span class="gi">+    ) -&gt; _T | list[_T]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize ``data``.

<span class="w"> </span>        :param dict data: The data to deserialize.
<span class="gu">@@ -420,12 +600,105 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>            serializing a collection, otherwise `None`.
<span class="w"> </span>        :return: A dictionary of the deserialized data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def load(self, data: (typing.Mapping[str, typing.Any] | typing.Iterable</span>
<span class="gd">-        [typing.Mapping[str, typing.Any]]), *, many: (bool | None)=None,</span>
<span class="gd">-        partial: (bool | types.StrSequenceOrSet | None)=None, unknown: (str |</span>
<span class="gd">-        None)=None):</span>
<span class="gi">+        index_errors = self.opts.index_errors</span>
<span class="gi">+        index = index if index_errors else None</span>
<span class="gi">+        if many:</span>
<span class="gi">+            if not is_collection(data):</span>
<span class="gi">+                error_store.store_error([self.error_messages[&quot;type&quot;]], index=index)</span>
<span class="gi">+                ret_l = []  # type: typing.List[_T]</span>
<span class="gi">+            else:</span>
<span class="gi">+                ret_l = [</span>
<span class="gi">+                    typing.cast(</span>
<span class="gi">+                        _T,</span>
<span class="gi">+                        self._deserialize(</span>
<span class="gi">+                            typing.cast(typing.Mapping[str, typing.Any], d),</span>
<span class="gi">+                            error_store=error_store,</span>
<span class="gi">+                            many=False,</span>
<span class="gi">+                            partial=partial,</span>
<span class="gi">+                            unknown=unknown,</span>
<span class="gi">+                            index=idx,</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for idx, d in enumerate(data)</span>
<span class="gi">+                ]</span>
<span class="gi">+            return ret_l</span>
<span class="gi">+        ret_d = self.dict_class()</span>
<span class="gi">+        # Check data is a dict</span>
<span class="gi">+        if not isinstance(data, Mapping):</span>
<span class="gi">+            error_store.store_error([self.error_messages[&quot;type&quot;]], index=index)</span>
<span class="gi">+        else:</span>
<span class="gi">+            partial_is_collection = is_collection(partial)</span>
<span class="gi">+            for attr_name, field_obj in self.load_fields.items():</span>
<span class="gi">+                field_name = (</span>
<span class="gi">+                    field_obj.data_key if field_obj.data_key is not None else attr_name</span>
<span class="gi">+                )</span>
<span class="gi">+                raw_value = data.get(field_name, missing)</span>
<span class="gi">+                if raw_value is missing:</span>
<span class="gi">+                    # Ignore missing field if we&#39;re allowed to.</span>
<span class="gi">+                    if partial is True or (</span>
<span class="gi">+                        partial_is_collection and attr_name in partial</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                d_kwargs = {}</span>
<span class="gi">+                # Allow partial loading of nested schemas.</span>
<span class="gi">+                if partial_is_collection:</span>
<span class="gi">+                    prefix = field_name + &quot;.&quot;</span>
<span class="gi">+                    len_prefix = len(prefix)</span>
<span class="gi">+                    sub_partial = [</span>
<span class="gi">+                        f[len_prefix:] for f in partial if f.startswith(prefix)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                    d_kwargs[&quot;partial&quot;] = sub_partial</span>
<span class="gi">+                elif partial is not None:</span>
<span class="gi">+                    d_kwargs[&quot;partial&quot;] = partial</span>
<span class="gi">+</span>
<span class="gi">+                def getter(</span>
<span class="gi">+                    val, field_obj=field_obj, field_name=field_name, d_kwargs=d_kwargs</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return field_obj.deserialize(</span>
<span class="gi">+                        val,</span>
<span class="gi">+                        field_name,</span>
<span class="gi">+                        data,</span>
<span class="gi">+                        **d_kwargs,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                value = self._call_and_store(</span>
<span class="gi">+                    getter_func=getter,</span>
<span class="gi">+                    data=raw_value,</span>
<span class="gi">+                    field_name=field_name,</span>
<span class="gi">+                    error_store=error_store,</span>
<span class="gi">+                    index=index,</span>
<span class="gi">+                )</span>
<span class="gi">+                if value is not missing:</span>
<span class="gi">+                    key = field_obj.attribute or attr_name</span>
<span class="gi">+                    set_value(ret_d, key, value)</span>
<span class="gi">+            if unknown != EXCLUDE:</span>
<span class="gi">+                fields = {</span>
<span class="gi">+                    field_obj.data_key if field_obj.data_key is not None else field_name</span>
<span class="gi">+                    for field_name, field_obj in self.load_fields.items()</span>
<span class="gi">+                }</span>
<span class="gi">+                for key in set(data) - fields:</span>
<span class="gi">+                    value = data[key]</span>
<span class="gi">+                    if unknown == INCLUDE:</span>
<span class="gi">+                        ret_d[key] = value</span>
<span class="gi">+                    elif unknown == RAISE:</span>
<span class="gi">+                        error_store.store_error(</span>
<span class="gi">+                            [self.error_messages[&quot;unknown&quot;]],</span>
<span class="gi">+                            key,</span>
<span class="gi">+                            (index if index_errors else None),</span>
<span class="gi">+                        )</span>
<span class="gi">+        return ret_d</span>
<span class="gi">+</span>
<span class="gi">+    def load(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: (</span>
<span class="gi">+            typing.Mapping[str, typing.Any]</span>
<span class="gi">+            | typing.Iterable[typing.Mapping[str, typing.Any]]</span>
<span class="gi">+        ),</span>
<span class="gi">+        *,</span>
<span class="gi">+        many: bool | None = None,</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        unknown: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize a data structure to an object defined by this Schema&#39;s fields.

<span class="w"> </span>        :param data: The data to deserialize.
<span class="gu">@@ -446,11 +719,19 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
<span class="w"> </span>            if invalid data are passed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def loads(self, json_data: str, *, many: (bool | None)=None, partial: (</span>
<span class="gd">-        bool | types.StrSequenceOrSet | None)=None, unknown: (str | None)=</span>
<span class="gd">-        None, **kwargs):</span>
<span class="gi">+        return self._do_load(</span>
<span class="gi">+            data, many=many, partial=partial, unknown=unknown, postprocess=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def loads(</span>
<span class="gi">+        self,</span>
<span class="gi">+        json_data: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        many: bool | None = None,</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        unknown: str | None = None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Same as :meth:`load`, except it takes a JSON string as input.

<span class="w"> </span>        :param json_data: A JSON string of the data to deserialize.
<span class="gu">@@ -471,12 +752,39 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
<span class="w"> </span>            if invalid data are passed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def validate(self, data: (typing.Mapping[str, typing.Any] | typing.</span>
<span class="gd">-        Iterable[typing.Mapping[str, typing.Any]]), *, many: (bool | None)=</span>
<span class="gd">-        None, partial: (bool | types.StrSequenceOrSet | None)=None) -&gt;dict[</span>
<span class="gd">-        str, list[str]]:</span>
<span class="gi">+        data = self.opts.render_module.loads(json_data, **kwargs)</span>
<span class="gi">+        return self.load(data, many=many, partial=partial, unknown=unknown)</span>
<span class="gi">+</span>
<span class="gi">+    def _run_validator(</span>
<span class="gi">+        self,</span>
<span class="gi">+        validator_func,</span>
<span class="gi">+        output,</span>
<span class="gi">+        *,</span>
<span class="gi">+        original_data,</span>
<span class="gi">+        error_store,</span>
<span class="gi">+        many,</span>
<span class="gi">+        partial,</span>
<span class="gi">+        pass_original,</span>
<span class="gi">+        index=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if pass_original:  # Pass original, raw data (before unmarshalling)</span>
<span class="gi">+                validator_func(output, original_data, partial=partial, many=many)</span>
<span class="gi">+            else:</span>
<span class="gi">+                validator_func(output, partial=partial, many=many)</span>
<span class="gi">+        except ValidationError as err:</span>
<span class="gi">+            error_store.store_error(err.messages, err.field_name, index=index)</span>
<span class="gi">+</span>
<span class="gi">+    def validate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: (</span>
<span class="gi">+            typing.Mapping[str, typing.Any]</span>
<span class="gi">+            | typing.Iterable[typing.Mapping[str, typing.Any]]</span>
<span class="gi">+        ),</span>
<span class="gi">+        *,</span>
<span class="gi">+        many: bool | None = None,</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None = None,</span>
<span class="gi">+    ) -&gt; dict[str, list[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate `data` against the schema, returning a dictionary of
<span class="w"> </span>        validation errors.

<span class="gu">@@ -491,12 +799,26 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>

<span class="w"> </span>        .. versionadded:: 1.1.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _do_load(self, data: (typing.Mapping[str, typing.Any] | typing.</span>
<span class="gd">-        Iterable[typing.Mapping[str, typing.Any]]), *, many: (bool | None)=</span>
<span class="gd">-        None, partial: (bool | types.StrSequenceOrSet | None)=None, unknown:</span>
<span class="gd">-        (str | None)=None, postprocess: bool=True):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._do_load(data, many=many, partial=partial, postprocess=False)</span>
<span class="gi">+        except ValidationError as exc:</span>
<span class="gi">+            return typing.cast(typing.Dict[str, typing.List[str]], exc.messages)</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    ##### Private Helpers #####</span>
<span class="gi">+</span>
<span class="gi">+    def _do_load(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: (</span>
<span class="gi">+            typing.Mapping[str, typing.Any]</span>
<span class="gi">+            | typing.Iterable[typing.Mapping[str, typing.Any]]</span>
<span class="gi">+        ),</span>
<span class="gi">+        *,</span>
<span class="gi">+        many: bool | None = None,</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        unknown: str | None = None,</span>
<span class="gi">+        postprocess: bool = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.
<span class="w"> </span>        This method is private API.

<span class="gu">@@ -513,41 +835,394 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        :param postprocess: Whether to run post_load methods..
<span class="w"> </span>        :return: Deserialized data
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _normalize_nested_options(self) -&gt;None:</span>
<span class="gi">+        error_store = ErrorStore()</span>
<span class="gi">+        errors = {}  # type: dict[str, list[str]]</span>
<span class="gi">+        many = self.many if many is None else bool(many)</span>
<span class="gi">+        unknown = (</span>
<span class="gi">+            self.unknown</span>
<span class="gi">+            if unknown is None</span>
<span class="gi">+            else validate_unknown_parameter_value(unknown)</span>
<span class="gi">+        )</span>
<span class="gi">+        if partial is None:</span>
<span class="gi">+            partial = self.partial</span>
<span class="gi">+        # Run preprocessors</span>
<span class="gi">+        if self._has_processors(PRE_LOAD):</span>
<span class="gi">+            try:</span>
<span class="gi">+                processed_data = self._invoke_load_processors(</span>
<span class="gi">+                    PRE_LOAD, data, many=many, original_data=data, partial=partial</span>
<span class="gi">+                )</span>
<span class="gi">+            except ValidationError as err:</span>
<span class="gi">+                errors = err.normalized_messages()</span>
<span class="gi">+                result = None  # type: list | dict | None</span>
<span class="gi">+        else:</span>
<span class="gi">+            processed_data = data</span>
<span class="gi">+        if not errors:</span>
<span class="gi">+            # Deserialize data</span>
<span class="gi">+            result = self._deserialize(</span>
<span class="gi">+                processed_data,</span>
<span class="gi">+                error_store=error_store,</span>
<span class="gi">+                many=many,</span>
<span class="gi">+                partial=partial,</span>
<span class="gi">+                unknown=unknown,</span>
<span class="gi">+            )</span>
<span class="gi">+            # Run field-level validation</span>
<span class="gi">+            self._invoke_field_validators(</span>
<span class="gi">+                error_store=error_store, data=result, many=many</span>
<span class="gi">+            )</span>
<span class="gi">+            # Run schema-level validation</span>
<span class="gi">+            if self._has_processors(VALIDATES_SCHEMA):</span>
<span class="gi">+                field_errors = bool(error_store.errors)</span>
<span class="gi">+                self._invoke_schema_validators(</span>
<span class="gi">+                    error_store=error_store,</span>
<span class="gi">+                    pass_many=True,</span>
<span class="gi">+                    data=result,</span>
<span class="gi">+                    original_data=data,</span>
<span class="gi">+                    many=many,</span>
<span class="gi">+                    partial=partial,</span>
<span class="gi">+                    field_errors=field_errors,</span>
<span class="gi">+                )</span>
<span class="gi">+                self._invoke_schema_validators(</span>
<span class="gi">+                    error_store=error_store,</span>
<span class="gi">+                    pass_many=False,</span>
<span class="gi">+                    data=result,</span>
<span class="gi">+                    original_data=data,</span>
<span class="gi">+                    many=many,</span>
<span class="gi">+                    partial=partial,</span>
<span class="gi">+                    field_errors=field_errors,</span>
<span class="gi">+                )</span>
<span class="gi">+            errors = error_store.errors</span>
<span class="gi">+            # Run post processors</span>
<span class="gi">+            if not errors and postprocess and self._has_processors(POST_LOAD):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    result = self._invoke_load_processors(</span>
<span class="gi">+                        POST_LOAD,</span>
<span class="gi">+                        result,</span>
<span class="gi">+                        many=many,</span>
<span class="gi">+                        original_data=data,</span>
<span class="gi">+                        partial=partial,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except ValidationError as err:</span>
<span class="gi">+                    errors = err.normalized_messages()</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            exc = ValidationError(errors, data=data, valid_data=result)</span>
<span class="gi">+            self.handle_error(exc, data, many=many, partial=partial)</span>
<span class="gi">+            raise exc</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _normalize_nested_options(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply then flatten nested schema options.
<span class="w"> </span>        This method is private API.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __apply_nested_option(self, option_name, field_names, set_operation</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if self.only is not None:</span>
<span class="gi">+            # Apply the only option to nested fields.</span>
<span class="gi">+            self.__apply_nested_option(&quot;only&quot;, self.only, &quot;intersection&quot;)</span>
<span class="gi">+            # Remove the child field names from the only option.</span>
<span class="gi">+            self.only = self.set_class([field.split(&quot;.&quot;, 1)[0] for field in self.only])</span>
<span class="gi">+        if self.exclude:</span>
<span class="gi">+            # Apply the exclude option to nested fields.</span>
<span class="gi">+            self.__apply_nested_option(&quot;exclude&quot;, self.exclude, &quot;union&quot;)</span>
<span class="gi">+            # Remove the parent field names from the exclude option.</span>
<span class="gi">+            self.exclude = self.set_class(</span>
<span class="gi">+                [field for field in self.exclude if &quot;.&quot; not in field]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def __apply_nested_option(self, option_name, field_names, set_operation) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply nested options to nested fields&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _init_fields(self) -&gt;None:</span>
<span class="gi">+        # Split nested field names on the first dot.</span>
<span class="gi">+        nested_fields = [name.split(&quot;.&quot;, 1) for name in field_names if &quot;.&quot; in name]</span>
<span class="gi">+        # Partition the nested field names by parent field.</span>
<span class="gi">+        nested_options = defaultdict(list)  # type: defaultdict</span>
<span class="gi">+        for parent, nested_names in nested_fields:</span>
<span class="gi">+            nested_options[parent].append(nested_names)</span>
<span class="gi">+        # Apply the nested field options.</span>
<span class="gi">+        for key, options in iter(nested_options.items()):</span>
<span class="gi">+            new_options = self.set_class(options)</span>
<span class="gi">+            original_options = getattr(self.declared_fields[key], option_name, ())</span>
<span class="gi">+            if original_options:</span>
<span class="gi">+                if set_operation == &quot;union&quot;:</span>
<span class="gi">+                    new_options |= self.set_class(original_options)</span>
<span class="gi">+                if set_operation == &quot;intersection&quot;:</span>
<span class="gi">+                    new_options &amp;= self.set_class(original_options)</span>
<span class="gi">+            setattr(self.declared_fields[key], option_name, new_options)</span>
<span class="gi">+</span>
<span class="gi">+    def _init_fields(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update self.fields, self.load_fields, and self.dump_fields based on schema options.
<span class="w"> </span>        This method is private API.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.opts.fields:</span>
<span class="gi">+            available_field_names = self.set_class(self.opts.fields)</span>
<span class="gi">+        else:</span>
<span class="gi">+            available_field_names = self.set_class(self.declared_fields.keys())</span>
<span class="gi">+            if self.opts.additional:</span>
<span class="gi">+                available_field_names |= self.set_class(self.opts.additional)</span>
<span class="gi">+</span>
<span class="gi">+        invalid_fields = self.set_class()</span>
<span class="gi">+</span>
<span class="gi">+        if self.only is not None:</span>
<span class="gi">+            # Return only fields specified in only option</span>
<span class="gi">+            field_names: typing.AbstractSet[typing.Any] = self.set_class(self.only)</span>
<span class="gi">+</span>
<span class="gi">+            invalid_fields |= field_names - available_field_names</span>
<span class="gi">+        else:</span>
<span class="gi">+            field_names = available_field_names</span>
<span class="gi">+</span>
<span class="gi">+        # If &quot;exclude&quot; option or param is specified, remove those fields.</span>
<span class="gi">+        if self.exclude:</span>
<span class="gi">+            # Note that this isn&#39;t available_field_names, since we want to</span>
<span class="gi">+            # apply &quot;only&quot; for the actual calculation.</span>
<span class="gi">+            field_names = field_names - self.exclude</span>
<span class="gi">+            invalid_fields |= self.exclude - available_field_names</span>
<span class="gi">+</span>
<span class="gi">+        if invalid_fields:</span>
<span class="gi">+            message = f&quot;Invalid fields for {self}: {invalid_fields}.&quot;</span>
<span class="gi">+            raise ValueError(message)</span>
<span class="gi">+</span>
<span class="gi">+        fields_dict = self.dict_class()</span>
<span class="gi">+        for field_name in field_names:</span>
<span class="gi">+            field_obj = self.declared_fields.get(field_name, ma_fields.Inferred())</span>
<span class="gi">+            self._bind_field(field_name, field_obj)</span>
<span class="gi">+            fields_dict[field_name] = field_obj</span>
<span class="gi">+</span>
<span class="gi">+        load_fields, dump_fields = self.dict_class(), self.dict_class()</span>
<span class="gi">+        for field_name, field_obj in fields_dict.items():</span>
<span class="gi">+            if not field_obj.dump_only:</span>
<span class="gi">+                load_fields[field_name] = field_obj</span>
<span class="gi">+            if not field_obj.load_only:</span>
<span class="gi">+                dump_fields[field_name] = field_obj</span>
<span class="gi">+</span>
<span class="gi">+        dump_data_keys = [</span>
<span class="gi">+            field_obj.data_key if field_obj.data_key is not None else name</span>
<span class="gi">+            for name, field_obj in dump_fields.items()</span>
<span class="gi">+        ]</span>
<span class="gi">+        if len(dump_data_keys) != len(set(dump_data_keys)):</span>
<span class="gi">+            data_keys_duplicates = {</span>
<span class="gi">+                x for x in dump_data_keys if dump_data_keys.count(x) &gt; 1</span>
<span class="gi">+            }</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;The data_key argument for one or more fields collides &quot;</span>
<span class="gi">+                &quot;with another field&#39;s name or data_key argument. &quot;</span>
<span class="gi">+                &quot;Check the following field names and &quot;</span>
<span class="gi">+                f&quot;data_key arguments: {list(data_keys_duplicates)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        load_attributes = [obj.attribute or name for name, obj in load_fields.items()]</span>
<span class="gi">+        if len(load_attributes) != len(set(load_attributes)):</span>
<span class="gi">+            attributes_duplicates = {</span>
<span class="gi">+                x for x in load_attributes if load_attributes.count(x) &gt; 1</span>
<span class="gi">+            }</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;The attribute argument for one or more fields collides &quot;</span>
<span class="gi">+                &quot;with another field&#39;s name or attribute argument. &quot;</span>
<span class="gi">+                &quot;Check the following field names and &quot;</span>
<span class="gi">+                f&quot;attribute arguments: {list(attributes_duplicates)}&quot;</span>
<span class="gi">+            )</span>

<span class="gd">-    def on_bind_field(self, field_name: str, field_obj: ma_fields.Field</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        self.fields = fields_dict</span>
<span class="gi">+        self.dump_fields = dump_fields</span>
<span class="gi">+        self.load_fields = load_fields</span>
<span class="gi">+</span>
<span class="gi">+    def on_bind_field(self, field_name: str, field_obj: ma_fields.Field) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook to modify a field when it is bound to the `Schema`.

<span class="w"> </span>        No-op by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def _bind_field(self, field_name: str, field_obj: ma_fields.Field) -&gt;None:</span>
<span class="gi">+    def _bind_field(self, field_name: str, field_obj: ma_fields.Field) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bind field to the schema, setting any necessary attributes on the
<span class="w"> </span>        field (e.g. parent and name).

<span class="w"> </span>        Also set field load_only and dump_only values if field_name was
<span class="w"> </span>        specified in ``class Meta``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if field_name in self.load_only:</span>
<span class="gi">+            field_obj.load_only = True</span>
<span class="gi">+        if field_name in self.dump_only:</span>
<span class="gi">+            field_obj.dump_only = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            field_obj._bind_to_schema(field_name, self)</span>
<span class="gi">+        except TypeError as error:</span>
<span class="gi">+            # Field declared as a class, not an instance. Ignore type checking because</span>
<span class="gi">+            # we handle unsupported arg types, i.e. this is dead code from</span>
<span class="gi">+            # the type checker&#39;s perspective.</span>
<span class="gi">+            if isinstance(field_obj, type) and issubclass(field_obj, base.FieldABC):</span>
<span class="gi">+                msg = (</span>
<span class="gi">+                    f&#39;Field for &quot;{field_name}&quot; must be declared as a &#39;</span>
<span class="gi">+                    &quot;Field instance, not a class. &quot;</span>
<span class="gi">+                    f&#39;Did you mean &quot;fields.{field_obj.__name__}()&quot;?&#39;  # type: ignore</span>
<span class="gi">+                )</span>
<span class="gi">+                raise TypeError(msg) from error</span>
<span class="gi">+            raise error</span>
<span class="gi">+        self.on_bind_field(field_name, field_obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _has_processors(self, tag) -&gt; bool:</span>
<span class="gi">+        return bool(self._hooks[(tag, True)] or self._hooks[(tag, False)])</span>
<span class="gi">+</span>
<span class="gi">+    def _invoke_dump_processors(</span>
<span class="gi">+        self, tag: str, data, *, many: bool, original_data=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        # The pass_many post-dump processors may do things like add an envelope, so</span>
<span class="gi">+        # invoke those after invoking the non-pass_many processors which will expect</span>
<span class="gi">+        # to get a list of items.</span>
<span class="gi">+        data = self._invoke_processors(</span>
<span class="gi">+            tag, pass_many=False, data=data, many=many, original_data=original_data</span>
<span class="gi">+        )</span>
<span class="gi">+        data = self._invoke_processors(</span>
<span class="gi">+            tag, pass_many=True, data=data, many=many, original_data=original_data</span>
<span class="gi">+        )</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def _invoke_load_processors(</span>
<span class="gi">+        self,</span>
<span class="gi">+        tag: str,</span>
<span class="gi">+        data,</span>
<span class="gi">+        *,</span>
<span class="gi">+        many: bool,</span>
<span class="gi">+        original_data,</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # This has to invert the order of the dump processors, so run the pass_many</span>
<span class="gi">+        # processors first.</span>
<span class="gi">+        data = self._invoke_processors(</span>
<span class="gi">+            tag,</span>
<span class="gi">+            pass_many=True,</span>
<span class="gi">+            data=data,</span>
<span class="gi">+            many=many,</span>
<span class="gi">+            original_data=original_data,</span>
<span class="gi">+            partial=partial,</span>
<span class="gi">+        )</span>
<span class="gi">+        data = self._invoke_processors(</span>
<span class="gi">+            tag,</span>
<span class="gi">+            pass_many=False,</span>
<span class="gi">+            data=data,</span>
<span class="gi">+            many=many,</span>
<span class="gi">+            original_data=original_data,</span>
<span class="gi">+            partial=partial,</span>
<span class="gi">+        )</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def _invoke_field_validators(self, *, error_store: ErrorStore, data, many: bool):</span>
<span class="gi">+        for attr_name in self._hooks[VALIDATES]:</span>
<span class="gi">+            validator = getattr(self, attr_name)</span>
<span class="gi">+            validator_kwargs = validator.__marshmallow_hook__[VALIDATES]</span>
<span class="gi">+            field_name = validator_kwargs[&quot;field_name&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                field_obj = self.fields[field_name]</span>
<span class="gi">+            except KeyError as error:</span>
<span class="gi">+                if field_name in self.declared_fields:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                raise ValueError(f&#39;&quot;{field_name}&quot; field does not exist.&#39;) from error</span>
<span class="gi">+</span>
<span class="gi">+            data_key = (</span>
<span class="gi">+                field_obj.data_key if field_obj.data_key is not None else field_name</span>
<span class="gi">+            )</span>
<span class="gi">+            if many:</span>
<span class="gi">+                for idx, item in enumerate(data):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = item[field_obj.attribute or field_name]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        validated_value = self._call_and_store(</span>
<span class="gi">+                            getter_func=validator,</span>
<span class="gi">+                            data=value,</span>
<span class="gi">+                            field_name=data_key,</span>
<span class="gi">+                            error_store=error_store,</span>
<span class="gi">+                            index=(idx if self.opts.index_errors else None),</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if validated_value is missing:</span>
<span class="gi">+                            data[idx].pop(field_name, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    value = data[field_obj.attribute or field_name]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    validated_value = self._call_and_store(</span>
<span class="gi">+                        getter_func=validator,</span>
<span class="gi">+                        data=value,</span>
<span class="gi">+                        field_name=data_key,</span>
<span class="gi">+                        error_store=error_store,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if validated_value is missing:</span>
<span class="gi">+                        data.pop(field_name, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _invoke_schema_validators(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        error_store: ErrorStore,</span>
<span class="gi">+        pass_many: bool,</span>
<span class="gi">+        data,</span>
<span class="gi">+        original_data,</span>
<span class="gi">+        many: bool,</span>
<span class="gi">+        partial: bool | types.StrSequenceOrSet | None,</span>
<span class="gi">+        field_errors: bool = False,</span>
<span class="gi">+    ):</span>
<span class="gi">+        for attr_name in self._hooks[(VALIDATES_SCHEMA, pass_many)]:</span>
<span class="gi">+            validator = getattr(self, attr_name)</span>
<span class="gi">+            validator_kwargs = validator.__marshmallow_hook__[</span>
<span class="gi">+                (VALIDATES_SCHEMA, pass_many)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if field_errors and validator_kwargs[&quot;skip_on_field_errors&quot;]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            pass_original = validator_kwargs.get(&quot;pass_original&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+            if many and not pass_many:</span>
<span class="gi">+                for idx, (item, orig) in enumerate(zip(data, original_data)):</span>
<span class="gi">+                    self._run_validator(</span>
<span class="gi">+                        validator,</span>
<span class="gi">+                        item,</span>
<span class="gi">+                        original_data=orig,</span>
<span class="gi">+                        error_store=error_store,</span>
<span class="gi">+                        many=many,</span>
<span class="gi">+                        partial=partial,</span>
<span class="gi">+                        index=idx,</span>
<span class="gi">+                        pass_original=pass_original,</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._run_validator(</span>
<span class="gi">+                    validator,</span>
<span class="gi">+                    data,</span>
<span class="gi">+                    original_data=original_data,</span>
<span class="gi">+                    error_store=error_store,</span>
<span class="gi">+                    many=many,</span>
<span class="gi">+                    pass_original=pass_original,</span>
<span class="gi">+                    partial=partial,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _invoke_processors(</span>
<span class="gi">+        self,</span>
<span class="gi">+        tag: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        pass_many: bool,</span>
<span class="gi">+        data,</span>
<span class="gi">+        many: bool,</span>
<span class="gi">+        original_data=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        key = (tag, pass_many)</span>
<span class="gi">+        for attr_name in self._hooks[key]:</span>
<span class="gi">+            # This will be a bound method.</span>
<span class="gi">+            processor = getattr(self, attr_name)</span>
<span class="gi">+</span>
<span class="gi">+            processor_kwargs = processor.__marshmallow_hook__[key]</span>
<span class="gi">+            pass_original = processor_kwargs.get(&quot;pass_original&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+            if many and not pass_many:</span>
<span class="gi">+                if pass_original:</span>
<span class="gi">+                    data = [</span>
<span class="gi">+                        processor(item, original, many=many, **kwargs)</span>
<span class="gi">+                        for item, original in zip(data, original_data)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data = [processor(item, many=many, **kwargs) for item in data]</span>
<span class="gi">+            else:</span>
<span class="gi">+                if pass_original:</span>
<span class="gi">+                    data = processor(data, original_data, many=many, **kwargs)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data = processor(data, many=many, **kwargs)</span>
<span class="gi">+        return data</span>


<span class="gd">-BaseSchema = Schema</span>
<span class="gi">+BaseSchema = Schema  # for backwards compatibility</span>
<span class="gh">diff --git a/src/marshmallow/types.py b/src/marshmallow/types.py</span>
<span class="gh">index 43103ae..ce31c05 100644</span>
<span class="gd">--- a/src/marshmallow/types.py</span>
<span class="gi">+++ b/src/marshmallow/types.py</span>
<span class="gu">@@ -4,7 +4,9 @@</span>

<span class="w"> </span>    This module is provisional. Types may be modified, added, and removed between minor releases.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>StrSequenceOrSet = typing.Union[typing.Sequence[str], typing.AbstractSet[str]]
<span class="w"> </span>Tag = typing.Union[str, typing.Tuple[str, bool]]
<span class="w"> </span>Validator = typing.Callable[[typing.Any], typing.Any]
<span class="gh">diff --git a/src/marshmallow/utils.py b/src/marshmallow/utils.py</span>
<span class="gh">index 1c71b57..a5fe726 100644</span>
<span class="gd">--- a/src/marshmallow/utils.py</span>
<span class="gi">+++ b/src/marshmallow/utils.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utility methods for marshmallow.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import datetime as dt
<span class="w"> </span>import functools
<span class="gu">@@ -11,17 +13,18 @@ import warnings</span>
<span class="w"> </span>from collections.abc import Mapping
<span class="w"> </span>from email.utils import format_datetime, parsedate_to_datetime
<span class="w"> </span>from pprint import pprint as py_pprint
<span class="gi">+</span>
<span class="w"> </span>from marshmallow.base import FieldABC
<span class="w"> </span>from marshmallow.exceptions import FieldInstanceResolutionError
<span class="w"> </span>from marshmallow.warnings import RemovedInMarshmallow4Warning
<span class="gd">-EXCLUDE = &#39;exclude&#39;</span>
<span class="gd">-INCLUDE = &#39;include&#39;</span>
<span class="gd">-RAISE = &#39;raise&#39;</span>
<span class="gi">+</span>
<span class="gi">+EXCLUDE = &quot;exclude&quot;</span>
<span class="gi">+INCLUDE = &quot;include&quot;</span>
<span class="gi">+RAISE = &quot;raise&quot;</span>
<span class="w"> </span>_UNKNOWN_VALUES = {EXCLUDE, INCLUDE, RAISE}


<span class="w"> </span>class _Missing:
<span class="gd">-</span>
<span class="w"> </span>    def __bool__(self):
<span class="w"> </span>        return False

<span class="gu">@@ -32,40 +35,46 @@ class _Missing:</span>
<span class="w"> </span>        return self

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;marshmallow.missing&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;marshmallow.missing&gt;&quot;</span>


<span class="gi">+# Singleton value that indicates that a field&#39;s value is missing from input</span>
<span class="gi">+# dict passed to :meth:`Schema.load`. If the field&#39;s value is not required,</span>
<span class="gi">+# it&#39;s ``default`` value is used.</span>
<span class="w"> </span>missing = _Missing()


<span class="gd">-def is_generator(obj) -&gt;bool:</span>
<span class="gi">+def is_generator(obj) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` is a generator&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return inspect.isgeneratorfunction(obj) or inspect.isgenerator(obj)</span>


<span class="gd">-def is_iterable_but_not_string(obj) -&gt;bool:</span>
<span class="gi">+def is_iterable_but_not_string(obj) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` is an iterable object that isn&#39;t a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (hasattr(obj, &quot;__iter__&quot;) and not hasattr(obj, &quot;strip&quot;)) or is_generator(obj)</span>


<span class="gd">-def is_collection(obj) -&gt;bool:</span>
<span class="gi">+def is_collection(obj) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` is a collection type, e.g list, tuple, queryset.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_iterable_but_not_string(obj) and not isinstance(obj, Mapping)</span>


<span class="gd">-def is_instance_or_subclass(val, class_) -&gt;bool:</span>
<span class="gi">+def is_instance_or_subclass(val, class_) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``val`` is either a subclass or instance of ``class_``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return issubclass(val, class_)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return isinstance(val, class_)</span>


<span class="gd">-def is_keyed_tuple(obj) -&gt;bool:</span>
<span class="gi">+def is_keyed_tuple(obj) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` has keyed tuple behavior, such as
<span class="w"> </span>    namedtuples or SQLAlchemy&#39;s KeyedTuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, tuple) and hasattr(obj, &quot;_fields&quot;)</span>


<span class="gd">-def pprint(obj, *args, **kwargs) -&gt;None:</span>
<span class="gi">+def pprint(obj, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pretty-printing function that can pretty-print OrderedDicts
<span class="w"> </span>    like regular dictionaries. Useful for printing the output of
<span class="w"> </span>    :meth:`marshmallow.Schema.dump`.
<span class="gu">@@ -73,38 +82,65 @@ def pprint(obj, *args, **kwargs) -&gt;None:</span>
<span class="w"> </span>    .. deprecated:: 3.7.0
<span class="w"> </span>        marshmallow.pprint will be removed in marshmallow 4.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;marshmallow&#39;s pprint function is deprecated and will be removed in marshmallow 4.&quot;,</span>
<span class="gi">+        RemovedInMarshmallow4Warning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    if isinstance(obj, collections.OrderedDict):</span>
<span class="gi">+        print(json.dumps(obj, *args, **kwargs))</span>
<span class="gi">+    else:</span>
<span class="gi">+        py_pprint(obj, *args, **kwargs)</span>
<span class="gi">+</span>

<span class="gi">+# https://stackoverflow.com/a/27596917</span>
<span class="gi">+def is_aware(datetime: dt.datetime) -&gt; bool:</span>
<span class="gi">+    return (</span>
<span class="gi">+        datetime.tzinfo is not None and datetime.tzinfo.utcoffset(datetime) is not None</span>
<span class="gi">+    )</span>

<span class="gd">-def from_rfc(datestring: str) -&gt;dt.datetime:</span>
<span class="gi">+</span>
<span class="gi">+def from_rfc(datestring: str) -&gt; dt.datetime:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a RFC822-formatted datetime string and return a datetime object.

<span class="w"> </span>    https://stackoverflow.com/questions/885015/how-to-parse-a-rfc-2822-date-time-into-a-python-datetime  # noqa: B950
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return parsedate_to_datetime(datestring)</span>


<span class="gd">-def rfcformat(datetime: dt.datetime) -&gt;str:</span>
<span class="gi">+def rfcformat(datetime: dt.datetime) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the RFC822-formatted representation of a datetime object.

<span class="w"> </span>    :param datetime datetime: The datetime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return format_datetime(datetime)</span>
<span class="gi">+</span>

<span class="gi">+# Hat tip to Django for ISO8601 deserialization functions</span>

<span class="w"> </span>_iso8601_datetime_re = re.compile(
<span class="gd">-    &#39;(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{1,2})-(?P&lt;day&gt;\\d{1,2})[T ](?P&lt;hour&gt;\\d{1,2}):(?P&lt;minute&gt;\\d{1,2})(?::(?P&lt;second&gt;\\d{1,2})(?:\\.(?P&lt;microsecond&gt;\\d{1,6})\\d{0,6})?)?(?P&lt;tzinfo&gt;Z|[+-]\\d{2}(?::?\\d{2})?)?$&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-_iso8601_date_re = re.compile(</span>
<span class="gd">-    &#39;(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{1,2})-(?P&lt;day&gt;\\d{1,2})$&#39;)</span>
<span class="gi">+    r&quot;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{1,2})-(?P&lt;day&gt;\d{1,2})&quot;</span>
<span class="gi">+    r&quot;[T ](?P&lt;hour&gt;\d{1,2}):(?P&lt;minute&gt;\d{1,2})&quot;</span>
<span class="gi">+    r&quot;(?::(?P&lt;second&gt;\d{1,2})(?:\.(?P&lt;microsecond&gt;\d{1,6})\d{0,6})?)?&quot;</span>
<span class="gi">+    r&quot;(?P&lt;tzinfo&gt;Z|[+-]\d{2}(?::?\d{2})?)?$&quot;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_iso8601_date_re = re.compile(r&quot;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{1,2})-(?P&lt;day&gt;\d{1,2})$&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>_iso8601_time_re = re.compile(
<span class="gd">-    &#39;(?P&lt;hour&gt;\\d{1,2}):(?P&lt;minute&gt;\\d{1,2})(?::(?P&lt;second&gt;\\d{1,2})(?:\\.(?P&lt;microsecond&gt;\\d{1,6})\\d{0,6})?)?&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&quot;(?P&lt;hour&gt;\d{1,2}):(?P&lt;minute&gt;\d{1,2})&quot;</span>
<span class="gi">+    r&quot;(?::(?P&lt;second&gt;\d{1,2})(?:\.(?P&lt;microsecond&gt;\d{1,6})\d{0,6})?)?&quot;</span>
<span class="gi">+)</span>


<span class="gd">-def get_fixed_timezone(offset: (int | float | dt.timedelta)) -&gt;dt.timezone:</span>
<span class="gi">+def get_fixed_timezone(offset: int | float | dt.timedelta) -&gt; dt.timezone:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a tzinfo instance with a fixed offset from UTC.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(offset, dt.timedelta):</span>
<span class="gi">+        offset = offset.total_seconds() // 60</span>
<span class="gi">+    sign = &quot;-&quot; if offset &lt; 0 else &quot;+&quot;</span>
<span class="gi">+    hhmm = &quot;%02d%02d&quot; % divmod(abs(offset), 60)</span>
<span class="gi">+    name = sign + hhmm</span>
<span class="gi">+    return dt.timezone(dt.timedelta(minutes=offset), name)</span>


<span class="w"> </span>def from_iso_datetime(value):
<span class="gu">@@ -113,7 +149,23 @@ def from_iso_datetime(value):</span>
<span class="w"> </span>    This function supports time zone offsets. When the input contains one,
<span class="w"> </span>    the output uses a timezone with a fixed offset from UTC.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _iso8601_datetime_re.match(value)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&quot;Not a valid ISO8601-formatted datetime string&quot;)</span>
<span class="gi">+    kw = match.groupdict()</span>
<span class="gi">+    kw[&quot;microsecond&quot;] = kw[&quot;microsecond&quot;] and kw[&quot;microsecond&quot;].ljust(6, &quot;0&quot;)</span>
<span class="gi">+    tzinfo = kw.pop(&quot;tzinfo&quot;)</span>
<span class="gi">+    if tzinfo == &quot;Z&quot;:</span>
<span class="gi">+        tzinfo = dt.timezone.utc</span>
<span class="gi">+    elif tzinfo is not None:</span>
<span class="gi">+        offset_mins = int(tzinfo[-2:]) if len(tzinfo) &gt; 3 else 0</span>
<span class="gi">+        offset = 60 * int(tzinfo[1:3]) + offset_mins</span>
<span class="gi">+        if tzinfo[0] == &quot;-&quot;:</span>
<span class="gi">+            offset = -offset</span>
<span class="gi">+        tzinfo = get_fixed_timezone(offset)</span>
<span class="gi">+    kw = {k: int(v) for k, v in kw.items() if v is not None}</span>
<span class="gi">+    kw[&quot;tzinfo&quot;] = tzinfo</span>
<span class="gi">+    return dt.datetime(**kw)</span>


<span class="w"> </span>def from_iso_time(value):
<span class="gu">@@ -121,20 +173,79 @@ def from_iso_time(value):</span>

<span class="w"> </span>    This function doesn&#39;t support time zone offsets.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _iso8601_time_re.match(value)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&quot;Not a valid ISO8601-formatted time string&quot;)</span>
<span class="gi">+    kw = match.groupdict()</span>
<span class="gi">+    kw[&quot;microsecond&quot;] = kw[&quot;microsecond&quot;] and kw[&quot;microsecond&quot;].ljust(6, &quot;0&quot;)</span>
<span class="gi">+    kw = {k: int(v) for k, v in kw.items() if v is not None}</span>
<span class="gi">+    return dt.time(**kw)</span>


<span class="w"> </span>def from_iso_date(value):
<span class="w"> </span>    &quot;&quot;&quot;Parse a string and return a datetime.date.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _iso8601_date_re.match(value)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&quot;Not a valid ISO8601-formatted date string&quot;)</span>
<span class="gi">+    kw = {k: int(v) for k, v in match.groupdict().items()}</span>
<span class="gi">+    return dt.date(**kw)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_timestamp(value: typing.Any) -&gt; dt.datetime:</span>
<span class="gi">+    if value is True or value is False:</span>
<span class="gi">+        raise ValueError(&quot;Not a valid POSIX timestamp&quot;)</span>
<span class="gi">+    value = float(value)</span>
<span class="gi">+    if value &lt; 0:</span>
<span class="gi">+        raise ValueError(&quot;Not a valid POSIX timestamp&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Load a timestamp with utc as timezone to prevent using system timezone.</span>
<span class="gi">+    # Then set timezone to None, to let the Field handle adding timezone info.</span>
<span class="gi">+    try:</span>
<span class="gi">+        return dt.datetime.fromtimestamp(value, tz=dt.timezone.utc).replace(tzinfo=None)</span>
<span class="gi">+    except OverflowError as exc:</span>
<span class="gi">+        raise ValueError(&quot;Timestamp is too large&quot;) from exc</span>
<span class="gi">+    except OSError as exc:</span>
<span class="gi">+        raise ValueError(&quot;Error converting value to datetime&quot;) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_timestamp_ms(value: typing.Any) -&gt; dt.datetime:</span>
<span class="gi">+    value = float(value)</span>
<span class="gi">+    return from_timestamp(value / 1000)</span>
<span class="gi">+</span>

<span class="gi">+def timestamp(</span>
<span class="gi">+    value: dt.datetime,</span>
<span class="gi">+) -&gt; float:</span>
<span class="gi">+    if not is_aware(value):</span>
<span class="gi">+        # When a date is naive, use UTC as zone info to prevent using system timezone.</span>
<span class="gi">+        value = value.replace(tzinfo=dt.timezone.utc)</span>
<span class="gi">+    return value.timestamp()</span>

<span class="gd">-def isoformat(datetime: dt.datetime) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def timestamp_ms(value: dt.datetime) -&gt; float:</span>
<span class="gi">+    return timestamp(value) * 1000</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def isoformat(datetime: dt.datetime) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the ISO8601-formatted representation of a datetime object.

<span class="w"> </span>    :param datetime datetime: The datetime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return datetime.isoformat()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_iso_time(time: dt.time) -&gt; str:</span>
<span class="gi">+    return dt.time.isoformat(time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_iso_date(date: dt.date) -&gt; str:</span>
<span class="gi">+    return dt.date.isoformat(date)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ensure_text_type(val: str | bytes) -&gt; str:</span>
<span class="gi">+    if isinstance(val, bytes):</span>
<span class="gi">+        val = val.decode(&quot;utf-8&quot;)</span>
<span class="gi">+    return str(val)</span>


<span class="w"> </span>def pluck(dictlist: list[dict[str, typing.Any]], key: str):
<span class="gu">@@ -145,10 +256,13 @@ def pluck(dictlist: list[dict[str, typing.Any]], key: str):</span>
<span class="w"> </span>        &gt;&gt;&gt; pluck(dlist, &#39;id&#39;)
<span class="w"> </span>        [1, 2]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [d[key] for d in dictlist]</span>
<span class="gi">+</span>

<span class="gi">+# Various utilities for pulling keyed values from objects</span>

<span class="gd">-def get_value(obj, key: (int | str), default=missing):</span>
<span class="gi">+</span>
<span class="gi">+def get_value(obj, key: int | str, default=missing):</span>
<span class="w"> </span>    &quot;&quot;&quot;Helper for pulling a keyed value off various types of objects. Fields use
<span class="w"> </span>    this method by default to access attributes of the source object. For object `x`
<span class="w"> </span>    and attribute `i`, this method first tries to access `x[i]`, and then falls back to
<span class="gu">@@ -159,7 +273,29 @@ def get_value(obj, key: (int | str), default=missing):</span>
<span class="w"> </span>        `get_value` will never check the value `x.i`. Consider overriding
<span class="w"> </span>        `marshmallow.fields.Field.get_value` in this case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(key, int) and &quot;.&quot; in key:</span>
<span class="gi">+        return _get_value_for_keys(obj, key.split(&quot;.&quot;), default)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _get_value_for_key(obj, key, default)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_value_for_keys(obj, keys, default):</span>
<span class="gi">+    if len(keys) == 1:</span>
<span class="gi">+        return _get_value_for_key(obj, keys[0], default)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _get_value_for_keys(</span>
<span class="gi">+            _get_value_for_key(obj, keys[0], default), keys[1:], default</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_value_for_key(obj, key, default):</span>
<span class="gi">+    if not hasattr(obj, &quot;__getitem__&quot;):</span>
<span class="gi">+        return getattr(obj, key, default)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return obj[key]</span>
<span class="gi">+    except (KeyError, IndexError, TypeError, AttributeError):</span>
<span class="gi">+        return getattr(obj, key, default)</span>


<span class="w"> </span>def set_value(dct: dict[str, typing.Any], key: str, value: typing.Any):
<span class="gu">@@ -173,22 +309,42 @@ def set_value(dct: dict[str, typing.Any], key: str, value: typing.Any):</span>
<span class="w"> </span>        &gt;&gt;&gt; d
<span class="w"> </span>        {&#39;foo&#39;: {&#39;bar&#39;: 42}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;.&quot; in key:</span>
<span class="gi">+        head, rest = key.split(&quot;.&quot;, 1)</span>
<span class="gi">+        target = dct.setdefault(head, {})</span>
<span class="gi">+        if not isinstance(target, dict):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;Cannot set {key} in {head} &quot; f&quot;due to existing value: {target}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        set_value(target, rest, value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        dct[key] = value</span>


<span class="w"> </span>def callable_or_raise(obj):
<span class="w"> </span>    &quot;&quot;&quot;Check that an object is callable, else raise a :exc:`TypeError`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not callable(obj):</span>
<span class="gi">+        raise TypeError(f&quot;Object {obj!r} is not callable.&quot;)</span>
<span class="gi">+    return obj</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _signature(func: typing.Callable) -&gt; list[str]:</span>
<span class="gi">+    return list(inspect.signature(func).parameters.keys())</span>


<span class="gd">-def get_func_args(func: typing.Callable) -&gt;list[str]:</span>
<span class="gi">+def get_func_args(func: typing.Callable) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a callable, return a list of argument names. Handles
<span class="w"> </span>    `functools.partial` objects and class-based callables.

<span class="w"> </span>    .. versionchanged:: 3.0.0a1
<span class="w"> </span>        Do not return bound arguments, eg. ``self``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if inspect.isfunction(func) or inspect.ismethod(func):</span>
<span class="gi">+        return _signature(func)</span>
<span class="gi">+    if isinstance(func, functools.partial):</span>
<span class="gi">+        return _signature(func.func)</span>
<span class="gi">+    # Callable class</span>
<span class="gi">+    return _signature(func)</span>


<span class="w"> </span>def resolve_field_instance(cls_or_instance):
<span class="gu">@@ -196,12 +352,27 @@ def resolve_field_instance(cls_or_instance):</span>

<span class="w"> </span>    :param type|Schema cls_or_instance: Marshmallow Schema class or instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(cls_or_instance, type):</span>
<span class="gi">+        if not issubclass(cls_or_instance, FieldABC):</span>
<span class="gi">+            raise FieldInstanceResolutionError</span>
<span class="gi">+        return cls_or_instance()</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not isinstance(cls_or_instance, FieldABC):</span>
<span class="gi">+            raise FieldInstanceResolutionError</span>
<span class="gi">+        return cls_or_instance</span>


<span class="gd">-def timedelta_to_microseconds(value: dt.timedelta) -&gt;int:</span>
<span class="gi">+def timedelta_to_microseconds(value: dt.timedelta) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the total microseconds of a timedelta

<span class="w"> </span>    https://github.com/python/cpython/blob/bb3e0c240bc60fe08d332ff5955d54197f79751c/Lib/datetime.py#L665-L667  # noqa: B950
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (value.days * (24 * 3600) + value.seconds) * 1000000 + value.microseconds</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_unknown_parameter_value(obj: typing.Any) -&gt; str:</span>
<span class="gi">+    if obj not in _UNKNOWN_VALUES:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            f&quot;Object {obj!r} is not a valid value for the &#39;unknown&#39; parameter&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    return obj</span>
<span class="gh">diff --git a/src/marshmallow/validate.py b/src/marshmallow/validate.py</span>
<span class="gh">index 3cc3b97..e4536d8 100644</span>
<span class="gd">--- a/src/marshmallow/validate.py</span>
<span class="gi">+++ b/src/marshmallow/validate.py</span>
<span class="gu">@@ -1,13 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Validation classes for various types of data.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import typing
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from itertools import zip_longest
<span class="w"> </span>from operator import attrgetter
<span class="gi">+</span>
<span class="w"> </span>from marshmallow import types
<span class="w"> </span>from marshmallow.exceptions import ValidationError
<span class="gd">-_T = typing.TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = typing.TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class Validator(ABC):
<span class="gu">@@ -17,22 +21,23 @@ class Validator(ABC):</span>
<span class="w"> </span>        This class does not provide any validation behavior. It is only used to
<span class="w"> </span>        add a useful `__repr__` implementation for validators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    error = None</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    error = None  # type: str | None</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        args = self._repr_args()
<span class="gd">-        args = f&#39;{args}, &#39; if args else &#39;&#39;</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__}({args}error={self.error!r})&gt;&#39;</span>
<span class="gi">+        args = f&quot;{args}, &quot; if args else &quot;&quot;</span>

<span class="gd">-    def _repr_args(self) -&gt;str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__}({args}error={self.error!r})&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;A string representation of the args passed to this validator. Used by
<span class="w"> </span>        `__repr__`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def __call__(self, value: typing.Any) -&gt;typing.Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, value: typing.Any) -&gt; typing.Any: ...</span>


<span class="w"> </span>class And(Validator):
<span class="gu">@@ -55,13 +60,17 @@ class And(Validator):</span>
<span class="w"> </span>    :param validators: Validators to combine.
<span class="w"> </span>    :param error: Error message to use when a validator returns ``False``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_error_message = &#39;Invalid value.&#39;</span>

<span class="gd">-    def __init__(self, *validators: types.Validator, error: (str | None)=None):</span>
<span class="gi">+    default_error_message = &quot;Invalid value.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *validators: types.Validator, error: str | None = None):</span>
<span class="w"> </span>        self.validators = tuple(validators)
<span class="gd">-        self.error = error or self.default_error_message</span>
<span class="gi">+        self.error = error or self.default_error_message  # type: str</span>

<span class="gd">-    def __call__(self, value: typing.Any) -&gt;typing.Any:</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;validators={self.validators!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Any) -&gt; typing.Any:</span>
<span class="w"> </span>        errors = []
<span class="w"> </span>        kwargs = {}
<span class="w"> </span>        for validator in self.validators:
<span class="gu">@@ -74,6 +83,7 @@ class And(Validator):</span>
<span class="w"> </span>                if isinstance(err.messages, dict):
<span class="w"> </span>                    errors.append(err.messages)
<span class="w"> </span>                else:
<span class="gi">+                    # FIXME : Get rid of cast</span>
<span class="w"> </span>                    errors.extend(typing.cast(list, err.messages))
<span class="w"> </span>        if errors:
<span class="w"> </span>            raise ValidationError(errors, **kwargs)
<span class="gu">@@ -92,47 +102,121 @@ class URL(Validator):</span>
<span class="w"> </span>    :param require_tld: Whether to reject non-FQDN hostnames.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    class RegexMemoizer:
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self):
<span class="w"> </span>            self._memoized = {}

<span class="gd">-        def __call__(self, relative: bool, absolute: bool, require_tld: bool</span>
<span class="gd">-            ) -&gt;typing.Pattern:</span>
<span class="gd">-            key = relative, absolute, require_tld</span>
<span class="gi">+        def _regex_generator(</span>
<span class="gi">+            self, relative: bool, absolute: bool, require_tld: bool</span>
<span class="gi">+        ) -&gt; typing.Pattern:</span>
<span class="gi">+            hostname_variants = [</span>
<span class="gi">+                # a normal domain name, expressed in [A-Z0-9] chars with hyphens allowed only in the middle</span>
<span class="gi">+                # note that the regex will be compiled with IGNORECASE, so these are upper and lowercase chars</span>
<span class="gi">+                (</span>
<span class="gi">+                    r&quot;(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+&quot;</span>
<span class="gi">+                    r&quot;(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+                # or the special string &#39;localhost&#39;</span>
<span class="gi">+                r&quot;localhost&quot;,</span>
<span class="gi">+                # or IPv4</span>
<span class="gi">+                r&quot;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&quot;,</span>
<span class="gi">+                # or IPv6</span>
<span class="gi">+                r&quot;\[[A-F0-9]*:[A-F0-9:]+\]&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+            if not require_tld:</span>
<span class="gi">+                # allow dotless hostnames</span>
<span class="gi">+                hostname_variants.append(r&quot;(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.?)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            absolute_part = &quot;&quot;.join(</span>
<span class="gi">+                (</span>
<span class="gi">+                    # scheme (e.g. &#39;https://&#39;, &#39;ftp://&#39;, etc)</span>
<span class="gi">+                    # this is validated separately against allowed schemes, so in the regex</span>
<span class="gi">+                    # we simply want to capture its existence</span>
<span class="gi">+                    r&quot;(?:[a-z0-9\.\-\+]*)://&quot;,</span>
<span class="gi">+                    # userinfo, for URLs encoding authentication</span>
<span class="gi">+                    # e.g. &#39;ftp://foo:bar@ftp.example.org/&#39;</span>
<span class="gi">+                    r&quot;(?:(?:[a-z0-9\-._~!$&amp;&#39;()*+,;=:]|%[0-9a-f]{2})*@)?&quot;,</span>
<span class="gi">+                    # netloc, the hostname/domain part of the URL plus the optional port</span>
<span class="gi">+                    r&quot;(?:&quot;,</span>
<span class="gi">+                    &quot;|&quot;.join(hostname_variants),</span>
<span class="gi">+                    r&quot;)&quot;,</span>
<span class="gi">+                    r&quot;(?::\d+)?&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            relative_part = r&quot;(?:/?|[/?]\S+)\Z&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if relative:</span>
<span class="gi">+                if absolute:</span>
<span class="gi">+                    parts: tuple[str, ...] = (</span>
<span class="gi">+                        r&quot;^(&quot;,</span>
<span class="gi">+                        absolute_part,</span>
<span class="gi">+                        r&quot;)?&quot;,</span>
<span class="gi">+                        relative_part,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    parts = (r&quot;^&quot;, relative_part)</span>
<span class="gi">+            else:</span>
<span class="gi">+                parts = (r&quot;^&quot;, absolute_part, relative_part)</span>
<span class="gi">+</span>
<span class="gi">+            return re.compile(&quot;&quot;.join(parts), re.IGNORECASE)</span>
<span class="gi">+</span>
<span class="gi">+        def __call__(</span>
<span class="gi">+            self, relative: bool, absolute: bool, require_tld: bool</span>
<span class="gi">+        ) -&gt; typing.Pattern:</span>
<span class="gi">+            key = (relative, absolute, require_tld)</span>
<span class="w"> </span>            if key not in self._memoized:
<span class="gd">-                self._memoized[key] = self._regex_generator(relative,</span>
<span class="gd">-                    absolute, require_tld)</span>
<span class="gi">+                self._memoized[key] = self._regex_generator(</span>
<span class="gi">+                    relative, absolute, require_tld</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>            return self._memoized[key]
<span class="gi">+</span>
<span class="w"> </span>    _regex = RegexMemoizer()
<span class="gd">-    default_message = &#39;Not a valid URL.&#39;</span>
<span class="gd">-    default_schemes = {&#39;http&#39;, &#39;https&#39;, &#39;ftp&#39;, &#39;ftps&#39;}</span>

<span class="gd">-    def __init__(self, *, relative: bool=False, absolute: bool=True,</span>
<span class="gd">-        schemes: (types.StrSequenceOrSet | None)=None, require_tld: bool=</span>
<span class="gd">-        True, error: (str | None)=None):</span>
<span class="gi">+    default_message = &quot;Not a valid URL.&quot;</span>
<span class="gi">+    default_schemes = {&quot;http&quot;, &quot;https&quot;, &quot;ftp&quot;, &quot;ftps&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        relative: bool = False,</span>
<span class="gi">+        absolute: bool = True,</span>
<span class="gi">+        schemes: types.StrSequenceOrSet | None = None,</span>
<span class="gi">+        require_tld: bool = True,</span>
<span class="gi">+        error: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if not relative and not absolute:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;URL validation cannot set both relative and absolute to False.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;URL validation cannot set both relative and absolute to False.&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self.relative = relative
<span class="w"> </span>        self.absolute = absolute
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>
<span class="w"> </span>        self.schemes = schemes or self.default_schemes
<span class="w"> </span>        self.require_tld = require_tld

<span class="gd">-    def __call__(self, value: str) -&gt;str:</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;relative={self.relative!r}, absolute={self.absolute!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value) -&gt; str:</span>
<span class="gi">+        return self.error.format(input=value)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: str) -&gt; str:</span>
<span class="w"> </span>        message = self._format_error(value)
<span class="w"> </span>        if not value:
<span class="w"> </span>            raise ValidationError(message)
<span class="gd">-        if &#39;://&#39; in value:</span>
<span class="gd">-            scheme = value.split(&#39;://&#39;)[0].lower()</span>
<span class="gi">+</span>
<span class="gi">+        # Check first if the scheme is valid</span>
<span class="gi">+        if &quot;://&quot; in value:</span>
<span class="gi">+            scheme = value.split(&quot;://&quot;)[0].lower()</span>
<span class="w"> </span>            if scheme not in self.schemes:
<span class="w"> </span>                raise ValidationError(message)
<span class="gi">+</span>
<span class="w"> </span>        regex = self._regex(self.relative, self.absolute, self.require_tld)
<span class="gi">+</span>
<span class="w"> </span>        if not regex.search(value):
<span class="w"> </span>            raise ValidationError(message)
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -142,35 +226,57 @@ class Email(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error. Can be
<span class="w"> </span>        interpolated with `{input}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    USER_REGEX = re.compile(
<span class="gd">-        &#39;(^[-!#$%&amp;\&#39;*+/=?^`{}|~\\w]+(\\.[-!#$%&amp;\&#39;*+/=?^`{}|~\\w]+)*\\Z|^&quot;([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*&quot;\\Z)&#39;</span>
<span class="gd">-        , re.IGNORECASE | re.UNICODE)</span>
<span class="gi">+        r&quot;(^[-!#$%&amp;&#39;*+/=?^`{}|~\w]+(\.[-!#$%&amp;&#39;*+/=?^`{}|~\w]+)*\Z&quot;  # dot-atom</span>
<span class="gi">+        # quoted-string</span>
<span class="gi">+        r&#39;|^&quot;([\001-\010\013\014\016-\037!#-\[\]-\177]&#39;</span>
<span class="gi">+        r&#39;|\\[\001-\011\013\014\016-\177])*&quot;\Z)&#39;,</span>
<span class="gi">+        re.IGNORECASE | re.UNICODE,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    DOMAIN_REGEX = re.compile(
<span class="gd">-        &#39;(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,})\\Z|^\\[(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\]\\Z&#39;</span>
<span class="gd">-        , re.IGNORECASE | re.UNICODE)</span>
<span class="gd">-    DOMAIN_WHITELIST = &#39;localhost&#39;,</span>
<span class="gd">-    default_message = &#39;Not a valid email address.&#39;</span>
<span class="gi">+        # domain</span>
<span class="gi">+        r&quot;(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+&quot;</span>
<span class="gi">+        r&quot;(?:[A-Z]{2,6}|[A-Z0-9-]{2,})\Z&quot;</span>
<span class="gi">+        # literal form, ipv4 address (SMTP 4.1.3)</span>
<span class="gi">+        r&quot;|^\[(25[0-5]|2[0-4]\d|[0-1]?\d?\d)&quot;</span>
<span class="gi">+        r&quot;(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\]\Z&quot;,</span>
<span class="gi">+        re.IGNORECASE | re.UNICODE,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    DOMAIN_WHITELIST = (&quot;localhost&quot;,)</span>

<span class="gd">-    def __init__(self, *, error: (str | None)=None):</span>
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+    default_message = &quot;Not a valid email address.&quot;</span>

<span class="gd">-    def __call__(self, value: str) -&gt;str:</span>
<span class="gi">+    def __init__(self, *, error: str | None = None):</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value: str) -&gt; str:</span>
<span class="gi">+        return self.error.format(input=value)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: str) -&gt; str:</span>
<span class="w"> </span>        message = self._format_error(value)
<span class="gd">-        if not value or &#39;@&#39; not in value:</span>
<span class="gi">+</span>
<span class="gi">+        if not value or &quot;@&quot; not in value:</span>
<span class="w"> </span>            raise ValidationError(message)
<span class="gd">-        user_part, domain_part = value.rsplit(&#39;@&#39;, 1)</span>
<span class="gi">+</span>
<span class="gi">+        user_part, domain_part = value.rsplit(&quot;@&quot;, 1)</span>
<span class="gi">+</span>
<span class="w"> </span>        if not self.USER_REGEX.match(user_part):
<span class="w"> </span>            raise ValidationError(message)
<span class="gi">+</span>
<span class="w"> </span>        if domain_part not in self.DOMAIN_WHITELIST:
<span class="w"> </span>            if not self.DOMAIN_REGEX.match(domain_part):
<span class="w"> </span>                try:
<span class="gd">-                    domain_part = domain_part.encode(&#39;idna&#39;).decode(&#39;ascii&#39;)</span>
<span class="gi">+                    domain_part = domain_part.encode(&quot;idna&quot;).decode(&quot;ascii&quot;)</span>
<span class="w"> </span>                except UnicodeError:
<span class="w"> </span>                    pass
<span class="w"> </span>                else:
<span class="w"> </span>                    if self.DOMAIN_REGEX.match(domain_part):
<span class="w"> </span>                        return value
<span class="w"> </span>                raise ValidationError(message)
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -192,40 +298,62 @@ class Range(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error.
<span class="w"> </span>        Can be interpolated with `{input}`, `{min}` and `{max}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    message_min = &#39;Must be {min_op} {{min}}.&#39;</span>
<span class="gd">-    message_max = &#39;Must be {max_op} {{max}}.&#39;</span>
<span class="gd">-    message_all = &#39;Must be {min_op} {{min}} and {max_op} {{max}}.&#39;</span>
<span class="gd">-    message_gte = &#39;greater than or equal to&#39;</span>
<span class="gd">-    message_gt = &#39;greater than&#39;</span>
<span class="gd">-    message_lte = &#39;less than or equal to&#39;</span>
<span class="gd">-    message_lt = &#39;less than&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, min=None, max=None, *, min_inclusive: bool=True,</span>
<span class="gd">-        max_inclusive: bool=True, error: (str | None)=None):</span>
<span class="gi">+</span>
<span class="gi">+    message_min = &quot;Must be {min_op} {{min}}.&quot;</span>
<span class="gi">+    message_max = &quot;Must be {max_op} {{max}}.&quot;</span>
<span class="gi">+    message_all = &quot;Must be {min_op} {{min}} and {max_op} {{max}}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    message_gte = &quot;greater than or equal to&quot;</span>
<span class="gi">+    message_gt = &quot;greater than&quot;</span>
<span class="gi">+    message_lte = &quot;less than or equal to&quot;</span>
<span class="gi">+    message_lt = &quot;less than&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min=None,</span>
<span class="gi">+        max=None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        min_inclusive: bool = True,</span>
<span class="gi">+        max_inclusive: bool = True,</span>
<span class="gi">+        error: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.min = min
<span class="w"> </span>        self.max = max
<span class="w"> </span>        self.error = error
<span class="w"> </span>        self.min_inclusive = min_inclusive
<span class="w"> </span>        self.max_inclusive = max_inclusive
<span class="gd">-        self.message_min = self.message_min.format(min_op=self.message_gte if</span>
<span class="gd">-            self.min_inclusive else self.message_gt)</span>
<span class="gd">-        self.message_max = self.message_max.format(max_op=self.message_lte if</span>
<span class="gd">-            self.max_inclusive else self.message_lt)</span>
<span class="gd">-        self.message_all = self.message_all.format(min_op=self.message_gte if</span>
<span class="gd">-            self.min_inclusive else self.message_gt, max_op=self.</span>
<span class="gd">-            message_lte if self.max_inclusive else self.message_lt)</span>
<span class="gd">-</span>
<span class="gd">-    def __call__(self, value: _T) -&gt;_T:</span>
<span class="gd">-        if self.min is not None and (value &lt; self.min if self.min_inclusive</span>
<span class="gd">-             else value &lt;= self.min):</span>
<span class="gd">-            message = (self.message_min if self.max is None else self.</span>
<span class="gd">-                message_all)</span>
<span class="gi">+</span>
<span class="gi">+        # interpolate messages based on bound inclusivity</span>
<span class="gi">+        self.message_min = self.message_min.format(</span>
<span class="gi">+            min_op=self.message_gte if self.min_inclusive else self.message_gt</span>
<span class="gi">+        )</span>
<span class="gi">+        self.message_max = self.message_max.format(</span>
<span class="gi">+            max_op=self.message_lte if self.max_inclusive else self.message_lt</span>
<span class="gi">+        )</span>
<span class="gi">+        self.message_all = self.message_all.format(</span>
<span class="gi">+            min_op=self.message_gte if self.min_inclusive else self.message_gt,</span>
<span class="gi">+            max_op=self.message_lte if self.max_inclusive else self.message_lt,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;min={self.min!r}, max={self.max!r}, min_inclusive={self.min_inclusive!r}, max_inclusive={self.max_inclusive!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value: _T, message: str) -&gt; str:</span>
<span class="gi">+        return (self.error or message).format(input=value, min=self.min, max=self.max)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: _T) -&gt; _T:</span>
<span class="gi">+        if self.min is not None and (</span>
<span class="gi">+            value &lt; self.min if self.min_inclusive else value &lt;= self.min</span>
<span class="gi">+        ):</span>
<span class="gi">+            message = self.message_min if self.max is None else self.message_all</span>
<span class="w"> </span>            raise ValidationError(self._format_error(value, message))
<span class="gd">-        if self.max is not None and (value &gt; self.max if self.max_inclusive</span>
<span class="gd">-             else value &gt;= self.max):</span>
<span class="gd">-            message = (self.message_max if self.min is None else self.</span>
<span class="gd">-                message_all)</span>
<span class="gi">+</span>
<span class="gi">+        if self.max is not None and (</span>
<span class="gi">+            value &gt; self.max if self.max_inclusive else value &gt;= self.max</span>
<span class="gi">+        ):</span>
<span class="gi">+            message = self.message_max if self.min is None else self.message_all</span>
<span class="w"> </span>            raise ValidationError(self._format_error(value, message))
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -243,37 +371,55 @@ class Length(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error.
<span class="w"> </span>        Can be interpolated with `{input}`, `{min}` and `{max}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    message_min = &#39;Shorter than minimum length {min}.&#39;</span>
<span class="gd">-    message_max = &#39;Longer than maximum length {max}.&#39;</span>
<span class="gd">-    message_all = &#39;Length must be between {min} and {max}.&#39;</span>
<span class="gd">-    message_equal = &#39;Length must be {equal}.&#39;</span>

<span class="gd">-    def __init__(self, min: (int | None)=None, max: (int | None)=None, *,</span>
<span class="gd">-        equal: (int | None)=None, error: (str | None)=None):</span>
<span class="gi">+    message_min = &quot;Shorter than minimum length {min}.&quot;</span>
<span class="gi">+    message_max = &quot;Longer than maximum length {max}.&quot;</span>
<span class="gi">+    message_all = &quot;Length must be between {min} and {max}.&quot;</span>
<span class="gi">+    message_equal = &quot;Length must be {equal}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min: int | None = None,</span>
<span class="gi">+        max: int | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        equal: int | None = None,</span>
<span class="gi">+        error: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if equal is not None and any([min, max]):
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;The `equal` parameter was provided, maximum or minimum parameter must not be provided.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;The `equal` parameter was provided, maximum or &quot;</span>
<span class="gi">+                &quot;minimum parameter must not be provided.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.min = min
<span class="w"> </span>        self.max = max
<span class="w"> </span>        self.error = error
<span class="w"> </span>        self.equal = equal

<span class="gd">-    def __call__(self, value: typing.Sized) -&gt;typing.Sized:</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;min={self.min!r}, max={self.max!r}, equal={self.equal!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value: typing.Sized, message: str) -&gt; str:</span>
<span class="gi">+        return (self.error or message).format(</span>
<span class="gi">+            input=value, min=self.min, max=self.max, equal=self.equal</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Sized) -&gt; typing.Sized:</span>
<span class="w"> </span>        length = len(value)
<span class="gi">+</span>
<span class="w"> </span>        if self.equal is not None:
<span class="w"> </span>            if length != self.equal:
<span class="gd">-                raise ValidationError(self._format_error(value, self.</span>
<span class="gd">-                    message_equal))</span>
<span class="gi">+                raise ValidationError(self._format_error(value, self.message_equal))</span>
<span class="w"> </span>            return value
<span class="gi">+</span>
<span class="w"> </span>        if self.min is not None and length &lt; self.min:
<span class="gd">-            message = (self.message_min if self.max is None else self.</span>
<span class="gd">-                message_all)</span>
<span class="gi">+            message = self.message_min if self.max is None else self.message_all</span>
<span class="w"> </span>            raise ValidationError(self._format_error(value, message))
<span class="gi">+</span>
<span class="w"> </span>        if self.max is not None and length &gt; self.max:
<span class="gd">-            message = (self.message_max if self.min is None else self.</span>
<span class="gd">-                message_all)</span>
<span class="gi">+            message = self.message_max if self.min is None else self.message_all</span>
<span class="w"> </span>            raise ValidationError(self._format_error(value, message))
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -285,13 +431,20 @@ class Equal(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error.
<span class="w"> </span>        Can be interpolated with `{input}` and `{other}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = &#39;Must be equal to {other}.&#39;</span>

<span class="gd">-    def __init__(self, comparable, *, error: (str | None)=None):</span>
<span class="gi">+    default_message = &quot;Must be equal to {other}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, comparable, *, error: str | None = None):</span>
<span class="w"> </span>        self.comparable = comparable
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;comparable={self.comparable!r}&quot;</span>

<span class="gd">-    def __call__(self, value: _T) -&gt;_T:</span>
<span class="gi">+    def _format_error(self, value: _T) -&gt; str:</span>
<span class="gi">+        return self.error.format(input=value, other=self.comparable)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: _T) -&gt; _T:</span>
<span class="w"> </span>        if value != self.comparable:
<span class="w"> </span>            raise ValidationError(self._format_error(value))
<span class="w"> </span>        return value
<span class="gu">@@ -311,25 +464,37 @@ class Regexp(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error.
<span class="w"> </span>        Can be interpolated with `{input}` and `{regex}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = &#39;String does not match expected pattern.&#39;</span>

<span class="gd">-    def __init__(self, regex: (str | bytes | typing.Pattern), flags: int=0,</span>
<span class="gd">-        *, error: (str | None)=None):</span>
<span class="gd">-        self.regex = re.compile(regex, flags) if isinstance(regex, (str, bytes)</span>
<span class="gd">-            ) else regex</span>
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+    default_message = &quot;String does not match expected pattern.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        regex: str | bytes | typing.Pattern,</span>
<span class="gi">+        flags: int = 0,</span>
<span class="gi">+        *,</span>
<span class="gi">+        error: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        self.regex = (</span>
<span class="gi">+            re.compile(regex, flags) if isinstance(regex, (str, bytes)) else regex</span>
<span class="gi">+        )</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;regex={self.regex!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value: str | bytes) -&gt; str:</span>
<span class="gi">+        return self.error.format(input=value, regex=self.regex.pattern)</span>

<span class="w"> </span>    @typing.overload
<span class="gd">-    def __call__(self, value: str) -&gt;str:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, value: str) -&gt; str: ...</span>

<span class="w"> </span>    @typing.overload
<span class="gd">-    def __call__(self, value: bytes) -&gt;bytes:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, value: bytes) -&gt; bytes: ...</span>

<span class="w"> </span>    def __call__(self, value):
<span class="w"> </span>        if self.regex.match(value) is None:
<span class="w"> </span>            raise ValidationError(self._format_error(value))
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -344,17 +509,26 @@ class Predicate(Validator):</span>
<span class="w"> </span>        Can be interpolated with `{input}` and `{method}`.
<span class="w"> </span>    :param kwargs: Additional keyword arguments to pass to the method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = &#39;Invalid input.&#39;</span>

<span class="gd">-    def __init__(self, method: str, *, error: (str | None)=None, **kwargs):</span>
<span class="gi">+    default_message = &quot;Invalid input.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, method: str, *, error: str | None = None, **kwargs):</span>
<span class="w"> </span>        self.method = method
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>
<span class="w"> </span>        self.kwargs = kwargs

<span class="gd">-    def __call__(self, value: typing.Any) -&gt;typing.Any:</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;method={self.method!r}, kwargs={self.kwargs!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value: typing.Any) -&gt; str:</span>
<span class="gi">+        return self.error.format(input=value, method=self.method)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Any) -&gt; typing.Any:</span>
<span class="w"> </span>        method = getattr(value, self.method)
<span class="gi">+</span>
<span class="w"> </span>        if not method(**self.kwargs):
<span class="w"> </span>            raise ValidationError(self._format_error(value))
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -365,19 +539,27 @@ class NoneOf(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error. Can be
<span class="w"> </span>        interpolated using `{input}` and `{values}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = &#39;Invalid input.&#39;</span>

<span class="gd">-    def __init__(self, iterable: typing.Iterable, *, error: (str | None)=None):</span>
<span class="gi">+    default_message = &quot;Invalid input.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, iterable: typing.Iterable, *, error: str | None = None):</span>
<span class="w"> </span>        self.iterable = iterable
<span class="gd">-        self.values_text = &#39;, &#39;.join(str(each) for each in self.iterable)</span>
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+        self.values_text = &quot;, &quot;.join(str(each) for each in self.iterable)</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>

<span class="gd">-    def __call__(self, value: typing.Any) -&gt;typing.Any:</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;iterable={self.iterable!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value) -&gt; str:</span>
<span class="gi">+        return self.error.format(input=value, values=self.values_text)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Any) -&gt; typing.Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            if value in self.iterable:
<span class="w"> </span>                raise ValidationError(self._format_error(value))
<span class="w"> </span>        except TypeError:
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="w"> </span>        return value


<span class="gu">@@ -389,26 +571,43 @@ class OneOf(Validator):</span>
<span class="w"> </span>    :param error: Error message to raise in case of a validation error. Can be
<span class="w"> </span>        interpolated with `{input}`, `{choices}` and `{labels}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = &#39;Must be one of: {choices}.&#39;</span>

<span class="gd">-    def __init__(self, choices: typing.Iterable, labels: (typing.Iterable[</span>
<span class="gd">-        str] | None)=None, *, error: (str | None)=None):</span>
<span class="gi">+    default_message = &quot;Must be one of: {choices}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        choices: typing.Iterable,</span>
<span class="gi">+        labels: typing.Iterable[str] | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        error: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.choices = choices
<span class="gd">-        self.choices_text = &#39;, &#39;.join(str(choice) for choice in self.choices)</span>
<span class="gi">+        self.choices_text = &quot;, &quot;.join(str(choice) for choice in self.choices)</span>
<span class="w"> </span>        self.labels = labels if labels is not None else []
<span class="gd">-        self.labels_text = &#39;, &#39;.join(str(label) for label in self.labels)</span>
<span class="gd">-        self.error = error or self.default_message</span>
<span class="gi">+        self.labels_text = &quot;, &quot;.join(str(label) for label in self.labels)</span>
<span class="gi">+        self.error = error or self.default_message  # type: str</span>

<span class="gd">-    def __call__(self, value: typing.Any) -&gt;typing.Any:</span>
<span class="gi">+    def _repr_args(self) -&gt; str:</span>
<span class="gi">+        return f&quot;choices={self.choices!r}, labels={self.labels!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value) -&gt; str:</span>
<span class="gi">+        return self.error.format(</span>
<span class="gi">+            input=value, choices=self.choices_text, labels=self.labels_text</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Any) -&gt; typing.Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            if value not in self.choices:
<span class="w"> </span>                raise ValidationError(self._format_error(value))
<span class="w"> </span>        except TypeError as error:
<span class="w"> </span>            raise ValidationError(self._format_error(value)) from error
<span class="gi">+</span>
<span class="w"> </span>        return value

<span class="gd">-    def options(self, valuegetter: (str | typing.Callable[[typing.Any],</span>
<span class="gd">-        typing.Any])=str) -&gt;typing.Iterable[tuple[typing.Any, str]]:</span>
<span class="gi">+    def options(</span>
<span class="gi">+        self,</span>
<span class="gi">+        valuegetter: str | typing.Callable[[typing.Any], typing.Any] = str,</span>
<span class="gi">+    ) -&gt; typing.Iterable[tuple[typing.Any, str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a generator over the (value, label) pairs, where value
<span class="w"> </span>        is a string associated with each choice. This convenience method
<span class="w"> </span>        is useful to populate, for instance, a form select field.
<span class="gu">@@ -419,7 +618,10 @@ class OneOf(Validator):</span>
<span class="w"> </span>            of an attribute of the choice objects. Defaults to `str()`
<span class="w"> </span>            or `str()`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        valuegetter = valuegetter if callable(valuegetter) else attrgetter(valuegetter)</span>
<span class="gi">+        pairs = zip_longest(self.choices, self.labels, fillvalue=&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return ((valuegetter(choice), label) for choice, label in pairs)</span>


<span class="w"> </span>class ContainsOnly(OneOf):
<span class="gu">@@ -437,10 +639,15 @@ class ContainsOnly(OneOf):</span>
<span class="w"> </span>        Empty input is considered valid. Use `validate.Length(min=1) &lt;marshmallow.validate.Length&gt;`
<span class="w"> </span>        to validate against empty inputs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = (</span>
<span class="gd">-        &#39;One or more of the choices you made was not in: {choices}.&#39;)</span>

<span class="gd">-    def __call__(self, value: typing.Sequence[_T]) -&gt;typing.Sequence[_T]:</span>
<span class="gi">+    default_message = &quot;One or more of the choices you made was not in: {choices}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value) -&gt; str:</span>
<span class="gi">+        value_text = &quot;, &quot;.join(str(val) for val in value)</span>
<span class="gi">+        return super()._format_error(value_text)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Sequence[_T]) -&gt; typing.Sequence[_T]:</span>
<span class="gi">+        # We can&#39;t use set.issubset because does not handle unhashable types</span>
<span class="w"> </span>        for val in value:
<span class="w"> </span>            if val not in self.choices:
<span class="w"> </span>                raise ValidationError(self._format_error(value))
<span class="gu">@@ -457,9 +664,14 @@ class ContainsNoneOf(NoneOf):</span>

<span class="w"> </span>    .. versionadded:: 3.6.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_message = &#39;One or more of the choices you made was in: {values}.&#39;</span>

<span class="gd">-    def __call__(self, value: typing.Sequence[_T]) -&gt;typing.Sequence[_T]:</span>
<span class="gi">+    default_message = &quot;One or more of the choices you made was in: {values}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _format_error(self, value) -&gt; str:</span>
<span class="gi">+        value_text = &quot;, &quot;.join(str(val) for val in value)</span>
<span class="gi">+        return super()._format_error(value_text)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, value: typing.Sequence[_T]) -&gt; typing.Sequence[_T]:</span>
<span class="w"> </span>        for val in value:
<span class="w"> </span>            if val in self.iterable:
<span class="w"> </span>                raise ValidationError(self._format_error(value))
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
    
  </body>
</html>