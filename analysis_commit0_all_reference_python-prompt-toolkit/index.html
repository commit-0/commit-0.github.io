
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference python prompt toolkit - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-python-prompt-toolkit" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference python prompt toolkit
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_memory_leakspytest_prompt_session_memory_leak" class="md-nav__link">
    <span class="md-ellipsis">
      test_memory_leaks.py::test_prompt_session_memory_leak
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-python-prompt-toolkit"><strong>Reference (Gold)</strong>: python-prompt-toolkit</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">xpassed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">151</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">151</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_memory_leakspytest_prompt_session_memory_leak">test_memory_leaks.py::test_prompt_session_memory_leak</h3>
<details><summary> <pre>test_memory_leaks.py::test_prompt_session_memory_leak</pre></summary><pre>

</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/prompt_toolkit/application/application.py b/src/prompt_toolkit/application/application.py</span>
<span class="gh">index a630e551..d4637811 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/application.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/application.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import contextvars
<span class="w"> </span>import os
<span class="gu">@@ -7,27 +8,62 @@ import signal</span>
<span class="w"> </span>import sys
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="gd">-from asyncio import AbstractEventLoop, Future, Task, ensure_future, get_running_loop, sleep</span>
<span class="gi">+from asyncio import (</span>
<span class="gi">+    AbstractEventLoop,</span>
<span class="gi">+    Future,</span>
<span class="gi">+    Task,</span>
<span class="gi">+    ensure_future,</span>
<span class="gi">+    get_running_loop,</span>
<span class="gi">+    sleep,</span>
<span class="gi">+)</span>
<span class="w"> </span>from contextlib import ExitStack, contextmanager
<span class="w"> </span>from subprocess import Popen
<span class="w"> </span>from traceback import format_tb
<span class="gd">-from typing import Any, Callable, Coroutine, Generator, Generic, Hashable, Iterable, Iterator, TypeVar, cast, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Coroutine,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Hashable,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.buffer import Buffer
<span class="w"> </span>from prompt_toolkit.cache import SimpleCache
<span class="w"> </span>from prompt_toolkit.clipboard import Clipboard, InMemoryClipboard
<span class="w"> </span>from prompt_toolkit.cursor_shapes import AnyCursorShapeConfig, to_cursor_shape_config
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.enums import EditingMode
<span class="gd">-from prompt_toolkit.eventloop import InputHook, get_traceback_from_context, new_eventloop_with_inputhook, run_in_executor_with_context</span>
<span class="gi">+from prompt_toolkit.eventloop import (</span>
<span class="gi">+    InputHook,</span>
<span class="gi">+    get_traceback_from_context,</span>
<span class="gi">+    new_eventloop_with_inputhook,</span>
<span class="gi">+    run_in_executor_with_context,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.eventloop.utils import call_soon_threadsafe
<span class="w"> </span>from prompt_toolkit.filters import Condition, Filter, FilterOrBool, to_filter
<span class="w"> </span>from prompt_toolkit.formatted_text import AnyFormattedText
<span class="w"> </span>from prompt_toolkit.input.base import Input
<span class="w"> </span>from prompt_toolkit.input.typeahead import get_typeahead, store_typeahead
<span class="gd">-from prompt_toolkit.key_binding.bindings.page_navigation import load_page_navigation_bindings</span>
<span class="gi">+from prompt_toolkit.key_binding.bindings.page_navigation import (</span>
<span class="gi">+    load_page_navigation_bindings,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.defaults import load_key_bindings
<span class="w"> </span>from prompt_toolkit.key_binding.emacs_state import EmacsState
<span class="gd">-from prompt_toolkit.key_binding.key_bindings import Binding, ConditionalKeyBindings, GlobalOnlyKeyBindings, KeyBindings, KeyBindingsBase, KeysTuple, merge_key_bindings</span>
<span class="gi">+from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+    Binding,</span>
<span class="gi">+    ConditionalKeyBindings,</span>
<span class="gi">+    GlobalOnlyKeyBindings,</span>
<span class="gi">+    KeyBindings,</span>
<span class="gi">+    KeyBindingsBase,</span>
<span class="gi">+    KeysTuple,</span>
<span class="gi">+    merge_key_bindings,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent, KeyProcessor
<span class="w"> </span>from prompt_toolkit.key_binding.vi_state import ViState
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="gu">@@ -38,16 +74,32 @@ from prompt_toolkit.layout.layout import Layout, walk</span>
<span class="w"> </span>from prompt_toolkit.output import ColorDepth, Output
<span class="w"> </span>from prompt_toolkit.renderer import Renderer, print_formatted_text
<span class="w"> </span>from prompt_toolkit.search import SearchState
<span class="gd">-from prompt_toolkit.styles import BaseStyle, DummyStyle, DummyStyleTransformation, DynamicStyle, StyleTransformation, default_pygments_style, default_ui_style, merge_styles</span>
<span class="gi">+from prompt_toolkit.styles import (</span>
<span class="gi">+    BaseStyle,</span>
<span class="gi">+    DummyStyle,</span>
<span class="gi">+    DummyStyleTransformation,</span>
<span class="gi">+    DynamicStyle,</span>
<span class="gi">+    StyleTransformation,</span>
<span class="gi">+    default_pygments_style,</span>
<span class="gi">+    default_ui_style,</span>
<span class="gi">+    merge_styles,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.utils import Event, in_main_thread
<span class="gi">+</span>
<span class="w"> </span>from .current import get_app_session, set_app
<span class="w"> </span>from .run_in_terminal import in_terminal, run_in_terminal
<span class="gd">-__all__ = [&#39;Application&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Application&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent
<span class="gd">-_AppResult = TypeVar(&#39;_AppResult&#39;)</span>
<span class="gd">-ApplicationEventHandler = Callable[[&#39;Application[_AppResult]&#39;], None]</span>
<span class="gd">-_SIGWINCH = getattr(signal, &#39;SIGWINCH&#39;, None)</span>
<span class="gd">-_SIGTSTP = getattr(signal, &#39;SIGTSTP&#39;, None)</span>
<span class="gi">+_AppResult = TypeVar(&quot;_AppResult&quot;)</span>
<span class="gi">+ApplicationEventHandler = Callable[[&quot;Application[_AppResult]&quot;], None]</span>
<span class="gi">+</span>
<span class="gi">+_SIGWINCH = getattr(signal, &quot;SIGWINCH&quot;, None)</span>
<span class="gi">+_SIGTSTP = getattr(signal, &quot;SIGTSTP&quot;, None)</span>


<span class="w"> </span>class Application(Generic[_AppResult]):
<span class="gu">@@ -131,50 +183,67 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        await app.run_async()
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, layout: (Layout | None)=None, style: (BaseStyle |</span>
<span class="gd">-        None)=None, include_default_pygments_style: FilterOrBool=True,</span>
<span class="gd">-        style_transformation: (StyleTransformation | None)=None,</span>
<span class="gd">-        key_bindings: (KeyBindingsBase | None)=None, clipboard: (Clipboard |</span>
<span class="gd">-        None)=None, full_screen: bool=False, color_depth: (ColorDepth |</span>
<span class="gd">-        Callable[[], ColorDepth | None] | None)=None, mouse_support:</span>
<span class="gd">-        FilterOrBool=False, enable_page_navigation_bindings: (None |</span>
<span class="gd">-        FilterOrBool)=None, paste_mode: FilterOrBool=False, editing_mode:</span>
<span class="gd">-        EditingMode=EditingMode.EMACS, erase_when_done: bool=False,</span>
<span class="gd">-        reverse_vi_search_direction: FilterOrBool=False,</span>
<span class="gd">-        min_redraw_interval: (float | int | None)=None,</span>
<span class="gd">-        max_render_postpone_time: (float | int | None)=0.01,</span>
<span class="gd">-        refresh_interval: (float | None)=None,</span>
<span class="gd">-        terminal_size_polling_interval: (float | None)=0.5, cursor:</span>
<span class="gd">-        AnyCursorShapeConfig=None, on_reset: (ApplicationEventHandler[</span>
<span class="gd">-        _AppResult] | None)=None, on_invalidate: (ApplicationEventHandler[</span>
<span class="gd">-        _AppResult] | None)=None, before_render: (ApplicationEventHandler[</span>
<span class="gd">-        _AppResult] | None)=None, after_render: (ApplicationEventHandler[</span>
<span class="gd">-        _AppResult] | None)=None, input: (Input | None)=None, output: (</span>
<span class="gd">-        Output | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        layout: Layout | None = None,</span>
<span class="gi">+        style: BaseStyle | None = None,</span>
<span class="gi">+        include_default_pygments_style: FilterOrBool = True,</span>
<span class="gi">+        style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        clipboard: Clipboard | None = None,</span>
<span class="gi">+        full_screen: bool = False,</span>
<span class="gi">+        color_depth: (ColorDepth | Callable[[], ColorDepth | None] | None) = None,</span>
<span class="gi">+        mouse_support: FilterOrBool = False,</span>
<span class="gi">+        enable_page_navigation_bindings: None</span>
<span class="gi">+        | (FilterOrBool) = None,  # Can be None, True or False.</span>
<span class="gi">+        paste_mode: FilterOrBool = False,</span>
<span class="gi">+        editing_mode: EditingMode = EditingMode.EMACS,</span>
<span class="gi">+        erase_when_done: bool = False,</span>
<span class="gi">+        reverse_vi_search_direction: FilterOrBool = False,</span>
<span class="gi">+        min_redraw_interval: float | int | None = None,</span>
<span class="gi">+        max_render_postpone_time: float | int | None = 0.01,</span>
<span class="gi">+        refresh_interval: float | None = None,</span>
<span class="gi">+        terminal_size_polling_interval: float | None = 0.5,</span>
<span class="gi">+        cursor: AnyCursorShapeConfig = None,</span>
<span class="gi">+        on_reset: ApplicationEventHandler[_AppResult] | None = None,</span>
<span class="gi">+        on_invalidate: ApplicationEventHandler[_AppResult] | None = None,</span>
<span class="gi">+        before_render: ApplicationEventHandler[_AppResult] | None = None,</span>
<span class="gi">+        after_render: ApplicationEventHandler[_AppResult] | None = None,</span>
<span class="gi">+        # I/O.</span>
<span class="gi">+        input: Input | None = None,</span>
<span class="gi">+        output: Output | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # If `enable_page_navigation_bindings` is not specified, enable it in</span>
<span class="gi">+        # case of full screen applications only. This can be overridden by the user.</span>
<span class="w"> </span>        if enable_page_navigation_bindings is None:
<span class="gd">-            enable_page_navigation_bindings = Condition(lambda : self.</span>
<span class="gd">-                full_screen)</span>
<span class="gi">+            enable_page_navigation_bindings = Condition(lambda: self.full_screen)</span>
<span class="gi">+</span>
<span class="w"> </span>        paste_mode = to_filter(paste_mode)
<span class="w"> </span>        mouse_support = to_filter(mouse_support)
<span class="w"> </span>        reverse_vi_search_direction = to_filter(reverse_vi_search_direction)
<span class="gd">-        enable_page_navigation_bindings = to_filter(</span>
<span class="gd">-            enable_page_navigation_bindings)</span>
<span class="gd">-        include_default_pygments_style = to_filter(</span>
<span class="gd">-            include_default_pygments_style)</span>
<span class="gi">+        enable_page_navigation_bindings = to_filter(enable_page_navigation_bindings)</span>
<span class="gi">+        include_default_pygments_style = to_filter(include_default_pygments_style)</span>
<span class="gi">+</span>
<span class="w"> </span>        if layout is None:
<span class="w"> </span>            layout = create_dummy_layout()
<span class="gi">+</span>
<span class="w"> </span>        if style_transformation is None:
<span class="w"> </span>            style_transformation = DummyStyleTransformation()
<span class="gi">+</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.style_transformation = style_transformation
<span class="gi">+</span>
<span class="gi">+        # Key bindings.</span>
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self._default_bindings = load_key_bindings()
<span class="w"> </span>        self._page_navigation_bindings = load_page_navigation_bindings()
<span class="gi">+</span>
<span class="w"> </span>        self.layout = layout
<span class="w"> </span>        self.clipboard = clipboard or InMemoryClipboard()
<span class="w"> </span>        self.full_screen: bool = full_screen
<span class="w"> </span>        self._color_depth = color_depth
<span class="w"> </span>        self.mouse_support = mouse_support
<span class="gi">+</span>
<span class="w"> </span>        self.paste_mode = paste_mode
<span class="w"> </span>        self.editing_mode = editing_mode
<span class="w"> </span>        self.erase_when_done = erase_when_done
<span class="gu">@@ -184,49 +253,114 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        self.max_render_postpone_time = max_render_postpone_time
<span class="w"> </span>        self.refresh_interval = refresh_interval
<span class="w"> </span>        self.terminal_size_polling_interval = terminal_size_polling_interval
<span class="gi">+</span>
<span class="w"> </span>        self.cursor = to_cursor_shape_config(cursor)
<span class="gi">+</span>
<span class="gi">+        # Events.</span>
<span class="w"> </span>        self.on_invalidate = Event(self, on_invalidate)
<span class="w"> </span>        self.on_reset = Event(self, on_reset)
<span class="w"> </span>        self.before_render = Event(self, before_render)
<span class="w"> </span>        self.after_render = Event(self, after_render)
<span class="gi">+</span>
<span class="gi">+        # I/O.</span>
<span class="w"> </span>        session = get_app_session()
<span class="w"> </span>        self.output = output or session.output
<span class="w"> </span>        self.input = input or session.input
<span class="gi">+</span>
<span class="gi">+        # List of &#39;extra&#39; functions to execute before a Application.run.</span>
<span class="w"> </span>        self.pre_run_callables: list[Callable[[], None]] = []
<span class="gi">+</span>
<span class="w"> </span>        self._is_running = False
<span class="w"> </span>        self.future: Future[_AppResult] | None = None
<span class="w"> </span>        self.loop: AbstractEventLoop | None = None
<span class="w"> </span>        self._loop_thread: threading.Thread | None = None
<span class="w"> </span>        self.context: contextvars.Context | None = None
<span class="gi">+</span>
<span class="gi">+        #: Quoted insert. This flag is set if we go into quoted insert mode.</span>
<span class="w"> </span>        self.quoted_insert = False
<span class="gi">+</span>
<span class="gi">+        #: Vi state. (For Vi key bindings.)</span>
<span class="w"> </span>        self.vi_state = ViState()
<span class="w"> </span>        self.emacs_state = EmacsState()
<span class="gd">-        self.ttimeoutlen = 0.5</span>
<span class="gi">+</span>
<span class="gi">+        #: When to flush the input (For flushing escape keys.) This is important</span>
<span class="gi">+        #: on terminals that use vt100 input. We can&#39;t distinguish the escape</span>
<span class="gi">+        #: key from for instance the left-arrow key, if we don&#39;t know what follows</span>
<span class="gi">+        #: after &quot;\x1b&quot;. This little timer will consider &quot;\x1b&quot; to be escape if</span>
<span class="gi">+        #: nothing did follow in this time span.</span>
<span class="gi">+        #: This seems to work like the `ttimeoutlen` option in Vim.</span>
<span class="gi">+        self.ttimeoutlen = 0.5  # Seconds.</span>
<span class="gi">+</span>
<span class="gi">+        #: Like Vim&#39;s `timeoutlen` option. This can be `None` or a float.  For</span>
<span class="gi">+        #: instance, suppose that we have a key binding AB and a second key</span>
<span class="gi">+        #: binding A. If the uses presses A and then waits, we don&#39;t handle</span>
<span class="gi">+        #: this binding yet (unless it was marked &#39;eager&#39;), because we don&#39;t</span>
<span class="gi">+        #: know what will follow. This timeout is the maximum amount of time</span>
<span class="gi">+        #: that we wait until we call the handlers anyway. Pass `None` to</span>
<span class="gi">+        #: disable this timeout.</span>
<span class="w"> </span>        self.timeoutlen = 1.0
<span class="gd">-        self._merged_style = self._create_merged_style(</span>
<span class="gd">-            include_default_pygments_style)</span>
<span class="gd">-        self.renderer = Renderer(self._merged_style, self.output,</span>
<span class="gd">-            full_screen=full_screen, mouse_support=mouse_support,</span>
<span class="gd">-            cpr_not_supported_callback=self.cpr_not_supported_callback)</span>
<span class="gi">+</span>
<span class="gi">+        #: The `Renderer` instance.</span>
<span class="gi">+        # Make sure that the same stdout is used, when a custom renderer has been passed.</span>
<span class="gi">+        self._merged_style = self._create_merged_style(include_default_pygments_style)</span>
<span class="gi">+</span>
<span class="gi">+        self.renderer = Renderer(</span>
<span class="gi">+            self._merged_style,</span>
<span class="gi">+            self.output,</span>
<span class="gi">+            full_screen=full_screen,</span>
<span class="gi">+            mouse_support=mouse_support,</span>
<span class="gi">+            cpr_not_supported_callback=self.cpr_not_supported_callback,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        #: Render counter. This one is increased every time the UI is rendered.</span>
<span class="gi">+        #: It can be used as a key for caching certain information during one</span>
<span class="gi">+        #: rendering.</span>
<span class="w"> </span>        self.render_counter = 0
<span class="gi">+</span>
<span class="gi">+        # Invalidate flag. When &#39;True&#39;, a repaint has been scheduled.</span>
<span class="w"> </span>        self._invalidated = False
<span class="gd">-        self._invalidate_events: list[Event[object]] = []</span>
<span class="gd">-        self._last_redraw_time = 0.0</span>
<span class="gi">+        self._invalidate_events: list[</span>
<span class="gi">+            Event[object]</span>
<span class="gi">+        ] = []  # Collection of &#39;invalidate&#39; Event objects.</span>
<span class="gi">+        self._last_redraw_time = 0.0  # Unix timestamp of last redraw. Used when</span>
<span class="gi">+        # `min_redraw_interval` is given.</span>
<span class="gi">+</span>
<span class="gi">+        #: The `InputProcessor` instance.</span>
<span class="w"> </span>        self.key_processor = KeyProcessor(_CombinedRegistry(self))
<span class="gi">+</span>
<span class="gi">+        # If `run_in_terminal` was called. This will point to a `Future` what will be</span>
<span class="gi">+        # set at the point when the previous run finishes.</span>
<span class="w"> </span>        self._running_in_terminal = False
<span class="w"> </span>        self._running_in_terminal_f: Future[None] | None = None
<span class="gi">+</span>
<span class="gi">+        # Trigger initialize callback.</span>
<span class="w"> </span>        self.reset()

<span class="gd">-    def _create_merged_style(self, include_default_pygments_style: Filter</span>
<span class="gd">-        ) -&gt;BaseStyle:</span>
<span class="gi">+    def _create_merged_style(self, include_default_pygments_style: Filter) -&gt; BaseStyle:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a `Style` object that merges the default UI style, the default
<span class="w"> </span>        pygments style, and the custom user style.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dummy_style = DummyStyle()</span>
<span class="gi">+        pygments_style = default_pygments_style()</span>
<span class="gi">+</span>
<span class="gi">+        @DynamicStyle</span>
<span class="gi">+        def conditional_pygments_style() -&gt; BaseStyle:</span>
<span class="gi">+            if include_default_pygments_style():</span>
<span class="gi">+                return pygments_style</span>
<span class="gi">+            else:</span>
<span class="gi">+                return dummy_style</span>
<span class="gi">+</span>
<span class="gi">+        return merge_styles(</span>
<span class="gi">+            [</span>
<span class="gi">+                default_ui_style(),</span>
<span class="gi">+                conditional_pygments_style,</span>
<span class="gi">+                DynamicStyle(lambda: self.style),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def color_depth(self) -&gt;ColorDepth:</span>
<span class="gi">+    def color_depth(self) -&gt; ColorDepth:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The active :class:`.ColorDepth`.

<span class="gu">@@ -239,10 +373,18 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>          created using `output.defaults.create_output`, then this value is
<span class="w"> </span>          coming from the $PROMPT_TOOLKIT_COLOR_DEPTH environment variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        depth = self._color_depth</span>
<span class="gi">+</span>
<span class="gi">+        if callable(depth):</span>
<span class="gi">+            depth = depth()</span>
<span class="gi">+</span>
<span class="gi">+        if depth is None:</span>
<span class="gi">+            depth = self.output.get_default_color_depth()</span>
<span class="gi">+</span>
<span class="gi">+        return depth</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_buffer(self) -&gt;Buffer:</span>
<span class="gi">+    def current_buffer(self) -&gt; Buffer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The currently focused :class:`~.Buffer`.

<span class="gu">@@ -250,57 +392,192 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        has the focus. In this case, it&#39;s really not practical to check for
<span class="w"> </span>        `None` values or catch exceptions every time.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.layout.current_buffer or Buffer(</span>
<span class="gi">+            name=&quot;dummy-buffer&quot;</span>
<span class="gi">+        )  # Dummy buffer.</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_search_state(self) -&gt;SearchState:</span>
<span class="gi">+    def current_search_state(self) -&gt; SearchState:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the current :class:`.SearchState`. (The one for the focused
<span class="w"> </span>        :class:`.BufferControl`.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ui_control = self.layout.current_control</span>
<span class="gi">+        if isinstance(ui_control, BufferControl):</span>
<span class="gi">+            return ui_control.search_state</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SearchState()  # Dummy search state.  (Don&#39;t return None!)</span>

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reset everything, for reading the next input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Notice that we don&#39;t reset the buffers. (This happens just before</span>
<span class="gi">+        # returning, and when we have multiple buffers, we clearly want the</span>
<span class="gi">+        # content in the other buffers to remain unchanged between several</span>
<span class="gi">+        # calls of `run`. (And the same is true for the focus stack.)</span>
<span class="gi">+</span>
<span class="gi">+        self.exit_style = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self._background_tasks: set[Task[None]] = set()</span>
<span class="gi">+</span>
<span class="gi">+        self.renderer.reset()</span>
<span class="gi">+        self.key_processor.reset()</span>
<span class="gi">+        self.layout.reset()</span>
<span class="gi">+        self.vi_state.reset()</span>
<span class="gi">+        self.emacs_state.reset()</span>

<span class="gd">-    def invalidate(self) -&gt;None:</span>
<span class="gi">+        # Trigger reset event.</span>
<span class="gi">+        self.on_reset.fire()</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure that we have a &#39;focusable&#39; widget focused.</span>
<span class="gi">+        # (The `Layout` class can&#39;t determine this.)</span>
<span class="gi">+        layout = self.layout</span>
<span class="gi">+</span>
<span class="gi">+        if not layout.current_control.is_focusable():</span>
<span class="gi">+            for w in layout.find_all_windows():</span>
<span class="gi">+                if w.content.is_focusable():</span>
<span class="gi">+                    layout.current_window = w</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+    def invalidate(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Thread safe way of sending a repaint trigger to the input event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._is_running:</span>
<span class="gi">+            # Don&#39;t schedule a redraw if we&#39;re not running.</span>
<span class="gi">+            # Otherwise, `get_running_loop()` in `call_soon_threadsafe` can fail.</span>
<span class="gi">+            # See: https://github.com/dbcli/mycli/issues/797</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # `invalidate()` called if we don&#39;t have a loop yet (not running?), or</span>
<span class="gi">+        # after the event loop was closed.</span>
<span class="gi">+        if self.loop is None or self.loop.is_closed():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Never schedule a second redraw, when a previous one has not yet been</span>
<span class="gi">+        # executed. (This should protect against other threads calling</span>
<span class="gi">+        # &#39;invalidate&#39; many times, resulting in 100% CPU.)</span>
<span class="gi">+        if self._invalidated:</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._invalidated = True</span>
<span class="gi">+</span>
<span class="gi">+        # Trigger event.</span>
<span class="gi">+        self.loop.call_soon_threadsafe(self.on_invalidate.fire)</span>
<span class="gi">+</span>
<span class="gi">+        def redraw() -&gt; None:</span>
<span class="gi">+            self._invalidated = False</span>
<span class="gi">+            self._redraw()</span>
<span class="gi">+</span>
<span class="gi">+        def schedule_redraw() -&gt; None:</span>
<span class="gi">+            call_soon_threadsafe(</span>
<span class="gi">+                redraw, max_postpone_time=self.max_render_postpone_time, loop=self.loop</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.min_redraw_interval:</span>
<span class="gi">+            # When a minimum redraw interval is set, wait minimum this amount</span>
<span class="gi">+            # of time between redraws.</span>
<span class="gi">+            diff = time.time() - self._last_redraw_time</span>
<span class="gi">+            if diff &lt; self.min_redraw_interval:</span>
<span class="gi">+</span>
<span class="gi">+                async def redraw_in_future() -&gt; None:</span>
<span class="gi">+                    await sleep(cast(float, self.min_redraw_interval) - diff)</span>
<span class="gi">+                    schedule_redraw()</span>
<span class="gi">+</span>
<span class="gi">+                self.loop.call_soon_threadsafe(</span>
<span class="gi">+                    lambda: self.create_background_task(redraw_in_future())</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                schedule_redraw()</span>
<span class="gi">+        else:</span>
<span class="gi">+            schedule_redraw()</span>

<span class="w"> </span>    @property
<span class="gd">-    def invalidated(self) -&gt;bool:</span>
<span class="gd">-        &quot;&quot;&quot;True when a redraw operation has been scheduled.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def invalidated(self) -&gt; bool:</span>
<span class="gi">+        &quot;True when a redraw operation has been scheduled.&quot;</span>
<span class="gi">+        return self._invalidated</span>

<span class="gd">-    def _redraw(self, render_as_done: bool=False) -&gt;None:</span>
<span class="gi">+    def _redraw(self, render_as_done: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Render the command line again. (Not thread safe!) (From other threads,
<span class="w"> </span>        or if unsure, use :meth:`.Application.invalidate`.)

<span class="w"> </span>        :param render_as_done: make sure to put the cursor after the UI.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _start_auto_refresh_task(self) -&gt;None:</span>
<span class="gi">+        def run_in_context() -&gt; None:</span>
<span class="gi">+            # Only draw when no sub application was started.</span>
<span class="gi">+            if self._is_running and not self._running_in_terminal:</span>
<span class="gi">+                if self.min_redraw_interval:</span>
<span class="gi">+                    self._last_redraw_time = time.time()</span>
<span class="gi">+</span>
<span class="gi">+                # Render</span>
<span class="gi">+                self.render_counter += 1</span>
<span class="gi">+                self.before_render.fire()</span>
<span class="gi">+</span>
<span class="gi">+                if render_as_done:</span>
<span class="gi">+                    if self.erase_when_done:</span>
<span class="gi">+                        self.renderer.erase()</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Draw in &#39;done&#39; state and reset renderer.</span>
<span class="gi">+                        self.renderer.render(self, self.layout, is_done=render_as_done)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.renderer.render(self, self.layout)</span>
<span class="gi">+</span>
<span class="gi">+                self.layout.update_parents_relations()</span>
<span class="gi">+</span>
<span class="gi">+                # Fire render event.</span>
<span class="gi">+                self.after_render.fire()</span>
<span class="gi">+</span>
<span class="gi">+                self._update_invalidate_events()</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: We want to make sure this Application is the active one. The</span>
<span class="gi">+        #       invalidate function is often called from a context where this</span>
<span class="gi">+        #       application is not the active one. (Like the</span>
<span class="gi">+        #       `PromptSession._auto_refresh_context`).</span>
<span class="gi">+        #       We copy the context in case the context was already active, to</span>
<span class="gi">+        #       prevent RuntimeErrors. (The rendering is not supposed to change</span>
<span class="gi">+        #       any context variables.)</span>
<span class="gi">+        if self.context is not None:</span>
<span class="gi">+            self.context.copy().run(run_in_context)</span>
<span class="gi">+</span>
<span class="gi">+    def _start_auto_refresh_task(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start a while/true loop in the background for automatic invalidation of
<span class="w"> </span>        the UI.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.refresh_interval is not None and self.refresh_interval != 0:</span>

<span class="gd">-    def _update_invalidate_events(self) -&gt;None:</span>
<span class="gi">+            async def auto_refresh(refresh_interval: float) -&gt; None:</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    await sleep(refresh_interval)</span>
<span class="gi">+                    self.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+            self.create_background_task(auto_refresh(self.refresh_interval))</span>
<span class="gi">+</span>
<span class="gi">+    def _update_invalidate_events(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Make sure to attach &#39;invalidate&#39; handlers to all invalidate events in
<span class="w"> </span>        the UI.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Remove all the original event handlers. (Components can be removed</span>
<span class="gi">+        # from the UI.)</span>
<span class="gi">+        for ev in self._invalidate_events:</span>
<span class="gi">+            ev -= self._invalidate_handler</span>
<span class="gi">+</span>
<span class="gi">+        # Gather all new events.</span>
<span class="gi">+        # (All controls are able to invalidate themselves.)</span>
<span class="gi">+        def gather_events() -&gt; Iterable[Event[object]]:</span>
<span class="gi">+            for c in self.layout.find_all_controls():</span>
<span class="gi">+                yield from c.get_invalidate_events()</span>

<span class="gd">-    def _invalidate_handler(self, sender: object) -&gt;None:</span>
<span class="gi">+        self._invalidate_events = list(gather_events())</span>
<span class="gi">+</span>
<span class="gi">+        for ev in self._invalidate_events:</span>
<span class="gi">+            ev += self._invalidate_handler</span>
<span class="gi">+</span>
<span class="gi">+    def _invalidate_handler(self, sender: object) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handler for invalidate events coming from UIControls.

<span class="gu">@@ -308,17 +585,21 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        `self.invalidate`. It also needs to be a method -not a nested
<span class="w"> </span>        function-, so that we can remove it again .)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.invalidate()</span>

<span class="gd">-    def _on_resize(self) -&gt;None:</span>
<span class="gi">+    def _on_resize(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When the window size changes, we erase the current output and request
<span class="w"> </span>        again the cursor position. When the CPR answer arrives, the output is
<span class="w"> </span>        drawn again.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Erase, request position (when cursor is at the start position)</span>
<span class="gi">+        # and redraw again. -- The order is important.</span>
<span class="gi">+        self.renderer.erase(leave_alternate_screen=False)</span>
<span class="gi">+        self._request_absolute_cursor_position()</span>
<span class="gi">+        self._redraw()</span>

<span class="gd">-    def _pre_run(self, pre_run: (Callable[[], None] | None)=None) -&gt;None:</span>
<span class="gi">+    def _pre_run(self, pre_run: Callable[[], None] | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Called during `run`.

<span class="gu">@@ -328,11 +609,21 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        another thread that would call `Application.exit`. (See the progress
<span class="w"> </span>        bar code for an example.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def run_async(self, pre_run: (Callable[[], None] | None)=None,</span>
<span class="gd">-        set_exception_handler: bool=True, handle_sigint: bool=True,</span>
<span class="gd">-        slow_callback_duration: float=0.5) -&gt;_AppResult:</span>
<span class="gi">+        if pre_run:</span>
<span class="gi">+            pre_run()</span>
<span class="gi">+</span>
<span class="gi">+        # Process registered &quot;pre_run_callables&quot; and clear list.</span>
<span class="gi">+        for c in self.pre_run_callables:</span>
<span class="gi">+            c()</span>
<span class="gi">+        del self.pre_run_callables[:]</span>
<span class="gi">+</span>
<span class="gi">+    async def run_async(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+        set_exception_handler: bool = True,</span>
<span class="gi">+        handle_sigint: bool = True,</span>
<span class="gi">+        slow_callback_duration: float = 0.5,</span>
<span class="gi">+    ) -&gt; _AppResult:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run the prompt_toolkit :class:`~prompt_toolkit.application.Application`
<span class="w"> </span>        until :meth:`~prompt_toolkit.application.Application.exit` has been
<span class="gu">@@ -357,12 +648,263 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>            because exceptionally, the drawing of the app, which happens in the
<span class="w"> </span>            event loop, can take a bit longer from time to time.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def run(self, pre_run: (Callable[[], None] | None)=None,</span>
<span class="gd">-        set_exception_handler: bool=True, handle_sigint: bool=True,</span>
<span class="gd">-        in_thread: bool=False, inputhook: (InputHook | None)=None</span>
<span class="gd">-        ) -&gt;_AppResult:</span>
<span class="gi">+        assert not self._is_running, &quot;Application is already running.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if not in_main_thread() or sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # Handling signals in other threads is not supported.</span>
<span class="gi">+            # Also on Windows, `add_signal_handler(signal.SIGINT, ...)` raises</span>
<span class="gi">+            # `NotImplementedError`.</span>
<span class="gi">+            # See: https://github.com/prompt-toolkit/python-prompt-toolkit/issues/1553</span>
<span class="gi">+            handle_sigint = False</span>
<span class="gi">+</span>
<span class="gi">+        async def _run_async(f: asyncio.Future[_AppResult]) -&gt; _AppResult:</span>
<span class="gi">+            context = contextvars.copy_context()</span>
<span class="gi">+            self.context = context</span>
<span class="gi">+</span>
<span class="gi">+            # Counter for cancelling &#39;flush&#39; timeouts. Every time when a key is</span>
<span class="gi">+            # pressed, we start a &#39;flush&#39; timer for flushing our escape key. But</span>
<span class="gi">+            # when any subsequent input is received, a new timer is started and</span>
<span class="gi">+            # the current timer will be ignored.</span>
<span class="gi">+            flush_task: asyncio.Task[None] | None = None</span>
<span class="gi">+</span>
<span class="gi">+            # Reset.</span>
<span class="gi">+            # (`self.future` needs to be set when `pre_run` is called.)</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+            self._pre_run(pre_run)</span>
<span class="gi">+</span>
<span class="gi">+            # Feed type ahead input first.</span>
<span class="gi">+            self.key_processor.feed_multiple(get_typeahead(self.input))</span>
<span class="gi">+            self.key_processor.process_keys()</span>
<span class="gi">+</span>
<span class="gi">+            def read_from_input() -&gt; None:</span>
<span class="gi">+                nonlocal flush_task</span>
<span class="gi">+</span>
<span class="gi">+                # Ignore when we aren&#39;t running anymore. This callback will</span>
<span class="gi">+                # removed from the loop next time. (It could be that it was</span>
<span class="gi">+                # still in the &#39;tasks&#39; list of the loop.)</span>
<span class="gi">+                # Except: if we need to process incoming CPRs.</span>
<span class="gi">+                if not self._is_running and not self.renderer.waiting_for_cpr:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # Get keys from the input object.</span>
<span class="gi">+                keys = self.input.read_keys()</span>
<span class="gi">+</span>
<span class="gi">+                # Feed to key processor.</span>
<span class="gi">+                self.key_processor.feed_multiple(keys)</span>
<span class="gi">+                self.key_processor.process_keys()</span>
<span class="gi">+</span>
<span class="gi">+                # Quit when the input stream was closed.</span>
<span class="gi">+                if self.input.closed:</span>
<span class="gi">+                    if not f.done():</span>
<span class="gi">+                        f.set_exception(EOFError)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Automatically flush keys.</span>
<span class="gi">+                    if flush_task:</span>
<span class="gi">+                        flush_task.cancel()</span>
<span class="gi">+                    flush_task = self.create_background_task(auto_flush_input())</span>
<span class="gi">+</span>
<span class="gi">+            def read_from_input_in_context() -&gt; None:</span>
<span class="gi">+                # Ensure that key bindings callbacks are always executed in the</span>
<span class="gi">+                # current context. This is important when key bindings are</span>
<span class="gi">+                # accessing contextvars. (These callbacks are currently being</span>
<span class="gi">+                # called from a different context. Underneath,</span>
<span class="gi">+                # `loop.add_reader` is used to register the stdin FD.)</span>
<span class="gi">+                # (We copy the context to avoid a `RuntimeError` in case the</span>
<span class="gi">+                # context is already active.)</span>
<span class="gi">+                context.copy().run(read_from_input)</span>
<span class="gi">+</span>
<span class="gi">+            async def auto_flush_input() -&gt; None:</span>
<span class="gi">+                # Flush input after timeout.</span>
<span class="gi">+                # (Used for flushing the enter key.)</span>
<span class="gi">+                # This sleep can be cancelled, in that case we won&#39;t flush yet.</span>
<span class="gi">+                await sleep(self.ttimeoutlen)</span>
<span class="gi">+                flush_input()</span>
<span class="gi">+</span>
<span class="gi">+            def flush_input() -&gt; None:</span>
<span class="gi">+                if not self.is_done:</span>
<span class="gi">+                    # Get keys, and feed to key processor.</span>
<span class="gi">+                    keys = self.input.flush_keys()</span>
<span class="gi">+                    self.key_processor.feed_multiple(keys)</span>
<span class="gi">+                    self.key_processor.process_keys()</span>
<span class="gi">+</span>
<span class="gi">+                    if self.input.closed:</span>
<span class="gi">+                        f.set_exception(EOFError)</span>
<span class="gi">+</span>
<span class="gi">+            # Enter raw mode, attach input and attach WINCH event handler.</span>
<span class="gi">+            with self.input.raw_mode(), self.input.attach(</span>
<span class="gi">+                read_from_input_in_context</span>
<span class="gi">+            ), attach_winch_signal_handler(self._on_resize):</span>
<span class="gi">+                # Draw UI.</span>
<span class="gi">+                self._request_absolute_cursor_position()</span>
<span class="gi">+                self._redraw()</span>
<span class="gi">+                self._start_auto_refresh_task()</span>
<span class="gi">+</span>
<span class="gi">+                self.create_background_task(self._poll_output_size())</span>
<span class="gi">+</span>
<span class="gi">+                # Wait for UI to finish.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    result = await f</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    # In any case, when the application finishes.</span>
<span class="gi">+                    # (Successful, or because of an error.)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        self._redraw(render_as_done=True)</span>
<span class="gi">+                    finally:</span>
<span class="gi">+                        # _redraw has a good chance to fail if it calls widgets</span>
<span class="gi">+                        # with bad code. Make sure to reset the renderer</span>
<span class="gi">+                        # anyway.</span>
<span class="gi">+                        self.renderer.reset()</span>
<span class="gi">+</span>
<span class="gi">+                        # Unset `is_running`, this ensures that possibly</span>
<span class="gi">+                        # scheduled draws won&#39;t paint during the following</span>
<span class="gi">+                        # yield.</span>
<span class="gi">+                        self._is_running = False</span>
<span class="gi">+</span>
<span class="gi">+                        # Detach event handlers for invalidate events.</span>
<span class="gi">+                        # (Important when a UIControl is embedded in multiple</span>
<span class="gi">+                        # applications, like ptterm in pymux. An invalidate</span>
<span class="gi">+                        # should not trigger a repaint in terminated</span>
<span class="gi">+                        # applications.)</span>
<span class="gi">+                        for ev in self._invalidate_events:</span>
<span class="gi">+                            ev -= self._invalidate_handler</span>
<span class="gi">+                        self._invalidate_events = []</span>
<span class="gi">+</span>
<span class="gi">+                        # Wait for CPR responses.</span>
<span class="gi">+                        if self.output.responds_to_cpr:</span>
<span class="gi">+                            await self.renderer.wait_for_cpr_responses()</span>
<span class="gi">+</span>
<span class="gi">+                        # Wait for the run-in-terminals to terminate.</span>
<span class="gi">+                        previous_run_in_terminal_f = self._running_in_terminal_f</span>
<span class="gi">+</span>
<span class="gi">+                        if previous_run_in_terminal_f:</span>
<span class="gi">+                            await previous_run_in_terminal_f</span>
<span class="gi">+</span>
<span class="gi">+                        # Store unprocessed input as typeahead for next time.</span>
<span class="gi">+                        store_typeahead(self.input, self.key_processor.empty_queue())</span>
<span class="gi">+</span>
<span class="gi">+                return result</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def set_loop() -&gt; Iterator[AbstractEventLoop]:</span>
<span class="gi">+            loop = get_running_loop()</span>
<span class="gi">+            self.loop = loop</span>
<span class="gi">+            self._loop_thread = threading.current_thread()</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield loop</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.loop = None</span>
<span class="gi">+                self._loop_thread = None</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def set_is_running() -&gt; Iterator[None]:</span>
<span class="gi">+            self._is_running = True</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self._is_running = False</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def set_handle_sigint(loop: AbstractEventLoop) -&gt; Iterator[None]:</span>
<span class="gi">+            if handle_sigint:</span>
<span class="gi">+                with _restore_sigint_from_ctypes():</span>
<span class="gi">+                    # save sigint handlers (python and os level)</span>
<span class="gi">+                    # See: https://github.com/prompt-toolkit/python-prompt-toolkit/issues/1576</span>
<span class="gi">+                    loop.add_signal_handler(</span>
<span class="gi">+                        signal.SIGINT,</span>
<span class="gi">+                        lambda *_: loop.call_soon_threadsafe(</span>
<span class="gi">+                            self.key_processor.send_sigint</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        yield</span>
<span class="gi">+                    finally:</span>
<span class="gi">+                        loop.remove_signal_handler(signal.SIGINT)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def set_exception_handler_ctx(loop: AbstractEventLoop) -&gt; Iterator[None]:</span>
<span class="gi">+            if set_exception_handler:</span>
<span class="gi">+                previous_exc_handler = loop.get_exception_handler()</span>
<span class="gi">+                loop.set_exception_handler(self._handle_exception)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    loop.set_exception_handler(previous_exc_handler)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def set_callback_duration(loop: AbstractEventLoop) -&gt; Iterator[None]:</span>
<span class="gi">+            # Set slow_callback_duration.</span>
<span class="gi">+            original_slow_callback_duration = loop.slow_callback_duration</span>
<span class="gi">+            loop.slow_callback_duration = slow_callback_duration</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield</span>
<span class="gi">+            finally:</span>
<span class="gi">+                # Reset slow_callback_duration.</span>
<span class="gi">+                loop.slow_callback_duration = original_slow_callback_duration</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def create_future(</span>
<span class="gi">+            loop: AbstractEventLoop,</span>
<span class="gi">+        ) -&gt; Iterator[asyncio.Future[_AppResult]]:</span>
<span class="gi">+            f = loop.create_future()</span>
<span class="gi">+            self.future = f  # XXX: make sure to set this before calling &#39;_redraw&#39;.</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield f</span>
<span class="gi">+            finally:</span>
<span class="gi">+                # Also remove the Future again. (This brings the</span>
<span class="gi">+                # application back to its initial state, where it also</span>
<span class="gi">+                # doesn&#39;t have a Future.)</span>
<span class="gi">+                self.future = None</span>
<span class="gi">+</span>
<span class="gi">+        with ExitStack() as stack:</span>
<span class="gi">+            stack.enter_context(set_is_running())</span>
<span class="gi">+</span>
<span class="gi">+            # Make sure to set `_invalidated` to `False` to begin with,</span>
<span class="gi">+            # otherwise we&#39;re not going to paint anything. This can happen if</span>
<span class="gi">+            # this application had run before on a different event loop, and a</span>
<span class="gi">+            # paint was scheduled using `call_soon_threadsafe` with</span>
<span class="gi">+            # `max_postpone_time`.</span>
<span class="gi">+            self._invalidated = False</span>
<span class="gi">+</span>
<span class="gi">+            loop = stack.enter_context(set_loop())</span>
<span class="gi">+</span>
<span class="gi">+            stack.enter_context(set_handle_sigint(loop))</span>
<span class="gi">+            stack.enter_context(set_exception_handler_ctx(loop))</span>
<span class="gi">+            stack.enter_context(set_callback_duration(loop))</span>
<span class="gi">+            stack.enter_context(set_app(self))</span>
<span class="gi">+            stack.enter_context(self._enable_breakpointhook())</span>
<span class="gi">+</span>
<span class="gi">+            f = stack.enter_context(create_future(loop))</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                return await _run_async(f)</span>
<span class="gi">+            finally:</span>
<span class="gi">+                # Wait for the background tasks to be done. This needs to</span>
<span class="gi">+                # go in the finally! If `_run_async` raises</span>
<span class="gi">+                # `KeyboardInterrupt`, we still want to wait for the</span>
<span class="gi">+                # background tasks.</span>
<span class="gi">+                await self.cancel_and_wait_for_background_tasks()</span>
<span class="gi">+</span>
<span class="gi">+        # The `ExitStack` above is defined in typeshed in a way that it can</span>
<span class="gi">+        # swallow exceptions. Without next line, mypy would think that there&#39;s</span>
<span class="gi">+        # a possibility we don&#39;t return here. See:</span>
<span class="gi">+        # https://github.com/python/mypy/issues/7726</span>
<span class="gi">+        assert False, &quot;unreachable&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def run(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+        set_exception_handler: bool = True,</span>
<span class="gi">+        handle_sigint: bool = True,</span>
<span class="gi">+        in_thread: bool = False,</span>
<span class="gi">+        inputhook: InputHook | None = None,</span>
<span class="gi">+    ) -&gt; _AppResult:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        A blocking &#39;run&#39; call that waits until the UI is finished.

<span class="gu">@@ -387,26 +929,122 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        :param handle_sigint: Handle SIGINT signal. Call the key binding for
<span class="w"> </span>            `Keys.SIGINT`. (This only works in the main thread.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _handle_exception(self, loop: AbstractEventLoop, context: dict[str,</span>
<span class="gd">-        Any]) -&gt;None:</span>
<span class="gi">+        if in_thread:</span>
<span class="gi">+            result: _AppResult</span>
<span class="gi">+            exception: BaseException | None = None</span>
<span class="gi">+</span>
<span class="gi">+            def run_in_thread() -&gt; None:</span>
<span class="gi">+                nonlocal result, exception</span>
<span class="gi">+                try:</span>
<span class="gi">+                    result = self.run(</span>
<span class="gi">+                        pre_run=pre_run,</span>
<span class="gi">+                        set_exception_handler=set_exception_handler,</span>
<span class="gi">+                        # Signal handling only works in the main thread.</span>
<span class="gi">+                        handle_sigint=False,</span>
<span class="gi">+                        inputhook=inputhook,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except BaseException as e:</span>
<span class="gi">+                    exception = e</span>
<span class="gi">+</span>
<span class="gi">+            thread = threading.Thread(target=run_in_thread)</span>
<span class="gi">+            thread.start()</span>
<span class="gi">+            thread.join()</span>
<span class="gi">+</span>
<span class="gi">+            if exception is not None:</span>
<span class="gi">+                raise exception</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        coro = self.run_async(</span>
<span class="gi">+            pre_run=pre_run,</span>
<span class="gi">+            set_exception_handler=set_exception_handler,</span>
<span class="gi">+            handle_sigint=handle_sigint,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def _called_from_ipython() -&gt; bool:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    sys.modules[&quot;IPython&quot;].version_info &lt; (8, 18, 0, &quot;&quot;)</span>
<span class="gi">+                    and &quot;IPython/terminal/interactiveshell.py&quot;</span>
<span class="gi">+                    in sys._getframe(3).f_code.co_filename</span>
<span class="gi">+                )</span>
<span class="gi">+            except BaseException:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        if inputhook is not None:</span>
<span class="gi">+            # Create new event loop with given input hook and run the app.</span>
<span class="gi">+            # In Python 3.12, we can use asyncio.run(loop_factory=...)</span>
<span class="gi">+            # For now, use `run_until_complete()`.</span>
<span class="gi">+            loop = new_eventloop_with_inputhook(inputhook)</span>
<span class="gi">+            result = loop.run_until_complete(coro)</span>
<span class="gi">+            loop.run_until_complete(loop.shutdown_asyncgens())</span>
<span class="gi">+            loop.close()</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        elif _called_from_ipython():</span>
<span class="gi">+            # workaround to make input hooks work for IPython until</span>
<span class="gi">+            # https://github.com/ipython/ipython/pull/14241 is merged.</span>
<span class="gi">+            # IPython was setting the input hook by installing an event loop</span>
<span class="gi">+            # previously.</span>
<span class="gi">+            try:</span>
<span class="gi">+                # See whether a loop was installed already. If so, use that.</span>
<span class="gi">+                # That&#39;s required for the input hooks to work, they are</span>
<span class="gi">+                # installed using `set_event_loop`.</span>
<span class="gi">+                loop = asyncio.get_event_loop()</span>
<span class="gi">+            except RuntimeError:</span>
<span class="gi">+                # No loop installed. Run like usual.</span>
<span class="gi">+                return asyncio.run(coro)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Use existing loop.</span>
<span class="gi">+                return loop.run_until_complete(coro)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # No loop installed. Run like usual.</span>
<span class="gi">+            return asyncio.run(coro)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_exception(</span>
<span class="gi">+        self, loop: AbstractEventLoop, context: dict[str, Any]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handler for event loop exceptions.
<span class="w"> </span>        This will print the exception, using run_in_terminal.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # For Python 2: we have to get traceback at this point, because</span>
<span class="gi">+        # we&#39;re still in the &#39;except:&#39; block of the event loop where the</span>
<span class="gi">+        # traceback is still available. Moving this code in the</span>
<span class="gi">+        # &#39;print_exception&#39; coroutine will loose the exception.</span>
<span class="gi">+        tb = get_traceback_from_context(context)</span>
<span class="gi">+        formatted_tb = &quot;&quot;.join(format_tb(tb))</span>
<span class="gi">+</span>
<span class="gi">+        async def in_term() -&gt; None:</span>
<span class="gi">+            async with in_terminal():</span>
<span class="gi">+                # Print output. Similar to &#39;loop.default_exception_handler&#39;,</span>
<span class="gi">+                # but don&#39;t use logger. (This works better on Python 2.)</span>
<span class="gi">+                print(&quot;\nUnhandled exception in event loop:&quot;)</span>
<span class="gi">+                print(formatted_tb)</span>
<span class="gi">+                print(&quot;Exception {}&quot;.format(context.get(&quot;exception&quot;)))</span>
<span class="gi">+</span>
<span class="gi">+                await _do_wait_for_enter(&quot;Press ENTER to continue...&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ensure_future(in_term())</span>

<span class="w"> </span>    @contextmanager
<span class="gd">-    def _enable_breakpointhook(self) -&gt;Generator[None, None, None]:</span>
<span class="gi">+    def _enable_breakpointhook(self) -&gt; Generator[None, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Install our custom breakpointhook for the duration of this context
<span class="w"> </span>        manager. (We will only install the hook if no other custom hook was
<span class="w"> </span>        set.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sys.breakpointhook == sys.__breakpointhook__:</span>
<span class="gi">+            sys.breakpointhook = self._breakpointhook</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield</span>
<span class="gi">+            finally:</span>
<span class="gi">+                sys.breakpointhook = sys.__breakpointhook__</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield</span>

<span class="gd">-    def _breakpointhook(self, *a: object, **kw: object) -&gt;None:</span>
<span class="gi">+    def _breakpointhook(self, *a: object, **kw: object) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Breakpointhook which uses PDB, but ensures that the application is
<span class="w"> </span>        hidden and input echoing is restored during each debugger dispatch.
<span class="gu">@@ -415,10 +1053,85 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        event loop will be blocked while the PDB input is displayed. The event
<span class="w"> </span>        will continue after leaving the debugger.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def create_background_task(self, coroutine: Coroutine[Any, Any, None]</span>
<span class="gd">-        ) -&gt;asyncio.Task[None]:</span>
<span class="gi">+        app = self</span>
<span class="gi">+        # Inline import on purpose. We don&#39;t want to import pdb, if not needed.</span>
<span class="gi">+        import pdb</span>
<span class="gi">+        from types import FrameType</span>
<span class="gi">+</span>
<span class="gi">+        TraceDispatch = Callable[[FrameType, str, Any], Any]</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def hide_app_from_eventloop_thread() -&gt; Generator[None, None, None]:</span>
<span class="gi">+            &quot;&quot;&quot;Stop application if `__breakpointhook__` is called from within</span>
<span class="gi">+            the App&#39;s event loop.&quot;&quot;&quot;</span>
<span class="gi">+            # Hide application.</span>
<span class="gi">+            app.renderer.erase()</span>
<span class="gi">+</span>
<span class="gi">+            # Detach input and dispatch to debugger.</span>
<span class="gi">+            with app.input.detach():</span>
<span class="gi">+                with app.input.cooked_mode():</span>
<span class="gi">+                    yield</span>
<span class="gi">+</span>
<span class="gi">+            # Note: we don&#39;t render the application again here, because</span>
<span class="gi">+            # there&#39;s a good chance that there&#39;s a breakpoint on the next</span>
<span class="gi">+            # line. This paint/erase cycle would move the PDB prompt back</span>
<span class="gi">+            # to the middle of the screen.</span>
<span class="gi">+</span>
<span class="gi">+        @contextmanager</span>
<span class="gi">+        def hide_app_from_other_thread() -&gt; Generator[None, None, None]:</span>
<span class="gi">+            &quot;&quot;&quot;Stop application if `__breakpointhook__` is called from a</span>
<span class="gi">+            thread other than the App&#39;s event loop.&quot;&quot;&quot;</span>
<span class="gi">+            ready = threading.Event()</span>
<span class="gi">+            done = threading.Event()</span>
<span class="gi">+</span>
<span class="gi">+            async def in_loop() -&gt; None:</span>
<span class="gi">+                # from .run_in_terminal import in_terminal</span>
<span class="gi">+                # async with in_terminal():</span>
<span class="gi">+                #     ready.set()</span>
<span class="gi">+                #     await asyncio.get_running_loop().run_in_executor(None, done.wait)</span>
<span class="gi">+                #     return</span>
<span class="gi">+</span>
<span class="gi">+                # Hide application.</span>
<span class="gi">+                app.renderer.erase()</span>
<span class="gi">+</span>
<span class="gi">+                # Detach input and dispatch to debugger.</span>
<span class="gi">+                with app.input.detach():</span>
<span class="gi">+                    with app.input.cooked_mode():</span>
<span class="gi">+                        ready.set()</span>
<span class="gi">+                        # Here we block the App&#39;s event loop thread until the</span>
<span class="gi">+                        # debugger resumes. We could have used `with</span>
<span class="gi">+                        # run_in_terminal.in_terminal():` like the commented</span>
<span class="gi">+                        # code above, but it seems to work better if we</span>
<span class="gi">+                        # completely stop the main event loop while debugging.</span>
<span class="gi">+                        done.wait()</span>
<span class="gi">+</span>
<span class="gi">+            self.create_background_task(in_loop())</span>
<span class="gi">+            ready.wait()</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield</span>
<span class="gi">+            finally:</span>
<span class="gi">+                done.set()</span>
<span class="gi">+</span>
<span class="gi">+        class CustomPdb(pdb.Pdb):</span>
<span class="gi">+            def trace_dispatch(</span>
<span class="gi">+                self, frame: FrameType, event: str, arg: Any</span>
<span class="gi">+            ) -&gt; TraceDispatch:</span>
<span class="gi">+                if app._loop_thread is None:</span>
<span class="gi">+                    return super().trace_dispatch(frame, event, arg)</span>
<span class="gi">+</span>
<span class="gi">+                if app._loop_thread == threading.current_thread():</span>
<span class="gi">+                    with hide_app_from_eventloop_thread():</span>
<span class="gi">+                        return super().trace_dispatch(frame, event, arg)</span>
<span class="gi">+</span>
<span class="gi">+                with hide_app_from_other_thread():</span>
<span class="gi">+                    return super().trace_dispatch(frame, event, arg)</span>
<span class="gi">+</span>
<span class="gi">+        frame = sys._getframe().f_back</span>
<span class="gi">+        CustomPdb(stdout=sys.__stdout__).set_trace(frame)</span>
<span class="gi">+</span>
<span class="gi">+    def create_background_task(</span>
<span class="gi">+        self, coroutine: Coroutine[Any, Any, None]</span>
<span class="gi">+    ) -&gt; asyncio.Task[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start a background task (coroutine) for the running application. When
<span class="w"> </span>        the `Application` terminates, unfinished background tasks will be
<span class="gu">@@ -435,16 +1148,35 @@ class Application(Generic[_AppResult]):</span>

<span class="w"> </span>        This is not threadsafe.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        loop = self.loop or get_running_loop()</span>
<span class="gi">+        task: asyncio.Task[None] = loop.create_task(coroutine)</span>
<span class="gi">+        self._background_tasks.add(task)</span>
<span class="gi">+</span>
<span class="gi">+        task.add_done_callback(self._on_background_task_done)</span>
<span class="gi">+        return task</span>

<span class="gd">-    def _on_background_task_done(self, task: asyncio.Task[None]) -&gt;None:</span>
<span class="gi">+    def _on_background_task_done(self, task: asyncio.Task[None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Called when a background task completes. Remove it from
<span class="w"> </span>        `_background_tasks`, and handle exceptions if any.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def cancel_and_wait_for_background_tasks(self) -&gt;None:</span>
<span class="gi">+        self._background_tasks.discard(task)</span>
<span class="gi">+</span>
<span class="gi">+        if task.cancelled():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        exc = task.exception()</span>
<span class="gi">+        if exc is not None:</span>
<span class="gi">+            get_running_loop().call_exception_handler(</span>
<span class="gi">+                {</span>
<span class="gi">+                    &quot;message&quot;: f&quot;prompt_toolkit.Application background task {task!r} &quot;</span>
<span class="gi">+                    &quot;raised an unexpected exception.&quot;,</span>
<span class="gi">+                    &quot;exception&quot;: exc,</span>
<span class="gi">+                    &quot;task&quot;: task,</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    async def cancel_and_wait_for_background_tasks(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Cancel all background tasks, and wait for the cancellation to complete.
<span class="w"> </span>        If any of the background tasks raised an exception, this will also
<span class="gu">@@ -453,9 +1185,30 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        (If we had nurseries like Trio, this would be the `__aexit__` of a
<span class="w"> </span>        nursery.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def _poll_output_size(self) -&gt;None:</span>
<span class="gi">+        for task in self._background_tasks:</span>
<span class="gi">+            task.cancel()</span>
<span class="gi">+</span>
<span class="gi">+        # Wait until the cancellation of the background tasks completes.</span>
<span class="gi">+        # `asyncio.wait()` does not propagate exceptions raised within any of</span>
<span class="gi">+        # these tasks, which is what we want. Otherwise, we can&#39;t distinguish</span>
<span class="gi">+        # between a `CancelledError` raised in this task because it got</span>
<span class="gi">+        # cancelled, and a `CancelledError` raised on this `await` checkpoint,</span>
<span class="gi">+        # because *we* got cancelled during the teardown of the application.</span>
<span class="gi">+        # (If we get cancelled here, then it&#39;s important to not suppress the</span>
<span class="gi">+        # `CancelledError`, and have it propagate.)</span>
<span class="gi">+        # NOTE: Currently, if we get cancelled at this point then we can&#39;t wait</span>
<span class="gi">+        #       for the cancellation to complete (in the future, we should be</span>
<span class="gi">+        #       using anyio or Python&#39;s 3.11 TaskGroup.)</span>
<span class="gi">+        #       Also, if we had exception groups, we could propagate an</span>
<span class="gi">+        #       `ExceptionGroup` if something went wrong here. Right now, we</span>
<span class="gi">+        #       don&#39;t propagate exceptions, but have them printed in</span>
<span class="gi">+        #       `_on_background_task_done`.</span>
<span class="gi">+        if len(self._background_tasks) &gt; 0:</span>
<span class="gi">+            await asyncio.wait(</span>
<span class="gi">+                self._background_tasks, timeout=None, return_when=asyncio.ALL_COMPLETED</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    async def _poll_output_size(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine for polling the terminal dimensions.

<span class="gu">@@ -463,33 +1216,55 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        - If we are not running in the main thread.
<span class="w"> </span>        - On Windows.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        size: Size | None = None</span>
<span class="gi">+        interval = self.terminal_size_polling_interval</span>

<span class="gd">-    def cpr_not_supported_callback(self) -&gt;None:</span>
<span class="gi">+        if interval is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            await asyncio.sleep(interval)</span>
<span class="gi">+            new_size = self.output.get_size()</span>
<span class="gi">+</span>
<span class="gi">+            if size is not None and new_size != size:</span>
<span class="gi">+                self._on_resize()</span>
<span class="gi">+            size = new_size</span>
<span class="gi">+</span>
<span class="gi">+    def cpr_not_supported_callback(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Called when we don&#39;t receive the cursor position response in time.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.output.responds_to_cpr:</span>
<span class="gi">+            return  # We know about this already.</span>

<span class="gd">-    @overload</span>
<span class="gd">-    def exit(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Exit without arguments.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        def in_terminal() -&gt; None:</span>
<span class="gi">+            self.output.write(</span>
<span class="gi">+                &quot;WARNING: your terminal doesn&#39;t support cursor position requests (CPR).\r\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        run_in_terminal(in_terminal)</span>

<span class="w"> </span>    @overload
<span class="gd">-    def exit(self, *, result: _AppResult, style: str=&#39;&#39;) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Exit with `_AppResult`.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def exit(self) -&gt; None:</span>
<span class="gi">+        &quot;Exit without arguments.&quot;</span>

<span class="w"> </span>    @overload
<span class="gd">-    def exit(self, *, exception: (BaseException | type[BaseException]),</span>
<span class="gd">-        style: str=&#39;&#39;) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Exit with exception.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def exit(self, *, result: _AppResult, style: str = &quot;&quot;) -&gt; None:</span>
<span class="gi">+        &quot;Exit with `_AppResult`.&quot;</span>

<span class="gd">-    def exit(self, result: (_AppResult | None)=None, exception: (</span>
<span class="gd">-        BaseException | type[BaseException] | None)=None, style: str=&#39;&#39;</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def exit(</span>
<span class="gi">+        self, *, exception: BaseException | type[BaseException], style: str = &quot;&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        &quot;Exit with exception.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def exit(</span>
<span class="gi">+        self,</span>
<span class="gi">+        result: _AppResult | None = None,</span>
<span class="gi">+        exception: BaseException | type[BaseException] | None = None,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Exit application.

<span class="gu">@@ -508,17 +1283,38 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>            often this is &#39;class:exiting&#39; for a prompt. (Used when
<span class="w"> </span>            `erase_when_done` is not set.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert result is None or exception is None</span>
<span class="gi">+</span>
<span class="gi">+        if self.future is None:</span>
<span class="gi">+            raise Exception(&quot;Application is not running. Application.exit() failed.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.future.done():</span>
<span class="gi">+            raise Exception(&quot;Return value already set. Application.exit() failed.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.exit_style = style</span>
<span class="gi">+</span>
<span class="gi">+        if exception is not None:</span>
<span class="gi">+            self.future.set_exception(exception)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.future.set_result(cast(_AppResult, result))</span>

<span class="gd">-    def _request_absolute_cursor_position(self) -&gt;None:</span>
<span class="gi">+    def _request_absolute_cursor_position(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send CPR request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def run_system_command(self, command: str, wait_for_enter: bool=</span>
<span class="gd">-        True, display_before_text: AnyFormattedText=&#39;&#39;, wait_text: str=</span>
<span class="gd">-        &#39;Press ENTER to continue...&#39;) -&gt;None:</span>
<span class="gi">+        # Note: only do this if the input queue is not empty, and a return</span>
<span class="gi">+        # value has not been set. Otherwise, we won&#39;t be able to read the</span>
<span class="gi">+        # response anyway.</span>
<span class="gi">+        if not self.key_processor.input_queue and not self.is_done:</span>
<span class="gi">+            self.renderer.request_absolute_cursor_position()</span>
<span class="gi">+</span>
<span class="gi">+    async def run_system_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        command: str,</span>
<span class="gi">+        wait_for_enter: bool = True,</span>
<span class="gi">+        display_before_text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        wait_text: str = &quot;Press ENTER to continue...&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run system command (While hiding the prompt. When finished, all the
<span class="w"> </span>        output will scroll above the prompt.)
<span class="gu">@@ -530,9 +1326,31 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>            command executes.
<span class="w"> </span>        :return: A `Future` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def suspend_to_background(self, suspend_group: bool=True) -&gt;None:</span>
<span class="gi">+        async with in_terminal():</span>
<span class="gi">+            # Try to use the same input/output file descriptors as the one,</span>
<span class="gi">+            # used to run this application.</span>
<span class="gi">+            try:</span>
<span class="gi">+                input_fd = self.input.fileno()</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                input_fd = sys.stdin.fileno()</span>
<span class="gi">+            try:</span>
<span class="gi">+                output_fd = self.output.fileno()</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                output_fd = sys.stdout.fileno()</span>
<span class="gi">+</span>
<span class="gi">+            # Run sub process.</span>
<span class="gi">+            def run_command() -&gt; None:</span>
<span class="gi">+                self.print_text(display_before_text)</span>
<span class="gi">+                p = Popen(command, shell=True, stdin=input_fd, stdout=output_fd)</span>
<span class="gi">+                p.wait()</span>
<span class="gi">+</span>
<span class="gi">+            await run_in_executor_with_context(run_command)</span>
<span class="gi">+</span>
<span class="gi">+            # Wait for the user to press enter.</span>
<span class="gi">+            if wait_for_enter:</span>
<span class="gi">+                await _do_wait_for_enter(wait_text)</span>
<span class="gi">+</span>
<span class="gi">+    def suspend_to_background(self, suspend_group: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        (Not thread safe -- to be called from inside the key bindings.)
<span class="w"> </span>        Suspend process.
<span class="gu">@@ -540,10 +1358,27 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        :param suspend_group: When true, suspend the whole process group.
<span class="w"> </span>            (This is the default, and probably what you want.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def print_text(self, text: AnyFormattedText, style: (BaseStyle | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # Only suspend when the operating system supports it.</span>
<span class="gi">+        # (Not on Windows.)</span>
<span class="gi">+        if _SIGTSTP is not None:</span>
<span class="gi">+</span>
<span class="gi">+            def run() -&gt; None:</span>
<span class="gi">+                signal = cast(int, _SIGTSTP)</span>
<span class="gi">+                # Send `SIGTSTP` to own process.</span>
<span class="gi">+                # This will cause it to suspend.</span>
<span class="gi">+</span>
<span class="gi">+                # Usually we want the whole process group to be suspended. This</span>
<span class="gi">+                # handles the case when input is piped from another process.</span>
<span class="gi">+                if suspend_group:</span>
<span class="gi">+                    os.kill(0, signal)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    os.kill(os.getpid(), signal)</span>
<span class="gi">+</span>
<span class="gi">+            run_in_terminal(run)</span>
<span class="gi">+</span>
<span class="gi">+    def print_text(</span>
<span class="gi">+        self, text: AnyFormattedText, style: BaseStyle | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Print a list of (style_str, text) tuples to the output.
<span class="w"> </span>        (When the UI is running, this method has to be called through
<span class="gu">@@ -552,19 +1387,39 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        :param text: List of ``(style_str, text)`` tuples.
<span class="w"> </span>        :param style: Style class to use. Defaults to the active style in the CLI.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print_formatted_text(</span>
<span class="gi">+            output=self.output,</span>
<span class="gi">+            formatted_text=text,</span>
<span class="gi">+            style=style or self._merged_style,</span>
<span class="gi">+            color_depth=self.color_depth,</span>
<span class="gi">+            style_transformation=self.style_transformation,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_running(self) -&gt;bool:</span>
<span class="gd">-        &quot;&quot;&quot;`True` when the application is currently active/running.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def is_running(self) -&gt; bool:</span>
<span class="gi">+        &quot;`True` when the application is currently active/running.&quot;</span>
<span class="gi">+        return self._is_running</span>

<span class="gd">-    def get_used_style_strings(self) -&gt;list[str]:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_done(self) -&gt; bool:</span>
<span class="gi">+        if self.future:</span>
<span class="gi">+            return self.future.done()</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def get_used_style_strings(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of used style strings. This is helpful for debugging, and
<span class="w"> </span>        for writing a new `Style`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrs_for_style = self.renderer._attrs_for_style</span>
<span class="gi">+</span>
<span class="gi">+        if attrs_for_style:</span>
<span class="gi">+            return sorted(</span>
<span class="gi">+                re.sub(r&quot;\s+&quot;, &quot; &quot;, style_str).strip()</span>
<span class="gi">+                for style_str in attrs_for_style.keys()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class _CombinedRegistry(KeyBindingsBase):
<span class="gu">@@ -574,45 +1429,128 @@ class _CombinedRegistry(KeyBindingsBase):</span>
<span class="w"> </span>    control.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Application[_AppResult]) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Application[_AppResult]) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="gd">-        self._cache: SimpleCache[tuple[Window, frozenset[UIControl]],</span>
<span class="gd">-            KeyBindingsBase] = SimpleCache()</span>
<span class="gi">+        self._cache: SimpleCache[</span>
<span class="gi">+            tuple[Window, frozenset[UIControl]], KeyBindingsBase</span>
<span class="gi">+        ] = SimpleCache()</span>

<span class="w"> </span>    @property
<span class="gd">-    def _version(self) -&gt;Hashable:</span>
<span class="gi">+    def _version(self) -&gt; Hashable:</span>
<span class="w"> </span>        &quot;&quot;&quot;Not needed - this object is not going to be wrapped in another
<span class="w"> </span>        KeyBindings object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @property
<span class="gd">-    def bindings(self) -&gt;list[Binding]:</span>
<span class="gi">+    def bindings(self) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Not needed - this object is not going to be wrapped in another
<span class="w"> </span>        KeyBindings object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def _create_key_bindings(self, current_window: Window, other_controls:</span>
<span class="gd">-        list[UIControl]) -&gt;KeyBindingsBase:</span>
<span class="gi">+    def _create_key_bindings(</span>
<span class="gi">+        self, current_window: Window, other_controls: list[UIControl]</span>
<span class="gi">+    ) -&gt; KeyBindingsBase:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a `KeyBindings` object that merges the `KeyBindings` from the
<span class="w"> </span>        `UIControl` with all the parent controls and the global key bindings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key_bindings = []</span>
<span class="gi">+        collected_containers = set()</span>
<span class="gi">+</span>
<span class="gi">+        # Collect key bindings from currently focused control and all parent</span>
<span class="gi">+        # controls. Don&#39;t include key bindings of container parent controls.</span>
<span class="gi">+        container: Container = current_window</span>
<span class="gi">+        while True:</span>
<span class="gi">+            collected_containers.add(container)</span>
<span class="gi">+            kb = container.get_key_bindings()</span>
<span class="gi">+            if kb is not None:</span>
<span class="gi">+                key_bindings.append(kb)</span>
<span class="gi">+</span>
<span class="gi">+            if container.is_modal():</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            parent = self.app.layout.get_parent(container)</span>
<span class="gi">+            if parent is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                container = parent</span>
<span class="gi">+</span>
<span class="gi">+        # Include global bindings (starting at the top-model container).</span>
<span class="gi">+        for c in walk(container):</span>
<span class="gi">+            if c not in collected_containers:</span>
<span class="gi">+                kb = c.get_key_bindings()</span>
<span class="gi">+                if kb is not None:</span>
<span class="gi">+                    key_bindings.append(GlobalOnlyKeyBindings(kb))</span>
<span class="gi">+</span>
<span class="gi">+        # Add App key bindings</span>
<span class="gi">+        if self.app.key_bindings:</span>
<span class="gi">+            key_bindings.append(self.app.key_bindings)</span>
<span class="gi">+</span>
<span class="gi">+        # Add mouse bindings.</span>
<span class="gi">+        key_bindings.append(</span>
<span class="gi">+            ConditionalKeyBindings(</span>
<span class="gi">+                self.app._page_navigation_bindings,</span>
<span class="gi">+                self.app.enable_page_navigation_bindings,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        key_bindings.append(self.app._default_bindings)</span>
<span class="gi">+</span>
<span class="gi">+        # Reverse this list. The current control&#39;s key bindings should come</span>
<span class="gi">+        # last. They need priority.</span>
<span class="gi">+        key_bindings = key_bindings[::-1]</span>
<span class="gi">+</span>
<span class="gi">+        return merge_key_bindings(key_bindings)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _key_bindings(self) -&gt; KeyBindingsBase:</span>
<span class="gi">+        current_window = self.app.layout.current_window</span>
<span class="gi">+        other_controls = list(self.app.layout.find_all_controls())</span>
<span class="gi">+        key = current_window, frozenset(other_controls)</span>
<span class="gi">+</span>
<span class="gi">+        return self._cache.get(</span>
<span class="gi">+            key, lambda: self._create_key_bindings(current_window, other_controls)</span>
<span class="gi">+        )</span>

<span class="gi">+    def get_bindings_for_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="gi">+        return self._key_bindings.get_bindings_for_keys(keys)</span>

<span class="gd">-async def _do_wait_for_enter(wait_text: AnyFormattedText) -&gt;None:</span>
<span class="gi">+    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="gi">+        return self._key_bindings.get_bindings_starting_with_keys(keys)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def _do_wait_for_enter(wait_text: AnyFormattedText) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a sub application to wait for the enter key press.
<span class="w"> </span>    This has two advantages over using &#39;input&#39;/&#39;raw_input&#39;:
<span class="w"> </span>    - This will share the same input/output I/O.
<span class="w"> </span>    - This doesn&#39;t block the event loop.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.shortcuts import PromptSession</span>
<span class="gi">+</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(&quot;enter&quot;)</span>
<span class="gi">+    def _ok(event: E) -&gt; None:</span>
<span class="gi">+        event.app.exit()</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.Any)</span>
<span class="gi">+    def _ignore(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Disallow typing.&quot;</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    session: PromptSession[None] = PromptSession(</span>
<span class="gi">+        message=wait_text, key_bindings=key_bindings</span>
<span class="gi">+    )</span>
<span class="gi">+    try:</span>
<span class="gi">+        await session.app.run_async()</span>
<span class="gi">+    except KeyboardInterrupt:</span>
<span class="gi">+        pass  # Control-c pressed. Don&#39;t propagate this error.</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def attach_winch_signal_handler(handler: Callable[[], None]) -&gt;Generator[</span>
<span class="gd">-    None, None, None]:</span>
<span class="gi">+def attach_winch_signal_handler(</span>
<span class="gi">+    handler: Callable[[], None],</span>
<span class="gi">+) -&gt; Generator[None, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attach the given callback as a WINCH signal handler within the context
<span class="w"> </span>    manager. Restore the original signal handler when done.
<span class="gu">@@ -624,4 +1562,64 @@ def attach_winch_signal_handler(handler: Callable[[], None]) -&gt;Generator[</span>
<span class="w"> </span>    SIGWINCH. This is why it&#39;s important to restore the handler when the app
<span class="w"> </span>    terminates.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The tricky part here is that signals are registered in the Unix event</span>
<span class="gi">+    # loop with a wakeup fd, but another application could have registered</span>
<span class="gi">+    # signals using signal.signal directly. For now, the implementation is</span>
<span class="gi">+    # hard-coded for the `asyncio.unix_events._UnixSelectorEventLoop`.</span>
<span class="gi">+</span>
<span class="gi">+    # No WINCH? Then don&#39;t do anything.</span>
<span class="gi">+    sigwinch = getattr(signal, &quot;SIGWINCH&quot;, None)</span>
<span class="gi">+    if sigwinch is None or not in_main_thread():</span>
<span class="gi">+        yield</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Keep track of the previous handler.</span>
<span class="gi">+    # (Only UnixSelectorEventloop has `_signal_handlers`.)</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+    previous_winch_handler = getattr(loop, &quot;_signal_handlers&quot;, {}).get(sigwinch)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        loop.add_signal_handler(sigwinch, handler)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Restore the previous signal handler.</span>
<span class="gi">+        loop.remove_signal_handler(sigwinch)</span>
<span class="gi">+        if previous_winch_handler is not None:</span>
<span class="gi">+            loop.add_signal_handler(</span>
<span class="gi">+                sigwinch,</span>
<span class="gi">+                previous_winch_handler._callback,</span>
<span class="gi">+                *previous_winch_handler._args,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def _restore_sigint_from_ctypes() -&gt; Generator[None, None, None]:</span>
<span class="gi">+    # The following functions are part of the stable ABI since python 3.2</span>
<span class="gi">+    # See: https://docs.python.org/3/c-api/sys.html#c.PyOS_getsig</span>
<span class="gi">+    # Inline import: these are not available on Pypy.</span>
<span class="gi">+    try:</span>
<span class="gi">+        from ctypes import c_int, c_void_p, pythonapi</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        # Any of the above imports don&#39;t exist? Don&#39;t do anything here.</span>
<span class="gi">+        yield</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # PyOS_sighandler_t PyOS_getsig(int i)</span>
<span class="gi">+    pythonapi.PyOS_getsig.restype = c_void_p</span>
<span class="gi">+    pythonapi.PyOS_getsig.argtypes = (c_int,)</span>
<span class="gi">+</span>
<span class="gi">+    # PyOS_sighandler_t PyOS_setsig(int i, PyOS_sighandler_t h)</span>
<span class="gi">+    pythonapi.PyOS_setsig.restype = c_void_p</span>
<span class="gi">+    pythonapi.PyOS_setsig.argtypes = (</span>
<span class="gi">+        c_int,</span>
<span class="gi">+        c_void_p,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    sigint = signal.getsignal(signal.SIGINT)</span>
<span class="gi">+    sigint_os = pythonapi.PyOS_getsig(signal.SIGINT)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        signal.signal(signal.SIGINT, sigint)</span>
<span class="gi">+        pythonapi.PyOS_setsig(signal.SIGINT, sigint_os)</span>
<span class="gh">diff --git a/src/prompt_toolkit/application/current.py b/src/prompt_toolkit/application/current.py</span>
<span class="gh">index 74edbaba..908141a4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/current.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/current.py</span>
<span class="gu">@@ -1,13 +1,24 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from contextvars import ContextVar
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Generator
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.input.base import Input
<span class="w"> </span>    from prompt_toolkit.output.base import Output
<span class="gi">+</span>
<span class="w"> </span>    from .application import Application
<span class="gd">-__all__ = [&#39;AppSession&#39;, &#39;get_app_session&#39;, &#39;get_app&#39;, &#39;get_app_or_none&#39;,</span>
<span class="gd">-    &#39;set_app&#39;, &#39;create_app_session&#39;, &#39;create_app_session_from_tty&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;AppSession&quot;,</span>
<span class="gi">+    &quot;get_app_session&quot;,</span>
<span class="gi">+    &quot;get_app&quot;,</span>
<span class="gi">+    &quot;get_app_or_none&quot;,</span>
<span class="gi">+    &quot;set_app&quot;,</span>
<span class="gi">+    &quot;create_app_session&quot;,</span>
<span class="gi">+    &quot;create_app_session_from_tty&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class AppSession:
<span class="gu">@@ -27,21 +38,46 @@ class AppSession:</span>
<span class="w"> </span>    :param output: Use this as a default output.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, input: (Input | None)=None, output: (Output | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, input: Input | None = None, output: Output | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._input = input
<span class="w"> </span>        self._output = output
<span class="gi">+</span>
<span class="gi">+        # The application will be set dynamically by the `set_app` context</span>
<span class="gi">+        # manager. This is called in the application itself.</span>
<span class="w"> </span>        self.app: Application[Any] | None = None

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;AppSession(app={self.app!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;AppSession(app={self.app!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def input(self) -&gt; Input:</span>
<span class="gi">+        if self._input is None:</span>
<span class="gi">+            from prompt_toolkit.input.defaults import create_input</span>
<span class="gi">+</span>
<span class="gi">+            self._input = create_input()</span>
<span class="gi">+        return self._input</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def output(self) -&gt; Output:</span>
<span class="gi">+        if self._output is None:</span>
<span class="gi">+            from prompt_toolkit.output.defaults import create_output</span>
<span class="gi">+</span>
<span class="gi">+            self._output = create_output()</span>
<span class="gi">+        return self._output</span>


<span class="w"> </span>_current_app_session: ContextVar[AppSession] = ContextVar(
<span class="gd">-    &#39;_current_app_session&#39;, default=AppSession())</span>
<span class="gi">+    &quot;_current_app_session&quot;, default=AppSession()</span>
<span class="gi">+)</span>


<span class="gd">-def get_app() -&gt;Application[Any]:</span>
<span class="gi">+def get_app_session() -&gt; AppSession:</span>
<span class="gi">+    return _current_app_session.get()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_app() -&gt; Application[Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the current active (running) Application.
<span class="w"> </span>    An :class:`.Application` is active during the
<span class="gu">@@ -60,19 +96,26 @@ def get_app() -&gt;Application[Any]:</span>
<span class="w"> </span>    (For applications like pymux where we can have more than one `Application`,
<span class="w"> </span>    we&#39;ll use a work-around to handle that.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    session = _current_app_session.get()</span>
<span class="gi">+    if session.app is not None:</span>
<span class="gi">+        return session.app</span>
<span class="gi">+</span>
<span class="gi">+    from .dummy import DummyApplication</span>

<span class="gi">+    return DummyApplication()</span>

<span class="gd">-def get_app_or_none() -&gt;(Application[Any] | None):</span>
<span class="gi">+</span>
<span class="gi">+def get_app_or_none() -&gt; Application[Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the current active (running) Application, or return `None` if no
<span class="w"> </span>    application is running.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    session = _current_app_session.get()</span>
<span class="gi">+    return session.app</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def set_app(app: Application[Any]) -&gt;Generator[None, None, None]:</span>
<span class="gi">+def set_app(app: Application[Any]) -&gt; Generator[None, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Context manager that sets the given :class:`.Application` active in an
<span class="w"> </span>    `AppSession`.
<span class="gu">@@ -83,23 +126,45 @@ def set_app(app: Application[Any]) -&gt;Generator[None, None, None]:</span>
<span class="w"> </span>    the case, use `contextvars.copy_context()`, or use `Application.context` to
<span class="w"> </span>    run it in the appropriate context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    session = _current_app_session.get()</span>
<span class="gi">+</span>
<span class="gi">+    previous_app = session.app</span>
<span class="gi">+    session.app = app</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        session.app = previous_app</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def create_app_session(input: (Input | None)=None, output: (Output | None)=None</span>
<span class="gd">-    ) -&gt;Generator[AppSession, None, None]:</span>
<span class="gi">+def create_app_session(</span>
<span class="gi">+    input: Input | None = None, output: Output | None = None</span>
<span class="gi">+) -&gt; Generator[AppSession, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a separate AppSession.

<span class="w"> </span>    This is useful if there can be multiple individual `AppSession`s going on.
<span class="w"> </span>    Like in the case of an Telnet/SSH server.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If no input/output is specified, fall back to the current input/output,</span>
<span class="gi">+    # whatever that is.</span>
<span class="gi">+    if input is None:</span>
<span class="gi">+        input = get_app_session().input</span>
<span class="gi">+    if output is None:</span>
<span class="gi">+        output = get_app_session().output</span>
<span class="gi">+</span>
<span class="gi">+    # Create new `AppSession` and activate.</span>
<span class="gi">+    session = AppSession(input=input, output=output)</span>
<span class="gi">+</span>
<span class="gi">+    token = _current_app_session.set(session)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield session</span>
<span class="gi">+    finally:</span>
<span class="gi">+        _current_app_session.reset(token)</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def create_app_session_from_tty() -&gt;Generator[AppSession, None, None]:</span>
<span class="gi">+def create_app_session_from_tty() -&gt; Generator[AppSession, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create `AppSession` that always prefers the TTY input/output.

<span class="gu">@@ -114,4 +179,11 @@ def create_app_session_from_tty() -&gt;Generator[AppSession, None, None]:</span>
<span class="w"> </span>        with create_app_session_from_tty():
<span class="w"> </span>            prompt(&#39;&gt;&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.input.defaults import create_input</span>
<span class="gi">+    from prompt_toolkit.output.defaults import create_output</span>
<span class="gi">+</span>
<span class="gi">+    input = create_input(always_prefer_tty=True)</span>
<span class="gi">+    output = create_output(always_prefer_tty=True)</span>
<span class="gi">+</span>
<span class="gi">+    with create_app_session(input=input, output=output) as app_session:</span>
<span class="gi">+        yield app_session</span>
<span class="gh">diff --git a/src/prompt_toolkit/application/dummy.py b/src/prompt_toolkit/application/dummy.py</span>
<span class="gh">index cfa188c6..43819e1e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/dummy.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/dummy.py</span>
<span class="gu">@@ -1,11 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.eventloop import InputHook
<span class="w"> </span>from prompt_toolkit.formatted_text import AnyFormattedText
<span class="w"> </span>from prompt_toolkit.input import DummyInput
<span class="w"> </span>from prompt_toolkit.output import DummyOutput
<span class="gi">+</span>
<span class="w"> </span>from .application import Application
<span class="gd">-__all__ = [&#39;DummyApplication&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;DummyApplication&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class DummyApplication(Application[None]):
<span class="gu">@@ -14,5 +20,36 @@ class DummyApplication(Application[None]):</span>
<span class="w"> </span>    :func:`.get_app` will run an instance of this :class:`.DummyApplication` instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__(output=DummyOutput(), input=DummyInput())
<span class="gi">+</span>
<span class="gi">+    def run(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+        set_exception_handler: bool = True,</span>
<span class="gi">+        handle_sigint: bool = True,</span>
<span class="gi">+        in_thread: bool = False,</span>
<span class="gi">+        inputhook: InputHook | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(&quot;A DummyApplication is not supposed to run.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def run_async(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+        set_exception_handler: bool = True,</span>
<span class="gi">+        handle_sigint: bool = True,</span>
<span class="gi">+        slow_callback_duration: float = 0.5,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(&quot;A DummyApplication is not supposed to run.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def run_system_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        command: str,</span>
<span class="gi">+        wait_for_enter: bool = True,</span>
<span class="gi">+        display_before_text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        wait_text: str = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def suspend_to_background(self, suspend_group: bool = True) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/src/prompt_toolkit/application/run_in_terminal.py b/src/prompt_toolkit/application/run_in_terminal.py</span>
<span class="gh">index 2d3682ca..1e4da2d9 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/run_in_terminal.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/run_in_terminal.py</span>
<span class="gu">@@ -2,17 +2,26 @@</span>
<span class="w"> </span>Tools for running functions on the terminal above the current application or prompt.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from asyncio import Future, ensure_future
<span class="w"> </span>from contextlib import asynccontextmanager
<span class="w"> </span>from typing import AsyncGenerator, Awaitable, Callable, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.eventloop import run_in_executor_with_context
<span class="gi">+</span>
<span class="w"> </span>from .current import get_app_or_none
<span class="gd">-__all__ = [&#39;run_in_terminal&#39;, &#39;in_terminal&#39;]</span>
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;run_in_terminal&quot;,</span>
<span class="gi">+    &quot;in_terminal&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>

<span class="gd">-def run_in_terminal(func: Callable[[], _T], render_cli_done: bool=False,</span>
<span class="gd">-    in_executor: bool=False) -&gt;Awaitable[_T]:</span>
<span class="gi">+</span>
<span class="gi">+def run_in_terminal(</span>
<span class="gi">+    func: Callable[[], _T], render_cli_done: bool = False, in_executor: bool = False</span>
<span class="gi">+) -&gt; Awaitable[_T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Run function on the terminal above the current application or prompt.

<span class="gu">@@ -34,12 +43,19 @@ def run_in_terminal(func: Callable[[], _T], render_cli_done: bool=False,</span>

<span class="w"> </span>    :returns: A `Future`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    async def run() -&gt; _T:</span>
<span class="gi">+        async with in_terminal(render_cli_done=render_cli_done):</span>
<span class="gi">+            if in_executor:</span>
<span class="gi">+                return await run_in_executor_with_context(func)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return func()</span>
<span class="gi">+</span>
<span class="gi">+    return ensure_future(run())</span>


<span class="w"> </span>@asynccontextmanager
<span class="gd">-async def in_terminal(render_cli_done: bool=False) -&gt;AsyncGenerator[None, None</span>
<span class="gd">-    ]:</span>
<span class="gi">+async def in_terminal(render_cli_done: bool = False) -&gt; AsyncGenerator[None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Asynchronous context manager that suspends the current application and runs
<span class="w"> </span>    the body in the terminal.
<span class="gu">@@ -51,4 +67,47 @@ async def in_terminal(render_cli_done: bool=False) -&gt;AsyncGenerator[None, None</span>
<span class="w"> </span>                call_some_function()
<span class="w"> </span>                await call_some_async_function()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app_or_none()</span>
<span class="gi">+    if app is None or not app._is_running:</span>
<span class="gi">+        yield</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # When a previous `run_in_terminal` call was in progress. Wait for that</span>
<span class="gi">+    # to finish, before starting this one. Chain to previous call.</span>
<span class="gi">+    previous_run_in_terminal_f = app._running_in_terminal_f</span>
<span class="gi">+    new_run_in_terminal_f: Future[None] = Future()</span>
<span class="gi">+    app._running_in_terminal_f = new_run_in_terminal_f</span>
<span class="gi">+</span>
<span class="gi">+    # Wait for the previous `run_in_terminal` to finish.</span>
<span class="gi">+    if previous_run_in_terminal_f is not None:</span>
<span class="gi">+        await previous_run_in_terminal_f</span>
<span class="gi">+</span>
<span class="gi">+    # Wait for all CPRs to arrive. We don&#39;t want to detach the input until</span>
<span class="gi">+    # all cursor position responses have been arrived. Otherwise, the tty</span>
<span class="gi">+    # will echo its input and can show stuff like ^[[39;1R.</span>
<span class="gi">+    if app.output.responds_to_cpr:</span>
<span class="gi">+        await app.renderer.wait_for_cpr_responses()</span>
<span class="gi">+</span>
<span class="gi">+    # Draw interface in &#39;done&#39; state, or erase.</span>
<span class="gi">+    if render_cli_done:</span>
<span class="gi">+        app._redraw(render_as_done=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        app.renderer.erase()</span>
<span class="gi">+</span>
<span class="gi">+    # Disable rendering.</span>
<span class="gi">+    app._running_in_terminal = True</span>
<span class="gi">+</span>
<span class="gi">+    # Detach input.</span>
<span class="gi">+    try:</span>
<span class="gi">+        with app.input.detach():</span>
<span class="gi">+            with app.input.cooked_mode():</span>
<span class="gi">+                yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Redraw interface again.</span>
<span class="gi">+        try:</span>
<span class="gi">+            app._running_in_terminal = False</span>
<span class="gi">+            app.renderer.reset()</span>
<span class="gi">+            app._request_absolute_cursor_position()</span>
<span class="gi">+            app._redraw()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            new_run_in_terminal_f.set_result(None)</span>
<span class="gh">diff --git a/src/prompt_toolkit/auto_suggest.py b/src/prompt_toolkit/auto_suggest.py</span>
<span class="gh">index 2e73a69c..98cb4ddd 100644</span>
<span class="gd">--- a/src/prompt_toolkit/auto_suggest.py</span>
<span class="gi">+++ b/src/prompt_toolkit/auto_suggest.py</span>
<span class="gu">@@ -12,16 +12,27 @@ then wrap the :class:`.AutoSuggest` instance into a</span>
<span class="w"> </span>:class:`.ThreadedAutoSuggest`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.eventloop import run_in_executor_with_context
<span class="gi">+</span>
<span class="w"> </span>from .document import Document
<span class="w"> </span>from .filters import Filter, to_filter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .buffer import Buffer
<span class="gd">-__all__ = [&#39;Suggestion&#39;, &#39;AutoSuggest&#39;, &#39;ThreadedAutoSuggest&#39;,</span>
<span class="gd">-    &#39;DummyAutoSuggest&#39;, &#39;AutoSuggestFromHistory&#39;, &#39;ConditionalAutoSuggest&#39;,</span>
<span class="gd">-    &#39;DynamicAutoSuggest&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Suggestion&quot;,</span>
<span class="gi">+    &quot;AutoSuggest&quot;,</span>
<span class="gi">+    &quot;ThreadedAutoSuggest&quot;,</span>
<span class="gi">+    &quot;DummyAutoSuggest&quot;,</span>
<span class="gi">+    &quot;AutoSuggestFromHistory&quot;,</span>
<span class="gi">+    &quot;ConditionalAutoSuggest&quot;,</span>
<span class="gi">+    &quot;DynamicAutoSuggest&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Suggestion:
<span class="gu">@@ -31,11 +42,11 @@ class Suggestion:</span>
<span class="w"> </span>    :param text: The suggestion text.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, text: str) -&gt; None:</span>
<span class="w"> </span>        self.text = text

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Suggestion(%s)&#39; % self.text</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Suggestion(%s)&quot; % self.text</span>


<span class="w"> </span>class AutoSuggest(metaclass=ABCMeta):
<span class="gu">@@ -44,8 +55,7 @@ class AutoSuggest(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_suggestion(self, buffer: Buffer, document: Document) -&gt;(Suggestion</span>
<span class="gd">-         | None):</span>
<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return `None` or a :class:`.Suggestion` instance.

<span class="gu">@@ -60,16 +70,16 @@ class AutoSuggest(metaclass=ABCMeta):</span>
<span class="w"> </span>        :param buffer: The :class:`~prompt_toolkit.buffer.Buffer` instance.
<span class="w"> </span>        :param document: The :class:`~prompt_toolkit.document.Document` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    async def get_suggestion_async(self, buff: Buffer, document: Document) -&gt;(</span>
<span class="gd">-        Suggestion | None):</span>
<span class="gi">+    async def get_suggestion_async(</span>
<span class="gi">+        self, buff: Buffer, document: Document</span>
<span class="gi">+    ) -&gt; Suggestion | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a :class:`.Future` which is set when the suggestions are ready.
<span class="w"> </span>        This function can be overloaded in order to provide an asynchronous
<span class="w"> </span>        implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_suggestion(buff, document)</span>


<span class="w"> </span>class ThreadedAutoSuggest(AutoSuggest):
<span class="gu">@@ -79,15 +89,23 @@ class ThreadedAutoSuggest(AutoSuggest):</span>
<span class="w"> </span>    generation of suggestions takes too much time.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, auto_suggest: AutoSuggest) -&gt;None:</span>
<span class="gi">+    def __init__(self, auto_suggest: AutoSuggest) -&gt; None:</span>
<span class="w"> </span>        self.auto_suggest = auto_suggest

<span class="gd">-    async def get_suggestion_async(self, buff: Buffer, document: Document) -&gt;(</span>
<span class="gd">-        Suggestion | None):</span>
<span class="gi">+    def get_suggestion(self, buff: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        return self.auto_suggest.get_suggestion(buff, document)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_suggestion_async(</span>
<span class="gi">+        self, buff: Buffer, document: Document</span>
<span class="gi">+    ) -&gt; Suggestion | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run the `get_suggestion` function in a thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def run_get_suggestion_thread() -&gt; Suggestion | None:</span>
<span class="gi">+            return self.get_suggestion(buff, document)</span>
<span class="gi">+</span>
<span class="gi">+        return await run_in_executor_with_context(run_get_suggestion_thread)</span>


<span class="w"> </span>class DummyAutoSuggest(AutoSuggest):
<span class="gu">@@ -95,23 +113,47 @@ class DummyAutoSuggest(AutoSuggest):</span>
<span class="w"> </span>    AutoSuggest class that doesn&#39;t return any suggestion.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        return None  # No suggestion</span>
<span class="gi">+</span>

<span class="w"> </span>class AutoSuggestFromHistory(AutoSuggest):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Give suggestions based on the lines in the history.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        history = buffer.history</span>
<span class="gi">+</span>
<span class="gi">+        # Consider only the last line for the suggestion.</span>
<span class="gi">+        text = document.text.rsplit(&quot;\n&quot;, 1)[-1]</span>
<span class="gi">+</span>
<span class="gi">+        # Only create a suggestion when this is not an empty line.</span>
<span class="gi">+        if text.strip():</span>
<span class="gi">+            # Find first matching line in history.</span>
<span class="gi">+            for string in reversed(list(history.get_strings())):</span>
<span class="gi">+                for line in reversed(string.splitlines()):</span>
<span class="gi">+                    if line.startswith(text):</span>
<span class="gi">+                        return Suggestion(line[len(text) :])</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class ConditionalAutoSuggest(AutoSuggest):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Auto suggest that can be turned on and of according to a certain condition.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, auto_suggest: AutoSuggest, filter: (bool | Filter)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, auto_suggest: AutoSuggest, filter: bool | Filter) -&gt; None:</span>
<span class="w"> </span>        self.auto_suggest = auto_suggest
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.auto_suggest.get_suggestion(buffer, document)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicAutoSuggest(AutoSuggest):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -120,6 +162,15 @@ class DynamicAutoSuggest(AutoSuggest):</span>
<span class="w"> </span>    :param get_validator: Callable that returns a :class:`.Validator` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_auto_suggest: Callable[[], AutoSuggest | None]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_auto_suggest: Callable[[], AutoSuggest | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_auto_suggest = get_auto_suggest
<span class="gi">+</span>
<span class="gi">+    def get_suggestion(self, buff: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        auto_suggest = self.get_auto_suggest() or DummyAutoSuggest()</span>
<span class="gi">+        return auto_suggest.get_suggestion(buff, document)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_suggestion_async(</span>
<span class="gi">+        self, buff: Buffer, document: Document</span>
<span class="gi">+    ) -&gt; Suggestion | None:</span>
<span class="gi">+        auto_suggest = self.get_auto_suggest() or DummyAutoSuggest()</span>
<span class="gi">+        return await auto_suggest.get_suggestion_async(buff, document)</span>
<span class="gh">diff --git a/src/prompt_toolkit/buffer.py b/src/prompt_toolkit/buffer.py</span>
<span class="gh">index b2382429..100ca78d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/buffer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/buffer.py</span>
<span class="gu">@@ -3,6 +3,7 @@ Data structures for the Buffer.</span>
<span class="w"> </span>It holds the text, cursor position, history, etc...
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="gu">@@ -15,12 +16,19 @@ from collections import deque</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from typing import Any, Callable, Coroutine, Iterable, TypeVar, cast
<span class="gi">+</span>
<span class="w"> </span>from .application.current import get_app
<span class="w"> </span>from .application.run_in_terminal import run_in_terminal
<span class="w"> </span>from .auto_suggest import AutoSuggest, Suggestion
<span class="w"> </span>from .cache import FastDictCache
<span class="w"> </span>from .clipboard import ClipboardData
<span class="gd">-from .completion import CompleteEvent, Completer, Completion, DummyCompleter, get_common_complete_suffix</span>
<span class="gi">+from .completion import (</span>
<span class="gi">+    CompleteEvent,</span>
<span class="gi">+    Completer,</span>
<span class="gi">+    Completion,</span>
<span class="gi">+    DummyCompleter,</span>
<span class="gi">+    get_common_complete_suffix,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .document import Document
<span class="w"> </span>from .eventloop import aclosing
<span class="w"> </span>from .filters import FilterOrBool, to_filter
<span class="gu">@@ -29,20 +37,29 @@ from .search import SearchDirection, SearchState</span>
<span class="w"> </span>from .selection import PasteMode, SelectionState, SelectionType
<span class="w"> </span>from .utils import Event, to_str
<span class="w"> </span>from .validation import ValidationError, Validator
<span class="gd">-__all__ = [&#39;EditReadOnlyBuffer&#39;, &#39;Buffer&#39;, &#39;CompletionState&#39;, &#39;indent&#39;,</span>
<span class="gd">-    &#39;unindent&#39;, &#39;reshape_text&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;EditReadOnlyBuffer&quot;,</span>
<span class="gi">+    &quot;Buffer&quot;,</span>
<span class="gi">+    &quot;CompletionState&quot;,</span>
<span class="gi">+    &quot;indent&quot;,</span>
<span class="gi">+    &quot;unindent&quot;,</span>
<span class="gi">+    &quot;reshape_text&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class EditReadOnlyBuffer(Exception):
<span class="gd">-    &quot;&quot;&quot;Attempt editing of read-only :class:`.Buffer`.&quot;&quot;&quot;</span>
<span class="gi">+    &quot;Attempt editing of read-only :class:`.Buffer`.&quot;</span>


<span class="w"> </span>class ValidationState(Enum):
<span class="gd">-    &quot;&quot;&quot;The validation state of a buffer. This is set after the validation.&quot;&quot;&quot;</span>
<span class="gd">-    VALID = &#39;VALID&#39;</span>
<span class="gd">-    INVALID = &#39;INVALID&#39;</span>
<span class="gd">-    UNKNOWN = &#39;UNKNOWN&#39;</span>
<span class="gi">+    &quot;The validation state of a buffer. This is set after the validation.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    VALID = &quot;VALID&quot;</span>
<span class="gi">+    INVALID = &quot;INVALID&quot;</span>
<span class="gi">+    UNKNOWN = &quot;UNKNOWN&quot;</span>


<span class="w"> </span>class CompletionState:
<span class="gu">@@ -50,41 +67,73 @@ class CompletionState:</span>
<span class="w"> </span>    Immutable class that contains a completion state.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, original_document: Document, completions: (list[</span>
<span class="gd">-        Completion] | None)=None, complete_index: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        original_document: Document,</span>
<span class="gi">+        completions: list[Completion] | None = None,</span>
<span class="gi">+        complete_index: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        #: Document as it was when the completion started.</span>
<span class="w"> </span>        self.original_document = original_document
<span class="gi">+</span>
<span class="gi">+        #: List of all the current Completion instances which are possible at</span>
<span class="gi">+        #: this point.</span>
<span class="w"> </span>        self.completions = completions or []
<span class="gd">-        self.complete_index = complete_index</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}({!r}, &lt;{!r}&gt; completions, index={!r})&#39;.format(self.</span>
<span class="gd">-            __class__.__name__, self.original_document, len(self.</span>
<span class="gd">-            completions), self.complete_index)</span>
<span class="gi">+        #: Position in the `completions` array.</span>
<span class="gi">+        #: This can be `None` to indicate &quot;no completion&quot;, the original text.</span>
<span class="gi">+        self.complete_index = complete_index  # Position in the `_completions` array.</span>

<span class="gd">-    def go_to_index(self, index: (int | None)) -&gt;None:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}({!r}, &lt;{!r}&gt; completions, index={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.original_document,</span>
<span class="gi">+            len(self.completions),</span>
<span class="gi">+            self.complete_index,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def go_to_index(self, index: int | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new :class:`.CompletionState` object with the new index.

<span class="w"> </span>        When `index` is `None` deselect the completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.completions:</span>
<span class="gi">+            assert index is None or 0 &lt;= index &lt; len(self.completions)</span>
<span class="gi">+            self.complete_index = index</span>

<span class="gd">-    def new_text_and_position(self) -&gt;tuple[str, int]:</span>
<span class="gi">+    def new_text_and_position(self) -&gt; tuple[str, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return (new_text, new_cursor_position) for this completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.complete_index is None:</span>
<span class="gi">+            return self.original_document.text, self.original_document.cursor_position</span>
<span class="gi">+        else:</span>
<span class="gi">+            original_text_before_cursor = self.original_document.text_before_cursor</span>
<span class="gi">+            original_text_after_cursor = self.original_document.text_after_cursor</span>
<span class="gi">+</span>
<span class="gi">+            c = self.completions[self.complete_index]</span>
<span class="gi">+            if c.start_position == 0:</span>
<span class="gi">+                before = original_text_before_cursor</span>
<span class="gi">+            else:</span>
<span class="gi">+                before = original_text_before_cursor[: c.start_position]</span>
<span class="gi">+</span>
<span class="gi">+            new_text = before + c.text + original_text_after_cursor</span>
<span class="gi">+            new_cursor_position = len(before) + len(c.text)</span>
<span class="gi">+            return new_text, new_cursor_position</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_completion(self) -&gt;(Completion | None):</span>
<span class="gi">+    def current_completion(self) -&gt; Completion | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the current completion, or return `None` when no completion is
<span class="w"> </span>        selected.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.complete_index is not None:</span>
<span class="gi">+            return self.completions[self.complete_index]</span>
<span class="gi">+        return None</span>


<span class="gd">-_QUOTED_WORDS_RE = re.compile(&#39;(\\s+|&quot;.*?&quot;|\&#39;.*?\&#39;)&#39;)</span>
<span class="gi">+_QUOTED_WORDS_RE = re.compile(r&quot;&quot;&quot;(\s+|&quot;.*?&quot;|&#39;.*?&#39;)&quot;&quot;&quot;)</span>


<span class="w"> </span>class YankNthArgState:
<span class="gu">@@ -92,21 +141,24 @@ class YankNthArgState:</span>
<span class="w"> </span>    For yank-last-arg/yank-nth-arg: Keep track of where we are in the history.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, history_position: int=0, n: int=-1,</span>
<span class="gd">-        previous_inserted_word: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, history_position: int = 0, n: int = -1, previous_inserted_word: str = &quot;&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.history_position = history_position
<span class="w"> </span>        self.previous_inserted_word = previous_inserted_word
<span class="w"> </span>        self.n = n

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            &#39;{}(history_position={!r}, n={!r}, previous_inserted_word={!r})&#39;</span>
<span class="gd">-            .format(self.__class__.__name__, self.history_position, self.n,</span>
<span class="gd">-            self.previous_inserted_word))</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(history_position={!r}, n={!r}, previous_inserted_word={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.history_position,</span>
<span class="gi">+            self.n,</span>
<span class="gi">+            self.previous_inserted_word,</span>
<span class="gi">+        )</span>


<span class="gd">-BufferEventHandler = Callable[[&#39;Buffer&#39;], None]</span>
<span class="gd">-BufferAcceptHandler = Callable[[&#39;Buffer&#39;], bool]</span>
<span class="gi">+BufferEventHandler = Callable[[&quot;Buffer&quot;], None]</span>
<span class="gi">+BufferAcceptHandler = Callable[[&quot;Buffer&quot;], bool]</span>


<span class="w"> </span>class Buffer:
<span class="gu">@@ -166,24 +218,35 @@ class Buffer:</span>
<span class="w"> </span>        pressing `Esc-Enter` is required.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, completer: (Completer | None)=None, auto_suggest: (</span>
<span class="gd">-        AutoSuggest | None)=None, history: (History | None)=None, validator:</span>
<span class="gd">-        (Validator | None)=None, tempfile_suffix: (str | Callable[[], str])</span>
<span class="gd">-        =&#39;&#39;, tempfile: (str | Callable[[], str])=&#39;&#39;, name: str=&#39;&#39;,</span>
<span class="gd">-        complete_while_typing: FilterOrBool=False, validate_while_typing:</span>
<span class="gd">-        FilterOrBool=False, enable_history_search: FilterOrBool=False,</span>
<span class="gd">-        document: (Document | None)=None, accept_handler: (</span>
<span class="gd">-        BufferAcceptHandler | None)=None, read_only: FilterOrBool=False,</span>
<span class="gd">-        multiline: FilterOrBool=True, on_text_changed: (BufferEventHandler |</span>
<span class="gd">-        None)=None, on_text_insert: (BufferEventHandler | None)=None,</span>
<span class="gd">-        on_cursor_position_changed: (BufferEventHandler | None)=None,</span>
<span class="gd">-        on_completions_changed: (BufferEventHandler | None)=None,</span>
<span class="gd">-        on_suggestion_set: (BufferEventHandler | None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        completer: Completer | None = None,</span>
<span class="gi">+        auto_suggest: AutoSuggest | None = None,</span>
<span class="gi">+        history: History | None = None,</span>
<span class="gi">+        validator: Validator | None = None,</span>
<span class="gi">+        tempfile_suffix: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+        tempfile: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+        name: str = &quot;&quot;,</span>
<span class="gi">+        complete_while_typing: FilterOrBool = False,</span>
<span class="gi">+        validate_while_typing: FilterOrBool = False,</span>
<span class="gi">+        enable_history_search: FilterOrBool = False,</span>
<span class="gi">+        document: Document | None = None,</span>
<span class="gi">+        accept_handler: BufferAcceptHandler | None = None,</span>
<span class="gi">+        read_only: FilterOrBool = False,</span>
<span class="gi">+        multiline: FilterOrBool = True,</span>
<span class="gi">+        on_text_changed: BufferEventHandler | None = None,</span>
<span class="gi">+        on_text_insert: BufferEventHandler | None = None,</span>
<span class="gi">+        on_cursor_position_changed: BufferEventHandler | None = None,</span>
<span class="gi">+        on_completions_changed: BufferEventHandler | None = None,</span>
<span class="gi">+        on_suggestion_set: BufferEventHandler | None = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Accept both filters and booleans as input.</span>
<span class="w"> </span>        enable_history_search = to_filter(enable_history_search)
<span class="w"> </span>        complete_while_typing = to_filter(complete_while_typing)
<span class="w"> </span>        validate_while_typing = to_filter(validate_while_typing)
<span class="w"> </span>        read_only = to_filter(read_only)
<span class="w"> </span>        multiline = to_filter(multiline)
<span class="gi">+</span>
<span class="w"> </span>        self.completer = completer or DummyCompleter()
<span class="w"> </span>        self.auto_suggest = auto_suggest
<span class="w"> </span>        self.validator = validator
<span class="gu">@@ -191,44 +254,123 @@ class Buffer:</span>
<span class="w"> </span>        self.tempfile = tempfile
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.accept_handler = accept_handler
<span class="gi">+</span>
<span class="gi">+        # Filters. (Usually, used by the key bindings to drive the buffer.)</span>
<span class="w"> </span>        self.complete_while_typing = complete_while_typing
<span class="w"> </span>        self.validate_while_typing = validate_while_typing
<span class="w"> </span>        self.enable_history_search = enable_history_search
<span class="w"> </span>        self.read_only = read_only
<span class="w"> </span>        self.multiline = multiline
<span class="gi">+</span>
<span class="gi">+        # Text width. (For wrapping, used by the Vi &#39;gq&#39; operator.)</span>
<span class="w"> </span>        self.text_width = 0
<span class="gi">+</span>
<span class="gi">+        #: The command buffer history.</span>
<span class="gi">+        # Note that we shouldn&#39;t use a lazy &#39;or&#39; here. bool(history) could be</span>
<span class="gi">+        # False when empty.</span>
<span class="w"> </span>        self.history = InMemoryHistory() if history is None else history
<span class="gi">+</span>
<span class="w"> </span>        self.__cursor_position = 0
<span class="gi">+</span>
<span class="gi">+        # Events</span>
<span class="w"> </span>        self.on_text_changed: Event[Buffer] = Event(self, on_text_changed)
<span class="w"> </span>        self.on_text_insert: Event[Buffer] = Event(self, on_text_insert)
<span class="gd">-        self.on_cursor_position_changed: Event[Buffer] = Event(self,</span>
<span class="gd">-            on_cursor_position_changed)</span>
<span class="gd">-        self.on_completions_changed: Event[Buffer] = Event(self,</span>
<span class="gd">-            on_completions_changed)</span>
<span class="gi">+        self.on_cursor_position_changed: Event[Buffer] = Event(</span>
<span class="gi">+            self, on_cursor_position_changed</span>
<span class="gi">+        )</span>
<span class="gi">+        self.on_completions_changed: Event[Buffer] = Event(self, on_completions_changed)</span>
<span class="w"> </span>        self.on_suggestion_set: Event[Buffer] = Event(self, on_suggestion_set)
<span class="gd">-        self._document_cache: FastDictCache[tuple[str, int, SelectionState |</span>
<span class="gd">-            None], Document] = FastDictCache(Document, size=10)</span>
<span class="gi">+</span>
<span class="gi">+        # Document cache. (Avoid creating new Document instances.)</span>
<span class="gi">+        self._document_cache: FastDictCache[</span>
<span class="gi">+            tuple[str, int, SelectionState | None], Document</span>
<span class="gi">+        ] = FastDictCache(Document, size=10)</span>
<span class="gi">+</span>
<span class="gi">+        # Create completer / auto suggestion / validation coroutines.</span>
<span class="w"> </span>        self._async_suggester = self._create_auto_suggest_coroutine()
<span class="w"> </span>        self._async_completer = self._create_completer_coroutine()
<span class="w"> </span>        self._async_validator = self._create_auto_validate_coroutine()
<span class="gi">+</span>
<span class="gi">+        # Asyncio task for populating the history.</span>
<span class="w"> </span>        self._load_history_task: asyncio.Future[None] | None = None
<span class="gi">+</span>
<span class="gi">+        # Reset other attributes.</span>
<span class="w"> </span>        self.reset(document=document)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if len(self.text) &lt; 15:
<span class="w"> </span>            text = self.text
<span class="w"> </span>        else:
<span class="gd">-            text = self.text[:12] + &#39;...&#39;</span>
<span class="gd">-        return f&#39;&lt;Buffer(name={self.name!r}, text={text!r}) at {id(self)!r}&gt;&#39;</span>
<span class="gi">+            text = self.text[:12] + &quot;...&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;&lt;Buffer(name={self.name!r}, text={text!r}) at {id(self)!r}&gt;&quot;</span>

<span class="gd">-    def reset(self, document: (Document | None)=None, append_to_history:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+    def reset(</span>
<span class="gi">+        self, document: Document | None = None, append_to_history: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param append_to_history: Append current input to history first.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if append_to_history:</span>
<span class="gi">+            self.append_to_history()</span>
<span class="gi">+</span>
<span class="gi">+        document = document or Document()</span>
<span class="gi">+</span>
<span class="gi">+        self.__cursor_position = document.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+        # `ValidationError` instance. (Will be set when the input is wrong.)</span>
<span class="gi">+        self.validation_error: ValidationError | None = None</span>
<span class="gi">+        self.validation_state: ValidationState | None = ValidationState.UNKNOWN</span>

<span class="gd">-    def load_history_if_not_yet_loaded(self) -&gt;None:</span>
<span class="gi">+        # State of the selection.</span>
<span class="gi">+        self.selection_state: SelectionState | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # Multiple cursor mode. (When we press &#39;I&#39; or &#39;A&#39; in visual-block mode,</span>
<span class="gi">+        # we can insert text on multiple lines at once. This is implemented by</span>
<span class="gi">+        # using multiple cursors.)</span>
<span class="gi">+        self.multiple_cursor_positions: list[int] = []</span>
<span class="gi">+</span>
<span class="gi">+        # When doing consecutive up/down movements, prefer to stay at this column.</span>
<span class="gi">+        self.preferred_column: int | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # State of complete browser</span>
<span class="gi">+        # For interactive completion through Ctrl-N/Ctrl-P.</span>
<span class="gi">+        self.complete_state: CompletionState | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # State of Emacs yank-nth-arg completion.</span>
<span class="gi">+        self.yank_nth_arg_state: YankNthArgState | None = None  # for yank-nth-arg.</span>
<span class="gi">+</span>
<span class="gi">+        # Remember the document that we had *right before* the last paste</span>
<span class="gi">+        # operation. This is used for rotating through the kill ring.</span>
<span class="gi">+        self.document_before_paste: Document | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # Current suggestion.</span>
<span class="gi">+        self.suggestion: Suggestion | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # The history search text. (Used for filtering the history when we</span>
<span class="gi">+        # browse through it.)</span>
<span class="gi">+        self.history_search_text: str | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # Undo/redo stacks (stack of `(text, cursor_position)`).</span>
<span class="gi">+        self._undo_stack: list[tuple[str, int]] = []</span>
<span class="gi">+        self._redo_stack: list[tuple[str, int]] = []</span>
<span class="gi">+</span>
<span class="gi">+        # Cancel history loader. If history loading was still ongoing.</span>
<span class="gi">+        # Cancel the `_load_history_task`, so that next repaint of the</span>
<span class="gi">+        # `BufferControl` we will repopulate it.</span>
<span class="gi">+        if self._load_history_task is not None:</span>
<span class="gi">+            self._load_history_task.cancel()</span>
<span class="gi">+        self._load_history_task = None</span>
<span class="gi">+</span>
<span class="gi">+        #: The working lines. Similar to history, except that this can be</span>
<span class="gi">+        #: modified. The user can press arrow_up and edit previous entries.</span>
<span class="gi">+        #: Ctrl-C should reset this, and copy the whole history back in here.</span>
<span class="gi">+        #: Enter should process the current command and append to the real</span>
<span class="gi">+        #: history.</span>
<span class="gi">+        self._working_lines: deque[str] = deque([document.text])</span>
<span class="gi">+        self.__working_index = 0</span>
<span class="gi">+</span>
<span class="gi">+    def load_history_if_not_yet_loaded(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create task for populating the buffer history (if not yet done).

<span class="gu">@@ -249,52 +391,192 @@ class Buffer:</span>
<span class="w"> </span>            thread, but history loading is the only place where it matters, and
<span class="w"> </span>            this solves it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _set_text(self, value: str) -&gt;bool:</span>
<span class="gi">+        if self._load_history_task is None:</span>
<span class="gi">+</span>
<span class="gi">+            async def load_history() -&gt; None:</span>
<span class="gi">+                async for item in self.history.load():</span>
<span class="gi">+                    self._working_lines.appendleft(item)</span>
<span class="gi">+                    self.__working_index += 1</span>
<span class="gi">+</span>
<span class="gi">+            self._load_history_task = get_app().create_background_task(load_history())</span>
<span class="gi">+</span>
<span class="gi">+            def load_history_done(f: asyncio.Future[None]) -&gt; None:</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                Handle `load_history` result when either done, cancelled, or</span>
<span class="gi">+                when an exception was raised.</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                try:</span>
<span class="gi">+                    f.result()</span>
<span class="gi">+                except asyncio.CancelledError:</span>
<span class="gi">+                    # Ignore cancellation. But handle it, so that we don&#39;t get</span>
<span class="gi">+                    # this traceback.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                except GeneratorExit:</span>
<span class="gi">+                    # Probably not needed, but we had situations where</span>
<span class="gi">+                    # `GeneratorExit` was raised in `load_history` during</span>
<span class="gi">+                    # cancellation.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                except BaseException:</span>
<span class="gi">+                    # Log error if something goes wrong. (We don&#39;t have a</span>
<span class="gi">+                    # caller to which we can propagate this exception.)</span>
<span class="gi">+                    logger.exception(&quot;Loading history failed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self._load_history_task.add_done_callback(load_history_done)</span>
<span class="gi">+</span>
<span class="gi">+    # &lt;getters/setters&gt;</span>
<span class="gi">+</span>
<span class="gi">+    def _set_text(self, value: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;set text at current working_index. Return whether it changed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _set_cursor_position(self, value: int) -&gt;bool:</span>
<span class="gi">+        working_index = self.working_index</span>
<span class="gi">+        working_lines = self._working_lines</span>
<span class="gi">+</span>
<span class="gi">+        original_value = working_lines[working_index]</span>
<span class="gi">+        working_lines[working_index] = value</span>
<span class="gi">+</span>
<span class="gi">+        # Return True when this text has been changed.</span>
<span class="gi">+        if len(value) != len(original_value):</span>
<span class="gi">+            # For Python 2, it seems that when two strings have a different</span>
<span class="gi">+            # length and one is a prefix of the other, Python still scans</span>
<span class="gi">+            # character by character to see whether the strings are different.</span>
<span class="gi">+            # (Some benchmarking showed significant differences for big</span>
<span class="gi">+            # documents. &gt;100,000 of lines.)</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif value != original_value:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _set_cursor_position(self, value: int) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set cursor position. Return whether it changed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_position = self.__cursor_position</span>
<span class="gi">+        self.__cursor_position = max(0, value)</span>
<span class="gi">+</span>
<span class="gi">+        return self.__cursor_position != original_position</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def text(self) -&gt; str:</span>
<span class="gi">+        return self._working_lines[self.working_index]</span>

<span class="w"> </span>    @text.setter
<span class="gd">-    def text(self, value: str) -&gt;None:</span>
<span class="gi">+    def text(self, value: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Setting text. (When doing this, make sure that the cursor_position is
<span class="w"> </span>        valid for this text. text/cursor_position should be consistent at any time,
<span class="w"> </span>        otherwise set a Document instead.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Ensure cursor position remains within the size of the text.</span>
<span class="gi">+        if self.cursor_position &gt; len(value):</span>
<span class="gi">+            self.cursor_position = len(value)</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t allow editing of read-only buffers.</span>
<span class="gi">+        if self.read_only():</span>
<span class="gi">+            raise EditReadOnlyBuffer()</span>
<span class="gi">+</span>
<span class="gi">+        changed = self._set_text(value)</span>
<span class="gi">+</span>
<span class="gi">+        if changed:</span>
<span class="gi">+            self._text_changed()</span>
<span class="gi">+</span>
<span class="gi">+            # Reset history search text.</span>
<span class="gi">+            # (Note that this doesn&#39;t need to happen when working_index</span>
<span class="gi">+            #  changes, which is when we traverse the history. That&#39;s why we</span>
<span class="gi">+            #  don&#39;t do this in `self._text_changed`.)</span>
<span class="gi">+            self.history_search_text = None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def cursor_position(self) -&gt; int:</span>
<span class="gi">+        return self.__cursor_position</span>

<span class="w"> </span>    @cursor_position.setter
<span class="gd">-    def cursor_position(self, value: int) -&gt;None:</span>
<span class="gi">+    def cursor_position(self, value: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Setting cursor position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(value, int)</span>
<span class="gi">+</span>
<span class="gi">+        # Ensure cursor position is within the size of the text.</span>
<span class="gi">+        if value &gt; len(self.text):</span>
<span class="gi">+            value = len(self.text)</span>
<span class="gi">+        if value &lt; 0:</span>
<span class="gi">+            value = 0</span>
<span class="gi">+</span>
<span class="gi">+        changed = self._set_cursor_position(value)</span>
<span class="gi">+</span>
<span class="gi">+        if changed:</span>
<span class="gi">+            self._cursor_position_changed()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def working_index(self) -&gt; int:</span>
<span class="gi">+        return self.__working_index</span>
<span class="gi">+</span>
<span class="gi">+    @working_index.setter</span>
<span class="gi">+    def working_index(self, value: int) -&gt; None:</span>
<span class="gi">+        if self.__working_index != value:</span>
<span class="gi">+            self.__working_index = value</span>
<span class="gi">+            # Make sure to reset the cursor position, otherwise we end up in</span>
<span class="gi">+            # situations where the cursor position is out of the bounds of the</span>
<span class="gi">+            # text.</span>
<span class="gi">+            self.cursor_position = 0</span>
<span class="gi">+            self._text_changed()</span>
<span class="gi">+</span>
<span class="gi">+    def _text_changed(self) -&gt; None:</span>
<span class="gi">+        # Remove any validation errors and complete state.</span>
<span class="gi">+        self.validation_error = None</span>
<span class="gi">+        self.validation_state = ValidationState.UNKNOWN</span>
<span class="gi">+        self.complete_state = None</span>
<span class="gi">+        self.yank_nth_arg_state = None</span>
<span class="gi">+        self.document_before_paste = None</span>
<span class="gi">+        self.selection_state = None</span>
<span class="gi">+        self.suggestion = None</span>
<span class="gi">+        self.preferred_column = None</span>
<span class="gi">+</span>
<span class="gi">+        # fire &#39;on_text_changed&#39; event.</span>
<span class="gi">+        self.on_text_changed.fire()</span>
<span class="gi">+</span>
<span class="gi">+        # Input validation.</span>
<span class="gi">+        # (This happens on all change events, unlike auto completion, also when</span>
<span class="gi">+        # deleting text.)</span>
<span class="gi">+        if self.validator and self.validate_while_typing():</span>
<span class="gi">+            get_app().create_background_task(self._async_validator())</span>
<span class="gi">+</span>
<span class="gi">+    def _cursor_position_changed(self) -&gt; None:</span>
<span class="gi">+        # Remove any complete state.</span>
<span class="gi">+        # (Input validation should only be undone when the cursor position</span>
<span class="gi">+        # changes.)</span>
<span class="gi">+        self.complete_state = None</span>
<span class="gi">+        self.yank_nth_arg_state = None</span>
<span class="gi">+        self.document_before_paste = None</span>
<span class="gi">+</span>
<span class="gi">+        # Unset preferred_column. (Will be set after the cursor movement, if</span>
<span class="gi">+        # required.)</span>
<span class="gi">+        self.preferred_column = None</span>
<span class="gi">+</span>
<span class="gi">+        # Note that the cursor position can change if we have a selection the</span>
<span class="gi">+        # new position of the cursor determines the end of the selection.</span>
<span class="gi">+</span>
<span class="gi">+        # fire &#39;on_cursor_position_changed&#39; event.</span>
<span class="gi">+        self.on_cursor_position_changed.fire()</span>

<span class="w"> </span>    @property
<span class="gd">-    def document(self) -&gt;Document:</span>
<span class="gi">+    def document(self) -&gt; Document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return :class:`~prompt_toolkit.document.Document` instance from the
<span class="w"> </span>        current text, cursor position and selection state.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._document_cache[</span>
<span class="gi">+            self.text, self.cursor_position, self.selection_state</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    @document.setter
<span class="gd">-    def document(self, value: Document) -&gt;None:</span>
<span class="gi">+    def document(self, value: Document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set :class:`~prompt_toolkit.document.Document` instance.

<span class="w"> </span>        This will set both the text and cursor position at the same time, but
<span class="w"> </span>        atomically. (Change events will be triggered only after both have been set.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_document(value)</span>

<span class="gd">-    def set_document(self, value: Document, bypass_readonly: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def set_document(self, value: Document, bypass_readonly: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set :class:`~prompt_toolkit.document.Document` instance. Like the
<span class="w"> </span>        ``document`` property, but accept an ``bypass_readonly`` argument.
<span class="gu">@@ -312,24 +594,53 @@ class Buffer:</span>
<span class="w"> </span>            you expect, and there won&#39;t be a stack trace. Use try/finally
<span class="w"> </span>            around this function if you need some cleanup code.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Don&#39;t allow editing of read-only buffers.</span>
<span class="gi">+        if not bypass_readonly and self.read_only():</span>
<span class="gi">+            raise EditReadOnlyBuffer()</span>
<span class="gi">+</span>
<span class="gi">+        # Set text and cursor position first.</span>
<span class="gi">+        text_changed = self._set_text(value.text)</span>
<span class="gi">+        cursor_position_changed = self._set_cursor_position(value.cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+        # Now handle change events. (We do this when text/cursor position is</span>
<span class="gi">+        # both set and consistent.)</span>
<span class="gi">+        if text_changed:</span>
<span class="gi">+            self._text_changed()</span>
<span class="gi">+            self.history_search_text = None</span>
<span class="gi">+</span>
<span class="gi">+        if cursor_position_changed:</span>
<span class="gi">+            self._cursor_position_changed()</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_returnable(self) -&gt;bool:</span>
<span class="gi">+    def is_returnable(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when there is something handling accept.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self.accept_handler)</span>

<span class="gd">-    def save_to_undo_stack(self, clear_redo_stack: bool=True) -&gt;None:</span>
<span class="gi">+    # End of &lt;getters/setters&gt;</span>
<span class="gi">+</span>
<span class="gi">+    def save_to_undo_stack(self, clear_redo_stack: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Safe current state (input text and cursor position), so that we can
<span class="w"> </span>        restore it by calling undo.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Safe if the text is different from the text at the top of the stack</span>
<span class="gi">+        # is different. If the text is the same, just update the cursor position.</span>
<span class="gi">+        if self._undo_stack and self._undo_stack[-1][0] == self.text:</span>
<span class="gi">+            self._undo_stack[-1] = (self._undo_stack[-1][0], self.cursor_position)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._undo_stack.append((self.text, self.cursor_position))</span>
<span class="gi">+</span>
<span class="gi">+        # Saving anything to the undo stack, clears the redo stack.</span>
<span class="gi">+        if clear_redo_stack:</span>
<span class="gi">+            self._redo_stack = []</span>

<span class="gd">-    def transform_lines(self, line_index_iterator: Iterable[int],</span>
<span class="gd">-        transform_callback: Callable[[str], str]) -&gt;str:</span>
<span class="gi">+    def transform_lines(</span>
<span class="gi">+        self,</span>
<span class="gi">+        line_index_iterator: Iterable[int],</span>
<span class="gi">+        transform_callback: Callable[[str], str],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Transforms the text on a range of lines.
<span class="w"> </span>        When the iterator yield an index not in the range of lines that the
<span class="gu">@@ -345,19 +656,36 @@ class Buffer:</span>

<span class="w"> </span>        :returns: The new text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Split lines</span>
<span class="gi">+        lines = self.text.split(&quot;\n&quot;)</span>

<span class="gd">-    def transform_current_line(self, transform_callback: Callable[[str], str]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # Apply transformation</span>
<span class="gi">+        for index in line_index_iterator:</span>
<span class="gi">+            try:</span>
<span class="gi">+                lines[index] = transform_callback(lines[index])</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;\n&quot;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+    def transform_current_line(self, transform_callback: Callable[[str], str]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Apply the given transformation function to the current line.

<span class="w"> </span>        :param transform_callback: callable that takes a string and return a new string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        document = self.document</span>
<span class="gi">+        a = document.cursor_position + document.get_start_of_line_position()</span>
<span class="gi">+        b = document.cursor_position + document.get_end_of_line_position()</span>
<span class="gi">+        self.text = (</span>
<span class="gi">+            document.text[:a]</span>
<span class="gi">+            + transform_callback(document.text[a:b])</span>
<span class="gi">+            + document.text[b:]</span>
<span class="gi">+        )</span>

<span class="gd">-    def transform_region(self, from_: int, to: int, transform_callback:</span>
<span class="gd">-        Callable[[str], str]) -&gt;None:</span>
<span class="gi">+    def transform_region(</span>
<span class="gi">+        self, from_: int, to: int, transform_callback: Callable[[str], str]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Transform a part of the input string.

<span class="gu">@@ -366,150 +694,374 @@ class Buffer:</span>
<span class="w"> </span>        :param transform_callback: Callable which accepts a string and returns
<span class="w"> </span>            the transformed string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert from_ &lt; to</span>
<span class="gi">+</span>
<span class="gi">+        self.text = &quot;&quot;.join(</span>
<span class="gi">+            [</span>
<span class="gi">+                self.text[:from_]</span>
<span class="gi">+                + transform_callback(self.text[from_:to])</span>
<span class="gi">+                + self.text[to:]</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>

<span class="gd">-    def cursor_up(self, count: int=1) -&gt;None:</span>
<span class="gi">+    def cursor_left(self, count: int = 1) -&gt; None:</span>
<span class="gi">+        self.cursor_position += self.document.get_cursor_left_position(count=count)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_right(self, count: int = 1) -&gt; None:</span>
<span class="gi">+        self.cursor_position += self.document.get_cursor_right_position(count=count)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_up(self, count: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;(for multiline edit). Move cursor to the previous line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_column = self.preferred_column or self.document.cursor_position_col</span>
<span class="gi">+        self.cursor_position += self.document.get_cursor_up_position(</span>
<span class="gi">+            count=count, preferred_column=original_column</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Remember the original column for the next up/down movement.</span>
<span class="gi">+        self.preferred_column = original_column</span>

<span class="gd">-    def cursor_down(self, count: int=1) -&gt;None:</span>
<span class="gi">+    def cursor_down(self, count: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;(for multiline edit). Move cursor to the next line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_column = self.preferred_column or self.document.cursor_position_col</span>
<span class="gi">+        self.cursor_position += self.document.get_cursor_down_position(</span>
<span class="gi">+            count=count, preferred_column=original_column</span>
<span class="gi">+        )</span>

<span class="gd">-    def auto_up(self, count: int=1, go_to_start_of_line_if_history_changes:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+        # Remember the original column for the next up/down movement.</span>
<span class="gi">+        self.preferred_column = original_column</span>
<span class="gi">+</span>
<span class="gi">+    def auto_up(</span>
<span class="gi">+        self, count: int = 1, go_to_start_of_line_if_history_changes: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If we&#39;re not on the first line (of a multiline input) go a line up,
<span class="w"> </span>        otherwise go back in history. (If nothing is selected.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.complete_state:</span>
<span class="gi">+            self.complete_previous(count=count)</span>
<span class="gi">+        elif self.document.cursor_position_row &gt; 0:</span>
<span class="gi">+            self.cursor_up(count=count)</span>
<span class="gi">+        elif not self.selection_state:</span>
<span class="gi">+            self.history_backward(count=count)</span>
<span class="gi">+</span>
<span class="gi">+            # Go to the start of the line?</span>
<span class="gi">+            if go_to_start_of_line_if_history_changes:</span>
<span class="gi">+                self.cursor_position += self.document.get_start_of_line_position()</span>

<span class="gd">-    def auto_down(self, count: int=1,</span>
<span class="gd">-        go_to_start_of_line_if_history_changes: bool=False) -&gt;None:</span>
<span class="gi">+    def auto_down(</span>
<span class="gi">+        self, count: int = 1, go_to_start_of_line_if_history_changes: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If we&#39;re not on the last line (of a multiline input) go a line down,
<span class="w"> </span>        otherwise go forward in history. (If nothing is selected.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.complete_state:</span>
<span class="gi">+            self.complete_next(count=count)</span>
<span class="gi">+        elif self.document.cursor_position_row &lt; self.document.line_count - 1:</span>
<span class="gi">+            self.cursor_down(count=count)</span>
<span class="gi">+        elif not self.selection_state:</span>
<span class="gi">+            self.history_forward(count=count)</span>
<span class="gi">+</span>
<span class="gi">+            # Go to the start of the line?</span>
<span class="gi">+            if go_to_start_of_line_if_history_changes:</span>
<span class="gi">+                self.cursor_position += self.document.get_start_of_line_position()</span>

<span class="gd">-    def delete_before_cursor(self, count: int=1) -&gt;str:</span>
<span class="gi">+    def delete_before_cursor(self, count: int = 1) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Delete specified number of characters before cursor and return the
<span class="w"> </span>        deleted text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert count &gt;= 0</span>
<span class="gi">+        deleted = &quot;&quot;</span>

<span class="gd">-    def delete(self, count: int=1) -&gt;str:</span>
<span class="gi">+        if self.cursor_position &gt; 0:</span>
<span class="gi">+            deleted = self.text[self.cursor_position - count : self.cursor_position]</span>
<span class="gi">+</span>
<span class="gi">+            new_text = (</span>
<span class="gi">+                self.text[: self.cursor_position - count]</span>
<span class="gi">+                + self.text[self.cursor_position :]</span>
<span class="gi">+            )</span>
<span class="gi">+            new_cursor_position = self.cursor_position - len(deleted)</span>
<span class="gi">+</span>
<span class="gi">+            # Set new Document atomically.</span>
<span class="gi">+            self.document = Document(new_text, new_cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+        return deleted</span>
<span class="gi">+</span>
<span class="gi">+    def delete(self, count: int = 1) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Delete specified number of characters and Return the deleted text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.cursor_position &lt; len(self.text):</span>
<span class="gi">+            deleted = self.document.text_after_cursor[:count]</span>
<span class="gi">+            self.text = (</span>
<span class="gi">+                self.text[: self.cursor_position]</span>
<span class="gi">+                + self.text[self.cursor_position + len(deleted) :]</span>
<span class="gi">+            )</span>
<span class="gi">+            return deleted</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;&quot;</span>

<span class="gd">-    def join_next_line(self, separator: str=&#39; &#39;) -&gt;None:</span>
<span class="gi">+    def join_next_line(self, separator: str = &quot; &quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Join the next line to the current one by deleting the line ending after
<span class="w"> </span>        the current line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.document.on_last_line:</span>
<span class="gi">+            self.cursor_position += self.document.get_end_of_line_position()</span>
<span class="gi">+            self.delete()</span>
<span class="gi">+</span>
<span class="gi">+            # Remove spaces.</span>
<span class="gi">+            self.text = (</span>
<span class="gi">+                self.document.text_before_cursor</span>
<span class="gi">+                + separator</span>
<span class="gi">+                + self.document.text_after_cursor.lstrip(&quot; &quot;)</span>
<span class="gi">+            )</span>

<span class="gd">-    def join_selected_lines(self, separator: str=&#39; &#39;) -&gt;None:</span>
<span class="gi">+    def join_selected_lines(self, separator: str = &quot; &quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Join the selected lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.selection_state</span>

<span class="gd">-    def swap_characters_before_cursor(self) -&gt;None:</span>
<span class="gi">+        # Get lines.</span>
<span class="gi">+        from_, to = sorted(</span>
<span class="gi">+            [self.cursor_position, self.selection_state.original_cursor_position]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        before = self.text[:from_]</span>
<span class="gi">+        lines = self.text[from_:to].splitlines()</span>
<span class="gi">+        after = self.text[to:]</span>
<span class="gi">+</span>
<span class="gi">+        # Replace leading spaces with just one space.</span>
<span class="gi">+        lines = [l.lstrip(&quot; &quot;) + separator for l in lines]</span>
<span class="gi">+</span>
<span class="gi">+        # Set new document.</span>
<span class="gi">+        self.document = Document(</span>
<span class="gi">+            text=before + &quot;&quot;.join(lines) + after,</span>
<span class="gi">+            cursor_position=len(before + &quot;&quot;.join(lines[:-1])) - 1,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def swap_characters_before_cursor(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Swap the last two characters before the cursor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pos = self.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+        if pos &gt;= 2:</span>
<span class="gi">+            a = self.text[pos - 2]</span>
<span class="gi">+            b = self.text[pos - 1]</span>
<span class="gi">+</span>
<span class="gi">+            self.text = self.text[: pos - 2] + b + a + self.text[pos:]</span>

<span class="gd">-    def go_to_history(self, index: int) -&gt;None:</span>
<span class="gi">+    def go_to_history(self, index: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Go to this item in the history.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if index &lt; len(self._working_lines):</span>
<span class="gi">+            self.working_index = index</span>
<span class="gi">+            self.cursor_position = len(self.text)</span>

<span class="gd">-    def complete_next(self, count: int=1, disable_wrap_around: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def complete_next(self, count: int = 1, disable_wrap_around: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Browse to the next completions.
<span class="w"> </span>        (Does nothing if there are no completion.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        index: int | None</span>

<span class="gd">-    def complete_previous(self, count: int=1, disable_wrap_around: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if self.complete_state:</span>
<span class="gi">+            completions_count = len(self.complete_state.completions)</span>
<span class="gi">+</span>
<span class="gi">+            if self.complete_state.complete_index is None:</span>
<span class="gi">+                index = 0</span>
<span class="gi">+            elif self.complete_state.complete_index == completions_count - 1:</span>
<span class="gi">+                index = None</span>
<span class="gi">+</span>
<span class="gi">+                if disable_wrap_around:</span>
<span class="gi">+                    return</span>
<span class="gi">+            else:</span>
<span class="gi">+                index = min(</span>
<span class="gi">+                    completions_count - 1, self.complete_state.complete_index + count</span>
<span class="gi">+                )</span>
<span class="gi">+            self.go_to_completion(index)</span>
<span class="gi">+</span>
<span class="gi">+    def complete_previous(</span>
<span class="gi">+        self, count: int = 1, disable_wrap_around: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Browse to the previous completions.
<span class="w"> </span>        (Does nothing if there are no completion.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        index: int | None</span>
<span class="gi">+</span>
<span class="gi">+        if self.complete_state:</span>
<span class="gi">+            if self.complete_state.complete_index == 0:</span>
<span class="gi">+                index = None</span>
<span class="gi">+</span>
<span class="gi">+                if disable_wrap_around:</span>
<span class="gi">+                    return</span>
<span class="gi">+            elif self.complete_state.complete_index is None:</span>
<span class="gi">+                index = len(self.complete_state.completions) - 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                index = max(0, self.complete_state.complete_index - count)</span>
<span class="gi">+</span>
<span class="gi">+            self.go_to_completion(index)</span>

<span class="gd">-    def cancel_completion(self) -&gt;None:</span>
<span class="gi">+    def cancel_completion(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Cancel completion, go back to the original text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.complete_state:</span>
<span class="gi">+            self.go_to_completion(None)</span>
<span class="gi">+            self.complete_state = None</span>

<span class="gd">-    def _set_completions(self, completions: list[Completion]</span>
<span class="gd">-        ) -&gt;CompletionState:</span>
<span class="gi">+    def _set_completions(self, completions: list[Completion]) -&gt; CompletionState:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start completions. (Generate list of completions and initialize.)

<span class="w"> </span>        By default, no completion will be selected.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.complete_state = CompletionState(</span>
<span class="gi">+            original_document=self.document, completions=completions</span>
<span class="gi">+        )</span>

<span class="gd">-    def start_history_lines_completion(self) -&gt;None:</span>
<span class="gi">+        # Trigger event. This should eventually invalidate the layout.</span>
<span class="gi">+        self.on_completions_changed.fire()</span>
<span class="gi">+</span>
<span class="gi">+        return self.complete_state</span>
<span class="gi">+</span>
<span class="gi">+    def start_history_lines_completion(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start a completion based on all the other lines in the document and the
<span class="w"> </span>        history.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        found_completions: set[str] = set()</span>
<span class="gi">+        completions = []</span>
<span class="gi">+</span>
<span class="gi">+        # For every line of the whole history, find matches with the current line.</span>
<span class="gi">+        current_line = self.document.current_line_before_cursor.lstrip()</span>
<span class="gi">+</span>
<span class="gi">+        for i, string in enumerate(self._working_lines):</span>
<span class="gi">+            for j, l in enumerate(string.split(&quot;\n&quot;)):</span>
<span class="gi">+                l = l.strip()</span>
<span class="gi">+                if l and l.startswith(current_line):</span>
<span class="gi">+                    # When a new line has been found.</span>
<span class="gi">+                    if l not in found_completions:</span>
<span class="gi">+                        found_completions.add(l)</span>
<span class="gi">+</span>
<span class="gi">+                        # Create completion.</span>
<span class="gi">+                        if i == self.working_index:</span>
<span class="gi">+                            display_meta = &quot;Current, line %s&quot; % (j + 1)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            display_meta = f&quot;History {i + 1}, line {j + 1}&quot;</span>
<span class="gi">+</span>
<span class="gi">+                        completions.append(</span>
<span class="gi">+                            Completion(</span>
<span class="gi">+                                text=l,</span>
<span class="gi">+                                start_position=-len(current_line),</span>
<span class="gi">+                                display_meta=display_meta,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        )</span>

<span class="gd">-    def go_to_completion(self, index: (int | None)) -&gt;None:</span>
<span class="gi">+        self._set_completions(completions=completions[::-1])</span>
<span class="gi">+        self.go_to_completion(0)</span>
<span class="gi">+</span>
<span class="gi">+    def go_to_completion(self, index: int | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Select a completion from the list of current completions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.complete_state</span>
<span class="gi">+</span>
<span class="gi">+        # Set new completion</span>
<span class="gi">+        state = self.complete_state</span>
<span class="gi">+        state.go_to_index(index)</span>
<span class="gi">+</span>
<span class="gi">+        # Set text/cursor position</span>
<span class="gi">+        new_text, new_cursor_position = state.new_text_and_position()</span>
<span class="gi">+        self.document = Document(new_text, new_cursor_position)</span>

<span class="gd">-    def apply_completion(self, completion: Completion) -&gt;None:</span>
<span class="gi">+        # (changing text/cursor position will unset complete_state.)</span>
<span class="gi">+        self.complete_state = state</span>
<span class="gi">+</span>
<span class="gi">+    def apply_completion(self, completion: Completion) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert a given completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If there was already a completion active, cancel that one.</span>
<span class="gi">+        if self.complete_state:</span>
<span class="gi">+            self.go_to_completion(None)</span>
<span class="gi">+        self.complete_state = None</span>
<span class="gi">+</span>
<span class="gi">+        # Insert text from the given completion.</span>
<span class="gi">+        self.delete_before_cursor(-completion.start_position)</span>
<span class="gi">+        self.insert_text(completion.text)</span>

<span class="gd">-    def _set_history_search(self) -&gt;None:</span>
<span class="gi">+    def _set_history_search(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set `history_search_text`.
<span class="w"> </span>        (The text before the cursor will be used for filtering the history.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.enable_history_search():</span>
<span class="gi">+            if self.history_search_text is None:</span>
<span class="gi">+                self.history_search_text = self.document.text_before_cursor</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.history_search_text = None</span>

<span class="gd">-    def _history_matches(self, i: int) -&gt;bool:</span>
<span class="gi">+    def _history_matches(self, i: int) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when the current entry matches the history search.
<span class="w"> </span>        (when we don&#39;t have history search, it&#39;s also True.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.history_search_text is None or self._working_lines[i].startswith(</span>
<span class="gi">+            self.history_search_text</span>
<span class="gi">+        )</span>

<span class="gd">-    def history_forward(self, count: int=1) -&gt;None:</span>
<span class="gi">+    def history_forward(self, count: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Move forwards through the history.

<span class="w"> </span>        :param count: Amount of items to move forward.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_history_search()</span>
<span class="gi">+</span>
<span class="gi">+        # Go forward in history.</span>
<span class="gi">+        found_something = False</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(self.working_index + 1, len(self._working_lines)):</span>
<span class="gi">+            if self._history_matches(i):</span>
<span class="gi">+                self.working_index = i</span>
<span class="gi">+                count -= 1</span>
<span class="gi">+                found_something = True</span>
<span class="gi">+            if count == 0:</span>
<span class="gi">+                break</span>

<span class="gd">-    def history_backward(self, count: int=1) -&gt;None:</span>
<span class="gi">+        # If we found an entry, move cursor to the end of the first line.</span>
<span class="gi">+        if found_something:</span>
<span class="gi">+            self.cursor_position = 0</span>
<span class="gi">+            self.cursor_position += self.document.get_end_of_line_position()</span>
<span class="gi">+</span>
<span class="gi">+    def history_backward(self, count: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Move backwards through history.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_history_search()</span>
<span class="gi">+</span>
<span class="gi">+        # Go back in history.</span>
<span class="gi">+        found_something = False</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(self.working_index - 1, -1, -1):</span>
<span class="gi">+            if self._history_matches(i):</span>
<span class="gi">+                self.working_index = i</span>
<span class="gi">+                count -= 1</span>
<span class="gi">+                found_something = True</span>
<span class="gi">+            if count == 0:</span>
<span class="gi">+                break</span>

<span class="gd">-    def yank_nth_arg(self, n: (int | None)=None, _yank_last_arg: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # If we move to another entry, move cursor to the end of the line.</span>
<span class="gi">+        if found_something:</span>
<span class="gi">+            self.cursor_position = len(self.text)</span>
<span class="gi">+</span>
<span class="gi">+    def yank_nth_arg(self, n: int | None = None, _yank_last_arg: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Pick nth word from previous history entry (depending on current
<span class="w"> </span>        `yank_nth_arg_state`) and insert it at current position. Rotate through
<span class="gu">@@ -519,23 +1071,63 @@ class Buffer:</span>
<span class="w"> </span>        :param n: (None or int), The index of the word from the previous line
<span class="w"> </span>            to take.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert n is None or isinstance(n, int)</span>
<span class="gi">+        history_strings = self.history.get_strings()</span>
<span class="gi">+</span>
<span class="gi">+        if not len(history_strings):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure we have a `YankNthArgState`.</span>
<span class="gi">+        if self.yank_nth_arg_state is None:</span>
<span class="gi">+            state = YankNthArgState(n=-1 if _yank_last_arg else 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            state = self.yank_nth_arg_state</span>
<span class="gi">+</span>
<span class="gi">+        if n is not None:</span>
<span class="gi">+            state.n = n</span>
<span class="gi">+</span>
<span class="gi">+        # Get new history position.</span>
<span class="gi">+        new_pos = state.history_position - 1</span>
<span class="gi">+        if -new_pos &gt; len(history_strings):</span>
<span class="gi">+            new_pos = -1</span>

<span class="gd">-    def yank_last_arg(self, n: (int | None)=None) -&gt;None:</span>
<span class="gi">+        # Take argument from line.</span>
<span class="gi">+        line = history_strings[new_pos]</span>
<span class="gi">+</span>
<span class="gi">+        words = [w.strip() for w in _QUOTED_WORDS_RE.split(line)]</span>
<span class="gi">+        words = [w for w in words if w]</span>
<span class="gi">+        try:</span>
<span class="gi">+            word = words[state.n]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            word = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Insert new argument.</span>
<span class="gi">+        if state.previous_inserted_word:</span>
<span class="gi">+            self.delete_before_cursor(len(state.previous_inserted_word))</span>
<span class="gi">+        self.insert_text(word)</span>
<span class="gi">+</span>
<span class="gi">+        # Save state again for next completion. (Note that the &#39;insert&#39;</span>
<span class="gi">+        # operation from above clears `self.yank_nth_arg_state`.)</span>
<span class="gi">+        state.previous_inserted_word = word</span>
<span class="gi">+        state.history_position = new_pos</span>
<span class="gi">+        self.yank_nth_arg_state = state</span>
<span class="gi">+</span>
<span class="gi">+    def yank_last_arg(self, n: int | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like `yank_nth_arg`, but if no argument has been given, yank the last
<span class="w"> </span>        word by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.yank_nth_arg(n=n, _yank_last_arg=True)</span>

<span class="gd">-    def start_selection(self, selection_type: SelectionType=SelectionType.</span>
<span class="gd">-        CHARACTERS) -&gt;None:</span>
<span class="gi">+    def start_selection(</span>
<span class="gi">+        self, selection_type: SelectionType = SelectionType.CHARACTERS</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Take the current cursor position as the start of this selection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.selection_state = SelectionState(self.cursor_position, selection_type)</span>

<span class="gd">-    def copy_selection(self, _cut: bool=False) -&gt;ClipboardData:</span>
<span class="gi">+    def copy_selection(self, _cut: bool = False) -&gt; ClipboardData:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy selected text and return :class:`.ClipboardData` instance.

<span class="gu">@@ -547,58 +1139,183 @@ class Buffer:</span>
<span class="w"> </span>            data = buffer.copy_selection()
<span class="w"> </span>            get_app().clipboard.set_data(data)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_document, clipboard_data = self.document.cut_selection()</span>
<span class="gi">+        if _cut:</span>
<span class="gi">+            self.document = new_document</span>
<span class="gi">+</span>
<span class="gi">+        self.selection_state = None</span>
<span class="gi">+        return clipboard_data</span>

<span class="gd">-    def cut_selection(self) -&gt;ClipboardData:</span>
<span class="gi">+    def cut_selection(self) -&gt; ClipboardData:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Delete selected text and return :class:`.ClipboardData` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.copy_selection(_cut=True)</span>

<span class="gd">-    def paste_clipboard_data(self, data: ClipboardData, paste_mode:</span>
<span class="gd">-        PasteMode=PasteMode.EMACS, count: int=1) -&gt;None:</span>
<span class="gi">+    def paste_clipboard_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: ClipboardData,</span>
<span class="gi">+        paste_mode: PasteMode = PasteMode.EMACS,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert the data from the clipboard.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(data, ClipboardData)</span>
<span class="gi">+        assert paste_mode in (PasteMode.VI_BEFORE, PasteMode.VI_AFTER, PasteMode.EMACS)</span>
<span class="gi">+</span>
<span class="gi">+        original_document = self.document</span>
<span class="gi">+        self.document = self.document.paste_clipboard_data(</span>
<span class="gi">+            data, paste_mode=paste_mode, count=count</span>
<span class="gi">+        )</span>

<span class="gd">-    def newline(self, copy_margin: bool=True) -&gt;None:</span>
<span class="gi">+        # Remember original document. This assignment should come at the end,</span>
<span class="gi">+        # because assigning to &#39;document&#39; will erase it.</span>
<span class="gi">+        self.document_before_paste = original_document</span>
<span class="gi">+</span>
<span class="gi">+    def newline(self, copy_margin: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert a line ending at the current position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if copy_margin:</span>
<span class="gi">+            self.insert_text(&quot;\n&quot; + self.document.leading_whitespace_in_current_line)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.insert_text(&quot;\n&quot;)</span>

<span class="gd">-    def insert_line_above(self, copy_margin: bool=True) -&gt;None:</span>
<span class="gi">+    def insert_line_above(self, copy_margin: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert a new line above the current one.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if copy_margin:</span>
<span class="gi">+            insert = self.document.leading_whitespace_in_current_line + &quot;\n&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            insert = &quot;\n&quot;</span>

<span class="gd">-    def insert_line_below(self, copy_margin: bool=True) -&gt;None:</span>
<span class="gi">+        self.cursor_position += self.document.get_start_of_line_position()</span>
<span class="gi">+        self.insert_text(insert)</span>
<span class="gi">+        self.cursor_position -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def insert_line_below(self, copy_margin: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert a new line below the current one.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if copy_margin:</span>
<span class="gi">+            insert = &quot;\n&quot; + self.document.leading_whitespace_in_current_line</span>
<span class="gi">+        else:</span>
<span class="gi">+            insert = &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_position += self.document.get_end_of_line_position()</span>
<span class="gi">+        self.insert_text(insert)</span>

<span class="gd">-    def insert_text(self, data: str, overwrite: bool=False, move_cursor:</span>
<span class="gd">-        bool=True, fire_event: bool=True) -&gt;None:</span>
<span class="gi">+    def insert_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: str,</span>
<span class="gi">+        overwrite: bool = False,</span>
<span class="gi">+        move_cursor: bool = True,</span>
<span class="gi">+        fire_event: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert characters at cursor position.

<span class="w"> </span>        :param fire_event: Fire `on_text_insert` event. This is mainly used to
<span class="w"> </span>            trigger autocompletion while typing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Original text &amp; cursor position.</span>
<span class="gi">+        otext = self.text</span>
<span class="gi">+        ocpos = self.cursor_position</span>

<span class="gd">-    def validate(self, set_cursor: bool=False) -&gt;bool:</span>
<span class="gi">+        # In insert/text mode.</span>
<span class="gi">+        if overwrite:</span>
<span class="gi">+            # Don&#39;t overwrite the newline itself. Just before the line ending,</span>
<span class="gi">+            # it should act like insert mode.</span>
<span class="gi">+            overwritten_text = otext[ocpos : ocpos + len(data)]</span>
<span class="gi">+            if &quot;\n&quot; in overwritten_text:</span>
<span class="gi">+                overwritten_text = overwritten_text[: overwritten_text.find(&quot;\n&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+            text = otext[:ocpos] + data + otext[ocpos + len(overwritten_text) :]</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = otext[:ocpos] + data + otext[ocpos:]</span>
<span class="gi">+</span>
<span class="gi">+        if move_cursor:</span>
<span class="gi">+            cpos = self.cursor_position + len(data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cpos = self.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+        # Set new document.</span>
<span class="gi">+        # (Set text and cursor position at the same time. Otherwise, setting</span>
<span class="gi">+        # the text will fire a change event before the cursor position has been</span>
<span class="gi">+        # set. It works better to have this atomic.)</span>
<span class="gi">+        self.document = Document(text, cpos)</span>
<span class="gi">+</span>
<span class="gi">+        # Fire &#39;on_text_insert&#39; event.</span>
<span class="gi">+        if fire_event:  # XXX: rename to `start_complete`.</span>
<span class="gi">+            self.on_text_insert.fire()</span>
<span class="gi">+</span>
<span class="gi">+            # Only complete when &quot;complete_while_typing&quot; is enabled.</span>
<span class="gi">+            if self.completer and self.complete_while_typing():</span>
<span class="gi">+                get_app().create_background_task(self._async_completer())</span>
<span class="gi">+</span>
<span class="gi">+            # Call auto_suggest.</span>
<span class="gi">+            if self.auto_suggest:</span>
<span class="gi">+                get_app().create_background_task(self._async_suggester())</span>
<span class="gi">+</span>
<span class="gi">+    def undo(self) -&gt; None:</span>
<span class="gi">+        # Pop from the undo-stack until we find a text that if different from</span>
<span class="gi">+        # the current text. (The current logic of `save_to_undo_stack` will</span>
<span class="gi">+        # cause that the top of the undo stack is usually the same as the</span>
<span class="gi">+        # current text, so in that case we have to pop twice.)</span>
<span class="gi">+        while self._undo_stack:</span>
<span class="gi">+            text, pos = self._undo_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+            if text != self.text:</span>
<span class="gi">+                # Push current text to redo stack.</span>
<span class="gi">+                self._redo_stack.append((self.text, self.cursor_position))</span>
<span class="gi">+</span>
<span class="gi">+                # Set new text/cursor_position.</span>
<span class="gi">+                self.document = Document(text, cursor_position=pos)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def redo(self) -&gt; None:</span>
<span class="gi">+        if self._redo_stack:</span>
<span class="gi">+            # Copy current state on undo stack.</span>
<span class="gi">+            self.save_to_undo_stack(clear_redo_stack=False)</span>
<span class="gi">+</span>
<span class="gi">+            # Pop state from redo stack.</span>
<span class="gi">+            text, pos = self._redo_stack.pop()</span>
<span class="gi">+            self.document = Document(text, cursor_position=pos)</span>
<span class="gi">+</span>
<span class="gi">+    def validate(self, set_cursor: bool = False) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns `True` if valid.

<span class="w"> </span>        :param set_cursor: Set the cursor position, if an error was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def _validate_async(self) -&gt;None:</span>
<span class="gi">+        # Don&#39;t call the validator again, if it was already called for the</span>
<span class="gi">+        # current input.</span>
<span class="gi">+        if self.validation_state != ValidationState.UNKNOWN:</span>
<span class="gi">+            return self.validation_state == ValidationState.VALID</span>
<span class="gi">+</span>
<span class="gi">+        # Call validator.</span>
<span class="gi">+        if self.validator:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.validator.validate(self.document)</span>
<span class="gi">+            except ValidationError as e:</span>
<span class="gi">+                # Set cursor position (don&#39;t allow invalid values.)</span>
<span class="gi">+                if set_cursor:</span>
<span class="gi">+                    self.cursor_position = min(</span>
<span class="gi">+                        max(0, e.cursor_position), len(self.text)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                self.validation_state = ValidationState.INVALID</span>
<span class="gi">+                self.validation_error = e</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        # Handle validation result.</span>
<span class="gi">+        self.validation_state = ValidationState.VALID</span>
<span class="gi">+        self.validation_error = None</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    async def _validate_async(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asynchronous version of `validate()`.
<span class="w"> </span>        This one doesn&#39;t set the cursor position.
<span class="gu">@@ -611,23 +1328,135 @@ class Buffer:</span>
<span class="w"> </span>        An asynchronous version is required if we have `validate_while_typing`
<span class="w"> </span>        enabled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # Don&#39;t call the validator again, if it was already called for the</span>
<span class="gi">+            # current input.</span>
<span class="gi">+            if self.validation_state != ValidationState.UNKNOWN:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Call validator.</span>
<span class="gi">+            error = None</span>
<span class="gi">+            document = self.document</span>
<span class="gi">+</span>
<span class="gi">+            if self.validator:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    await self.validator.validate_async(self.document)</span>
<span class="gi">+                except ValidationError as e:</span>
<span class="gi">+                    error = e</span>
<span class="gi">+</span>
<span class="gi">+                # If the document changed during the validation, try again.</span>
<span class="gi">+                if self.document != document:</span>
<span class="gi">+                    continue</span>

<span class="gd">-    def append_to_history(self) -&gt;None:</span>
<span class="gi">+            # Handle validation result.</span>
<span class="gi">+            if error:</span>
<span class="gi">+                self.validation_state = ValidationState.INVALID</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.validation_state = ValidationState.VALID</span>
<span class="gi">+</span>
<span class="gi">+            self.validation_error = error</span>
<span class="gi">+            get_app().invalidate()  # Trigger redraw (display error).</span>
<span class="gi">+</span>
<span class="gi">+    def append_to_history(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Append the current input to the history.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Save at the tail of the history. (But don&#39;t if the last entry the</span>
<span class="gi">+        # history is already the same.)</span>
<span class="gi">+        if self.text:</span>
<span class="gi">+            history_strings = self.history.get_strings()</span>
<span class="gi">+            if not len(history_strings) or history_strings[-1] != self.text:</span>
<span class="gi">+                self.history.append_string(self.text)</span>

<span class="gd">-    def _search(self, search_state: SearchState, include_current_position:</span>
<span class="gd">-        bool=False, count: int=1) -&gt;(tuple[int, int] | None):</span>
<span class="gi">+    def _search(</span>
<span class="gi">+        self,</span>
<span class="gi">+        search_state: SearchState,</span>
<span class="gi">+        include_current_position: bool = False,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; tuple[int, int] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Execute search. Return (working_index, cursor_position) tuple when this
<span class="w"> </span>        search is applied. Returns `None` when this text cannot be found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def document_for_search(self, search_state: SearchState) -&gt;Document:</span>
<span class="gi">+        assert count &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        text = search_state.text</span>
<span class="gi">+        direction = search_state.direction</span>
<span class="gi">+        ignore_case = search_state.ignore_case()</span>
<span class="gi">+</span>
<span class="gi">+        def search_once(</span>
<span class="gi">+            working_index: int, document: Document</span>
<span class="gi">+        ) -&gt; tuple[int, Document] | None:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Do search one time.</span>
<span class="gi">+            Return (working_index, document) or `None`</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if direction == SearchDirection.FORWARD:</span>
<span class="gi">+                # Try find at the current input.</span>
<span class="gi">+                new_index = document.find(</span>
<span class="gi">+                    text,</span>
<span class="gi">+                    include_current_position=include_current_position,</span>
<span class="gi">+                    ignore_case=ignore_case,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if new_index is not None:</span>
<span class="gi">+                    return (</span>
<span class="gi">+                        working_index,</span>
<span class="gi">+                        Document(document.text, document.cursor_position + new_index),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # No match, go forward in the history. (Include len+1 to wrap around.)</span>
<span class="gi">+                    # (Here we should always include all cursor positions, because</span>
<span class="gi">+                    # it&#39;s a different line.)</span>
<span class="gi">+                    for i in range(working_index + 1, len(self._working_lines) + 1):</span>
<span class="gi">+                        i %= len(self._working_lines)</span>
<span class="gi">+</span>
<span class="gi">+                        document = Document(self._working_lines[i], 0)</span>
<span class="gi">+                        new_index = document.find(</span>
<span class="gi">+                            text, include_current_position=True, ignore_case=ignore_case</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if new_index is not None:</span>
<span class="gi">+                            return (i, Document(document.text, new_index))</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Try find at the current input.</span>
<span class="gi">+                new_index = document.find_backwards(text, ignore_case=ignore_case)</span>
<span class="gi">+</span>
<span class="gi">+                if new_index is not None:</span>
<span class="gi">+                    return (</span>
<span class="gi">+                        working_index,</span>
<span class="gi">+                        Document(document.text, document.cursor_position + new_index),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # No match, go back in the history. (Include -1 to wrap around.)</span>
<span class="gi">+                    for i in range(working_index - 1, -2, -1):</span>
<span class="gi">+                        i %= len(self._working_lines)</span>
<span class="gi">+</span>
<span class="gi">+                        document = Document(</span>
<span class="gi">+                            self._working_lines[i], len(self._working_lines[i])</span>
<span class="gi">+                        )</span>
<span class="gi">+                        new_index = document.find_backwards(</span>
<span class="gi">+                            text, ignore_case=ignore_case</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if new_index is not None:</span>
<span class="gi">+                            return (</span>
<span class="gi">+                                i,</span>
<span class="gi">+                                Document(document.text, len(document.text) + new_index),</span>
<span class="gi">+                            )</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # Do &#39;count&#39; search iterations.</span>
<span class="gi">+        working_index = self.working_index</span>
<span class="gi">+        document = self.document</span>
<span class="gi">+        for _ in range(count):</span>
<span class="gi">+            result = search_once(working_index, document)</span>
<span class="gi">+            if result is None:</span>
<span class="gi">+                return None  # Nothing found.</span>
<span class="gi">+            else:</span>
<span class="gi">+                working_index, document = result</span>
<span class="gi">+</span>
<span class="gi">+        return (working_index, document.cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+    def document_for_search(self, search_state: SearchState) -&gt; Document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a :class:`~prompt_toolkit.document.Document` instance that has
<span class="w"> </span>        the text/cursor position for this search, if we would apply it. This
<span class="gu">@@ -635,95 +1464,437 @@ class Buffer:</span>
<span class="w"> </span>        :class:`~prompt_toolkit.layout.BufferControl` to display feedback while
<span class="w"> </span>        searching.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        search_result = self._search(search_state, include_current_position=True)</span>
<span class="gi">+</span>
<span class="gi">+        if search_result is None:</span>
<span class="gi">+            return self.document</span>
<span class="gi">+        else:</span>
<span class="gi">+            working_index, cursor_position = search_result</span>
<span class="gi">+</span>
<span class="gi">+            # Keep selection, when `working_index` was not changed.</span>
<span class="gi">+            if working_index == self.working_index:</span>
<span class="gi">+                selection = self.selection_state</span>
<span class="gi">+            else:</span>
<span class="gi">+                selection = None</span>

<span class="gd">-    def get_search_position(self, search_state: SearchState,</span>
<span class="gd">-        include_current_position: bool=True, count: int=1) -&gt;int:</span>
<span class="gi">+            return Document(</span>
<span class="gi">+                self._working_lines[working_index], cursor_position, selection=selection</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def get_search_position(</span>
<span class="gi">+        self,</span>
<span class="gi">+        search_state: SearchState,</span>
<span class="gi">+        include_current_position: bool = True,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the cursor position for this search.
<span class="w"> </span>        (This operation won&#39;t change the `working_index`. It&#39;s won&#39;t go through
<span class="w"> </span>        the history. Vi text objects can&#39;t span multiple items.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        search_result = self._search(</span>
<span class="gi">+            search_state, include_current_position=include_current_position, count=count</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if search_result is None:</span>
<span class="gi">+            return self.cursor_position</span>
<span class="gi">+        else:</span>
<span class="gi">+            working_index, cursor_position = search_result</span>
<span class="gi">+            return cursor_position</span>

<span class="gd">-    def apply_search(self, search_state: SearchState,</span>
<span class="gd">-        include_current_position: bool=True, count: int=1) -&gt;None:</span>
<span class="gi">+    def apply_search(</span>
<span class="gi">+        self,</span>
<span class="gi">+        search_state: SearchState,</span>
<span class="gi">+        include_current_position: bool = True,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Apply search. If something is found, set `working_index` and
<span class="w"> </span>        `cursor_position`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        search_result = self._search(</span>
<span class="gi">+            search_state, include_current_position=include_current_position, count=count</span>
<span class="gi">+        )</span>

<span class="gd">-    def _editor_simple_tempfile(self) -&gt;tuple[str, Callable[[], None]]:</span>
<span class="gi">+        if search_result is not None:</span>
<span class="gi">+            working_index, cursor_position = search_result</span>
<span class="gi">+            self.working_index = working_index</span>
<span class="gi">+            self.cursor_position = cursor_position</span>
<span class="gi">+</span>
<span class="gi">+    def exit_selection(self) -&gt; None:</span>
<span class="gi">+        self.selection_state = None</span>
<span class="gi">+</span>
<span class="gi">+    def _editor_simple_tempfile(self) -&gt; tuple[str, Callable[[], None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Simple (file) tempfile implementation.
<span class="w"> </span>        Return (tempfile, cleanup_func).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        suffix = to_str(self.tempfile_suffix)</span>
<span class="gi">+        descriptor, filename = tempfile.mkstemp(suffix)</span>
<span class="gi">+</span>
<span class="gi">+        os.write(descriptor, self.text.encode(&quot;utf-8&quot;))</span>
<span class="gi">+        os.close(descriptor)</span>
<span class="gi">+</span>
<span class="gi">+        def cleanup() -&gt; None:</span>
<span class="gi">+            os.unlink(filename)</span>
<span class="gi">+</span>
<span class="gi">+        return filename, cleanup</span>
<span class="gi">+</span>
<span class="gi">+    def _editor_complex_tempfile(self) -&gt; tuple[str, Callable[[], None]]:</span>
<span class="gi">+        # Complex (directory) tempfile implementation.</span>
<span class="gi">+        headtail = to_str(self.tempfile)</span>
<span class="gi">+        if not headtail:</span>
<span class="gi">+            # Revert to simple case.</span>
<span class="gi">+            return self._editor_simple_tempfile()</span>
<span class="gi">+        headtail = str(headtail)</span>
<span class="gi">+</span>
<span class="gi">+        # Try to make according to tempfile logic.</span>
<span class="gi">+        head, tail = os.path.split(headtail)</span>
<span class="gi">+        if os.path.isabs(head):</span>
<span class="gi">+            head = head[1:]</span>
<span class="gi">+</span>
<span class="gi">+        dirpath = tempfile.mkdtemp()</span>
<span class="gi">+        if head:</span>
<span class="gi">+            dirpath = os.path.join(dirpath, head)</span>
<span class="gi">+        # Assume there is no issue creating dirs in this temp dir.</span>
<span class="gi">+        os.makedirs(dirpath)</span>
<span class="gi">+</span>
<span class="gi">+        # Open the filename and write current text.</span>
<span class="gi">+        filename = os.path.join(dirpath, tail)</span>
<span class="gi">+        with open(filename, &quot;w&quot;, encoding=&quot;utf-8&quot;) as fh:</span>
<span class="gi">+            fh.write(self.text)</span>

<span class="gd">-    def open_in_editor(self, validate_and_handle: bool=False) -&gt;asyncio.Task[</span>
<span class="gd">-        None]:</span>
<span class="gi">+        def cleanup() -&gt; None:</span>
<span class="gi">+            shutil.rmtree(dirpath)</span>
<span class="gi">+</span>
<span class="gi">+        return filename, cleanup</span>
<span class="gi">+</span>
<span class="gi">+    def open_in_editor(self, validate_and_handle: bool = False) -&gt; asyncio.Task[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Open code in editor.

<span class="w"> </span>        This returns a future, and runs in a thread executor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.read_only():</span>
<span class="gi">+            raise EditReadOnlyBuffer()</span>
<span class="gi">+</span>
<span class="gi">+        # Write current text to temporary file</span>
<span class="gi">+        if self.tempfile:</span>
<span class="gi">+            filename, cleanup_func = self._editor_complex_tempfile()</span>
<span class="gi">+        else:</span>
<span class="gi">+            filename, cleanup_func = self._editor_simple_tempfile()</span>
<span class="gi">+</span>
<span class="gi">+        async def run() -&gt; None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Open in editor</span>
<span class="gi">+                # (We need to use `run_in_terminal`, because not all editors go to</span>
<span class="gi">+                # the alternate screen buffer, and some could influence the cursor</span>
<span class="gi">+                # position.)</span>
<span class="gi">+                success = await run_in_terminal(</span>
<span class="gi">+                    lambda: self._open_file_in_editor(filename), in_executor=True</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # Read content again.</span>
<span class="gi">+                if success:</span>
<span class="gi">+                    with open(filename, &quot;rb&quot;) as f:</span>
<span class="gi">+                        text = f.read().decode(&quot;utf-8&quot;)</span>

<span class="gd">-    def _open_file_in_editor(self, filename: str) -&gt;bool:</span>
<span class="gi">+                        # Drop trailing newline. (Editors are supposed to add it at the</span>
<span class="gi">+                        # end, but we don&#39;t need it.)</span>
<span class="gi">+                        if text.endswith(&quot;\n&quot;):</span>
<span class="gi">+                            text = text[:-1]</span>
<span class="gi">+</span>
<span class="gi">+                        self.document = Document(text=text, cursor_position=len(text))</span>
<span class="gi">+</span>
<span class="gi">+                    # Accept the input.</span>
<span class="gi">+                    if validate_and_handle:</span>
<span class="gi">+                        self.validate_and_handle()</span>
<span class="gi">+</span>
<span class="gi">+            finally:</span>
<span class="gi">+                # Clean up temp dir/file.</span>
<span class="gi">+                cleanup_func()</span>
<span class="gi">+</span>
<span class="gi">+        return get_app().create_background_task(run())</span>
<span class="gi">+</span>
<span class="gi">+    def _open_file_in_editor(self, filename: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Call editor executable.

<span class="w"> </span>        Return True when we received a zero return code.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def start_completion(self, select_first: bool=False, select_last: bool=</span>
<span class="gd">-        False, insert_common_part: bool=False, complete_event: (</span>
<span class="gd">-        CompleteEvent | None)=None) -&gt;None:</span>
<span class="gi">+        # If the &#39;VISUAL&#39; or &#39;EDITOR&#39; environment variable has been set, use that.</span>
<span class="gi">+        # Otherwise, fall back to the first available editor that we can find.</span>
<span class="gi">+        visual = os.environ.get(&quot;VISUAL&quot;)</span>
<span class="gi">+        editor = os.environ.get(&quot;EDITOR&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        editors = [</span>
<span class="gi">+            visual,</span>
<span class="gi">+            editor,</span>
<span class="gi">+            # Order of preference.</span>
<span class="gi">+            &quot;/usr/bin/editor&quot;,</span>
<span class="gi">+            &quot;/usr/bin/nano&quot;,</span>
<span class="gi">+            &quot;/usr/bin/pico&quot;,</span>
<span class="gi">+            &quot;/usr/bin/vi&quot;,</span>
<span class="gi">+            &quot;/usr/bin/emacs&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        for e in editors:</span>
<span class="gi">+            if e:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # Use &#39;shlex.split()&#39;, because $VISUAL can contain spaces</span>
<span class="gi">+                    # and quotes.</span>
<span class="gi">+                    returncode = subprocess.call(shlex.split(e) + [filename])</span>
<span class="gi">+                    return returncode == 0</span>
<span class="gi">+</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    # Executable does not exist, try the next one.</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def start_completion(</span>
<span class="gi">+        self,</span>
<span class="gi">+        select_first: bool = False,</span>
<span class="gi">+        select_last: bool = False,</span>
<span class="gi">+        insert_common_part: bool = False,</span>
<span class="gi">+        complete_event: CompleteEvent | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start asynchronous autocompletion of this buffer.
<span class="w"> </span>        (This will do nothing if a previous completion was still in progress.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Only one of these options can be selected.</span>
<span class="gi">+        assert select_first + select_last + insert_common_part &lt;= 1</span>

<span class="gd">-    def _create_completer_coroutine(self) -&gt;Callable[..., Coroutine[Any,</span>
<span class="gd">-        Any, None]]:</span>
<span class="gi">+        get_app().create_background_task(</span>
<span class="gi">+            self._async_completer(</span>
<span class="gi">+                select_first=select_first,</span>
<span class="gi">+                select_last=select_last,</span>
<span class="gi">+                insert_common_part=insert_common_part,</span>
<span class="gi">+                complete_event=complete_event</span>
<span class="gi">+                or CompleteEvent(completion_requested=True),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _create_completer_coroutine(self) -&gt; Callable[..., Coroutine[Any, Any, None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create function for asynchronous autocompletion.

<span class="w"> </span>        (This consumes the asynchronous completer generator, which possibly
<span class="w"> </span>        runs the completion algorithm in another thread.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _create_auto_suggest_coroutine(self) -&gt;Callable[[], Coroutine[Any,</span>
<span class="gd">-        Any, None]]:</span>
<span class="gi">+        def completion_does_nothing(document: Document, completion: Completion) -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Return `True` if applying this completion doesn&#39;t have any effect.</span>
<span class="gi">+            (When it doesn&#39;t insert any new text.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            text_before_cursor = document.text_before_cursor</span>
<span class="gi">+            replaced_text = text_before_cursor[</span>
<span class="gi">+                len(text_before_cursor) + completion.start_position :</span>
<span class="gi">+            ]</span>
<span class="gi">+            return replaced_text == completion.text</span>
<span class="gi">+</span>
<span class="gi">+        @_only_one_at_a_time</span>
<span class="gi">+        async def async_completer(</span>
<span class="gi">+            select_first: bool = False,</span>
<span class="gi">+            select_last: bool = False,</span>
<span class="gi">+            insert_common_part: bool = False,</span>
<span class="gi">+            complete_event: CompleteEvent | None = None,</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            document = self.document</span>
<span class="gi">+            complete_event = complete_event or CompleteEvent(text_inserted=True)</span>
<span class="gi">+</span>
<span class="gi">+            # Don&#39;t complete when we already have completions.</span>
<span class="gi">+            if self.complete_state or not self.completer:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Create an empty CompletionState.</span>
<span class="gi">+            complete_state = CompletionState(original_document=self.document)</span>
<span class="gi">+            self.complete_state = complete_state</span>
<span class="gi">+</span>
<span class="gi">+            def proceed() -&gt; bool:</span>
<span class="gi">+                &quot;&quot;&quot;Keep retrieving completions. Input text has not yet changed</span>
<span class="gi">+                while generating completions.&quot;&quot;&quot;</span>
<span class="gi">+                return self.complete_state == complete_state</span>
<span class="gi">+</span>
<span class="gi">+            refresh_needed = asyncio.Event()</span>
<span class="gi">+</span>
<span class="gi">+            async def refresh_while_loading() -&gt; None:</span>
<span class="gi">+                &quot;&quot;&quot;Background loop to refresh the UI at most 3 times a second</span>
<span class="gi">+                while the completion are loading. Calling</span>
<span class="gi">+                `on_completions_changed.fire()` for every completion that we</span>
<span class="gi">+                receive is too expensive when there are many completions. (We</span>
<span class="gi">+                could tune `Application.max_render_postpone_time` and</span>
<span class="gi">+                `Application.min_redraw_interval`, but having this here is a</span>
<span class="gi">+                better approach.)</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    self.on_completions_changed.fire()</span>
<span class="gi">+                    refresh_needed.clear()</span>
<span class="gi">+                    await asyncio.sleep(0.3)</span>
<span class="gi">+                    await refresh_needed.wait()</span>
<span class="gi">+</span>
<span class="gi">+            refresh_task = asyncio.ensure_future(refresh_while_loading())</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Load.</span>
<span class="gi">+                async with aclosing(</span>
<span class="gi">+                    self.completer.get_completions_async(document, complete_event)</span>
<span class="gi">+                ) as async_generator:</span>
<span class="gi">+                    async for completion in async_generator:</span>
<span class="gi">+                        complete_state.completions.append(completion)</span>
<span class="gi">+                        refresh_needed.set()</span>
<span class="gi">+</span>
<span class="gi">+                        # If the input text changes, abort.</span>
<span class="gi">+                        if not proceed():</span>
<span class="gi">+                            break</span>
<span class="gi">+            finally:</span>
<span class="gi">+                refresh_task.cancel()</span>
<span class="gi">+</span>
<span class="gi">+                # Refresh one final time after we got everything.</span>
<span class="gi">+                self.on_completions_changed.fire()</span>
<span class="gi">+</span>
<span class="gi">+            completions = complete_state.completions</span>
<span class="gi">+</span>
<span class="gi">+            # When there is only one completion, which has nothing to add, ignore it.</span>
<span class="gi">+            if len(completions) == 1 and completion_does_nothing(</span>
<span class="gi">+                document, completions[0]</span>
<span class="gi">+            ):</span>
<span class="gi">+                del completions[:]</span>
<span class="gi">+</span>
<span class="gi">+            # Set completions if the text was not yet changed.</span>
<span class="gi">+            if proceed():</span>
<span class="gi">+                # When no completions were found, or when the user selected</span>
<span class="gi">+                # already a completion by using the arrow keys, don&#39;t do anything.</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not self.complete_state</span>
<span class="gi">+                    or self.complete_state.complete_index is not None</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # When there are no completions, reset completion state anyway.</span>
<span class="gi">+                if not completions:</span>
<span class="gi">+                    self.complete_state = None</span>
<span class="gi">+                    # Render the ui if the completion menu was shown</span>
<span class="gi">+                    # it is needed especially if there is one completion and it was deleted.</span>
<span class="gi">+                    self.on_completions_changed.fire()</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # Select first/last or insert common part, depending on the key</span>
<span class="gi">+                # binding. (For this we have to wait until all completions are</span>
<span class="gi">+                # loaded.)</span>
<span class="gi">+</span>
<span class="gi">+                if select_first:</span>
<span class="gi">+                    self.go_to_completion(0)</span>
<span class="gi">+</span>
<span class="gi">+                elif select_last:</span>
<span class="gi">+                    self.go_to_completion(len(completions) - 1)</span>
<span class="gi">+</span>
<span class="gi">+                elif insert_common_part:</span>
<span class="gi">+                    common_part = get_common_complete_suffix(document, completions)</span>
<span class="gi">+                    if common_part:</span>
<span class="gi">+                        # Insert the common part, update completions.</span>
<span class="gi">+                        self.insert_text(common_part)</span>
<span class="gi">+                        if len(completions) &gt; 1:</span>
<span class="gi">+                            # (Don&#39;t call `async_completer` again, but</span>
<span class="gi">+                            # recalculate completions. See:</span>
<span class="gi">+                            # https://github.com/ipython/ipython/issues/9658)</span>
<span class="gi">+                            completions[:] = [</span>
<span class="gi">+                                c.new_completion_from_position(len(common_part))</span>
<span class="gi">+                                for c in completions</span>
<span class="gi">+                            ]</span>
<span class="gi">+</span>
<span class="gi">+                            self._set_completions(completions=completions)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self.complete_state = None</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # When we were asked to insert the &quot;common&quot;</span>
<span class="gi">+                        # prefix, but there was no common suffix but</span>
<span class="gi">+                        # still exactly one match, then select the</span>
<span class="gi">+                        # first. (It could be that we have a completion</span>
<span class="gi">+                        # which does * expansion, like &#39;*.py&#39;, with</span>
<span class="gi">+                        # exactly one match.)</span>
<span class="gi">+                        if len(completions) == 1:</span>
<span class="gi">+                            self.go_to_completion(0)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                # If the last operation was an insert, (not a delete), restart</span>
<span class="gi">+                # the completion coroutine.</span>
<span class="gi">+</span>
<span class="gi">+                if self.document.text_before_cursor == document.text_before_cursor:</span>
<span class="gi">+                    return  # Nothing changed.</span>
<span class="gi">+</span>
<span class="gi">+                if self.document.text_before_cursor.startswith(</span>
<span class="gi">+                    document.text_before_cursor</span>
<span class="gi">+                ):</span>
<span class="gi">+                    raise _Retry</span>
<span class="gi">+</span>
<span class="gi">+        return async_completer</span>
<span class="gi">+</span>
<span class="gi">+    def _create_auto_suggest_coroutine(self) -&gt; Callable[[], Coroutine[Any, Any, None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create function for asynchronous auto suggestion.
<span class="w"> </span>        (This can be in another thread.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _create_auto_validate_coroutine(self) -&gt;Callable[[], Coroutine[Any,</span>
<span class="gd">-        Any, None]]:</span>
<span class="gi">+        @_only_one_at_a_time</span>
<span class="gi">+        async def async_suggestor() -&gt; None:</span>
<span class="gi">+            document = self.document</span>
<span class="gi">+</span>
<span class="gi">+            # Don&#39;t suggest when we already have a suggestion.</span>
<span class="gi">+            if self.suggestion or not self.auto_suggest:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            suggestion = await self.auto_suggest.get_suggestion_async(self, document)</span>
<span class="gi">+</span>
<span class="gi">+            # Set suggestion only if the text was not yet changed.</span>
<span class="gi">+            if self.document == document:</span>
<span class="gi">+                # Set suggestion and redraw interface.</span>
<span class="gi">+                self.suggestion = suggestion</span>
<span class="gi">+                self.on_suggestion_set.fire()</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Otherwise, restart thread.</span>
<span class="gi">+                raise _Retry</span>
<span class="gi">+</span>
<span class="gi">+        return async_suggestor</span>
<span class="gi">+</span>
<span class="gi">+    def _create_auto_validate_coroutine(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Callable[[], Coroutine[Any, Any, None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a function for asynchronous validation while typing.
<span class="w"> </span>        (This can be in another thread.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def validate_and_handle(self) -&gt;None:</span>
<span class="gi">+        @_only_one_at_a_time</span>
<span class="gi">+        async def async_validator() -&gt; None:</span>
<span class="gi">+            await self._validate_async()</span>
<span class="gi">+</span>
<span class="gi">+        return async_validator</span>
<span class="gi">+</span>
<span class="gi">+    def validate_and_handle(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Validate buffer and handle the accept action.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        valid = self.validate(set_cursor=True)</span>
<span class="gi">+</span>
<span class="gi">+        # When the validation succeeded, accept the input.</span>
<span class="gi">+        if valid:</span>
<span class="gi">+            if self.accept_handler:</span>
<span class="gi">+                keep_text = self.accept_handler(self)</span>
<span class="gi">+            else:</span>
<span class="gi">+                keep_text = False</span>

<span class="gi">+            self.append_to_history()</span>

<span class="gd">-_T = TypeVar(&#39;_T&#39;, bound=Callable[..., Coroutine[Any, Any, None]])</span>
<span class="gi">+            if not keep_text:</span>
<span class="gi">+                self.reset()</span>


<span class="gd">-def _only_one_at_a_time(coroutine: _T) -&gt;_T:</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;, bound=Callable[..., Coroutine[Any, Any, None]])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _only_one_at_a_time(coroutine: _T) -&gt; _T:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decorator that only starts the coroutine only if the previous call has
<span class="w"> </span>    finished. (Used to make sure that we have only one autocompleter, auto
<span class="gu">@@ -731,31 +1902,125 @@ def _only_one_at_a_time(coroutine: _T) -&gt;_T:</span>

<span class="w"> </span>    When the coroutine raises `_Retry`, it is restarted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    running = False</span>
<span class="gi">+</span>
<span class="gi">+    @wraps(coroutine)</span>
<span class="gi">+    async def new_coroutine(*a: Any, **kw: Any) -&gt; Any:</span>
<span class="gi">+        nonlocal running</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t start a new function, if the previous is still in progress.</span>
<span class="gi">+        if running:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        running = True</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    await coroutine(*a, **kw)</span>
<span class="gi">+                except _Retry:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            running = False</span>
<span class="gi">+</span>
<span class="gi">+    return cast(_T, new_coroutine)</span>


<span class="w"> </span>class _Retry(Exception):
<span class="gd">-    &quot;&quot;&quot;Retry in `_only_one_at_a_time`.&quot;&quot;&quot;</span>
<span class="gi">+    &quot;Retry in `_only_one_at_a_time`.&quot;</span>


<span class="gd">-def indent(buffer: Buffer, from_row: int, to_row: int, count: int=1) -&gt;None:</span>
<span class="gi">+def indent(buffer: Buffer, from_row: int, to_row: int, count: int = 1) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Indent text of a :class:`.Buffer` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_row = buffer.document.cursor_position_row</span>
<span class="gi">+    current_col = buffer.document.cursor_position_col</span>
<span class="gi">+    line_range = range(from_row, to_row)</span>
<span class="gi">+</span>
<span class="gi">+    # Apply transformation.</span>
<span class="gi">+    indent_content = &quot;    &quot; * count</span>
<span class="gi">+    new_text = buffer.transform_lines(line_range, lambda l: indent_content + l)</span>
<span class="gi">+    buffer.document = Document(</span>
<span class="gi">+        new_text, Document(new_text).translate_row_col_to_index(current_row, 0)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Place cursor in the same position in text after indenting</span>
<span class="gi">+    buffer.cursor_position += current_col + len(indent_content)</span>


<span class="gd">-def unindent(buffer: Buffer, from_row: int, to_row: int, count: int=1) -&gt;None:</span>
<span class="gi">+def unindent(buffer: Buffer, from_row: int, to_row: int, count: int = 1) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Unindent text of a :class:`.Buffer` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_row = buffer.document.cursor_position_row</span>
<span class="gi">+    current_col = buffer.document.cursor_position_col</span>
<span class="gi">+    line_range = range(from_row, to_row)</span>
<span class="gi">+</span>
<span class="gi">+    indent_content = &quot;    &quot; * count</span>
<span class="gi">+</span>
<span class="gi">+    def transform(text: str) -&gt; str:</span>
<span class="gi">+        remove = indent_content</span>
<span class="gi">+        if text.startswith(remove):</span>
<span class="gi">+            return text[len(remove) :]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return text.lstrip()</span>
<span class="gi">+</span>
<span class="gi">+    # Apply transformation.</span>
<span class="gi">+    new_text = buffer.transform_lines(line_range, transform)</span>
<span class="gi">+    buffer.document = Document(</span>
<span class="gi">+        new_text, Document(new_text).translate_row_col_to_index(current_row, 0)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Place cursor in the same position in text after dedent</span>
<span class="gi">+    buffer.cursor_position += current_col - len(indent_content)</span>


<span class="gd">-def reshape_text(buffer: Buffer, from_row: int, to_row: int) -&gt;None:</span>
<span class="gi">+def reshape_text(buffer: Buffer, from_row: int, to_row: int) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Reformat text, taking the width into account.
<span class="w"> </span>    `to_row` is included.
<span class="w"> </span>    (Vi &#39;gq&#39; operator.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = buffer.text.splitlines(True)</span>
<span class="gi">+    lines_before = lines[:from_row]</span>
<span class="gi">+    lines_after = lines[to_row + 1 :]</span>
<span class="gi">+    lines_to_reformat = lines[from_row : to_row + 1]</span>
<span class="gi">+</span>
<span class="gi">+    if lines_to_reformat:</span>
<span class="gi">+        # Take indentation from the first line.</span>
<span class="gi">+        match = re.search(r&quot;^\s*&quot;, lines_to_reformat[0])</span>
<span class="gi">+        length = match.end() if match else 0  # `match` can&#39;t be None, actually.</span>
<span class="gi">+</span>
<span class="gi">+        indent = lines_to_reformat[0][:length].replace(&quot;\n&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Now, take all the &#39;words&#39; from the lines to be reshaped.</span>
<span class="gi">+        words = &quot;&quot;.join(lines_to_reformat).split()</span>
<span class="gi">+</span>
<span class="gi">+        # And reshape.</span>
<span class="gi">+        width = (buffer.text_width or 80) - len(indent)</span>
<span class="gi">+        reshaped_text = [indent]</span>
<span class="gi">+        current_width = 0</span>
<span class="gi">+        for w in words:</span>
<span class="gi">+            if current_width:</span>
<span class="gi">+                if len(w) + current_width + 1 &gt; width:</span>
<span class="gi">+                    reshaped_text.append(&quot;\n&quot;)</span>
<span class="gi">+                    reshaped_text.append(indent)</span>
<span class="gi">+                    current_width = 0</span>
<span class="gi">+                else:</span>
<span class="gi">+                    reshaped_text.append(&quot; &quot;)</span>
<span class="gi">+                    current_width += 1</span>
<span class="gi">+</span>
<span class="gi">+            reshaped_text.append(w)</span>
<span class="gi">+            current_width += len(w)</span>
<span class="gi">+</span>
<span class="gi">+        if reshaped_text[-1] != &quot;\n&quot;:</span>
<span class="gi">+            reshaped_text.append(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply result.</span>
<span class="gi">+        buffer.document = Document(</span>
<span class="gi">+            text=&quot;&quot;.join(lines_before + reshaped_text + lines_after),</span>
<span class="gi">+            cursor_position=len(&quot;&quot;.join(lines_before + reshaped_text)),</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/cache.py b/src/prompt_toolkit/cache.py</span>
<span class="gh">index bfff0829..01dd1f79 100644</span>
<span class="gd">--- a/src/prompt_toolkit/cache.py</span>
<span class="gi">+++ b/src/prompt_toolkit/cache.py</span>
<span class="gu">@@ -1,10 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from typing import Any, Callable, Dict, Generic, Hashable, Tuple, TypeVar, cast
<span class="gd">-__all__ = [&#39;SimpleCache&#39;, &#39;FastDictCache&#39;, &#39;memoized&#39;]</span>
<span class="gd">-_T = TypeVar(&#39;_T&#39;, bound=Hashable)</span>
<span class="gd">-_U = TypeVar(&#39;_U&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;SimpleCache&quot;,</span>
<span class="gi">+    &quot;FastDictCache&quot;,</span>
<span class="gi">+    &quot;memoized&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;, bound=Hashable)</span>
<span class="gi">+_U = TypeVar(&quot;_U&quot;)</span>


<span class="w"> </span>class SimpleCache(Generic[_T, _U]):
<span class="gu">@@ -15,27 +22,44 @@ class SimpleCache(Generic[_T, _U]):</span>
<span class="w"> </span>    :param maxsize: Maximum size of the cache. (Don&#39;t make it too big.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, maxsize: int=8) -&gt;None:</span>
<span class="gi">+    def __init__(self, maxsize: int = 8) -&gt; None:</span>
<span class="w"> </span>        assert maxsize &gt; 0
<span class="gi">+</span>
<span class="w"> </span>        self._data: dict[_T, _U] = {}
<span class="w"> </span>        self._keys: deque[_T] = deque()
<span class="w"> </span>        self.maxsize: int = maxsize

<span class="gd">-    def get(self, key: _T, getter_func: Callable[[], _U]) -&gt;_U:</span>
<span class="gi">+    def get(self, key: _T, getter_func: Callable[[], _U]) -&gt; _U:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get object from the cache.
<span class="w"> </span>        If not found, call `getter_func` to resolve it, and put that on the top
<span class="w"> </span>        of the cache instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Look in cache first.</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._data[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Not found? Get it.</span>
<span class="gi">+            value = getter_func()</span>
<span class="gi">+            self._data[key] = value</span>
<span class="gi">+            self._keys.append(key)</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Clear cache.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+            # Remove the oldest key when the size is exceeded.</span>
<span class="gi">+            if len(self._data) &gt; self.maxsize:</span>
<span class="gi">+                key_to_remove = self._keys.popleft()</span>
<span class="gi">+                if key_to_remove in self._data:</span>
<span class="gi">+                    del self._data[key_to_remove]</span>

<span class="gi">+            return value</span>

<span class="gd">-_K = TypeVar(&#39;_K&#39;, bound=Tuple[Hashable, ...])</span>
<span class="gd">-_V = TypeVar(&#39;_V&#39;)</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="gi">+        &quot;Clear cache.&quot;</span>
<span class="gi">+        self._data = {}</span>
<span class="gi">+        self._keys = deque()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_K = TypeVar(&quot;_K&quot;, bound=Tuple[Hashable, ...])</span>
<span class="gi">+_V = TypeVar(&quot;_V&quot;)</span>


<span class="w"> </span>class FastDictCache(Dict[_K, _V]):
<span class="gu">@@ -51,28 +75,53 @@ class FastDictCache(Dict[_K, _V]):</span>
<span class="w"> </span>    :param get_value: Callable that&#39;s called in case of a missing key.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_value: Callable[..., _V], size: int=1000000) -&gt;None:</span>
<span class="gi">+    # NOTE: This cache is used to cache `prompt_toolkit.layout.screen.Char` and</span>
<span class="gi">+    #       `prompt_toolkit.Document`. Make sure to keep this really lightweight.</span>
<span class="gi">+    #       Accessing the cache should stay faster than instantiating new</span>
<span class="gi">+    #       objects.</span>
<span class="gi">+    #       (Dictionary lookups are really fast.)</span>
<span class="gi">+    #       SimpleCache is still required for cases where the cache key is not</span>
<span class="gi">+    #       the same as the arguments given to the function that creates the</span>
<span class="gi">+    #       value.)</span>
<span class="gi">+    def __init__(self, get_value: Callable[..., _V], size: int = 1000000) -&gt; None:</span>
<span class="w"> </span>        assert size &gt; 0
<span class="gi">+</span>
<span class="w"> </span>        self._keys: deque[_K] = deque()
<span class="w"> </span>        self.get_value = get_value
<span class="w"> </span>        self.size = size

<span class="gd">-    def __missing__(self, key: _K) -&gt;_V:</span>
<span class="gi">+    def __missing__(self, key: _K) -&gt; _V:</span>
<span class="gi">+        # Remove the oldest key when the size is exceeded.</span>
<span class="w"> </span>        if len(self) &gt; self.size:
<span class="w"> </span>            key_to_remove = self._keys.popleft()
<span class="w"> </span>            if key_to_remove in self:
<span class="w"> </span>                del self[key_to_remove]
<span class="gi">+</span>
<span class="w"> </span>        result = self.get_value(*key)
<span class="w"> </span>        self[key] = result
<span class="w"> </span>        self._keys.append(key)
<span class="w"> </span>        return result


<span class="gd">-_F = TypeVar(&#39;_F&#39;, bound=Callable[..., object])</span>
<span class="gi">+_F = TypeVar(&quot;_F&quot;, bound=Callable[..., object])</span>


<span class="gd">-def memoized(maxsize: int=1024) -&gt;Callable[[_F], _F]:</span>
<span class="gi">+def memoized(maxsize: int = 1024) -&gt; Callable[[_F], _F]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Memoization decorator for immutable classes and pure functions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(obj: _F) -&gt; _F:</span>
<span class="gi">+        cache: SimpleCache[Hashable, Any] = SimpleCache(maxsize=maxsize)</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(obj)</span>
<span class="gi">+        def new_callable(*a: Any, **kw: Any) -&gt; Any:</span>
<span class="gi">+            def create_new() -&gt; Any:</span>
<span class="gi">+                return obj(*a, **kw)</span>
<span class="gi">+</span>
<span class="gi">+            key = (a, tuple(sorted(kw.items())))</span>
<span class="gi">+            return cache.get(key, create_new)</span>
<span class="gi">+</span>
<span class="gi">+        return cast(_F, new_callable)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/src/prompt_toolkit/clipboard/base.py b/src/prompt_toolkit/clipboard/base.py</span>
<span class="gh">index e09febd7..b05275ba 100644</span>
<span class="gd">--- a/src/prompt_toolkit/clipboard/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/clipboard/base.py</span>
<span class="gu">@@ -2,10 +2,18 @@</span>
<span class="w"> </span>Clipboard for command line interface.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.selection import SelectionType
<span class="gd">-__all__ = [&#39;Clipboard&#39;, &#39;ClipboardData&#39;, &#39;DummyClipboard&#39;, &#39;DynamicClipboard&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Clipboard&quot;,</span>
<span class="gi">+    &quot;ClipboardData&quot;,</span>
<span class="gi">+    &quot;DummyClipboard&quot;,</span>
<span class="gi">+    &quot;DynamicClipboard&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ClipboardData:
<span class="gu">@@ -16,8 +24,9 @@ class ClipboardData:</span>
<span class="w"> </span>    :param type: :class:`~prompt_toolkit.selection.SelectionType`
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str=&#39;&#39;, type: SelectionType=SelectionType.</span>
<span class="gd">-        CHARACTERS) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, text: str = &quot;&quot;, type: SelectionType = SelectionType.CHARACTERS</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.type = type

<span class="gu">@@ -30,32 +39,29 @@ class Clipboard(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def set_data(self, data: ClipboardData) -&gt;None:</span>
<span class="gi">+    def set_data(self, data: ClipboardData) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set data to the clipboard.

<span class="w"> </span>        :param data: :class:`~.ClipboardData` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def set_text(self, text: str) -&gt;None:</span>
<span class="gi">+    def set_text(self, text: str) -&gt; None:  # Not abstract.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Shortcut for setting plain text on clipboard.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_data(ClipboardData(text))</span>

<span class="gd">-    def rotate(self) -&gt;None:</span>
<span class="gi">+    def rotate(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For Emacs mode, rotate the kill ring.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_data(self) -&gt;ClipboardData:</span>
<span class="gi">+    def get_data(self) -&gt; ClipboardData:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return clipboard data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class DummyClipboard(Clipboard):
<span class="gu">@@ -63,6 +69,18 @@ class DummyClipboard(Clipboard):</span>
<span class="w"> </span>    Clipboard implementation that doesn&#39;t remember anything.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def set_data(self, data: ClipboardData) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_text(self, text: str) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def rotate(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_data(self) -&gt; ClipboardData:</span>
<span class="gi">+        return ClipboardData()</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicClipboard(Clipboard):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -71,5 +89,20 @@ class DynamicClipboard(Clipboard):</span>
<span class="w"> </span>    :param get_clipboard: Callable that returns a :class:`.Clipboard` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_clipboard: Callable[[], Clipboard | None]) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_clipboard: Callable[[], Clipboard | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_clipboard = get_clipboard
<span class="gi">+</span>
<span class="gi">+    def _clipboard(self) -&gt; Clipboard:</span>
<span class="gi">+        return self.get_clipboard() or DummyClipboard()</span>
<span class="gi">+</span>
<span class="gi">+    def set_data(self, data: ClipboardData) -&gt; None:</span>
<span class="gi">+        self._clipboard().set_data(data)</span>
<span class="gi">+</span>
<span class="gi">+    def set_text(self, text: str) -&gt; None:</span>
<span class="gi">+        self._clipboard().set_text(text)</span>
<span class="gi">+</span>
<span class="gi">+    def rotate(self) -&gt; None:</span>
<span class="gi">+        self._clipboard().rotate()</span>
<span class="gi">+</span>
<span class="gi">+    def get_data(self) -&gt; ClipboardData:</span>
<span class="gi">+        return self._clipboard().get_data()</span>
<span class="gh">diff --git a/src/prompt_toolkit/clipboard/in_memory.py b/src/prompt_toolkit/clipboard/in_memory.py</span>
<span class="gh">index 8c6ea6b4..d9ae0817 100644</span>
<span class="gd">--- a/src/prompt_toolkit/clipboard/in_memory.py</span>
<span class="gi">+++ b/src/prompt_toolkit/clipboard/in_memory.py</span>
<span class="gu">@@ -1,7 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>from .base import Clipboard, ClipboardData
<span class="gd">-__all__ = [&#39;InMemoryClipboard&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;InMemoryClipboard&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class InMemoryClipboard(Clipboard):
<span class="gu">@@ -12,10 +17,28 @@ class InMemoryClipboard(Clipboard):</span>
<span class="w"> </span>    This implements a kill-ring, for Emacs mode.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, data: (ClipboardData | None)=None, max_size: int=60</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, data: ClipboardData | None = None, max_size: int = 60) -&gt; None:</span>
<span class="w"> </span>        assert max_size &gt;= 1
<span class="gi">+</span>
<span class="w"> </span>        self.max_size = max_size
<span class="w"> </span>        self._ring: deque[ClipboardData] = deque()
<span class="gi">+</span>
<span class="w"> </span>        if data is not None:
<span class="w"> </span>            self.set_data(data)
<span class="gi">+</span>
<span class="gi">+    def set_data(self, data: ClipboardData) -&gt; None:</span>
<span class="gi">+        self._ring.appendleft(data)</span>
<span class="gi">+</span>
<span class="gi">+        while len(self._ring) &gt; self.max_size:</span>
<span class="gi">+            self._ring.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def get_data(self) -&gt; ClipboardData:</span>
<span class="gi">+        if self._ring:</span>
<span class="gi">+            return self._ring[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ClipboardData()</span>
<span class="gi">+</span>
<span class="gi">+    def rotate(self) -&gt; None:</span>
<span class="gi">+        if self._ring:</span>
<span class="gi">+            # Add the very first item at the end.</span>
<span class="gi">+            self._ring.append(self._ring.popleft())</span>
<span class="gh">diff --git a/src/prompt_toolkit/clipboard/pyperclip.py b/src/prompt_toolkit/clipboard/pyperclip.py</span>
<span class="gh">index 3405ec25..66eb7117 100644</span>
<span class="gd">--- a/src/prompt_toolkit/clipboard/pyperclip.py</span>
<span class="gi">+++ b/src/prompt_toolkit/clipboard/pyperclip.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import pyperclip
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.selection import SelectionType
<span class="gi">+</span>
<span class="w"> </span>from .base import Clipboard, ClipboardData
<span class="gd">-__all__ = [&#39;PyperclipClipboard&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PyperclipClipboard&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class PyperclipClipboard(Clipboard):
<span class="gu">@@ -11,5 +17,26 @@ class PyperclipClipboard(Clipboard):</span>
<span class="w"> </span>    using the pyperclip module.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._data: ClipboardData | None = None
<span class="gi">+</span>
<span class="gi">+    def set_data(self, data: ClipboardData) -&gt; None:</span>
<span class="gi">+        self._data = data</span>
<span class="gi">+        pyperclip.copy(data.text)</span>
<span class="gi">+</span>
<span class="gi">+    def get_data(self) -&gt; ClipboardData:</span>
<span class="gi">+        text = pyperclip.paste()</span>
<span class="gi">+</span>
<span class="gi">+        # When the clipboard data is equal to what we copied last time, reuse</span>
<span class="gi">+        # the `ClipboardData` instance. That way we&#39;re sure to keep the same</span>
<span class="gi">+        # `SelectionType`.</span>
<span class="gi">+        if self._data and self._data.text == text:</span>
<span class="gi">+            return self._data</span>
<span class="gi">+</span>
<span class="gi">+        # Pyperclip returned something else. Create a new `ClipboardData`</span>
<span class="gi">+        # instance.</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ClipboardData(</span>
<span class="gi">+                text=text,</span>
<span class="gi">+                type=SelectionType.LINES if &quot;\n&quot; in text else SelectionType.CHARACTERS,</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/base.py b/src/prompt_toolkit/completion/base.py</span>
<span class="gh">index 62214619..04a712df 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/base.py</span>
<span class="gu">@@ -1,15 +1,26 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import AsyncGenerator, Callable, Iterable, Sequence
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.eventloop import aclosing, generator_to_async_generator
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="w"> </span>from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples
<span class="gd">-__all__ = [&#39;Completion&#39;, &#39;Completer&#39;, &#39;ThreadedCompleter&#39;, &#39;DummyCompleter&#39;,</span>
<span class="gd">-    &#39;DynamicCompleter&#39;, &#39;CompleteEvent&#39;, &#39;ConditionalCompleter&#39;,</span>
<span class="gd">-    &#39;merge_completers&#39;, &#39;get_common_complete_suffix&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Completion&quot;,</span>
<span class="gi">+    &quot;Completer&quot;,</span>
<span class="gi">+    &quot;ThreadedCompleter&quot;,</span>
<span class="gi">+    &quot;DummyCompleter&quot;,</span>
<span class="gi">+    &quot;DynamicCompleter&quot;,</span>
<span class="gi">+    &quot;CompleteEvent&quot;,</span>
<span class="gi">+    &quot;ConditionalCompleter&quot;,</span>
<span class="gi">+    &quot;merge_completers&quot;,</span>
<span class="gi">+    &quot;get_common_complete_suffix&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Completion:
<span class="gu">@@ -28,63 +39,94 @@ class Completion:</span>
<span class="w"> </span>        This can override the `style` parameter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str, start_position: int=0, display: (</span>
<span class="gd">-        AnyFormattedText | None)=None, display_meta: (AnyFormattedText |</span>
<span class="gd">-        None)=None, style: str=&#39;&#39;, selected_style: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: str,</span>
<span class="gi">+        start_position: int = 0,</span>
<span class="gi">+        display: AnyFormattedText | None = None,</span>
<span class="gi">+        display_meta: AnyFormattedText | None = None,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+        selected_style: str = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        from prompt_toolkit.formatted_text import to_formatted_text
<span class="gi">+</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.start_position = start_position
<span class="w"> </span>        self._display_meta = display_meta
<span class="gi">+</span>
<span class="w"> </span>        if display is None:
<span class="w"> </span>            display = text
<span class="gi">+</span>
<span class="w"> </span>        self.display = to_formatted_text(display)
<span class="gi">+</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.selected_style = selected_style
<span class="gi">+</span>
<span class="w"> </span>        assert self.start_position &lt;= 0

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if isinstance(self.display, str) and self.display == self.text:
<span class="gd">-            return &#39;{}(text={!r}, start_position={!r})&#39;.format(self.</span>
<span class="gd">-                __class__.__name__, self.text, self.start_position)</span>
<span class="gi">+            return &quot;{}(text={!r}, start_position={!r})&quot;.format(</span>
<span class="gi">+                self.__class__.__name__,</span>
<span class="gi">+                self.text,</span>
<span class="gi">+                self.start_position,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            return &#39;{}(text={!r}, start_position={!r}, display={!r})&#39;.format(</span>
<span class="gd">-                self.__class__.__name__, self.text, self.start_position,</span>
<span class="gd">-                self.display)</span>
<span class="gi">+            return &quot;{}(text={!r}, start_position={!r}, display={!r})&quot;.format(</span>
<span class="gi">+                self.__class__.__name__,</span>
<span class="gi">+                self.text,</span>
<span class="gi">+                self.start_position,</span>
<span class="gi">+                self.display,</span>
<span class="gi">+            )</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, Completion):
<span class="w"> </span>            return False
<span class="gd">-        return (self.text == other.text and self.start_position == other.</span>
<span class="gd">-            start_position and self.display == other.display and self.</span>
<span class="gd">-            _display_meta == other._display_meta)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.text == other.text</span>
<span class="gi">+            and self.start_position == other.start_position</span>
<span class="gi">+            and self.display == other.display</span>
<span class="gi">+            and self._display_meta == other._display_meta</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.text, self.start_position, self.display, self.</span>
<span class="gd">-            _display_meta))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.text, self.start_position, self.display, self._display_meta))</span>

<span class="w"> </span>    @property
<span class="gd">-    def display_text(self) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;The &#39;display&#39; field as plain text.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def display_text(self) -&gt; str:</span>
<span class="gi">+        &quot;The &#39;display&#39; field as plain text.&quot;</span>
<span class="gi">+        from prompt_toolkit.formatted_text import fragment_list_to_text</span>
<span class="gi">+</span>
<span class="gi">+        return fragment_list_to_text(self.display)</span>

<span class="w"> </span>    @property
<span class="gd">-    def display_meta(self) -&gt;StyleAndTextTuples:</span>
<span class="gd">-        &quot;&quot;&quot;Return meta-text. (This is lazy when using a callable).&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def display_meta(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        &quot;Return meta-text. (This is lazy when using a callable).&quot;</span>
<span class="gi">+        from prompt_toolkit.formatted_text import to_formatted_text</span>
<span class="gi">+</span>
<span class="gi">+        return to_formatted_text(self._display_meta or &quot;&quot;)</span>

<span class="w"> </span>    @property
<span class="gd">-    def display_meta_text(self) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;The &#39;meta&#39; field as plain text.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def display_meta_text(self) -&gt; str:</span>
<span class="gi">+        &quot;The &#39;meta&#39; field as plain text.&quot;</span>
<span class="gi">+        from prompt_toolkit.formatted_text import fragment_list_to_text</span>

<span class="gd">-    def new_completion_from_position(self, position: int) -&gt;Completion:</span>
<span class="gi">+        return fragment_list_to_text(self.display_meta)</span>
<span class="gi">+</span>
<span class="gi">+    def new_completion_from_position(self, position: int) -&gt; Completion:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        (Only for internal use!)
<span class="w"> </span>        Get a new completion by splitting this one. Used by `Application` when
<span class="w"> </span>        it needs to have a list of new completions after inserting the common
<span class="w"> </span>        prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert position - self.start_position &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+        return Completion(</span>
<span class="gi">+            text=self.text[position - self.start_position :],</span>
<span class="gi">+            display=self.display,</span>
<span class="gi">+            display_meta=self._display_meta,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class CompleteEvent:
<span class="gu">@@ -102,15 +144,23 @@ class CompleteEvent:</span>
<span class="w"> </span>    `complete_while_typing`.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text_inserted: bool=False, completion_requested:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, text_inserted: bool = False, completion_requested: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert not (text_inserted and completion_requested)
<span class="gi">+</span>
<span class="gi">+        #: Automatic completion while typing.</span>
<span class="w"> </span>        self.text_inserted = text_inserted
<span class="gi">+</span>
<span class="gi">+        #: Used explicitly requested completion by pressing &#39;tab&#39;.</span>
<span class="w"> </span>        self.completion_requested = completion_requested

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(text_inserted={!r}, completion_requested={!r})&#39;.format(self</span>
<span class="gd">-            .__class__.__name__, self.text_inserted, self.completion_requested)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(text_inserted={!r}, completion_requested={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.text_inserted,</span>
<span class="gi">+            self.completion_requested,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class Completer(metaclass=ABCMeta):
<span class="gu">@@ -119,8 +169,9 @@ class Completer(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_completions(self, document: Document, complete_event: CompleteEvent</span>
<span class="gd">-        ) -&gt;Iterable[Completion]:</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This should be a generator that yields :class:`.Completion` instances.

<span class="gu">@@ -133,17 +184,20 @@ class Completer(metaclass=ABCMeta):</span>
<span class="w"> </span>        :param document: :class:`~prompt_toolkit.document.Document` instance.
<span class="w"> </span>        :param complete_event: :class:`.CompleteEvent` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while False:</span>
<span class="gi">+            yield</span>

<span class="gd">-    async def get_completions_async(self, document: Document,</span>
<span class="gd">-        complete_event: CompleteEvent) -&gt;AsyncGenerator[Completion, None]:</span>
<span class="gi">+    async def get_completions_async(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; AsyncGenerator[Completion, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asynchronous generator for completions. (Probably, you won&#39;t have to
<span class="w"> </span>        override this.)

<span class="w"> </span>        Asynchronous generator of :class:`.Completion` objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in self.get_completions(document, complete_event):</span>
<span class="gi">+            yield item</span>


<span class="w"> </span>class ThreadedCompleter(Completer):
<span class="gu">@@ -157,18 +211,78 @@ class ThreadedCompleter(Completer):</span>
<span class="w"> </span>    can already select a completion, even if not all completions are displayed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, completer: Completer) -&gt;None:</span>
<span class="gi">+    def __init__(self, completer: Completer) -&gt; None:</span>
<span class="w"> </span>        self.completer = completer

<span class="gd">-    async def get_completions_async(self, document: Document,</span>
<span class="gd">-        complete_event: CompleteEvent) -&gt;AsyncGenerator[Completion, None]:</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        return self.completer.get_completions(document, complete_event)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_completions_async(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; AsyncGenerator[Completion, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asynchronous generator of completions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # NOTE: Right now, we are consuming the `get_completions` generator in</span>
<span class="gi">+        #       a synchronous background thread, then passing the results one</span>
<span class="gi">+        #       at a time over a queue, and consuming this queue in the main</span>
<span class="gi">+        #       thread (that&#39;s what `generator_to_async_generator` does). That</span>
<span class="gi">+        #       means that if the completer is *very* slow, we&#39;ll be showing</span>
<span class="gi">+        #       completions in the UI once they are computed.</span>
<span class="gi">+</span>
<span class="gi">+        #       It&#39;s very tempting to replace this implementation with the</span>
<span class="gi">+        #       commented code below for several reasons:</span>
<span class="gi">+</span>
<span class="gi">+        #       - `generator_to_async_generator` is not perfect and hard to get</span>
<span class="gi">+        #         right. It&#39;s a lot of complexity for little gain. The</span>
<span class="gi">+        #         implementation needs a huge buffer for it to be efficient</span>
<span class="gi">+        #         when there are many completions (like 50k+).</span>
<span class="gi">+        #       - Normally, a completer is supposed to be fast, users can have</span>
<span class="gi">+        #         &quot;complete while typing&quot; enabled, and want to see the</span>
<span class="gi">+        #         completions within a second. Handling one completion at a</span>
<span class="gi">+        #         time, and rendering once we get it here doesn&#39;t make any</span>
<span class="gi">+        #         sense if this is quick anyway.</span>
<span class="gi">+        #       - Completers like `FuzzyCompleter` prepare all completions</span>
<span class="gi">+        #         anyway so that they can be sorted by accuracy before they are</span>
<span class="gi">+        #         yielded. At the point that we start yielding completions</span>
<span class="gi">+        #         here, we already have all completions.</span>
<span class="gi">+        #       - The `Buffer` class has complex logic to invalidate the UI</span>
<span class="gi">+        #         while it is consuming the completions. We don&#39;t want to</span>
<span class="gi">+        #         invalidate the UI for every completion (if there are many),</span>
<span class="gi">+        #         but we want to do it often enough so that completions are</span>
<span class="gi">+        #         being displayed while they are produced.</span>
<span class="gi">+</span>
<span class="gi">+        #       We keep the current behavior mainly for backward-compatibility.</span>
<span class="gi">+        #       Similarly, it would be better for this function to not return</span>
<span class="gi">+        #       an async generator, but simply be a coroutine that returns a</span>
<span class="gi">+        #       list of `Completion` objects, containing all completions at</span>
<span class="gi">+        #       once.</span>
<span class="gi">+</span>
<span class="gi">+        #       Note that this argument doesn&#39;t mean we shouldn&#39;t use</span>
<span class="gi">+        #       `ThreadedCompleter`. It still makes sense to produce</span>
<span class="gi">+        #       completions in a background thread, because we don&#39;t want to</span>
<span class="gi">+        #       freeze the UI while the user is typing. But sending the</span>
<span class="gi">+        #       completions one at a time to the UI maybe isn&#39;t worth it.</span>
<span class="gi">+</span>
<span class="gi">+        # def get_all_in_thread() -&gt; List[Completion]:</span>
<span class="gi">+        #   return list(self.get_completions(document, complete_event))</span>
<span class="gi">+</span>
<span class="gi">+        # completions = await get_running_loop().run_in_executor(None, get_all_in_thread)</span>
<span class="gi">+        # for completion in completions:</span>
<span class="gi">+        #   yield completion</span>
<span class="gi">+</span>
<span class="gi">+        async with aclosing(</span>
<span class="gi">+            generator_to_async_generator(</span>
<span class="gi">+                lambda: self.completer.get_completions(document, complete_event)</span>
<span class="gi">+            )</span>
<span class="gi">+        ) as async_generator:</span>
<span class="gi">+            async for completion in async_generator:</span>
<span class="gi">+                yield completion</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;ThreadedCompleter({self.completer!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;ThreadedCompleter({self.completer!r})&quot;</span>


<span class="w"> </span>class DummyCompleter(Completer):
<span class="gu">@@ -176,8 +290,13 @@ class DummyCompleter(Completer):</span>
<span class="w"> </span>    A completer that doesn&#39;t return any completion.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;DummyCompleter()&#39;</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;DummyCompleter()&quot;</span>


<span class="w"> </span>class DynamicCompleter(Completer):
<span class="gu">@@ -187,13 +306,27 @@ class DynamicCompleter(Completer):</span>
<span class="w"> </span>    :param get_completer: Callable that returns a :class:`.Completer` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_completer: Callable[[], Completer | None]) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_completer: Callable[[], Completer | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_completer = get_completer

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;DynamicCompleter({self.get_completer!r} -&gt; {self.get_completer()!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        completer = self.get_completer() or DummyCompleter()</span>
<span class="gi">+        return completer.get_completions(document, complete_event)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_completions_async(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; AsyncGenerator[Completion, None]:</span>
<span class="gi">+        completer = self.get_completer() or DummyCompleter()</span>
<span class="gi">+</span>
<span class="gi">+        async for completion in completer.get_completions_async(</span>
<span class="gi">+            document, complete_event</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield completion</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;DynamicCompleter({self.get_completer!r} -&gt; {self.get_completer()!r})&quot;</span>


<span class="w"> </span>class ConditionalCompleter(Completer):
<span class="gu">@@ -205,14 +338,30 @@ class ConditionalCompleter(Completer):</span>
<span class="w"> </span>    :param filter: :class:`.Filter` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, completer: Completer, filter: FilterOrBool) -&gt;None:</span>
<span class="gi">+    def __init__(self, completer: Completer, filter: FilterOrBool) -&gt; None:</span>
<span class="w"> </span>        self.completer = completer
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;ConditionalCompleter({self.completer!r}, filter={self.filter!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;ConditionalCompleter({self.completer!r}, filter={self.filter!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        # Get all completions in a blocking way.</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            yield from self.completer.get_completions(document, complete_event)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_completions_async(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; AsyncGenerator[Completion, None]:</span>
<span class="gi">+        # Get all completions in a non-blocking way.</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            async with aclosing(</span>
<span class="gi">+                self.completer.get_completions_async(document, complete_event)</span>
<span class="gi">+            ) as async_generator:</span>
<span class="gi">+                async for item in async_generator:</span>
<span class="gi">+                    yield item</span>


<span class="w"> </span>class _MergedCompleter(Completer):
<span class="gu">@@ -220,12 +369,31 @@ class _MergedCompleter(Completer):</span>
<span class="w"> </span>    Combine several completers into one.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, completers: Sequence[Completer]) -&gt;None:</span>
<span class="gi">+    def __init__(self, completers: Sequence[Completer]) -&gt; None:</span>
<span class="w"> </span>        self.completers = completers

<span class="gd">-</span>
<span class="gd">-def merge_completers(completers: Sequence[Completer], deduplicate: bool=False</span>
<span class="gd">-    ) -&gt;Completer:</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        # Get all completions from the other completers in a blocking way.</span>
<span class="gi">+        for completer in self.completers:</span>
<span class="gi">+            yield from completer.get_completions(document, complete_event)</span>
<span class="gi">+</span>
<span class="gi">+    async def get_completions_async(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; AsyncGenerator[Completion, None]:</span>
<span class="gi">+        # Get all completions from the other completers in a non-blocking way.</span>
<span class="gi">+        for completer in self.completers:</span>
<span class="gi">+            async with aclosing(</span>
<span class="gi">+                completer.get_completions_async(document, complete_event)</span>
<span class="gi">+            ) as async_generator:</span>
<span class="gi">+                async for item in async_generator:</span>
<span class="gi">+                    yield item</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge_completers(</span>
<span class="gi">+    completers: Sequence[Completer], deduplicate: bool = False</span>
<span class="gi">+) -&gt; Completer:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Combine several completers into one.

<span class="gu">@@ -233,12 +401,51 @@ def merge_completers(completers: Sequence[Completer], deduplicate: bool=False</span>
<span class="w"> </span>        so that completions that would result in the same text will be
<span class="w"> </span>        deduplicated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if deduplicate:</span>
<span class="gi">+        from .deduplicate import DeduplicateCompleter</span>
<span class="gi">+</span>
<span class="gi">+        return DeduplicateCompleter(_MergedCompleter(completers))</span>
<span class="gi">+</span>
<span class="gi">+    return _MergedCompleter(completers)</span>


<span class="gd">-def get_common_complete_suffix(document: Document, completions: Sequence[</span>
<span class="gd">-    Completion]) -&gt;str:</span>
<span class="gi">+def get_common_complete_suffix(</span>
<span class="gi">+    document: Document, completions: Sequence[Completion]</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the common prefix for all completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Take only completions that don&#39;t change the text before the cursor.</span>
<span class="gi">+    def doesnt_change_before_cursor(completion: Completion) -&gt; bool:</span>
<span class="gi">+        end = completion.text[: -completion.start_position]</span>
<span class="gi">+        return document.text_before_cursor.endswith(end)</span>
<span class="gi">+</span>
<span class="gi">+    completions2 = [c for c in completions if doesnt_change_before_cursor(c)]</span>
<span class="gi">+</span>
<span class="gi">+    # When there is at least one completion that changes the text before the</span>
<span class="gi">+    # cursor, don&#39;t return any common part.</span>
<span class="gi">+    if len(completions2) != len(completions):</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Return the common prefix.</span>
<span class="gi">+    def get_suffix(completion: Completion) -&gt; str:</span>
<span class="gi">+        return completion.text[-completion.start_position :]</span>
<span class="gi">+</span>
<span class="gi">+    return _commonprefix([get_suffix(c) for c in completions2])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _commonprefix(strings: Iterable[str]) -&gt; str:</span>
<span class="gi">+    # Similar to os.path.commonprefix</span>
<span class="gi">+    if not strings:</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        s1 = min(strings)</span>
<span class="gi">+        s2 = max(strings)</span>
<span class="gi">+</span>
<span class="gi">+        for i, c in enumerate(s1):</span>
<span class="gi">+            if c != s2[i]:</span>
<span class="gi">+                return s1[:i]</span>
<span class="gi">+</span>
<span class="gi">+        return s1</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/deduplicate.py b/src/prompt_toolkit/completion/deduplicate.py</span>
<span class="gh">index 5860f486..c3d52566 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/deduplicate.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/deduplicate.py</span>
<span class="gu">@@ -1,8 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="gi">+</span>
<span class="w"> </span>from .base import CompleteEvent, Completer, Completion
<span class="gd">-__all__ = [&#39;DeduplicateCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;DeduplicateCompleter&quot;]</span>


<span class="w"> </span>class DeduplicateCompleter(Completer):
<span class="gu">@@ -14,5 +18,28 @@ class DeduplicateCompleter(Completer):</span>
<span class="w"> </span>    document text when they would be applied.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, completer: Completer) -&gt;None:</span>
<span class="gi">+    def __init__(self, completer: Completer) -&gt; None:</span>
<span class="w"> </span>        self.completer = completer
<span class="gi">+</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        # Keep track of the document strings we&#39;d get after applying any completion.</span>
<span class="gi">+        found_so_far: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        for completion in self.completer.get_completions(document, complete_event):</span>
<span class="gi">+            text_if_applied = (</span>
<span class="gi">+                document.text[: document.cursor_position + completion.start_position]</span>
<span class="gi">+                + completion.text</span>
<span class="gi">+                + document.text[document.cursor_position :]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if text_if_applied == document.text:</span>
<span class="gi">+                # Don&#39;t include completions that don&#39;t have any effect at all.</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if text_if_applied in found_so_far:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            found_so_far.add(text_if_applied)</span>
<span class="gi">+            yield completion</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/filesystem.py b/src/prompt_toolkit/completion/filesystem.py</span>
<span class="gh">index 729dddb2..8e7f87e0 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/filesystem.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/filesystem.py</span>
<span class="gu">@@ -1,9 +1,15 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from typing import Callable, Iterable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.completion import CompleteEvent, Completer, Completion
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="gd">-__all__ = [&#39;PathCompleter&#39;, &#39;ExecutableCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PathCompleter&quot;,</span>
<span class="gi">+    &quot;ExecutableCompleter&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class PathCompleter(Completer):
<span class="gu">@@ -18,22 +24,95 @@ class PathCompleter(Completer):</span>
<span class="w"> </span>    :param min_input_len: Don&#39;t do autocompletion when the input string is shorter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, only_directories: bool=False, get_paths: (Callable[[</span>
<span class="gd">-        ], list[str]] | None)=None, file_filter: (Callable[[str], bool] |</span>
<span class="gd">-        None)=None, min_input_len: int=0, expanduser: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        only_directories: bool = False,</span>
<span class="gi">+        get_paths: Callable[[], list[str]] | None = None,</span>
<span class="gi">+        file_filter: Callable[[str], bool] | None = None,</span>
<span class="gi">+        min_input_len: int = 0,</span>
<span class="gi">+        expanduser: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.only_directories = only_directories
<span class="gd">-        self.get_paths = get_paths or (lambda : [&#39;.&#39;])</span>
<span class="gi">+        self.get_paths = get_paths or (lambda: [&quot;.&quot;])</span>
<span class="w"> </span>        self.file_filter = file_filter or (lambda _: True)
<span class="w"> </span>        self.min_input_len = min_input_len
<span class="w"> </span>        self.expanduser = expanduser

<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        text = document.text_before_cursor</span>
<span class="gi">+</span>
<span class="gi">+        # Complete only when we have at least the minimal input length,</span>
<span class="gi">+        # otherwise, we can too many results and autocompletion will become too</span>
<span class="gi">+        # heavy.</span>
<span class="gi">+        if len(text) &lt; self.min_input_len:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Do tilde expansion.</span>
<span class="gi">+            if self.expanduser:</span>
<span class="gi">+                text = os.path.expanduser(text)</span>
<span class="gi">+</span>
<span class="gi">+            # Directories where to look.</span>
<span class="gi">+            dirname = os.path.dirname(text)</span>
<span class="gi">+            if dirname:</span>
<span class="gi">+                directories = [</span>
<span class="gi">+                    os.path.dirname(os.path.join(p, text)) for p in self.get_paths()</span>
<span class="gi">+                ]</span>
<span class="gi">+            else:</span>
<span class="gi">+                directories = self.get_paths()</span>
<span class="gi">+</span>
<span class="gi">+            # Start of current file.</span>
<span class="gi">+            prefix = os.path.basename(text)</span>
<span class="gi">+</span>
<span class="gi">+            # Get all filenames.</span>
<span class="gi">+            filenames = []</span>
<span class="gi">+            for directory in directories:</span>
<span class="gi">+                # Look for matches in this directory.</span>
<span class="gi">+                if os.path.isdir(directory):</span>
<span class="gi">+                    for filename in os.listdir(directory):</span>
<span class="gi">+                        if filename.startswith(prefix):</span>
<span class="gi">+                            filenames.append((directory, filename))</span>
<span class="gi">+</span>
<span class="gi">+            # Sort</span>
<span class="gi">+            filenames = sorted(filenames, key=lambda k: k[1])</span>
<span class="gi">+</span>
<span class="gi">+            # Yield them.</span>
<span class="gi">+            for directory, filename in filenames:</span>
<span class="gi">+                completion = filename[len(prefix) :]</span>
<span class="gi">+                full_name = os.path.join(directory, filename)</span>
<span class="gi">+</span>
<span class="gi">+                if os.path.isdir(full_name):</span>
<span class="gi">+                    # For directories, add a slash to the filename.</span>
<span class="gi">+                    # (We don&#39;t add them to the `completion`. Users can type it</span>
<span class="gi">+                    # to trigger the autocompletion themselves.)</span>
<span class="gi">+                    filename += &quot;/&quot;</span>
<span class="gi">+                elif self.only_directories:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if not self.file_filter(full_name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                yield Completion(</span>
<span class="gi">+                    text=completion,</span>
<span class="gi">+                    start_position=0,</span>
<span class="gi">+                    display=filename,</span>
<span class="gi">+                )</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>

<span class="w"> </span>class ExecutableCompleter(PathCompleter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Complete only executable files in the current path.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        super().__init__(only_directories=False, min_input_len=1, get_paths</span>
<span class="gd">-            =lambda : os.environ.get(&#39;PATH&#39;, &#39;&#39;).split(os.pathsep),</span>
<span class="gd">-            file_filter=lambda name: os.access(name, os.X_OK), expanduser=True)</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            only_directories=False,</span>
<span class="gi">+            min_input_len=1,</span>
<span class="gi">+            get_paths=lambda: os.environ.get(&quot;PATH&quot;, &quot;&quot;).split(os.pathsep),</span>
<span class="gi">+            file_filter=lambda name: os.access(name, os.X_OK),</span>
<span class="gi">+            expanduser=True,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/fuzzy_completer.py b/src/prompt_toolkit/completion/fuzzy_completer.py</span>
<span class="gh">index fc4b7e20..25ea8923 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/fuzzy_completer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/fuzzy_completer.py</span>
<span class="gu">@@ -1,12 +1,19 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import Callable, Iterable, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="w"> </span>from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples
<span class="gi">+</span>
<span class="w"> </span>from .base import CompleteEvent, Completer, Completion
<span class="w"> </span>from .word_completer import WordCompleter
<span class="gd">-__all__ = [&#39;FuzzyCompleter&#39;, &#39;FuzzyWordCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;FuzzyCompleter&quot;,</span>
<span class="gi">+    &quot;FuzzyWordCompleter&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class FuzzyCompleter(Completer):
<span class="gu">@@ -38,21 +45,133 @@ class FuzzyCompleter(Completer):</span>
<span class="w"> </span>        easily turning fuzzyness on or off according to a certain condition.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, completer: Completer, WORD: bool=False, pattern: (</span>
<span class="gd">-        str | None)=None, enable_fuzzy: FilterOrBool=True) -&gt;None:</span>
<span class="gd">-        assert pattern is None or pattern.startswith(&#39;^&#39;)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        completer: Completer,</span>
<span class="gi">+        WORD: bool = False,</span>
<span class="gi">+        pattern: str | None = None,</span>
<span class="gi">+        enable_fuzzy: FilterOrBool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert pattern is None or pattern.startswith(&quot;^&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.completer = completer
<span class="w"> </span>        self.pattern = pattern
<span class="w"> </span>        self.WORD = WORD
<span class="w"> </span>        self.pattern = pattern
<span class="w"> </span>        self.enable_fuzzy = to_filter(enable_fuzzy)

<span class="gd">-    def _get_display(self, fuzzy_match: _FuzzyMatch, word_before_cursor: str</span>
<span class="gd">-        ) -&gt;AnyFormattedText:</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        if self.enable_fuzzy():</span>
<span class="gi">+            return self._get_fuzzy_completions(document, complete_event)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.completer.get_completions(document, complete_event)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_pattern(self) -&gt; str:</span>
<span class="gi">+        if self.pattern:</span>
<span class="gi">+            return self.pattern</span>
<span class="gi">+        if self.WORD:</span>
<span class="gi">+            return r&quot;[^\s]+&quot;</span>
<span class="gi">+        return &quot;^[a-zA-Z0-9_]*&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _get_fuzzy_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        word_before_cursor = document.get_word_before_cursor(</span>
<span class="gi">+            pattern=re.compile(self._get_pattern())</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Get completions</span>
<span class="gi">+        document2 = Document(</span>
<span class="gi">+            text=document.text[: document.cursor_position - len(word_before_cursor)],</span>
<span class="gi">+            cursor_position=document.cursor_position - len(word_before_cursor),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        inner_completions = list(</span>
<span class="gi">+            self.completer.get_completions(document2, complete_event)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        fuzzy_matches: list[_FuzzyMatch] = []</span>
<span class="gi">+</span>
<span class="gi">+        if word_before_cursor == &quot;&quot;:</span>
<span class="gi">+            # If word before the cursor is an empty string, consider all</span>
<span class="gi">+            # completions, without filtering everything with an empty regex</span>
<span class="gi">+            # pattern.</span>
<span class="gi">+            fuzzy_matches = [_FuzzyMatch(0, 0, compl) for compl in inner_completions]</span>
<span class="gi">+        else:</span>
<span class="gi">+            pat = &quot;.*?&quot;.join(map(re.escape, word_before_cursor))</span>
<span class="gi">+            pat = f&quot;(?=({pat}))&quot;  # lookahead regex to manage overlapping matches</span>
<span class="gi">+            regex = re.compile(pat, re.IGNORECASE)</span>
<span class="gi">+            for compl in inner_completions:</span>
<span class="gi">+                matches = list(regex.finditer(compl.text))</span>
<span class="gi">+                if matches:</span>
<span class="gi">+                    # Prefer the match, closest to the left, then shortest.</span>
<span class="gi">+                    best = min(matches, key=lambda m: (m.start(), len(m.group(1))))</span>
<span class="gi">+                    fuzzy_matches.append(</span>
<span class="gi">+                        _FuzzyMatch(len(best.group(1)), best.start(), compl)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            def sort_key(fuzzy_match: _FuzzyMatch) -&gt; tuple[int, int]:</span>
<span class="gi">+                &quot;Sort by start position, then by the length of the match.&quot;</span>
<span class="gi">+                return fuzzy_match.start_pos, fuzzy_match.match_length</span>
<span class="gi">+</span>
<span class="gi">+            fuzzy_matches = sorted(fuzzy_matches, key=sort_key)</span>
<span class="gi">+</span>
<span class="gi">+        for match in fuzzy_matches:</span>
<span class="gi">+            # Include these completions, but set the correct `display`</span>
<span class="gi">+            # attribute and `start_position`.</span>
<span class="gi">+            yield Completion(</span>
<span class="gi">+                text=match.completion.text,</span>
<span class="gi">+                start_position=match.completion.start_position</span>
<span class="gi">+                - len(word_before_cursor),</span>
<span class="gi">+                # We access to private `_display_meta` attribute, because that one is lazy.</span>
<span class="gi">+                display_meta=match.completion._display_meta,</span>
<span class="gi">+                display=self._get_display(match, word_before_cursor),</span>
<span class="gi">+                style=match.completion.style,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_display(</span>
<span class="gi">+        self, fuzzy_match: _FuzzyMatch, word_before_cursor: str</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate formatted text for the display label.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def get_display() -&gt; AnyFormattedText:</span>
<span class="gi">+            m = fuzzy_match</span>
<span class="gi">+            word = m.completion.text</span>
<span class="gi">+</span>
<span class="gi">+            if m.match_length == 0:</span>
<span class="gi">+                # No highlighting when we have zero length matches (no input text).</span>
<span class="gi">+                # In this case, use the original display text (which can include</span>
<span class="gi">+                # additional styling or characters).</span>
<span class="gi">+                return m.completion.display</span>
<span class="gi">+</span>
<span class="gi">+            result: StyleAndTextTuples = []</span>
<span class="gi">+</span>
<span class="gi">+            # Text before match.</span>
<span class="gi">+            result.append((&quot;class:fuzzymatch.outside&quot;, word[: m.start_pos]))</span>
<span class="gi">+</span>
<span class="gi">+            # The match itself.</span>
<span class="gi">+            characters = list(word_before_cursor)</span>
<span class="gi">+</span>
<span class="gi">+            for c in word[m.start_pos : m.start_pos + m.match_length]:</span>
<span class="gi">+                classname = &quot;class:fuzzymatch.inside&quot;</span>
<span class="gi">+                if characters and c.lower() == characters[0].lower():</span>
<span class="gi">+                    classname += &quot;.character&quot;</span>
<span class="gi">+                    del characters[0]</span>
<span class="gi">+</span>
<span class="gi">+                result.append((classname, c))</span>
<span class="gi">+</span>
<span class="gi">+            # Text after match.</span>
<span class="gi">+            result.append(</span>
<span class="gi">+                (&quot;class:fuzzymatch.outside&quot;, word[m.start_pos + m.match_length :])</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return get_display()</span>


<span class="w"> </span>class FuzzyWordCompleter(Completer):
<span class="gu">@@ -66,15 +185,26 @@ class FuzzyWordCompleter(Completer):</span>
<span class="w"> </span>    :param WORD: When True, use WORD characters.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, words: (list[str] | Callable[[], list[str]]),</span>
<span class="gd">-        meta_dict: (dict[str, str] | None)=None, WORD: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        words: list[str] | Callable[[], list[str]],</span>
<span class="gi">+        meta_dict: dict[str, str] | None = None,</span>
<span class="gi">+        WORD: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.words = words
<span class="w"> </span>        self.meta_dict = meta_dict or {}
<span class="w"> </span>        self.WORD = WORD
<span class="gd">-        self.word_completer = WordCompleter(words=self.words, WORD=self.</span>
<span class="gd">-            WORD, meta_dict=self.meta_dict)</span>
<span class="gd">-        self.fuzzy_completer = FuzzyCompleter(self.word_completer, WORD=</span>
<span class="gd">-            self.WORD)</span>
<span class="gi">+</span>
<span class="gi">+        self.word_completer = WordCompleter(</span>
<span class="gi">+            words=self.words, WORD=self.WORD, meta_dict=self.meta_dict</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.fuzzy_completer = FuzzyCompleter(self.word_completer, WORD=self.WORD)</span>
<span class="gi">+</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        return self.fuzzy_completer.get_completions(document, complete_event)</span>


<span class="w"> </span>class _FuzzyMatch(NamedTuple):
<span class="gh">diff --git a/src/prompt_toolkit/completion/nested.py b/src/prompt_toolkit/completion/nested.py</span>
<span class="gh">index 130f3429..a1d211ab 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/nested.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/nested.py</span>
<span class="gu">@@ -2,11 +2,16 @@</span>
<span class="w"> </span>Nestedcompleter for completion of hierarchical data structures.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Iterable, Mapping, Set, Union
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.completion import CompleteEvent, Completer, Completion
<span class="w"> </span>from prompt_toolkit.completion.word_completer import WordCompleter
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="gd">-__all__ = [&#39;NestedCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;NestedCompleter&quot;]</span>
<span class="gi">+</span>
<span class="gi">+# NestedDict = Mapping[str, Union[&#39;NestedDict&#39;, Set[str], None, Completer]]</span>
<span class="w"> </span>NestedDict = Mapping[str, Union[Any, Set[str], None, Completer]]


<span class="gu">@@ -22,18 +27,17 @@ class NestedCompleter(Completer):</span>
<span class="w"> </span>    If you need multiple levels, check out the `from_nested_dict` classmethod.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, options: dict[str, Completer | None], ignore_case:</span>
<span class="gd">-        bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, options: dict[str, Completer | None], ignore_case: bool = True</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.options = options
<span class="w"> </span>        self.ignore_case = ignore_case

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;NestedCompleter({self.options!r}, ignore_case={self.ignore_case!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;NestedCompleter({self.options!r}, ignore_case={self.ignore_case!r})&quot;</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_nested_dict(cls, data: NestedDict) -&gt;NestedCompleter:</span>
<span class="gi">+    def from_nested_dict(cls, data: NestedDict) -&gt; NestedCompleter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a `NestedCompleter`, starting from a nested dictionary data
<span class="w"> </span>        structure, like this:
<span class="gu">@@ -57,4 +61,48 @@ class NestedCompleter(Completer):</span>

<span class="w"> </span>        Values in this data structure can be a completers as well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        options: dict[str, Completer | None] = {}</span>
<span class="gi">+        for key, value in data.items():</span>
<span class="gi">+            if isinstance(value, Completer):</span>
<span class="gi">+                options[key] = value</span>
<span class="gi">+            elif isinstance(value, dict):</span>
<span class="gi">+                options[key] = cls.from_nested_dict(value)</span>
<span class="gi">+            elif isinstance(value, set):</span>
<span class="gi">+                options[key] = cls.from_nested_dict({item: None for item in value})</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert value is None</span>
<span class="gi">+                options[key] = None</span>
<span class="gi">+</span>
<span class="gi">+        return cls(options)</span>
<span class="gi">+</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        # Split document.</span>
<span class="gi">+        text = document.text_before_cursor.lstrip()</span>
<span class="gi">+        stripped_len = len(document.text_before_cursor) - len(text)</span>
<span class="gi">+</span>
<span class="gi">+        # If there is a space, check for the first term, and use a</span>
<span class="gi">+        # subcompleter.</span>
<span class="gi">+        if &quot; &quot; in text:</span>
<span class="gi">+            first_term = text.split()[0]</span>
<span class="gi">+            completer = self.options.get(first_term)</span>
<span class="gi">+</span>
<span class="gi">+            # If we have a sub completer, use this for the completions.</span>
<span class="gi">+            if completer is not None:</span>
<span class="gi">+                remaining_text = text[len(first_term) :].lstrip()</span>
<span class="gi">+                move_cursor = len(text) - len(remaining_text) + stripped_len</span>
<span class="gi">+</span>
<span class="gi">+                new_document = Document(</span>
<span class="gi">+                    remaining_text,</span>
<span class="gi">+                    cursor_position=document.cursor_position - move_cursor,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                yield from completer.get_completions(new_document, complete_event)</span>
<span class="gi">+</span>
<span class="gi">+        # No space in the input: behave exactly like `WordCompleter`.</span>
<span class="gi">+        else:</span>
<span class="gi">+            completer = WordCompleter(</span>
<span class="gi">+                list(self.options.keys()), ignore_case=self.ignore_case</span>
<span class="gi">+            )</span>
<span class="gi">+            yield from completer.get_completions(document, complete_event)</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/word_completer.py b/src/prompt_toolkit/completion/word_completer.py</span>
<span class="gh">index 60a1da8f..6ef4031f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/word_completer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/word_completer.py</span>
<span class="gu">@@ -1,9 +1,14 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable, Iterable, Mapping, Pattern
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.completion import CompleteEvent, Completer, Completion
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.formatted_text import AnyFormattedText
<span class="gd">-__all__ = [&#39;WordCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;WordCompleter&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class WordCompleter(Completer):
<span class="gu">@@ -26,13 +31,19 @@ class WordCompleter(Completer):</span>
<span class="w"> </span>        default one (see document._FIND_WORD_RE)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, words: (list[str] | Callable[[], list[str]]),</span>
<span class="gd">-        ignore_case: bool=False, display_dict: (Mapping[str,</span>
<span class="gd">-        AnyFormattedText] | None)=None, meta_dict: (Mapping[str,</span>
<span class="gd">-        AnyFormattedText] | None)=None, WORD: bool=False, sentence: bool=</span>
<span class="gd">-        False, match_middle: bool=False, pattern: (Pattern[str] | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        words: list[str] | Callable[[], list[str]],</span>
<span class="gi">+        ignore_case: bool = False,</span>
<span class="gi">+        display_dict: Mapping[str, AnyFormattedText] | None = None,</span>
<span class="gi">+        meta_dict: Mapping[str, AnyFormattedText] | None = None,</span>
<span class="gi">+        WORD: bool = False,</span>
<span class="gi">+        sentence: bool = False,</span>
<span class="gi">+        match_middle: bool = False,</span>
<span class="gi">+        pattern: Pattern[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert not (WORD and sentence)
<span class="gi">+</span>
<span class="w"> </span>        self.words = words
<span class="w"> </span>        self.ignore_case = ignore_case
<span class="w"> </span>        self.display_dict = display_dict or {}
<span class="gu">@@ -41,3 +52,43 @@ class WordCompleter(Completer):</span>
<span class="w"> </span>        self.sentence = sentence
<span class="w"> </span>        self.match_middle = match_middle
<span class="w"> </span>        self.pattern = pattern
<span class="gi">+</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        # Get list of words.</span>
<span class="gi">+        words = self.words</span>
<span class="gi">+        if callable(words):</span>
<span class="gi">+            words = words()</span>
<span class="gi">+</span>
<span class="gi">+        # Get word/text before cursor.</span>
<span class="gi">+        if self.sentence:</span>
<span class="gi">+            word_before_cursor = document.text_before_cursor</span>
<span class="gi">+        else:</span>
<span class="gi">+            word_before_cursor = document.get_word_before_cursor(</span>
<span class="gi">+                WORD=self.WORD, pattern=self.pattern</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.ignore_case:</span>
<span class="gi">+            word_before_cursor = word_before_cursor.lower()</span>
<span class="gi">+</span>
<span class="gi">+        def word_matches(word: str) -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot;True when the word before the cursor matches.&quot;&quot;&quot;</span>
<span class="gi">+            if self.ignore_case:</span>
<span class="gi">+                word = word.lower()</span>
<span class="gi">+</span>
<span class="gi">+            if self.match_middle:</span>
<span class="gi">+                return word_before_cursor in word</span>
<span class="gi">+            else:</span>
<span class="gi">+                return word.startswith(word_before_cursor)</span>
<span class="gi">+</span>
<span class="gi">+        for a in words:</span>
<span class="gi">+            if word_matches(a):</span>
<span class="gi">+                display = self.display_dict.get(a, a)</span>
<span class="gi">+                display_meta = self.meta_dict.get(a, &quot;&quot;)</span>
<span class="gi">+                yield Completion(</span>
<span class="gi">+                    text=a,</span>
<span class="gi">+                    start_position=-len(word_before_cursor),</span>
<span class="gi">+                    display=display,</span>
<span class="gi">+                    display_meta=display_meta,</span>
<span class="gi">+                )</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/completers/system.py b/src/prompt_toolkit/contrib/completers/system.py</span>
<span class="gh">index d3409c9a..5d990e52 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/completers/system.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/completers/system.py</span>
<span class="gu">@@ -1,8 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.completion.filesystem import ExecutableCompleter, PathCompleter
<span class="w"> </span>from prompt_toolkit.contrib.regular_languages.compiler import compile
<span class="w"> </span>from prompt_toolkit.contrib.regular_languages.completion import GrammarCompleter
<span class="gd">-__all__ = [&#39;SystemCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;SystemCompleter&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class SystemCompleter(GrammarCompleter):
<span class="gu">@@ -10,35 +14,51 @@ class SystemCompleter(GrammarCompleter):</span>
<span class="w"> </span>    Completer for system commands.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # Compile grammar.</span>
<span class="w"> </span>        g = compile(
<span class="gd">-            &quot;&quot;&quot;</span>
<span class="gi">+            r&quot;&quot;&quot;</span>
<span class="w"> </span>                # First we have an executable.
<span class="gd">-                (?P&lt;executable&gt;[^\\s]+)</span>
<span class="gi">+                (?P&lt;executable&gt;[^\s]+)</span>

<span class="w"> </span>                # Ignore literals in between.
<span class="w"> </span>                (
<span class="gd">-                    \\s+</span>
<span class="gi">+                    \s+</span>
<span class="w"> </span>                    (&quot;[^&quot;]*&quot; | &#39;[^&#39;]*&#39; | [^&#39;&quot;]+ )
<span class="w"> </span>                )*

<span class="gd">-                \\s+</span>
<span class="gi">+                \s+</span>

<span class="w"> </span>                # Filename as parameters.
<span class="w"> </span>                (
<span class="gd">-                    (?P&lt;filename&gt;[^\\s]+) |</span>
<span class="gd">-                    &quot;(?P&lt;double_quoted_filename&gt;[^\\s]+)&quot; |</span>
<span class="gd">-                    &#39;(?P&lt;single_quoted_filename&gt;[^\\s]+)&#39;</span>
<span class="gi">+                    (?P&lt;filename&gt;[^\s]+) |</span>
<span class="gi">+                    &quot;(?P&lt;double_quoted_filename&gt;[^\s]+)&quot; |</span>
<span class="gi">+                    &#39;(?P&lt;single_quoted_filename&gt;[^\s]+)&#39;</span>
<span class="w"> </span>                )
<span class="gd">-            &quot;&quot;&quot;</span>
<span class="gd">-            , escape_funcs={&#39;double_quoted_filename&#39;: lambda string: string</span>
<span class="gd">-            .replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;), &#39;single_quoted_filename&#39;: lambda string:</span>
<span class="gd">-            string.replace(&quot;&#39;&quot;, &quot;\\&#39;&quot;)}, unescape_funcs={</span>
<span class="gd">-            &#39;double_quoted_filename&#39;: lambda string: string.replace(&#39;\\&quot;&#39;,</span>
<span class="gd">-            &#39;&quot;&#39;), &#39;single_quoted_filename&#39;: lambda string: string.replace(</span>
<span class="gd">-            &quot;\\&#39;&quot;, &quot;&#39;&quot;)})</span>
<span class="gd">-        super().__init__(g, {&#39;executable&#39;: ExecutableCompleter(),</span>
<span class="gd">-            &#39;filename&#39;: PathCompleter(only_directories=False, expanduser=</span>
<span class="gd">-            True), &#39;double_quoted_filename&#39;: PathCompleter(only_directories</span>
<span class="gd">-            =False, expanduser=True), &#39;single_quoted_filename&#39;:</span>
<span class="gd">-            PathCompleter(only_directories=False, expanduser=True)})</span>
<span class="gi">+            &quot;&quot;&quot;,</span>
<span class="gi">+            escape_funcs={</span>
<span class="gi">+                &quot;double_quoted_filename&quot;: (lambda string: string.replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;)),</span>
<span class="gi">+                &quot;single_quoted_filename&quot;: (lambda string: string.replace(&quot;&#39;&quot;, &quot;\\&#39;&quot;)),</span>
<span class="gi">+            },</span>
<span class="gi">+            unescape_funcs={</span>
<span class="gi">+                &quot;double_quoted_filename&quot;: (</span>
<span class="gi">+                    lambda string: string.replace(&#39;\\&quot;&#39;, &#39;&quot;&#39;)</span>
<span class="gi">+                ),  # XXX: not entirely correct.</span>
<span class="gi">+                &quot;single_quoted_filename&quot;: (lambda string: string.replace(&quot;\\&#39;&quot;, &quot;&#39;&quot;)),</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Create GrammarCompleter</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            g,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;executable&quot;: ExecutableCompleter(),</span>
<span class="gi">+                &quot;filename&quot;: PathCompleter(only_directories=False, expanduser=True),</span>
<span class="gi">+                &quot;double_quoted_filename&quot;: PathCompleter(</span>
<span class="gi">+                    only_directories=False, expanduser=True</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;single_quoted_filename&quot;: PathCompleter(</span>
<span class="gi">+                    only_directories=False, expanduser=True</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/compiler.py b/src/prompt_toolkit/contrib/regular_languages/compiler.py</span>
<span class="gh">index b154d948..474f6cfd 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/compiler.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/compiler.py</span>
<span class="gu">@@ -1,10 +1,10 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+r&quot;&quot;&quot;</span>
<span class="w"> </span>Compiler for a regular grammar.

<span class="w"> </span>Example usage::

<span class="w"> </span>    # Create and compile grammar.
<span class="gd">-    p = compile(&#39;add \\s+ (?P&lt;var1&gt;[^\\s]+)  \\s+  (?P&lt;var2&gt;[^\\s]+)&#39;)</span>
<span class="gi">+    p = compile(&#39;add \s+ (?P&lt;var1&gt;[^\s]+)  \s+  (?P&lt;var2&gt;[^\s]+)&#39;)</span>

<span class="w"> </span>    # Match input string.
<span class="w"> </span>    m = p.match(&#39;add 23 432&#39;)
<span class="gu">@@ -19,10 +19,10 @@ Partial matches are possible::</span>
<span class="w"> </span>    # Create and compile grammar.
<span class="w"> </span>    p = compile(&#39;&#39;&#39;
<span class="w"> </span>        # Operators with two arguments.
<span class="gd">-        ((?P&lt;operator1&gt;[^\\s]+)  \\s+ (?P&lt;var1&gt;[^\\s]+)  \\s+  (?P&lt;var2&gt;[^\\s]+)) |</span>
<span class="gi">+        ((?P&lt;operator1&gt;[^\s]+)  \s+ (?P&lt;var1&gt;[^\s]+)  \s+  (?P&lt;var2&gt;[^\s]+)) |</span>

<span class="w"> </span>        # Operators with only one arguments.
<span class="gd">-        ((?P&lt;operator2&gt;[^\\s]+)  \\s+ (?P&lt;var1&gt;[^\\s]+))</span>
<span class="gi">+        ((?P&lt;operator2&gt;[^\s]+)  \s+ (?P&lt;var1&gt;[^\s]+))</span>
<span class="w"> </span>    &#39;&#39;&#39;)

<span class="w"> </span>    # Match partial input string.
<span class="gu">@@ -39,12 +39,33 @@ Partial matches are possible::</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import Callable, Dict, Iterable, Iterator, Pattern
<span class="w"> </span>from typing import Match as RegexMatch
<span class="gd">-from .regex_parser import AnyNode, Lookahead, Node, NodeSequence, Regex, Repeat, Variable, parse_regex, tokenize_regex</span>
<span class="gd">-__all__ = [&#39;compile&#39;]</span>
<span class="gd">-_INVALID_TRAILING_INPUT = &#39;invalid_trailing&#39;</span>
<span class="gi">+</span>
<span class="gi">+from .regex_parser import (</span>
<span class="gi">+    AnyNode,</span>
<span class="gi">+    Lookahead,</span>
<span class="gi">+    Node,</span>
<span class="gi">+    NodeSequence,</span>
<span class="gi">+    Regex,</span>
<span class="gi">+    Repeat,</span>
<span class="gi">+    Variable,</span>
<span class="gi">+    parse_regex,</span>
<span class="gi">+    tokenize_regex,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;compile&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Name of the named group in the regex, matching trailing input.</span>
<span class="gi">+# (Trailing input is when the input contains characters after the end of the</span>
<span class="gi">+# expression has been matched.)</span>
<span class="gi">+_INVALID_TRAILING_INPUT = &quot;invalid_trailing&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>EscapeFuncDict = Dict[str, Callable[[str], str]]


<span class="gu">@@ -58,46 +79,69 @@ class _CompiledGrammar:</span>
<span class="w"> </span>    :param unescape_funcs: `dict` mapping variable names to unescape callables.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, root_node: Node, escape_funcs: (EscapeFuncDict |</span>
<span class="gd">-        None)=None, unescape_funcs: (EscapeFuncDict | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        root_node: Node,</span>
<span class="gi">+        escape_funcs: EscapeFuncDict | None = None,</span>
<span class="gi">+        unescape_funcs: EscapeFuncDict | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.root_node = root_node
<span class="w"> </span>        self.escape_funcs = escape_funcs or {}
<span class="w"> </span>        self.unescape_funcs = unescape_funcs or {}
<span class="gd">-        self._group_names_to_nodes: dict[str, str] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: Dictionary that will map the regex names to Node instances.</span>
<span class="gi">+        self._group_names_to_nodes: dict[</span>
<span class="gi">+            str, str</span>
<span class="gi">+        ] = {}  # Maps regex group names to varnames.</span>
<span class="w"> </span>        counter = [0]

<span class="gd">-        def create_group_func(node: Variable) -&gt;str:</span>
<span class="gd">-            name = &#39;n%s&#39; % counter[0]</span>
<span class="gi">+        def create_group_func(node: Variable) -&gt; str:</span>
<span class="gi">+            name = &quot;n%s&quot; % counter[0]</span>
<span class="w"> </span>            self._group_names_to_nodes[name] = node.varname
<span class="w"> </span>            counter[0] += 1
<span class="w"> </span>            return name
<span class="gd">-        self._re_pattern = &#39;^%s$&#39; % self._transform(root_node,</span>
<span class="gd">-            create_group_func)</span>
<span class="gd">-        self._re_prefix_patterns = list(self._transform_prefix(root_node,</span>
<span class="gd">-            create_group_func))</span>
<span class="gd">-        flags = re.DOTALL</span>
<span class="gd">-        self._re = re.compile(self._re_pattern, flags)</span>
<span class="gd">-        self._re_prefix = [re.compile(t, flags) for t in self.</span>
<span class="gd">-            _re_prefix_patterns]</span>
<span class="gd">-        self._re_prefix_with_trailing_input = [re.compile(</span>
<span class="gd">-            &#39;(?:{})(?P&lt;{}&gt;.*?)$&#39;.format(t.rstrip(&#39;$&#39;),</span>
<span class="gd">-            _INVALID_TRAILING_INPUT), flags) for t in self._re_prefix_patterns]</span>

<span class="gd">-    def escape(self, varname: str, value: str) -&gt;str:</span>
<span class="gi">+        # Compile regex strings.</span>
<span class="gi">+        self._re_pattern = &quot;^%s$&quot; % self._transform(root_node, create_group_func)</span>
<span class="gi">+        self._re_prefix_patterns = list(</span>
<span class="gi">+            self._transform_prefix(root_node, create_group_func)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Compile the regex itself.</span>
<span class="gi">+        flags = re.DOTALL  # Note that we don&#39;t need re.MULTILINE! (^ and $</span>
<span class="gi">+        # still represent the start and end of input text.)</span>
<span class="gi">+        self._re = re.compile(self._re_pattern, flags)</span>
<span class="gi">+        self._re_prefix = [re.compile(t, flags) for t in self._re_prefix_patterns]</span>
<span class="gi">+</span>
<span class="gi">+        # We compile one more set of regexes, similar to `_re_prefix`, but accept any trailing</span>
<span class="gi">+        # input. This will ensure that we can still highlight the input correctly, even when the</span>
<span class="gi">+        # input contains some additional characters at the end that don&#39;t match the grammar.)</span>
<span class="gi">+        self._re_prefix_with_trailing_input = [</span>
<span class="gi">+            re.compile(</span>
<span class="gi">+                r&quot;(?:{})(?P&lt;{}&gt;.*?)$&quot;.format(t.rstrip(&quot;$&quot;), _INVALID_TRAILING_INPUT),</span>
<span class="gi">+                flags,</span>
<span class="gi">+            )</span>
<span class="gi">+            for t in self._re_prefix_patterns</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def escape(self, varname: str, value: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Escape `value` to fit in the place of this variable into the grammar.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = self.escape_funcs.get(varname)</span>
<span class="gi">+        return f(value) if f else value</span>

<span class="gd">-    def unescape(self, varname: str, value: str) -&gt;str:</span>
<span class="gi">+    def unescape(self, varname: str, value: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Unescape `value`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = self.unescape_funcs.get(varname)</span>
<span class="gi">+        return f(value) if f else value</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def _transform(cls, root_node: Node, create_group_func: Callable[[</span>
<span class="gd">-        Variable], str]) -&gt;str:</span>
<span class="gi">+    def _transform(</span>
<span class="gi">+        cls, root_node: Node, create_group_func: Callable[[Variable], str]</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Turn a :class:`Node` object into a regular expression.

<span class="gu">@@ -105,11 +149,55 @@ class _CompiledGrammar:</span>
<span class="w"> </span>        :param create_group_func: A callable which takes a `Node` and returns the next
<span class="w"> </span>            free name for this node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def transform(node: Node) -&gt; str:</span>
<span class="gi">+            # Turn `AnyNode` into an OR.</span>
<span class="gi">+            if isinstance(node, AnyNode):</span>
<span class="gi">+                return &quot;(?:%s)&quot; % &quot;|&quot;.join(transform(c) for c in node.children)</span>
<span class="gi">+</span>
<span class="gi">+            # Concatenate a `NodeSequence`</span>
<span class="gi">+            elif isinstance(node, NodeSequence):</span>
<span class="gi">+                return &quot;&quot;.join(transform(c) for c in node.children)</span>
<span class="gi">+</span>
<span class="gi">+            # For Regex and Lookahead nodes, just insert them literally.</span>
<span class="gi">+            elif isinstance(node, Regex):</span>
<span class="gi">+                return node.regex</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(node, Lookahead):</span>
<span class="gi">+                before = &quot;(?!&quot; if node.negative else &quot;(=&quot;</span>
<span class="gi">+                return before + transform(node.childnode) + &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # A `Variable` wraps the children into a named group.</span>
<span class="gi">+            elif isinstance(node, Variable):</span>
<span class="gi">+                return f&quot;(?P&lt;{create_group_func(node)}&gt;{transform(node.childnode)})&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # `Repeat`.</span>
<span class="gi">+            elif isinstance(node, Repeat):</span>
<span class="gi">+                if node.max_repeat is None:</span>
<span class="gi">+                    if node.min_repeat == 0:</span>
<span class="gi">+                        repeat_sign = &quot;*&quot;</span>
<span class="gi">+                    elif node.min_repeat == 1:</span>
<span class="gi">+                        repeat_sign = &quot;+&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    repeat_sign = &quot;{%i,%s}&quot; % (</span>
<span class="gi">+                        node.min_repeat,</span>
<span class="gi">+                        (&quot;&quot; if node.max_repeat is None else str(node.max_repeat)),</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                return &quot;(?:{}){}{}&quot;.format(</span>
<span class="gi">+                    transform(node.childnode),</span>
<span class="gi">+                    repeat_sign,</span>
<span class="gi">+                    (&quot;&quot; if node.greedy else &quot;?&quot;),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(f&quot;Got {node!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return transform(root_node)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def _transform_prefix(cls, root_node: Node, create_group_func: Callable</span>
<span class="gd">-        [[Variable], str]) -&gt;Iterable[str]:</span>
<span class="gi">+    def _transform_prefix(</span>
<span class="gi">+        cls, root_node: Node, create_group_func: Callable[[Variable], str]</span>
<span class="gi">+    ) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Yield all the regular expressions matching a prefix of the grammar
<span class="w"> </span>        defined by the `Node` instance.
<span class="gu">@@ -131,18 +219,157 @@ class _CompiledGrammar:</span>
<span class="w"> </span>        :param create_group_func: A callable which takes a `Node` and returns the next
<span class="w"> </span>            free name for this node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def match(self, string: str) -&gt;(Match | None):</span>
<span class="gi">+        def contains_variable(node: Node) -&gt; bool:</span>
<span class="gi">+            if isinstance(node, Regex):</span>
<span class="gi">+                return False</span>
<span class="gi">+            elif isinstance(node, Variable):</span>
<span class="gi">+                return True</span>
<span class="gi">+            elif isinstance(node, (Lookahead, Repeat)):</span>
<span class="gi">+                return contains_variable(node.childnode)</span>
<span class="gi">+            elif isinstance(node, (NodeSequence, AnyNode)):</span>
<span class="gi">+                return any(contains_variable(child) for child in node.children)</span>
<span class="gi">+</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        def transform(node: Node) -&gt; Iterable[str]:</span>
<span class="gi">+            # Generate separate pattern for all terms that contain variables</span>
<span class="gi">+            # within this OR. Terms that don&#39;t contain a variable can be merged</span>
<span class="gi">+            # together in one pattern.</span>
<span class="gi">+            if isinstance(node, AnyNode):</span>
<span class="gi">+                # If we have a definition like:</span>
<span class="gi">+                #           (?P&lt;name&gt; .*)  | (?P&lt;city&gt; .*)</span>
<span class="gi">+                # Then we want to be able to generate completions for both the</span>
<span class="gi">+                # name as well as the city. We do this by yielding two</span>
<span class="gi">+                # different regular expressions, because the engine won&#39;t</span>
<span class="gi">+                # follow multiple paths, if multiple are possible.</span>
<span class="gi">+                children_with_variable = []</span>
<span class="gi">+                children_without_variable = []</span>
<span class="gi">+                for c in node.children:</span>
<span class="gi">+                    if contains_variable(c):</span>
<span class="gi">+                        children_with_variable.append(c)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        children_without_variable.append(c)</span>
<span class="gi">+</span>
<span class="gi">+                for c in children_with_variable:</span>
<span class="gi">+                    yield from transform(c)</span>
<span class="gi">+</span>
<span class="gi">+                # Merge options without variable together.</span>
<span class="gi">+                if children_without_variable:</span>
<span class="gi">+                    yield &quot;|&quot;.join(</span>
<span class="gi">+                        r for c in children_without_variable for r in transform(c)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            # For a sequence, generate a pattern for each prefix that ends with</span>
<span class="gi">+            # a variable + one pattern of the complete sequence.</span>
<span class="gi">+            # (This is because, for autocompletion, we match the text before</span>
<span class="gi">+            # the cursor, and completions are given for the variable that we</span>
<span class="gi">+            # match right before the cursor.)</span>
<span class="gi">+            elif isinstance(node, NodeSequence):</span>
<span class="gi">+                # For all components in the sequence, compute prefix patterns,</span>
<span class="gi">+                # as well as full patterns.</span>
<span class="gi">+                complete = [cls._transform(c, create_group_func) for c in node.children]</span>
<span class="gi">+                prefixes = [list(transform(c)) for c in node.children]</span>
<span class="gi">+                variable_nodes = [contains_variable(c) for c in node.children]</span>
<span class="gi">+</span>
<span class="gi">+                # If any child is contains a variable, we should yield a</span>
<span class="gi">+                # pattern up to that point, so that we are sure this will be</span>
<span class="gi">+                # matched.</span>
<span class="gi">+                for i in range(len(node.children)):</span>
<span class="gi">+                    if variable_nodes[i]:</span>
<span class="gi">+                        for c_str in prefixes[i]:</span>
<span class="gi">+                            yield &quot;&quot;.join(complete[:i]) + c_str</span>
<span class="gi">+</span>
<span class="gi">+                # If there are non-variable nodes, merge all the prefixes into</span>
<span class="gi">+                # one pattern. If the input is: &quot;[part1] [part2] [part3]&quot;, then</span>
<span class="gi">+                # this gets compiled into:</span>
<span class="gi">+                #  (complete1 + (complete2 + (complete3  | partial3) | partial2) | partial1 )</span>
<span class="gi">+                # For nodes that contain a variable, we skip the &quot;|partial&quot;</span>
<span class="gi">+                # part here, because thees are matched with the previous</span>
<span class="gi">+                # patterns.</span>
<span class="gi">+                if not all(variable_nodes):</span>
<span class="gi">+                    result = []</span>
<span class="gi">+</span>
<span class="gi">+                    # Start with complete patterns.</span>
<span class="gi">+                    for i in range(len(node.children)):</span>
<span class="gi">+                        result.append(&quot;(?:&quot;)</span>
<span class="gi">+                        result.append(complete[i])</span>
<span class="gi">+</span>
<span class="gi">+                    # Add prefix patterns.</span>
<span class="gi">+                    for i in range(len(node.children) - 1, -1, -1):</span>
<span class="gi">+                        if variable_nodes[i]:</span>
<span class="gi">+                            # No need to yield a prefix for this one, we did</span>
<span class="gi">+                            # the variable prefixes earlier.</span>
<span class="gi">+                            result.append(&quot;)&quot;)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            result.append(&quot;|(?:&quot;)</span>
<span class="gi">+                            # If this yields multiple, we should yield all combinations.</span>
<span class="gi">+                            assert len(prefixes[i]) == 1</span>
<span class="gi">+                            result.append(prefixes[i][0])</span>
<span class="gi">+                            result.append(&quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                    yield &quot;&quot;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(node, Regex):</span>
<span class="gi">+                yield &quot;(?:%s)?&quot; % node.regex</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(node, Lookahead):</span>
<span class="gi">+                if node.negative:</span>
<span class="gi">+                    yield &quot;(?!%s)&quot; % cls._transform(node.childnode, create_group_func)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Not sure what the correct semantics are in this case.</span>
<span class="gi">+                    # (Probably it&#39;s not worth implementing this.)</span>
<span class="gi">+                    raise Exception(&quot;Positive lookahead not yet supported.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(node, Variable):</span>
<span class="gi">+                # (Note that we should not append a &#39;?&#39; here. the &#39;transform&#39;</span>
<span class="gi">+                # method will already recursively do that.)</span>
<span class="gi">+                for c_str in transform(node.childnode):</span>
<span class="gi">+                    yield f&quot;(?P&lt;{create_group_func(node)}&gt;{c_str})&quot;</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(node, Repeat):</span>
<span class="gi">+                # If we have a repetition of 8 times. That would mean that the</span>
<span class="gi">+                # current input could have for instance 7 times a complete</span>
<span class="gi">+                # match, followed by a partial match.</span>
<span class="gi">+                prefix = cls._transform(node.childnode, create_group_func)</span>
<span class="gi">+</span>
<span class="gi">+                if node.max_repeat == 1:</span>
<span class="gi">+                    yield from transform(node.childnode)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    for c_str in transform(node.childnode):</span>
<span class="gi">+                        if node.max_repeat:</span>
<span class="gi">+                            repeat_sign = &quot;{,%i}&quot; % (node.max_repeat - 1)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            repeat_sign = &quot;*&quot;</span>
<span class="gi">+                        yield &quot;(?:{}){}{}{}&quot;.format(</span>
<span class="gi">+                            prefix,</span>
<span class="gi">+                            repeat_sign,</span>
<span class="gi">+                            (&quot;&quot; if node.greedy else &quot;?&quot;),</span>
<span class="gi">+                            c_str,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(&quot;Got %r&quot; % node)</span>
<span class="gi">+</span>
<span class="gi">+        for r in transform(root_node):</span>
<span class="gi">+            yield &quot;^(?:%s)$&quot; % r</span>
<span class="gi">+</span>
<span class="gi">+    def match(self, string: str) -&gt; Match | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Match the string with the grammar.
<span class="w"> </span>        Returns a :class:`Match` instance or `None` when the input doesn&#39;t match the grammar.

<span class="w"> </span>        :param string: The input string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = self._re.match(string)</span>
<span class="gi">+</span>
<span class="gi">+        if m:</span>
<span class="gi">+            return Match(</span>
<span class="gi">+                string, [(self._re, m)], self._group_names_to_nodes, self.unescape_funcs</span>
<span class="gi">+            )</span>
<span class="gi">+        return None</span>

<span class="gd">-    def match_prefix(self, string: str) -&gt;(Match | None):</span>
<span class="gi">+    def match_prefix(self, string: str) -&gt; Match | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Do a partial match of the string with the grammar. The returned
<span class="w"> </span>        :class:`Match` instance can contain multiple representations of the
<span class="gu">@@ -151,7 +378,18 @@ class _CompiledGrammar:</span>

<span class="w"> </span>        :param string: The input string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First try to match using `_re_prefix`. If nothing is found, use the patterns that</span>
<span class="gi">+        # also accept trailing characters.</span>
<span class="gi">+        for patterns in [self._re_prefix, self._re_prefix_with_trailing_input]:</span>
<span class="gi">+            matches = [(r, r.match(string)) for r in patterns]</span>
<span class="gi">+            matches2 = [(r, m) for r, m in matches if m]</span>
<span class="gi">+</span>
<span class="gi">+            if matches2 != []:</span>
<span class="gi">+                return Match(</span>
<span class="gi">+                    string, matches2, self._group_names_to_nodes, self.unescape_funcs</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class Match:
<span class="gu">@@ -161,61 +399,119 @@ class Match:</span>
<span class="w"> </span>    :param group_names_to_nodes: Dictionary mapping all the re group names to the matching Node instances.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, string: str, re_matches: list[tuple[Pattern[str],</span>
<span class="gd">-        RegexMatch[str]]], group_names_to_nodes: dict[str, str],</span>
<span class="gd">-        unescape_funcs: dict[str, Callable[[str], str]]):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        string: str,</span>
<span class="gi">+        re_matches: list[tuple[Pattern[str], RegexMatch[str]]],</span>
<span class="gi">+        group_names_to_nodes: dict[str, str],</span>
<span class="gi">+        unescape_funcs: dict[str, Callable[[str], str]],</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.string = string
<span class="w"> </span>        self._re_matches = re_matches
<span class="w"> </span>        self._group_names_to_nodes = group_names_to_nodes
<span class="w"> </span>        self._unescape_funcs = unescape_funcs

<span class="gd">-    def _nodes_to_regs(self) -&gt;list[tuple[str, tuple[int, int]]]:</span>
<span class="gi">+    def _nodes_to_regs(self) -&gt; list[tuple[str, tuple[int, int]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of (varname, reg) tuples.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _nodes_to_values(self) -&gt;list[tuple[str, str, tuple[int, int]]]:</span>
<span class="gi">+        def get_tuples() -&gt; Iterable[tuple[str, tuple[int, int]]]:</span>
<span class="gi">+            for r, re_match in self._re_matches:</span>
<span class="gi">+                for group_name, group_index in r.groupindex.items():</span>
<span class="gi">+                    if group_name != _INVALID_TRAILING_INPUT:</span>
<span class="gi">+                        regs = re_match.regs</span>
<span class="gi">+                        reg = regs[group_index]</span>
<span class="gi">+                        node = self._group_names_to_nodes[group_name]</span>
<span class="gi">+                        yield (node, reg)</span>
<span class="gi">+</span>
<span class="gi">+        return list(get_tuples())</span>
<span class="gi">+</span>
<span class="gi">+    def _nodes_to_values(self) -&gt; list[tuple[str, str, tuple[int, int]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns list of (Node, string_value) tuples.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def variables(self) -&gt;Variables:</span>
<span class="gi">+        def is_none(sl: tuple[int, int]) -&gt; bool:</span>
<span class="gi">+            return sl[0] == -1 and sl[1] == -1</span>
<span class="gi">+</span>
<span class="gi">+        def get(sl: tuple[int, int]) -&gt; str:</span>
<span class="gi">+            return self.string[sl[0] : sl[1]]</span>
<span class="gi">+</span>
<span class="gi">+        return [</span>
<span class="gi">+            (varname, get(slice), slice)</span>
<span class="gi">+            for varname, slice in self._nodes_to_regs()</span>
<span class="gi">+            if not is_none(slice)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _unescape(self, varname: str, value: str) -&gt; str:</span>
<span class="gi">+        unwrapper = self._unescape_funcs.get(varname)</span>
<span class="gi">+        return unwrapper(value) if unwrapper else value</span>
<span class="gi">+</span>
<span class="gi">+    def variables(self) -&gt; Variables:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns :class:`Variables` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Variables(</span>
<span class="gi">+            [(k, self._unescape(k, v), sl) for k, v, sl in self._nodes_to_values()]</span>
<span class="gi">+        )</span>

<span class="gd">-    def trailing_input(self) -&gt;(MatchVariable | None):</span>
<span class="gi">+    def trailing_input(self) -&gt; MatchVariable | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the `MatchVariable` instance, representing trailing input, if there is any.
<span class="w"> </span>        &quot;Trailing input&quot; is input at the end that does not match the grammar anymore, but
<span class="w"> </span>        when this is removed from the end of the input, the input would be a valid string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def end_nodes(self) -&gt;Iterable[MatchVariable]:</span>
<span class="gi">+        slices: list[tuple[int, int]] = []</span>
<span class="gi">+</span>
<span class="gi">+        # Find all regex group for the name _INVALID_TRAILING_INPUT.</span>
<span class="gi">+        for r, re_match in self._re_matches:</span>
<span class="gi">+            for group_name, group_index in r.groupindex.items():</span>
<span class="gi">+                if group_name == _INVALID_TRAILING_INPUT:</span>
<span class="gi">+                    slices.append(re_match.regs[group_index])</span>
<span class="gi">+</span>
<span class="gi">+        # Take the smallest part. (Smaller trailing text means that a larger input has</span>
<span class="gi">+        # been matched, so that is better.)</span>
<span class="gi">+        if slices:</span>
<span class="gi">+            slice = (max(i[0] for i in slices), max(i[1] for i in slices))</span>
<span class="gi">+            value = self.string[slice[0] : slice[1]]</span>
<span class="gi">+            return MatchVariable(&quot;&lt;trailing_input&gt;&quot;, value, slice)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def end_nodes(self) -&gt; Iterable[MatchVariable]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Yields `MatchVariable` instances for all the nodes having their end
<span class="w"> </span>        position at the end of the input string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for varname, reg in self._nodes_to_regs():</span>
<span class="gi">+            # If this part goes until the end of the input string.</span>
<span class="gi">+            if reg[1] == len(self.string):</span>
<span class="gi">+                value = self._unescape(varname, self.string[reg[0] : reg[1]])</span>
<span class="gi">+                yield MatchVariable(varname, value, (reg[0], reg[1]))</span>


<span class="w"> </span>class Variables:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, tuples: list[tuple[str, str, tuple[int, int]]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, tuples: list[tuple[str, str, tuple[int, int]]]) -&gt; None:</span>
<span class="gi">+        #: List of (varname, value, slice) tuples.</span>
<span class="w"> </span>        self._tuples = tuples

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}({})&#39;.format(self.__class__.__name__, &#39;, &#39;.join(</span>
<span class="gd">-            f&#39;{k}={v!r}&#39; for k, v, _ in self._tuples))</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}({})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            &quot;, &quot;.join(f&quot;{k}={v!r}&quot; for k, v, _ in self._tuples),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key: str, default: str | None = None) -&gt; str | None:</span>
<span class="gi">+        items = self.getall(key)</span>
<span class="gi">+        return items[0] if items else default</span>
<span class="gi">+</span>
<span class="gi">+    def getall(self, key: str) -&gt; list[str]:</span>
<span class="gi">+        return [v for k, v, _ in self._tuples if k == key]</span>

<span class="gd">-    def __getitem__(self, key: str) -&gt;(str | None):</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; str | None:</span>
<span class="w"> </span>        return self.get(key)

<span class="gd">-    def __iter__(self) -&gt;Iterator[MatchVariable]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[MatchVariable]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Yield `MatchVariable` instances.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -233,32 +529,43 @@ class MatchVariable:</span>
<span class="w"> </span>                  in the input string.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, varname: str, value: str, slice: tuple[int, int]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, varname: str, value: str, slice: tuple[int, int]) -&gt; None:</span>
<span class="w"> </span>        self.varname = varname
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.slice = slice
<span class="gi">+</span>
<span class="w"> </span>        self.start = self.slice[0]
<span class="w"> </span>        self.stop = self.slice[1]

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.varname!r}, {self.value!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.varname!r}, {self.value!r})&quot;</span>


<span class="gd">-def compile(expression: str, escape_funcs: (EscapeFuncDict | None)=None,</span>
<span class="gd">-    unescape_funcs: (EscapeFuncDict | None)=None) -&gt;_CompiledGrammar:</span>
<span class="gi">+def compile(</span>
<span class="gi">+    expression: str,</span>
<span class="gi">+    escape_funcs: EscapeFuncDict | None = None,</span>
<span class="gi">+    unescape_funcs: EscapeFuncDict | None = None,</span>
<span class="gi">+) -&gt; _CompiledGrammar:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Compile grammar (given as regex string), returning a `CompiledGrammar`
<span class="w"> </span>    instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _compile_from_parse_tree(root_node: Node, escape_funcs: (EscapeFuncDict |</span>
<span class="gd">-    None)=None, unescape_funcs: (EscapeFuncDict | None)=None</span>
<span class="gd">-    ) -&gt;_CompiledGrammar:</span>
<span class="gi">+    return _compile_from_parse_tree(</span>
<span class="gi">+        parse_regex(tokenize_regex(expression)),</span>
<span class="gi">+        escape_funcs=escape_funcs,</span>
<span class="gi">+        unescape_funcs=unescape_funcs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _compile_from_parse_tree(</span>
<span class="gi">+    root_node: Node,</span>
<span class="gi">+    escape_funcs: EscapeFuncDict | None = None,</span>
<span class="gi">+    unescape_funcs: EscapeFuncDict | None = None,</span>
<span class="gi">+) -&gt; _CompiledGrammar:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Compile grammar (given as parse tree), returning a `CompiledGrammar`
<span class="w"> </span>    instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _CompiledGrammar(</span>
<span class="gi">+        root_node, escape_funcs=escape_funcs, unescape_funcs=unescape_funcs</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/completion.py b/src/prompt_toolkit/contrib/regular_languages/completion.py</span>
<span class="gh">index cf287636..2e353e8d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/completion.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/completion.py</span>
<span class="gu">@@ -2,11 +2,17 @@</span>
<span class="w"> </span>Completer for a regular grammar.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.completion import CompleteEvent, Completer, Completion
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="gi">+</span>
<span class="w"> </span>from .compiler import Match, _CompiledGrammar
<span class="gd">-__all__ = [&#39;GrammarCompleter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;GrammarCompleter&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class GrammarCompleter(Completer):
<span class="gu">@@ -19,25 +25,70 @@ class GrammarCompleter(Completer):</span>
<span class="w"> </span>                       `Completer` instances to be used for each variable.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, compiled_grammar: _CompiledGrammar, completers: dict</span>
<span class="gd">-        [str, Completer]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, compiled_grammar: _CompiledGrammar, completers: dict[str, Completer]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.compiled_grammar = compiled_grammar
<span class="w"> </span>        self.completers = completers

<span class="gd">-    def _get_completions_for_match(self, match: Match, complete_event:</span>
<span class="gd">-        CompleteEvent) -&gt;Iterable[Completion]:</span>
<span class="gi">+    def get_completions(</span>
<span class="gi">+        self, document: Document, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="gi">+        m = self.compiled_grammar.match_prefix(document.text_before_cursor)</span>
<span class="gi">+</span>
<span class="gi">+        if m:</span>
<span class="gi">+            completions = self._remove_duplicates(</span>
<span class="gi">+                self._get_completions_for_match(m, complete_event)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            yield from completions</span>
<span class="gi">+</span>
<span class="gi">+    def _get_completions_for_match(</span>
<span class="gi">+        self, match: Match, complete_event: CompleteEvent</span>
<span class="gi">+    ) -&gt; Iterable[Completion]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Yield all the possible completions for this input string.
<span class="w"> </span>        (The completer assumes that the cursor position was at the end of the
<span class="w"> </span>        input string.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for match_variable in match.end_nodes():</span>
<span class="gi">+            varname = match_variable.varname</span>
<span class="gi">+            start = match_variable.start</span>
<span class="gi">+</span>
<span class="gi">+            completer = self.completers.get(varname)</span>
<span class="gi">+</span>
<span class="gi">+            if completer:</span>
<span class="gi">+                text = match_variable.value</span>
<span class="gi">+</span>
<span class="gi">+                # Unwrap text.</span>
<span class="gi">+                unwrapped_text = self.compiled_grammar.unescape(varname, text)</span>
<span class="gi">+</span>
<span class="gi">+                # Create a document, for the completions API (text/cursor_position)</span>
<span class="gi">+                document = Document(unwrapped_text, len(unwrapped_text))</span>
<span class="gi">+</span>
<span class="gi">+                # Call completer</span>
<span class="gi">+                for completion in completer.get_completions(document, complete_event):</span>
<span class="gi">+                    new_text = (</span>
<span class="gi">+                        unwrapped_text[: len(text) + completion.start_position]</span>
<span class="gi">+                        + completion.text</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    # Wrap again.</span>
<span class="gi">+                    yield Completion(</span>
<span class="gi">+                        text=self.compiled_grammar.escape(varname, new_text),</span>
<span class="gi">+                        start_position=start - len(match.string),</span>
<span class="gi">+                        display=completion.display,</span>
<span class="gi">+                        display_meta=completion.display_meta,</span>
<span class="gi">+                    )</span>

<span class="gd">-    def _remove_duplicates(self, items: Iterable[Completion]) -&gt;list[Completion</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def _remove_duplicates(self, items: Iterable[Completion]) -&gt; list[Completion]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove duplicates, while keeping the order.
<span class="w"> </span>        (Sometimes we have duplicates, because the there several matches of the
<span class="w"> </span>        same grammar, each yielding similar completions.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result: list[Completion] = []</span>
<span class="gi">+        for i in items:</span>
<span class="gi">+            if i not in result:</span>
<span class="gi">+                result.append(i)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/lexer.py b/src/prompt_toolkit/contrib/regular_languages/lexer.py</span>
<span class="gh">index e69b634c..b0a4debe 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/lexer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/lexer.py</span>
<span class="gu">@@ -3,13 +3,19 @@</span>
<span class="w"> </span>the input using a regular grammar with annotations.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.formatted_text.base import StyleAndTextTuples
<span class="w"> </span>from prompt_toolkit.formatted_text.utils import split_lines
<span class="w"> </span>from prompt_toolkit.lexers import Lexer
<span class="gi">+</span>
<span class="w"> </span>from .compiler import _CompiledGrammar
<span class="gd">-__all__ = [&#39;GrammarLexer&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;GrammarLexer&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class GrammarLexer(Lexer):
<span class="gu">@@ -27,8 +33,61 @@ class GrammarLexer(Lexer):</span>
<span class="w"> </span>                   `prompt_toolkit.lexers.SimpleLexer`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, compiled_grammar: _CompiledGrammar, default_style:</span>
<span class="gd">-        str=&#39;&#39;, lexers: (dict[str, Lexer] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        compiled_grammar: _CompiledGrammar,</span>
<span class="gi">+        default_style: str = &quot;&quot;,</span>
<span class="gi">+        lexers: dict[str, Lexer] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.compiled_grammar = compiled_grammar
<span class="w"> </span>        self.default_style = default_style
<span class="w"> </span>        self.lexers = lexers or {}
<span class="gi">+</span>
<span class="gi">+    def _get_text_fragments(self, text: str) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        m = self.compiled_grammar.match_prefix(text)</span>
<span class="gi">+</span>
<span class="gi">+        if m:</span>
<span class="gi">+            characters: StyleAndTextTuples = [(self.default_style, c) for c in text]</span>
<span class="gi">+</span>
<span class="gi">+            for v in m.variables():</span>
<span class="gi">+                # If we have a `Lexer` instance for this part of the input.</span>
<span class="gi">+                # Tokenize recursively and apply tokens.</span>
<span class="gi">+                lexer = self.lexers.get(v.varname)</span>
<span class="gi">+</span>
<span class="gi">+                if lexer:</span>
<span class="gi">+                    document = Document(text[v.start : v.stop])</span>
<span class="gi">+                    lexer_tokens_for_line = lexer.lex_document(document)</span>
<span class="gi">+                    text_fragments: StyleAndTextTuples = []</span>
<span class="gi">+                    for i in range(len(document.lines)):</span>
<span class="gi">+                        text_fragments.extend(lexer_tokens_for_line(i))</span>
<span class="gi">+                        text_fragments.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+                    if text_fragments:</span>
<span class="gi">+                        text_fragments.pop()</span>
<span class="gi">+</span>
<span class="gi">+                    i = v.start</span>
<span class="gi">+                    for t, s, *_ in text_fragments:</span>
<span class="gi">+                        for c in s:</span>
<span class="gi">+                            if characters[i][0] == self.default_style:</span>
<span class="gi">+                                characters[i] = (t, characters[i][1])</span>
<span class="gi">+                            i += 1</span>
<span class="gi">+</span>
<span class="gi">+            # Highlight trailing input.</span>
<span class="gi">+            trailing_input = m.trailing_input()</span>
<span class="gi">+            if trailing_input:</span>
<span class="gi">+                for i in range(trailing_input.start, trailing_input.stop):</span>
<span class="gi">+                    characters[i] = (&quot;class:trailing-input&quot;, characters[i][1])</span>
<span class="gi">+</span>
<span class="gi">+            return characters</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [(&quot;&quot;, text)]</span>
<span class="gi">+</span>
<span class="gi">+    def lex_document(self, document: Document) -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="gi">+        lines = list(split_lines(self._get_text_fragments(document.text)))</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(lineno: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return lines[lineno]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+        return get_line</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/regex_parser.py b/src/prompt_toolkit/contrib/regular_languages/regex_parser.py</span>
<span class="gh">index ba97c928..a365ba8e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/regex_parser.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/regex_parser.py</span>
<span class="gu">@@ -15,9 +15,17 @@ Limitations:</span>
<span class="w"> </span>- Lookahead is not supported.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gd">-__all__ = [&#39;Repeat&#39;, &#39;Variable&#39;, &#39;Regex&#39;, &#39;Lookahead&#39;, &#39;tokenize_regex&#39;,</span>
<span class="gd">-    &#39;parse_regex&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Repeat&quot;,</span>
<span class="gi">+    &quot;Variable&quot;,</span>
<span class="gi">+    &quot;Regex&quot;,</span>
<span class="gi">+    &quot;Lookahead&quot;,</span>
<span class="gi">+    &quot;tokenize_regex&quot;,</span>
<span class="gi">+    &quot;parse_regex&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Node:
<span class="gu">@@ -26,10 +34,10 @@ class Node:</span>
<span class="w"> </span>    (You don&#39;t initialize this one.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __add__(self, other_node: Node) -&gt;NodeSequence:</span>
<span class="gi">+    def __add__(self, other_node: Node) -&gt; NodeSequence:</span>
<span class="w"> </span>        return NodeSequence([self, other_node])

<span class="gd">-    def __or__(self, other_node: Node) -&gt;AnyNode:</span>
<span class="gi">+    def __or__(self, other_node: Node) -&gt; AnyNode:</span>
<span class="w"> </span>        return AnyNode([self, other_node])


<span class="gu">@@ -40,14 +48,14 @@ class AnyNode(Node):</span>
<span class="w"> </span>    operation.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, children: list[Node]) -&gt;None:</span>
<span class="gi">+    def __init__(self, children: list[Node]) -&gt; None:</span>
<span class="w"> </span>        self.children = children

<span class="gd">-    def __or__(self, other_node: Node) -&gt;AnyNode:</span>
<span class="gi">+    def __or__(self, other_node: Node) -&gt; AnyNode:</span>
<span class="w"> </span>        return AnyNode(self.children + [other_node])

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.children!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.children!r})&quot;</span>


<span class="w"> </span>class NodeSequence(Node):
<span class="gu">@@ -56,14 +64,14 @@ class NodeSequence(Node):</span>
<span class="w"> </span>    yourself, but it&#39;s a result of a &quot;Grammar1 + Grammar2&quot; operation.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, children: list[Node]) -&gt;None:</span>
<span class="gi">+    def __init__(self, children: list[Node]) -&gt; None:</span>
<span class="w"> </span>        self.children = children

<span class="gd">-    def __add__(self, other_node: Node) -&gt;NodeSequence:</span>
<span class="gi">+    def __add__(self, other_node: Node) -&gt; NodeSequence:</span>
<span class="w"> </span>        return NodeSequence(self.children + [other_node])

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.children!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.children!r})&quot;</span>


<span class="w"> </span>class Regex(Node):
<span class="gu">@@ -71,12 +79,13 @@ class Regex(Node):</span>
<span class="w"> </span>    Regular expression.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, regex: str) -&gt;None:</span>
<span class="gd">-        re.compile(regex)</span>
<span class="gi">+    def __init__(self, regex: str) -&gt; None:</span>
<span class="gi">+        re.compile(regex)  # Validate</span>
<span class="gi">+</span>
<span class="w"> </span>        self.regex = regex

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}(/{self.regex}/)&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(/{self.regex}/)&quot;</span>


<span class="w"> </span>class Lookahead(Node):
<span class="gu">@@ -84,12 +93,12 @@ class Lookahead(Node):</span>
<span class="w"> </span>    Lookahead expression.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, childnode: Node, negative: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, childnode: Node, negative: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.childnode = childnode
<span class="w"> </span>        self.negative = negative

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.childnode!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.childnode!r})&quot;</span>


<span class="w"> </span>class Variable(Node):
<span class="gu">@@ -101,29 +110,36 @@ class Variable(Node):</span>
<span class="w"> </span>    :param varname: String.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, childnode: Node, varname: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, childnode: Node, varname: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        self.childnode = childnode
<span class="w"> </span>        self.varname = varname

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(childnode={!r}, varname={!r})&#39;.format(self.__class__.</span>
<span class="gd">-            __name__, self.childnode, self.varname)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(childnode={!r}, varname={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.childnode,</span>
<span class="gi">+            self.varname,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class Repeat(Node):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, childnode: Node, min_repeat: int=0, max_repeat: (int |</span>
<span class="gd">-        None)=None, greedy: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        childnode: Node,</span>
<span class="gi">+        min_repeat: int = 0,</span>
<span class="gi">+        max_repeat: int | None = None,</span>
<span class="gi">+        greedy: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.childnode = childnode
<span class="w"> </span>        self.min_repeat = min_repeat
<span class="w"> </span>        self.max_repeat = max_repeat
<span class="w"> </span>        self.greedy = greedy

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}(childnode={self.childnode!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(childnode={self.childnode!r})&quot;</span>


<span class="gd">-def tokenize_regex(input: str) -&gt;list[str]:</span>
<span class="gi">+def tokenize_regex(input: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Takes a string, representing a regular expression as input, and tokenizes
<span class="w"> </span>    it.
<span class="gu">@@ -131,11 +147,136 @@ def tokenize_regex(input: str) -&gt;list[str]:</span>
<span class="w"> </span>    :param input: string, representing a regular expression.
<span class="w"> </span>    :returns: List of tokens.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_regex(regex_tokens: list[str]) -&gt;Node:</span>
<span class="gi">+    # Regular expression for tokenizing other regular expressions.</span>
<span class="gi">+    p = re.compile(</span>
<span class="gi">+        r&quot;&quot;&quot;^(</span>
<span class="gi">+        \(\?P\&lt;[a-zA-Z0-9_-]+\&gt;  | # Start of named group.</span>
<span class="gi">+        \(\?#[^)]*\)             | # Comment</span>
<span class="gi">+        \(\?=                    | # Start of lookahead assertion</span>
<span class="gi">+        \(\?!                    | # Start of negative lookahead assertion</span>
<span class="gi">+        \(\?&lt;=                   | # If preceded by.</span>
<span class="gi">+        \(\?&lt;                    | # If not preceded by.</span>
<span class="gi">+        \(?:                     | # Start of group. (non capturing.)</span>
<span class="gi">+        \(                       | # Start of group.</span>
<span class="gi">+        \(?[iLmsux]              | # Flags.</span>
<span class="gi">+        \(?P=[a-zA-Z]+\)         | # Back reference to named group</span>
<span class="gi">+        \)                       | # End of group.</span>
<span class="gi">+        \{[^{}]*\}               | # Repetition</span>
<span class="gi">+        \*\? | \+\? | \?\?\      | # Non greedy repetition.</span>
<span class="gi">+        \* | \+ | \?             | # Repetition</span>
<span class="gi">+        \#.*\n                   | # Comment</span>
<span class="gi">+        \\. |</span>
<span class="gi">+</span>
<span class="gi">+        # Character group.</span>
<span class="gi">+        \[</span>
<span class="gi">+            ( [^\]\\]  |  \\.)*</span>
<span class="gi">+        \]                  |</span>
<span class="gi">+</span>
<span class="gi">+        [^(){}]             |</span>
<span class="gi">+        .</span>
<span class="gi">+    )&quot;&quot;&quot;,</span>
<span class="gi">+        re.VERBOSE,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    tokens = []</span>
<span class="gi">+</span>
<span class="gi">+    while input:</span>
<span class="gi">+        m = p.match(input)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            token, input = input[: m.end()], input[m.end() :]</span>
<span class="gi">+            if not token.isspace():</span>
<span class="gi">+                tokens.append(token)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Exception(&quot;Could not tokenize input regex.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return tokens</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_regex(regex_tokens: list[str]) -&gt; Node:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Takes a list of tokens from the tokenizer, and returns a parse tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # We add a closing brace because that represents the final pop of the stack.</span>
<span class="gi">+    tokens: list[str] = [&quot;)&quot;] + regex_tokens[::-1]</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(lst: list[Node]) -&gt; Node:</span>
<span class="gi">+        &quot;&quot;&quot;Turn list into sequence when it contains several items.&quot;&quot;&quot;</span>
<span class="gi">+        if len(lst) == 1:</span>
<span class="gi">+            return lst[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return NodeSequence(lst)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse() -&gt; Node:</span>
<span class="gi">+        or_list: list[list[Node]] = []</span>
<span class="gi">+        result: list[Node] = []</span>
<span class="gi">+</span>
<span class="gi">+        def wrapped_result() -&gt; Node:</span>
<span class="gi">+            if or_list == []:</span>
<span class="gi">+                return wrap(result)</span>
<span class="gi">+            else:</span>
<span class="gi">+                or_list.append(result)</span>
<span class="gi">+                return AnyNode([wrap(i) for i in or_list])</span>
<span class="gi">+</span>
<span class="gi">+        while tokens:</span>
<span class="gi">+            t = tokens.pop()</span>
<span class="gi">+</span>
<span class="gi">+            if t.startswith(&quot;(?P&lt;&quot;):</span>
<span class="gi">+                variable = Variable(_parse(), varname=t[4:-1])</span>
<span class="gi">+                result.append(variable)</span>
<span class="gi">+</span>
<span class="gi">+            elif t in (&quot;*&quot;, &quot;*?&quot;):</span>
<span class="gi">+                greedy = t == &quot;*&quot;</span>
<span class="gi">+                result[-1] = Repeat(result[-1], greedy=greedy)</span>
<span class="gi">+</span>
<span class="gi">+            elif t in (&quot;+&quot;, &quot;+?&quot;):</span>
<span class="gi">+                greedy = t == &quot;+&quot;</span>
<span class="gi">+                result[-1] = Repeat(result[-1], min_repeat=1, greedy=greedy)</span>
<span class="gi">+</span>
<span class="gi">+            elif t in (&quot;?&quot;, &quot;??&quot;):</span>
<span class="gi">+                if result == []:</span>
<span class="gi">+                    raise Exception(&quot;Nothing to repeat.&quot; + repr(tokens))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    greedy = t == &quot;?&quot;</span>
<span class="gi">+                    result[-1] = Repeat(</span>
<span class="gi">+                        result[-1], min_repeat=0, max_repeat=1, greedy=greedy</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            elif t == &quot;|&quot;:</span>
<span class="gi">+                or_list.append(result)</span>
<span class="gi">+                result = []</span>
<span class="gi">+</span>
<span class="gi">+            elif t in (&quot;(&quot;, &quot;(?:&quot;):</span>
<span class="gi">+                result.append(_parse())</span>
<span class="gi">+</span>
<span class="gi">+            elif t == &quot;(?!&quot;:</span>
<span class="gi">+                result.append(Lookahead(_parse(), negative=True))</span>
<span class="gi">+</span>
<span class="gi">+            elif t == &quot;(?=&quot;:</span>
<span class="gi">+                result.append(Lookahead(_parse(), negative=False))</span>
<span class="gi">+</span>
<span class="gi">+            elif t == &quot;)&quot;:</span>
<span class="gi">+                return wrapped_result()</span>
<span class="gi">+</span>
<span class="gi">+            elif t.startswith(&quot;#&quot;):</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            elif t.startswith(&quot;{&quot;):</span>
<span class="gi">+                # TODO: implement!</span>
<span class="gi">+                raise Exception(f&quot;{t}-style repetition not yet supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            elif t.startswith(&quot;(?&quot;):</span>
<span class="gi">+                raise Exception(&quot;%r not supported&quot; % t)</span>
<span class="gi">+</span>
<span class="gi">+            elif t.isspace():</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(Regex(t))</span>
<span class="gi">+</span>
<span class="gi">+        raise Exception(&quot;Expecting &#39;)&#39; token&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    result = _parse()</span>
<span class="gi">+</span>
<span class="gi">+    if len(tokens) != 0:</span>
<span class="gi">+        raise Exception(&quot;Unmatched parentheses.&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/validation.py b/src/prompt_toolkit/contrib/regular_languages/validation.py</span>
<span class="gh">index 8ce0aa3e..8e56e050 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/validation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/validation.py</span>
<span class="gu">@@ -2,10 +2,15 @@</span>
<span class="w"> </span>Validator for a regular language.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.validation import ValidationError, Validator
<span class="gi">+</span>
<span class="w"> </span>from .compiler import _CompiledGrammar
<span class="gd">-__all__ = [&#39;GrammarValidator&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;GrammarValidator&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class GrammarValidator(Validator):
<span class="gu">@@ -18,7 +23,37 @@ class GrammarValidator(Validator):</span>
<span class="w"> </span>                       `Validator` instances to be used for each variable.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, compiled_grammar: _CompiledGrammar, validators: dict</span>
<span class="gd">-        [str, Validator]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, compiled_grammar: _CompiledGrammar, validators: dict[str, Validator]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.compiled_grammar = compiled_grammar
<span class="w"> </span>        self.validators = validators
<span class="gi">+</span>
<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="gi">+        # Parse input document.</span>
<span class="gi">+        # We use `match`, not `match_prefix`, because for validation, we want</span>
<span class="gi">+        # the actual, unambiguous interpretation of the input.</span>
<span class="gi">+        m = self.compiled_grammar.match(document.text)</span>
<span class="gi">+</span>
<span class="gi">+        if m:</span>
<span class="gi">+            for v in m.variables():</span>
<span class="gi">+                validator = self.validators.get(v.varname)</span>
<span class="gi">+</span>
<span class="gi">+                if validator:</span>
<span class="gi">+                    # Unescape text.</span>
<span class="gi">+                    unwrapped_text = self.compiled_grammar.unescape(v.varname, v.value)</span>
<span class="gi">+</span>
<span class="gi">+                    # Create a document, for the completions API (text/cursor_position)</span>
<span class="gi">+                    inner_document = Document(unwrapped_text, len(unwrapped_text))</span>
<span class="gi">+</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        validator.validate(inner_document)</span>
<span class="gi">+                    except ValidationError as e:</span>
<span class="gi">+                        raise ValidationError(</span>
<span class="gi">+                            cursor_position=v.start + e.cursor_position,</span>
<span class="gi">+                            message=e.message,</span>
<span class="gi">+                        ) from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValidationError(</span>
<span class="gi">+                cursor_position=len(document.text), message=&quot;Invalid command&quot;</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/ssh/server.py b/src/prompt_toolkit/contrib/ssh/server.py</span>
<span class="gh">index 73ec9401..9a5d4022 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/ssh/server.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/ssh/server.py</span>
<span class="gu">@@ -2,57 +2,124 @@</span>
<span class="w"> </span>Utility for running a prompt_toolkit application in an asyncssh server.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import traceback
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from typing import Any, Callable, Coroutine, TextIO, cast
<span class="gi">+</span>
<span class="w"> </span>import asyncssh
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import AppSession, create_app_session
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.input import PipeInput, create_pipe_input
<span class="w"> </span>from prompt_toolkit.output.vt100 import Vt100_Output
<span class="gd">-__all__ = [&#39;PromptToolkitSSHSession&#39;, &#39;PromptToolkitSSHServer&#39;]</span>

<span class="gi">+__all__ = [&quot;PromptToolkitSSHSession&quot;, &quot;PromptToolkitSSHServer&quot;]</span>

<span class="gd">-class PromptToolkitSSHSession(asyncssh.SSHServerSession):</span>

<span class="gd">-    def __init__(self, interact: Callable[[PromptToolkitSSHSession],</span>
<span class="gd">-        Coroutine[Any, Any, None]], *, enable_cpr: bool) -&gt;None:</span>
<span class="gi">+class PromptToolkitSSHSession(asyncssh.SSHServerSession):  # type: ignore</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        interact: Callable[[PromptToolkitSSHSession], Coroutine[Any, Any, None]],</span>
<span class="gi">+        *,</span>
<span class="gi">+        enable_cpr: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.interact = interact
<span class="w"> </span>        self.enable_cpr = enable_cpr
<span class="w"> </span>        self.interact_task: asyncio.Task[None] | None = None
<span class="w"> </span>        self._chan: Any | None = None
<span class="w"> </span>        self.app_session: AppSession | None = None
<span class="gi">+</span>
<span class="gi">+        # PipInput object, for sending input in the CLI.</span>
<span class="gi">+        # (This is something that we can use in the prompt_toolkit event loop,</span>
<span class="gi">+        # but still write date in manually.)</span>
<span class="w"> </span>        self._input: PipeInput | None = None
<span class="w"> </span>        self._output: Vt100_Output | None = None

<span class="gd">-</span>
<span class="gi">+        # Output object. Don&#39;t render to the real stdout, but write everything</span>
<span class="gi">+        # in the SSH channel.</span>
<span class="w"> </span>        class Stdout:
<span class="gd">-</span>
<span class="gd">-            def write(s, data: str) -&gt;None:</span>
<span class="gi">+            def write(s, data: str) -&gt; None:</span>
<span class="w"> </span>                try:
<span class="w"> </span>                    if self._chan is not None:
<span class="gd">-                        self._chan.write(data.replace(&#39;\n&#39;, &#39;\r\n&#39;))</span>
<span class="gi">+                        self._chan.write(data.replace(&quot;\n&quot;, &quot;\r\n&quot;))</span>
<span class="w"> </span>                except BrokenPipeError:
<span class="gd">-                    pass</span>
<span class="gi">+                    pass  # Channel not open for sending.</span>

<span class="gd">-            def isatty(s) -&gt;bool:</span>
<span class="gi">+            def isatty(s) -&gt; bool:</span>
<span class="w"> </span>                return True

<span class="gd">-            def flush(s) -&gt;None:</span>
<span class="gi">+            def flush(s) -&gt; None:</span>
<span class="w"> </span>                pass

<span class="w"> </span>            @property
<span class="gd">-            def encoding(s) -&gt;str:</span>
<span class="gi">+            def encoding(s) -&gt; str:</span>
<span class="w"> </span>                assert self._chan is not None
<span class="w"> </span>                return str(self._chan._orig_chan.get_encoding()[0])
<span class="gi">+</span>
<span class="w"> </span>        self.stdout = cast(TextIO, Stdout())

<span class="gd">-    def _get_size(self) -&gt;Size:</span>
<span class="gi">+    def _get_size(self) -&gt; Size:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Callable that returns the current `Size`, required by Vt100_Output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._chan is None:</span>
<span class="gi">+            return Size(rows=20, columns=79)</span>
<span class="gi">+        else:</span>
<span class="gi">+            width, height, pixwidth, pixheight = self._chan.get_terminal_size()</span>
<span class="gi">+            return Size(rows=height, columns=width)</span>
<span class="gi">+</span>
<span class="gi">+    def connection_made(self, chan: Any) -&gt; None:</span>
<span class="gi">+        self._chan = chan</span>
<span class="gi">+</span>
<span class="gi">+    def shell_requested(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def session_started(self) -&gt; None:</span>
<span class="gi">+        self.interact_task = get_running_loop().create_task(self._interact())</span>
<span class="gi">+</span>
<span class="gi">+    async def _interact(self) -&gt; None:</span>
<span class="gi">+        if self._chan is None:</span>
<span class="gi">+            # Should not happen.</span>
<span class="gi">+            raise Exception(&quot;`_interact` called before `connection_made`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(self._chan, &quot;set_line_mode&quot;) and self._chan._editor is not None:</span>
<span class="gi">+            # Disable the line editing provided by asyncssh. Prompt_toolkit</span>
<span class="gi">+            # provides the line editing.</span>
<span class="gi">+            self._chan.set_line_mode(False)</span>
<span class="gi">+</span>
<span class="gi">+        term = self._chan.get_terminal_type()</span>
<span class="gi">+</span>
<span class="gi">+        self._output = Vt100_Output(</span>
<span class="gi">+            self.stdout, self._get_size, term=term, enable_cpr=self.enable_cpr</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        with create_pipe_input() as self._input:</span>
<span class="gi">+            with create_app_session(input=self._input, output=self._output) as session:</span>
<span class="gi">+                self.app_session = session</span>
<span class="gi">+                try:</span>
<span class="gi">+                    await self.interact(self)</span>
<span class="gi">+                except BaseException:</span>
<span class="gi">+                    traceback.print_exc()</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    # Close the connection.</span>
<span class="gi">+                    self._chan.close()</span>
<span class="gi">+                    self._input.close()</span>
<span class="gi">+</span>
<span class="gi">+    def terminal_size_changed(</span>
<span class="gi">+        self, width: int, height: int, pixwidth: object, pixheight: object</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Send resize event to the current application.</span>
<span class="gi">+        if self.app_session and self.app_session.app:</span>
<span class="gi">+            self.app_session.app._on_resize()</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, data: str, datatype: object) -&gt; None:</span>
<span class="gi">+        if self._input is None:</span>
<span class="gi">+            # Should not happen.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._input.send_text(data)</span>


<span class="w"> </span>class PromptToolkitSSHServer(asyncssh.SSHServer):
<span class="gu">@@ -93,7 +160,18 @@ class PromptToolkitSSHServer(asyncssh.SSHServer):</span>
<span class="w"> </span>        for the UI (especially for drop down menus) to render.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, interact: Callable[[PromptToolkitSSHSession],</span>
<span class="gd">-        Coroutine[Any, Any, None]], *, enable_cpr: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        interact: Callable[[PromptToolkitSSHSession], Coroutine[Any, Any, None]],</span>
<span class="gi">+        *,</span>
<span class="gi">+        enable_cpr: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.interact = interact
<span class="w"> </span>        self.enable_cpr = enable_cpr
<span class="gi">+</span>
<span class="gi">+    def begin_auth(self, username: str) -&gt; bool:</span>
<span class="gi">+        # No authentication.</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def session_requested(self) -&gt; PromptToolkitSSHSession:</span>
<span class="gi">+        return PromptToolkitSSHSession(self.interact, enable_cpr=self.enable_cpr)</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/telnet/log.py b/src/prompt_toolkit/contrib/telnet/log.py</span>
<span class="gh">index 3012a780..0fe84337 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/telnet/log.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/telnet/log.py</span>
<span class="gu">@@ -2,6 +2,11 @@</span>
<span class="w"> </span>Python logger for the telnet server.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__package__)
<span class="gd">-__all__ = [&#39;logger&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;logger&quot;,</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/telnet/protocol.py b/src/prompt_toolkit/contrib/telnet/protocol.py</span>
<span class="gh">index f58280d4..4b90e985 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/telnet/protocol.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/telnet/protocol.py</span>
<span class="gu">@@ -5,12 +5,25 @@ specification, but sufficient for a command line interface.)</span>
<span class="w"> </span>Inspired by `Twisted.conch.telnet`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Callable, Generator
<span class="gi">+</span>
<span class="w"> </span>from .log import logger
<span class="gd">-__all__ = [&#39;TelnetProtocolParser&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;TelnetProtocolParser&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def int2byte(number: int) -&gt; bytes:</span>
<span class="gi">+    return bytes((number,))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Telnet constants.</span>
<span class="w"> </span>NOP = int2byte(0)
<span class="w"> </span>SGA = int2byte(3)
<span class="gi">+</span>
<span class="w"> </span>IAC = int2byte(255)
<span class="w"> </span>DO = int2byte(253)
<span class="w"> </span>DONT = int2byte(254)
<span class="gu">@@ -24,9 +37,11 @@ ECHO = int2byte(1)</span>
<span class="w"> </span>NAWS = int2byte(31)
<span class="w"> </span>LINEMODE = int2byte(34)
<span class="w"> </span>SUPPRESS_GO_AHEAD = int2byte(3)
<span class="gi">+</span>
<span class="w"> </span>TTYPE = int2byte(24)
<span class="w"> </span>SEND = int2byte(1)
<span class="w"> </span>IS = int2byte(0)
<span class="gi">+</span>
<span class="w"> </span>DM = int2byte(242)
<span class="w"> </span>BRK = int2byte(243)
<span class="w"> </span>IP = int2byte(244)
<span class="gu">@@ -52,58 +67,142 @@ class TelnetProtocolParser:</span>
<span class="w"> </span>        p.feed(binary_data)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, data_received_callback: Callable[[bytes], None],</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data_received_callback: Callable[[bytes], None],</span>
<span class="w"> </span>        size_received_callback: Callable[[int, int], None],
<span class="gd">-        ttype_received_callback: Callable[[str], None]) -&gt;None:</span>
<span class="gi">+        ttype_received_callback: Callable[[str], None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.data_received_callback = data_received_callback
<span class="w"> </span>        self.size_received_callback = size_received_callback
<span class="w"> </span>        self.ttype_received_callback = ttype_received_callback
<span class="gi">+</span>
<span class="w"> </span>        self._parser = self._parse_coroutine()
<span class="gd">-        self._parser.send(None)</span>
<span class="gi">+        self._parser.send(None)  # type: ignore</span>

<span class="gd">-    def do_received(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def received_data(self, data: bytes) -&gt; None:</span>
<span class="gi">+        self.data_received_callback(data)</span>
<span class="gi">+</span>
<span class="gi">+    def do_received(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Received telnet DO command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(&quot;DO %r&quot;, data)</span>

<span class="gd">-    def dont_received(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def dont_received(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Received telnet DONT command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(&quot;DONT %r&quot;, data)</span>

<span class="gd">-    def will_received(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def will_received(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Received telnet WILL command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(&quot;WILL %r&quot;, data)</span>

<span class="gd">-    def wont_received(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def wont_received(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Received telnet WONT command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(&quot;WONT %r&quot;, data)</span>
<span class="gi">+</span>
<span class="gi">+    def command_received(self, command: bytes, data: bytes) -&gt; None:</span>
<span class="gi">+        if command == DO:</span>
<span class="gi">+            self.do_received(data)</span>
<span class="gi">+</span>
<span class="gi">+        elif command == DONT:</span>
<span class="gi">+            self.dont_received(data)</span>
<span class="gi">+</span>
<span class="gi">+        elif command == WILL:</span>
<span class="gi">+            self.will_received(data)</span>
<span class="gi">+</span>
<span class="gi">+        elif command == WONT:</span>
<span class="gi">+            self.wont_received(data)</span>

<span class="gd">-    def naws(self, data: bytes) -&gt;None:</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.info(&quot;command received %r %r&quot;, command, data)</span>
<span class="gi">+</span>
<span class="gi">+    def naws(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Received NAWS. (Window dimensions.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def ttype(self, data: bytes) -&gt;None:</span>
<span class="gi">+        if len(data) == 4:</span>
<span class="gi">+            # NOTE: the first parameter of struct.unpack should be</span>
<span class="gi">+            # a &#39;str&#39; object. Both on Py2/py3. This crashes on OSX</span>
<span class="gi">+            # otherwise.</span>
<span class="gi">+            columns, rows = struct.unpack(&quot;!HH&quot;, data)</span>
<span class="gi">+            self.size_received_callback(rows, columns)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(&quot;Wrong number of NAWS bytes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def ttype(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Received terminal type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def negotiate(self, data: bytes) -&gt;None:</span>
<span class="gi">+        subcmd, data = data[0:1], data[1:]</span>
<span class="gi">+        if subcmd == IS:</span>
<span class="gi">+            ttype = data.decode(&quot;ascii&quot;)</span>
<span class="gi">+            self.ttype_received_callback(ttype)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(&quot;Received a non-IS terminal type Subnegotiation&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def negotiate(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Got negotiate data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        command, payload = data[0:1], data[1:]</span>

<span class="gd">-    def _parse_coroutine(self) -&gt;Generator[None, bytes, None]:</span>
<span class="gi">+        if command == NAWS:</span>
<span class="gi">+            self.naws(payload)</span>
<span class="gi">+        elif command == TTYPE:</span>
<span class="gi">+            self.ttype(payload)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.info(&quot;Negotiate (%r got bytes)&quot;, len(data))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_coroutine(self) -&gt; Generator[None, bytes, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parser state machine.
<span class="w"> </span>        Every &#39;yield&#39; expression returns the next byte.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def feed(self, data: bytes) -&gt;None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            d = yield</span>
<span class="gi">+</span>
<span class="gi">+            if d == int2byte(0):</span>
<span class="gi">+                pass  # NOP</span>
<span class="gi">+</span>
<span class="gi">+            # Go to state escaped.</span>
<span class="gi">+            elif d == IAC:</span>
<span class="gi">+                d2 = yield</span>
<span class="gi">+</span>
<span class="gi">+                if d2 == IAC:</span>
<span class="gi">+                    self.received_data(d2)</span>
<span class="gi">+</span>
<span class="gi">+                # Handle simple commands.</span>
<span class="gi">+                elif d2 in (NOP, DM, BRK, IP, AO, AYT, EC, EL, GA):</span>
<span class="gi">+                    self.command_received(d2, b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # Handle IAC-[DO/DONT/WILL/WONT] commands.</span>
<span class="gi">+                elif d2 in (DO, DONT, WILL, WONT):</span>
<span class="gi">+                    d3 = yield</span>
<span class="gi">+                    self.command_received(d2, d3)</span>
<span class="gi">+</span>
<span class="gi">+                # Subnegotiation</span>
<span class="gi">+                elif d2 == SB:</span>
<span class="gi">+                    # Consume everything until next IAC-SE</span>
<span class="gi">+                    data = []</span>
<span class="gi">+</span>
<span class="gi">+                    while True:</span>
<span class="gi">+                        d3 = yield</span>
<span class="gi">+</span>
<span class="gi">+                        if d3 == IAC:</span>
<span class="gi">+                            d4 = yield</span>
<span class="gi">+                            if d4 == SE:</span>
<span class="gi">+                                break</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                data.append(d4)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            data.append(d3)</span>
<span class="gi">+</span>
<span class="gi">+                    self.negotiate(b&quot;&quot;.join(data))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.received_data(d)</span>
<span class="gi">+</span>
<span class="gi">+    def feed(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Feed data to the parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for b in data:</span>
<span class="gi">+            self._parser.send(int2byte(b))</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/telnet/server.py b/src/prompt_toolkit/contrib/telnet/server.py</span>
<span class="gh">index 4feaaadb..9ebe66c6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/telnet/server.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/telnet/server.py</span>
<span class="gu">@@ -2,11 +2,13 @@</span>
<span class="w"> </span>Telnet server.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import contextvars
<span class="w"> </span>import socket
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from typing import Any, Callable, Coroutine, TextIO, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import create_app_session, get_app
<span class="w"> </span>from prompt_toolkit.application.run_in_terminal import run_in_terminal
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="gu">@@ -15,9 +17,60 @@ from prompt_toolkit.input import PipeInput, create_pipe_input</span>
<span class="w"> </span>from prompt_toolkit.output.vt100 import Vt100_Output
<span class="w"> </span>from prompt_toolkit.renderer import print_formatted_text as print_formatted_text
<span class="w"> </span>from prompt_toolkit.styles import BaseStyle, DummyStyle
<span class="gi">+</span>
<span class="w"> </span>from .log import logger
<span class="gd">-from .protocol import DO, ECHO, IAC, LINEMODE, MODE, NAWS, SB, SE, SEND, SUPPRESS_GO_AHEAD, TTYPE, WILL, TelnetProtocolParser</span>
<span class="gd">-__all__ = [&#39;TelnetServer&#39;]</span>
<span class="gi">+from .protocol import (</span>
<span class="gi">+    DO,</span>
<span class="gi">+    ECHO,</span>
<span class="gi">+    IAC,</span>
<span class="gi">+    LINEMODE,</span>
<span class="gi">+    MODE,</span>
<span class="gi">+    NAWS,</span>
<span class="gi">+    SB,</span>
<span class="gi">+    SE,</span>
<span class="gi">+    SEND,</span>
<span class="gi">+    SUPPRESS_GO_AHEAD,</span>
<span class="gi">+    TTYPE,</span>
<span class="gi">+    WILL,</span>
<span class="gi">+    TelnetProtocolParser,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;TelnetServer&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def int2byte(number: int) -&gt; bytes:</span>
<span class="gi">+    return bytes((number,))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _initialize_telnet(connection: socket.socket) -&gt; None:</span>
<span class="gi">+    logger.info(&quot;Initializing telnet connection&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Iac Do Linemode</span>
<span class="gi">+    connection.send(IAC + DO + LINEMODE)</span>
<span class="gi">+</span>
<span class="gi">+    # Suppress Go Ahead. (This seems important for Putty to do correct echoing.)</span>
<span class="gi">+    # This will allow bi-directional operation.</span>
<span class="gi">+    connection.send(IAC + WILL + SUPPRESS_GO_AHEAD)</span>
<span class="gi">+</span>
<span class="gi">+    # Iac sb</span>
<span class="gi">+    connection.send(IAC + SB + LINEMODE + MODE + int2byte(0) + IAC + SE)</span>
<span class="gi">+</span>
<span class="gi">+    # IAC Will Echo</span>
<span class="gi">+    connection.send(IAC + WILL + ECHO)</span>
<span class="gi">+</span>
<span class="gi">+    # Negotiate window size</span>
<span class="gi">+    connection.send(IAC + DO + NAWS)</span>
<span class="gi">+</span>
<span class="gi">+    # Negotiate terminal type</span>
<span class="gi">+    # Assume the client will accept the negotiation with `IAC +  WILL + TTYPE`</span>
<span class="gi">+    connection.send(IAC + DO + TTYPE)</span>
<span class="gi">+</span>
<span class="gi">+    # We can then select the first terminal type supported by the client,</span>
<span class="gi">+    # which is generally the best type the client supports</span>
<span class="gi">+    # The client should reply with a `IAC + SB  + TTYPE + IS + ttype + IAC + SE`</span>
<span class="gi">+    connection.send(IAC + SB + TTYPE + SEND + IAC + SE)</span>


<span class="w"> </span>class _ConnectionStdout:
<span class="gu">@@ -26,23 +79,58 @@ class _ConnectionStdout:</span>
<span class="w"> </span>    Vt100_Output output.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, connection: socket.socket, encoding: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, connection: socket.socket, encoding: str) -&gt; None:</span>
<span class="w"> </span>        self._encoding = encoding
<span class="w"> </span>        self._connection = connection
<span class="gd">-        self._errors = &#39;strict&#39;</span>
<span class="gi">+        self._errors = &quot;strict&quot;</span>
<span class="w"> </span>        self._buffer: list[bytes] = []
<span class="w"> </span>        self._closed = False

<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        data = data.replace(&quot;\n&quot;, &quot;\r\n&quot;)</span>
<span class="gi">+        self._buffer.append(data.encode(self._encoding, errors=self._errors))</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def isatty(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not self._closed:</span>
<span class="gi">+                self._connection.send(b&quot;&quot;.join(self._buffer))</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            logger.warning(&quot;Couldn&#39;t send data over socket: %s&quot; % e)</span>
<span class="gi">+</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="gi">+        return self._encoding</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def errors(self) -&gt; str:</span>
<span class="gi">+        return self._errors</span>
<span class="gi">+</span>

<span class="w"> </span>class TelnetConnection:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Class that represents one Telnet connection.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, conn: socket.socket, addr: tuple[str, int], interact:</span>
<span class="gd">-        Callable[[TelnetConnection], Coroutine[Any, Any, None]], server:</span>
<span class="gd">-        TelnetServer, encoding: str, style: (BaseStyle | None), vt100_input:</span>
<span class="gd">-        PipeInput, enable_cpr: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        conn: socket.socket,</span>
<span class="gi">+        addr: tuple[str, int],</span>
<span class="gi">+        interact: Callable[[TelnetConnection], Coroutine[Any, Any, None]],</span>
<span class="gi">+        server: TelnetServer,</span>
<span class="gi">+        encoding: str,</span>
<span class="gi">+        style: BaseStyle | None,</span>
<span class="gi">+        vt100_input: PipeInput,</span>
<span class="gi">+        enable_cpr: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.conn = conn
<span class="w"> </span>        self.addr = addr
<span class="w"> </span>        self.interact = interact
<span class="gu">@@ -54,68 +142,124 @@ class TelnetConnection:</span>
<span class="w"> </span>        self.vt100_input = vt100_input
<span class="w"> </span>        self.enable_cpr = enable_cpr
<span class="w"> </span>        self.vt100_output: Vt100_Output | None = None
<span class="gi">+</span>
<span class="gi">+        # Create &quot;Output&quot; object.</span>
<span class="w"> </span>        self.size = Size(rows=40, columns=79)
<span class="gi">+</span>
<span class="gi">+        # Initialize.</span>
<span class="w"> </span>        _initialize_telnet(conn)

<span class="gd">-        def get_size() -&gt;Size:</span>
<span class="gi">+        # Create output.</span>
<span class="gi">+        def get_size() -&gt; Size:</span>
<span class="w"> </span>            return self.size
<span class="gi">+</span>
<span class="w"> </span>        self.stdout = cast(TextIO, _ConnectionStdout(conn, encoding=encoding))

<span class="gd">-        def data_received(data: bytes) -&gt;None:</span>
<span class="gi">+        def data_received(data: bytes) -&gt; None:</span>
<span class="w"> </span>            &quot;&quot;&quot;TelnetProtocolParser &#39;data_received&#39; callback&quot;&quot;&quot;
<span class="w"> </span>            self.vt100_input.send_bytes(data)

<span class="gd">-        def size_received(rows: int, columns: int) -&gt;None:</span>
<span class="gi">+        def size_received(rows: int, columns: int) -&gt; None:</span>
<span class="w"> </span>            &quot;&quot;&quot;TelnetProtocolParser &#39;size_received&#39; callback&quot;&quot;&quot;
<span class="w"> </span>            self.size = Size(rows=rows, columns=columns)
<span class="w"> </span>            if self.vt100_output is not None and self.context:
<span class="gd">-                self.context.run(lambda : get_app()._on_resize())</span>
<span class="gi">+                self.context.run(lambda: get_app()._on_resize())</span>

<span class="gd">-        def ttype_received(ttype: str) -&gt;None:</span>
<span class="gi">+        def ttype_received(ttype: str) -&gt; None:</span>
<span class="w"> </span>            &quot;&quot;&quot;TelnetProtocolParser &#39;ttype_received&#39; callback&quot;&quot;&quot;
<span class="gd">-            self.vt100_output = Vt100_Output(self.stdout, get_size, term=</span>
<span class="gd">-                ttype, enable_cpr=enable_cpr)</span>
<span class="gi">+            self.vt100_output = Vt100_Output(</span>
<span class="gi">+                self.stdout, get_size, term=ttype, enable_cpr=enable_cpr</span>
<span class="gi">+            )</span>
<span class="w"> </span>            self._ready.set()
<span class="gd">-        self.parser = TelnetProtocolParser(data_received, size_received,</span>
<span class="gd">-            ttype_received)</span>
<span class="gi">+</span>
<span class="gi">+        self.parser = TelnetProtocolParser(data_received, size_received, ttype_received)</span>
<span class="w"> </span>        self.context: contextvars.Context | None = None

<span class="gd">-    async def run_application(self) -&gt;None:</span>
<span class="gi">+    async def run_application(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run application.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def feed(self, data: bytes) -&gt;None:</span>
<span class="gi">+        def handle_incoming_data() -&gt; None:</span>
<span class="gi">+            data = self.conn.recv(1024)</span>
<span class="gi">+            if data:</span>
<span class="gi">+                self.feed(data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Connection closed by client.</span>
<span class="gi">+                logger.info(&quot;Connection closed by client. {!r} {!r}&quot;.format(*self.addr))</span>
<span class="gi">+                self.close()</span>
<span class="gi">+</span>
<span class="gi">+        # Add reader.</span>
<span class="gi">+        loop = get_running_loop()</span>
<span class="gi">+        loop.add_reader(self.conn, handle_incoming_data)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Wait for v100_output to be properly instantiated</span>
<span class="gi">+            await self._ready.wait()</span>
<span class="gi">+            with create_app_session(input=self.vt100_input, output=self.vt100_output):</span>
<span class="gi">+                self.context = contextvars.copy_context()</span>
<span class="gi">+                await self.interact(self)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.close()</span>
<span class="gi">+</span>
<span class="gi">+    def feed(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handler for incoming data. (Called by TelnetServer.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.parser.feed(data)</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Closed by client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+</span>
<span class="gi">+            self.vt100_input.close()</span>
<span class="gi">+            get_running_loop().remove_reader(self.conn)</span>
<span class="gi">+            self.conn.close()</span>
<span class="gi">+            self.stdout.close()</span>

<span class="gd">-    def send(self, formatted_text: AnyFormattedText) -&gt;None:</span>
<span class="gi">+    def send(self, formatted_text: AnyFormattedText) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send text to the client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.vt100_output is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        formatted_text = to_formatted_text(formatted_text)</span>
<span class="gi">+        print_formatted_text(</span>
<span class="gi">+            self.vt100_output, formatted_text, self.style or DummyStyle()</span>
<span class="gi">+        )</span>

<span class="gd">-    def send_above_prompt(self, formatted_text: AnyFormattedText) -&gt;None:</span>
<span class="gi">+    def send_above_prompt(self, formatted_text: AnyFormattedText) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send text to the client.
<span class="w"> </span>        This is asynchronous, returns a `Future`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        formatted_text = to_formatted_text(formatted_text)</span>
<span class="gi">+        return self._run_in_terminal(lambda: self.send(formatted_text))</span>

<span class="gd">-    def erase_screen(self) -&gt;None:</span>
<span class="gi">+    def _run_in_terminal(self, func: Callable[[], None]) -&gt; None:</span>
<span class="gi">+        # Make sure that when an application was active for this connection,</span>
<span class="gi">+        # that we print the text above the application.</span>
<span class="gi">+        if self.context:</span>
<span class="gi">+            self.context.run(run_in_terminal, func)  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(&quot;Called _run_in_terminal outside `run_application`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_screen(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erase the screen and move the cursor to the top.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.vt100_output is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.vt100_output.erase_screen()</span>
<span class="gi">+        self.vt100_output.cursor_goto(0, 0)</span>
<span class="gi">+        self.vt100_output.flush()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def _dummy_interact(connection: TelnetConnection) -&gt; None:</span>
<span class="gi">+    pass</span>


<span class="w"> </span>class TelnetServer:
<span class="gu">@@ -128,56 +272,156 @@ class TelnetServer:</span>
<span class="w"> </span>            connection.send(&quot;Welcome&quot;)
<span class="w"> </span>            session = PromptSession()
<span class="w"> </span>            result = await session.prompt_async(message=&quot;Say something: &quot;)
<span class="gd">-            connection.send(f&quot;You said: {result}</span>
<span class="gd">-&quot;)</span>
<span class="gi">+            connection.send(f&quot;You said: {result}\n&quot;)</span>

<span class="w"> </span>        async def main():
<span class="w"> </span>            server = TelnetServer(interact=interact, port=2323)
<span class="w"> </span>            await server.run()
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, host: str=&#39;127.0.0.1&#39;, port: int=23, interact:</span>
<span class="gd">-        Callable[[TelnetConnection], Coroutine[Any, Any, None]]=</span>
<span class="gd">-        _dummy_interact, encoding: str=&#39;utf-8&#39;, style: (BaseStyle | None)=</span>
<span class="gd">-        None, enable_cpr: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host: str = &quot;127.0.0.1&quot;,</span>
<span class="gi">+        port: int = 23,</span>
<span class="gi">+        interact: Callable[</span>
<span class="gi">+            [TelnetConnection], Coroutine[Any, Any, None]</span>
<span class="gi">+        ] = _dummy_interact,</span>
<span class="gi">+        encoding: str = &quot;utf-8&quot;,</span>
<span class="gi">+        style: BaseStyle | None = None,</span>
<span class="gi">+        enable_cpr: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.host = host
<span class="w"> </span>        self.port = port
<span class="w"> </span>        self.interact = interact
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.enable_cpr = enable_cpr
<span class="gi">+</span>
<span class="w"> </span>        self._run_task: asyncio.Task[None] | None = None
<span class="w"> </span>        self._application_tasks: list[asyncio.Task[None]] = []
<span class="gi">+</span>
<span class="w"> </span>        self.connections: set[TelnetConnection] = set()

<span class="gd">-    async def run(self, ready_cb: (Callable[[], None] | None)=None) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _create_socket(cls, host: str, port: int) -&gt; socket.socket:</span>
<span class="gi">+        # Create and bind socket</span>
<span class="gi">+        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>
<span class="gi">+        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="gi">+        s.bind((host, port))</span>
<span class="gi">+</span>
<span class="gi">+        s.listen(4)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    async def run(self, ready_cb: Callable[[], None] | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run the telnet server, until this gets cancelled.

<span class="w"> </span>        :param ready_cb: Callback that will be called at the point that we&#39;re
<span class="w"> </span>            actually listening.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        socket = self._create_socket(self.host, self.port)</span>
<span class="gi">+        logger.info(</span>
<span class="gi">+            &quot;Listening for telnet connections on %s port %r&quot;, self.host, self.port</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        get_running_loop().add_reader(socket, lambda: self._accept(socket))</span>
<span class="gi">+</span>
<span class="gi">+        if ready_cb:</span>
<span class="gi">+            ready_cb()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Run forever, until cancelled.</span>
<span class="gi">+            await asyncio.Future()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            get_running_loop().remove_reader(socket)</span>
<span class="gi">+            socket.close()</span>
<span class="gi">+</span>
<span class="gi">+            # Wait for all applications to finish.</span>
<span class="gi">+            for t in self._application_tasks:</span>
<span class="gi">+                t.cancel()</span>
<span class="gi">+</span>
<span class="gi">+            # (This is similar to</span>
<span class="gi">+            # `Application.cancel_and_wait_for_background_tasks`. We wait for the</span>
<span class="gi">+            # background tasks to complete, but don&#39;t propagate exceptions, because</span>
<span class="gi">+            # we can&#39;t use `ExceptionGroup` yet.)</span>
<span class="gi">+            if len(self._application_tasks) &gt; 0:</span>
<span class="gi">+                await asyncio.wait(</span>
<span class="gi">+                    self._application_tasks,</span>
<span class="gi">+                    timeout=None,</span>
<span class="gi">+                    return_when=asyncio.ALL_COMPLETED,</span>
<span class="gi">+                )</span>

<span class="gd">-    def start(self) -&gt;None:</span>
<span class="gi">+    def start(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Deprecated: Use `.run()` instead.

<span class="w"> </span>        Start the telnet server (stop by calling and awaiting `stop()`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._run_task is not None:</span>
<span class="gi">+            # Already running.</span>
<span class="gi">+            return</span>

<span class="gd">-    async def stop(self) -&gt;None:</span>
<span class="gi">+        self._run_task = get_running_loop().create_task(self.run())</span>
<span class="gi">+</span>
<span class="gi">+    async def stop(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Deprecated: Use `.run()` instead.

<span class="w"> </span>        Stop a telnet server that was started using `.start()` and wait for the
<span class="w"> </span>        cancellation to complete.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._run_task is not None:</span>
<span class="gi">+            self._run_task.cancel()</span>
<span class="gi">+            try:</span>
<span class="gi">+                await self._run_task</span>
<span class="gi">+            except asyncio.CancelledError:</span>
<span class="gi">+                pass</span>

<span class="gd">-    def _accept(self, listen_socket: socket.socket) -&gt;None:</span>
<span class="gi">+    def _accept(self, listen_socket: socket.socket) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Accept new incoming connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        conn, addr = listen_socket.accept()</span>
<span class="gi">+        logger.info(&quot;New connection %r %r&quot;, *addr)</span>
<span class="gi">+</span>
<span class="gi">+        # Run application for this connection.</span>
<span class="gi">+        async def run() -&gt; None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                with create_pipe_input() as vt100_input:</span>
<span class="gi">+                    connection = TelnetConnection(</span>
<span class="gi">+                        conn,</span>
<span class="gi">+                        addr,</span>
<span class="gi">+                        self.interact,</span>
<span class="gi">+                        self,</span>
<span class="gi">+                        encoding=self.encoding,</span>
<span class="gi">+                        style=self.style,</span>
<span class="gi">+                        vt100_input=vt100_input,</span>
<span class="gi">+                        enable_cpr=self.enable_cpr,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.connections.add(connection)</span>
<span class="gi">+</span>
<span class="gi">+                    logger.info(&quot;Starting interaction %r %r&quot;, *addr)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        await connection.run_application()</span>
<span class="gi">+                    finally:</span>
<span class="gi">+                        self.connections.remove(connection)</span>
<span class="gi">+                        logger.info(&quot;Stopping interaction %r %r&quot;, *addr)</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                # Happens either when the connection is closed by the client</span>
<span class="gi">+                # (e.g., when the user types &#39;control-]&#39;, then &#39;quit&#39; in the</span>
<span class="gi">+                # telnet client) or when the user types control-d in a prompt</span>
<span class="gi">+                # and this is not handled by the interact function.</span>
<span class="gi">+                logger.info(&quot;Unhandled EOFError in telnet application.&quot;)</span>
<span class="gi">+            except KeyboardInterrupt:</span>
<span class="gi">+                # Unhandled control-c propagated by a prompt.</span>
<span class="gi">+                logger.info(&quot;Unhandled KeyboardInterrupt in telnet application.&quot;)</span>
<span class="gi">+            except BaseException as e:</span>
<span class="gi">+                print(&quot;Got %s&quot; % type(e).__name__, e)</span>
<span class="gi">+                import traceback</span>
<span class="gi">+</span>
<span class="gi">+                traceback.print_exc()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self._application_tasks.remove(task)</span>
<span class="gi">+</span>
<span class="gi">+        task = get_running_loop().create_task(run())</span>
<span class="gi">+        self._application_tasks.append(task)</span>
<span class="gh">diff --git a/src/prompt_toolkit/cursor_shapes.py b/src/prompt_toolkit/cursor_shapes.py</span>
<span class="gh">index 076033d2..453b72c3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/cursor_shapes.py</span>
<span class="gi">+++ b/src/prompt_toolkit/cursor_shapes.py</span>
<span class="gu">@@ -1,34 +1,50 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Union
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.enums import EditingMode
<span class="w"> </span>from prompt_toolkit.key_binding.vi_state import InputMode
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .application import Application
<span class="gd">-__all__ = [&#39;CursorShape&#39;, &#39;CursorShapeConfig&#39;, &#39;SimpleCursorShapeConfig&#39;,</span>
<span class="gd">-    &#39;ModalCursorShapeConfig&#39;, &#39;DynamicCursorShapeConfig&#39;,</span>
<span class="gd">-    &#39;to_cursor_shape_config&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CursorShape&quot;,</span>
<span class="gi">+    &quot;CursorShapeConfig&quot;,</span>
<span class="gi">+    &quot;SimpleCursorShapeConfig&quot;,</span>
<span class="gi">+    &quot;ModalCursorShapeConfig&quot;,</span>
<span class="gi">+    &quot;DynamicCursorShapeConfig&quot;,</span>
<span class="gi">+    &quot;to_cursor_shape_config&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class CursorShape(Enum):
<span class="gd">-    _NEVER_CHANGE = &#39;_NEVER_CHANGE&#39;</span>
<span class="gd">-    BLOCK = &#39;BLOCK&#39;</span>
<span class="gd">-    BEAM = &#39;BEAM&#39;</span>
<span class="gd">-    UNDERLINE = &#39;UNDERLINE&#39;</span>
<span class="gd">-    BLINKING_BLOCK = &#39;BLINKING_BLOCK&#39;</span>
<span class="gd">-    BLINKING_BEAM = &#39;BLINKING_BEAM&#39;</span>
<span class="gd">-    BLINKING_UNDERLINE = &#39;BLINKING_UNDERLINE&#39;</span>
<span class="gi">+    # Default value that should tell the output implementation to never send</span>
<span class="gi">+    # cursor shape escape sequences. This is the default right now, because</span>
<span class="gi">+    # before this `CursorShape` functionality was introduced into</span>
<span class="gi">+    # prompt_toolkit itself, people had workarounds to send cursor shapes</span>
<span class="gi">+    # escapes into the terminal, by monkey patching some of prompt_toolkit&#39;s</span>
<span class="gi">+    # internals. We don&#39;t want the default prompt_toolkit implementation to</span>
<span class="gi">+    # interfere with that. E.g., IPython patches the `ViState.input_mode`</span>
<span class="gi">+    # property. See: https://github.com/ipython/ipython/pull/13501/files</span>
<span class="gi">+    _NEVER_CHANGE = &quot;_NEVER_CHANGE&quot;</span>
<span class="gi">+</span>
<span class="gi">+    BLOCK = &quot;BLOCK&quot;</span>
<span class="gi">+    BEAM = &quot;BEAM&quot;</span>
<span class="gi">+    UNDERLINE = &quot;UNDERLINE&quot;</span>
<span class="gi">+    BLINKING_BLOCK = &quot;BLINKING_BLOCK&quot;</span>
<span class="gi">+    BLINKING_BEAM = &quot;BLINKING_BEAM&quot;</span>
<span class="gi">+    BLINKING_UNDERLINE = &quot;BLINKING_UNDERLINE&quot;</span>


<span class="w"> </span>class CursorShapeConfig(ABC):
<span class="gd">-</span>
<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_cursor_shape(self, application: Application[Any]) -&gt;CursorShape:</span>
<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt; CursorShape:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the cursor shape to be used in the current state.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>AnyCursorShapeConfig = Union[CursorShape, CursorShapeConfig, None]
<span class="gu">@@ -39,27 +55,50 @@ class SimpleCursorShapeConfig(CursorShapeConfig):</span>
<span class="w"> </span>    Always show the given cursor shape.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cursor_shape: CursorShape=CursorShape._NEVER_CHANGE</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, cursor_shape: CursorShape = CursorShape._NEVER_CHANGE) -&gt; None:</span>
<span class="w"> </span>        self.cursor_shape = cursor_shape

<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt; CursorShape:</span>
<span class="gi">+        return self.cursor_shape</span>
<span class="gi">+</span>

<span class="w"> </span>class ModalCursorShapeConfig(CursorShapeConfig):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Show cursor shape according to the current input mode.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt; CursorShape:</span>
<span class="gi">+        if application.editing_mode == EditingMode.VI:</span>
<span class="gi">+            if application.vi_state.input_mode == InputMode.INSERT:</span>
<span class="gi">+                return CursorShape.BEAM</span>
<span class="gi">+            if application.vi_state.input_mode == InputMode.REPLACE:</span>
<span class="gi">+                return CursorShape.UNDERLINE</span>
<span class="gi">+</span>
<span class="gi">+        # Default</span>
<span class="gi">+        return CursorShape.BLOCK</span>

<span class="gd">-class DynamicCursorShapeConfig(CursorShapeConfig):</span>

<span class="gd">-    def __init__(self, get_cursor_shape_config: Callable[[],</span>
<span class="gd">-        AnyCursorShapeConfig]) -&gt;None:</span>
<span class="gi">+class DynamicCursorShapeConfig(CursorShapeConfig):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, get_cursor_shape_config: Callable[[], AnyCursorShapeConfig]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.get_cursor_shape_config = get_cursor_shape_config

<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt; CursorShape:</span>
<span class="gi">+        return to_cursor_shape_config(self.get_cursor_shape_config()).get_cursor_shape(</span>
<span class="gi">+            application</span>
<span class="gi">+        )</span>

<span class="gd">-def to_cursor_shape_config(value: AnyCursorShapeConfig) -&gt;CursorShapeConfig:</span>
<span class="gi">+</span>
<span class="gi">+def to_cursor_shape_config(value: AnyCursorShapeConfig) -&gt; CursorShapeConfig:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a `CursorShape` instance or `CursorShapeConfig` and turn it into a
<span class="w"> </span>    `CursorShapeConfig`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return SimpleCursorShapeConfig()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, CursorShape):</span>
<span class="gi">+        return SimpleCursorShapeConfig(value)</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>
<span class="gh">diff --git a/src/prompt_toolkit/data_structures.py b/src/prompt_toolkit/data_structures.py</span>
<span class="gh">index 8b413a31..27dd4585 100644</span>
<span class="gd">--- a/src/prompt_toolkit/data_structures.py</span>
<span class="gi">+++ b/src/prompt_toolkit/data_structures.py</span>
<span class="gu">@@ -1,6 +1,11 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import NamedTuple
<span class="gd">-__all__ = [&#39;Point&#39;, &#39;Size&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Point&quot;,</span>
<span class="gi">+    &quot;Size&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Point(NamedTuple):
<span class="gh">diff --git a/src/prompt_toolkit/document.py b/src/prompt_toolkit/document.py</span>
<span class="gh">index c246ba0d..74f4c13f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/document.py</span>
<span class="gi">+++ b/src/prompt_toolkit/document.py</span>
<span class="gu">@@ -2,25 +2,46 @@</span>
<span class="w"> </span>The `Document` that implements all the text operations/querying.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import bisect
<span class="w"> </span>import re
<span class="w"> </span>import string
<span class="w"> </span>import weakref
<span class="w"> </span>from typing import Callable, Dict, Iterable, List, NoReturn, Pattern, cast
<span class="gi">+</span>
<span class="w"> </span>from .clipboard import ClipboardData
<span class="w"> </span>from .filters import vi_mode
<span class="w"> </span>from .selection import PasteMode, SelectionState, SelectionType
<span class="gd">-__all__ = [&#39;Document&#39;]</span>
<span class="gd">-_FIND_WORD_RE = re.compile(&#39;([a-zA-Z0-9_]+|[^a-zA-Z0-9_\\s]+)&#39;)</span>
<span class="gd">-_FIND_CURRENT_WORD_RE = re.compile(&#39;^([a-zA-Z0-9_]+|[^a-zA-Z0-9_\\s]+)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Document&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Regex for finding &quot;words&quot; in documents. (We consider a group of alnum</span>
<span class="gi">+# characters a word, but also a group of special characters a word, as long as</span>
<span class="gi">+# it doesn&#39;t contain a space.)</span>
<span class="gi">+# (This is a &#39;word&#39; in Vi.)</span>
<span class="gi">+_FIND_WORD_RE = re.compile(r&quot;([a-zA-Z0-9_]+|[^a-zA-Z0-9_\s]+)&quot;)</span>
<span class="gi">+_FIND_CURRENT_WORD_RE = re.compile(r&quot;^([a-zA-Z0-9_]+|[^a-zA-Z0-9_\s]+)&quot;)</span>
<span class="w"> </span>_FIND_CURRENT_WORD_INCLUDE_TRAILING_WHITESPACE_RE = re.compile(
<span class="gd">-    &#39;^(([a-zA-Z0-9_]+|[^a-zA-Z0-9_\\s]+)\\s*)&#39;)</span>
<span class="gd">-_FIND_BIG_WORD_RE = re.compile(&#39;([^\\s]+)&#39;)</span>
<span class="gd">-_FIND_CURRENT_BIG_WORD_RE = re.compile(&#39;^([^\\s]+)&#39;)</span>
<span class="gd">-_FIND_CURRENT_BIG_WORD_INCLUDE_TRAILING_WHITESPACE_RE = re.compile(</span>
<span class="gd">-    &#39;^([^\\s]+\\s*)&#39;)</span>
<span class="gd">-_text_to_document_cache: dict[str, _DocumentCache] = cast(Dict[str,</span>
<span class="gd">-    &#39;_DocumentCache&#39;], weakref.WeakValueDictionary())</span>
<span class="gi">+    r&quot;^(([a-zA-Z0-9_]+|[^a-zA-Z0-9_\s]+)\s*)&quot;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# Regex for finding &quot;WORDS&quot; in documents.</span>
<span class="gi">+# (This is a &#39;WORD in Vi.)</span>
<span class="gi">+_FIND_BIG_WORD_RE = re.compile(r&quot;([^\s]+)&quot;)</span>
<span class="gi">+_FIND_CURRENT_BIG_WORD_RE = re.compile(r&quot;^([^\s]+)&quot;)</span>
<span class="gi">+_FIND_CURRENT_BIG_WORD_INCLUDE_TRAILING_WHITESPACE_RE = re.compile(r&quot;^([^\s]+\s*)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# Share the Document._cache between all Document instances.</span>
<span class="gi">+# (Document instances are considered immutable. That means that if another</span>
<span class="gi">+# `Document` is constructed with the same text, it should have the same</span>
<span class="gi">+# `_DocumentCache`.)</span>
<span class="gi">+_text_to_document_cache: dict[str, _DocumentCache] = cast(</span>
<span class="gi">+    Dict[str, &quot;_DocumentCache&quot;],</span>
<span class="gi">+    weakref.WeakValueDictionary(),  # Maps document.text to DocumentCache instance.</span>
<span class="gi">+)</span>


<span class="w"> </span>class _ImmutableLineList(List[str]):
<span class="gu">@@ -28,7 +49,11 @@ class _ImmutableLineList(List[str]):</span>
<span class="w"> </span>    Some protection for our &#39;lines&#39; list, which is assumed to be immutable in the cache.
<span class="w"> </span>    (Useful for detecting obvious bugs.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __setitem__ = _error</span>
<span class="gi">+</span>
<span class="gi">+    def _error(self, *a: object, **kw: object) -&gt; NoReturn:</span>
<span class="gi">+        raise NotImplementedError(&quot;Attempt to modify an immutable list.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    __setitem__ = _error  # type: ignore</span>
<span class="w"> </span>    append = _error
<span class="w"> </span>    clear = _error
<span class="w"> </span>    extend = _error
<span class="gu">@@ -36,13 +61,15 @@ class _ImmutableLineList(List[str]):</span>
<span class="w"> </span>    pop = _error
<span class="w"> </span>    remove = _error
<span class="w"> </span>    reverse = _error
<span class="gd">-    sort = _error</span>
<span class="gi">+    sort = _error  # type: ignore</span>


<span class="w"> </span>class _DocumentCache:
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        #: List of lines for the Document text.</span>
<span class="w"> </span>        self.lines: _ImmutableLineList | None = None
<span class="gi">+</span>
<span class="gi">+        #: List of index positions, pointing to the start of all the lines.</span>
<span class="w"> </span>        self.line_indexes: list[int] | None = None


<span class="gu">@@ -58,213 +85,358 @@ class Document:</span>
<span class="w"> </span>    :param cursor_position: int
<span class="w"> </span>    :param selection: :class:`.SelectionState`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_text&#39;, &#39;_cursor_position&#39;, &#39;_selection&#39;, &#39;_cache&#39;</span>

<span class="gd">-    def __init__(self, text: str=&#39;&#39;, cursor_position: (int | None)=None,</span>
<span class="gd">-        selection: (SelectionState | None)=None) -&gt;None:</span>
<span class="gd">-        assert cursor_position is None or cursor_position &lt;= len(text</span>
<span class="gd">-            ), AssertionError(</span>
<span class="gd">-            f&#39;cursor_position={cursor_position!r}, len_text={len(text)!r}&#39;)</span>
<span class="gi">+    __slots__ = (&quot;_text&quot;, &quot;_cursor_position&quot;, &quot;_selection&quot;, &quot;_cache&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: str = &quot;&quot;,</span>
<span class="gi">+        cursor_position: int | None = None,</span>
<span class="gi">+        selection: SelectionState | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Check cursor position. It can also be right after the end. (Where we</span>
<span class="gi">+        # insert text.)</span>
<span class="gi">+        assert cursor_position is None or cursor_position &lt;= len(text), AssertionError(</span>
<span class="gi">+            f&quot;cursor_position={cursor_position!r}, len_text={len(text)!r}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # By default, if no cursor position was given, make sure to put the</span>
<span class="gi">+        # cursor position is at the end of the document. This is what makes</span>
<span class="gi">+        # sense in most places.</span>
<span class="w"> </span>        if cursor_position is None:
<span class="w"> </span>            cursor_position = len(text)
<span class="gi">+</span>
<span class="gi">+        # Keep these attributes private. A `Document` really has to be</span>
<span class="gi">+        # considered to be immutable, because otherwise the caching will break</span>
<span class="gi">+        # things. Because of that, we wrap these into read-only properties.</span>
<span class="w"> </span>        self._text = text
<span class="w"> </span>        self._cursor_position = cursor_position
<span class="w"> </span>        self._selection = selection
<span class="gi">+</span>
<span class="gi">+        # Cache for lines/indexes. (Shared with other Document instances that</span>
<span class="gi">+        # contain the same text.</span>
<span class="w"> </span>        try:
<span class="w"> </span>            self._cache = _text_to_document_cache[self.text]
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            self._cache = _DocumentCache()
<span class="w"> </span>            _text_to_document_cache[self.text] = self._cache

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}({self.text!r}, {self.cursor_position!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        # XX: For some reason, above, we can&#39;t use &#39;WeakValueDictionary.setdefault&#39;.</span>
<span class="gi">+        #     This fails in Pypy3. `self._cache` becomes None, because that&#39;s what</span>
<span class="gi">+        #     &#39;setdefault&#39; returns.</span>
<span class="gi">+        # self._cache = _text_to_document_cache.setdefault(self.text, _DocumentCache())</span>
<span class="gi">+        # assert self._cache</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.text!r}, {self.cursor_position!r})&quot;</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, Document):
<span class="w"> </span>            return False
<span class="gd">-        return (self.text == other.text and self.cursor_position == other.</span>
<span class="gd">-            cursor_position and self.selection == other.selection)</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.text == other.text</span>
<span class="gi">+            and self.cursor_position == other.cursor_position</span>
<span class="gi">+            and self.selection == other.selection</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def text(self) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;The document text.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def text(self) -&gt; str:</span>
<span class="gi">+        &quot;The document text.&quot;</span>
<span class="gi">+        return self._text</span>

<span class="w"> </span>    @property
<span class="gd">-    def cursor_position(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;The document cursor position.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_position(self) -&gt; int:</span>
<span class="gi">+        &quot;The document cursor position.&quot;</span>
<span class="gi">+        return self._cursor_position</span>

<span class="w"> </span>    @property
<span class="gd">-    def selection(self) -&gt;(SelectionState | None):</span>
<span class="gd">-        &quot;&quot;&quot;:class:`.SelectionState` object.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def selection(self) -&gt; SelectionState | None:</span>
<span class="gi">+        &quot;:class:`.SelectionState` object.&quot;</span>
<span class="gi">+        return self._selection</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_char(self) -&gt;str:</span>
<span class="gi">+    def current_char(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return character under cursor or an empty string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_char_relative_to_cursor(0) or &quot;&quot;</span>

<span class="w"> </span>    @property
<span class="gd">-    def char_before_cursor(self) -&gt;str:</span>
<span class="gi">+    def char_before_cursor(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return character before the cursor or an empty string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_char_relative_to_cursor(-1) or &quot;&quot;</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_line_before_cursor(self) -&gt;str:</span>
<span class="gi">+    def text_before_cursor(self) -&gt; str:</span>
<span class="gi">+        return self.text[: self.cursor_position :]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def text_after_cursor(self) -&gt; str:</span>
<span class="gi">+        return self.text[self.cursor_position :]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def current_line_before_cursor(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Text from the start of the line until the cursor.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        _, _, text = self.text_before_cursor.rpartition(&quot;\n&quot;)</span>
<span class="gi">+        return text</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_line_after_cursor(self) -&gt;str:</span>
<span class="gi">+    def current_line_after_cursor(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Text from the cursor until the end of the line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        text, _, _ = self.text_after_cursor.partition(&quot;\n&quot;)</span>
<span class="gi">+        return text</span>

<span class="w"> </span>    @property
<span class="gd">-    def lines(self) -&gt;list[str]:</span>
<span class="gi">+    def lines(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Array of all the lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Cache, because this one is reused very often.</span>
<span class="gi">+        if self._cache.lines is None:</span>
<span class="gi">+            self._cache.lines = _ImmutableLineList(self.text.split(&quot;\n&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        return self._cache.lines</span>

<span class="w"> </span>    @property
<span class="gd">-    def _line_start_indexes(self) -&gt;list[int]:</span>
<span class="gi">+    def _line_start_indexes(self) -&gt; list[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Array pointing to the start indexes of all the lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Cache, because this is often reused. (If it is used, it&#39;s often used</span>
<span class="gi">+        # many times. And this has to be fast for editing big documents!)</span>
<span class="gi">+        if self._cache.line_indexes is None:</span>
<span class="gi">+            # Create list of line lengths.</span>
<span class="gi">+            line_lengths = map(len, self.lines)</span>
<span class="gi">+</span>
<span class="gi">+            # Calculate cumulative sums.</span>
<span class="gi">+            indexes = [0]</span>
<span class="gi">+            append = indexes.append</span>
<span class="gi">+            pos = 0</span>
<span class="gi">+</span>
<span class="gi">+            for line_length in line_lengths:</span>
<span class="gi">+                pos += line_length + 1</span>
<span class="gi">+                append(pos)</span>
<span class="gi">+</span>
<span class="gi">+            # Remove the last item. (This is not a new line.)</span>
<span class="gi">+            if len(indexes) &gt; 1:</span>
<span class="gi">+                indexes.pop()</span>
<span class="gi">+</span>
<span class="gi">+            self._cache.line_indexes = indexes</span>
<span class="gi">+</span>
<span class="gi">+        return self._cache.line_indexes</span>

<span class="w"> </span>    @property
<span class="gd">-    def lines_from_current(self) -&gt;list[str]:</span>
<span class="gi">+    def lines_from_current(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Array of the lines starting from the current line, until the last line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.lines[self.cursor_position_row :]</span>

<span class="w"> </span>    @property
<span class="gd">-    def line_count(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;Return the number of lines in this document. If the document ends</span>
<span class="gd">-        with a trailing \\n, that counts as the beginning of a new line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def line_count(self) -&gt; int:</span>
<span class="gi">+        r&quot;&quot;&quot;Return the number of lines in this document. If the document ends</span>
<span class="gi">+        with a trailing \n, that counts as the beginning of a new line.&quot;&quot;&quot;</span>
<span class="gi">+        return len(self.lines)</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_line(self) -&gt;str:</span>
<span class="gi">+    def current_line(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the text on the line where the cursor is. (when the input
<span class="w"> </span>        consists of just one line, it equals `text`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_line_before_cursor + self.current_line_after_cursor</span>

<span class="w"> </span>    @property
<span class="gd">-    def leading_whitespace_in_current_line(self) -&gt;str:</span>
<span class="gi">+    def leading_whitespace_in_current_line(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The leading whitespace in the left margin of the current line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        current_line = self.current_line</span>
<span class="gi">+        length = len(current_line) - len(current_line.lstrip())</span>
<span class="gi">+        return current_line[:length]</span>

<span class="gd">-    def _get_char_relative_to_cursor(self, offset: int=0) -&gt;str:</span>
<span class="gi">+    def _get_char_relative_to_cursor(self, offset: int = 0) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return character relative to cursor position, or empty string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.text[self.cursor_position + offset]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return &quot;&quot;</span>

<span class="w"> </span>    @property
<span class="gd">-    def on_first_line(self) -&gt;bool:</span>
<span class="gi">+    def on_first_line(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when we are at the first line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cursor_position_row == 0</span>

<span class="w"> </span>    @property
<span class="gd">-    def on_last_line(self) -&gt;bool:</span>
<span class="gi">+    def on_last_line(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when we are at the last line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cursor_position_row == self.line_count - 1</span>

<span class="w"> </span>    @property
<span class="gd">-    def cursor_position_row(self) -&gt;int:</span>
<span class="gi">+    def cursor_position_row(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Current row. (0-based.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        row, _ = self._find_line_start_index(self.cursor_position)</span>
<span class="gi">+        return row</span>

<span class="w"> </span>    @property
<span class="gd">-    def cursor_position_col(self) -&gt;int:</span>
<span class="gi">+    def cursor_position_col(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Current column. (0-based.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # (Don&#39;t use self.text_before_cursor to calculate this. Creating</span>
<span class="gi">+        # substrings and doing rsplit is too expensive for getting the cursor</span>
<span class="gi">+        # position.)</span>
<span class="gi">+        _, line_start_index = self._find_line_start_index(self.cursor_position)</span>
<span class="gi">+        return self.cursor_position - line_start_index</span>

<span class="gd">-    def _find_line_start_index(self, index: int) -&gt;tuple[int, int]:</span>
<span class="gi">+    def _find_line_start_index(self, index: int) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For the index of a character at a certain line, calculate the index of
<span class="w"> </span>        the first character on that line.

<span class="w"> </span>        Return (row, index) tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indexes = self._line_start_indexes</span>

<span class="gd">-    def translate_index_to_position(self, index: int) -&gt;tuple[int, int]:</span>
<span class="gi">+        pos = bisect.bisect_right(indexes, index) - 1</span>
<span class="gi">+        return pos, indexes[pos]</span>
<span class="gi">+</span>
<span class="gi">+    def translate_index_to_position(self, index: int) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Given an index for the text, return the corresponding (row, col) tuple.
<span class="w"> </span>        (0-based. Returns (0, 0) for index=0.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Find start of this line.</span>
<span class="gi">+        row, row_index = self._find_line_start_index(index)</span>
<span class="gi">+        col = index - row_index</span>
<span class="gi">+</span>
<span class="gi">+        return row, col</span>

<span class="gd">-    def translate_row_col_to_index(self, row: int, col: int) -&gt;int:</span>
<span class="gi">+    def translate_row_col_to_index(self, row: int, col: int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Given a (row, col) tuple, return the corresponding index.
<span class="w"> </span>        (Row and col params are 0-based.)

<span class="w"> </span>        Negative row/col values are turned into zero.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = self._line_start_indexes[row]</span>
<span class="gi">+            line = self.lines[row]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            if row &lt; 0:</span>
<span class="gi">+                result = self._line_start_indexes[0]</span>
<span class="gi">+                line = self.lines[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = self._line_start_indexes[-1]</span>
<span class="gi">+                line = self.lines[-1]</span>
<span class="gi">+</span>
<span class="gi">+        result += max(0, min(col, len(line)))</span>
<span class="gi">+</span>
<span class="gi">+        # Keep in range. (len(self.text) is included, because the cursor can be</span>
<span class="gi">+        # right after the end of the text as well.)</span>
<span class="gi">+        result = max(0, min(result, len(self.text)))</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_cursor_at_the_end(self) -&gt;bool:</span>
<span class="gi">+    def is_cursor_at_the_end(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;True when the cursor is at the end of the text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cursor_position == len(self.text)</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_cursor_at_the_end_of_line(self) -&gt;bool:</span>
<span class="gi">+    def is_cursor_at_the_end_of_line(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;True when the cursor is at the end of this line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_char in (&quot;\n&quot;, &quot;&quot;)</span>

<span class="gd">-    def has_match_at_current_position(self, sub: str) -&gt;bool:</span>
<span class="gi">+    def has_match_at_current_position(self, sub: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        `True` when this substring is found at the cursor position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.text.find(sub, self.cursor_position) == self.cursor_position</span>

<span class="gd">-    def find(self, sub: str, in_current_line: bool=False,</span>
<span class="gd">-        include_current_position: bool=False, ignore_case: bool=False,</span>
<span class="gd">-        count: int=1) -&gt;(int | None):</span>
<span class="gi">+    def find(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sub: str,</span>
<span class="gi">+        in_current_line: bool = False,</span>
<span class="gi">+        include_current_position: bool = False,</span>
<span class="gi">+        ignore_case: bool = False,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find `text` after the cursor, return position relative to the cursor
<span class="w"> </span>        position. Return `None` if nothing was found.

<span class="w"> </span>        :param count: Find the n-th occurrence.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(ignore_case, bool)</span>
<span class="gi">+</span>
<span class="gi">+        if in_current_line:</span>
<span class="gi">+            text = self.current_line_after_cursor</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = self.text_after_cursor</span>
<span class="gi">+</span>
<span class="gi">+        if not include_current_position:</span>
<span class="gi">+            if len(text) == 0:</span>
<span class="gi">+                return None  # (Otherwise, we always get a match for the empty string.)</span>
<span class="gi">+            else:</span>
<span class="gi">+                text = text[1:]</span>
<span class="gi">+</span>
<span class="gi">+        flags = re.IGNORECASE if ignore_case else 0</span>
<span class="gi">+        iterator = re.finditer(re.escape(sub), text, flags)</span>

<span class="gd">-    def find_all(self, sub: str, ignore_case: bool=False) -&gt;list[int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterator):</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    if include_current_position:</span>
<span class="gi">+                        return match.start(0)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        return match.start(0) + 1</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_all(self, sub: str, ignore_case: bool = False) -&gt; list[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find all occurrences of the substring. Return a list of absolute
<span class="w"> </span>        positions in the document.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        flags = re.IGNORECASE if ignore_case else 0</span>
<span class="gi">+        return [a.start() for a in re.finditer(re.escape(sub), self.text, flags)]</span>

<span class="gd">-    def find_backwards(self, sub: str, in_current_line: bool=False,</span>
<span class="gd">-        ignore_case: bool=False, count: int=1) -&gt;(int | None):</span>
<span class="gi">+    def find_backwards(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sub: str,</span>
<span class="gi">+        in_current_line: bool = False,</span>
<span class="gi">+        ignore_case: bool = False,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find `text` before the cursor, return position relative to the cursor
<span class="w"> </span>        position. Return `None` if nothing was found.

<span class="w"> </span>        :param count: Find the n-th occurrence.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if in_current_line:</span>
<span class="gi">+            before_cursor = self.current_line_before_cursor[::-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            before_cursor = self.text_before_cursor[::-1]</span>
<span class="gi">+</span>
<span class="gi">+        flags = re.IGNORECASE if ignore_case else 0</span>
<span class="gi">+        iterator = re.finditer(re.escape(sub[::-1]), before_cursor, flags)</span>

<span class="gd">-    def get_word_before_cursor(self, WORD: bool=False, pattern: (Pattern[</span>
<span class="gd">-        str] | None)=None) -&gt;str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterator):</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    return -match.start(0) - len(sub)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_word_before_cursor(</span>
<span class="gi">+        self, WORD: bool = False, pattern: Pattern[str] | None = None</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Give the word before the cursor.
<span class="w"> </span>        If we have whitespace before the cursor this returns an empty string.
<span class="gu">@@ -272,10 +444,28 @@ class Document:</span>
<span class="w"> </span>        :param pattern: (None or compiled regex). When given, use this regex
<span class="w"> </span>            pattern.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._is_word_before_cursor_complete(WORD=WORD, pattern=pattern):</span>
<span class="gi">+            # Space before the cursor or no text before cursor.</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        text_before_cursor = self.text_before_cursor</span>
<span class="gi">+        start = self.find_start_of_previous_word(WORD=WORD, pattern=pattern) or 0</span>

<span class="gd">-    def find_start_of_previous_word(self, count: int=1, WORD: bool=False,</span>
<span class="gd">-        pattern: (Pattern[str] | None)=None) -&gt;(int | None):</span>
<span class="gi">+        return text_before_cursor[len(text_before_cursor) + start :]</span>
<span class="gi">+</span>
<span class="gi">+    def _is_word_before_cursor_complete(</span>
<span class="gi">+        self, WORD: bool = False, pattern: Pattern[str] | None = None</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if pattern:</span>
<span class="gi">+            return self.find_start_of_previous_word(WORD=WORD, pattern=pattern) is None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (</span>
<span class="gi">+                self.text_before_cursor == &quot;&quot; or self.text_before_cursor[-1:].isspace()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def find_start_of_previous_word(</span>
<span class="gi">+        self, count: int = 1, WORD: bool = False, pattern: Pattern[str] | None = None</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return an index relative to the cursor position pointing to the start
<span class="w"> </span>        of the previous word. Return `None` if nothing was found.
<span class="gu">@@ -283,88 +473,244 @@ class Document:</span>
<span class="w"> </span>        :param pattern: (None or compiled regex). When given, use this regex
<span class="w"> </span>            pattern.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert not (WORD and pattern)</span>
<span class="gi">+</span>
<span class="gi">+        # Reverse the text before the cursor, in order to do an efficient</span>
<span class="gi">+        # backwards search.</span>
<span class="gi">+        text_before_cursor = self.text_before_cursor[::-1]</span>

<span class="gd">-    def find_boundaries_of_current_word(self, WORD: bool=False,</span>
<span class="gd">-        include_leading_whitespace: bool=False, include_trailing_whitespace:</span>
<span class="gd">-        bool=False) -&gt;tuple[int, int]:</span>
<span class="gi">+        if pattern:</span>
<span class="gi">+            regex = pattern</span>
<span class="gi">+        elif WORD:</span>
<span class="gi">+            regex = _FIND_BIG_WORD_RE</span>
<span class="gi">+        else:</span>
<span class="gi">+            regex = _FIND_WORD_RE</span>
<span class="gi">+</span>
<span class="gi">+        iterator = regex.finditer(text_before_cursor)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterator):</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    return -match.end(0)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_boundaries_of_current_word(</span>
<span class="gi">+        self,</span>
<span class="gi">+        WORD: bool = False,</span>
<span class="gi">+        include_leading_whitespace: bool = False,</span>
<span class="gi">+        include_trailing_whitespace: bool = False,</span>
<span class="gi">+    ) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the relative boundaries (startpos, endpos) of the current word under the
<span class="w"> </span>        cursor. (This is at the current line, because line boundaries obviously
<span class="w"> </span>        don&#39;t belong to any word.)
<span class="w"> </span>        If not on a word, this returns (0,0)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        text_before_cursor = self.current_line_before_cursor[::-1]</span>
<span class="gi">+        text_after_cursor = self.current_line_after_cursor</span>
<span class="gi">+</span>
<span class="gi">+        def get_regex(include_whitespace: bool) -&gt; Pattern[str]:</span>
<span class="gi">+            return {</span>
<span class="gi">+                (False, False): _FIND_CURRENT_WORD_RE,</span>
<span class="gi">+                (False, True): _FIND_CURRENT_WORD_INCLUDE_TRAILING_WHITESPACE_RE,</span>
<span class="gi">+                (True, False): _FIND_CURRENT_BIG_WORD_RE,</span>
<span class="gi">+                (True, True): _FIND_CURRENT_BIG_WORD_INCLUDE_TRAILING_WHITESPACE_RE,</span>
<span class="gi">+            }[(WORD, include_whitespace)]</span>
<span class="gi">+</span>
<span class="gi">+        match_before = get_regex(include_leading_whitespace).search(text_before_cursor)</span>
<span class="gi">+        match_after = get_regex(include_trailing_whitespace).search(text_after_cursor)</span>
<span class="gi">+</span>
<span class="gi">+        # When there is a match before and after, and we&#39;re not looking for</span>
<span class="gi">+        # WORDs, make sure that both the part before and after the cursor are</span>
<span class="gi">+        # either in the [a-zA-Z_] alphabet or not. Otherwise, drop the part</span>
<span class="gi">+        # before the cursor.</span>
<span class="gi">+        if not WORD and match_before and match_after:</span>
<span class="gi">+            c1 = self.text[self.cursor_position - 1]</span>
<span class="gi">+            c2 = self.text[self.cursor_position]</span>
<span class="gi">+            alphabet = string.ascii_letters + &quot;0123456789_&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if (c1 in alphabet) != (c2 in alphabet):</span>
<span class="gi">+                match_before = None</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            -match_before.end(1) if match_before else 0,</span>
<span class="gi">+            match_after.end(1) if match_after else 0,</span>
<span class="gi">+        )</span>

<span class="gd">-    def get_word_under_cursor(self, WORD: bool=False) -&gt;str:</span>
<span class="gi">+    def get_word_under_cursor(self, WORD: bool = False) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the word, currently below the cursor.
<span class="w"> </span>        This returns an empty string when the cursor is on a whitespace region.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start, end = self.find_boundaries_of_current_word(WORD=WORD)</span>
<span class="gi">+        return self.text[self.cursor_position + start : self.cursor_position + end]</span>

<span class="gd">-    def find_next_word_beginning(self, count: int=1, WORD: bool=False) -&gt;(int |</span>
<span class="gd">-        None):</span>
<span class="gi">+    def find_next_word_beginning(</span>
<span class="gi">+        self, count: int = 1, WORD: bool = False</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return an index relative to the cursor position pointing to the start
<span class="w"> </span>        of the next word. Return `None` if nothing was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            return self.find_previous_word_beginning(count=-count, WORD=WORD)</span>

<span class="gd">-    def find_next_word_ending(self, include_current_position: bool=False,</span>
<span class="gd">-        count: int=1, WORD: bool=False) -&gt;(int | None):</span>
<span class="gi">+        regex = _FIND_BIG_WORD_RE if WORD else _FIND_WORD_RE</span>
<span class="gi">+        iterator = regex.finditer(self.text_after_cursor)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterator):</span>
<span class="gi">+                # Take first match, unless it&#39;s the word on which we&#39;re right now.</span>
<span class="gi">+                if i == 0 and match.start(1) == 0:</span>
<span class="gi">+                    count += 1</span>
<span class="gi">+</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    return match.start(1)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_next_word_ending(</span>
<span class="gi">+        self, include_current_position: bool = False, count: int = 1, WORD: bool = False</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return an index relative to the cursor position pointing to the end
<span class="w"> </span>        of the next word. Return `None` if nothing was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            return self.find_previous_word_ending(count=-count, WORD=WORD)</span>
<span class="gi">+</span>
<span class="gi">+        if include_current_position:</span>
<span class="gi">+            text = self.text_after_cursor</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = self.text_after_cursor[1:]</span>
<span class="gi">+</span>
<span class="gi">+        regex = _FIND_BIG_WORD_RE if WORD else _FIND_WORD_RE</span>
<span class="gi">+        iterable = regex.finditer(text)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterable):</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    value = match.end(1)</span>
<span class="gi">+</span>
<span class="gi">+                    if include_current_position:</span>
<span class="gi">+                        return value</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        return value + 1</span>

<span class="gd">-    def find_previous_word_beginning(self, count: int=1, WORD: bool=False) -&gt;(</span>
<span class="gd">-        int | None):</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_previous_word_beginning(</span>
<span class="gi">+        self, count: int = 1, WORD: bool = False</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return an index relative to the cursor position pointing to the start
<span class="w"> </span>        of the previous word. Return `None` if nothing was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            return self.find_next_word_beginning(count=-count, WORD=WORD)</span>
<span class="gi">+</span>
<span class="gi">+        regex = _FIND_BIG_WORD_RE if WORD else _FIND_WORD_RE</span>
<span class="gi">+        iterator = regex.finditer(self.text_before_cursor[::-1])</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterator):</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    return -match.end(1)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def find_previous_word_ending(self, count: int=1, WORD: bool=False) -&gt;(int</span>
<span class="gd">-         | None):</span>
<span class="gi">+    def find_previous_word_ending(</span>
<span class="gi">+        self, count: int = 1, WORD: bool = False</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return an index relative to the cursor position pointing to the end
<span class="w"> </span>        of the previous word. Return `None` if nothing was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            return self.find_next_word_ending(count=-count, WORD=WORD)</span>
<span class="gi">+</span>
<span class="gi">+        text_before_cursor = self.text_after_cursor[:1] + self.text_before_cursor[::-1]</span>
<span class="gi">+</span>
<span class="gi">+        regex = _FIND_BIG_WORD_RE if WORD else _FIND_WORD_RE</span>
<span class="gi">+        iterator = regex.finditer(text_before_cursor)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for i, match in enumerate(iterator):</span>
<span class="gi">+                # Take first match, unless it&#39;s the word on which we&#39;re right now.</span>
<span class="gi">+                if i == 0 and match.start(1) == 0:</span>
<span class="gi">+                    count += 1</span>

<span class="gd">-    def find_next_matching_line(self, match_func: Callable[[str], bool],</span>
<span class="gd">-        count: int=1) -&gt;(int | None):</span>
<span class="gi">+                if i + 1 == count:</span>
<span class="gi">+                    return -match.start(1) + 1</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_next_matching_line(</span>
<span class="gi">+        self, match_func: Callable[[str], bool], count: int = 1</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Look downwards for empty lines.
<span class="w"> </span>        Return the line index, relative to the current line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = None</span>
<span class="gi">+</span>
<span class="gi">+        for index, line in enumerate(self.lines[self.cursor_position_row + 1 :]):</span>
<span class="gi">+            if match_func(line):</span>
<span class="gi">+                result = 1 + index</span>
<span class="gi">+                count -= 1</span>
<span class="gi">+</span>
<span class="gi">+            if count == 0:</span>
<span class="gi">+                break</span>

<span class="gd">-    def find_previous_matching_line(self, match_func: Callable[[str], bool],</span>
<span class="gd">-        count: int=1) -&gt;(int | None):</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def find_previous_matching_line(</span>
<span class="gi">+        self, match_func: Callable[[str], bool], count: int = 1</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Look upwards for empty lines.
<span class="w"> </span>        Return the line index, relative to the current line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = None</span>
<span class="gi">+</span>
<span class="gi">+        for index, line in enumerate(self.lines[: self.cursor_position_row][::-1]):</span>
<span class="gi">+            if match_func(line):</span>
<span class="gi">+                result = -1 - index</span>
<span class="gi">+                count -= 1</span>

<span class="gd">-    def get_cursor_left_position(self, count: int=1) -&gt;int:</span>
<span class="gi">+            if count == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def get_cursor_left_position(self, count: int = 1) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Relative position for cursor left.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            return self.get_cursor_right_position(-count)</span>

<span class="gd">-    def get_cursor_right_position(self, count: int=1) -&gt;int:</span>
<span class="gi">+        return -min(self.cursor_position_col, count)</span>
<span class="gi">+</span>
<span class="gi">+    def get_cursor_right_position(self, count: int = 1) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Relative position for cursor_right.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            return self.get_cursor_left_position(-count)</span>
<span class="gi">+</span>
<span class="gi">+        return min(count, len(self.current_line_after_cursor))</span>

<span class="gd">-    def get_cursor_up_position(self, count: int=1, preferred_column: (int |</span>
<span class="gd">-        None)=None) -&gt;int:</span>
<span class="gi">+    def get_cursor_up_position(</span>
<span class="gi">+        self, count: int = 1, preferred_column: int | None = None</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the relative cursor position (character index) where we would be if the
<span class="w"> </span>        user pressed the arrow-up button.
<span class="gu">@@ -372,10 +718,21 @@ class Document:</span>
<span class="w"> </span>        :param preferred_column: When given, go to this column instead of
<span class="w"> </span>                                 staying at the current column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert count &gt;= 1</span>
<span class="gi">+        column = (</span>
<span class="gi">+            self.cursor_position_col if preferred_column is None else preferred_column</span>
<span class="gi">+        )</span>

<span class="gd">-    def get_cursor_down_position(self, count: int=1, preferred_column: (int |</span>
<span class="gd">-        None)=None) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.translate_row_col_to_index(</span>
<span class="gi">+                max(0, self.cursor_position_row - count), column</span>
<span class="gi">+            )</span>
<span class="gi">+            - self.cursor_position</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_cursor_down_position(</span>
<span class="gi">+        self, count: int = 1, preferred_column: int | None = None</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the relative cursor position (character index) where we would be if the
<span class="w"> </span>        user pressed the arrow-down button.
<span class="gu">@@ -383,68 +740,149 @@ class Document:</span>
<span class="w"> </span>        :param preferred_column: When given, go to this column instead of
<span class="w"> </span>                                 staying at the current column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert count &gt;= 1</span>
<span class="gi">+        column = (</span>
<span class="gi">+            self.cursor_position_col if preferred_column is None else preferred_column</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.translate_row_col_to_index(self.cursor_position_row + count, column)</span>
<span class="gi">+            - self.cursor_position</span>
<span class="gi">+        )</span>

<span class="gd">-    def find_enclosing_bracket_right(self, left_ch: str, right_ch: str,</span>
<span class="gd">-        end_pos: (int | None)=None) -&gt;(int | None):</span>
<span class="gi">+    def find_enclosing_bracket_right(</span>
<span class="gi">+        self, left_ch: str, right_ch: str, end_pos: int | None = None</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find the right bracket enclosing current position. Return the relative
<span class="w"> </span>        position to the cursor position.

<span class="w"> </span>        When `end_pos` is given, don&#39;t look past the position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.current_char == right_ch:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        if end_pos is None:</span>
<span class="gi">+            end_pos = len(self.text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            end_pos = min(len(self.text), end_pos)</span>
<span class="gi">+</span>
<span class="gi">+        stack = 1</span>
<span class="gi">+</span>
<span class="gi">+        # Look forward.</span>
<span class="gi">+        for i in range(self.cursor_position + 1, end_pos):</span>
<span class="gi">+            c = self.text[i]</span>
<span class="gi">+</span>
<span class="gi">+            if c == left_ch:</span>
<span class="gi">+                stack += 1</span>
<span class="gi">+            elif c == right_ch:</span>
<span class="gi">+                stack -= 1</span>

<span class="gd">-    def find_enclosing_bracket_left(self, left_ch: str, right_ch: str,</span>
<span class="gd">-        start_pos: (int | None)=None) -&gt;(int | None):</span>
<span class="gi">+            if stack == 0:</span>
<span class="gi">+                return i - self.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_enclosing_bracket_left(</span>
<span class="gi">+        self, left_ch: str, right_ch: str, start_pos: int | None = None</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find the left bracket enclosing current position. Return the relative
<span class="w"> </span>        position to the cursor position.

<span class="w"> </span>        When `start_pos` is given, don&#39;t look past the position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.current_char == left_ch:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        if start_pos is None:</span>
<span class="gi">+            start_pos = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            start_pos = max(0, start_pos)</span>
<span class="gi">+</span>
<span class="gi">+        stack = 1</span>
<span class="gi">+</span>
<span class="gi">+        # Look backward.</span>
<span class="gi">+        for i in range(self.cursor_position - 1, start_pos - 1, -1):</span>
<span class="gi">+            c = self.text[i]</span>

<span class="gd">-    def find_matching_bracket_position(self, start_pos: (int | None)=None,</span>
<span class="gd">-        end_pos: (int | None)=None) -&gt;int:</span>
<span class="gi">+            if c == right_ch:</span>
<span class="gi">+                stack += 1</span>
<span class="gi">+            elif c == left_ch:</span>
<span class="gi">+                stack -= 1</span>
<span class="gi">+</span>
<span class="gi">+            if stack == 0:</span>
<span class="gi">+                return i - self.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_matching_bracket_position(</span>
<span class="gi">+        self, start_pos: int | None = None, end_pos: int | None = None</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return relative cursor position of matching [, (, { or &lt; bracket.

<span class="w"> </span>        When `start_pos` or `end_pos` are given. Don&#39;t look past the positions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_start_of_document_position(self) -&gt;int:</span>
<span class="gi">+        # Look for a match.</span>
<span class="gi">+        for pair in &quot;()&quot;, &quot;[]&quot;, &quot;{}&quot;, &quot;&lt;&gt;&quot;:</span>
<span class="gi">+            A = pair[0]</span>
<span class="gi">+            B = pair[1]</span>
<span class="gi">+            if self.current_char == A:</span>
<span class="gi">+                return self.find_enclosing_bracket_right(A, B, end_pos=end_pos) or 0</span>
<span class="gi">+            elif self.current_char == B:</span>
<span class="gi">+                return self.find_enclosing_bracket_left(A, B, start_pos=start_pos) or 0</span>
<span class="gi">+</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def get_start_of_document_position(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Relative position for the start of the document.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return -self.cursor_position</span>

<span class="gd">-    def get_end_of_document_position(self) -&gt;int:</span>
<span class="gi">+    def get_end_of_document_position(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Relative position for the end of the document.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.text) - self.cursor_position</span>

<span class="gd">-    def get_start_of_line_position(self, after_whitespace: bool=False) -&gt;int:</span>
<span class="gi">+    def get_start_of_line_position(self, after_whitespace: bool = False) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Relative position for the start of this line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if after_whitespace:</span>
<span class="gi">+            current_line = self.current_line</span>
<span class="gi">+            return (</span>
<span class="gi">+                len(current_line)</span>
<span class="gi">+                - len(current_line.lstrip())</span>
<span class="gi">+                - self.cursor_position_col</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return -len(self.current_line_before_cursor)</span>

<span class="gd">-    def get_end_of_line_position(self) -&gt;int:</span>
<span class="gi">+    def get_end_of_line_position(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Relative position for the end of this line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.current_line_after_cursor)</span>

<span class="gd">-    def last_non_blank_of_current_line_position(self) -&gt;int:</span>
<span class="gi">+    def last_non_blank_of_current_line_position(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Relative position for the last non blank character of this line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.current_line.rstrip()) - self.cursor_position_col - 1</span>

<span class="gd">-    def get_column_cursor_position(self, column: int) -&gt;int:</span>
<span class="gi">+    def get_column_cursor_position(self, column: int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the relative cursor position for this column at the current
<span class="w"> </span>        line. (It will stay between the boundaries of the line in case of a
<span class="w"> </span>        larger number.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        line_length = len(self.current_line)</span>
<span class="gi">+        current_column = self.cursor_position_col</span>
<span class="gi">+        column = max(0, min(line_length, column))</span>

<span class="gd">-    def selection_range(self) -&gt;tuple[int, int]:</span>
<span class="gi">+        return column - current_column</span>
<span class="gi">+</span>
<span class="gi">+    def selection_range(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; tuple[</span>
<span class="gi">+        int, int</span>
<span class="gi">+    ]:  # XXX: shouldn&#39;t this return `None` if there is no selection???</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return (from, to) tuple of the selection.
<span class="w"> </span>        start and end position are included.
<span class="gu">@@ -452,9 +890,16 @@ class Document:</span>
<span class="w"> </span>        This doesn&#39;t take the selection type into account. Use
<span class="w"> </span>        `selection_ranges` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.selection:</span>
<span class="gi">+            from_, to = sorted(</span>
<span class="gi">+                [self.cursor_position, self.selection.original_cursor_position]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            from_, to = self.cursor_position, self.cursor_position</span>

<span class="gd">-    def selection_ranges(self) -&gt;Iterable[tuple[int, int]]:</span>
<span class="gi">+        return from_, to</span>
<span class="gi">+</span>
<span class="gi">+    def selection_ranges(self) -&gt; Iterable[tuple[int, int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of `(from, to)` tuples for the selection or none if
<span class="w"> </span>        nothing was selected. The upper boundary is not included.
<span class="gu">@@ -463,9 +908,48 @@ class Document:</span>
<span class="w"> </span>        This will return zero ranges, like (8,8) for empty lines in a block
<span class="w"> </span>        selection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.selection:</span>
<span class="gi">+            from_, to = sorted(</span>
<span class="gi">+                [self.cursor_position, self.selection.original_cursor_position]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if self.selection.type == SelectionType.BLOCK:</span>
<span class="gi">+                from_line, from_column = self.translate_index_to_position(from_)</span>
<span class="gi">+                to_line, to_column = self.translate_index_to_position(to)</span>
<span class="gi">+                from_column, to_column = sorted([from_column, to_column])</span>
<span class="gi">+                lines = self.lines</span>
<span class="gi">+</span>
<span class="gi">+                if vi_mode():</span>
<span class="gi">+                    to_column += 1</span>

<span class="gd">-    def selection_range_at_line(self, row: int) -&gt;(tuple[int, int] | None):</span>
<span class="gi">+                for l in range(from_line, to_line + 1):</span>
<span class="gi">+                    line_length = len(lines[l])</span>
<span class="gi">+</span>
<span class="gi">+                    if from_column &lt;= line_length:</span>
<span class="gi">+                        yield (</span>
<span class="gi">+                            self.translate_row_col_to_index(l, from_column),</span>
<span class="gi">+                            self.translate_row_col_to_index(</span>
<span class="gi">+                                l, min(line_length, to_column)</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        )</span>
<span class="gi">+            else:</span>
<span class="gi">+                # In case of a LINES selection, go to the start/end of the lines.</span>
<span class="gi">+                if self.selection.type == SelectionType.LINES:</span>
<span class="gi">+                    from_ = max(0, self.text.rfind(&quot;\n&quot;, 0, from_) + 1)</span>
<span class="gi">+</span>
<span class="gi">+                    if self.text.find(&quot;\n&quot;, to) &gt;= 0:</span>
<span class="gi">+                        to = self.text.find(&quot;\n&quot;, to)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        to = len(self.text) - 1</span>
<span class="gi">+</span>
<span class="gi">+                # In Vi mode, the upper boundary is always included. For Emacs,</span>
<span class="gi">+                # that&#39;s not the case.</span>
<span class="gi">+                if vi_mode():</span>
<span class="gi">+                    to += 1</span>
<span class="gi">+</span>
<span class="gi">+                yield from_, to</span>
<span class="gi">+</span>
<span class="gi">+    def selection_range_at_line(self, row: int) -&gt; tuple[int, int] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If the selection spans a portion of the given line, return a (from, to) tuple.

<span class="gu">@@ -474,18 +958,89 @@ class Document:</span>

<span class="w"> </span>        Returns None if the selection doesn&#39;t cover this line at all.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.selection:</span>
<span class="gi">+            line = self.lines[row]</span>
<span class="gi">+</span>
<span class="gi">+            row_start = self.translate_row_col_to_index(row, 0)</span>
<span class="gi">+            row_end = self.translate_row_col_to_index(row, len(line))</span>
<span class="gi">+</span>
<span class="gi">+            from_, to = sorted(</span>
<span class="gi">+                [self.cursor_position, self.selection.original_cursor_position]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Take the intersection of the current line and the selection.</span>
<span class="gi">+            intersection_start = max(row_start, from_)</span>
<span class="gi">+            intersection_end = min(row_end, to)</span>

<span class="gd">-    def cut_selection(self) -&gt;tuple[Document, ClipboardData]:</span>
<span class="gi">+            if intersection_start &lt;= intersection_end:</span>
<span class="gi">+                if self.selection.type == SelectionType.LINES:</span>
<span class="gi">+                    intersection_start = row_start</span>
<span class="gi">+                    intersection_end = row_end</span>
<span class="gi">+</span>
<span class="gi">+                elif self.selection.type == SelectionType.BLOCK:</span>
<span class="gi">+                    _, col1 = self.translate_index_to_position(from_)</span>
<span class="gi">+                    _, col2 = self.translate_index_to_position(to)</span>
<span class="gi">+                    col1, col2 = sorted([col1, col2])</span>
<span class="gi">+</span>
<span class="gi">+                    if col1 &gt; len(line):</span>
<span class="gi">+                        return None  # Block selection doesn&#39;t cross this line.</span>
<span class="gi">+</span>
<span class="gi">+                    intersection_start = self.translate_row_col_to_index(row, col1)</span>
<span class="gi">+                    intersection_end = self.translate_row_col_to_index(row, col2)</span>
<span class="gi">+</span>
<span class="gi">+                _, from_column = self.translate_index_to_position(intersection_start)</span>
<span class="gi">+                _, to_column = self.translate_index_to_position(intersection_end)</span>
<span class="gi">+</span>
<span class="gi">+                # In Vi mode, the upper boundary is always included. For Emacs</span>
<span class="gi">+                # mode, that&#39;s not the case.</span>
<span class="gi">+                if vi_mode():</span>
<span class="gi">+                    to_column += 1</span>
<span class="gi">+</span>
<span class="gi">+                return from_column, to_column</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def cut_selection(self) -&gt; tuple[Document, ClipboardData]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (:class:`.Document`, :class:`.ClipboardData`) tuple, where the
<span class="w"> </span>        document represents the new document when the selection is cut, and the
<span class="w"> </span>        clipboard data, represents whatever has to be put on the clipboard.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.selection:</span>
<span class="gi">+            cut_parts = []</span>
<span class="gi">+            remaining_parts = []</span>
<span class="gi">+            new_cursor_position = self.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+            last_to = 0</span>
<span class="gi">+            for from_, to in self.selection_ranges():</span>
<span class="gi">+                if last_to == 0:</span>
<span class="gi">+                    new_cursor_position = from_</span>
<span class="gi">+</span>
<span class="gi">+                remaining_parts.append(self.text[last_to:from_])</span>
<span class="gi">+                cut_parts.append(self.text[from_:to])</span>
<span class="gi">+                last_to = to</span>

<span class="gd">-    def paste_clipboard_data(self, data: ClipboardData, paste_mode:</span>
<span class="gd">-        PasteMode=PasteMode.EMACS, count: int=1) -&gt;Document:</span>
<span class="gi">+            remaining_parts.append(self.text[last_to:])</span>
<span class="gi">+</span>
<span class="gi">+            cut_text = &quot;\n&quot;.join(cut_parts)</span>
<span class="gi">+            remaining_text = &quot;&quot;.join(remaining_parts)</span>
<span class="gi">+</span>
<span class="gi">+            # In case of a LINES selection, don&#39;t include the trailing newline.</span>
<span class="gi">+            if self.selection.type == SelectionType.LINES and cut_text.endswith(&quot;\n&quot;):</span>
<span class="gi">+                cut_text = cut_text[:-1]</span>
<span class="gi">+</span>
<span class="gi">+            return (</span>
<span class="gi">+                Document(text=remaining_text, cursor_position=new_cursor_position),</span>
<span class="gi">+                ClipboardData(cut_text, self.selection.type),</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self, ClipboardData(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def paste_clipboard_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: ClipboardData,</span>
<span class="gi">+        paste_mode: PasteMode = PasteMode.EMACS,</span>
<span class="gi">+        count: int = 1,</span>
<span class="gi">+    ) -&gt; Document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a new :class:`.Document` instance which contains the result if
<span class="w"> </span>        we would paste this data at the current cursor position.
<span class="gu">@@ -493,36 +1048,134 @@ class Document:</span>
<span class="w"> </span>        :param paste_mode: Where to paste. (Before/after/emacs.)
<span class="w"> </span>        :param count: When &gt;1, Paste multiple times.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def empty_line_count_at_the_end(self) -&gt;int:</span>
<span class="gi">+        before = paste_mode == PasteMode.VI_BEFORE</span>
<span class="gi">+        after = paste_mode == PasteMode.VI_AFTER</span>
<span class="gi">+</span>
<span class="gi">+        if data.type == SelectionType.CHARACTERS:</span>
<span class="gi">+            if after:</span>
<span class="gi">+                new_text = (</span>
<span class="gi">+                    self.text[: self.cursor_position + 1]</span>
<span class="gi">+                    + data.text * count</span>
<span class="gi">+                    + self.text[self.cursor_position + 1 :]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_text = (</span>
<span class="gi">+                    self.text_before_cursor + data.text * count + self.text_after_cursor</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            new_cursor_position = self.cursor_position + len(data.text) * count</span>
<span class="gi">+            if before:</span>
<span class="gi">+                new_cursor_position -= 1</span>
<span class="gi">+</span>
<span class="gi">+        elif data.type == SelectionType.LINES:</span>
<span class="gi">+            l = self.cursor_position_row</span>
<span class="gi">+            if before:</span>
<span class="gi">+                lines = self.lines[:l] + [data.text] * count + self.lines[l:]</span>
<span class="gi">+                new_text = &quot;\n&quot;.join(lines)</span>
<span class="gi">+                new_cursor_position = len(&quot;&quot;.join(self.lines[:l])) + l</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines = self.lines[: l + 1] + [data.text] * count + self.lines[l + 1 :]</span>
<span class="gi">+                new_cursor_position = len(&quot;&quot;.join(self.lines[: l + 1])) + l + 1</span>
<span class="gi">+                new_text = &quot;\n&quot;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+        elif data.type == SelectionType.BLOCK:</span>
<span class="gi">+            lines = self.lines[:]</span>
<span class="gi">+            start_line = self.cursor_position_row</span>
<span class="gi">+            start_column = self.cursor_position_col + (0 if before else 1)</span>
<span class="gi">+</span>
<span class="gi">+            for i, line in enumerate(data.text.split(&quot;\n&quot;)):</span>
<span class="gi">+                index = i + start_line</span>
<span class="gi">+                if index &gt;= len(lines):</span>
<span class="gi">+                    lines.append(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                lines[index] = lines[index].ljust(start_column)</span>
<span class="gi">+                lines[index] = (</span>
<span class="gi">+                    lines[index][:start_column]</span>
<span class="gi">+                    + line * count</span>
<span class="gi">+                    + lines[index][start_column:]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            new_text = &quot;\n&quot;.join(lines)</span>
<span class="gi">+            new_cursor_position = self.cursor_position + (0 if before else 1)</span>
<span class="gi">+</span>
<span class="gi">+        return Document(text=new_text, cursor_position=new_cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+    def empty_line_count_at_the_end(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return number of empty lines at the end of the document.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        for line in self.lines[::-1]:</span>
<span class="gi">+            if not line or line.isspace():</span>
<span class="gi">+                count += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return count</span>

<span class="gd">-    def start_of_paragraph(self, count: int=1, before: bool=False) -&gt;int:</span>
<span class="gi">+    def start_of_paragraph(self, count: int = 1, before: bool = False) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the start of the current paragraph. (Relative cursor position.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def end_of_paragraph(self, count: int=1, after: bool=False) -&gt;int:</span>
<span class="gi">+        def match_func(text: str) -&gt; bool:</span>
<span class="gi">+            return not text or text.isspace()</span>
<span class="gi">+</span>
<span class="gi">+        line_index = self.find_previous_matching_line(</span>
<span class="gi">+            match_func=match_func, count=count</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if line_index:</span>
<span class="gi">+            add = 0 if before else 1</span>
<span class="gi">+            return min(0, self.get_cursor_up_position(count=-line_index) + add)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return -self.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+    def end_of_paragraph(self, count: int = 1, after: bool = False) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the end of the current paragraph. (Relative cursor position.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def insert_after(self, text: str) -&gt;Document:</span>
<span class="gi">+        def match_func(text: str) -&gt; bool:</span>
<span class="gi">+            return not text or text.isspace()</span>
<span class="gi">+</span>
<span class="gi">+        line_index = self.find_next_matching_line(match_func=match_func, count=count)</span>
<span class="gi">+</span>
<span class="gi">+        if line_index:</span>
<span class="gi">+            add = 0 if after else 1</span>
<span class="gi">+            return max(0, self.get_cursor_down_position(count=line_index) - add)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return len(self.text_after_cursor)</span>
<span class="gi">+</span>
<span class="gi">+    # Modifiers.</span>
<span class="gi">+</span>
<span class="gi">+    def insert_after(self, text: str) -&gt; Document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new document, with this text inserted after the buffer.
<span class="w"> </span>        It keeps selection ranges and cursor position in sync.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Document(</span>
<span class="gi">+            text=self.text + text,</span>
<span class="gi">+            cursor_position=self.cursor_position,</span>
<span class="gi">+            selection=self.selection,</span>
<span class="gi">+        )</span>

<span class="gd">-    def insert_before(self, text: str) -&gt;Document:</span>
<span class="gi">+    def insert_before(self, text: str) -&gt; Document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new document, with this text inserted before the buffer.
<span class="w"> </span>        It keeps selection ranges and cursor position in sync.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        selection_state = self.selection</span>
<span class="gi">+</span>
<span class="gi">+        if selection_state:</span>
<span class="gi">+            selection_state = SelectionState(</span>
<span class="gi">+                original_cursor_position=selection_state.original_cursor_position</span>
<span class="gi">+                + len(text),</span>
<span class="gi">+                type=selection_state.type,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return Document(</span>
<span class="gi">+            text=text + self.text,</span>
<span class="gi">+            cursor_position=self.cursor_position + len(text),</span>
<span class="gi">+            selection=selection_state,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/enums.py b/src/prompt_toolkit/enums.py</span>
<span class="gh">index 0a8e11fa..da036337 100644</span>
<span class="gd">--- a/src/prompt_toolkit/enums.py</span>
<span class="gi">+++ b/src/prompt_toolkit/enums.py</span>
<span class="gu">@@ -1,12 +1,19 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from enum import Enum


<span class="w"> </span>class EditingMode(Enum):
<span class="gd">-    VI = &#39;VI&#39;</span>
<span class="gd">-    EMACS = &#39;EMACS&#39;</span>
<span class="gi">+    # The set of key bindings that is active.</span>
<span class="gi">+    VI = &quot;VI&quot;</span>
<span class="gi">+    EMACS = &quot;EMACS&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: Name of the search buffer.</span>
<span class="gi">+SEARCH_BUFFER = &quot;SEARCH_BUFFER&quot;</span>

<span class="gi">+#: Name of the default buffer.</span>
<span class="gi">+DEFAULT_BUFFER = &quot;DEFAULT_BUFFER&quot;</span>

<span class="gd">-SEARCH_BUFFER = &#39;SEARCH_BUFFER&#39;</span>
<span class="gd">-DEFAULT_BUFFER = &#39;DEFAULT_BUFFER&#39;</span>
<span class="gd">-SYSTEM_BUFFER = &#39;SYSTEM_BUFFER&#39;</span>
<span class="gi">+#: Name of the system buffer.</span>
<span class="gi">+SYSTEM_BUFFER = &quot;SYSTEM_BUFFER&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/async_generator.py b/src/prompt_toolkit/eventloop/async_generator.py</span>
<span class="gh">index 9c1d7e5a..5aee50a4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/async_generator.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/async_generator.py</span>
<span class="gu">@@ -2,31 +2,57 @@</span>
<span class="w"> </span>Implementation for async generators.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from contextlib import asynccontextmanager
<span class="w"> </span>from queue import Empty, Full, Queue
<span class="w"> </span>from typing import Any, AsyncGenerator, Callable, Iterable, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from .utils import run_in_executor_with_context
<span class="gd">-__all__ = [&#39;aclosing&#39;, &#39;generator_to_async_generator&#39;]</span>
<span class="gd">-_T_Generator = TypeVar(&#39;_T_Generator&#39;, bound=AsyncGenerator[Any, None])</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;aclosing&quot;,</span>
<span class="gi">+    &quot;generator_to_async_generator&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T_Generator = TypeVar(&quot;_T_Generator&quot;, bound=AsyncGenerator[Any, None])</span>


<span class="w"> </span>@asynccontextmanager
<span class="gd">-async def aclosing(thing: _T_Generator) -&gt;AsyncGenerator[_T_Generator, None]:</span>
<span class="gd">-    &quot;&quot;&quot;Similar to `contextlib.aclosing`, in Python 3.10.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+async def aclosing(</span>
<span class="gi">+    thing: _T_Generator,</span>
<span class="gi">+) -&gt; AsyncGenerator[_T_Generator, None]:</span>
<span class="gi">+    &quot;Similar to `contextlib.aclosing`, in Python 3.10.&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield thing</span>
<span class="gi">+    finally:</span>
<span class="gi">+        await thing.aclose()</span>


<span class="gi">+# By default, choose a buffer size that&#39;s a good balance between having enough</span>
<span class="gi">+# throughput, but not consuming too much memory. We use this to consume a sync</span>
<span class="gi">+# generator of completions as an async generator. If the queue size is very</span>
<span class="gi">+# small (like 1), consuming the completions goes really slow (when there are a</span>
<span class="gi">+# lot of items). If the queue size would be unlimited or too big, this can</span>
<span class="gi">+# cause overconsumption of memory, and cause CPU time spent producing items</span>
<span class="gi">+# that are no longer needed (if the consumption of the async generator stops at</span>
<span class="gi">+# some point). We need a fixed size in order to get some back pressure from the</span>
<span class="gi">+# async consumer to the sync producer. We choose 1000 by default here. If we</span>
<span class="gi">+# have around 50k completions, measurements show that 1000 is still</span>
<span class="gi">+# significantly faster than a buffer of 100.</span>
<span class="w"> </span>DEFAULT_BUFFER_SIZE: int = 1000
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class _Done:
<span class="w"> </span>    pass


<span class="gd">-async def generator_to_async_generator(get_iterable: Callable[[], Iterable[</span>
<span class="gd">-    _T]], buffer_size: int=DEFAULT_BUFFER_SIZE) -&gt;AsyncGenerator[_T, None]:</span>
<span class="gi">+async def generator_to_async_generator(</span>
<span class="gi">+    get_iterable: Callable[[], Iterable[_T]],</span>
<span class="gi">+    buffer_size: int = DEFAULT_BUFFER_SIZE,</span>
<span class="gi">+) -&gt; AsyncGenerator[_T, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn a generator or iterable into an async generator.

<span class="gu">@@ -37,4 +63,62 @@ async def generator_to_async_generator(get_iterable: Callable[[], Iterable[</span>
<span class="w"> </span>    :param buffer_size: Size of the queue between the async consumer and the
<span class="w"> </span>        synchronous generator that produces items.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    quitting = False</span>
<span class="gi">+    # NOTE: We are limiting the queue size in order to have back-pressure.</span>
<span class="gi">+    q: Queue[_T | _Done] = Queue(maxsize=buffer_size)</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+</span>
<span class="gi">+    def runner() -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Consume the generator in background thread.</span>
<span class="gi">+        When items are received, they&#39;ll be pushed to the queue.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            for item in get_iterable():</span>
<span class="gi">+                # When this async generator was cancelled (closed), stop this</span>
<span class="gi">+                # thread.</span>
<span class="gi">+                if quitting:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        q.put(item, timeout=1)</span>
<span class="gi">+                    except Full:</span>
<span class="gi">+                        if quitting:</span>
<span class="gi">+                            return</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+        finally:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    q.put(_Done(), timeout=1)</span>
<span class="gi">+                except Full:</span>
<span class="gi">+                    if quitting:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+    # Start background thread.</span>
<span class="gi">+    runner_f = run_in_executor_with_context(runner)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                item = q.get_nowait()</span>
<span class="gi">+            except Empty:</span>
<span class="gi">+                item = await loop.run_in_executor(None, q.get)</span>
<span class="gi">+            if isinstance(item, _Done):</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield item</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # When this async generator is closed (GeneratorExit exception, stop</span>
<span class="gi">+        # the background thread as well. - we don&#39;t need that anymore.)</span>
<span class="gi">+        quitting = True</span>
<span class="gi">+</span>
<span class="gi">+        # Wait for the background thread to finish. (should happen right after</span>
<span class="gi">+        # the last item is yielded).</span>
<span class="gi">+        await runner_f</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/inputhook.py b/src/prompt_toolkit/eventloop/inputhook.py</span>
<span class="gh">index 33584d8e..a4c0eee6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/inputhook.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/inputhook.py</span>
<span class="gu">@@ -23,6 +23,7 @@ stuff to do. There are two ways to detect when to return:</span>
<span class="w"> </span>  also want prompt-toolkit to gain control again in order to display that.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import os
<span class="w"> </span>import select
<span class="gu">@@ -32,11 +33,19 @@ import threading</span>
<span class="w"> </span>from asyncio import AbstractEventLoop, get_running_loop
<span class="w"> </span>from selectors import BaseSelector, SelectorKey
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Mapping
<span class="gd">-__all__ = [&#39;new_eventloop_with_inputhook&#39;, &#39;set_eventloop_with_inputhook&#39;,</span>
<span class="gd">-    &#39;InputHookSelector&#39;, &#39;InputHookContext&#39;, &#39;InputHook&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;new_eventloop_with_inputhook&quot;,</span>
<span class="gi">+    &quot;set_eventloop_with_inputhook&quot;,</span>
<span class="gi">+    &quot;InputHookSelector&quot;,</span>
<span class="gi">+    &quot;InputHookContext&quot;,</span>
<span class="gi">+    &quot;InputHook&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from _typeshed import FileDescriptorLike
<span class="w"> </span>    from typing_extensions import TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    _EventMask = int


<span class="gu">@@ -45,28 +54,39 @@ class InputHookContext:</span>
<span class="w"> </span>    Given as a parameter to the inputhook.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, fileno: int, input_is_ready: Callable[[], bool]) -&gt;None:</span>
<span class="gi">+    def __init__(self, fileno: int, input_is_ready: Callable[[], bool]) -&gt; None:</span>
<span class="w"> </span>        self._fileno = fileno
<span class="w"> </span>        self.input_is_ready = input_is_ready

<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return self._fileno</span>
<span class="gi">+</span>

<span class="w"> </span>InputHook: TypeAlias = Callable[[InputHookContext], None]


<span class="gd">-def new_eventloop_with_inputhook(inputhook: Callable[[InputHookContext], None]</span>
<span class="gd">-    ) -&gt;AbstractEventLoop:</span>
<span class="gi">+def new_eventloop_with_inputhook(</span>
<span class="gi">+    inputhook: Callable[[InputHookContext], None],</span>
<span class="gi">+) -&gt; AbstractEventLoop:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new event loop with the given inputhook.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    selector = InputHookSelector(selectors.DefaultSelector(), inputhook)</span>
<span class="gi">+    loop = asyncio.SelectorEventLoop(selector)</span>
<span class="gi">+    return loop</span>


<span class="gd">-def set_eventloop_with_inputhook(inputhook: Callable[[InputHookContext], None]</span>
<span class="gd">-    ) -&gt;AbstractEventLoop:</span>
<span class="gi">+def set_eventloop_with_inputhook(</span>
<span class="gi">+    inputhook: Callable[[InputHookContext], None],</span>
<span class="gi">+) -&gt; AbstractEventLoop:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new event loop with the given inputhook, and activate it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Deprecated!</span>
<span class="gi">+</span>
<span class="gi">+    loop = new_eventloop_with_inputhook(inputhook)</span>
<span class="gi">+    asyncio.set_event_loop(loop)</span>
<span class="gi">+    return loop</span>


<span class="w"> </span>class InputHookSelector(BaseSelector):
<span class="gu">@@ -78,14 +98,93 @@ class InputHookSelector(BaseSelector):</span>
<span class="w"> </span>        asyncio.set_event_loop(loop)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, selector: BaseSelector, inputhook: Callable[[</span>
<span class="gd">-        InputHookContext], None]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, selector: BaseSelector, inputhook: Callable[[InputHookContext], None]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.selector = selector
<span class="w"> </span>        self.inputhook = inputhook
<span class="w"> </span>        self._r, self._w = os.pipe()

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def register(</span>
<span class="gi">+        self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None</span>
<span class="gi">+    ) -&gt; SelectorKey:</span>
<span class="gi">+        return self.selector.register(fileobj, events, data=data)</span>
<span class="gi">+</span>
<span class="gi">+    def unregister(self, fileobj: FileDescriptorLike) -&gt; SelectorKey:</span>
<span class="gi">+        return self.selector.unregister(fileobj)</span>
<span class="gi">+</span>
<span class="gi">+    def modify(</span>
<span class="gi">+        self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None</span>
<span class="gi">+    ) -&gt; SelectorKey:</span>
<span class="gi">+        return self.selector.modify(fileobj, events, data=None)</span>
<span class="gi">+</span>
<span class="gi">+    def select(</span>
<span class="gi">+        self, timeout: float | None = None</span>
<span class="gi">+    ) -&gt; list[tuple[SelectorKey, _EventMask]]:</span>
<span class="gi">+        # If there are tasks in the current event loop,</span>
<span class="gi">+        # don&#39;t run the input hook.</span>
<span class="gi">+        if len(getattr(get_running_loop(), &quot;_ready&quot;, [])) &gt; 0:</span>
<span class="gi">+            return self.selector.select(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+        ready = False</span>
<span class="gi">+        result = None</span>
<span class="gi">+</span>
<span class="gi">+        # Run selector in other thread.</span>
<span class="gi">+        def run_selector() -&gt; None:</span>
<span class="gi">+            nonlocal ready, result</span>
<span class="gi">+            result = self.selector.select(timeout=timeout)</span>
<span class="gi">+            os.write(self._w, b&quot;x&quot;)</span>
<span class="gi">+            ready = True</span>
<span class="gi">+</span>
<span class="gi">+        th = threading.Thread(target=run_selector)</span>
<span class="gi">+        th.start()</span>
<span class="gi">+</span>
<span class="gi">+        def input_is_ready() -&gt; bool:</span>
<span class="gi">+            return ready</span>
<span class="gi">+</span>
<span class="gi">+        # Call inputhook.</span>
<span class="gi">+        # The inputhook function is supposed to return when our selector</span>
<span class="gi">+        # becomes ready. The inputhook can do that by registering the fd in its</span>
<span class="gi">+        # own loop, or by checking the `input_is_ready` function regularly.</span>
<span class="gi">+        self.inputhook(InputHookContext(self._r, input_is_ready))</span>
<span class="gi">+</span>
<span class="gi">+        # Flush the read end of the pipe.</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Before calling &#39;os.read&#39;, call select.select. This is required</span>
<span class="gi">+            # when the gevent monkey patch has been applied. &#39;os.read&#39; is never</span>
<span class="gi">+            # monkey patched and won&#39;t be cooperative, so that would block all</span>
<span class="gi">+            # other select() calls otherwise.</span>
<span class="gi">+            # See: http://www.gevent.org/gevent.os.html</span>
<span class="gi">+</span>
<span class="gi">+            # Note: On Windows, this is apparently not an issue.</span>
<span class="gi">+            #       However, if we would ever want to add a select call, it</span>
<span class="gi">+            #       should use `windll.kernel32.WaitForMultipleObjects`,</span>
<span class="gi">+            #       because `select.select` can&#39;t wait for a pipe on Windows.</span>
<span class="gi">+            if sys.platform != &quot;win32&quot;:</span>
<span class="gi">+                select.select([self._r], [], [], None)</span>
<span class="gi">+</span>
<span class="gi">+            os.read(self._r, 1024)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # This happens when the window resizes and a SIGWINCH was received.</span>
<span class="gi">+            # We get &#39;Error: [Errno 4] Interrupted system call&#39;</span>
<span class="gi">+            # Just ignore.</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Wait for the real selector to be done.</span>
<span class="gi">+        th.join()</span>
<span class="gi">+        assert result is not None</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clean up resources.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._r:</span>
<span class="gi">+            os.close(self._r)</span>
<span class="gi">+            os.close(self._w)</span>
<span class="gi">+</span>
<span class="gi">+        self._r = self._w = -1</span>
<span class="gi">+        self.selector.close()</span>
<span class="gi">+</span>
<span class="gi">+    def get_map(self) -&gt; Mapping[FileDescriptorLike, SelectorKey]:</span>
<span class="gi">+        return self.selector.get_map()</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/utils.py b/src/prompt_toolkit/eventloop/utils.py</span>
<span class="gh">index 4b6cc6db..31383613 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/utils.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import contextvars
<span class="w"> </span>import sys
<span class="gu">@@ -6,24 +7,38 @@ import time</span>
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>from typing import Any, Awaitable, Callable, TypeVar, cast
<span class="gd">-__all__ = [&#39;run_in_executor_with_context&#39;, &#39;call_soon_threadsafe&#39;,</span>
<span class="gd">-    &#39;get_traceback_from_context&#39;]</span>
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;run_in_executor_with_context&quot;,</span>
<span class="gi">+    &quot;call_soon_threadsafe&quot;,</span>
<span class="gi">+    &quot;get_traceback_from_context&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="gd">-def run_in_executor_with_context(func: Callable[..., _T], *args: Any, loop:</span>
<span class="gd">-    (asyncio.AbstractEventLoop | None)=None) -&gt;Awaitable[_T]:</span>
<span class="gi">+def run_in_executor_with_context(</span>
<span class="gi">+    func: Callable[..., _T],</span>
<span class="gi">+    *args: Any,</span>
<span class="gi">+    loop: asyncio.AbstractEventLoop | None = None,</span>
<span class="gi">+) -&gt; Awaitable[_T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Run a function in an executor, but make sure it uses the same contextvars.
<span class="w"> </span>    This is required so that the function will see the right application.

<span class="w"> </span>    See also: https://bugs.python.org/issue34014
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = loop or get_running_loop()</span>
<span class="gi">+    ctx: contextvars.Context = contextvars.copy_context()</span>

<span class="gi">+    return loop.run_in_executor(None, ctx.run, func, *args)</span>

<span class="gd">-def call_soon_threadsafe(func: Callable[[], None], max_postpone_time: (</span>
<span class="gd">-    float | None)=None, loop: (asyncio.AbstractEventLoop | None)=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def call_soon_threadsafe(</span>
<span class="gi">+    func: Callable[[], None],</span>
<span class="gi">+    max_postpone_time: float | None = None,</span>
<span class="gi">+    loop: asyncio.AbstractEventLoop | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Wrapper around asyncio&#39;s `call_soon_threadsafe`.

<span class="gu">@@ -40,12 +55,47 @@ def call_soon_threadsafe(func: Callable[[], None], max_postpone_time: (</span>
<span class="w"> </span>    However, we want to set a deadline value, for when the rendering should
<span class="w"> </span>    happen. (The UI should stay responsive).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop2 = loop or get_running_loop()</span>
<span class="gi">+</span>
<span class="gi">+    # If no `max_postpone_time` has been given, schedule right now.</span>
<span class="gi">+    if max_postpone_time is None:</span>
<span class="gi">+        loop2.call_soon_threadsafe(func)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    max_postpone_until = time.time() + max_postpone_time</span>

<span class="gi">+    def schedule() -&gt; None:</span>
<span class="gi">+        # When there are no other tasks scheduled in the event loop. Run it</span>
<span class="gi">+        # now.</span>
<span class="gi">+        # Notice: uvloop doesn&#39;t have this _ready attribute. In that case,</span>
<span class="gi">+        #         always call immediately.</span>
<span class="gi">+        if not getattr(loop2, &quot;_ready&quot;, []):</span>
<span class="gi">+            func()</span>
<span class="gi">+            return</span>

<span class="gd">-def get_traceback_from_context(context: dict[str, Any]) -&gt;(TracebackType | None</span>
<span class="gd">-    ):</span>
<span class="gi">+        # If the timeout expired, run this now.</span>
<span class="gi">+        if time.time() &gt; max_postpone_until:</span>
<span class="gi">+            func()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Schedule again for later.</span>
<span class="gi">+        loop2.call_soon_threadsafe(schedule)</span>
<span class="gi">+</span>
<span class="gi">+    loop2.call_soon_threadsafe(schedule)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_traceback_from_context(context: dict[str, Any]) -&gt; TracebackType | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the traceback object from the context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exception = context.get(&quot;exception&quot;)</span>
<span class="gi">+    if exception:</span>
<span class="gi">+        if hasattr(exception, &quot;__traceback__&quot;):</span>
<span class="gi">+            return cast(TracebackType, exception.__traceback__)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # call_exception_handler() is usually called indirectly</span>
<span class="gi">+            # from an except block. If it&#39;s not the case, the traceback</span>
<span class="gi">+            # is undefined...</span>
<span class="gi">+            return sys.exc_info()[2]</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/win32.py b/src/prompt_toolkit/eventloop/win32.py</span>
<span class="gh">index 55033702..56a0c7da 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/win32.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/win32.py</span>
<span class="gu">@@ -1,19 +1,30 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>from ctypes import pointer
<span class="gi">+</span>
<span class="w"> </span>from ..utils import SPHINX_AUTODOC_RUNNING
<span class="gi">+</span>
<span class="gi">+# Do not import win32-specific stuff when generating documentation.</span>
<span class="gi">+# Otherwise RTD would be unable to generate docs for this module.</span>
<span class="w"> </span>if not SPHINX_AUTODOC_RUNNING:
<span class="w"> </span>    from ctypes import windll
<span class="gi">+</span>
<span class="w"> </span>from ctypes.wintypes import BOOL, DWORD, HANDLE
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.win32_types import SECURITY_ATTRIBUTES
<span class="gd">-__all__ = [&#39;wait_for_handles&#39;, &#39;create_win32_event&#39;]</span>
<span class="gd">-WAIT_TIMEOUT = 258</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;wait_for_handles&quot;, &quot;create_win32_event&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+WAIT_TIMEOUT = 0x00000102</span>
<span class="w"> </span>INFINITE = -1


<span class="gd">-def wait_for_handles(handles: list[HANDLE], timeout: int=INFINITE) -&gt;(HANDLE |</span>
<span class="gd">-    None):</span>
<span class="gi">+def wait_for_handles(handles: list[HANDLE], timeout: int = INFINITE) -&gt; HANDLE | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Waits for multiple handles. (Similar to &#39;select&#39;) Returns the handle which is ready.
<span class="w"> </span>    Returns `None` on timeout.
<span class="gu">@@ -33,12 +44,29 @@ def wait_for_handles(handles: list[HANDLE], timeout: int=INFINITE) -&gt;(HANDLE |</span>
<span class="w"> </span>    This function returns either `None` or one of the given `HANDLE` objects.
<span class="w"> </span>    (The return value can be tested with the `is` operator.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    arrtype = HANDLE * len(handles)</span>
<span class="gi">+    handle_array = arrtype(*handles)</span>
<span class="gi">+</span>
<span class="gi">+    ret: int = windll.kernel32.WaitForMultipleObjects(</span>
<span class="gi">+        len(handle_array), handle_array, BOOL(False), DWORD(timeout)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ret == WAIT_TIMEOUT:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return handles[ret]</span>


<span class="gd">-def create_win32_event() -&gt;HANDLE:</span>
<span class="gi">+def create_win32_event() -&gt; HANDLE:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Creates a Win32 unnamed Event .
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms682396(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return HANDLE(</span>
<span class="gi">+        windll.kernel32.CreateEventA(</span>
<span class="gi">+            pointer(SECURITY_ATTRIBUTES()),</span>
<span class="gi">+            BOOL(True),  # Manual reset event.</span>
<span class="gi">+            BOOL(False),  # Initial state.</span>
<span class="gi">+            None,  # Unnamed event object.</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/src/prompt_toolkit/filters/app.py b/src/prompt_toolkit/filters/app.py</span>
<span class="gh">index 1cf7bf99..aacb2284 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/app.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/app.py</span>
<span class="gu">@@ -2,110 +2,190 @@</span>
<span class="w"> </span>Filters that accept a `Application` as argument.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.cache import memoized
<span class="w"> </span>from prompt_toolkit.enums import EditingMode
<span class="gi">+</span>
<span class="w"> </span>from .base import Condition
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.layout.layout import FocusableElement
<span class="gd">-__all__ = [&#39;has_arg&#39;, &#39;has_completions&#39;, &#39;completion_is_selected&#39;,</span>
<span class="gd">-    &#39;has_focus&#39;, &#39;buffer_has_focus&#39;, &#39;has_selection&#39;, &#39;has_suggestion&#39;,</span>
<span class="gd">-    &#39;has_validation_error&#39;, &#39;is_done&#39;, &#39;is_read_only&#39;, &#39;is_multiline&#39;,</span>
<span class="gd">-    &#39;renderer_height_is_known&#39;, &#39;in_editing_mode&#39;, &#39;in_paste_mode&#39;,</span>
<span class="gd">-    &#39;vi_mode&#39;, &#39;vi_navigation_mode&#39;, &#39;vi_insert_mode&#39;,</span>
<span class="gd">-    &#39;vi_insert_multiple_mode&#39;, &#39;vi_replace_mode&#39;, &#39;vi_selection_mode&#39;,</span>
<span class="gd">-    &#39;vi_waiting_for_text_object_mode&#39;, &#39;vi_digraph_mode&#39;,</span>
<span class="gd">-    &#39;vi_recording_macro&#39;, &#39;emacs_mode&#39;, &#39;emacs_insert_mode&#39;,</span>
<span class="gd">-    &#39;emacs_selection_mode&#39;, &#39;shift_selection_mode&#39;, &#39;is_searching&#39;,</span>
<span class="gd">-    &#39;control_is_searchable&#39;, &#39;vi_search_direction_reversed&#39;]</span>


<span class="gd">-def has_focus(value: FocusableElement) -&gt;Condition:</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;has_arg&quot;,</span>
<span class="gi">+    &quot;has_completions&quot;,</span>
<span class="gi">+    &quot;completion_is_selected&quot;,</span>
<span class="gi">+    &quot;has_focus&quot;,</span>
<span class="gi">+    &quot;buffer_has_focus&quot;,</span>
<span class="gi">+    &quot;has_selection&quot;,</span>
<span class="gi">+    &quot;has_suggestion&quot;,</span>
<span class="gi">+    &quot;has_validation_error&quot;,</span>
<span class="gi">+    &quot;is_done&quot;,</span>
<span class="gi">+    &quot;is_read_only&quot;,</span>
<span class="gi">+    &quot;is_multiline&quot;,</span>
<span class="gi">+    &quot;renderer_height_is_known&quot;,</span>
<span class="gi">+    &quot;in_editing_mode&quot;,</span>
<span class="gi">+    &quot;in_paste_mode&quot;,</span>
<span class="gi">+    &quot;vi_mode&quot;,</span>
<span class="gi">+    &quot;vi_navigation_mode&quot;,</span>
<span class="gi">+    &quot;vi_insert_mode&quot;,</span>
<span class="gi">+    &quot;vi_insert_multiple_mode&quot;,</span>
<span class="gi">+    &quot;vi_replace_mode&quot;,</span>
<span class="gi">+    &quot;vi_selection_mode&quot;,</span>
<span class="gi">+    &quot;vi_waiting_for_text_object_mode&quot;,</span>
<span class="gi">+    &quot;vi_digraph_mode&quot;,</span>
<span class="gi">+    &quot;vi_recording_macro&quot;,</span>
<span class="gi">+    &quot;emacs_mode&quot;,</span>
<span class="gi">+    &quot;emacs_insert_mode&quot;,</span>
<span class="gi">+    &quot;emacs_selection_mode&quot;,</span>
<span class="gi">+    &quot;shift_selection_mode&quot;,</span>
<span class="gi">+    &quot;is_searching&quot;,</span>
<span class="gi">+    &quot;control_is_searchable&quot;,</span>
<span class="gi">+    &quot;vi_search_direction_reversed&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# NOTE: `has_focus` below should *not* be `memoized`. It can reference any user</span>
<span class="gi">+#       control. For instance, if we would continuously create new</span>
<span class="gi">+#       `PromptSession` instances, then previous instances won&#39;t be released,</span>
<span class="gi">+#       because this memoize (which caches results in the global scope) will</span>
<span class="gi">+#       still refer to each instance.</span>
<span class="gi">+def has_focus(value: FocusableElement) -&gt; Condition:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when this buffer has the focus.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.buffer import Buffer</span>
<span class="gi">+    from prompt_toolkit.layout import walk</span>
<span class="gi">+    from prompt_toolkit.layout.containers import Container, Window, to_container</span>
<span class="gi">+    from prompt_toolkit.layout.controls import UIControl</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+</span>
<span class="gi">+        def test() -&gt; bool:</span>
<span class="gi">+            return get_app().current_buffer.name == value</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(value, Buffer):</span>
<span class="gi">+</span>
<span class="gi">+        def test() -&gt; bool:</span>
<span class="gi">+            return get_app().current_buffer == value</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(value, UIControl):</span>
<span class="gi">+</span>
<span class="gi">+        def test() -&gt; bool:</span>
<span class="gi">+            return get_app().layout.current_control == value</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        value = to_container(value)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, Window):</span>
<span class="gi">+</span>
<span class="gi">+            def test() -&gt; bool:</span>
<span class="gi">+                return get_app().layout.current_window == value</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def test() -&gt; bool:</span>
<span class="gi">+                # Consider focused when any window inside this container is</span>
<span class="gi">+                # focused.</span>
<span class="gi">+                current_window = get_app().layout.current_window</span>
<span class="gi">+</span>
<span class="gi">+                for c in walk(cast(Container, value)):</span>
<span class="gi">+                    if isinstance(c, Window) and c == current_window:</span>
<span class="gi">+                        return True</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def has_focus_filter() -&gt; bool:</span>
<span class="gi">+        return test()</span>
<span class="gi">+</span>
<span class="gi">+    return has_focus_filter</span>


<span class="w"> </span>@Condition
<span class="gd">-def buffer_has_focus() -&gt;bool:</span>
<span class="gi">+def buffer_has_focus() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enabled when the currently focused control is a `BufferControl`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().layout.buffer_has_focus</span>


<span class="w"> </span>@Condition
<span class="gd">-def has_selection() -&gt;bool:</span>
<span class="gi">+def has_selection() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when the current buffer has a selection.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(get_app().current_buffer.selection_state)</span>


<span class="w"> </span>@Condition
<span class="gd">-def has_suggestion() -&gt;bool:</span>
<span class="gi">+def has_suggestion() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when the current buffer has a suggestion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buffer = get_app().current_buffer</span>
<span class="gi">+    return buffer.suggestion is not None and buffer.suggestion.text != &quot;&quot;</span>


<span class="w"> </span>@Condition
<span class="gd">-def has_completions() -&gt;bool:</span>
<span class="gi">+def has_completions() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when the current buffer has completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    state = get_app().current_buffer.complete_state</span>
<span class="gi">+    return state is not None and len(state.completions) &gt; 0</span>


<span class="w"> </span>@Condition
<span class="gd">-def completion_is_selected() -&gt;bool:</span>
<span class="gi">+def completion_is_selected() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the user selected a completion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+    return complete_state is not None and complete_state.current_completion is not None</span>


<span class="w"> </span>@Condition
<span class="gd">-def is_read_only() -&gt;bool:</span>
<span class="gi">+def is_read_only() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the current buffer is read only.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.read_only()</span>


<span class="w"> </span>@Condition
<span class="gd">-def is_multiline() -&gt;bool:</span>
<span class="gi">+def is_multiline() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the current buffer has been marked as multiline.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.multiline()</span>


<span class="w"> </span>@Condition
<span class="gd">-def has_validation_error() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Current buffer has validation error.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def has_validation_error() -&gt; bool:</span>
<span class="gi">+    &quot;Current buffer has validation error.&quot;</span>
<span class="gi">+    return get_app().current_buffer.validation_error is not None</span>


<span class="w"> </span>@Condition
<span class="gd">-def has_arg() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Enable when the input processor has an &#39;arg&#39;.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def has_arg() -&gt; bool:</span>
<span class="gi">+    &quot;Enable when the input processor has an &#39;arg&#39;.&quot;</span>
<span class="gi">+    return get_app().key_processor.arg is not None</span>


<span class="w"> </span>@Condition
<span class="gd">-def is_done() -&gt;bool:</span>
<span class="gi">+def is_done() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the CLI is returning, aborting or exiting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().is_done</span>


<span class="w"> </span>@Condition
<span class="gd">-def renderer_height_is_known() -&gt;bool:</span>
<span class="gi">+def renderer_height_is_known() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Only True when the renderer knows it&#39;s real height.

<span class="gu">@@ -115,50 +195,224 @@ def renderer_height_is_known() -&gt;bool:</span>
<span class="w"> </span>    until we receive the height, in order to avoid flickering -- first drawing
<span class="w"> </span>    somewhere in the middle, and then again at the bottom.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().renderer.height_is_known</span>


<span class="w"> </span>@memoized()
<span class="gd">-def in_editing_mode(editing_mode: EditingMode) -&gt;Condition:</span>
<span class="gi">+def in_editing_mode(editing_mode: EditingMode) -&gt; Condition:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether a given editing mode is active. (Vi or Emacs.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def in_editing_mode_filter() -&gt; bool:</span>
<span class="gi">+        return get_app().editing_mode == editing_mode</span>
<span class="gi">+</span>
<span class="gi">+    return in_editing_mode_filter</span>


<span class="w"> </span>@Condition
<span class="gd">-def vi_navigation_mode() -&gt;bool:</span>
<span class="gi">+def in_paste_mode() -&gt; bool:</span>
<span class="gi">+    return get_app().paste_mode()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def vi_mode() -&gt; bool:</span>
<span class="gi">+    return get_app().editing_mode == EditingMode.VI</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def vi_navigation_mode() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Active when the set for Vi navigation key bindings are active.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.key_binding.vi_state import InputMode</span>
<span class="gi">+</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.editing_mode != EditingMode.VI</span>
<span class="gi">+        or app.vi_state.operator_func</span>
<span class="gi">+        or app.vi_state.waiting_for_digraph</span>
<span class="gi">+        or app.current_buffer.selection_state</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        app.vi_state.input_mode == InputMode.NAVIGATION</span>
<span class="gi">+        or app.vi_state.temporary_navigation_mode</span>
<span class="gi">+        or app.current_buffer.read_only()</span>
<span class="gi">+    )</span>


<span class="w"> </span>@Condition
<span class="gd">-def vi_recording_macro() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;When recording a Vi macro.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def vi_insert_mode() -&gt; bool:</span>
<span class="gi">+    from prompt_toolkit.key_binding.vi_state import InputMode</span>
<span class="gi">+</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.editing_mode != EditingMode.VI</span>
<span class="gi">+        or app.vi_state.operator_func</span>
<span class="gi">+        or app.vi_state.waiting_for_digraph</span>
<span class="gi">+        or app.current_buffer.selection_state</span>
<span class="gi">+        or app.vi_state.temporary_navigation_mode</span>
<span class="gi">+        or app.current_buffer.read_only()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.input_mode == InputMode.INSERT</span>


<span class="w"> </span>@Condition
<span class="gd">-def emacs_mode() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;When the Emacs bindings are active.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def vi_insert_multiple_mode() -&gt; bool:</span>
<span class="gi">+    from prompt_toolkit.key_binding.vi_state import InputMode</span>
<span class="gi">+</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.editing_mode != EditingMode.VI</span>
<span class="gi">+        or app.vi_state.operator_func</span>
<span class="gi">+        or app.vi_state.waiting_for_digraph</span>
<span class="gi">+        or app.current_buffer.selection_state</span>
<span class="gi">+        or app.vi_state.temporary_navigation_mode</span>
<span class="gi">+        or app.current_buffer.read_only()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.input_mode == InputMode.INSERT_MULTIPLE</span>


<span class="w"> </span>@Condition
<span class="gd">-def is_searching() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;When we are searching.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def vi_replace_mode() -&gt; bool:</span>
<span class="gi">+    from prompt_toolkit.key_binding.vi_state import InputMode</span>
<span class="gi">+</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.editing_mode != EditingMode.VI</span>
<span class="gi">+        or app.vi_state.operator_func</span>
<span class="gi">+        or app.vi_state.waiting_for_digraph</span>
<span class="gi">+        or app.current_buffer.selection_state</span>
<span class="gi">+        or app.vi_state.temporary_navigation_mode</span>
<span class="gi">+        or app.current_buffer.read_only()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.input_mode == InputMode.REPLACE</span>


<span class="w"> </span>@Condition
<span class="gd">-def control_is_searchable() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;When the current UIControl is searchable.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def vi_replace_single_mode() -&gt; bool:</span>
<span class="gi">+    from prompt_toolkit.key_binding.vi_state import InputMode</span>
<span class="gi">+</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.editing_mode != EditingMode.VI</span>
<span class="gi">+        or app.vi_state.operator_func</span>
<span class="gi">+        or app.vi_state.waiting_for_digraph</span>
<span class="gi">+        or app.current_buffer.selection_state</span>
<span class="gi">+        or app.vi_state.temporary_navigation_mode</span>
<span class="gi">+        or app.current_buffer.read_only()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.input_mode == InputMode.REPLACE_SINGLE</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def vi_selection_mode() -&gt; bool:</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    if app.editing_mode != EditingMode.VI:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return bool(app.current_buffer.selection_state)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def vi_waiting_for_text_object_mode() -&gt; bool:</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    if app.editing_mode != EditingMode.VI:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.operator_func is not None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def vi_digraph_mode() -&gt; bool:</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    if app.editing_mode != EditingMode.VI:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.waiting_for_digraph</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def vi_recording_macro() -&gt; bool:</span>
<span class="gi">+    &quot;When recording a Vi macro.&quot;</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    if app.editing_mode != EditingMode.VI:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return app.vi_state.recording_register is not None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def emacs_mode() -&gt; bool:</span>
<span class="gi">+    &quot;When the Emacs bindings are active.&quot;</span>
<span class="gi">+    return get_app().editing_mode == EditingMode.EMACS</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def emacs_insert_mode() -&gt; bool:</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.editing_mode != EditingMode.EMACS</span>
<span class="gi">+        or app.current_buffer.selection_state</span>
<span class="gi">+        or app.current_buffer.read_only()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def emacs_selection_mode() -&gt; bool:</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    return bool(</span>
<span class="gi">+        app.editing_mode == EditingMode.EMACS and app.current_buffer.selection_state</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def shift_selection_mode() -&gt; bool:</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    return bool(</span>
<span class="gi">+        app.current_buffer.selection_state</span>
<span class="gi">+        and app.current_buffer.selection_state.shift_mode</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def is_searching() -&gt; bool:</span>
<span class="gi">+    &quot;When we are searching.&quot;</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    return app.layout.is_searching</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@Condition</span>
<span class="gi">+def control_is_searchable() -&gt; bool:</span>
<span class="gi">+    &quot;When the current UIControl is searchable.&quot;</span>
<span class="gi">+    from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+</span>
<span class="gi">+    control = get_app().layout.current_control</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(control, BufferControl) and control.search_buffer_control is not None</span>
<span class="gi">+    )</span>


<span class="w"> </span>@Condition
<span class="gd">-def vi_search_direction_reversed() -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;When the &#39;/&#39; and &#39;?&#39; key bindings for Vi-style searching have been reversed.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def vi_search_direction_reversed() -&gt; bool:</span>
<span class="gi">+    &quot;When the &#39;/&#39; and &#39;?&#39; key bindings for Vi-style searching have been reversed.&quot;</span>
<span class="gi">+    return get_app().reverse_vi_search_direction()</span>
<span class="gh">diff --git a/src/prompt_toolkit/filters/base.py b/src/prompt_toolkit/filters/base.py</span>
<span class="gh">index 66696022..afce6dc5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/base.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import Callable, Iterable, Union
<span class="gd">-__all__ = [&#39;Filter&#39;, &#39;Never&#39;, &#39;Always&#39;, &#39;Condition&#39;, &#39;FilterOrBool&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;Filter&quot;, &quot;Never&quot;, &quot;Always&quot;, &quot;Condition&quot;, &quot;FilterOrBool&quot;]</span>


<span class="w"> </span>class Filter(metaclass=ABCMeta):
<span class="gu">@@ -12,57 +14,64 @@ class Filter(metaclass=ABCMeta):</span>
<span class="w"> </span>    The return value of ``__call__`` will tell if the feature should be active.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._and_cache: dict[Filter, Filter] = {}
<span class="w"> </span>        self._or_cache: dict[Filter, Filter] = {}
<span class="w"> </span>        self._invert_result: Filter | None = None

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The actual call to evaluate the filter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return True

<span class="gd">-    def __and__(self, other: Filter) -&gt;Filter:</span>
<span class="gi">+    def __and__(self, other: Filter) -&gt; Filter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Chaining of filters using the &amp; operator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        assert isinstance(other, Filter), &#39;Expecting filter, got %r&#39; % other</span>
<span class="gi">+        assert isinstance(other, Filter), &quot;Expecting filter, got %r&quot; % other</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(other, Always):
<span class="w"> </span>            return self
<span class="w"> </span>        if isinstance(other, Never):
<span class="w"> </span>            return other
<span class="gi">+</span>
<span class="w"> </span>        if other in self._and_cache:
<span class="w"> </span>            return self._and_cache[other]
<span class="gi">+</span>
<span class="w"> </span>        result = _AndList.create([self, other])
<span class="w"> </span>        self._and_cache[other] = result
<span class="w"> </span>        return result

<span class="gd">-    def __or__(self, other: Filter) -&gt;Filter:</span>
<span class="gi">+    def __or__(self, other: Filter) -&gt; Filter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Chaining of filters using the | operator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        assert isinstance(other, Filter), &#39;Expecting filter, got %r&#39; % other</span>
<span class="gi">+        assert isinstance(other, Filter), &quot;Expecting filter, got %r&quot; % other</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(other, Always):
<span class="w"> </span>            return other
<span class="w"> </span>        if isinstance(other, Never):
<span class="w"> </span>            return self
<span class="gi">+</span>
<span class="w"> </span>        if other in self._or_cache:
<span class="w"> </span>            return self._or_cache[other]
<span class="gi">+</span>
<span class="w"> </span>        result = _OrList.create([self, other])
<span class="w"> </span>        self._or_cache[other] = result
<span class="w"> </span>        return result

<span class="gd">-    def __invert__(self) -&gt;Filter:</span>
<span class="gi">+    def __invert__(self) -&gt; Filter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Inverting of filters using the ~ operator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if self._invert_result is None:
<span class="w"> </span>            self._invert_result = _Invert(self)
<span class="gi">+</span>
<span class="w"> </span>        return self._invert_result

<span class="gd">-    def __bool__(self) -&gt;None:</span>
<span class="gi">+    def __bool__(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        By purpose, we don&#39;t allow bool(...) operations directly on a filter,
<span class="w"> </span>        because the meaning is ambiguous.
<span class="gu">@@ -72,8 +81,17 @@ class Filter(metaclass=ABCMeta):</span>
<span class="w"> </span>        instead of for instance ``filter1 or Always()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        raise ValueError(
<span class="gd">-            &#39;The truth value of a Filter is ambiguous. Instead, call it as a function.&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            &quot;The truth value of a Filter is ambiguous. &quot;</span>
<span class="gi">+            &quot;Instead, call it as a function.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_duplicates(filters: list[Filter]) -&gt; list[Filter]:</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for f in filters:</span>
<span class="gi">+        if f not in result:</span>
<span class="gi">+            result.append(f)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class _AndList(Filter):
<span class="gu">@@ -81,25 +99,42 @@ class _AndList(Filter):</span>
<span class="w"> </span>    Result of &amp;-operation between several filters.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filters: list[Filter]) -&gt;None:</span>
<span class="gi">+    def __init__(self, filters: list[Filter]) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.filters = filters

<span class="w"> </span>    @classmethod
<span class="gd">-    def create(cls, filters: Iterable[Filter]) -&gt;Filter:</span>
<span class="gi">+    def create(cls, filters: Iterable[Filter]) -&gt; Filter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new filter by applying an `&amp;` operator between them.

<span class="w"> </span>        If there&#39;s only one unique filter in the given iterable, it will return
<span class="w"> </span>        that one filter instead of an `_AndList`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        filters_2: list[Filter] = []</span>
<span class="gi">+</span>
<span class="gi">+        for f in filters:</span>
<span class="gi">+            if isinstance(f, _AndList):  # Turn nested _AndLists into one.</span>
<span class="gi">+                filters_2.extend(f.filters)</span>
<span class="gi">+            else:</span>
<span class="gi">+                filters_2.append(f)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove duplicates. This could speed up execution, and doesn&#39;t make a</span>
<span class="gi">+        # difference for the evaluation.</span>
<span class="gi">+        filters = _remove_duplicates(filters_2)</span>
<span class="gi">+</span>
<span class="gi">+        # If only one filter is left, return that without wrapping into an</span>
<span class="gi">+        # `_AndList`.</span>
<span class="gi">+        if len(filters) == 1:</span>
<span class="gi">+            return filters[0]</span>
<span class="gi">+</span>
<span class="gi">+        return cls(filters)</span>

<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        return all(f() for f in self.filters)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;&amp;&#39;.join(repr(f) for f in self.filters)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;&amp;&quot;.join(repr(f) for f in self.filters)</span>


<span class="w"> </span>class _OrList(Filter):
<span class="gu">@@ -107,25 +142,42 @@ class _OrList(Filter):</span>
<span class="w"> </span>    Result of |-operation between several filters.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filters: list[Filter]) -&gt;None:</span>
<span class="gi">+    def __init__(self, filters: list[Filter]) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.filters = filters

<span class="w"> </span>    @classmethod
<span class="gd">-    def create(cls, filters: Iterable[Filter]) -&gt;Filter:</span>
<span class="gi">+    def create(cls, filters: Iterable[Filter]) -&gt; Filter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new filter by applying an `|` operator between them.

<span class="w"> </span>        If there&#39;s only one unique filter in the given iterable, it will return
<span class="w"> </span>        that one filter instead of an `_OrList`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        filters_2: list[Filter] = []</span>
<span class="gi">+</span>
<span class="gi">+        for f in filters:</span>
<span class="gi">+            if isinstance(f, _OrList):  # Turn nested _AndLists into one.</span>
<span class="gi">+                filters_2.extend(f.filters)</span>
<span class="gi">+            else:</span>
<span class="gi">+                filters_2.append(f)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove duplicates. This could speed up execution, and doesn&#39;t make a</span>
<span class="gi">+        # difference for the evaluation.</span>
<span class="gi">+        filters = _remove_duplicates(filters_2)</span>
<span class="gi">+</span>
<span class="gi">+        # If only one filter is left, return that without wrapping into an</span>
<span class="gi">+        # `_AndList`.</span>
<span class="gi">+        if len(filters) == 1:</span>
<span class="gi">+            return filters[0]</span>
<span class="gi">+</span>
<span class="gi">+        return cls(filters)</span>

<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        return any(f() for f in self.filters)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;|&#39;.join(repr(f) for f in self.filters)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;|&quot;.join(repr(f) for f in self.filters)</span>


<span class="w"> </span>class _Invert(Filter):
<span class="gu">@@ -133,15 +185,15 @@ class _Invert(Filter):</span>
<span class="w"> </span>    Negation of another filter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filter: Filter) -&gt;None:</span>
<span class="gi">+    def __init__(self, filter: Filter) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.filter = filter

<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        return not self.filter()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;~%r&#39; % self.filter</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;~%r&quot; % self.filter</span>


<span class="w"> </span>class Always(Filter):
<span class="gu">@@ -149,13 +201,13 @@ class Always(Filter):</span>
<span class="w"> </span>    Always enable feature.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        return True

<span class="gd">-    def __or__(self, other: Filter) -&gt;Filter:</span>
<span class="gi">+    def __or__(self, other: Filter) -&gt; Filter:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __invert__(self) -&gt;Never:</span>
<span class="gi">+    def __invert__(self) -&gt; Never:</span>
<span class="w"> </span>        return Never()


<span class="gu">@@ -164,13 +216,13 @@ class Never(Filter):</span>
<span class="w"> </span>    Never enable feature.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __and__(self, other: Filter) -&gt;Filter:</span>
<span class="gi">+    def __and__(self, other: Filter) -&gt; Filter:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __invert__(self) -&gt;Always:</span>
<span class="gi">+    def __invert__(self) -&gt; Always:</span>
<span class="w"> </span>        return Always()


<span class="gu">@@ -188,15 +240,16 @@ class Condition(Filter):</span>
<span class="w"> </span>    :param func: Callable which takes no inputs and returns a boolean.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, func: Callable[[], bool]) -&gt;None:</span>
<span class="gi">+    def __init__(self, func: Callable[[], bool]) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.func = func

<span class="gd">-    def __call__(self) -&gt;bool:</span>
<span class="gi">+    def __call__(self) -&gt; bool:</span>
<span class="w"> </span>        return self.func()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Condition(%r)&#39; % self.func</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Condition(%r)&quot; % self.func</span>


<span class="gi">+# Often used as type annotation.</span>
<span class="w"> </span>FilterOrBool = Union[Filter, bool]
<span class="gh">diff --git a/src/prompt_toolkit/filters/cli.py b/src/prompt_toolkit/filters/cli.py</span>
<span class="gh">index bc535e54..c95080a9 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/cli.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/cli.py</span>
<span class="gu">@@ -3,36 +3,62 @@ For backwards-compatibility. keep this file.</span>
<span class="w"> </span>(Many people are going to have key bindings that rely on this file.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from .app import *
<span class="gd">-__all__ = [&#39;HasArg&#39;, &#39;HasCompletions&#39;, &#39;HasFocus&#39;, &#39;HasSelection&#39;,</span>
<span class="gd">-    &#39;HasValidationError&#39;, &#39;IsDone&#39;, &#39;IsReadOnly&#39;, &#39;IsMultiline&#39;,</span>
<span class="gd">-    &#39;RendererHeightIsKnown&#39;, &#39;InEditingMode&#39;, &#39;InPasteMode&#39;, &#39;ViMode&#39;,</span>
<span class="gd">-    &#39;ViNavigationMode&#39;, &#39;ViInsertMode&#39;, &#39;ViInsertMultipleMode&#39;,</span>
<span class="gd">-    &#39;ViReplaceMode&#39;, &#39;ViSelectionMode&#39;, &#39;ViWaitingForTextObjectMode&#39;,</span>
<span class="gd">-    &#39;ViDigraphMode&#39;, &#39;EmacsMode&#39;, &#39;EmacsInsertMode&#39;, &#39;EmacsSelectionMode&#39;,</span>
<span class="gd">-    &#39;IsSearching&#39;, &#39;HasSearch&#39;, &#39;ControlIsSearchable&#39;]</span>
<span class="gd">-HasValidationError = lambda : has_validation_error</span>
<span class="gd">-HasArg = lambda : has_arg</span>
<span class="gd">-IsDone = lambda : is_done</span>
<span class="gd">-RendererHeightIsKnown = lambda : renderer_height_is_known</span>
<span class="gd">-ViNavigationMode = lambda : vi_navigation_mode</span>
<span class="gd">-InPasteMode = lambda : in_paste_mode</span>
<span class="gd">-EmacsMode = lambda : emacs_mode</span>
<span class="gd">-EmacsInsertMode = lambda : emacs_insert_mode</span>
<span class="gd">-ViMode = lambda : vi_mode</span>
<span class="gd">-IsSearching = lambda : is_searching</span>
<span class="gd">-HasSearch = lambda : is_searching</span>
<span class="gd">-ControlIsSearchable = lambda : control_is_searchable</span>
<span class="gd">-EmacsSelectionMode = lambda : emacs_selection_mode</span>
<span class="gd">-ViDigraphMode = lambda : vi_digraph_mode</span>
<span class="gd">-ViWaitingForTextObjectMode = lambda : vi_waiting_for_text_object_mode</span>
<span class="gd">-ViSelectionMode = lambda : vi_selection_mode</span>
<span class="gd">-ViReplaceMode = lambda : vi_replace_mode</span>
<span class="gd">-ViInsertMultipleMode = lambda : vi_insert_multiple_mode</span>
<span class="gd">-ViInsertMode = lambda : vi_insert_mode</span>
<span class="gd">-HasSelection = lambda : has_selection</span>
<span class="gd">-HasCompletions = lambda : has_completions</span>
<span class="gd">-IsReadOnly = lambda : is_read_only</span>
<span class="gd">-IsMultiline = lambda : is_multiline</span>
<span class="gd">-HasFocus = has_focus</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    # Old names.</span>
<span class="gi">+    &quot;HasArg&quot;,</span>
<span class="gi">+    &quot;HasCompletions&quot;,</span>
<span class="gi">+    &quot;HasFocus&quot;,</span>
<span class="gi">+    &quot;HasSelection&quot;,</span>
<span class="gi">+    &quot;HasValidationError&quot;,</span>
<span class="gi">+    &quot;IsDone&quot;,</span>
<span class="gi">+    &quot;IsReadOnly&quot;,</span>
<span class="gi">+    &quot;IsMultiline&quot;,</span>
<span class="gi">+    &quot;RendererHeightIsKnown&quot;,</span>
<span class="gi">+    &quot;InEditingMode&quot;,</span>
<span class="gi">+    &quot;InPasteMode&quot;,</span>
<span class="gi">+    &quot;ViMode&quot;,</span>
<span class="gi">+    &quot;ViNavigationMode&quot;,</span>
<span class="gi">+    &quot;ViInsertMode&quot;,</span>
<span class="gi">+    &quot;ViInsertMultipleMode&quot;,</span>
<span class="gi">+    &quot;ViReplaceMode&quot;,</span>
<span class="gi">+    &quot;ViSelectionMode&quot;,</span>
<span class="gi">+    &quot;ViWaitingForTextObjectMode&quot;,</span>
<span class="gi">+    &quot;ViDigraphMode&quot;,</span>
<span class="gi">+    &quot;EmacsMode&quot;,</span>
<span class="gi">+    &quot;EmacsInsertMode&quot;,</span>
<span class="gi">+    &quot;EmacsSelectionMode&quot;,</span>
<span class="gi">+    &quot;IsSearching&quot;,</span>
<span class="gi">+    &quot;HasSearch&quot;,</span>
<span class="gi">+    &quot;ControlIsSearchable&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Keep the original classnames for backwards compatibility.</span>
<span class="gi">+HasValidationError = lambda: has_validation_error</span>
<span class="gi">+HasArg = lambda: has_arg</span>
<span class="gi">+IsDone = lambda: is_done</span>
<span class="gi">+RendererHeightIsKnown = lambda: renderer_height_is_known</span>
<span class="gi">+ViNavigationMode = lambda: vi_navigation_mode</span>
<span class="gi">+InPasteMode = lambda: in_paste_mode</span>
<span class="gi">+EmacsMode = lambda: emacs_mode</span>
<span class="gi">+EmacsInsertMode = lambda: emacs_insert_mode</span>
<span class="gi">+ViMode = lambda: vi_mode</span>
<span class="gi">+IsSearching = lambda: is_searching</span>
<span class="gi">+HasSearch = lambda: is_searching</span>
<span class="gi">+ControlIsSearchable = lambda: control_is_searchable</span>
<span class="gi">+EmacsSelectionMode = lambda: emacs_selection_mode</span>
<span class="gi">+ViDigraphMode = lambda: vi_digraph_mode</span>
<span class="gi">+ViWaitingForTextObjectMode = lambda: vi_waiting_for_text_object_mode</span>
<span class="gi">+ViSelectionMode = lambda: vi_selection_mode</span>
<span class="gi">+ViReplaceMode = lambda: vi_replace_mode</span>
<span class="gi">+ViInsertMultipleMode = lambda: vi_insert_multiple_mode</span>
<span class="gi">+ViInsertMode = lambda: vi_insert_mode</span>
<span class="gi">+HasSelection = lambda: has_selection</span>
<span class="gi">+HasCompletions = lambda: has_completions</span>
<span class="gi">+IsReadOnly = lambda: is_read_only</span>
<span class="gi">+IsMultiline = lambda: is_multiline</span>
<span class="gi">+</span>
<span class="gi">+HasFocus = has_focus  # No lambda here! (Has_focus is callable that returns a callable.)</span>
<span class="w"> </span>InEditingMode = in_editing_mode
<span class="gh">diff --git a/src/prompt_toolkit/filters/utils.py b/src/prompt_toolkit/filters/utils.py</span>
<span class="gh">index 4234ca63..bac85bab 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/utils.py</span>
<span class="gu">@@ -1,23 +1,41 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from .base import Always, Filter, FilterOrBool, Never
<span class="gd">-__all__ = [&#39;to_filter&#39;, &#39;is_true&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;to_filter&quot;,</span>
<span class="gi">+    &quot;is_true&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_always = Always()
<span class="w"> </span>_never = Never()
<span class="gd">-_bool_to_filter: dict[bool, Filter] = {(True): _always, (False): _never}</span>


<span class="gd">-def to_filter(bool_or_filter: FilterOrBool) -&gt;Filter:</span>
<span class="gi">+_bool_to_filter: dict[bool, Filter] = {</span>
<span class="gi">+    True: _always,</span>
<span class="gi">+    False: _never,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_filter(bool_or_filter: FilterOrBool) -&gt; Filter:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept both booleans and Filters as input and
<span class="w"> </span>    turn it into a Filter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(bool_or_filter, bool):</span>
<span class="gi">+        return _bool_to_filter[bool_or_filter]</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(bool_or_filter, Filter):</span>
<span class="gi">+        return bool_or_filter</span>
<span class="gi">+</span>
<span class="gi">+    raise TypeError(&quot;Expecting a bool or a Filter instance. Got %r&quot; % bool_or_filter)</span>


<span class="gd">-def is_true(value: FilterOrBool) -&gt;bool:</span>
<span class="gi">+def is_true(value: FilterOrBool) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Test whether `value` is True. In case of a Filter, call it.

<span class="w"> </span>    :param value: Boolean or `Filter` instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return to_filter(value)()</span>
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/ansi.py b/src/prompt_toolkit/formatted_text/ansi.py</span>
<span class="gh">index 35ad0c63..08ec0b32 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/ansi.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/ansi.py</span>
<span class="gu">@@ -1,10 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from string import Formatter
<span class="w"> </span>from typing import Generator
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.output.vt100 import BG_ANSI_COLORS, FG_ANSI_COLORS
<span class="w"> </span>from prompt_toolkit.output.vt100 import _256_colors as _256_colors_table
<span class="gi">+</span>
<span class="w"> </span>from .base import StyleAndTextTuples
<span class="gd">-__all__ = [&#39;ANSI&#39;, &#39;ansi_escape&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ANSI&quot;,</span>
<span class="gi">+    &quot;ansi_escape&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ANSI:
<span class="gu">@@ -22,9 +29,11 @@ class ANSI:</span>
<span class="w"> </span>    be translated into a prompt_toolkit &#39;[ZeroWidthEscape]&#39; fragment.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, value: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: str) -&gt; None:</span>
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self._formatted_text: StyleAndTextTuples = []
<span class="gi">+</span>
<span class="gi">+        # Default style attributes.</span>
<span class="w"> </span>        self._color: str | None = None
<span class="w"> </span>        self._bgcolor: str | None = None
<span class="w"> </span>        self._bold = False
<span class="gu">@@ -34,68 +43,257 @@ class ANSI:</span>
<span class="w"> </span>        self._blink = False
<span class="w"> </span>        self._reverse = False
<span class="w"> </span>        self._hidden = False
<span class="gi">+</span>
<span class="gi">+        # Process received text.</span>
<span class="w"> </span>        parser = self._parse_corot()
<span class="gd">-        parser.send(None)</span>
<span class="gi">+        parser.send(None)  # type: ignore</span>
<span class="w"> </span>        for c in value:
<span class="w"> </span>            parser.send(c)

<span class="gd">-    def _parse_corot(self) -&gt;Generator[None, str, None]:</span>
<span class="gi">+    def _parse_corot(self) -&gt; Generator[None, str, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine that parses the ANSI escape sequences.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        style = &quot;&quot;</span>
<span class="gi">+        formatted_text = self._formatted_text</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # NOTE: CSI is a special token within a stream of characters that</span>
<span class="gi">+            #       introduces an ANSI control sequence used to set the</span>
<span class="gi">+            #       style attributes of the following characters.</span>
<span class="gi">+            csi = False</span>
<span class="gi">+</span>
<span class="gi">+            c = yield</span>
<span class="gi">+</span>
<span class="gi">+            # Everything between \001 and \002 should become a ZeroWidthEscape.</span>
<span class="gi">+            if c == &quot;\001&quot;:</span>
<span class="gi">+                escaped_text = &quot;&quot;</span>
<span class="gi">+                while c != &quot;\002&quot;:</span>
<span class="gi">+                    c = yield</span>
<span class="gi">+                    if c == &quot;\002&quot;:</span>
<span class="gi">+                        formatted_text.append((&quot;[ZeroWidthEscape]&quot;, escaped_text))</span>
<span class="gi">+                        c = yield</span>
<span class="gi">+                        break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        escaped_text += c</span>
<span class="gi">+</span>
<span class="gi">+            # Check for CSI</span>
<span class="gi">+            if c == &quot;\x1b&quot;:</span>
<span class="gi">+                # Start of color escape sequence.</span>
<span class="gi">+                square_bracket = yield</span>
<span class="gi">+                if square_bracket == &quot;[&quot;:</span>
<span class="gi">+                    csi = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            elif c == &quot;\x9b&quot;:</span>
<span class="gi">+                csi = True</span>
<span class="gi">+</span>
<span class="gi">+            if csi:</span>
<span class="gi">+                # Got a CSI sequence. Color codes are following.</span>
<span class="gi">+                current = &quot;&quot;</span>
<span class="gi">+                params = []</span>
<span class="gi">+</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    char = yield</span>
<span class="gi">+</span>
<span class="gi">+                    # Construct number</span>
<span class="gi">+                    if char.isdigit():</span>
<span class="gi">+                        current += char</span>
<span class="gi">+</span>
<span class="gi">+                    # Eval number</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Limit and save number value</span>
<span class="gi">+                        params.append(min(int(current or 0), 9999))</span>

<span class="gd">-    def _select_graphic_rendition(self, attrs: list[int]) -&gt;None:</span>
<span class="gi">+                        # Get delimiter token if present</span>
<span class="gi">+                        if char == &quot;;&quot;:</span>
<span class="gi">+                            current = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+                        # Check and evaluate color codes</span>
<span class="gi">+                        elif char == &quot;m&quot;:</span>
<span class="gi">+                            # Set attributes and token.</span>
<span class="gi">+                            self._select_graphic_rendition(params)</span>
<span class="gi">+                            style = self._create_style_string()</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                        # Check and evaluate cursor forward</span>
<span class="gi">+                        elif char == &quot;C&quot;:</span>
<span class="gi">+                            for i in range(params[0]):</span>
<span class="gi">+                                # add &lt;SPACE&gt; using current style</span>
<span class="gi">+                                formatted_text.append((style, &quot; &quot;))</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            # Ignore unsupported sequence.</span>
<span class="gi">+                            break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Add current character.</span>
<span class="gi">+                # NOTE: At this point, we could merge the current character</span>
<span class="gi">+                #       into the previous tuple if the style did not change,</span>
<span class="gi">+                #       however, it&#39;s not worth the effort given that it will</span>
<span class="gi">+                #       be &quot;Exploded&quot; once again when it&#39;s rendered to the</span>
<span class="gi">+                #       output.</span>
<span class="gi">+                formatted_text.append((style, c))</span>
<span class="gi">+</span>
<span class="gi">+    def _select_graphic_rendition(self, attrs: list[int]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Taken a list of graphics attributes and apply changes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not attrs:</span>
<span class="gi">+            attrs = [0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            attrs = list(attrs[::-1])</span>
<span class="gi">+</span>
<span class="gi">+        while attrs:</span>
<span class="gi">+            attr = attrs.pop()</span>
<span class="gi">+</span>
<span class="gi">+            if attr in _fg_colors:</span>
<span class="gi">+                self._color = _fg_colors[attr]</span>
<span class="gi">+            elif attr in _bg_colors:</span>
<span class="gi">+                self._bgcolor = _bg_colors[attr]</span>
<span class="gi">+            elif attr == 1:</span>
<span class="gi">+                self._bold = True</span>
<span class="gi">+            # elif attr == 2:</span>
<span class="gi">+            #   self._faint = True</span>
<span class="gi">+            elif attr == 3:</span>
<span class="gi">+                self._italic = True</span>
<span class="gi">+            elif attr == 4:</span>
<span class="gi">+                self._underline = True</span>
<span class="gi">+            elif attr == 5:</span>
<span class="gi">+                self._blink = True  # Slow blink</span>
<span class="gi">+            elif attr == 6:</span>
<span class="gi">+                self._blink = True  # Fast blink</span>
<span class="gi">+            elif attr == 7:</span>
<span class="gi">+                self._reverse = True</span>
<span class="gi">+            elif attr == 8:</span>
<span class="gi">+                self._hidden = True</span>
<span class="gi">+            elif attr == 9:</span>
<span class="gi">+                self._strike = True</span>
<span class="gi">+            elif attr == 22:</span>
<span class="gi">+                self._bold = False  # Normal intensity</span>
<span class="gi">+            elif attr == 23:</span>
<span class="gi">+                self._italic = False</span>
<span class="gi">+            elif attr == 24:</span>
<span class="gi">+                self._underline = False</span>
<span class="gi">+            elif attr == 25:</span>
<span class="gi">+                self._blink = False</span>
<span class="gi">+            elif attr == 27:</span>
<span class="gi">+                self._reverse = False</span>
<span class="gi">+            elif attr == 28:</span>
<span class="gi">+                self._hidden = False</span>
<span class="gi">+            elif attr == 29:</span>
<span class="gi">+                self._strike = False</span>
<span class="gi">+            elif not attr:</span>
<span class="gi">+                # Reset all style attributes</span>
<span class="gi">+                self._color = None</span>
<span class="gi">+                self._bgcolor = None</span>
<span class="gi">+                self._bold = False</span>
<span class="gi">+                self._underline = False</span>
<span class="gi">+                self._strike = False</span>
<span class="gi">+                self._italic = False</span>
<span class="gi">+                self._blink = False</span>
<span class="gi">+                self._reverse = False</span>
<span class="gi">+                self._hidden = False</span>
<span class="gi">+</span>
<span class="gi">+            elif attr in (38, 48) and len(attrs) &gt; 1:</span>
<span class="gi">+                n = attrs.pop()</span>

<span class="gd">-    def _create_style_string(self) -&gt;str:</span>
<span class="gi">+                # 256 colors.</span>
<span class="gi">+                if n == 5 and len(attrs) &gt;= 1:</span>
<span class="gi">+                    if attr == 38:</span>
<span class="gi">+                        m = attrs.pop()</span>
<span class="gi">+                        self._color = _256_colors.get(m)</span>
<span class="gi">+                    elif attr == 48:</span>
<span class="gi">+                        m = attrs.pop()</span>
<span class="gi">+                        self._bgcolor = _256_colors.get(m)</span>
<span class="gi">+</span>
<span class="gi">+                # True colors.</span>
<span class="gi">+                if n == 2 and len(attrs) &gt;= 3:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        color_str = &quot;#{:02x}{:02x}{:02x}&quot;.format(</span>
<span class="gi">+                            attrs.pop(),</span>
<span class="gi">+                            attrs.pop(),</span>
<span class="gi">+                            attrs.pop(),</span>
<span class="gi">+                        )</span>
<span class="gi">+                    except IndexError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if attr == 38:</span>
<span class="gi">+                            self._color = color_str</span>
<span class="gi">+                        elif attr == 48:</span>
<span class="gi">+                            self._bgcolor = color_str</span>
<span class="gi">+</span>
<span class="gi">+    def _create_style_string(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Turn current style flags into a string for usage in a formatted text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        if self._color:</span>
<span class="gi">+            result.append(self._color)</span>
<span class="gi">+        if self._bgcolor:</span>
<span class="gi">+            result.append(&quot;bg:&quot; + self._bgcolor)</span>
<span class="gi">+        if self._bold:</span>
<span class="gi">+            result.append(&quot;bold&quot;)</span>
<span class="gi">+        if self._underline:</span>
<span class="gi">+            result.append(&quot;underline&quot;)</span>
<span class="gi">+        if self._strike:</span>
<span class="gi">+            result.append(&quot;strike&quot;)</span>
<span class="gi">+        if self._italic:</span>
<span class="gi">+            result.append(&quot;italic&quot;)</span>
<span class="gi">+        if self._blink:</span>
<span class="gi">+            result.append(&quot;blink&quot;)</span>
<span class="gi">+        if self._reverse:</span>
<span class="gi">+            result.append(&quot;reverse&quot;)</span>
<span class="gi">+        if self._hidden:</span>
<span class="gi">+            result.append(&quot;hidden&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot; &quot;.join(result)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;ANSI({self.value!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;ANSI({self.value!r})&quot;</span>

<span class="gd">-    def __pt_formatted_text__(self) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def __pt_formatted_text__(self) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        return self._formatted_text

<span class="gd">-    def format(self, *args: str, **kwargs: str) -&gt;ANSI:</span>
<span class="gi">+    def format(self, *args: str, **kwargs: str) -&gt; ANSI:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like `str.format`, but make sure that the arguments are properly
<span class="w"> </span>        escaped. (No ANSI escapes can be injected.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ANSI(FORMATTER.vformat(self.value, args, kwargs))</span>

<span class="gd">-    def __mod__(self, value: object) -&gt;ANSI:</span>
<span class="gi">+    def __mod__(self, value: object) -&gt; ANSI:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        ANSI(&#39;&lt;b&gt;%s&lt;/b&gt;&#39;) % value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not isinstance(value, tuple):
<span class="gd">-            value = value,</span>
<span class="gi">+            value = (value,)</span>
<span class="gi">+</span>
<span class="w"> </span>        value = tuple(ansi_escape(i) for i in value)
<span class="w"> </span>        return ANSI(self.value % value)


<span class="gi">+# Mapping of the ANSI color codes to their names.</span>
<span class="w"> </span>_fg_colors = {v: k for k, v in FG_ANSI_COLORS.items()}
<span class="w"> </span>_bg_colors = {v: k for k, v in BG_ANSI_COLORS.items()}
<span class="gi">+</span>
<span class="gi">+# Mapping of the escape codes for 256colors to their &#39;ffffff&#39; value.</span>
<span class="w"> </span>_256_colors = {}
<span class="gi">+</span>
<span class="w"> </span>for i, (r, g, b) in enumerate(_256_colors_table.colors):
<span class="gd">-    _256_colors[i] = f&#39;#{r:02x}{g:02x}{b:02x}&#39;</span>
<span class="gi">+    _256_colors[i] = f&quot;#{r:02x}{g:02x}{b:02x}&quot;</span>


<span class="gd">-def ansi_escape(text: object) -&gt;str:</span>
<span class="gi">+def ansi_escape(text: object) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace characters with a special meaning.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(text).replace(&quot;\x1b&quot;, &quot;?&quot;).replace(&quot;\b&quot;, &quot;?&quot;)</span>


<span class="w"> </span>class ANSIFormatter(Formatter):
<span class="gd">-    pass</span>
<span class="gi">+    def format_field(self, value: object, format_spec: str) -&gt; str:</span>
<span class="gi">+        return ansi_escape(format(value, format_spec))</span>


<span class="w"> </span>FORMATTER = ANSIFormatter()
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/base.py b/src/prompt_toolkit/formatted_text/base.py</span>
<span class="gh">index 41ecbc3b..92de3535 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/base.py</span>
<span class="gu">@@ -1,33 +1,60 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Iterable, List, Tuple, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Protocol
<span class="gi">+</span>
<span class="w"> </span>    from prompt_toolkit.key_binding.key_bindings import NotImplementedOrNone
<span class="gd">-__all__ = [&#39;OneStyleAndTextTuple&#39;, &#39;StyleAndTextTuples&#39;,</span>
<span class="gd">-    &#39;MagicFormattedText&#39;, &#39;AnyFormattedText&#39;, &#39;to_formatted_text&#39;,</span>
<span class="gd">-    &#39;is_formatted_text&#39;, &#39;Template&#39;, &#39;merge_formatted_text&#39;, &#39;FormattedText&#39;]</span>
<span class="gd">-OneStyleAndTextTuple = Union[Tuple[str, str], Tuple[str, str, Callable[[</span>
<span class="gd">-    MouseEvent], &#39;NotImplementedOrNone&#39;]]]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;OneStyleAndTextTuple&quot;,</span>
<span class="gi">+    &quot;StyleAndTextTuples&quot;,</span>
<span class="gi">+    &quot;MagicFormattedText&quot;,</span>
<span class="gi">+    &quot;AnyFormattedText&quot;,</span>
<span class="gi">+    &quot;to_formatted_text&quot;,</span>
<span class="gi">+    &quot;is_formatted_text&quot;,</span>
<span class="gi">+    &quot;Template&quot;,</span>
<span class="gi">+    &quot;merge_formatted_text&quot;,</span>
<span class="gi">+    &quot;FormattedText&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+OneStyleAndTextTuple = Union[</span>
<span class="gi">+    Tuple[str, str], Tuple[str, str, Callable[[MouseEvent], &quot;NotImplementedOrNone&quot;]]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# List of (style, text) tuples.</span>
<span class="w"> </span>StyleAndTextTuples = List[OneStyleAndTextTuple]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import TypeGuard

<span class="gd">-</span>
<span class="w"> </span>    class MagicFormattedText(Protocol):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Any object that implements ``__pt_formatted_text__`` represents formatted
<span class="w"> </span>        text.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def __pt_formatted_text__(self) -&gt;StyleAndTextTuples:</span>
<span class="gi">+        def __pt_formatted_text__(self) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>            ...
<span class="gd">-AnyFormattedText = Union[str, &#39;MagicFormattedText&#39;, StyleAndTextTuples,</span>
<span class="gd">-    Callable[[], Any], None]</span>


<span class="gd">-def to_formatted_text(value: AnyFormattedText, style: str=&#39;&#39;, auto_convert:</span>
<span class="gd">-    bool=False) -&gt;FormattedText:</span>
<span class="gi">+AnyFormattedText = Union[</span>
<span class="gi">+    str,</span>
<span class="gi">+    &quot;MagicFormattedText&quot;,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    # Callable[[], &#39;AnyFormattedText&#39;]  # Recursive definition not supported by mypy.</span>
<span class="gi">+    Callable[[], Any],</span>
<span class="gi">+    None,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_formatted_text(</span>
<span class="gi">+    value: AnyFormattedText, style: str = &quot;&quot;, auto_convert: bool = False</span>
<span class="gi">+) -&gt; FormattedText:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert the given value (which can be formatted text) into a list of text
<span class="w"> </span>    fragments. (Which is the canonical form of formatted text.) The outcome is
<span class="gu">@@ -42,16 +69,55 @@ def to_formatted_text(value: AnyFormattedText, style: str=&#39;&#39;, auto_convert:</span>
<span class="w"> </span>    :param auto_convert: If `True`, also accept other types, and convert them
<span class="w"> </span>        to a string first.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_formatted_text(value: object) -&gt;TypeGuard[AnyFormattedText]:</span>
<span class="gi">+    result: FormattedText | StyleAndTextTuples</span>
<span class="gi">+</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        result = []</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        result = [(&quot;&quot;, value)]</span>
<span class="gi">+    elif isinstance(value, list):</span>
<span class="gi">+        result = value  # StyleAndTextTuples</span>
<span class="gi">+    elif hasattr(value, &quot;__pt_formatted_text__&quot;):</span>
<span class="gi">+        result = cast(&quot;MagicFormattedText&quot;, value).__pt_formatted_text__()</span>
<span class="gi">+    elif callable(value):</span>
<span class="gi">+        return to_formatted_text(value(), style=style)</span>
<span class="gi">+    elif auto_convert:</span>
<span class="gi">+        result = [(&quot;&quot;, f&quot;{value}&quot;)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;No formatted text. Expecting a unicode object, &quot;</span>
<span class="gi">+            f&quot;HTML, ANSI or a FormattedText instance. Got {value!r}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Apply extra style.</span>
<span class="gi">+    if style:</span>
<span class="gi">+        result = cast(</span>
<span class="gi">+            StyleAndTextTuples,</span>
<span class="gi">+            [(style + &quot; &quot; + item_style, *rest) for item_style, *rest in result],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Make sure the result is wrapped in a `FormattedText`. Among other</span>
<span class="gi">+    # reasons, this is important for `print_formatted_text` to work correctly</span>
<span class="gi">+    # and distinguish between lists and formatted text.</span>
<span class="gi">+    if isinstance(result, FormattedText):</span>
<span class="gi">+        return result</span>
<span class="gi">+    else:</span>
<span class="gi">+        return FormattedText(result)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_formatted_text(value: object) -&gt; TypeGuard[AnyFormattedText]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether the input is valid formatted text (for use in assert
<span class="w"> </span>    statements).
<span class="w"> </span>    In case of a callable, it doesn&#39;t check the return type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isinstance(value, (str, list)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if hasattr(value, &quot;__pt_formatted_text__&quot;):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class FormattedText(StyleAndTextTuples):
<span class="gu">@@ -62,11 +128,11 @@ class FormattedText(StyleAndTextTuples):</span>
<span class="w"> </span>    tuples.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __pt_formatted_text__(self) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def __pt_formatted_text__(self) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;FormattedText(%s)&#39; % super().__repr__()</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;FormattedText(%s)&quot; % super().__repr__()</span>


<span class="w"> </span>class Template:
<span class="gu">@@ -80,13 +146,35 @@ class Template:</span>
<span class="w"> </span>    :param text: Plain text.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str) -&gt;None:</span>
<span class="gd">-        assert &#39;{0}&#39; not in text</span>
<span class="gi">+    def __init__(self, text: str) -&gt; None:</span>
<span class="gi">+        assert &quot;{0}&quot; not in text</span>
<span class="w"> </span>        self.text = text

<span class="gi">+    def format(self, *values: AnyFormattedText) -&gt; AnyFormattedText:</span>
<span class="gi">+        def get_result() -&gt; AnyFormattedText:</span>
<span class="gi">+            # Split the template in parts.</span>
<span class="gi">+            parts = self.text.split(&quot;{}&quot;)</span>
<span class="gi">+            assert len(parts) - 1 == len(values)</span>
<span class="gi">+</span>
<span class="gi">+            result = FormattedText()</span>
<span class="gi">+            for part, val in zip(parts, values):</span>
<span class="gi">+                result.append((&quot;&quot;, part))</span>
<span class="gi">+                result.extend(to_formatted_text(val))</span>
<span class="gi">+            result.append((&quot;&quot;, parts[-1]))</span>
<span class="gi">+            return result</span>

<span class="gd">-def merge_formatted_text(items: Iterable[AnyFormattedText]) -&gt;AnyFormattedText:</span>
<span class="gi">+        return get_result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge_formatted_text(items: Iterable[AnyFormattedText]) -&gt; AnyFormattedText:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge (Concatenate) several pieces of formatted text together.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _merge_formatted_text() -&gt; AnyFormattedText:</span>
<span class="gi">+        result = FormattedText()</span>
<span class="gi">+        for i in items:</span>
<span class="gi">+            result.extend(to_formatted_text(i))</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    return _merge_formatted_text</span>
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/html.py b/src/prompt_toolkit/formatted_text/html.py</span>
<span class="gh">index 25f82c7d..a940ac8f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/html.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/html.py</span>
<span class="gu">@@ -1,9 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import xml.dom.minidom as minidom
<span class="w"> </span>from string import Formatter
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from .base import FormattedText, StyleAndTextTuples
<span class="gd">-__all__ = [&#39;HTML&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;HTML&quot;]</span>


<span class="w"> </span>class HTML:
<span class="gu">@@ -27,86 +30,116 @@ class HTML:</span>
<span class="w"> </span>    ``username``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, value: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: str) -&gt; None:</span>
<span class="w"> </span>        self.value = value
<span class="gd">-        document = minidom.parseString(f&#39;&lt;html-root&gt;{value}&lt;/html-root&gt;&#39;)</span>
<span class="gi">+        document = minidom.parseString(f&quot;&lt;html-root&gt;{value}&lt;/html-root&gt;&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        result: StyleAndTextTuples = []
<span class="w"> </span>        name_stack: list[str] = []
<span class="w"> </span>        fg_stack: list[str] = []
<span class="w"> </span>        bg_stack: list[str] = []

<span class="gd">-        def get_current_style() -&gt;str:</span>
<span class="gd">-            &quot;&quot;&quot;Build style string for current node.&quot;&quot;&quot;</span>
<span class="gi">+        def get_current_style() -&gt; str:</span>
<span class="gi">+            &quot;Build style string for current node.&quot;</span>
<span class="w"> </span>            parts = []
<span class="w"> </span>            if name_stack:
<span class="gd">-                parts.append(&#39;class:&#39; + &#39;,&#39;.join(name_stack))</span>
<span class="gi">+                parts.append(&quot;class:&quot; + &quot;,&quot;.join(name_stack))</span>
<span class="gi">+</span>
<span class="w"> </span>            if fg_stack:
<span class="gd">-                parts.append(&#39;fg:&#39; + fg_stack[-1])</span>
<span class="gi">+                parts.append(&quot;fg:&quot; + fg_stack[-1])</span>
<span class="w"> </span>            if bg_stack:
<span class="gd">-                parts.append(&#39;bg:&#39; + bg_stack[-1])</span>
<span class="gd">-            return &#39; &#39;.join(parts)</span>
<span class="gi">+                parts.append(&quot;bg:&quot; + bg_stack[-1])</span>
<span class="gi">+            return &quot; &quot;.join(parts)</span>

<span class="gd">-        def process_node(node: Any) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;Process node recursively.&quot;&quot;&quot;</span>
<span class="gi">+        def process_node(node: Any) -&gt; None:</span>
<span class="gi">+            &quot;Process node recursively.&quot;</span>
<span class="w"> </span>            for child in node.childNodes:
<span class="w"> </span>                if child.nodeType == child.TEXT_NODE:
<span class="w"> </span>                    result.append((get_current_style(), child.data))
<span class="w"> </span>                else:
<span class="gd">-                    add_to_name_stack = child.nodeName not in (&#39;#document&#39;,</span>
<span class="gd">-                        &#39;html-root&#39;, &#39;style&#39;)</span>
<span class="gd">-                    fg = bg = &#39;&#39;</span>
<span class="gi">+                    add_to_name_stack = child.nodeName not in (</span>
<span class="gi">+                        &quot;#document&quot;,</span>
<span class="gi">+                        &quot;html-root&quot;,</span>
<span class="gi">+                        &quot;style&quot;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    fg = bg = &quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>                    for k, v in child.attributes.items():
<span class="gd">-                        if k == &#39;fg&#39;:</span>
<span class="gi">+                        if k == &quot;fg&quot;:</span>
<span class="w"> </span>                            fg = v
<span class="gd">-                        if k == &#39;bg&#39;:</span>
<span class="gi">+                        if k == &quot;bg&quot;:</span>
<span class="w"> </span>                            bg = v
<span class="gd">-                        if k == &#39;color&#39;:</span>
<span class="gd">-                            fg = v</span>
<span class="gd">-                    if &#39; &#39; in fg:</span>
<span class="gi">+                        if k == &quot;color&quot;:</span>
<span class="gi">+                            fg = v  # Alias for &#39;fg&#39;.</span>
<span class="gi">+</span>
<span class="gi">+                    # Check for spaces in attributes. This would result in</span>
<span class="gi">+                    # invalid style strings otherwise.</span>
<span class="gi">+                    if &quot; &quot; in fg:</span>
<span class="w"> </span>                        raise ValueError(&#39;&quot;fg&quot; attribute contains a space.&#39;)
<span class="gd">-                    if &#39; &#39; in bg:</span>
<span class="gi">+                    if &quot; &quot; in bg:</span>
<span class="w"> </span>                        raise ValueError(&#39;&quot;bg&quot; attribute contains a space.&#39;)
<span class="gi">+</span>
<span class="w"> </span>                    if add_to_name_stack:
<span class="w"> </span>                        name_stack.append(child.nodeName)
<span class="w"> </span>                    if fg:
<span class="w"> </span>                        fg_stack.append(fg)
<span class="w"> </span>                    if bg:
<span class="w"> </span>                        bg_stack.append(bg)
<span class="gi">+</span>
<span class="w"> </span>                    process_node(child)
<span class="gi">+</span>
<span class="w"> </span>                    if add_to_name_stack:
<span class="w"> </span>                        name_stack.pop()
<span class="w"> </span>                    if fg:
<span class="w"> </span>                        fg_stack.pop()
<span class="w"> </span>                    if bg:
<span class="w"> </span>                        bg_stack.pop()
<span class="gi">+</span>
<span class="w"> </span>        process_node(document)
<span class="gi">+</span>
<span class="w"> </span>        self.formatted_text = FormattedText(result)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;HTML({self.value!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;HTML({self.value!r})&quot;</span>

<span class="gd">-    def __pt_formatted_text__(self) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def __pt_formatted_text__(self) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        return self.formatted_text

<span class="gd">-    def format(self, *args: object, **kwargs: object) -&gt;HTML:</span>
<span class="gi">+    def format(self, *args: object, **kwargs: object) -&gt; HTML:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like `str.format`, but make sure that the arguments are properly
<span class="w"> </span>        escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return HTML(FORMATTER.vformat(self.value, args, kwargs))</span>

<span class="gd">-    def __mod__(self, value: object) -&gt;HTML:</span>
<span class="gi">+    def __mod__(self, value: object) -&gt; HTML:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        HTML(&#39;&lt;b&gt;%s&lt;/b&gt;&#39;) % value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not isinstance(value, tuple):
<span class="gd">-            value = value,</span>
<span class="gi">+            value = (value,)</span>
<span class="gi">+</span>
<span class="w"> </span>        value = tuple(html_escape(i) for i in value)
<span class="w"> </span>        return HTML(self.value % value)


<span class="w"> </span>class HTMLFormatter(Formatter):
<span class="gd">-    pass</span>
<span class="gi">+    def format_field(self, value: object, format_spec: str) -&gt; str:</span>
<span class="gi">+        return html_escape(format(value, format_spec))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_escape(text: object) -&gt; str:</span>
<span class="gi">+    # The string interpolation functions also take integers and other types.</span>
<span class="gi">+    # Convert to string first.</span>
<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        text = f&quot;{text}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        text.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)</span>
<span class="gi">+        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)</span>
<span class="gi">+        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)</span>
<span class="gi">+        .replace(&#39;&quot;&#39;, &quot;&amp;quot;&quot;)</span>
<span class="gi">+    )</span>


<span class="w"> </span>FORMATTER = HTMLFormatter()
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/pygments.py b/src/prompt_toolkit/formatted_text/pygments.py</span>
<span class="gh">index e0c34f89..d4ef3ad8 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/pygments.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/pygments.py</span>
<span class="gu">@@ -1,10 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.styles.pygments import pygments_token_to_classname
<span class="gi">+</span>
<span class="w"> </span>from .base import StyleAndTextTuples
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pygments.token import Token
<span class="gd">-__all__ = [&#39;PygmentsTokens&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PygmentsTokens&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class PygmentsTokens:
<span class="gu">@@ -13,12 +20,13 @@ class PygmentsTokens:</span>
<span class="w"> </span>    (``(style_str, text)`` tuples).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, token_list: list[tuple[Token, str]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, token_list: list[tuple[Token, str]]) -&gt; None:</span>
<span class="w"> </span>        self.token_list = token_list

<span class="gd">-    def __pt_formatted_text__(self) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def __pt_formatted_text__(self) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        result: StyleAndTextTuples = []
<span class="gi">+</span>
<span class="w"> </span>        for token, text in self.token_list:
<span class="gd">-            result.append((&#39;class:&#39; + pygments_token_to_classname(token), text)</span>
<span class="gd">-                )</span>
<span class="gi">+            result.append((&quot;class:&quot; + pygments_token_to_classname(token), text))</span>
<span class="gi">+</span>
<span class="w"> </span>        return result
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/utils.py b/src/prompt_toolkit/formatted_text/utils.py</span>
<span class="gh">index 1e4f49b4..c8c37e09 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/utils.py</span>
<span class="gu">@@ -5,31 +5,46 @@ When ``to_formatted_text`` has been called, we get a list of ``(style, text)``</span>
<span class="w"> </span>tuples. This file contains functions for manipulating such a list.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterable, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gd">-from .base import AnyFormattedText, OneStyleAndTextTuple, StyleAndTextTuples, to_formatted_text</span>
<span class="gd">-__all__ = [&#39;to_plain_text&#39;, &#39;fragment_list_len&#39;, &#39;fragment_list_width&#39;,</span>
<span class="gd">-    &#39;fragment_list_to_text&#39;, &#39;split_lines&#39;]</span>
<span class="gi">+</span>
<span class="gi">+from .base import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    OneStyleAndTextTuple,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;to_plain_text&quot;,</span>
<span class="gi">+    &quot;fragment_list_len&quot;,</span>
<span class="gi">+    &quot;fragment_list_width&quot;,</span>
<span class="gi">+    &quot;fragment_list_to_text&quot;,</span>
<span class="gi">+    &quot;split_lines&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def to_plain_text(value: AnyFormattedText) -&gt;str:</span>
<span class="gi">+def to_plain_text(value: AnyFormattedText) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn any kind of formatted text back into plain text.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return fragment_list_to_text(to_formatted_text(value))</span>


<span class="gd">-def fragment_list_len(fragments: StyleAndTextTuples) -&gt;int:</span>
<span class="gi">+def fragment_list_len(fragments: StyleAndTextTuples) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the amount of characters in this text fragment list.

<span class="w"> </span>    :param fragments: List of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ZeroWidthEscape = &quot;[ZeroWidthEscape]&quot;</span>
<span class="gi">+    return sum(len(item[1]) for item in fragments if ZeroWidthEscape not in item[0])</span>


<span class="gd">-def fragment_list_width(fragments: StyleAndTextTuples) -&gt;int:</span>
<span class="gi">+def fragment_list_width(fragments: StyleAndTextTuples) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the character width of this text fragment list.
<span class="w"> </span>    (Take double width characters into account.)
<span class="gu">@@ -37,21 +52,29 @@ def fragment_list_width(fragments: StyleAndTextTuples) -&gt;int:</span>
<span class="w"> </span>    :param fragments: List of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ZeroWidthEscape = &quot;[ZeroWidthEscape]&quot;</span>
<span class="gi">+    return sum(</span>
<span class="gi">+        get_cwidth(c)</span>
<span class="gi">+        for item in fragments</span>
<span class="gi">+        for c in item[1]</span>
<span class="gi">+        if ZeroWidthEscape not in item[0]</span>
<span class="gi">+    )</span>


<span class="gd">-def fragment_list_to_text(fragments: StyleAndTextTuples) -&gt;str:</span>
<span class="gi">+def fragment_list_to_text(fragments: StyleAndTextTuples) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Concatenate all the text parts again.

<span class="w"> </span>    :param fragments: List of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ZeroWidthEscape = &quot;[ZeroWidthEscape]&quot;</span>
<span class="gi">+    return &quot;&quot;.join(item[1] for item in fragments if ZeroWidthEscape not in item[0])</span>


<span class="gd">-def split_lines(fragments: Iterable[OneStyleAndTextTuple]) -&gt;Iterable[</span>
<span class="gd">-    StyleAndTextTuples]:</span>
<span class="gi">+def split_lines(</span>
<span class="gi">+    fragments: Iterable[OneStyleAndTextTuple],</span>
<span class="gi">+) -&gt; Iterable[StyleAndTextTuples]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a single list of (style_str, text) tuples and yield one such list for each
<span class="w"> </span>    line. Just like str.split, this will yield at least one item.
<span class="gu">@@ -59,4 +82,21 @@ def split_lines(fragments: Iterable[OneStyleAndTextTuple]) -&gt;Iterable[</span>
<span class="w"> </span>    :param fragments: Iterable of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    line: StyleAndTextTuples = []</span>
<span class="gi">+</span>
<span class="gi">+    for style, string, *mouse_handler in fragments:</span>
<span class="gi">+        parts = string.split(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for part in parts[:-1]:</span>
<span class="gi">+            if part:</span>
<span class="gi">+                line.append(cast(OneStyleAndTextTuple, (style, part, *mouse_handler)))</span>
<span class="gi">+            yield line</span>
<span class="gi">+            line = []</span>
<span class="gi">+</span>
<span class="gi">+        line.append(cast(OneStyleAndTextTuple, (style, parts[-1], *mouse_handler)))</span>
<span class="gi">+</span>
<span class="gi">+    # Always yield the last line, even when this is an empty line. This ensures</span>
<span class="gi">+    # that when `fragments` ends with a newline character, an additional empty</span>
<span class="gi">+    # line is yielded. (Otherwise, there&#39;s no way to differentiate between the</span>
<span class="gi">+    # cases where `fragments` does and doesn&#39;t end with a newline.)</span>
<span class="gi">+    yield line</span>
<span class="gh">diff --git a/src/prompt_toolkit/history.py b/src/prompt_toolkit/history.py</span>
<span class="gh">index de643197..553918e5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/history.py</span>
<span class="gi">+++ b/src/prompt_toolkit/history.py</span>
<span class="gu">@@ -8,14 +8,21 @@ NOTE: There is no `DynamicHistory`:</span>
<span class="w"> </span>      probably break this.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import os
<span class="w"> </span>import threading
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from typing import AsyncGenerator, Iterable, Sequence
<span class="gd">-__all__ = [&#39;History&#39;, &#39;ThreadedHistory&#39;, &#39;DummyHistory&#39;, &#39;FileHistory&#39;,</span>
<span class="gd">-    &#39;InMemoryHistory&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;History&quot;,</span>
<span class="gi">+    &quot;ThreadedHistory&quot;,</span>
<span class="gi">+    &quot;DummyHistory&quot;,</span>
<span class="gi">+    &quot;FileHistory&quot;,</span>
<span class="gi">+    &quot;InMemoryHistory&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class History(metaclass=ABCMeta):
<span class="gu">@@ -25,11 +32,19 @@ class History(metaclass=ABCMeta):</span>
<span class="w"> </span>    This also includes abstract methods for loading/storing history.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # In memory storage for strings.</span>
<span class="w"> </span>        self._loaded = False
<span class="gi">+</span>
<span class="gi">+        # History that&#39;s loaded already, in reverse order. Latest, most recent</span>
<span class="gi">+        # item first.</span>
<span class="w"> </span>        self._loaded_strings: list[str] = []

<span class="gd">-    async def load(self) -&gt;AsyncGenerator[str, None]:</span>
<span class="gi">+    #</span>
<span class="gi">+    # Methods expected by `Buffer`.</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    async def load(self) -&gt; AsyncGenerator[str, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Load the history and yield all the entries in reverse order (latest,
<span class="w"> </span>        most recent history entry first).
<span class="gu">@@ -40,21 +55,31 @@ class History(metaclass=ABCMeta):</span>
<span class="w"> </span>        were were appended to the history will be incorporated next time this
<span class="w"> </span>        method is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._loaded:</span>
<span class="gi">+            self._loaded_strings = list(self.load_history_strings())</span>
<span class="gi">+            self._loaded = True</span>
<span class="gi">+</span>
<span class="gi">+        for item in self._loaded_strings:</span>
<span class="gi">+            yield item</span>

<span class="gd">-    def get_strings(self) -&gt;list[str]:</span>
<span class="gi">+    def get_strings(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the strings from the history that are loaded so far.
<span class="w"> </span>        (In order. Oldest item first.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._loaded_strings[::-1]</span>

<span class="gd">-    def append_string(self, string: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Add string to the history.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def append_string(self, string: str) -&gt; None:</span>
<span class="gi">+        &quot;Add string to the history.&quot;</span>
<span class="gi">+        self._loaded_strings.insert(0, string)</span>
<span class="gi">+        self.store_string(string)</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # Implementation for specific backends.</span>
<span class="gi">+    #</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def load_history_strings(self) -&gt;Iterable[str]:</span>
<span class="gi">+    def load_history_strings(self) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This should be a generator that yields `str` instances.

<span class="gu">@@ -62,14 +87,14 @@ class History(metaclass=ABCMeta):</span>
<span class="w"> </span>        important. (The history can already be used, even when it&#39;s only
<span class="w"> </span>        partially loaded.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while False:</span>
<span class="gi">+            yield</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def store_string(self, string: str) -&gt;None:</span>
<span class="gi">+    def store_string(self, string: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Store the string in persistent storage.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class ThreadedHistory(History):
<span class="gu">@@ -82,22 +107,112 @@ class ThreadedHistory(History):</span>
<span class="w"> </span>    wait for everything to be loaded.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, history: History) -&gt;None:</span>
<span class="gi">+    def __init__(self, history: History) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="w"> </span>        self.history = history
<span class="gi">+</span>
<span class="w"> </span>        self._load_thread: threading.Thread | None = None
<span class="gi">+</span>
<span class="gi">+        # Lock for accessing/manipulating `_loaded_strings` and `_loaded`</span>
<span class="gi">+        # together in a consistent state.</span>
<span class="w"> </span>        self._lock = threading.Lock()
<span class="gi">+</span>
<span class="gi">+        # Events created by each `load()` call. Used to wait for new history</span>
<span class="gi">+        # entries from the loader thread.</span>
<span class="w"> </span>        self._string_load_events: list[threading.Event] = []

<span class="gd">-    async def load(self) -&gt;AsyncGenerator[str, None]:</span>
<span class="gi">+    async def load(self) -&gt; AsyncGenerator[str, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like `History.load(), but call `self.load_history_strings()` in a
<span class="w"> </span>        background thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Start the load thread, if this is called for the first time.</span>
<span class="gi">+        if not self._load_thread:</span>
<span class="gi">+            self._load_thread = threading.Thread(</span>
<span class="gi">+                target=self._in_load_thread,</span>
<span class="gi">+                daemon=True,</span>
<span class="gi">+            )</span>
<span class="gi">+            self._load_thread.start()</span>
<span class="gi">+</span>
<span class="gi">+        # Consume the `_loaded_strings` list, using asyncio.</span>
<span class="gi">+        loop = get_running_loop()</span>
<span class="gi">+</span>
<span class="gi">+        # Create threading Event so that we can wait for new items.</span>
<span class="gi">+        event = threading.Event()</span>
<span class="gi">+        event.set()</span>
<span class="gi">+        self._string_load_events.append(event)</span>
<span class="gi">+</span>
<span class="gi">+        items_yielded = 0</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                # Wait for new items to be available.</span>
<span class="gi">+                # (Use a timeout, because the executor thread is not a daemon</span>
<span class="gi">+                # thread. The &quot;slow-history.py&quot; example would otherwise hang if</span>
<span class="gi">+                # Control-C is pressed before the history is fully loaded,</span>
<span class="gi">+                # because there&#39;s still this non-daemon executor thread waiting</span>
<span class="gi">+                # for this event.)</span>
<span class="gi">+                got_timeout = await loop.run_in_executor(</span>
<span class="gi">+                    None, lambda: event.wait(timeout=0.5)</span>
<span class="gi">+                )</span>
<span class="gi">+                if not got_timeout:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Read new items (in lock).</span>
<span class="gi">+                def in_executor() -&gt; tuple[list[str], bool]:</span>
<span class="gi">+                    with self._lock:</span>
<span class="gi">+                        new_items = self._loaded_strings[items_yielded:]</span>
<span class="gi">+                        done = self._loaded</span>
<span class="gi">+                        event.clear()</span>
<span class="gi">+                    return new_items, done</span>
<span class="gi">+</span>
<span class="gi">+                new_items, done = await loop.run_in_executor(None, in_executor)</span>
<span class="gi">+</span>
<span class="gi">+                items_yielded += len(new_items)</span>
<span class="gi">+</span>
<span class="gi">+                for item in new_items:</span>
<span class="gi">+                    yield item</span>
<span class="gi">+</span>
<span class="gi">+                if done:</span>
<span class="gi">+                    break</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._string_load_events.remove(event)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;ThreadedHistory({self.history!r})&#39;</span>
<span class="gi">+    def _in_load_thread(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Start with an empty list. In case `append_string()` was called</span>
<span class="gi">+            # before `load()` happened. Then `.store_string()` will have</span>
<span class="gi">+            # written these entries back to disk and we will reload it.</span>
<span class="gi">+            self._loaded_strings = []</span>
<span class="gi">+</span>
<span class="gi">+            for item in self.history.load_history_strings():</span>
<span class="gi">+                with self._lock:</span>
<span class="gi">+                    self._loaded_strings.append(item)</span>
<span class="gi">+</span>
<span class="gi">+                for event in self._string_load_events:</span>
<span class="gi">+                    event.set()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                self._loaded = True</span>
<span class="gi">+            for event in self._string_load_events:</span>
<span class="gi">+                event.set()</span>
<span class="gi">+</span>
<span class="gi">+    def append_string(self, string: str) -&gt; None:</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._loaded_strings.insert(0, string)</span>
<span class="gi">+        self.store_string(string)</span>
<span class="gi">+</span>
<span class="gi">+    # All of the following are proxied to `self.history`.</span>
<span class="gi">+</span>
<span class="gi">+    def load_history_strings(self) -&gt; Iterable[str]:</span>
<span class="gi">+        return self.history.load_history_strings()</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt; None:</span>
<span class="gi">+        self.history.store_string(string)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;ThreadedHistory({self.history!r})&quot;</span>


<span class="w"> </span>class InMemoryHistory(History):
<span class="gu">@@ -108,25 +223,80 @@ class InMemoryHistory(History):</span>
<span class="w"> </span>    `append_string` for all items or pass a list of strings to `__init__` here.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, history_strings: (Sequence[str] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, history_strings: Sequence[str] | None = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+        # Emulating disk storage.</span>
<span class="w"> </span>        if history_strings is None:
<span class="w"> </span>            self._storage = []
<span class="w"> </span>        else:
<span class="w"> </span>            self._storage = list(history_strings)

<span class="gi">+    def load_history_strings(self) -&gt; Iterable[str]:</span>
<span class="gi">+        yield from self._storage[::-1]</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt; None:</span>
<span class="gi">+        self._storage.append(string)</span>
<span class="gi">+</span>

<span class="w"> </span>class DummyHistory(History):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :class:`.History` object that doesn&#39;t remember anything.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def load_history_strings(self) -&gt; Iterable[str]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def append_string(self, string: str) -&gt; None:</span>
<span class="gi">+        # Don&#39;t remember this.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class FileHistory(History):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :class:`.History` class that stores all strings in a file.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename: str) -&gt; None:</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="gi">+    def load_history_strings(self) -&gt; Iterable[str]:</span>
<span class="gi">+        strings: list[str] = []</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        def add() -&gt; None:</span>
<span class="gi">+            if lines:</span>
<span class="gi">+                # Join and drop trailing newline.</span>
<span class="gi">+                string = &quot;&quot;.join(lines)[:-1]</span>
<span class="gi">+</span>
<span class="gi">+                strings.append(string)</span>
<span class="gi">+</span>
<span class="gi">+        if os.path.exists(self.filename):</span>
<span class="gi">+            with open(self.filename, &quot;rb&quot;) as f:</span>
<span class="gi">+                for line_bytes in f:</span>
<span class="gi">+                    line = line_bytes.decode(&quot;utf-8&quot;, errors=&quot;replace&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                    if line.startswith(&quot;+&quot;):</span>
<span class="gi">+                        lines.append(line[1:])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        add()</span>
<span class="gi">+                        lines = []</span>
<span class="gi">+</span>
<span class="gi">+                add()</span>
<span class="gi">+</span>
<span class="gi">+        # Reverse the order, because newest items have to go first.</span>
<span class="gi">+        return reversed(strings)</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt; None:</span>
<span class="gi">+        # Save to file.</span>
<span class="gi">+        with open(self.filename, &quot;ab&quot;) as f:</span>
<span class="gi">+</span>
<span class="gi">+            def write(t: str) -&gt; None:</span>
<span class="gi">+                f.write(t.encode(&quot;utf-8&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            write(&quot;\n# %s\n&quot; % datetime.datetime.now())</span>
<span class="gi">+            for line in string.split(&quot;\n&quot;):</span>
<span class="gi">+                write(&quot;+%s\n&quot; % line)</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/ansi_escape_sequences.py b/src/prompt_toolkit/input/ansi_escape_sequences.py</span>
<span class="gh">index e1df88bf..5648c664 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/ansi_escape_sequences.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/ansi_escape_sequences.py</span>
<span class="gu">@@ -11,129 +11,333 @@ Some useful docs:</span>
<span class="w"> </span>- Mintty: https://github.com/mintty/mintty/blob/master/wiki/Keycodes.md
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from ..keys import Keys
<span class="gd">-__all__ = [&#39;ANSI_SEQUENCES&#39;, &#39;REVERSE_ANSI_SEQUENCES&#39;]</span>
<span class="gd">-ANSI_SEQUENCES: dict[str, Keys | tuple[Keys, ...]] = {&#39;\x00&#39;: Keys.</span>
<span class="gd">-    ControlAt, &#39;\x01&#39;: Keys.ControlA, &#39;\x02&#39;: Keys.ControlB, &#39;\x03&#39;: Keys.</span>
<span class="gd">-    ControlC, &#39;\x04&#39;: Keys.ControlD, &#39;\x05&#39;: Keys.ControlE, &#39;\x06&#39;: Keys.</span>
<span class="gd">-    ControlF, &#39;\x07&#39;: Keys.ControlG, &#39;\x08&#39;: Keys.ControlH, &#39;\t&#39;: Keys.</span>
<span class="gd">-    ControlI, &#39;\n&#39;: Keys.ControlJ, &#39;\x0b&#39;: Keys.ControlK, &#39;\x0c&#39;: Keys.</span>
<span class="gd">-    ControlL, &#39;\r&#39;: Keys.ControlM, &#39;\x0e&#39;: Keys.ControlN, &#39;\x0f&#39;: Keys.</span>
<span class="gd">-    ControlO, &#39;\x10&#39;: Keys.ControlP, &#39;\x11&#39;: Keys.ControlQ, &#39;\x12&#39;: Keys.</span>
<span class="gd">-    ControlR, &#39;\x13&#39;: Keys.ControlS, &#39;\x14&#39;: Keys.ControlT, &#39;\x15&#39;: Keys.</span>
<span class="gd">-    ControlU, &#39;\x16&#39;: Keys.ControlV, &#39;\x17&#39;: Keys.ControlW, &#39;\x18&#39;: Keys.</span>
<span class="gd">-    ControlX, &#39;\x19&#39;: Keys.ControlY, &#39;\x1a&#39;: Keys.ControlZ, &#39;\x1b&#39;: Keys.</span>
<span class="gd">-    Escape, &#39;\x9b&#39;: Keys.ShiftEscape, &#39;\x1c&#39;: Keys.ControlBackslash, &#39;\x1d&#39;:</span>
<span class="gd">-    Keys.ControlSquareClose, &#39;\x1e&#39;: Keys.ControlCircumflex, &#39;\x1f&#39;: Keys.</span>
<span class="gd">-    ControlUnderscore, &#39;\x7f&#39;: Keys.ControlH, &#39;\x1b[1~&#39;: Keys.Home,</span>
<span class="gd">-    &#39;\x1b[2~&#39;: Keys.Insert, &#39;\x1b[3~&#39;: Keys.Delete, &#39;\x1b[4~&#39;: Keys.End,</span>
<span class="gd">-    &#39;\x1b[5~&#39;: Keys.PageUp, &#39;\x1b[6~&#39;: Keys.PageDown, &#39;\x1b[7~&#39;: Keys.Home,</span>
<span class="gd">-    &#39;\x1b[8~&#39;: Keys.End, &#39;\x1b[Z&#39;: Keys.BackTab, &#39;\x1b\t&#39;: Keys.BackTab,</span>
<span class="gd">-    &#39;\x1b[~&#39;: Keys.BackTab, &#39;\x1bOP&#39;: Keys.F1, &#39;\x1bOQ&#39;: Keys.F2, &#39;\x1bOR&#39;:</span>
<span class="gd">-    Keys.F3, &#39;\x1bOS&#39;: Keys.F4, &#39;\x1b[[A&#39;: Keys.F1, &#39;\x1b[[B&#39;: Keys.F2,</span>
<span class="gd">-    &#39;\x1b[[C&#39;: Keys.F3, &#39;\x1b[[D&#39;: Keys.F4, &#39;\x1b[[E&#39;: Keys.F5, &#39;\x1b[11~&#39;:</span>
<span class="gd">-    Keys.F1, &#39;\x1b[12~&#39;: Keys.F2, &#39;\x1b[13~&#39;: Keys.F3, &#39;\x1b[14~&#39;: Keys.F4,</span>
<span class="gd">-    &#39;\x1b[15~&#39;: Keys.F5, &#39;\x1b[17~&#39;: Keys.F6, &#39;\x1b[18~&#39;: Keys.F7,</span>
<span class="gd">-    &#39;\x1b[19~&#39;: Keys.F8, &#39;\x1b[20~&#39;: Keys.F9, &#39;\x1b[21~&#39;: Keys.F10,</span>
<span class="gd">-    &#39;\x1b[23~&#39;: Keys.F11, &#39;\x1b[24~&#39;: Keys.F12, &#39;\x1b[25~&#39;: Keys.F13,</span>
<span class="gd">-    &#39;\x1b[26~&#39;: Keys.F14, &#39;\x1b[28~&#39;: Keys.F15, &#39;\x1b[29~&#39;: Keys.F16,</span>
<span class="gd">-    &#39;\x1b[31~&#39;: Keys.F17, &#39;\x1b[32~&#39;: Keys.F18, &#39;\x1b[33~&#39;: Keys.F19,</span>
<span class="gd">-    &#39;\x1b[34~&#39;: Keys.F20, &#39;\x1b[1;2P&#39;: Keys.F13, &#39;\x1b[1;2Q&#39;: Keys.F14,</span>
<span class="gd">-    &#39;\x1b[1;2S&#39;: Keys.F16, &#39;\x1b[15;2~&#39;: Keys.F17, &#39;\x1b[17;2~&#39;: Keys.F18,</span>
<span class="gd">-    &#39;\x1b[18;2~&#39;: Keys.F19, &#39;\x1b[19;2~&#39;: Keys.F20, &#39;\x1b[20;2~&#39;: Keys.F21,</span>
<span class="gd">-    &#39;\x1b[21;2~&#39;: Keys.F22, &#39;\x1b[23;2~&#39;: Keys.F23, &#39;\x1b[24;2~&#39;: Keys.F24,</span>
<span class="gd">-    &#39;\x1b[27;2;13~&#39;: Keys.ControlM, &#39;\x1b[27;5;13~&#39;: Keys.ControlM,</span>
<span class="gd">-    &#39;\x1b[27;6;13~&#39;: Keys.ControlM, &#39;\x1b[1;5P&#39;: Keys.ControlF1,</span>
<span class="gd">-    &#39;\x1b[1;5Q&#39;: Keys.ControlF2, &#39;\x1b[1;5S&#39;: Keys.ControlF4, &#39;\x1b[15;5~&#39;:</span>
<span class="gd">-    Keys.ControlF5, &#39;\x1b[17;5~&#39;: Keys.ControlF6, &#39;\x1b[18;5~&#39;: Keys.</span>
<span class="gd">-    ControlF7, &#39;\x1b[19;5~&#39;: Keys.ControlF8, &#39;\x1b[20;5~&#39;: Keys.ControlF9,</span>
<span class="gd">-    &#39;\x1b[21;5~&#39;: Keys.ControlF10, &#39;\x1b[23;5~&#39;: Keys.ControlF11,</span>
<span class="gd">-    &#39;\x1b[24;5~&#39;: Keys.ControlF12, &#39;\x1b[1;6P&#39;: Keys.ControlF13,</span>
<span class="gd">-    &#39;\x1b[1;6Q&#39;: Keys.ControlF14, &#39;\x1b[1;6S&#39;: Keys.ControlF16,</span>
<span class="gd">-    &#39;\x1b[15;6~&#39;: Keys.ControlF17, &#39;\x1b[17;6~&#39;: Keys.ControlF18,</span>
<span class="gd">-    &#39;\x1b[18;6~&#39;: Keys.ControlF19, &#39;\x1b[19;6~&#39;: Keys.ControlF20,</span>
<span class="gd">-    &#39;\x1b[20;6~&#39;: Keys.ControlF21, &#39;\x1b[21;6~&#39;: Keys.ControlF22,</span>
<span class="gd">-    &#39;\x1b[23;6~&#39;: Keys.ControlF23, &#39;\x1b[24;6~&#39;: Keys.ControlF24,</span>
<span class="gd">-    &#39;\x1b[62~&#39;: Keys.ScrollUp, &#39;\x1b[63~&#39;: Keys.ScrollDown, &#39;\x1b[200~&#39;:</span>
<span class="gd">-    Keys.BracketedPaste, &#39;\x1b[E&#39;: Keys.Ignore, &#39;\x1b[G&#39;: Keys.Ignore,</span>
<span class="gd">-    &#39;\x1b[3;2~&#39;: Keys.ShiftDelete, &#39;\x1b[5;2~&#39;: Keys.ShiftPageUp,</span>
<span class="gd">-    &#39;\x1b[6;2~&#39;: Keys.ShiftPageDown, &#39;\x1b[2;3~&#39;: (Keys.Escape, Keys.Insert</span>
<span class="gd">-    ), &#39;\x1b[3;3~&#39;: (Keys.Escape, Keys.Delete), &#39;\x1b[5;3~&#39;: (Keys.Escape,</span>
<span class="gd">-    Keys.PageUp), &#39;\x1b[6;3~&#39;: (Keys.Escape, Keys.PageDown), &#39;\x1b[2;4~&#39;: (</span>
<span class="gd">-    Keys.Escape, Keys.ShiftInsert), &#39;\x1b[3;4~&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ShiftDelete), &#39;\x1b[5;4~&#39;: (Keys.Escape, Keys.ShiftPageUp), &#39;\x1b[6;4~&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ShiftPageDown), &#39;\x1b[3;5~&#39;: Keys.ControlDelete,</span>
<span class="gd">-    &#39;\x1b[5;5~&#39;: Keys.ControlPageUp, &#39;\x1b[6;5~&#39;: Keys.ControlPageDown,</span>
<span class="gd">-    &#39;\x1b[3;6~&#39;: Keys.ControlShiftDelete, &#39;\x1b[5;6~&#39;: Keys.</span>
<span class="gd">-    ControlShiftPageUp, &#39;\x1b[6;6~&#39;: Keys.ControlShiftPageDown, &#39;\x1b[2;7~&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ControlInsert), &#39;\x1b[5;7~&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlPageDown), &#39;\x1b[6;7~&#39;: (Keys.Escape, Keys.ControlPageDown),</span>
<span class="gd">-    &#39;\x1b[2;8~&#39;: (Keys.Escape, Keys.ControlShiftInsert), &#39;\x1b[5;8~&#39;: (Keys</span>
<span class="gd">-    .Escape, Keys.ControlShiftPageDown), &#39;\x1b[6;8~&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlShiftPageDown), &#39;\x1b[A&#39;: Keys.Up, &#39;\x1b[B&#39;: Keys.Down, &#39;\x1b[C&#39;:</span>
<span class="gd">-    Keys.Right, &#39;\x1b[D&#39;: Keys.Left, &#39;\x1b[H&#39;: Keys.Home, &#39;\x1b[F&#39;: Keys.</span>
<span class="gd">-    End, &#39;\x1bOA&#39;: Keys.Up, &#39;\x1bOB&#39;: Keys.Down, &#39;\x1bOC&#39;: Keys.Right,</span>
<span class="gd">-    &#39;\x1bOD&#39;: Keys.Left, &#39;\x1bOF&#39;: Keys.End, &#39;\x1bOH&#39;: Keys.Home,</span>
<span class="gd">-    &#39;\x1b[1;2A&#39;: Keys.ShiftUp, &#39;\x1b[1;2B&#39;: Keys.ShiftDown, &#39;\x1b[1;2C&#39;:</span>
<span class="gd">-    Keys.ShiftRight, &#39;\x1b[1;2D&#39;: Keys.ShiftLeft, &#39;\x1b[1;2F&#39;: Keys.</span>
<span class="gd">-    ShiftEnd, &#39;\x1b[1;2H&#39;: Keys.ShiftHome, &#39;\x1b[1;3A&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    Up), &#39;\x1b[1;3B&#39;: (Keys.Escape, Keys.Down), &#39;\x1b[1;3C&#39;: (Keys.Escape,</span>
<span class="gd">-    Keys.Right), &#39;\x1b[1;3D&#39;: (Keys.Escape, Keys.Left), &#39;\x1b[1;3F&#39;: (Keys.</span>
<span class="gd">-    Escape, Keys.End), &#39;\x1b[1;3H&#39;: (Keys.Escape, Keys.Home), &#39;\x1b[1;4A&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ShiftDown), &#39;\x1b[1;4B&#39;: (Keys.Escape, Keys.ShiftUp),</span>
<span class="gd">-    &#39;\x1b[1;4C&#39;: (Keys.Escape, Keys.ShiftRight), &#39;\x1b[1;4D&#39;: (Keys.Escape,</span>
<span class="gd">-    Keys.ShiftLeft), &#39;\x1b[1;4F&#39;: (Keys.Escape, Keys.ShiftEnd), &#39;\x1b[1;4H&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ShiftHome), &#39;\x1b[1;5A&#39;: Keys.ControlUp, &#39;\x1b[1;5B&#39;:</span>
<span class="gd">-    Keys.ControlDown, &#39;\x1b[1;5C&#39;: Keys.ControlRight, &#39;\x1b[1;5D&#39;: Keys.</span>
<span class="gd">-    ControlLeft, &#39;\x1b[1;5F&#39;: Keys.ControlEnd, &#39;\x1b[1;5H&#39;: Keys.</span>
<span class="gd">-    ControlHome, &#39;\x1b[5A&#39;: Keys.ControlUp, &#39;\x1b[5B&#39;: Keys.ControlDown,</span>
<span class="gd">-    &#39;\x1b[5C&#39;: Keys.ControlRight, &#39;\x1b[5D&#39;: Keys.ControlLeft, &#39;\x1bOc&#39;:</span>
<span class="gd">-    Keys.ControlRight, &#39;\x1bOd&#39;: Keys.ControlLeft, &#39;\x1b[1;6A&#39;: Keys.</span>
<span class="gd">-    ControlShiftDown, &#39;\x1b[1;6B&#39;: Keys.ControlShiftUp, &#39;\x1b[1;6C&#39;: Keys.</span>
<span class="gd">-    ControlShiftRight, &#39;\x1b[1;6D&#39;: Keys.ControlShiftLeft, &#39;\x1b[1;6F&#39;:</span>
<span class="gd">-    Keys.ControlShiftEnd, &#39;\x1b[1;6H&#39;: Keys.ControlShiftHome, &#39;\x1b[1;7A&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ControlDown), &#39;\x1b[1;7B&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlUp), &#39;\x1b[1;7C&#39;: (Keys.Escape, Keys.ControlRight), &#39;\x1b[1;7D&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ControlLeft), &#39;\x1b[1;7F&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlEnd), &#39;\x1b[1;7H&#39;: (Keys.Escape, Keys.ControlHome), &#39;\x1b[1;8A&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ControlShiftDown), &#39;\x1b[1;8B&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlShiftUp), &#39;\x1b[1;8C&#39;: (Keys.Escape, Keys.ControlShiftRight),</span>
<span class="gd">-    &#39;\x1b[1;8D&#39;: (Keys.Escape, Keys.ControlShiftLeft), &#39;\x1b[1;8F&#39;: (Keys.</span>
<span class="gd">-    Escape, Keys.ControlShiftEnd), &#39;\x1b[1;8H&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlShiftHome), &#39;\x1b[1;9A&#39;: (Keys.Escape, Keys.Up), &#39;\x1b[1;9B&#39;: (</span>
<span class="gd">-    Keys.Escape, Keys.Down), &#39;\x1b[1;9C&#39;: (Keys.Escape, Keys.Right),</span>
<span class="gd">-    &#39;\x1b[1;9D&#39;: (Keys.Escape, Keys.Left), &#39;\x1b[1;5p&#39;: Keys.Control0,</span>
<span class="gd">-    &#39;\x1b[1;5q&#39;: Keys.Control1, &#39;\x1b[1;5r&#39;: Keys.Control2, &#39;\x1b[1;5s&#39;:</span>
<span class="gd">-    Keys.Control3, &#39;\x1b[1;5t&#39;: Keys.Control4, &#39;\x1b[1;5u&#39;: Keys.Control5,</span>
<span class="gd">-    &#39;\x1b[1;5v&#39;: Keys.Control6, &#39;\x1b[1;5w&#39;: Keys.Control7, &#39;\x1b[1;5x&#39;:</span>
<span class="gd">-    Keys.Control8, &#39;\x1b[1;5y&#39;: Keys.Control9, &#39;\x1b[1;6p&#39;: Keys.</span>
<span class="gd">-    ControlShift0, &#39;\x1b[1;6q&#39;: Keys.ControlShift1, &#39;\x1b[1;6r&#39;: Keys.</span>
<span class="gd">-    ControlShift2, &#39;\x1b[1;6s&#39;: Keys.ControlShift3, &#39;\x1b[1;6t&#39;: Keys.</span>
<span class="gd">-    ControlShift4, &#39;\x1b[1;6u&#39;: Keys.ControlShift5, &#39;\x1b[1;6v&#39;: Keys.</span>
<span class="gd">-    ControlShift6, &#39;\x1b[1;6w&#39;: Keys.ControlShift7, &#39;\x1b[1;6x&#39;: Keys.</span>
<span class="gd">-    ControlShift8, &#39;\x1b[1;6y&#39;: Keys.ControlShift9, &#39;\x1b[1;7p&#39;: (Keys.</span>
<span class="gd">-    Escape, Keys.Control0), &#39;\x1b[1;7q&#39;: (Keys.Escape, Keys.Control1),</span>
<span class="gd">-    &#39;\x1b[1;7r&#39;: (Keys.Escape, Keys.Control2), &#39;\x1b[1;7s&#39;: (Keys.Escape,</span>
<span class="gd">-    Keys.Control3), &#39;\x1b[1;7t&#39;: (Keys.Escape, Keys.Control4), &#39;\x1b[1;7u&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.Control5), &#39;\x1b[1;7v&#39;: (Keys.Escape, Keys.Control6),</span>
<span class="gd">-    &#39;\x1b[1;7w&#39;: (Keys.Escape, Keys.Control7), &#39;\x1b[1;7x&#39;: (Keys.Escape,</span>
<span class="gd">-    Keys.Control8), &#39;\x1b[1;7y&#39;: (Keys.Escape, Keys.Control9), &#39;\x1b[1;8p&#39;:</span>
<span class="gd">-    (Keys.Escape, Keys.ControlShift0), &#39;\x1b[1;8q&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlShift1), &#39;\x1b[1;8r&#39;: (Keys.Escape, Keys.ControlShift2),</span>
<span class="gd">-    &#39;\x1b[1;8s&#39;: (Keys.Escape, Keys.ControlShift3), &#39;\x1b[1;8t&#39;: (Keys.</span>
<span class="gd">-    Escape, Keys.ControlShift4), &#39;\x1b[1;8u&#39;: (Keys.Escape, Keys.</span>
<span class="gd">-    ControlShift5), &#39;\x1b[1;8v&#39;: (Keys.Escape, Keys.ControlShift6),</span>
<span class="gd">-    &#39;\x1b[1;8w&#39;: (Keys.Escape, Keys.ControlShift7), &#39;\x1b[1;8x&#39;: (Keys.</span>
<span class="gd">-    Escape, Keys.ControlShift8), &#39;\x1b[1;8y&#39;: (Keys.Escape, Keys.ControlShift9)</span>
<span class="gd">-    }</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ANSI_SEQUENCES&quot;,</span>
<span class="gi">+    &quot;REVERSE_ANSI_SEQUENCES&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Mapping of vt100 escape codes to Keys.</span>
<span class="gi">+ANSI_SEQUENCES: dict[str, Keys | tuple[Keys, ...]] = {</span>
<span class="gi">+    # Control keys.</span>
<span class="gi">+    &quot;\x00&quot;: Keys.ControlAt,  # Control-At (Also for Ctrl-Space)</span>
<span class="gi">+    &quot;\x01&quot;: Keys.ControlA,  # Control-A (home)</span>
<span class="gi">+    &quot;\x02&quot;: Keys.ControlB,  # Control-B (emacs cursor left)</span>
<span class="gi">+    &quot;\x03&quot;: Keys.ControlC,  # Control-C (interrupt)</span>
<span class="gi">+    &quot;\x04&quot;: Keys.ControlD,  # Control-D (exit)</span>
<span class="gi">+    &quot;\x05&quot;: Keys.ControlE,  # Control-E (end)</span>
<span class="gi">+    &quot;\x06&quot;: Keys.ControlF,  # Control-F (cursor forward)</span>
<span class="gi">+    &quot;\x07&quot;: Keys.ControlG,  # Control-G</span>
<span class="gi">+    &quot;\x08&quot;: Keys.ControlH,  # Control-H (8) (Identical to &#39;\b&#39;)</span>
<span class="gi">+    &quot;\x09&quot;: Keys.ControlI,  # Control-I (9) (Identical to &#39;\t&#39;)</span>
<span class="gi">+    &quot;\x0a&quot;: Keys.ControlJ,  # Control-J (10) (Identical to &#39;\n&#39;)</span>
<span class="gi">+    &quot;\x0b&quot;: Keys.ControlK,  # Control-K (delete until end of line; vertical tab)</span>
<span class="gi">+    &quot;\x0c&quot;: Keys.ControlL,  # Control-L (clear; form feed)</span>
<span class="gi">+    &quot;\x0d&quot;: Keys.ControlM,  # Control-M (13) (Identical to &#39;\r&#39;)</span>
<span class="gi">+    &quot;\x0e&quot;: Keys.ControlN,  # Control-N (14) (history forward)</span>
<span class="gi">+    &quot;\x0f&quot;: Keys.ControlO,  # Control-O (15)</span>
<span class="gi">+    &quot;\x10&quot;: Keys.ControlP,  # Control-P (16) (history back)</span>
<span class="gi">+    &quot;\x11&quot;: Keys.ControlQ,  # Control-Q</span>
<span class="gi">+    &quot;\x12&quot;: Keys.ControlR,  # Control-R (18) (reverse search)</span>
<span class="gi">+    &quot;\x13&quot;: Keys.ControlS,  # Control-S (19) (forward search)</span>
<span class="gi">+    &quot;\x14&quot;: Keys.ControlT,  # Control-T</span>
<span class="gi">+    &quot;\x15&quot;: Keys.ControlU,  # Control-U</span>
<span class="gi">+    &quot;\x16&quot;: Keys.ControlV,  # Control-V</span>
<span class="gi">+    &quot;\x17&quot;: Keys.ControlW,  # Control-W</span>
<span class="gi">+    &quot;\x18&quot;: Keys.ControlX,  # Control-X</span>
<span class="gi">+    &quot;\x19&quot;: Keys.ControlY,  # Control-Y (25)</span>
<span class="gi">+    &quot;\x1a&quot;: Keys.ControlZ,  # Control-Z</span>
<span class="gi">+    &quot;\x1b&quot;: Keys.Escape,  # Also Control-[</span>
<span class="gi">+    &quot;\x9b&quot;: Keys.ShiftEscape,</span>
<span class="gi">+    &quot;\x1c&quot;: Keys.ControlBackslash,  # Both Control-\ (also Ctrl-| )</span>
<span class="gi">+    &quot;\x1d&quot;: Keys.ControlSquareClose,  # Control-]</span>
<span class="gi">+    &quot;\x1e&quot;: Keys.ControlCircumflex,  # Control-^</span>
<span class="gi">+    &quot;\x1f&quot;: Keys.ControlUnderscore,  # Control-underscore (Also for Ctrl-hyphen.)</span>
<span class="gi">+    # ASCII Delete (0x7f)</span>
<span class="gi">+    # Vt220 (and Linux terminal) send this when pressing backspace. We map this</span>
<span class="gi">+    # to ControlH, because that will make it easier to create key bindings that</span>
<span class="gi">+    # work everywhere, with the trade-off that it&#39;s no longer possible to</span>
<span class="gi">+    # handle backspace and control-h individually for the few terminals that</span>
<span class="gi">+    # support it. (Most terminals send ControlH when backspace is pressed.)</span>
<span class="gi">+    # See: http://www.ibb.net/~anne/keyboard.html</span>
<span class="gi">+    &quot;\x7f&quot;: Keys.ControlH,</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Various</span>
<span class="gi">+    &quot;\x1b[1~&quot;: Keys.Home,  # tmux</span>
<span class="gi">+    &quot;\x1b[2~&quot;: Keys.Insert,</span>
<span class="gi">+    &quot;\x1b[3~&quot;: Keys.Delete,</span>
<span class="gi">+    &quot;\x1b[4~&quot;: Keys.End,  # tmux</span>
<span class="gi">+    &quot;\x1b[5~&quot;: Keys.PageUp,</span>
<span class="gi">+    &quot;\x1b[6~&quot;: Keys.PageDown,</span>
<span class="gi">+    &quot;\x1b[7~&quot;: Keys.Home,  # xrvt</span>
<span class="gi">+    &quot;\x1b[8~&quot;: Keys.End,  # xrvt</span>
<span class="gi">+    &quot;\x1b[Z&quot;: Keys.BackTab,  # shift + tab</span>
<span class="gi">+    &quot;\x1b\x09&quot;: Keys.BackTab,  # Linux console</span>
<span class="gi">+    &quot;\x1b[~&quot;: Keys.BackTab,  # Windows console</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Function keys.</span>
<span class="gi">+    &quot;\x1bOP&quot;: Keys.F1,</span>
<span class="gi">+    &quot;\x1bOQ&quot;: Keys.F2,</span>
<span class="gi">+    &quot;\x1bOR&quot;: Keys.F3,</span>
<span class="gi">+    &quot;\x1bOS&quot;: Keys.F4,</span>
<span class="gi">+    &quot;\x1b[[A&quot;: Keys.F1,  # Linux console.</span>
<span class="gi">+    &quot;\x1b[[B&quot;: Keys.F2,  # Linux console.</span>
<span class="gi">+    &quot;\x1b[[C&quot;: Keys.F3,  # Linux console.</span>
<span class="gi">+    &quot;\x1b[[D&quot;: Keys.F4,  # Linux console.</span>
<span class="gi">+    &quot;\x1b[[E&quot;: Keys.F5,  # Linux console.</span>
<span class="gi">+    &quot;\x1b[11~&quot;: Keys.F1,  # rxvt-unicode</span>
<span class="gi">+    &quot;\x1b[12~&quot;: Keys.F2,  # rxvt-unicode</span>
<span class="gi">+    &quot;\x1b[13~&quot;: Keys.F3,  # rxvt-unicode</span>
<span class="gi">+    &quot;\x1b[14~&quot;: Keys.F4,  # rxvt-unicode</span>
<span class="gi">+    &quot;\x1b[15~&quot;: Keys.F5,</span>
<span class="gi">+    &quot;\x1b[17~&quot;: Keys.F6,</span>
<span class="gi">+    &quot;\x1b[18~&quot;: Keys.F7,</span>
<span class="gi">+    &quot;\x1b[19~&quot;: Keys.F8,</span>
<span class="gi">+    &quot;\x1b[20~&quot;: Keys.F9,</span>
<span class="gi">+    &quot;\x1b[21~&quot;: Keys.F10,</span>
<span class="gi">+    &quot;\x1b[23~&quot;: Keys.F11,</span>
<span class="gi">+    &quot;\x1b[24~&quot;: Keys.F12,</span>
<span class="gi">+    &quot;\x1b[25~&quot;: Keys.F13,</span>
<span class="gi">+    &quot;\x1b[26~&quot;: Keys.F14,</span>
<span class="gi">+    &quot;\x1b[28~&quot;: Keys.F15,</span>
<span class="gi">+    &quot;\x1b[29~&quot;: Keys.F16,</span>
<span class="gi">+    &quot;\x1b[31~&quot;: Keys.F17,</span>
<span class="gi">+    &quot;\x1b[32~&quot;: Keys.F18,</span>
<span class="gi">+    &quot;\x1b[33~&quot;: Keys.F19,</span>
<span class="gi">+    &quot;\x1b[34~&quot;: Keys.F20,</span>
<span class="gi">+    # Xterm</span>
<span class="gi">+    &quot;\x1b[1;2P&quot;: Keys.F13,</span>
<span class="gi">+    &quot;\x1b[1;2Q&quot;: Keys.F14,</span>
<span class="gi">+    # &#39;\x1b[1;2R&#39;: Keys.F15,  # Conflicts with CPR response.</span>
<span class="gi">+    &quot;\x1b[1;2S&quot;: Keys.F16,</span>
<span class="gi">+    &quot;\x1b[15;2~&quot;: Keys.F17,</span>
<span class="gi">+    &quot;\x1b[17;2~&quot;: Keys.F18,</span>
<span class="gi">+    &quot;\x1b[18;2~&quot;: Keys.F19,</span>
<span class="gi">+    &quot;\x1b[19;2~&quot;: Keys.F20,</span>
<span class="gi">+    &quot;\x1b[20;2~&quot;: Keys.F21,</span>
<span class="gi">+    &quot;\x1b[21;2~&quot;: Keys.F22,</span>
<span class="gi">+    &quot;\x1b[23;2~&quot;: Keys.F23,</span>
<span class="gi">+    &quot;\x1b[24;2~&quot;: Keys.F24,</span>
<span class="gi">+    # --</span>
<span class="gi">+    # CSI 27 disambiguated modified &quot;other&quot; keys (xterm)</span>
<span class="gi">+    # Ref: https://invisible-island.net/xterm/modified-keys.html</span>
<span class="gi">+    # These are currently unsupported, so just re-map some common ones to the</span>
<span class="gi">+    # unmodified versions</span>
<span class="gi">+    &quot;\x1b[27;2;13~&quot;: Keys.ControlM,  # Shift + Enter</span>
<span class="gi">+    &quot;\x1b[27;5;13~&quot;: Keys.ControlM,  # Ctrl + Enter</span>
<span class="gi">+    &quot;\x1b[27;6;13~&quot;: Keys.ControlM,  # Ctrl + Shift + Enter</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Control + function keys.</span>
<span class="gi">+    &quot;\x1b[1;5P&quot;: Keys.ControlF1,</span>
<span class="gi">+    &quot;\x1b[1;5Q&quot;: Keys.ControlF2,</span>
<span class="gi">+    # &quot;\x1b[1;5R&quot;: Keys.ControlF3,  # Conflicts with CPR response.</span>
<span class="gi">+    &quot;\x1b[1;5S&quot;: Keys.ControlF4,</span>
<span class="gi">+    &quot;\x1b[15;5~&quot;: Keys.ControlF5,</span>
<span class="gi">+    &quot;\x1b[17;5~&quot;: Keys.ControlF6,</span>
<span class="gi">+    &quot;\x1b[18;5~&quot;: Keys.ControlF7,</span>
<span class="gi">+    &quot;\x1b[19;5~&quot;: Keys.ControlF8,</span>
<span class="gi">+    &quot;\x1b[20;5~&quot;: Keys.ControlF9,</span>
<span class="gi">+    &quot;\x1b[21;5~&quot;: Keys.ControlF10,</span>
<span class="gi">+    &quot;\x1b[23;5~&quot;: Keys.ControlF11,</span>
<span class="gi">+    &quot;\x1b[24;5~&quot;: Keys.ControlF12,</span>
<span class="gi">+    &quot;\x1b[1;6P&quot;: Keys.ControlF13,</span>
<span class="gi">+    &quot;\x1b[1;6Q&quot;: Keys.ControlF14,</span>
<span class="gi">+    # &quot;\x1b[1;6R&quot;: Keys.ControlF15,  # Conflicts with CPR response.</span>
<span class="gi">+    &quot;\x1b[1;6S&quot;: Keys.ControlF16,</span>
<span class="gi">+    &quot;\x1b[15;6~&quot;: Keys.ControlF17,</span>
<span class="gi">+    &quot;\x1b[17;6~&quot;: Keys.ControlF18,</span>
<span class="gi">+    &quot;\x1b[18;6~&quot;: Keys.ControlF19,</span>
<span class="gi">+    &quot;\x1b[19;6~&quot;: Keys.ControlF20,</span>
<span class="gi">+    &quot;\x1b[20;6~&quot;: Keys.ControlF21,</span>
<span class="gi">+    &quot;\x1b[21;6~&quot;: Keys.ControlF22,</span>
<span class="gi">+    &quot;\x1b[23;6~&quot;: Keys.ControlF23,</span>
<span class="gi">+    &quot;\x1b[24;6~&quot;: Keys.ControlF24,</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Tmux (Win32 subsystem) sends the following scroll events.</span>
<span class="gi">+    &quot;\x1b[62~&quot;: Keys.ScrollUp,</span>
<span class="gi">+    &quot;\x1b[63~&quot;: Keys.ScrollDown,</span>
<span class="gi">+    &quot;\x1b[200~&quot;: Keys.BracketedPaste,  # Start of bracketed paste.</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Sequences generated by numpad 5. Not sure what it means. (It doesn&#39;t</span>
<span class="gi">+    # appear in &#39;infocmp&#39;. Just ignore.</span>
<span class="gi">+    &quot;\x1b[E&quot;: Keys.Ignore,  # Xterm.</span>
<span class="gi">+    &quot;\x1b[G&quot;: Keys.Ignore,  # Linux console.</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Meta/control/escape + pageup/pagedown/insert/delete.</span>
<span class="gi">+    &quot;\x1b[3;2~&quot;: Keys.ShiftDelete,  # xterm, gnome-terminal.</span>
<span class="gi">+    &quot;\x1b[5;2~&quot;: Keys.ShiftPageUp,</span>
<span class="gi">+    &quot;\x1b[6;2~&quot;: Keys.ShiftPageDown,</span>
<span class="gi">+    &quot;\x1b[2;3~&quot;: (Keys.Escape, Keys.Insert),</span>
<span class="gi">+    &quot;\x1b[3;3~&quot;: (Keys.Escape, Keys.Delete),</span>
<span class="gi">+    &quot;\x1b[5;3~&quot;: (Keys.Escape, Keys.PageUp),</span>
<span class="gi">+    &quot;\x1b[6;3~&quot;: (Keys.Escape, Keys.PageDown),</span>
<span class="gi">+    &quot;\x1b[2;4~&quot;: (Keys.Escape, Keys.ShiftInsert),</span>
<span class="gi">+    &quot;\x1b[3;4~&quot;: (Keys.Escape, Keys.ShiftDelete),</span>
<span class="gi">+    &quot;\x1b[5;4~&quot;: (Keys.Escape, Keys.ShiftPageUp),</span>
<span class="gi">+    &quot;\x1b[6;4~&quot;: (Keys.Escape, Keys.ShiftPageDown),</span>
<span class="gi">+    &quot;\x1b[3;5~&quot;: Keys.ControlDelete,  # xterm, gnome-terminal.</span>
<span class="gi">+    &quot;\x1b[5;5~&quot;: Keys.ControlPageUp,</span>
<span class="gi">+    &quot;\x1b[6;5~&quot;: Keys.ControlPageDown,</span>
<span class="gi">+    &quot;\x1b[3;6~&quot;: Keys.ControlShiftDelete,</span>
<span class="gi">+    &quot;\x1b[5;6~&quot;: Keys.ControlShiftPageUp,</span>
<span class="gi">+    &quot;\x1b[6;6~&quot;: Keys.ControlShiftPageDown,</span>
<span class="gi">+    &quot;\x1b[2;7~&quot;: (Keys.Escape, Keys.ControlInsert),</span>
<span class="gi">+    &quot;\x1b[5;7~&quot;: (Keys.Escape, Keys.ControlPageDown),</span>
<span class="gi">+    &quot;\x1b[6;7~&quot;: (Keys.Escape, Keys.ControlPageDown),</span>
<span class="gi">+    &quot;\x1b[2;8~&quot;: (Keys.Escape, Keys.ControlShiftInsert),</span>
<span class="gi">+    &quot;\x1b[5;8~&quot;: (Keys.Escape, Keys.ControlShiftPageDown),</span>
<span class="gi">+    &quot;\x1b[6;8~&quot;: (Keys.Escape, Keys.ControlShiftPageDown),</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Arrows.</span>
<span class="gi">+    # (Normal cursor mode).</span>
<span class="gi">+    &quot;\x1b[A&quot;: Keys.Up,</span>
<span class="gi">+    &quot;\x1b[B&quot;: Keys.Down,</span>
<span class="gi">+    &quot;\x1b[C&quot;: Keys.Right,</span>
<span class="gi">+    &quot;\x1b[D&quot;: Keys.Left,</span>
<span class="gi">+    &quot;\x1b[H&quot;: Keys.Home,</span>
<span class="gi">+    &quot;\x1b[F&quot;: Keys.End,</span>
<span class="gi">+    # Tmux sends following keystrokes when control+arrow is pressed, but for</span>
<span class="gi">+    # Emacs ansi-term sends the same sequences for normal arrow keys. Consider</span>
<span class="gi">+    # it a normal arrow press, because that&#39;s more important.</span>
<span class="gi">+    # (Application cursor mode).</span>
<span class="gi">+    &quot;\x1bOA&quot;: Keys.Up,</span>
<span class="gi">+    &quot;\x1bOB&quot;: Keys.Down,</span>
<span class="gi">+    &quot;\x1bOC&quot;: Keys.Right,</span>
<span class="gi">+    &quot;\x1bOD&quot;: Keys.Left,</span>
<span class="gi">+    &quot;\x1bOF&quot;: Keys.End,</span>
<span class="gi">+    &quot;\x1bOH&quot;: Keys.Home,</span>
<span class="gi">+    # Shift + arrows.</span>
<span class="gi">+    &quot;\x1b[1;2A&quot;: Keys.ShiftUp,</span>
<span class="gi">+    &quot;\x1b[1;2B&quot;: Keys.ShiftDown,</span>
<span class="gi">+    &quot;\x1b[1;2C&quot;: Keys.ShiftRight,</span>
<span class="gi">+    &quot;\x1b[1;2D&quot;: Keys.ShiftLeft,</span>
<span class="gi">+    &quot;\x1b[1;2F&quot;: Keys.ShiftEnd,</span>
<span class="gi">+    &quot;\x1b[1;2H&quot;: Keys.ShiftHome,</span>
<span class="gi">+    # Meta + arrow keys. Several terminals handle this differently.</span>
<span class="gi">+    # The following sequences are for xterm and gnome-terminal.</span>
<span class="gi">+    #     (Iterm sends ESC followed by the normal arrow_up/down/left/right</span>
<span class="gi">+    #     sequences, and the OSX Terminal sends ESCb and ESCf for &quot;alt</span>
<span class="gi">+    #     arrow_left&quot; and &quot;alt arrow_right.&quot; We don&#39;t handle these</span>
<span class="gi">+    #     explicitly, in here, because would could not distinguish between</span>
<span class="gi">+    #     pressing ESC (to go to Vi navigation mode), followed by just the</span>
<span class="gi">+    #     &#39;b&#39; or &#39;f&#39; key. These combinations are handled in</span>
<span class="gi">+    #     the input processor.)</span>
<span class="gi">+    &quot;\x1b[1;3A&quot;: (Keys.Escape, Keys.Up),</span>
<span class="gi">+    &quot;\x1b[1;3B&quot;: (Keys.Escape, Keys.Down),</span>
<span class="gi">+    &quot;\x1b[1;3C&quot;: (Keys.Escape, Keys.Right),</span>
<span class="gi">+    &quot;\x1b[1;3D&quot;: (Keys.Escape, Keys.Left),</span>
<span class="gi">+    &quot;\x1b[1;3F&quot;: (Keys.Escape, Keys.End),</span>
<span class="gi">+    &quot;\x1b[1;3H&quot;: (Keys.Escape, Keys.Home),</span>
<span class="gi">+    # Alt+shift+number.</span>
<span class="gi">+    &quot;\x1b[1;4A&quot;: (Keys.Escape, Keys.ShiftDown),</span>
<span class="gi">+    &quot;\x1b[1;4B&quot;: (Keys.Escape, Keys.ShiftUp),</span>
<span class="gi">+    &quot;\x1b[1;4C&quot;: (Keys.Escape, Keys.ShiftRight),</span>
<span class="gi">+    &quot;\x1b[1;4D&quot;: (Keys.Escape, Keys.ShiftLeft),</span>
<span class="gi">+    &quot;\x1b[1;4F&quot;: (Keys.Escape, Keys.ShiftEnd),</span>
<span class="gi">+    &quot;\x1b[1;4H&quot;: (Keys.Escape, Keys.ShiftHome),</span>
<span class="gi">+    # Control + arrows.</span>
<span class="gi">+    &quot;\x1b[1;5A&quot;: Keys.ControlUp,  # Cursor Mode</span>
<span class="gi">+    &quot;\x1b[1;5B&quot;: Keys.ControlDown,  # Cursor Mode</span>
<span class="gi">+    &quot;\x1b[1;5C&quot;: Keys.ControlRight,  # Cursor Mode</span>
<span class="gi">+    &quot;\x1b[1;5D&quot;: Keys.ControlLeft,  # Cursor Mode</span>
<span class="gi">+    &quot;\x1b[1;5F&quot;: Keys.ControlEnd,</span>
<span class="gi">+    &quot;\x1b[1;5H&quot;: Keys.ControlHome,</span>
<span class="gi">+    # Tmux sends following keystrokes when control+arrow is pressed, but for</span>
<span class="gi">+    # Emacs ansi-term sends the same sequences for normal arrow keys. Consider</span>
<span class="gi">+    # it a normal arrow press, because that&#39;s more important.</span>
<span class="gi">+    &quot;\x1b[5A&quot;: Keys.ControlUp,</span>
<span class="gi">+    &quot;\x1b[5B&quot;: Keys.ControlDown,</span>
<span class="gi">+    &quot;\x1b[5C&quot;: Keys.ControlRight,</span>
<span class="gi">+    &quot;\x1b[5D&quot;: Keys.ControlLeft,</span>
<span class="gi">+    &quot;\x1bOc&quot;: Keys.ControlRight,  # rxvt</span>
<span class="gi">+    &quot;\x1bOd&quot;: Keys.ControlLeft,  # rxvt</span>
<span class="gi">+    # Control + shift + arrows.</span>
<span class="gi">+    &quot;\x1b[1;6A&quot;: Keys.ControlShiftDown,</span>
<span class="gi">+    &quot;\x1b[1;6B&quot;: Keys.ControlShiftUp,</span>
<span class="gi">+    &quot;\x1b[1;6C&quot;: Keys.ControlShiftRight,</span>
<span class="gi">+    &quot;\x1b[1;6D&quot;: Keys.ControlShiftLeft,</span>
<span class="gi">+    &quot;\x1b[1;6F&quot;: Keys.ControlShiftEnd,</span>
<span class="gi">+    &quot;\x1b[1;6H&quot;: Keys.ControlShiftHome,</span>
<span class="gi">+    # Control + Meta + arrows.</span>
<span class="gi">+    &quot;\x1b[1;7A&quot;: (Keys.Escape, Keys.ControlDown),</span>
<span class="gi">+    &quot;\x1b[1;7B&quot;: (Keys.Escape, Keys.ControlUp),</span>
<span class="gi">+    &quot;\x1b[1;7C&quot;: (Keys.Escape, Keys.ControlRight),</span>
<span class="gi">+    &quot;\x1b[1;7D&quot;: (Keys.Escape, Keys.ControlLeft),</span>
<span class="gi">+    &quot;\x1b[1;7F&quot;: (Keys.Escape, Keys.ControlEnd),</span>
<span class="gi">+    &quot;\x1b[1;7H&quot;: (Keys.Escape, Keys.ControlHome),</span>
<span class="gi">+    # Meta + Shift + arrows.</span>
<span class="gi">+    &quot;\x1b[1;8A&quot;: (Keys.Escape, Keys.ControlShiftDown),</span>
<span class="gi">+    &quot;\x1b[1;8B&quot;: (Keys.Escape, Keys.ControlShiftUp),</span>
<span class="gi">+    &quot;\x1b[1;8C&quot;: (Keys.Escape, Keys.ControlShiftRight),</span>
<span class="gi">+    &quot;\x1b[1;8D&quot;: (Keys.Escape, Keys.ControlShiftLeft),</span>
<span class="gi">+    &quot;\x1b[1;8F&quot;: (Keys.Escape, Keys.ControlShiftEnd),</span>
<span class="gi">+    &quot;\x1b[1;8H&quot;: (Keys.Escape, Keys.ControlShiftHome),</span>
<span class="gi">+    # Meta + arrow on (some?) Macs when using iTerm defaults (see issue #483).</span>
<span class="gi">+    &quot;\x1b[1;9A&quot;: (Keys.Escape, Keys.Up),</span>
<span class="gi">+    &quot;\x1b[1;9B&quot;: (Keys.Escape, Keys.Down),</span>
<span class="gi">+    &quot;\x1b[1;9C&quot;: (Keys.Escape, Keys.Right),</span>
<span class="gi">+    &quot;\x1b[1;9D&quot;: (Keys.Escape, Keys.Left),</span>
<span class="gi">+    # --</span>
<span class="gi">+    # Control/shift/meta + number in mintty.</span>
<span class="gi">+    # (c-2 will actually send c-@ and c-6 will send c-^.)</span>
<span class="gi">+    &quot;\x1b[1;5p&quot;: Keys.Control0,</span>
<span class="gi">+    &quot;\x1b[1;5q&quot;: Keys.Control1,</span>
<span class="gi">+    &quot;\x1b[1;5r&quot;: Keys.Control2,</span>
<span class="gi">+    &quot;\x1b[1;5s&quot;: Keys.Control3,</span>
<span class="gi">+    &quot;\x1b[1;5t&quot;: Keys.Control4,</span>
<span class="gi">+    &quot;\x1b[1;5u&quot;: Keys.Control5,</span>
<span class="gi">+    &quot;\x1b[1;5v&quot;: Keys.Control6,</span>
<span class="gi">+    &quot;\x1b[1;5w&quot;: Keys.Control7,</span>
<span class="gi">+    &quot;\x1b[1;5x&quot;: Keys.Control8,</span>
<span class="gi">+    &quot;\x1b[1;5y&quot;: Keys.Control9,</span>
<span class="gi">+    &quot;\x1b[1;6p&quot;: Keys.ControlShift0,</span>
<span class="gi">+    &quot;\x1b[1;6q&quot;: Keys.ControlShift1,</span>
<span class="gi">+    &quot;\x1b[1;6r&quot;: Keys.ControlShift2,</span>
<span class="gi">+    &quot;\x1b[1;6s&quot;: Keys.ControlShift3,</span>
<span class="gi">+    &quot;\x1b[1;6t&quot;: Keys.ControlShift4,</span>
<span class="gi">+    &quot;\x1b[1;6u&quot;: Keys.ControlShift5,</span>
<span class="gi">+    &quot;\x1b[1;6v&quot;: Keys.ControlShift6,</span>
<span class="gi">+    &quot;\x1b[1;6w&quot;: Keys.ControlShift7,</span>
<span class="gi">+    &quot;\x1b[1;6x&quot;: Keys.ControlShift8,</span>
<span class="gi">+    &quot;\x1b[1;6y&quot;: Keys.ControlShift9,</span>
<span class="gi">+    &quot;\x1b[1;7p&quot;: (Keys.Escape, Keys.Control0),</span>
<span class="gi">+    &quot;\x1b[1;7q&quot;: (Keys.Escape, Keys.Control1),</span>
<span class="gi">+    &quot;\x1b[1;7r&quot;: (Keys.Escape, Keys.Control2),</span>
<span class="gi">+    &quot;\x1b[1;7s&quot;: (Keys.Escape, Keys.Control3),</span>
<span class="gi">+    &quot;\x1b[1;7t&quot;: (Keys.Escape, Keys.Control4),</span>
<span class="gi">+    &quot;\x1b[1;7u&quot;: (Keys.Escape, Keys.Control5),</span>
<span class="gi">+    &quot;\x1b[1;7v&quot;: (Keys.Escape, Keys.Control6),</span>
<span class="gi">+    &quot;\x1b[1;7w&quot;: (Keys.Escape, Keys.Control7),</span>
<span class="gi">+    &quot;\x1b[1;7x&quot;: (Keys.Escape, Keys.Control8),</span>
<span class="gi">+    &quot;\x1b[1;7y&quot;: (Keys.Escape, Keys.Control9),</span>
<span class="gi">+    &quot;\x1b[1;8p&quot;: (Keys.Escape, Keys.ControlShift0),</span>
<span class="gi">+    &quot;\x1b[1;8q&quot;: (Keys.Escape, Keys.ControlShift1),</span>
<span class="gi">+    &quot;\x1b[1;8r&quot;: (Keys.Escape, Keys.ControlShift2),</span>
<span class="gi">+    &quot;\x1b[1;8s&quot;: (Keys.Escape, Keys.ControlShift3),</span>
<span class="gi">+    &quot;\x1b[1;8t&quot;: (Keys.Escape, Keys.ControlShift4),</span>
<span class="gi">+    &quot;\x1b[1;8u&quot;: (Keys.Escape, Keys.ControlShift5),</span>
<span class="gi">+    &quot;\x1b[1;8v&quot;: (Keys.Escape, Keys.ControlShift6),</span>
<span class="gi">+    &quot;\x1b[1;8w&quot;: (Keys.Escape, Keys.ControlShift7),</span>
<span class="gi">+    &quot;\x1b[1;8x&quot;: (Keys.Escape, Keys.ControlShift8),</span>
<span class="gi">+    &quot;\x1b[1;8y&quot;: (Keys.Escape, Keys.ControlShift9),</span>
<span class="gi">+}</span>


<span class="gd">-def _get_reverse_ansi_sequences() -&gt;dict[Keys, str]:</span>
<span class="gi">+def _get_reverse_ansi_sequences() -&gt; dict[Keys, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a dictionary that maps prompt_toolkit keys back to the VT100 escape
<span class="w"> </span>    sequences.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: dict[Keys, str] = {}</span>
<span class="gi">+</span>
<span class="gi">+    for sequence, key in ANSI_SEQUENCES.items():</span>
<span class="gi">+        if not isinstance(key, tuple):</span>
<span class="gi">+            if key not in result:</span>
<span class="gi">+                result[key] = sequence</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>REVERSE_ANSI_SEQUENCES = _get_reverse_ansi_sequences()
<span class="gh">diff --git a/src/prompt_toolkit/input/base.py b/src/prompt_toolkit/input/base.py</span>
<span class="gh">index 208e9d1f..fd1429df 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/base.py</span>
<span class="gu">@@ -2,11 +2,18 @@</span>
<span class="w"> </span>Abstraction of CLI Input.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod, abstractproperty
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from typing import Callable, ContextManager, Generator
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.key_binding import KeyPress
<span class="gd">-__all__ = [&#39;Input&#39;, &#39;PipeInput&#39;, &#39;DummyInput&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Input&quot;,</span>
<span class="gi">+    &quot;PipeInput&quot;,</span>
<span class="gi">+    &quot;DummyInput&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Input(metaclass=ABCMeta):
<span class="gu">@@ -19,75 +26,67 @@ class Input(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fileno for putting this in an event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def typeahead_hash(self) -&gt;str:</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Identifier for storing type ahead key presses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def read_keys(self) -&gt;list[KeyPress]:</span>
<span class="gi">+    def read_keys(self) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of Key objects which are read/parsed from the input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def flush_keys(self) -&gt;list[KeyPress]:</span>
<span class="gi">+    def flush_keys(self) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush the underlying parser. and return the pending keys.
<span class="w"> </span>        (Used for vt100 input.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;The event loop can call this when the input has to be flushed.&quot;&quot;&quot;</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        &quot;The event loop can call this when the input has to be flushed.&quot;</span>
<span class="w"> </span>        pass

<span class="w"> </span>    @abstractproperty
<span class="gd">-    def closed(self) -&gt;bool:</span>
<span class="gd">-        &quot;&quot;&quot;Should be true when the input stream is closed.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="gi">+        &quot;Should be true when the input stream is closed.&quot;</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def raw_mode(self) -&gt;ContextManager[None]:</span>
<span class="gi">+    def raw_mode(self) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Context manager that turns the input into raw mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def cooked_mode(self) -&gt;ContextManager[None]:</span>
<span class="gi">+    def cooked_mode(self) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Context manager that turns the input into cooked mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def attach(self, input_ready_callback: Callable[[], None]</span>
<span class="gd">-        ) -&gt;ContextManager[None]:</span>
<span class="gi">+    def attach(self, input_ready_callback: Callable[[], None]) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def detach(self) -&gt;ContextManager[None]:</span>
<span class="gi">+    def detach(self) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close input.&quot;&quot;&quot;</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        &quot;Close input.&quot;</span>
<span class="w"> </span>        pass


<span class="gu">@@ -97,14 +96,12 @@ class PipeInput(Input):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def send_bytes(self, data: bytes) -&gt;None:</span>
<span class="gi">+    def send_bytes(self, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Feed byte string into the pipe&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def send_text(self, data: str) -&gt;None:</span>
<span class="gi">+    def send_text(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Feed a text string into the pipe&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class DummyInput(Input):
<span class="gu">@@ -114,3 +111,42 @@ class DummyInput(Input):</span>
<span class="w"> </span>    If used in an actual application, it will make the application render
<span class="w"> </span>    itself once and exit immediately, due to an `EOFError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="gi">+        return &quot;dummy-%s&quot; % id(self)</span>
<span class="gi">+</span>
<span class="gi">+    def read_keys(self) -&gt; list[KeyPress]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="gi">+        # This needs to be true, so that the dummy input will trigger an</span>
<span class="gi">+        # `EOFError` immediately in the application.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def raw_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return _dummy_context_manager()</span>
<span class="gi">+</span>
<span class="gi">+    def cooked_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return _dummy_context_manager()</span>
<span class="gi">+</span>
<span class="gi">+    def attach(self, input_ready_callback: Callable[[], None]) -&gt; ContextManager[None]:</span>
<span class="gi">+        # Call the callback immediately once after attaching.</span>
<span class="gi">+        # This tells the callback to call `read_keys` and check the</span>
<span class="gi">+        # `input.closed` flag, after which it won&#39;t receive any keys, but knows</span>
<span class="gi">+        # that `EOFError` should be raised. This unblocks `read_from_input` in</span>
<span class="gi">+        # `application.py`.</span>
<span class="gi">+        input_ready_callback()</span>
<span class="gi">+</span>
<span class="gi">+        return _dummy_context_manager()</span>
<span class="gi">+</span>
<span class="gi">+    def detach(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return _dummy_context_manager()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def _dummy_context_manager() -&gt; Generator[None, None, None]:</span>
<span class="gi">+    yield</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/defaults.py b/src/prompt_toolkit/input/defaults.py</span>
<span class="gh">index 43cd9c53..483eeb20 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/defaults.py</span>
<span class="gu">@@ -1,13 +1,18 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import io
<span class="w"> </span>import sys
<span class="w"> </span>from typing import ContextManager, TextIO
<span class="gi">+</span>
<span class="w"> </span>from .base import DummyInput, Input, PipeInput
<span class="gd">-__all__ = [&#39;create_input&#39;, &#39;create_pipe_input&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;create_input&quot;,</span>
<span class="gi">+    &quot;create_pipe_input&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def create_input(stdin: (TextIO | None)=None, always_prefer_tty: bool=False</span>
<span class="gd">-    ) -&gt;Input:</span>
<span class="gi">+def create_input(stdin: TextIO | None = None, always_prefer_tty: bool = False) -&gt; Input:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create the appropriate `Input` object for the current os/environment.

<span class="gu">@@ -17,10 +22,41 @@ def create_input(stdin: (TextIO | None)=None, always_prefer_tty: bool=False</span>
<span class="w"> </span>        `sys.stdin`. (We can open `stdout` or `stderr` for reading, this is how
<span class="w"> </span>        a `$PAGER` works.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        from .win32 import Win32Input</span>
<span class="gi">+</span>
<span class="gi">+        # If `stdin` was assigned `None` (which happens with pythonw.exe), use</span>
<span class="gi">+        # a `DummyInput`. This triggers `EOFError` in the application code.</span>
<span class="gi">+        if stdin is None and sys.stdin is None:</span>
<span class="gi">+            return DummyInput()</span>
<span class="gi">+</span>
<span class="gi">+        return Win32Input(stdin or sys.stdin)</span>
<span class="gi">+    else:</span>
<span class="gi">+        from .vt100 import Vt100Input</span>
<span class="gi">+</span>
<span class="gi">+        # If no input TextIO is given, use stdin/stdout.</span>
<span class="gi">+        if stdin is None:</span>
<span class="gi">+            stdin = sys.stdin</span>

<span class="gi">+            if always_prefer_tty:</span>
<span class="gi">+                for obj in [sys.stdin, sys.stdout, sys.stderr]:</span>
<span class="gi">+                    if obj.isatty():</span>
<span class="gi">+                        stdin = obj</span>
<span class="gi">+                        break</span>

<span class="gd">-def create_pipe_input() -&gt;ContextManager[PipeInput]:</span>
<span class="gi">+        # If we can&#39;t access the file descriptor for the selected stdin, return</span>
<span class="gi">+        # a `DummyInput` instead. This can happen for instance in unit tests,</span>
<span class="gi">+        # when `sys.stdin` is patched by something that&#39;s not an actual file.</span>
<span class="gi">+        # (Instantiating `Vt100Input` would fail in this case.)</span>
<span class="gi">+        try:</span>
<span class="gi">+            stdin.fileno()</span>
<span class="gi">+        except io.UnsupportedOperation:</span>
<span class="gi">+            return DummyInput()</span>
<span class="gi">+</span>
<span class="gi">+        return Vt100Input(stdin)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_pipe_input() -&gt; ContextManager[PipeInput]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create an input pipe.
<span class="w"> </span>    This is mostly useful for unit testing.
<span class="gu">@@ -33,4 +69,11 @@ def create_pipe_input() -&gt;ContextManager[PipeInput]:</span>
<span class="w"> </span>    Breaking change: In prompt_toolkit 3.0.28 and earlier, this was returning
<span class="w"> </span>    the `PipeInput` directly, rather than through a context manager.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        from .win32_pipe import Win32PipeInput</span>
<span class="gi">+</span>
<span class="gi">+        return Win32PipeInput.create()</span>
<span class="gi">+    else:</span>
<span class="gi">+        from .posix_pipe import PosixPipeInput</span>
<span class="gi">+</span>
<span class="gi">+        return PosixPipeInput.create()</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/posix_pipe.py b/src/prompt_toolkit/input/posix_pipe.py</span>
<span class="gh">index 33950c1e..c131fb81 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/posix_pipe.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/posix_pipe.py</span>
<span class="gu">@@ -1,34 +1,50 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform != &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform != &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from typing import ContextManager, Iterator, TextIO, cast
<span class="gi">+</span>
<span class="w"> </span>from ..utils import DummyContext
<span class="w"> </span>from .base import PipeInput
<span class="w"> </span>from .vt100 import Vt100Input
<span class="gd">-__all__ = [&#39;PosixPipeInput&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PosixPipeInput&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class _Pipe:
<span class="gd">-    &quot;&quot;&quot;Wrapper around os.pipe, that ensures we don&#39;t double close any end.&quot;&quot;&quot;</span>
<span class="gi">+    &quot;Wrapper around os.pipe, that ensures we don&#39;t double close any end.&quot;</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.read_fd, self.write_fd = os.pipe()
<span class="w"> </span>        self._read_closed = False
<span class="w"> </span>        self._write_closed = False

<span class="gd">-    def close_read(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close read-end if not yet closed.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def close_read(self) -&gt; None:</span>
<span class="gi">+        &quot;Close read-end if not yet closed.&quot;</span>
<span class="gi">+        if self._read_closed:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        os.close(self.read_fd)</span>
<span class="gi">+        self._read_closed = True</span>
<span class="gi">+</span>
<span class="gi">+    def close_write(self) -&gt; None:</span>
<span class="gi">+        &quot;Close write-end if not yet closed.&quot;</span>
<span class="gi">+        if self._write_closed:</span>
<span class="gi">+            return</span>

<span class="gd">-    def close_write(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close write-end if not yet closed.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        os.close(self.write_fd)</span>
<span class="gi">+        self._write_closed = True</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close both read and write ends.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        &quot;Close both read and write ends.&quot;</span>
<span class="gi">+        self.close_read()</span>
<span class="gi">+        self.close_write()</span>


<span class="w"> </span>class PosixPipeInput(Vt100Input, PipeInput):
<span class="gu">@@ -42,35 +58,61 @@ class PosixPipeInput(Vt100Input, PipeInput):</span>
<span class="w"> </span>        with PosixPipeInput.create() as input:
<span class="w"> </span>            input.send_text(&#39;inputdata&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _id = 0

<span class="gd">-    def __init__(self, _pipe: _Pipe, _text: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, _pipe: _Pipe, _text: str = &quot;&quot;) -&gt; None:</span>
<span class="gi">+        # Private constructor. Users should use the public `.create()` method.</span>
<span class="w"> </span>        self.pipe = _pipe

<span class="gd">-</span>
<span class="w"> </span>        class Stdin:
<span class="gd">-            encoding = &#39;utf-8&#39;</span>
<span class="gi">+            encoding = &quot;utf-8&quot;</span>

<span class="gd">-            def isatty(stdin) -&gt;bool:</span>
<span class="gi">+            def isatty(stdin) -&gt; bool:</span>
<span class="w"> </span>                return True

<span class="gd">-            def fileno(stdin) -&gt;int:</span>
<span class="gi">+            def fileno(stdin) -&gt; int:</span>
<span class="w"> </span>                return self.pipe.read_fd
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(cast(TextIO, Stdin()))
<span class="w"> </span>        self.send_text(_text)
<span class="gi">+</span>
<span class="gi">+        # Identifier for every PipeInput for the hash.</span>
<span class="w"> </span>        self.__class__._id += 1
<span class="w"> </span>        self._id = self.__class__._id

<span class="gd">-    def send_text(self, data: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Send text to the input.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close pipe fds.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def typeahead_hash(self) -&gt;str:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def create(cls, text: str = &quot;&quot;) -&gt; Iterator[PosixPipeInput]:</span>
<span class="gi">+        pipe = _Pipe()</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield PosixPipeInput(_pipe=pipe, _text=text)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            pipe.close()</span>
<span class="gi">+</span>
<span class="gi">+    def send_bytes(self, data: bytes) -&gt; None:</span>
<span class="gi">+        os.write(self.pipe.write_fd, data)</span>
<span class="gi">+</span>
<span class="gi">+    def send_text(self, data: str) -&gt; None:</span>
<span class="gi">+        &quot;Send text to the input.&quot;</span>
<span class="gi">+        os.write(self.pipe.write_fd, data.encode(&quot;utf-8&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def raw_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return DummyContext()</span>
<span class="gi">+</span>
<span class="gi">+    def cooked_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return DummyContext()</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        &quot;Close pipe fds.&quot;</span>
<span class="gi">+        # Only close the write-end of the pipe. This will unblock the reader</span>
<span class="gi">+        # callback (in vt100.py &gt; _attached_input), which eventually will raise</span>
<span class="gi">+        # `EOFError`. If we&#39;d also close the read-end, then the event loop</span>
<span class="gi">+        # won&#39;t wake up the corresponding callback because of this.</span>
<span class="gi">+        self.pipe.close_write()</span>
<span class="gi">+</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This needs to be unique for every `PipeInput`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;pipe-input-{self._id}&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/posix_utils.py b/src/prompt_toolkit/input/posix_utils.py</span>
<span class="gh">index 3e1d3ca4..4a78dc42 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/posix_utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/posix_utils.py</span>
<span class="gu">@@ -1,8 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import select
<span class="w"> </span>from codecs import getincrementaldecoder
<span class="gd">-__all__ = [&#39;PosixStdinReader&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PosixStdinReader&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class PosixStdinReader:
<span class="gu">@@ -27,15 +31,30 @@ class PosixStdinReader:</span>
<span class="w"> </span>        can be any possible byte.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stdin_fd: int, errors: str=&#39;surrogateescape&#39;,</span>
<span class="gd">-        encoding: str=&#39;utf-8&#39;) -&gt;None:</span>
<span class="gi">+    # By default, we want to &#39;ignore&#39; errors here. The input stream can be full</span>
<span class="gi">+    # of junk.  One occurrence of this that I had was when using iTerm2 on OS X,</span>
<span class="gi">+    # with &quot;Option as Meta&quot; checked (You should choose &quot;Option as +Esc&quot;.)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, stdin_fd: int, errors: str = &quot;surrogateescape&quot;, encoding: str = &quot;utf-8&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.stdin_fd = stdin_fd
<span class="w"> </span>        self.errors = errors
<span class="gi">+</span>
<span class="gi">+        # Create incremental decoder for decoding stdin.</span>
<span class="gi">+        # We can not just do `os.read(stdin.fileno(), 1024).decode(&#39;utf-8&#39;)`, because</span>
<span class="gi">+        # it could be that we are in the middle of a utf-8 byte sequence.</span>
<span class="w"> </span>        self._stdin_decoder_cls = getincrementaldecoder(encoding)
<span class="w"> </span>        self._stdin_decoder = self._stdin_decoder_cls(errors=errors)
<span class="gi">+</span>
<span class="gi">+        #: True when there is nothing anymore to read.</span>
<span class="w"> </span>        self.closed = False

<span class="gd">-    def read(self, count: int=1024) -&gt;str:</span>
<span class="gi">+    def read(self, count: int = 1024) -&gt; str:</span>
<span class="gi">+        # By default we choose a rather small chunk size, because reading</span>
<span class="gi">+        # big amounts of input at once, causes the event loop to process</span>
<span class="gi">+        # all these key bindings also at once without going back to the</span>
<span class="gi">+        # loop. This will make the application feel unresponsive.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Read the input and return it as a string.

<span class="gu">@@ -43,4 +62,36 @@ class PosixStdinReader:</span>
<span class="w"> </span>        the input stream was not yet closed. This means that something went
<span class="w"> </span>        wrong during the decoding.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Check whether there is some input to read. `os.read` would block</span>
<span class="gi">+        # otherwise.</span>
<span class="gi">+        # (Actually, the event loop is responsible to make sure that this</span>
<span class="gi">+        # function is only called when there is something to read, but for some</span>
<span class="gi">+        # reason this happens in certain situations.)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not select.select([self.stdin_fd], [], [], 0)[0]:</span>
<span class="gi">+                return &quot;&quot;</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # Happens for instance when the file descriptor was closed.</span>
<span class="gi">+            # (We had this in ptterm, where the FD became ready, a callback was</span>
<span class="gi">+            # scheduled, but in the meantime another callback closed it already.)</span>
<span class="gi">+            self.closed = True</span>
<span class="gi">+</span>
<span class="gi">+        # Note: the following works better than wrapping `self.stdin` like</span>
<span class="gi">+        #       `codecs.getreader(&#39;utf-8&#39;)(stdin)` and doing `read(1)`.</span>
<span class="gi">+        #       Somehow that causes some latency when the escape</span>
<span class="gi">+        #       character is pressed. (Especially on combination with the `select`.)</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = os.read(self.stdin_fd, count)</span>
<span class="gi">+</span>
<span class="gi">+            # Nothing more to read, stream is closed.</span>
<span class="gi">+            if data == b&quot;&quot;:</span>
<span class="gi">+                self.closed = True</span>
<span class="gi">+                return &quot;&quot;</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # In case of SIGWINCH</span>
<span class="gi">+            data = b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return self._stdin_decoder.decode(data)</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/typeahead.py b/src/prompt_toolkit/input/typeahead.py</span>
<span class="gh">index 1d5e4fca..a45e7cf5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/typeahead.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/typeahead.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+r&quot;&quot;&quot;</span>
<span class="w"> </span>Store input key strokes if we did read more than was required.

<span class="w"> </span>The input classes `Vt100Input` and `Win32Input` read the input text in chunks
<span class="gu">@@ -23,7 +23,7 @@ in bigger chunks.</span>

<span class="w"> </span>Further, line buffering is also not an option, because it doesn&#39;t work well in
<span class="w"> </span>the architecture. We use lower level Posix APIs, that work better with the
<span class="gd">-event loop and so on. In fact, there is also nothing that defines that only \\n</span>
<span class="gi">+event loop and so on. In fact, there is also nothing that defines that only \n</span>
<span class="w"> </span>can accept the input, you could create a key binding for any key to accept the
<span class="w"> </span>input.

<span class="gu">@@ -32,29 +32,46 @@ read too early, so that they can be feed into to the next `prompt()` call or to</span>
<span class="w"> </span>the next prompt_toolkit `Application`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>from ..key_binding import KeyPress
<span class="w"> </span>from .base import Input
<span class="gd">-__all__ = [&#39;store_typeahead&#39;, &#39;get_typeahead&#39;, &#39;clear_typeahead&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;store_typeahead&quot;,</span>
<span class="gi">+    &quot;get_typeahead&quot;,</span>
<span class="gi">+    &quot;clear_typeahead&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>_buffer: dict[str, list[KeyPress]] = defaultdict(list)


<span class="gd">-def store_typeahead(input_obj: Input, key_presses: list[KeyPress]) -&gt;None:</span>
<span class="gi">+def store_typeahead(input_obj: Input, key_presses: list[KeyPress]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Insert typeahead key presses for the given input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _buffer</span>
<span class="gi">+    key = input_obj.typeahead_hash()</span>
<span class="gi">+    _buffer[key].extend(key_presses)</span>


<span class="gd">-def get_typeahead(input_obj: Input) -&gt;list[KeyPress]:</span>
<span class="gi">+def get_typeahead(input_obj: Input) -&gt; list[KeyPress]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Retrieve typeahead and reset the buffer for this input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _buffer</span>
<span class="gi">+</span>
<span class="gi">+    key = input_obj.typeahead_hash()</span>
<span class="gi">+    result = _buffer[key]</span>
<span class="gi">+    _buffer[key] = []</span>
<span class="gi">+    return result</span>


<span class="gd">-def clear_typeahead(input_obj: Input) -&gt;None:</span>
<span class="gi">+def clear_typeahead(input_obj: Input) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clear typeahead buffer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _buffer</span>
<span class="gi">+    key = input_obj.typeahead_hash()</span>
<span class="gi">+    _buffer[key] = []</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/vt100.py b/src/prompt_toolkit/input/vt100.py</span>
<span class="gh">index 2e980418..c1660de9 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/vt100.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/vt100.py</span>
<span class="gu">@@ -1,17 +1,26 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform != &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform != &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import io
<span class="w"> </span>import termios
<span class="w"> </span>import tty
<span class="w"> </span>from asyncio import AbstractEventLoop, get_running_loop
<span class="w"> </span>from typing import Callable, ContextManager, Generator, TextIO
<span class="gi">+</span>
<span class="w"> </span>from ..key_binding import KeyPress
<span class="w"> </span>from .base import Input
<span class="w"> </span>from .posix_utils import PosixStdinReader
<span class="w"> </span>from .vt100_parser import Vt100Parser
<span class="gd">-__all__ = [&#39;Vt100Input&#39;, &#39;raw_mode&#39;, &#39;cooked_mode&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Vt100Input&quot;,</span>
<span class="gi">+    &quot;raw_mode&quot;,</span>
<span class="gi">+    &quot;cooked_mode&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Vt100Input(Input):
<span class="gu">@@ -19,75 +28,181 @@ class Vt100Input(Input):</span>
<span class="w"> </span>    Vt100 input for Posix systems.
<span class="w"> </span>    (This uses a posix file descriptor that can be registered in the event loop.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # For the error messages. Only display &quot;Input is not a terminal&quot; once per</span>
<span class="gi">+    # file descriptor.</span>
<span class="w"> </span>    _fds_not_a_terminal: set[int] = set()

<span class="gd">-    def __init__(self, stdin: TextIO) -&gt;None:</span>
<span class="gi">+    def __init__(self, stdin: TextIO) -&gt; None:</span>
<span class="gi">+        # Test whether the given input object has a file descriptor.</span>
<span class="gi">+        # (Idle reports stdin to be a TTY, but fileno() is not implemented.)</span>
<span class="w"> </span>        try:
<span class="gi">+            # This should not raise, but can return 0.</span>
<span class="w"> </span>            stdin.fileno()
<span class="w"> </span>        except io.UnsupportedOperation as e:
<span class="gd">-            if &#39;idlelib.run&#39; in sys.modules:</span>
<span class="gi">+            if &quot;idlelib.run&quot; in sys.modules:</span>
<span class="w"> </span>                raise io.UnsupportedOperation(
<span class="gd">-                    &#39;Stdin is not a terminal. Running from Idle is not supported.&#39;</span>
<span class="gd">-                    ) from e</span>
<span class="gi">+                    &quot;Stdin is not a terminal. Running from Idle is not supported.&quot;</span>
<span class="gi">+                ) from e</span>
<span class="w"> </span>            else:
<span class="gd">-                raise io.UnsupportedOperation(&#39;Stdin is not a terminal.&#39;</span>
<span class="gd">-                    ) from e</span>
<span class="gi">+                raise io.UnsupportedOperation(&quot;Stdin is not a terminal.&quot;) from e</span>
<span class="gi">+</span>
<span class="gi">+        # Even when we have a file descriptor, it doesn&#39;t mean it&#39;s a TTY.</span>
<span class="gi">+        # Normally, this requires a real TTY device, but people instantiate</span>
<span class="gi">+        # this class often during unit tests as well. They use for instance</span>
<span class="gi">+        # pexpect to pipe data into an application. For convenience, we print</span>
<span class="gi">+        # an error message and go on.</span>
<span class="w"> </span>        isatty = stdin.isatty()
<span class="w"> </span>        fd = stdin.fileno()
<span class="gi">+</span>
<span class="w"> </span>        if not isatty and fd not in Vt100Input._fds_not_a_terminal:
<span class="gd">-            msg = &#39;Warning: Input is not a terminal (fd=%r).\n&#39;</span>
<span class="gi">+            msg = &quot;Warning: Input is not a terminal (fd=%r).\n&quot;</span>
<span class="w"> </span>            sys.stderr.write(msg % fd)
<span class="w"> </span>            sys.stderr.flush()
<span class="w"> </span>            Vt100Input._fds_not_a_terminal.add(fd)
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="w"> </span>        self.stdin = stdin
<span class="gi">+</span>
<span class="gi">+        # Create a backup of the fileno(). We want this to work even if the</span>
<span class="gi">+        # underlying file is closed, so that `typeahead_hash()` keeps working.</span>
<span class="w"> </span>        self._fileno = stdin.fileno()
<span class="gd">-        self._buffer: list[KeyPress] = []</span>
<span class="gd">-        self.stdin_reader = PosixStdinReader(self._fileno, encoding=stdin.</span>
<span class="gd">-            encoding)</span>
<span class="gd">-        self.vt100_parser = Vt100Parser(lambda key_press: self._buffer.</span>
<span class="gd">-            append(key_press))</span>
<span class="gd">-</span>
<span class="gd">-    def attach(self, input_ready_callback: Callable[[], None]</span>
<span class="gd">-        ) -&gt;ContextManager[None]:</span>
<span class="gi">+</span>
<span class="gi">+        self._buffer: list[KeyPress] = []  # Buffer to collect the Key objects.</span>
<span class="gi">+        self.stdin_reader = PosixStdinReader(self._fileno, encoding=stdin.encoding)</span>
<span class="gi">+        self.vt100_parser = Vt100Parser(</span>
<span class="gi">+            lambda key_press: self._buffer.append(key_press)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def attach(self, input_ready_callback: Callable[[], None]) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _attached_input(self, input_ready_callback)</span>

<span class="gd">-    def detach(self) -&gt;ContextManager[None]:</span>
<span class="gi">+    def detach(self) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _detached_input(self)</span>
<span class="gi">+</span>
<span class="gi">+    def read_keys(self) -&gt; list[KeyPress]:</span>
<span class="gi">+        &quot;Read list of KeyPress.&quot;</span>
<span class="gi">+        # Read text from stdin.</span>
<span class="gi">+        data = self.stdin_reader.read()</span>

<span class="gd">-    def read_keys(self) -&gt;list[KeyPress]:</span>
<span class="gd">-        &quot;&quot;&quot;Read list of KeyPress.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        # Pass it through our vt100 parser.</span>
<span class="gi">+        self.vt100_parser.feed(data)</span>

<span class="gd">-    def flush_keys(self) -&gt;list[KeyPress]:</span>
<span class="gi">+        # Return result.</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def flush_keys(self) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush pending keys and return them.
<span class="w"> </span>        (Used for flushing the &#39;escape&#39; key.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Flush all pending keys. (This is most important to flush the vt100</span>
<span class="gi">+        # &#39;Escape&#39; key early when nothing else follows.)</span>
<span class="gi">+        self.vt100_parser.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Return result.</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="gi">+        return self.stdin_reader.closed</span>
<span class="gi">+</span>
<span class="gi">+    def raw_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return raw_mode(self.stdin.fileno())</span>
<span class="gi">+</span>
<span class="gi">+    def cooked_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return cooked_mode(self.stdin.fileno())</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return self.stdin.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="gi">+        return f&quot;fd-{self._fileno}&quot;</span>


<span class="gd">-_current_callbacks: dict[tuple[AbstractEventLoop, int], Callable[[], None] |</span>
<span class="gd">-    None] = {}</span>
<span class="gi">+_current_callbacks: dict[</span>
<span class="gi">+    tuple[AbstractEventLoop, int], Callable[[], None] | None</span>
<span class="gi">+] = {}  # (loop, fd) -&gt; current callback</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="gd">-def _attached_input(input: Vt100Input, callback: Callable[[], None]</span>
<span class="gd">-    ) -&gt;Generator[None, None, None]:</span>
<span class="gi">+def _attached_input(</span>
<span class="gi">+    input: Vt100Input, callback: Callable[[], None]</span>
<span class="gi">+) -&gt; Generator[None, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Context manager that makes this input active in the current event loop.

<span class="w"> </span>    :param input: :class:`~prompt_toolkit.input.Input` object.
<span class="w"> </span>    :param callback: Called when the input is ready to read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+    fd = input.fileno()</span>
<span class="gi">+    previous = _current_callbacks.get((loop, fd))</span>
<span class="gi">+</span>
<span class="gi">+    def callback_wrapper() -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Wrapper around the callback that already removes the reader when</span>
<span class="gi">+        the input is closed. Otherwise, we keep continuously calling this</span>
<span class="gi">+        callback, until we leave the context manager (which can happen a bit</span>
<span class="gi">+        later). This fixes issues when piping /dev/null into a prompt_toolkit</span>
<span class="gi">+        application.&quot;&quot;&quot;</span>
<span class="gi">+        if input.closed:</span>
<span class="gi">+            loop.remove_reader(fd)</span>
<span class="gi">+        callback()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        loop.add_reader(fd, callback_wrapper)</span>
<span class="gi">+    except PermissionError:</span>
<span class="gi">+        # For `EPollSelector`, adding /dev/null to the event loop will raise</span>
<span class="gi">+        # `PermissionError` (that doesn&#39;t happen for `SelectSelector`</span>
<span class="gi">+        # apparently). Whenever we get a `PermissionError`, we can raise</span>
<span class="gi">+        # `EOFError`, because there&#39;s not more to be read anyway. `EOFError` is</span>
<span class="gi">+        # an exception that people expect in</span>
<span class="gi">+        # `prompt_toolkit.application.Application.run()`.</span>
<span class="gi">+        # To reproduce, do: `ptpython 0&lt; /dev/null 1&lt; /dev/null`</span>
<span class="gi">+        raise EOFError</span>
<span class="gi">+</span>
<span class="gi">+    _current_callbacks[loop, fd] = callback</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        loop.remove_reader(fd)</span>
<span class="gi">+</span>
<span class="gi">+        if previous:</span>
<span class="gi">+            loop.add_reader(fd, previous)</span>
<span class="gi">+            _current_callbacks[loop, fd] = previous</span>
<span class="gi">+        else:</span>
<span class="gi">+            del _current_callbacks[loop, fd]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _detached_input(input: Vt100Input) -&gt; Generator[None, None, None]:</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+    fd = input.fileno()</span>
<span class="gi">+    previous = _current_callbacks.get((loop, fd))</span>
<span class="gi">+</span>
<span class="gi">+    if previous:</span>
<span class="gi">+        loop.remove_reader(fd)</span>
<span class="gi">+        _current_callbacks[loop, fd] = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if previous:</span>
<span class="gi">+            loop.add_reader(fd, previous)</span>
<span class="gi">+            _current_callbacks[loop, fd] = previous</span>


<span class="w"> </span>class raw_mode:
<span class="gu">@@ -100,15 +215,31 @@ class raw_mode:</span>
<span class="w"> </span>    We ignore errors when executing `tcgetattr` fails.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, fileno: int) -&gt;None:</span>
<span class="gi">+    # There are several reasons for ignoring errors:</span>
<span class="gi">+    # 1. To avoid the &quot;Inappropriate ioctl for device&quot; crash if somebody would</span>
<span class="gi">+    #    execute this code (In a Python REPL, for instance):</span>
<span class="gi">+    #</span>
<span class="gi">+    #         import os; f = open(os.devnull); os.dup2(f.fileno(), 0)</span>
<span class="gi">+    #</span>
<span class="gi">+    #    The result is that the eventloop will stop correctly, because it has</span>
<span class="gi">+    #    to logic to quit when stdin is closed. However, we should not fail at</span>
<span class="gi">+    #    this point. See:</span>
<span class="gi">+    #      https://github.com/jonathanslenders/python-prompt-toolkit/pull/393</span>
<span class="gi">+    #      https://github.com/jonathanslenders/python-prompt-toolkit/issues/392</span>
<span class="gi">+</span>
<span class="gi">+    # 2. Related, when stdin is an SSH pipe, and no full terminal was allocated.</span>
<span class="gi">+    #    See: https://github.com/jonathanslenders/python-prompt-toolkit/pull/165</span>
<span class="gi">+    def __init__(self, fileno: int) -&gt; None:</span>
<span class="w"> </span>        self.fileno = fileno
<span class="w"> </span>        self.attrs_before: list[int | list[bytes | int]] | None
<span class="w"> </span>        try:
<span class="w"> </span>            self.attrs_before = termios.tcgetattr(fileno)
<span class="w"> </span>        except termios.error:
<span class="gi">+            # Ignore attribute errors.</span>
<span class="w"> </span>            self.attrs_before = None

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="gi">+        # NOTE: On os X systems, using pty.setraw() fails. Therefor we are using this:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            newattr = termios.tcgetattr(self.fileno)
<span class="w"> </span>        except termios.error:
<span class="gu">@@ -116,17 +247,45 @@ class raw_mode:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            newattr[tty.LFLAG] = self._patch_lflag(newattr[tty.LFLAG])
<span class="w"> </span>            newattr[tty.IFLAG] = self._patch_iflag(newattr[tty.IFLAG])
<span class="gi">+</span>
<span class="gi">+            # VMIN defines the number of characters read at a time in</span>
<span class="gi">+            # non-canonical mode. It seems to default to 1 on Linux, but on</span>
<span class="gi">+            # Solaris and derived operating systems it defaults to 4. (This is</span>
<span class="gi">+            # because the VMIN slot is the same as the VEOF slot, which</span>
<span class="gi">+            # defaults to ASCII EOT = Ctrl-D = 4.)</span>
<span class="w"> </span>            newattr[tty.CC][termios.VMIN] = 1
<span class="gi">+</span>
<span class="w"> </span>            termios.tcsetattr(self.fileno, termios.TCSANOW, newattr)

<span class="gd">-    def __exit__(self, *a: object) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _patch_lflag(cls, attrs: int) -&gt; int:</span>
<span class="gi">+        return attrs &amp; ~(termios.ECHO | termios.ICANON | termios.IEXTEN | termios.ISIG)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _patch_iflag(cls, attrs: int) -&gt; int:</span>
<span class="gi">+        return attrs &amp; ~(</span>
<span class="gi">+            # Disable XON/XOFF flow control on output and input.</span>
<span class="gi">+            # (Don&#39;t capture Ctrl-S and Ctrl-Q.)</span>
<span class="gi">+            # Like executing: &quot;stty -ixon.&quot;</span>
<span class="gi">+            termios.IXON</span>
<span class="gi">+            | termios.IXOFF</span>
<span class="gi">+            |</span>
<span class="gi">+            # Don&#39;t translate carriage return into newline on input.</span>
<span class="gi">+            termios.ICRNL</span>
<span class="gi">+            | termios.INLCR</span>
<span class="gi">+            | termios.IGNCR</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __exit__(self, *a: object) -&gt; None:</span>
<span class="w"> </span>        if self.attrs_before is not None:
<span class="w"> </span>            try:
<span class="gd">-                termios.tcsetattr(self.fileno, termios.TCSANOW, self.</span>
<span class="gd">-                    attrs_before)</span>
<span class="gi">+                termios.tcsetattr(self.fileno, termios.TCSANOW, self.attrs_before)</span>
<span class="w"> </span>            except termios.error:
<span class="w"> </span>                pass

<span class="gi">+            # # Put the terminal in application mode.</span>
<span class="gi">+            # self._stdout.write(&#39;\x1b[?1h&#39;)</span>
<span class="gi">+</span>

<span class="w"> </span>class cooked_mode(raw_mode):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -136,3 +295,15 @@ class cooked_mode(raw_mode):</span>
<span class="w"> </span>        with cooked_mode(stdin):
<span class="w"> </span>            &#39;&#39;&#39; the pseudo-terminal stdin is now used in cooked mode. &#39;&#39;&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _patch_lflag(cls, attrs: int) -&gt; int:</span>
<span class="gi">+        return attrs | (termios.ECHO | termios.ICANON | termios.IEXTEN | termios.ISIG)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _patch_iflag(cls, attrs: int) -&gt; int:</span>
<span class="gi">+        # Turn the ICRNL flag back on. (Without this, calling `input()` in</span>
<span class="gi">+        # run_in_terminal doesn&#39;t work and displays ^M instead. Ptpython</span>
<span class="gi">+        # evaluates commands using `run_in_terminal`, so it&#39;s important that</span>
<span class="gi">+        # they translate ^M back into ^J.)</span>
<span class="gi">+        return attrs | termios.ICRNL</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/vt100_parser.py b/src/prompt_toolkit/input/vt100_parser.py</span>
<span class="gh">index e2623b5d..99e2d99c 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/vt100_parser.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/vt100_parser.py</span>
<span class="gu">@@ -2,22 +2,39 @@</span>
<span class="w"> </span>Parser for VT100 input stream.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import Callable, Dict, Generator
<span class="gi">+</span>
<span class="w"> </span>from ..key_binding.key_processor import KeyPress
<span class="w"> </span>from ..keys import Keys
<span class="w"> </span>from .ansi_escape_sequences import ANSI_SEQUENCES
<span class="gd">-__all__ = [&#39;Vt100Parser&#39;]</span>
<span class="gd">-_cpr_response_re = re.compile(&#39;^&#39; + re.escape(&#39;\x1b[&#39;) + &#39;\\d+;\\d+R\\Z&#39;)</span>
<span class="gd">-_mouse_event_re = re.compile(&#39;^&#39; + re.escape(&#39;\x1b[&#39;) +</span>
<span class="gd">-    &#39;(&lt;?[\\d;]+[mM]|M...)\\Z&#39;)</span>
<span class="gd">-_cpr_response_prefix_re = re.compile(&#39;^&#39; + re.escape(&#39;\x1b[&#39;) + &#39;[\\d;]*\\Z&#39;)</span>
<span class="gd">-_mouse_event_prefix_re = re.compile(&#39;^&#39; + re.escape(&#39;\x1b[&#39;) +</span>
<span class="gd">-    &#39;(&lt;?[\\d;]*|M.{0,2})\\Z&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Vt100Parser&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Regex matching any CPR response</span>
<span class="gi">+# (Note that we use &#39;\Z&#39; instead of &#39;$&#39;, because &#39;$&#39; could include a trailing</span>
<span class="gi">+# newline.)</span>
<span class="gi">+_cpr_response_re = re.compile(&quot;^&quot; + re.escape(&quot;\x1b[&quot;) + r&quot;\d+;\d+R\Z&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# Mouse events:</span>
<span class="gi">+# Typical: &quot;Esc[MaB*&quot;  Urxvt: &quot;Esc[96;14;13M&quot; and for Xterm SGR: &quot;Esc[&lt;64;85;12M&quot;</span>
<span class="gi">+_mouse_event_re = re.compile(&quot;^&quot; + re.escape(&quot;\x1b[&quot;) + r&quot;(&lt;?[\d;]+[mM]|M...)\Z&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# Regex matching any valid prefix of a CPR response.</span>
<span class="gi">+# (Note that it doesn&#39;t contain the last character, the &#39;R&#39;. The prefix has to</span>
<span class="gi">+# be shorter.)</span>
<span class="gi">+_cpr_response_prefix_re = re.compile(&quot;^&quot; + re.escape(&quot;\x1b[&quot;) + r&quot;[\d;]*\Z&quot;)</span>
<span class="gi">+</span>
<span class="gi">+_mouse_event_prefix_re = re.compile(&quot;^&quot; + re.escape(&quot;\x1b[&quot;) + r&quot;(&lt;?[\d;]*|M.{0,2})\Z&quot;)</span>


<span class="w"> </span>class _Flush:
<span class="w"> </span>    &quot;&quot;&quot;Helper object to indicate flush operation to the parser.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -27,13 +44,21 @@ class _IsPrefixOfLongerMatchCache(Dict[str, bool]):</span>
<span class="w"> </span>    any key that start with this characters.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __missing__(self, prefix: str) -&gt;bool:</span>
<span class="gd">-        if _cpr_response_prefix_re.match(prefix</span>
<span class="gd">-            ) or _mouse_event_prefix_re.match(prefix):</span>
<span class="gi">+    def __missing__(self, prefix: str) -&gt; bool:</span>
<span class="gi">+        # (hard coded) If this could be a prefix of a CPR response, return</span>
<span class="gi">+        # True.</span>
<span class="gi">+        if _cpr_response_prefix_re.match(prefix) or _mouse_event_prefix_re.match(</span>
<span class="gi">+            prefix</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            result = True
<span class="w"> </span>        else:
<span class="gd">-            result = any(v for k, v in ANSI_SEQUENCES.items() if k.</span>
<span class="gd">-                startswith(prefix) and k != prefix)</span>
<span class="gi">+            # If this could be a prefix of anything else, also return True.</span>
<span class="gi">+            result = any(</span>
<span class="gi">+                v</span>
<span class="gi">+                for k, v in ANSI_SEQUENCES.items()</span>
<span class="gi">+                if k.startswith(prefix) and k != prefix</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self[prefix] = result
<span class="w"> </span>        return result

<span class="gu">@@ -52,49 +77,157 @@ class Vt100Parser:</span>
<span class="w"> </span>        def callback(key):
<span class="w"> </span>            pass
<span class="w"> </span>        i = Vt100Parser(callback)
<span class="gd">-        i.feed(&#39;data...&#39;)</span>
<span class="gi">+        i.feed(&#39;data\x01...&#39;)</span>

<span class="w"> </span>    :attr feed_key_callback: Function that will be called when a key is parsed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, feed_key_callback: Callable[[KeyPress], None]) -&gt;None:</span>
<span class="gi">+    # Lookup table of ANSI escape sequences for a VT100 terminal</span>
<span class="gi">+    # Hint: in order to know what sequences your terminal writes to stdin, run</span>
<span class="gi">+    #       &quot;od -c&quot; and start typing.</span>
<span class="gi">+    def __init__(self, feed_key_callback: Callable[[KeyPress], None]) -&gt; None:</span>
<span class="w"> </span>        self.feed_key_callback = feed_key_callback
<span class="w"> </span>        self.reset()

<span class="gd">-    def _start_parser(self) -&gt;None:</span>
<span class="gi">+    def reset(self, request: bool = False) -&gt; None:</span>
<span class="gi">+        self._in_bracketed_paste = False</span>
<span class="gi">+        self._start_parser()</span>
<span class="gi">+</span>
<span class="gi">+    def _start_parser(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start the parser coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._input_parser = self._input_parser_generator()</span>
<span class="gi">+        self._input_parser.send(None)  # type: ignore</span>

<span class="gd">-    def _get_match(self, prefix: str) -&gt;(None | Keys | tuple[Keys, ...]):</span>
<span class="gi">+    def _get_match(self, prefix: str) -&gt; None | Keys | tuple[Keys, ...]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the key (or keys) that maps to this prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _input_parser_generator(self) -&gt;Generator[None, str | _Flush, None]:</span>
<span class="gi">+        # (hard coded) If we match a CPR response, return Keys.CPRResponse.</span>
<span class="gi">+        # (This one doesn&#39;t fit in the ANSI_SEQUENCES, because it contains</span>
<span class="gi">+        # integer variables.)</span>
<span class="gi">+        if _cpr_response_re.match(prefix):</span>
<span class="gi">+            return Keys.CPRResponse</span>
<span class="gi">+</span>
<span class="gi">+        elif _mouse_event_re.match(prefix):</span>
<span class="gi">+            return Keys.Vt100MouseEvent</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, use the mappings.</span>
<span class="gi">+        try:</span>
<span class="gi">+            return ANSI_SEQUENCES[prefix]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _input_parser_generator(self) -&gt; Generator[None, str | _Flush, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine (state machine) for the input parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _call_handler(self, key: (str | Keys | tuple[Keys, ...]),</span>
<span class="gd">-        insert_text: str) -&gt;None:</span>
<span class="gi">+        prefix = &quot;&quot;</span>
<span class="gi">+        retry = False</span>
<span class="gi">+        flush = False</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            flush = False</span>
<span class="gi">+</span>
<span class="gi">+            if retry:</span>
<span class="gi">+                retry = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Get next character.</span>
<span class="gi">+                c = yield</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(c, _Flush):</span>
<span class="gi">+                    flush = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    prefix += c</span>
<span class="gi">+</span>
<span class="gi">+            # If we have some data, check for matches.</span>
<span class="gi">+            if prefix:</span>
<span class="gi">+                is_prefix_of_longer_match = _IS_PREFIX_OF_LONGER_MATCH_CACHE[prefix]</span>
<span class="gi">+                match = self._get_match(prefix)</span>
<span class="gi">+</span>
<span class="gi">+                # Exact matches found, call handlers..</span>
<span class="gi">+                if (flush or not is_prefix_of_longer_match) and match:</span>
<span class="gi">+                    self._call_handler(match, prefix)</span>
<span class="gi">+                    prefix = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+                # No exact match found.</span>
<span class="gi">+                elif (flush or not is_prefix_of_longer_match) and not match:</span>
<span class="gi">+                    found = False</span>
<span class="gi">+                    retry = True</span>
<span class="gi">+</span>
<span class="gi">+                    # Loop over the input, try the longest match first and</span>
<span class="gi">+                    # shift.</span>
<span class="gi">+                    for i in range(len(prefix), 0, -1):</span>
<span class="gi">+                        match = self._get_match(prefix[:i])</span>
<span class="gi">+                        if match:</span>
<span class="gi">+                            self._call_handler(match, prefix[:i])</span>
<span class="gi">+                            prefix = prefix[i:]</span>
<span class="gi">+                            found = True</span>
<span class="gi">+</span>
<span class="gi">+                    if not found:</span>
<span class="gi">+                        self._call_handler(prefix[0], prefix[0])</span>
<span class="gi">+                        prefix = prefix[1:]</span>
<span class="gi">+</span>
<span class="gi">+    def _call_handler(</span>
<span class="gi">+        self, key: str | Keys | tuple[Keys, ...], insert_text: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Callback to handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(key, tuple):</span>
<span class="gi">+            # Received ANSI sequence that corresponds with multiple keys</span>
<span class="gi">+            # (probably alt+something). Handle keys individually, but only pass</span>
<span class="gi">+            # data payload to first KeyPress (so that we won&#39;t insert it</span>
<span class="gi">+            # multiple times).</span>
<span class="gi">+            for i, k in enumerate(key):</span>
<span class="gi">+                self._call_handler(k, insert_text if i == 0 else &quot;&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if key == Keys.BracketedPaste:</span>
<span class="gi">+                self._in_bracketed_paste = True</span>
<span class="gi">+                self._paste_buffer = &quot;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.feed_key_callback(KeyPress(key, insert_text))</span>

<span class="gd">-    def feed(self, data: str) -&gt;None:</span>
<span class="gi">+    def feed(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Feed the input stream.

<span class="w"> </span>        :param data: Input string (unicode).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Handle bracketed paste. (We bypass the parser that matches all other</span>
<span class="gi">+        # key presses and keep reading input until we see the end mark.)</span>
<span class="gi">+        # This is much faster then parsing character by character.</span>
<span class="gi">+        if self._in_bracketed_paste:</span>
<span class="gi">+            self._paste_buffer += data</span>
<span class="gi">+            end_mark = &quot;\x1b[201~&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if end_mark in self._paste_buffer:</span>
<span class="gi">+                end_index = self._paste_buffer.index(end_mark)</span>

<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gi">+                # Feed content to key bindings.</span>
<span class="gi">+                paste_content = self._paste_buffer[:end_index]</span>
<span class="gi">+                self.feed_key_callback(KeyPress(Keys.BracketedPaste, paste_content))</span>
<span class="gi">+</span>
<span class="gi">+                # Quit bracketed paste mode and handle remaining input.</span>
<span class="gi">+                self._in_bracketed_paste = False</span>
<span class="gi">+                remaining = self._paste_buffer[end_index + len(end_mark) :]</span>
<span class="gi">+                self._paste_buffer = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+                self.feed(remaining)</span>
<span class="gi">+</span>
<span class="gi">+        # Handle normal input character by character.</span>
<span class="gi">+        else:</span>
<span class="gi">+            for i, c in enumerate(data):</span>
<span class="gi">+                if self._in_bracketed_paste:</span>
<span class="gi">+                    # Quit loop and process from this position when the parser</span>
<span class="gi">+                    # entered bracketed paste.</span>
<span class="gi">+                    self.feed(data[i:])</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._input_parser.send(c)</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush the buffer of the input stream.

<span class="gu">@@ -106,10 +239,11 @@ class Vt100Parser:</span>
<span class="w"> </span>        timeout, and processes everything that&#39;s still in the buffer as-is, so
<span class="w"> </span>        without assuming any characters will follow.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._input_parser.send(_Flush())</span>

<span class="gd">-    def feed_and_flush(self, data: str) -&gt;None:</span>
<span class="gi">+    def feed_and_flush(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wrapper around ``feed`` and ``flush``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.feed(data)</span>
<span class="gi">+        self.flush()</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/win32.py b/src/prompt_toolkit/input/win32.py</span>
<span class="gh">index 8d89a53c..35e8948d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/win32.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/win32.py</span>
<span class="gu">@@ -1,31 +1,56 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from abc import abstractmethod
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>from ..utils import SPHINX_AUTODOC_RUNNING
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Do not import win32-specific stuff when generating documentation.</span>
<span class="gi">+# Otherwise RTD would be unable to generate docs for this module.</span>
<span class="w"> </span>if not SPHINX_AUTODOC_RUNNING:
<span class="w"> </span>    import msvcrt
<span class="w"> </span>    from ctypes import windll
<span class="gi">+</span>
<span class="w"> </span>from ctypes import Array, pointer
<span class="w"> </span>from ctypes.wintypes import DWORD, HANDLE
<span class="w"> </span>from typing import Callable, ContextManager, Iterable, Iterator, TextIO
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.eventloop import run_in_executor_with_context
<span class="w"> </span>from prompt_toolkit.eventloop.win32 import create_win32_event, wait_for_handles
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPress
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseButton, MouseEventType
<span class="gd">-from prompt_toolkit.win32_types import INPUT_RECORD, KEY_EVENT_RECORD, MOUSE_EVENT_RECORD, STD_INPUT_HANDLE, EventTypes</span>
<span class="gi">+from prompt_toolkit.win32_types import (</span>
<span class="gi">+    INPUT_RECORD,</span>
<span class="gi">+    KEY_EVENT_RECORD,</span>
<span class="gi">+    MOUSE_EVENT_RECORD,</span>
<span class="gi">+    STD_INPUT_HANDLE,</span>
<span class="gi">+    EventTypes,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .ansi_escape_sequences import REVERSE_ANSI_SEQUENCES
<span class="w"> </span>from .base import Input
<span class="gd">-__all__ = [&#39;Win32Input&#39;, &#39;ConsoleInputReader&#39;, &#39;raw_mode&#39;, &#39;cooked_mode&#39;,</span>
<span class="gd">-    &#39;attach_win32_input&#39;, &#39;detach_win32_input&#39;]</span>
<span class="gd">-FROM_LEFT_1ST_BUTTON_PRESSED = 1</span>
<span class="gd">-RIGHTMOST_BUTTON_PRESSED = 2</span>
<span class="gd">-MOUSE_MOVED = 1</span>
<span class="gd">-MOUSE_WHEELED = 4</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Win32Input&quot;,</span>
<span class="gi">+    &quot;ConsoleInputReader&quot;,</span>
<span class="gi">+    &quot;raw_mode&quot;,</span>
<span class="gi">+    &quot;cooked_mode&quot;,</span>
<span class="gi">+    &quot;attach_win32_input&quot;,</span>
<span class="gi">+    &quot;detach_win32_input&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Win32 Constants for MOUSE_EVENT_RECORD.</span>
<span class="gi">+# See: https://docs.microsoft.com/en-us/windows/console/mouse-event-record-str</span>
<span class="gi">+FROM_LEFT_1ST_BUTTON_PRESSED = 0x1</span>
<span class="gi">+RIGHTMOST_BUTTON_PRESSED = 0x2</span>
<span class="gi">+MOUSE_MOVED = 0x0001</span>
<span class="gi">+MOUSE_WHEELED = 0x0004</span>


<span class="w"> </span>class _Win32InputBase(Input):
<span class="gu">@@ -33,114 +58,303 @@ class _Win32InputBase(Input):</span>
<span class="w"> </span>    Base class for `Win32Input` and `Win32PipeInput`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.win32_handles = _Win32Handles()

<span class="gi">+    @property</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def handle(self) -&gt; HANDLE:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class Win32Input(_Win32InputBase):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    `Input` class that reads from the Windows console.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stdin: (TextIO | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, stdin: TextIO | None = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.console_input_reader = ConsoleInputReader()

<span class="gd">-    def attach(self, input_ready_callback: Callable[[], None]</span>
<span class="gd">-        ) -&gt;ContextManager[None]:</span>
<span class="gi">+    def attach(self, input_ready_callback: Callable[[], None]) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return attach_win32_input(self, input_ready_callback)</span>

<span class="gd">-    def detach(self) -&gt;ContextManager[None]:</span>
<span class="gi">+    def detach(self) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        return detach_win32_input(self)</span>
<span class="gi">+</span>
<span class="gi">+    def read_keys(self) -&gt; list[KeyPress]:</span>
<span class="gi">+        return list(self.console_input_reader.read())</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gi">+    @property</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def raw_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return raw_mode()</span>
<span class="gi">+</span>
<span class="gi">+    def cooked_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return cooked_mode()</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        # The windows console doesn&#39;t depend on the file handle, so</span>
<span class="gi">+        # this is not used for the event loop (which uses the</span>
<span class="gi">+        # handle instead). But it&#39;s used in `Application.run_system_command`</span>
<span class="gi">+        # which opens a subprocess with a given stdin/stdout.</span>
<span class="gi">+        return sys.stdin.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="gi">+        return &quot;win32-input&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self.console_input_reader.close()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def handle(self) -&gt; HANDLE:</span>
<span class="gi">+        return self.console_input_reader.handle</span>
<span class="gi">+</span>

<span class="w"> </span>class ConsoleInputReader:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :param recognize_paste: When True, try to discover paste actions and turn
<span class="w"> </span>        the event into a BracketedPaste.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    mappings = {b&#39;\x1b&#39;: Keys.Escape, b&#39;\x00&#39;: Keys.ControlSpace, b&#39;\x01&#39;:</span>
<span class="gd">-        Keys.ControlA, b&#39;\x02&#39;: Keys.ControlB, b&#39;\x03&#39;: Keys.ControlC,</span>
<span class="gd">-        b&#39;\x04&#39;: Keys.ControlD, b&#39;\x05&#39;: Keys.ControlE, b&#39;\x06&#39;: Keys.</span>
<span class="gd">-        ControlF, b&#39;\x07&#39;: Keys.ControlG, b&#39;\x08&#39;: Keys.ControlH, b&#39;\t&#39;:</span>
<span class="gd">-        Keys.ControlI, b&#39;\n&#39;: Keys.ControlJ, b&#39;\x0b&#39;: Keys.ControlK,</span>
<span class="gd">-        b&#39;\x0c&#39;: Keys.ControlL, b&#39;\r&#39;: Keys.ControlM, b&#39;\x0e&#39;: Keys.</span>
<span class="gd">-        ControlN, b&#39;\x0f&#39;: Keys.ControlO, b&#39;\x10&#39;: Keys.ControlP, b&#39;\x11&#39;:</span>
<span class="gd">-        Keys.ControlQ, b&#39;\x12&#39;: Keys.ControlR, b&#39;\x13&#39;: Keys.ControlS,</span>
<span class="gd">-        b&#39;\x14&#39;: Keys.ControlT, b&#39;\x15&#39;: Keys.ControlU, b&#39;\x16&#39;: Keys.</span>
<span class="gd">-        ControlV, b&#39;\x17&#39;: Keys.ControlW, b&#39;\x18&#39;: Keys.ControlX, b&#39;\x19&#39;:</span>
<span class="gd">-        Keys.ControlY, b&#39;\x1a&#39;: Keys.ControlZ, b&#39;\x1c&#39;: Keys.</span>
<span class="gd">-        ControlBackslash, b&#39;\x1d&#39;: Keys.ControlSquareClose, b&#39;\x1e&#39;: Keys.</span>
<span class="gd">-        ControlCircumflex, b&#39;\x1f&#39;: Keys.ControlUnderscore, b&#39;\x7f&#39;: Keys.</span>
<span class="gd">-        Backspace}</span>
<span class="gd">-    keycodes = {(33): Keys.PageUp, (34): Keys.PageDown, (35): Keys.End, (36</span>
<span class="gd">-        ): Keys.Home, (37): Keys.Left, (38): Keys.Up, (39): Keys.Right, (40</span>
<span class="gd">-        ): Keys.Down, (45): Keys.Insert, (46): Keys.Delete, (112): Keys.F1,</span>
<span class="gd">-        (113): Keys.F2, (114): Keys.F3, (115): Keys.F4, (116): Keys.F5, (</span>
<span class="gd">-        117): Keys.F6, (118): Keys.F7, (119): Keys.F8, (120): Keys.F9, (121</span>
<span class="gd">-        ): Keys.F10, (122): Keys.F11, (123): Keys.F12}</span>
<span class="gd">-    LEFT_ALT_PRESSED = 2</span>
<span class="gd">-    RIGHT_ALT_PRESSED = 1</span>
<span class="gd">-    SHIFT_PRESSED = 16</span>
<span class="gd">-    LEFT_CTRL_PRESSED = 8</span>
<span class="gd">-    RIGHT_CTRL_PRESSED = 4</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, recognize_paste: bool=True) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    # Keys with character data.</span>
<span class="gi">+    mappings = {</span>
<span class="gi">+        b&quot;\x1b&quot;: Keys.Escape,</span>
<span class="gi">+        b&quot;\x00&quot;: Keys.ControlSpace,  # Control-Space (Also for Ctrl-@)</span>
<span class="gi">+        b&quot;\x01&quot;: Keys.ControlA,  # Control-A (home)</span>
<span class="gi">+        b&quot;\x02&quot;: Keys.ControlB,  # Control-B (emacs cursor left)</span>
<span class="gi">+        b&quot;\x03&quot;: Keys.ControlC,  # Control-C (interrupt)</span>
<span class="gi">+        b&quot;\x04&quot;: Keys.ControlD,  # Control-D (exit)</span>
<span class="gi">+        b&quot;\x05&quot;: Keys.ControlE,  # Control-E (end)</span>
<span class="gi">+        b&quot;\x06&quot;: Keys.ControlF,  # Control-F (cursor forward)</span>
<span class="gi">+        b&quot;\x07&quot;: Keys.ControlG,  # Control-G</span>
<span class="gi">+        b&quot;\x08&quot;: Keys.ControlH,  # Control-H (8) (Identical to &#39;\b&#39;)</span>
<span class="gi">+        b&quot;\x09&quot;: Keys.ControlI,  # Control-I (9) (Identical to &#39;\t&#39;)</span>
<span class="gi">+        b&quot;\x0a&quot;: Keys.ControlJ,  # Control-J (10) (Identical to &#39;\n&#39;)</span>
<span class="gi">+        b&quot;\x0b&quot;: Keys.ControlK,  # Control-K (delete until end of line; vertical tab)</span>
<span class="gi">+        b&quot;\x0c&quot;: Keys.ControlL,  # Control-L (clear; form feed)</span>
<span class="gi">+        b&quot;\x0d&quot;: Keys.ControlM,  # Control-M (enter)</span>
<span class="gi">+        b&quot;\x0e&quot;: Keys.ControlN,  # Control-N (14) (history forward)</span>
<span class="gi">+        b&quot;\x0f&quot;: Keys.ControlO,  # Control-O (15)</span>
<span class="gi">+        b&quot;\x10&quot;: Keys.ControlP,  # Control-P (16) (history back)</span>
<span class="gi">+        b&quot;\x11&quot;: Keys.ControlQ,  # Control-Q</span>
<span class="gi">+        b&quot;\x12&quot;: Keys.ControlR,  # Control-R (18) (reverse search)</span>
<span class="gi">+        b&quot;\x13&quot;: Keys.ControlS,  # Control-S (19) (forward search)</span>
<span class="gi">+        b&quot;\x14&quot;: Keys.ControlT,  # Control-T</span>
<span class="gi">+        b&quot;\x15&quot;: Keys.ControlU,  # Control-U</span>
<span class="gi">+        b&quot;\x16&quot;: Keys.ControlV,  # Control-V</span>
<span class="gi">+        b&quot;\x17&quot;: Keys.ControlW,  # Control-W</span>
<span class="gi">+        b&quot;\x18&quot;: Keys.ControlX,  # Control-X</span>
<span class="gi">+        b&quot;\x19&quot;: Keys.ControlY,  # Control-Y (25)</span>
<span class="gi">+        b&quot;\x1a&quot;: Keys.ControlZ,  # Control-Z</span>
<span class="gi">+        b&quot;\x1c&quot;: Keys.ControlBackslash,  # Both Control-\ and Ctrl-|</span>
<span class="gi">+        b&quot;\x1d&quot;: Keys.ControlSquareClose,  # Control-]</span>
<span class="gi">+        b&quot;\x1e&quot;: Keys.ControlCircumflex,  # Control-^</span>
<span class="gi">+        b&quot;\x1f&quot;: Keys.ControlUnderscore,  # Control-underscore (Also for Ctrl-hyphen.)</span>
<span class="gi">+        b&quot;\x7f&quot;: Keys.Backspace,  # (127) Backspace   (ASCII Delete.)</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Keys that don&#39;t carry character data.</span>
<span class="gi">+    keycodes = {</span>
<span class="gi">+        # Home/End</span>
<span class="gi">+        33: Keys.PageUp,</span>
<span class="gi">+        34: Keys.PageDown,</span>
<span class="gi">+        35: Keys.End,</span>
<span class="gi">+        36: Keys.Home,</span>
<span class="gi">+        # Arrows</span>
<span class="gi">+        37: Keys.Left,</span>
<span class="gi">+        38: Keys.Up,</span>
<span class="gi">+        39: Keys.Right,</span>
<span class="gi">+        40: Keys.Down,</span>
<span class="gi">+        45: Keys.Insert,</span>
<span class="gi">+        46: Keys.Delete,</span>
<span class="gi">+        # F-keys.</span>
<span class="gi">+        112: Keys.F1,</span>
<span class="gi">+        113: Keys.F2,</span>
<span class="gi">+        114: Keys.F3,</span>
<span class="gi">+        115: Keys.F4,</span>
<span class="gi">+        116: Keys.F5,</span>
<span class="gi">+        117: Keys.F6,</span>
<span class="gi">+        118: Keys.F7,</span>
<span class="gi">+        119: Keys.F8,</span>
<span class="gi">+        120: Keys.F9,</span>
<span class="gi">+        121: Keys.F10,</span>
<span class="gi">+        122: Keys.F11,</span>
<span class="gi">+        123: Keys.F12,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    LEFT_ALT_PRESSED = 0x0002</span>
<span class="gi">+    RIGHT_ALT_PRESSED = 0x0001</span>
<span class="gi">+    SHIFT_PRESSED = 0x0010</span>
<span class="gi">+    LEFT_CTRL_PRESSED = 0x0008</span>
<span class="gi">+    RIGHT_CTRL_PRESSED = 0x0004</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, recognize_paste: bool = True) -&gt; None:</span>
<span class="w"> </span>        self._fdcon = None
<span class="w"> </span>        self.recognize_paste = recognize_paste
<span class="gi">+</span>
<span class="gi">+        # When stdin is a tty, use that handle, otherwise, create a handle from</span>
<span class="gi">+        # CONIN$.</span>
<span class="w"> </span>        self.handle: HANDLE
<span class="w"> </span>        if sys.stdin.isatty():
<span class="gd">-            self.handle = HANDLE(windll.kernel32.GetStdHandle(STD_INPUT_HANDLE)</span>
<span class="gd">-                )</span>
<span class="gi">+            self.handle = HANDLE(windll.kernel32.GetStdHandle(STD_INPUT_HANDLE))</span>
<span class="w"> </span>        else:
<span class="gd">-            self._fdcon = os.open(&#39;CONIN$&#39;, os.O_RDWR | os.O_BINARY)</span>
<span class="gi">+            self._fdcon = os.open(&quot;CONIN$&quot;, os.O_RDWR | os.O_BINARY)</span>
<span class="w"> </span>            self.handle = HANDLE(msvcrt.get_osfhandle(self._fdcon))

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close fdcon.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        &quot;Close fdcon.&quot;</span>
<span class="gi">+        if self._fdcon is not None:</span>
<span class="gi">+            os.close(self._fdcon)</span>

<span class="gd">-    def read(self) -&gt;Iterable[KeyPress]:</span>
<span class="gi">+    def read(self) -&gt; Iterable[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of `KeyPress` instances. It won&#39;t return anything when
<span class="w"> </span>        there was nothing to read.  (This function doesn&#39;t block.)

<span class="w"> </span>        http://msdn.microsoft.com/en-us/library/windows/desktop/ms684961(v=vs.85).aspx
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        max_count = 2048  # Max events to read at the same time.</span>
<span class="gi">+</span>
<span class="gi">+        read = DWORD(0)</span>
<span class="gi">+        arrtype = INPUT_RECORD * max_count</span>
<span class="gi">+        input_records = arrtype()</span>
<span class="gi">+</span>
<span class="gi">+        # Check whether there is some input to read. `ReadConsoleInputW` would</span>
<span class="gi">+        # block otherwise.</span>
<span class="gi">+        # (Actually, the event loop is responsible to make sure that this</span>
<span class="gi">+        # function is only called when there is something to read, but for some</span>
<span class="gi">+        # reason this happened in the asyncio_win32 loop, and it&#39;s better to be</span>
<span class="gi">+        # safe anyway.)</span>
<span class="gi">+        if not wait_for_handles([self.handle], timeout=0):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Get next batch of input event.</span>
<span class="gi">+        windll.kernel32.ReadConsoleInputW(</span>
<span class="gi">+            self.handle, pointer(input_records), max_count, pointer(read)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # First, get all the keys from the input buffer, in order to determine</span>
<span class="gi">+        # whether we should consider this a paste event or not.</span>
<span class="gi">+        all_keys = list(self._get_keys(read, input_records))</span>
<span class="gi">+</span>
<span class="gi">+        # Fill in &#39;data&#39; for key presses.</span>
<span class="gi">+        all_keys = [self._insert_key_data(key) for key in all_keys]</span>
<span class="gi">+</span>
<span class="gi">+        # Correct non-bmp characters that are passed as separate surrogate codes</span>
<span class="gi">+        all_keys = list(self._merge_paired_surrogates(all_keys))</span>
<span class="gi">+</span>
<span class="gi">+        if self.recognize_paste and self._is_paste(all_keys):</span>
<span class="gi">+            gen = iter(all_keys)</span>
<span class="gi">+            k: KeyPress | None</span>
<span class="gi">+</span>
<span class="gi">+            for k in gen:</span>
<span class="gi">+                # Pasting: if the current key consists of text or \n, turn it</span>
<span class="gi">+                # into a BracketedPaste.</span>
<span class="gi">+                data = []</span>
<span class="gi">+                while k and (</span>
<span class="gi">+                    not isinstance(k.key, Keys)</span>
<span class="gi">+                    or k.key in {Keys.ControlJ, Keys.ControlM}</span>
<span class="gi">+                ):</span>
<span class="gi">+                    data.append(k.data)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        k = next(gen)</span>
<span class="gi">+                    except StopIteration:</span>
<span class="gi">+                        k = None</span>
<span class="gi">+</span>
<span class="gi">+                if data:</span>
<span class="gi">+                    yield KeyPress(Keys.BracketedPaste, &quot;&quot;.join(data))</span>
<span class="gi">+                if k is not None:</span>
<span class="gi">+                    yield k</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from all_keys</span>

<span class="gd">-    def _insert_key_data(self, key_press: KeyPress) -&gt;KeyPress:</span>
<span class="gi">+    def _insert_key_data(self, key_press: KeyPress) -&gt; KeyPress:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert KeyPress data, for vt100 compatibility.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key_press.data:</span>
<span class="gi">+            return key_press</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(key_press.key, Keys):</span>
<span class="gi">+            data = REVERSE_ANSI_SEQUENCES.get(key_press.key, &quot;&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = &quot;&quot;</span>

<span class="gd">-    def _get_keys(self, read: DWORD, input_records: Array[INPUT_RECORD]</span>
<span class="gd">-        ) -&gt;Iterator[KeyPress]:</span>
<span class="gi">+        return KeyPress(key_press.key, data)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_keys(</span>
<span class="gi">+        self, read: DWORD, input_records: Array[INPUT_RECORD]</span>
<span class="gi">+    ) -&gt; Iterator[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generator that yields `KeyPress` objects from the input records.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for i in range(read.value):</span>
<span class="gi">+            ir = input_records[i]</span>
<span class="gi">+</span>
<span class="gi">+            # Get the right EventType from the EVENT_RECORD.</span>
<span class="gi">+            # (For some reason the Windows console application &#39;cmder&#39;</span>
<span class="gi">+            # [http://gooseberrycreative.com/cmder/] can return &#39;0&#39; for</span>
<span class="gi">+            # ir.EventType. -- Just ignore that.)</span>
<span class="gi">+            if ir.EventType in EventTypes:</span>
<span class="gi">+                ev = getattr(ir.Event, EventTypes[ir.EventType])</span>
<span class="gi">+</span>
<span class="gi">+                # Process if this is a key event. (We also have mouse, menu and</span>
<span class="gi">+                # focus events.)</span>
<span class="gi">+                if isinstance(ev, KEY_EVENT_RECORD) and ev.KeyDown:</span>
<span class="gi">+                    yield from self._event_to_key_presses(ev)</span>
<span class="gi">+</span>
<span class="gi">+                elif isinstance(ev, MOUSE_EVENT_RECORD):</span>
<span class="gi">+                    yield from self._handle_mouse(ev)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _merge_paired_surrogates(key_presses: list[KeyPress]) -&gt;Iterator[</span>
<span class="gd">-        KeyPress]:</span>
<span class="gi">+    def _merge_paired_surrogates(key_presses: list[KeyPress]) -&gt; Iterator[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Combines consecutive KeyPresses with high and low surrogates into
<span class="w"> </span>        single characters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buffered_high_surrogate = None</span>
<span class="gi">+        for key in key_presses:</span>
<span class="gi">+            is_text = not isinstance(key.key, Keys)</span>
<span class="gi">+            is_high_surrogate = is_text and &quot;\uD800&quot; &lt;= key.key &lt;= &quot;\uDBFF&quot;</span>
<span class="gi">+            is_low_surrogate = is_text and &quot;\uDC00&quot; &lt;= key.key &lt;= &quot;\uDFFF&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if buffered_high_surrogate:</span>
<span class="gi">+                if is_low_surrogate:</span>
<span class="gi">+                    # convert high surrogate + low surrogate to single character</span>
<span class="gi">+                    fullchar = (</span>
<span class="gi">+                        (buffered_high_surrogate.key + key.key)</span>
<span class="gi">+                        .encode(&quot;utf-16-le&quot;, &quot;surrogatepass&quot;)</span>
<span class="gi">+                        .decode(&quot;utf-16-le&quot;)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    key = KeyPress(fullchar, fullchar)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield buffered_high_surrogate</span>
<span class="gi">+                buffered_high_surrogate = None</span>
<span class="gi">+</span>
<span class="gi">+            if is_high_surrogate:</span>
<span class="gi">+                buffered_high_surrogate = key</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield key</span>
<span class="gi">+</span>
<span class="gi">+        if buffered_high_surrogate:</span>
<span class="gi">+            yield buffered_high_surrogate</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_paste(keys: list[KeyPress]) -&gt;bool:</span>
<span class="gi">+    def _is_paste(keys: list[KeyPress]) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return `True` when we should consider this list of keys as a paste
<span class="w"> </span>        event. Pasted text on windows will be turned into a
<span class="gu">@@ -148,19 +362,197 @@ class ConsoleInputReader:</span>
<span class="w"> </span>        the best possible way to detect pasting of text and handle that
<span class="w"> </span>        correctly.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Consider paste when it contains at least one newline and at least one</span>
<span class="gi">+        # other character.</span>
<span class="gi">+        text_count = 0</span>
<span class="gi">+        newline_count = 0</span>
<span class="gi">+</span>
<span class="gi">+        for k in keys:</span>
<span class="gi">+            if not isinstance(k.key, Keys):</span>
<span class="gi">+                text_count += 1</span>
<span class="gi">+            if k.key == Keys.ControlM:</span>
<span class="gi">+                newline_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        return newline_count &gt;= 1 and text_count &gt;= 1</span>

<span class="gd">-    def _event_to_key_presses(self, ev: KEY_EVENT_RECORD) -&gt;list[KeyPress]:</span>
<span class="gi">+    def _event_to_key_presses(self, ev: KEY_EVENT_RECORD) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For this `KEY_EVENT_RECORD`, return a list of `KeyPress` instances.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert isinstance(ev, KEY_EVENT_RECORD) and ev.KeyDown</span>
<span class="gi">+</span>
<span class="gi">+        result: KeyPress | None = None</span>
<span class="gi">+</span>
<span class="gi">+        control_key_state = ev.ControlKeyState</span>
<span class="gi">+        u_char = ev.uChar.UnicodeChar</span>
<span class="gi">+        # Use surrogatepass because u_char may be an unmatched surrogate</span>
<span class="gi">+        ascii_char = u_char.encode(&quot;utf-8&quot;, &quot;surrogatepass&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: We don&#39;t use `ev.uChar.AsciiChar`. That appears to be the</span>
<span class="gi">+        # unicode code point truncated to 1 byte. See also:</span>
<span class="gi">+        # https://github.com/ipython/ipython/issues/10004</span>
<span class="gi">+        # https://github.com/jonathanslenders/python-prompt-toolkit/issues/389</span>
<span class="gi">+</span>
<span class="gi">+        if u_char == &quot;\x00&quot;:</span>
<span class="gi">+            if ev.VirtualKeyCode in self.keycodes:</span>
<span class="gi">+                result = KeyPress(self.keycodes[ev.VirtualKeyCode], &quot;&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if ascii_char in self.mappings:</span>
<span class="gi">+                if self.mappings[ascii_char] == Keys.ControlJ:</span>
<span class="gi">+                    u_char = (</span>
<span class="gi">+                        &quot;\n&quot;  # Windows sends \n, turn into \r for unix compatibility.</span>
<span class="gi">+                    )</span>
<span class="gi">+                result = KeyPress(self.mappings[ascii_char], u_char)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = KeyPress(u_char, u_char)</span>
<span class="gi">+</span>
<span class="gi">+        # First we handle Shift-Control-Arrow/Home/End (need to do this first)</span>
<span class="gi">+        if (</span>
<span class="gi">+            (</span>
<span class="gi">+                control_key_state &amp; self.LEFT_CTRL_PRESSED</span>
<span class="gi">+                or control_key_state &amp; self.RIGHT_CTRL_PRESSED</span>
<span class="gi">+            )</span>
<span class="gi">+            and control_key_state &amp; self.SHIFT_PRESSED</span>
<span class="gi">+            and result</span>
<span class="gi">+        ):</span>
<span class="gi">+            mapping: dict[str, str] = {</span>
<span class="gi">+                Keys.Left: Keys.ControlShiftLeft,</span>
<span class="gi">+                Keys.Right: Keys.ControlShiftRight,</span>
<span class="gi">+                Keys.Up: Keys.ControlShiftUp,</span>
<span class="gi">+                Keys.Down: Keys.ControlShiftDown,</span>
<span class="gi">+                Keys.Home: Keys.ControlShiftHome,</span>
<span class="gi">+                Keys.End: Keys.ControlShiftEnd,</span>
<span class="gi">+                Keys.Insert: Keys.ControlShiftInsert,</span>
<span class="gi">+                Keys.PageUp: Keys.ControlShiftPageUp,</span>
<span class="gi">+                Keys.PageDown: Keys.ControlShiftPageDown,</span>
<span class="gi">+            }</span>
<span class="gi">+            result.key = mapping.get(result.key, result.key)</span>
<span class="gi">+</span>
<span class="gi">+        # Correctly handle Control-Arrow/Home/End and Control-Insert/Delete keys.</span>
<span class="gi">+        if (</span>
<span class="gi">+            control_key_state &amp; self.LEFT_CTRL_PRESSED</span>
<span class="gi">+            or control_key_state &amp; self.RIGHT_CTRL_PRESSED</span>
<span class="gi">+        ) and result:</span>
<span class="gi">+            mapping = {</span>
<span class="gi">+                Keys.Left: Keys.ControlLeft,</span>
<span class="gi">+                Keys.Right: Keys.ControlRight,</span>
<span class="gi">+                Keys.Up: Keys.ControlUp,</span>
<span class="gi">+                Keys.Down: Keys.ControlDown,</span>
<span class="gi">+                Keys.Home: Keys.ControlHome,</span>
<span class="gi">+                Keys.End: Keys.ControlEnd,</span>
<span class="gi">+                Keys.Insert: Keys.ControlInsert,</span>
<span class="gi">+                Keys.Delete: Keys.ControlDelete,</span>
<span class="gi">+                Keys.PageUp: Keys.ControlPageUp,</span>
<span class="gi">+                Keys.PageDown: Keys.ControlPageDown,</span>
<span class="gi">+            }</span>
<span class="gi">+            result.key = mapping.get(result.key, result.key)</span>
<span class="gi">+</span>
<span class="gi">+        # Turn &#39;Tab&#39; into &#39;BackTab&#39; when shift was pressed.</span>
<span class="gi">+        # Also handle other shift-key combination</span>
<span class="gi">+        if control_key_state &amp; self.SHIFT_PRESSED and result:</span>
<span class="gi">+            mapping = {</span>
<span class="gi">+                Keys.Tab: Keys.BackTab,</span>
<span class="gi">+                Keys.Left: Keys.ShiftLeft,</span>
<span class="gi">+                Keys.Right: Keys.ShiftRight,</span>
<span class="gi">+                Keys.Up: Keys.ShiftUp,</span>
<span class="gi">+                Keys.Down: Keys.ShiftDown,</span>
<span class="gi">+                Keys.Home: Keys.ShiftHome,</span>
<span class="gi">+                Keys.End: Keys.ShiftEnd,</span>
<span class="gi">+                Keys.Insert: Keys.ShiftInsert,</span>
<span class="gi">+                Keys.Delete: Keys.ShiftDelete,</span>
<span class="gi">+                Keys.PageUp: Keys.ShiftPageUp,</span>
<span class="gi">+                Keys.PageDown: Keys.ShiftPageDown,</span>
<span class="gi">+            }</span>
<span class="gi">+            result.key = mapping.get(result.key, result.key)</span>
<span class="gi">+</span>
<span class="gi">+        # Turn &#39;Space&#39; into &#39;ControlSpace&#39; when control was pressed.</span>
<span class="gi">+        if (</span>
<span class="gi">+            (</span>
<span class="gi">+                control_key_state &amp; self.LEFT_CTRL_PRESSED</span>
<span class="gi">+                or control_key_state &amp; self.RIGHT_CTRL_PRESSED</span>
<span class="gi">+            )</span>
<span class="gi">+            and result</span>
<span class="gi">+            and result.data == &quot; &quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            result = KeyPress(Keys.ControlSpace, &quot; &quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Turn Control-Enter into META-Enter. (On a vt100 terminal, we cannot</span>
<span class="gi">+        # detect this combination. But it&#39;s really practical on Windows.)</span>
<span class="gi">+        if (</span>
<span class="gi">+            (</span>
<span class="gi">+                control_key_state &amp; self.LEFT_CTRL_PRESSED</span>
<span class="gi">+                or control_key_state &amp; self.RIGHT_CTRL_PRESSED</span>
<span class="gi">+            )</span>
<span class="gi">+            and result</span>
<span class="gi">+            and result.key == Keys.ControlJ</span>
<span class="gi">+        ):</span>
<span class="gi">+            return [KeyPress(Keys.Escape, &quot;&quot;), result]</span>
<span class="gi">+</span>
<span class="gi">+        # Return result. If alt was pressed, prefix the result with an</span>
<span class="gi">+        # &#39;Escape&#39; key, just like unix VT100 terminals do.</span>

<span class="gd">-    def _handle_mouse(self, ev: MOUSE_EVENT_RECORD) -&gt;list[KeyPress]:</span>
<span class="gi">+        # NOTE: Only replace the left alt with escape. The right alt key often</span>
<span class="gi">+        #       acts as altgr and is used in many non US keyboard layouts for</span>
<span class="gi">+        #       typing some special characters, like a backslash. We don&#39;t want</span>
<span class="gi">+        #       all backslashes to be prefixed with escape. (Esc-\ has a</span>
<span class="gi">+        #       meaning in E-macs, for instance.)</span>
<span class="gi">+        if result:</span>
<span class="gi">+            meta_pressed = control_key_state &amp; self.LEFT_ALT_PRESSED</span>
<span class="gi">+</span>
<span class="gi">+            if meta_pressed:</span>
<span class="gi">+                return [KeyPress(Keys.Escape, &quot;&quot;), result]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return [result]</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_mouse(self, ev: MOUSE_EVENT_RECORD) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle mouse events. Return a list of KeyPress instances.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        event_flags = ev.EventFlags</span>
<span class="gi">+        button_state = ev.ButtonState</span>
<span class="gi">+</span>
<span class="gi">+        event_type: MouseEventType | None = None</span>
<span class="gi">+        button: MouseButton = MouseButton.NONE</span>
<span class="gi">+</span>
<span class="gi">+        # Scroll events.</span>
<span class="gi">+        if event_flags &amp; MOUSE_WHEELED:</span>
<span class="gi">+            if button_state &gt; 0:</span>
<span class="gi">+                event_type = MouseEventType.SCROLL_UP</span>
<span class="gi">+            else:</span>
<span class="gi">+                event_type = MouseEventType.SCROLL_DOWN</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Handle button state for non-scroll events.</span>
<span class="gi">+            if button_state == FROM_LEFT_1ST_BUTTON_PRESSED:</span>
<span class="gi">+                button = MouseButton.LEFT</span>
<span class="gi">+</span>
<span class="gi">+            elif button_state == RIGHTMOST_BUTTON_PRESSED:</span>
<span class="gi">+                button = MouseButton.RIGHT</span>
<span class="gi">+</span>
<span class="gi">+        # Move events.</span>
<span class="gi">+        if event_flags &amp; MOUSE_MOVED:</span>
<span class="gi">+            event_type = MouseEventType.MOUSE_MOVE</span>
<span class="gi">+</span>
<span class="gi">+        # No key pressed anymore: mouse up.</span>
<span class="gi">+        if event_type is None:</span>
<span class="gi">+            if button_state &gt; 0:</span>
<span class="gi">+                # Some button pressed.</span>
<span class="gi">+                event_type = MouseEventType.MOUSE_DOWN</span>
<span class="gi">+            else:</span>
<span class="gi">+                # No button pressed.</span>
<span class="gi">+                event_type = MouseEventType.MOUSE_UP</span>
<span class="gi">+</span>
<span class="gi">+        data = &quot;;&quot;.join(</span>
<span class="gi">+            [</span>
<span class="gi">+                button.value,</span>
<span class="gi">+                event_type.value,</span>
<span class="gi">+                str(ev.MousePosition.X),</span>
<span class="gi">+                str(ev.MousePosition.Y),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+        return [KeyPress(Keys.WindowsMouseEvent, data)]</span>


<span class="w"> </span>class _Win32Handles:
<span class="gu">@@ -179,36 +571,122 @@ class _Win32Handles:</span>
<span class="w"> </span>          mechanism (used by IPython), only works with the `SelectorEventLoop`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._handle_callbacks: dict[int, Callable[[], None]] = {}
<span class="gi">+</span>
<span class="gi">+        # Windows Events that are triggered when we have to stop watching this</span>
<span class="gi">+        # handle.</span>
<span class="w"> </span>        self._remove_events: dict[int, HANDLE] = {}

<span class="gd">-    def add_win32_handle(self, handle: HANDLE, callback: Callable[[], None]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_win32_handle(self, handle: HANDLE, callback: Callable[[], None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a Win32 handle to the event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def remove_win32_handle(self, handle: HANDLE) -&gt;(Callable[[], None] | None</span>
<span class="gd">-        ):</span>
<span class="gi">+        handle_value = handle.value</span>
<span class="gi">+</span>
<span class="gi">+        if handle_value is None:</span>
<span class="gi">+            raise ValueError(&quot;Invalid handle.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure to remove a previous registered handler first.</span>
<span class="gi">+        self.remove_win32_handle(handle)</span>
<span class="gi">+</span>
<span class="gi">+        loop = get_running_loop()</span>
<span class="gi">+        self._handle_callbacks[handle_value] = callback</span>
<span class="gi">+</span>
<span class="gi">+        # Create remove event.</span>
<span class="gi">+        remove_event = create_win32_event()</span>
<span class="gi">+        self._remove_events[handle_value] = remove_event</span>
<span class="gi">+</span>
<span class="gi">+        # Add reader.</span>
<span class="gi">+        def ready() -&gt; None:</span>
<span class="gi">+            # Tell the callback that input&#39;s ready.</span>
<span class="gi">+            try:</span>
<span class="gi">+                callback()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                run_in_executor_with_context(wait, loop=loop)</span>
<span class="gi">+</span>
<span class="gi">+        # Wait for the input to become ready.</span>
<span class="gi">+        # (Use an executor for this, the Windows asyncio event loop doesn&#39;t</span>
<span class="gi">+        # allow us to wait for handles like stdin.)</span>
<span class="gi">+        def wait() -&gt; None:</span>
<span class="gi">+            # Wait until either the handle becomes ready, or the remove event</span>
<span class="gi">+            # has been set.</span>
<span class="gi">+            result = wait_for_handles([remove_event, handle])</span>
<span class="gi">+</span>
<span class="gi">+            if result is remove_event:</span>
<span class="gi">+                windll.kernel32.CloseHandle(remove_event)</span>
<span class="gi">+                return</span>
<span class="gi">+            else:</span>
<span class="gi">+                loop.call_soon_threadsafe(ready)</span>
<span class="gi">+</span>
<span class="gi">+        run_in_executor_with_context(wait, loop=loop)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_win32_handle(self, handle: HANDLE) -&gt; Callable[[], None] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove a Win32 handle from the event loop.
<span class="w"> </span>        Return either the registered handler or `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if handle.value is None:</span>
<span class="gi">+            return None  # Ignore.</span>
<span class="gi">+</span>
<span class="gi">+        # Trigger remove events, so that the reader knows to stop.</span>
<span class="gi">+        try:</span>
<span class="gi">+            event = self._remove_events.pop(handle.value)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            windll.kernel32.SetEvent(event)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._handle_callbacks.pop(handle.value)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def attach_win32_input(input: _Win32InputBase, callback: Callable[[], None]</span>
<span class="gd">-    ) -&gt;Iterator[None]:</span>
<span class="gi">+def attach_win32_input(</span>
<span class="gi">+    input: _Win32InputBase, callback: Callable[[], None]</span>
<span class="gi">+) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Context manager that makes this input active in the current event loop.

<span class="w"> </span>    :param input: :class:`~prompt_toolkit.input.Input` object.
<span class="w"> </span>    :param input_ready_callback: Called when the input is ready to read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    win32_handles = input.win32_handles</span>
<span class="gi">+    handle = input.handle</span>
<span class="gi">+</span>
<span class="gi">+    if handle.value is None:</span>
<span class="gi">+        raise ValueError(&quot;Invalid handle.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Add reader.</span>
<span class="gi">+    previous_callback = win32_handles.remove_win32_handle(handle)</span>
<span class="gi">+    win32_handles.add_win32_handle(handle, callback)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        win32_handles.remove_win32_handle(handle)</span>
<span class="gi">+</span>
<span class="gi">+        if previous_callback:</span>
<span class="gi">+            win32_handles.add_win32_handle(handle, previous_callback)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def detach_win32_input(input: _Win32InputBase) -&gt; Iterator[None]:</span>
<span class="gi">+    win32_handles = input.win32_handles</span>
<span class="gi">+    handle = input.handle</span>
<span class="gi">+</span>
<span class="gi">+    if handle.value is None:</span>
<span class="gi">+        raise ValueError(&quot;Invalid handle.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    previous_callback = win32_handles.remove_win32_handle(handle)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if previous_callback:</span>
<span class="gi">+            win32_handles.add_win32_handle(handle, previous_callback)</span>


<span class="w"> </span>class raw_mode:
<span class="gu">@@ -222,16 +700,31 @@ class raw_mode:</span>
<span class="w"> </span>    `raw_input` method of `.vt100_input`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, fileno: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, fileno: int | None = None) -&gt; None:</span>
<span class="w"> </span>        self.handle = HANDLE(windll.kernel32.GetStdHandle(STD_INPUT_HANDLE))

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="gi">+        # Remember original mode.</span>
<span class="w"> </span>        original_mode = DWORD()
<span class="w"> </span>        windll.kernel32.GetConsoleMode(self.handle, pointer(original_mode))
<span class="w"> </span>        self.original_mode = original_mode
<span class="gi">+</span>
<span class="w"> </span>        self._patch()

<span class="gd">-    def __exit__(self, *a: object) -&gt;None:</span>
<span class="gi">+    def _patch(self) -&gt; None:</span>
<span class="gi">+        # Set raw</span>
<span class="gi">+        ENABLE_ECHO_INPUT = 0x0004</span>
<span class="gi">+        ENABLE_LINE_INPUT = 0x0002</span>
<span class="gi">+        ENABLE_PROCESSED_INPUT = 0x0001</span>
<span class="gi">+</span>
<span class="gi">+        windll.kernel32.SetConsoleMode(</span>
<span class="gi">+            self.handle,</span>
<span class="gi">+            self.original_mode.value</span>
<span class="gi">+            &amp; ~(ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __exit__(self, *a: object) -&gt; None:</span>
<span class="gi">+        # Restore original mode</span>
<span class="w"> </span>        windll.kernel32.SetConsoleMode(self.handle, self.original_mode)


<span class="gu">@@ -242,3 +735,15 @@ class cooked_mode(raw_mode):</span>
<span class="w"> </span>        with cooked_mode(stdin):
<span class="w"> </span>            &#39;&#39;&#39; The pseudo-terminal stdin is now used in cooked mode. &#39;&#39;&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _patch(self) -&gt; None:</span>
<span class="gi">+        # Set cooked.</span>
<span class="gi">+        ENABLE_ECHO_INPUT = 0x0004</span>
<span class="gi">+        ENABLE_LINE_INPUT = 0x0002</span>
<span class="gi">+        ENABLE_PROCESSED_INPUT = 0x0001</span>
<span class="gi">+</span>
<span class="gi">+        windll.kernel32.SetConsoleMode(</span>
<span class="gi">+            self.handle,</span>
<span class="gi">+            self.original_mode.value</span>
<span class="gi">+            | (ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT),</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/win32_pipe.py b/src/prompt_toolkit/input/win32_pipe.py</span>
<span class="gh">index 740ea177..0bafa49e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/win32_pipe.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/win32_pipe.py</span>
<span class="gu">@@ -1,17 +1,23 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from ctypes import windll
<span class="w"> </span>from ctypes.wintypes import HANDLE
<span class="w"> </span>from typing import Callable, ContextManager, Iterator
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.eventloop.win32 import create_win32_event
<span class="gi">+</span>
<span class="w"> </span>from ..key_binding import KeyPress
<span class="w"> </span>from ..utils import DummyContext
<span class="w"> </span>from .base import PipeInput
<span class="w"> </span>from .vt100_parser import Vt100Parser
<span class="w"> </span>from .win32 import _Win32InputBase, attach_win32_input, detach_win32_input
<span class="gd">-__all__ = [&#39;Win32PipeInput&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;Win32PipeInput&quot;]</span>


<span class="w"> </span>class Win32PipeInput(_Win32InputBase, PipeInput):
<span class="gu">@@ -29,68 +35,122 @@ class Win32PipeInput(_Win32InputBase, PipeInput):</span>
<span class="w"> </span>        input = Win32PipeInput()
<span class="w"> </span>        input.send_text(&#39;inputdata&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _id = 0

<span class="gd">-    def __init__(self, _event: HANDLE) -&gt;None:</span>
<span class="gi">+    def __init__(self, _event: HANDLE) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+        # Event (handle) for registering this input in the event loop.</span>
<span class="gi">+        # This event is set when there is data available to read from the pipe.</span>
<span class="gi">+        # Note: We use this approach instead of using a regular pipe, like</span>
<span class="gi">+        #       returned from `os.pipe()`, because making such a regular pipe</span>
<span class="gi">+        #       non-blocking is tricky and this works really well.</span>
<span class="w"> </span>        self._event = create_win32_event()
<span class="gi">+</span>
<span class="w"> </span>        self._closed = False
<span class="gd">-        self._buffer: list[KeyPress] = []</span>
<span class="gi">+</span>
<span class="gi">+        # Parser for incoming keys.</span>
<span class="gi">+        self._buffer: list[KeyPress] = []  # Buffer to collect the Key objects.</span>
<span class="w"> </span>        self.vt100_parser = Vt100Parser(lambda key: self._buffer.append(key))
<span class="gi">+</span>
<span class="gi">+        # Identifier for every PipeInput for the hash.</span>
<span class="w"> </span>        self.__class__._id += 1
<span class="w"> </span>        self._id = self.__class__._id

<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def create(cls) -&gt; Iterator[Win32PipeInput]:</span>
<span class="gi">+        event = create_win32_event()</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield Win32PipeInput(_event=event)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            windll.kernel32.CloseHandle(event)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="gi">+        return self._closed</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The windows pipe doesn&#39;t depend on the file handle.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @property
<span class="gd">-    def handle(self) -&gt;HANDLE:</span>
<span class="gd">-        &quot;&quot;&quot;The handle used for registering this pipe in the event loop.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def handle(self) -&gt; HANDLE:</span>
<span class="gi">+        &quot;The handle used for registering this pipe in the event loop.&quot;</span>
<span class="gi">+        return self._event</span>

<span class="gd">-    def attach(self, input_ready_callback: Callable[[], None]</span>
<span class="gd">-        ) -&gt;ContextManager[None]:</span>
<span class="gi">+    def attach(self, input_ready_callback: Callable[[], None]) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return attach_win32_input(self, input_ready_callback)</span>

<span class="gd">-    def detach(self) -&gt;ContextManager[None]:</span>
<span class="gi">+    def detach(self) -&gt; ContextManager[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return detach_win32_input(self)</span>
<span class="gi">+</span>
<span class="gi">+    def read_keys(self) -&gt; list[KeyPress]:</span>
<span class="gi">+        &quot;Read list of KeyPress.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Return result.</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+</span>
<span class="gi">+        # Reset event.</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            # (If closed, the event should not reset.)</span>
<span class="gi">+            windll.kernel32.ResetEvent(self._event)</span>

<span class="gd">-    def read_keys(self) -&gt;list[KeyPress]:</span>
<span class="gd">-        &quot;&quot;&quot;Read list of KeyPress.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return result</span>

<span class="gd">-    def flush_keys(self) -&gt;list[KeyPress]:</span>
<span class="gi">+    def flush_keys(self) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush pending keys and return them.
<span class="w"> </span>        (Used for flushing the &#39;escape&#39; key.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Flush all pending keys. (This is most important to flush the vt100</span>
<span class="gi">+        # &#39;Escape&#39; key early when nothing else follows.)</span>
<span class="gi">+        self.vt100_parser.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Return result.</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def send_bytes(self, data: bytes) -&gt; None:</span>
<span class="gi">+        &quot;Send bytes to the input.&quot;</span>
<span class="gi">+        self.send_text(data.decode(&quot;utf-8&quot;, &quot;ignore&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def send_text(self, text: str) -&gt; None:</span>
<span class="gi">+        &quot;Send text to the input.&quot;</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise ValueError(&quot;Attempt to write into a closed pipe.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Pass it through our vt100 parser.</span>
<span class="gi">+        self.vt100_parser.feed(text)</span>
<span class="gi">+</span>
<span class="gi">+        # Set event.</span>
<span class="gi">+        windll.kernel32.SetEvent(self._event)</span>

<span class="gd">-    def send_bytes(self, data: bytes) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Send bytes to the input.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def raw_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return DummyContext()</span>

<span class="gd">-    def send_text(self, text: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Send text to the input.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cooked_mode(self) -&gt; ContextManager[None]:</span>
<span class="gi">+        return DummyContext()</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Close write-end of the pipe.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        &quot;Close write-end of the pipe.&quot;</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+        windll.kernel32.SetEvent(self._event)</span>

<span class="gd">-    def typeahead_hash(self) -&gt;str:</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This needs to be unique for every `PipeInput`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;pipe-input-{self._id}&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/auto_suggest.py b/src/prompt_toolkit/key_binding/bindings/auto_suggest.py</span>
<span class="gh">index 67735983..3d8a843d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/auto_suggest.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/auto_suggest.py</span>
<span class="gu">@@ -2,16 +2,22 @@</span>
<span class="w"> </span>Key bindings for auto suggestion (for fish-style auto suggestion).
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.filters import Condition, emacs_mode
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import KeyBindings
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="gd">-__all__ = [&#39;load_auto_suggest_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_auto_suggest_bindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def load_auto_suggest_bindings() -&gt;KeyBindings:</span>
<span class="gi">+def load_auto_suggest_bindings() -&gt; KeyBindings:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Key bindings for accepting auto suggestion text.

<span class="gu">@@ -19,4 +25,41 @@ def load_auto_suggest_bindings() -&gt;KeyBindings:</span>
<span class="w"> </span>    implementation for the &quot;right arrow&quot;, but we really want the suggestion
<span class="w"> </span>    binding when a suggestion is available.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def suggestion_available() -&gt; bool:</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        return (</span>
<span class="gi">+            app.current_buffer.suggestion is not None</span>
<span class="gi">+            and len(app.current_buffer.suggestion.text) &gt; 0</span>
<span class="gi">+            and app.current_buffer.document.is_cursor_at_the_end</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-f&quot;, filter=suggestion_available)</span>
<span class="gi">+    @handle(&quot;c-e&quot;, filter=suggestion_available)</span>
<span class="gi">+    @handle(&quot;right&quot;, filter=suggestion_available)</span>
<span class="gi">+    def _accept(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Accept suggestion.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        suggestion = b.suggestion</span>
<span class="gi">+</span>
<span class="gi">+        if suggestion:</span>
<span class="gi">+            b.insert_text(suggestion.text)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;f&quot;, filter=suggestion_available &amp; emacs_mode)</span>
<span class="gi">+    def _fill(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Fill partial suggestion.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        suggestion = b.suggestion</span>
<span class="gi">+</span>
<span class="gi">+        if suggestion:</span>
<span class="gi">+            t = re.split(r&quot;([^\s/]+(?:\s+|/))&quot;, suggestion.text)</span>
<span class="gi">+            b.insert_text(next(x for x in t if x))</span>
<span class="gi">+</span>
<span class="gi">+    return key_bindings</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/basic.py b/src/prompt_toolkit/key_binding/bindings/basic.py</span>
<span class="gh">index 9c3870ef..084548d6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/basic.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/basic.py</span>
<span class="gu">@@ -1,15 +1,255 @@</span>
<span class="gi">+# pylint: disable=function-redefined</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="gd">-from prompt_toolkit.filters import Condition, emacs_insert_mode, has_selection, in_paste_mode, is_multiline, vi_insert_mode</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    emacs_insert_mode,</span>
<span class="gi">+    has_selection,</span>
<span class="gi">+    in_paste_mode,</span>
<span class="gi">+    is_multiline,</span>
<span class="gi">+    vi_insert_mode,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPress, KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import KeyBindings
<span class="w"> </span>from .named_commands import get_by_name
<span class="gd">-__all__ = [&#39;load_basic_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_basic_bindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def if_no_repeat(event: E) -&gt;bool:</span>
<span class="gi">+def if_no_repeat(event: E) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Callable that returns True when the previous event was delivered to
<span class="w"> </span>    another handler.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not event.is_repeat</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_basic_bindings() -&gt; KeyBindings:</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    insert_mode = vi_insert_mode | emacs_insert_mode</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-a&quot;)</span>
<span class="gi">+    @handle(&quot;c-b&quot;)</span>
<span class="gi">+    @handle(&quot;c-c&quot;)</span>
<span class="gi">+    @handle(&quot;c-d&quot;)</span>
<span class="gi">+    @handle(&quot;c-e&quot;)</span>
<span class="gi">+    @handle(&quot;c-f&quot;)</span>
<span class="gi">+    @handle(&quot;c-g&quot;)</span>
<span class="gi">+    @handle(&quot;c-h&quot;)</span>
<span class="gi">+    @handle(&quot;c-i&quot;)</span>
<span class="gi">+    @handle(&quot;c-j&quot;)</span>
<span class="gi">+    @handle(&quot;c-k&quot;)</span>
<span class="gi">+    @handle(&quot;c-l&quot;)</span>
<span class="gi">+    @handle(&quot;c-m&quot;)</span>
<span class="gi">+    @handle(&quot;c-n&quot;)</span>
<span class="gi">+    @handle(&quot;c-o&quot;)</span>
<span class="gi">+    @handle(&quot;c-p&quot;)</span>
<span class="gi">+    @handle(&quot;c-q&quot;)</span>
<span class="gi">+    @handle(&quot;c-r&quot;)</span>
<span class="gi">+    @handle(&quot;c-s&quot;)</span>
<span class="gi">+    @handle(&quot;c-t&quot;)</span>
<span class="gi">+    @handle(&quot;c-u&quot;)</span>
<span class="gi">+    @handle(&quot;c-v&quot;)</span>
<span class="gi">+    @handle(&quot;c-w&quot;)</span>
<span class="gi">+    @handle(&quot;c-x&quot;)</span>
<span class="gi">+    @handle(&quot;c-y&quot;)</span>
<span class="gi">+    @handle(&quot;c-z&quot;)</span>
<span class="gi">+    @handle(&quot;f1&quot;)</span>
<span class="gi">+    @handle(&quot;f2&quot;)</span>
<span class="gi">+    @handle(&quot;f3&quot;)</span>
<span class="gi">+    @handle(&quot;f4&quot;)</span>
<span class="gi">+    @handle(&quot;f5&quot;)</span>
<span class="gi">+    @handle(&quot;f6&quot;)</span>
<span class="gi">+    @handle(&quot;f7&quot;)</span>
<span class="gi">+    @handle(&quot;f8&quot;)</span>
<span class="gi">+    @handle(&quot;f9&quot;)</span>
<span class="gi">+    @handle(&quot;f10&quot;)</span>
<span class="gi">+    @handle(&quot;f11&quot;)</span>
<span class="gi">+    @handle(&quot;f12&quot;)</span>
<span class="gi">+    @handle(&quot;f13&quot;)</span>
<span class="gi">+    @handle(&quot;f14&quot;)</span>
<span class="gi">+    @handle(&quot;f15&quot;)</span>
<span class="gi">+    @handle(&quot;f16&quot;)</span>
<span class="gi">+    @handle(&quot;f17&quot;)</span>
<span class="gi">+    @handle(&quot;f18&quot;)</span>
<span class="gi">+    @handle(&quot;f19&quot;)</span>
<span class="gi">+    @handle(&quot;f20&quot;)</span>
<span class="gi">+    @handle(&quot;f21&quot;)</span>
<span class="gi">+    @handle(&quot;f22&quot;)</span>
<span class="gi">+    @handle(&quot;f23&quot;)</span>
<span class="gi">+    @handle(&quot;f24&quot;)</span>
<span class="gi">+    @handle(&quot;c-@&quot;)  # Also c-space.</span>
<span class="gi">+    @handle(&quot;c-\\&quot;)</span>
<span class="gi">+    @handle(&quot;c-]&quot;)</span>
<span class="gi">+    @handle(&quot;c-^&quot;)</span>
<span class="gi">+    @handle(&quot;c-_&quot;)</span>
<span class="gi">+    @handle(&quot;backspace&quot;)</span>
<span class="gi">+    @handle(&quot;up&quot;)</span>
<span class="gi">+    @handle(&quot;down&quot;)</span>
<span class="gi">+    @handle(&quot;right&quot;)</span>
<span class="gi">+    @handle(&quot;left&quot;)</span>
<span class="gi">+    @handle(&quot;s-up&quot;)</span>
<span class="gi">+    @handle(&quot;s-down&quot;)</span>
<span class="gi">+    @handle(&quot;s-right&quot;)</span>
<span class="gi">+    @handle(&quot;s-left&quot;)</span>
<span class="gi">+    @handle(&quot;home&quot;)</span>
<span class="gi">+    @handle(&quot;end&quot;)</span>
<span class="gi">+    @handle(&quot;s-home&quot;)</span>
<span class="gi">+    @handle(&quot;s-end&quot;)</span>
<span class="gi">+    @handle(&quot;delete&quot;)</span>
<span class="gi">+    @handle(&quot;s-delete&quot;)</span>
<span class="gi">+    @handle(&quot;c-delete&quot;)</span>
<span class="gi">+    @handle(&quot;pageup&quot;)</span>
<span class="gi">+    @handle(&quot;pagedown&quot;)</span>
<span class="gi">+    @handle(&quot;s-tab&quot;)</span>
<span class="gi">+    @handle(&quot;tab&quot;)</span>
<span class="gi">+    @handle(&quot;c-s-left&quot;)</span>
<span class="gi">+    @handle(&quot;c-s-right&quot;)</span>
<span class="gi">+    @handle(&quot;c-s-home&quot;)</span>
<span class="gi">+    @handle(&quot;c-s-end&quot;)</span>
<span class="gi">+    @handle(&quot;c-left&quot;)</span>
<span class="gi">+    @handle(&quot;c-right&quot;)</span>
<span class="gi">+    @handle(&quot;c-up&quot;)</span>
<span class="gi">+    @handle(&quot;c-down&quot;)</span>
<span class="gi">+    @handle(&quot;c-home&quot;)</span>
<span class="gi">+    @handle(&quot;c-end&quot;)</span>
<span class="gi">+    @handle(&quot;insert&quot;)</span>
<span class="gi">+    @handle(&quot;s-insert&quot;)</span>
<span class="gi">+    @handle(&quot;c-insert&quot;)</span>
<span class="gi">+    @handle(&quot;&lt;sigint&gt;&quot;)</span>
<span class="gi">+    @handle(Keys.Ignore)</span>
<span class="gi">+    def _ignore(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        First, for any of these keys, Don&#39;t do anything by default. Also don&#39;t</span>
<span class="gi">+        catch them in the &#39;Any&#39; handler which will insert them as data.</span>
<span class="gi">+</span>
<span class="gi">+        If people want to insert these characters as a literal, they can always</span>
<span class="gi">+        do by doing a quoted insert. (ControlQ in emacs mode, ControlV in Vi</span>
<span class="gi">+        mode.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Readline-style bindings.</span>
<span class="gi">+    handle(&quot;home&quot;)(get_by_name(&quot;beginning-of-line&quot;))</span>
<span class="gi">+    handle(&quot;end&quot;)(get_by_name(&quot;end-of-line&quot;))</span>
<span class="gi">+    handle(&quot;left&quot;)(get_by_name(&quot;backward-char&quot;))</span>
<span class="gi">+    handle(&quot;right&quot;)(get_by_name(&quot;forward-char&quot;))</span>
<span class="gi">+    handle(&quot;c-up&quot;)(get_by_name(&quot;previous-history&quot;))</span>
<span class="gi">+    handle(&quot;c-down&quot;)(get_by_name(&quot;next-history&quot;))</span>
<span class="gi">+    handle(&quot;c-l&quot;)(get_by_name(&quot;clear-screen&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-k&quot;, filter=insert_mode)(get_by_name(&quot;kill-line&quot;))</span>
<span class="gi">+    handle(&quot;c-u&quot;, filter=insert_mode)(get_by_name(&quot;unix-line-discard&quot;))</span>
<span class="gi">+    handle(&quot;backspace&quot;, filter=insert_mode, save_before=if_no_repeat)(</span>
<span class="gi">+        get_by_name(&quot;backward-delete-char&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(&quot;delete&quot;, filter=insert_mode, save_before=if_no_repeat)(</span>
<span class="gi">+        get_by_name(&quot;delete-char&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(&quot;c-delete&quot;, filter=insert_mode, save_before=if_no_repeat)(</span>
<span class="gi">+        get_by_name(&quot;delete-char&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(Keys.Any, filter=insert_mode, save_before=if_no_repeat)(</span>
<span class="gi">+        get_by_name(&quot;self-insert&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(&quot;c-t&quot;, filter=insert_mode)(get_by_name(&quot;transpose-chars&quot;))</span>
<span class="gi">+    handle(&quot;c-i&quot;, filter=insert_mode)(get_by_name(&quot;menu-complete&quot;))</span>
<span class="gi">+    handle(&quot;s-tab&quot;, filter=insert_mode)(get_by_name(&quot;menu-complete-backward&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    # Control-W should delete, using whitespace as separator, while M-Del</span>
<span class="gi">+    # should delete using [^a-zA-Z0-9] as a boundary.</span>
<span class="gi">+    handle(&quot;c-w&quot;, filter=insert_mode)(get_by_name(&quot;unix-word-rubout&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;pageup&quot;, filter=~has_selection)(get_by_name(&quot;previous-history&quot;))</span>
<span class="gi">+    handle(&quot;pagedown&quot;, filter=~has_selection)(get_by_name(&quot;next-history&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    # CTRL keys.</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def has_text_before_cursor() -&gt; bool:</span>
<span class="gi">+        return bool(get_app().current_buffer.text)</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-d&quot;, filter=has_text_before_cursor &amp; insert_mode)(</span>
<span class="gi">+        get_by_name(&quot;delete-char&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;enter&quot;, filter=insert_mode &amp; is_multiline)</span>
<span class="gi">+    def _newline(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Newline (in case of multiline input.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.newline(copy_margin=not in_paste_mode())</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-j&quot;)</span>
<span class="gi">+    def _newline2(event: E) -&gt; None:</span>
<span class="gi">+        r&quot;&quot;&quot;</span>
<span class="gi">+        By default, handle \n as if it were a \r (enter).</span>
<span class="gi">+        (It appears that some terminals send \n instead of \r when pressing</span>
<span class="gi">+        enter. - at least the Linux subsystem for Windows.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.key_processor.feed(KeyPress(Keys.ControlM, &quot;\r&quot;), first=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Delete the word before the cursor.</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;up&quot;)</span>
<span class="gi">+    def _go_up(event: E) -&gt; None:</span>
<span class="gi">+        event.current_buffer.auto_up(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;down&quot;)</span>
<span class="gi">+    def _go_down(event: E) -&gt; None:</span>
<span class="gi">+        event.current_buffer.auto_down(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;delete&quot;, filter=has_selection)</span>
<span class="gi">+    def _cut(event: E) -&gt; None:</span>
<span class="gi">+        data = event.current_buffer.cut_selection()</span>
<span class="gi">+        event.app.clipboard.set_data(data)</span>
<span class="gi">+</span>
<span class="gi">+    # Global bindings.</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-z&quot;)</span>
<span class="gi">+    def _insert_ctrl_z(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        By default, control-Z should literally insert Ctrl-Z.</span>
<span class="gi">+        (Ansi Ctrl-Z, code 26 in MSDOS means End-Of-File.</span>
<span class="gi">+        In a Python REPL for instance, it&#39;s possible to type</span>
<span class="gi">+        Control-Z followed by enter to quit.)</span>
<span class="gi">+</span>
<span class="gi">+        When the system bindings are loaded and suspend-to-background is</span>
<span class="gi">+        supported, that will override this binding.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.insert_text(event.data)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.BracketedPaste)</span>
<span class="gi">+    def _paste(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Pasting from clipboard.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        data = event.data</span>
<span class="gi">+</span>
<span class="gi">+        # Be sure to use \n as line ending.</span>
<span class="gi">+        # Some terminals (Like iTerm2) seem to paste \r\n line endings in a</span>
<span class="gi">+        # bracketed paste. See: https://github.com/ipython/ipython/issues/9737</span>
<span class="gi">+        data = data.replace(&quot;\r\n&quot;, &quot;\n&quot;)</span>
<span class="gi">+        data = data.replace(&quot;\r&quot;, &quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        event.current_buffer.insert_text(data)</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def in_quoted_insert() -&gt; bool:</span>
<span class="gi">+        return get_app().quoted_insert</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=in_quoted_insert, eager=True)</span>
<span class="gi">+    def _insert_text(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Handle quoted insert.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.insert_text(event.data, overwrite=False)</span>
<span class="gi">+        event.app.quoted_insert = False</span>
<span class="gi">+</span>
<span class="gi">+    return key_bindings</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/completion.py b/src/prompt_toolkit/key_binding/bindings/completion.py</span>
<span class="gh">index e88dca52..016821f4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/completion.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/completion.py</span>
<span class="gu">@@ -2,32 +2,50 @@</span>
<span class="w"> </span>Key binding handlers for displaying completions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import math
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.run_in_terminal import in_terminal
<span class="gd">-from prompt_toolkit.completion import CompleteEvent, Completion, get_common_complete_suffix</span>
<span class="gi">+from prompt_toolkit.completion import (</span>
<span class="gi">+    CompleteEvent,</span>
<span class="gi">+    Completion,</span>
<span class="gi">+    get_common_complete_suffix,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.formatted_text import StyleAndTextTuples
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import KeyBindings
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.application import Application
<span class="w"> </span>    from prompt_toolkit.shortcuts import PromptSession
<span class="gd">-__all__ = [&#39;generate_completions&#39;, &#39;display_completions_like_readline&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;generate_completions&quot;,</span>
<span class="gi">+    &quot;display_completions_like_readline&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def generate_completions(event: E) -&gt;None:</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+def generate_completions(event: E) -&gt; None:</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    Tab-completion: where the first tab completes the common suffix and the
<span class="w"> </span>    second tab lists all the completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b = event.current_buffer</span>

<span class="gi">+    # When already navigating through completions, select the next one.</span>
<span class="gi">+    if b.complete_state:</span>
<span class="gi">+        b.complete_next()</span>
<span class="gi">+    else:</span>
<span class="gi">+        b.start_completion(insert_common_part=True)</span>

<span class="gd">-def display_completions_like_readline(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def display_completions_like_readline(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Key binding handler for readline-style tab completion.
<span class="w"> </span>    This is meant to be as similar as possible to the way how readline displays
<span class="gu">@@ -41,21 +59,147 @@ def display_completions_like_readline(event: E) -&gt;None:</span>
<span class="w"> </span>        # Call this handler when &#39;Tab&#39; has been pressed.
<span class="w"> </span>        key_bindings.add(Keys.ControlI)(display_completions_like_readline)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Request completions.</span>
<span class="gi">+    b = event.current_buffer</span>
<span class="gi">+    if b.completer is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    complete_event = CompleteEvent(completion_requested=True)</span>
<span class="gi">+    completions = list(b.completer.get_completions(b.document, complete_event))</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate the common suffix.</span>
<span class="gi">+    common_suffix = get_common_complete_suffix(b.document, completions)</span>

<span class="gi">+    # One completion: insert it.</span>
<span class="gi">+    if len(completions) == 1:</span>
<span class="gi">+        b.delete_before_cursor(-completions[0].start_position)</span>
<span class="gi">+        b.insert_text(completions[0].text)</span>
<span class="gi">+    # Multiple completions with common part.</span>
<span class="gi">+    elif common_suffix:</span>
<span class="gi">+        b.insert_text(common_suffix)</span>
<span class="gi">+    # Otherwise: display all completions.</span>
<span class="gi">+    elif completions:</span>
<span class="gi">+        _display_completions_like_readline(event.app, completions)</span>

<span class="gd">-def _display_completions_like_readline(app: Application[object],</span>
<span class="gd">-    completions: list[Completion]) -&gt;asyncio.Task[None]:</span>
<span class="gi">+</span>
<span class="gi">+def _display_completions_like_readline(</span>
<span class="gi">+    app: Application[object], completions: list[Completion]</span>
<span class="gi">+) -&gt; asyncio.Task[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display the list of completions in columns above the prompt.
<span class="w"> </span>    This will ask for a confirmation if there are too many completions to fit
<span class="w"> </span>    on a single page and provide a paginator to walk through them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.formatted_text import to_formatted_text</span>
<span class="gi">+    from prompt_toolkit.shortcuts.prompt import create_confirm_session</span>
<span class="gi">+</span>
<span class="gi">+    # Get terminal dimensions.</span>
<span class="gi">+    term_size = app.output.get_size()</span>
<span class="gi">+    term_width = term_size.columns</span>
<span class="gi">+    term_height = term_size.rows</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate amount of required columns/rows for displaying the</span>
<span class="gi">+    # completions. (Keep in mind that completions are displayed</span>
<span class="gi">+    # alphabetically column-wise.)</span>
<span class="gi">+    max_compl_width = min(</span>
<span class="gi">+        term_width, max(get_cwidth(c.display_text) for c in completions) + 1</span>
<span class="gi">+    )</span>
<span class="gi">+    column_count = max(1, term_width // max_compl_width)</span>
<span class="gi">+    completions_per_page = column_count * (term_height - 1)</span>
<span class="gi">+    page_count = int(math.ceil(len(completions) / float(completions_per_page)))</span>
<span class="gi">+    # Note: math.ceil can return float on Python2.</span>
<span class="gi">+</span>
<span class="gi">+    def display(page: int) -&gt; None:</span>
<span class="gi">+        # Display completions.</span>
<span class="gi">+        page_completions = completions[</span>
<span class="gi">+            page * completions_per_page : (page + 1) * completions_per_page</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        page_row_count = int(math.ceil(len(page_completions) / float(column_count)))</span>
<span class="gi">+        page_columns = [</span>
<span class="gi">+            page_completions[i * page_row_count : (i + 1) * page_row_count]</span>
<span class="gi">+            for i in range(column_count)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+</span>
<span class="gi">+        for r in range(page_row_count):</span>
<span class="gi">+            for c in range(column_count):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    completion = page_columns[c][r]</span>
<span class="gi">+                    style = &quot;class:readline-like-completions.completion &quot; + (</span>
<span class="gi">+                        completion.style or &quot;&quot;</span>
<span class="gi">+                    )</span>

<span class="gi">+                    result.extend(to_formatted_text(completion.display, style=style))</span>

<span class="gd">-def _create_more_session(message: str=&#39;--MORE--&#39;) -&gt;PromptSession[bool]:</span>
<span class="gi">+                    # Add padding.</span>
<span class="gi">+                    padding = max_compl_width - get_cwidth(completion.display_text)</span>
<span class="gi">+                    result.append((completion.style, &quot; &quot; * padding))</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            result.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        app.print_text(to_formatted_text(result, &quot;class:readline-like-completions&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    # User interaction through an application generator function.</span>
<span class="gi">+    async def run_compl() -&gt; None:</span>
<span class="gi">+        &quot;Coroutine.&quot;</span>
<span class="gi">+        async with in_terminal(render_cli_done=True):</span>
<span class="gi">+            if len(completions) &gt; completions_per_page:</span>
<span class="gi">+                # Ask confirmation if it doesn&#39;t fit on the screen.</span>
<span class="gi">+                confirm = await create_confirm_session(</span>
<span class="gi">+                    f&quot;Display all {len(completions)} possibilities?&quot;,</span>
<span class="gi">+                ).prompt_async()</span>
<span class="gi">+</span>
<span class="gi">+                if confirm:</span>
<span class="gi">+                    # Display pages.</span>
<span class="gi">+                    for page in range(page_count):</span>
<span class="gi">+                        display(page)</span>
<span class="gi">+</span>
<span class="gi">+                        if page != page_count - 1:</span>
<span class="gi">+                            # Display --MORE-- and go to the next page.</span>
<span class="gi">+                            show_more = await _create_more_session(</span>
<span class="gi">+                                &quot;--MORE--&quot;</span>
<span class="gi">+                            ).prompt_async()</span>
<span class="gi">+</span>
<span class="gi">+                            if not show_more:</span>
<span class="gi">+                                return</span>
<span class="gi">+                else:</span>
<span class="gi">+                    app.output.flush()</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Display all completions.</span>
<span class="gi">+                display(0)</span>
<span class="gi">+</span>
<span class="gi">+    return app.create_background_task(run_compl())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_more_session(message: str = &quot;--MORE--&quot;) -&gt; PromptSession[bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `PromptSession` object for displaying the &quot;--MORE--&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.shortcuts import PromptSession</span>
<span class="gi">+</span>
<span class="gi">+    bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(&quot; &quot;)</span>
<span class="gi">+    @bindings.add(&quot;y&quot;)</span>
<span class="gi">+    @bindings.add(&quot;Y&quot;)</span>
<span class="gi">+    @bindings.add(Keys.ControlJ)</span>
<span class="gi">+    @bindings.add(Keys.ControlM)</span>
<span class="gi">+    @bindings.add(Keys.ControlI)  # Tab.</span>
<span class="gi">+    def _yes(event: E) -&gt; None:</span>
<span class="gi">+        event.app.exit(result=True)</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(&quot;n&quot;)</span>
<span class="gi">+    @bindings.add(&quot;N&quot;)</span>
<span class="gi">+    @bindings.add(&quot;q&quot;)</span>
<span class="gi">+    @bindings.add(&quot;Q&quot;)</span>
<span class="gi">+    @bindings.add(Keys.ControlC)</span>
<span class="gi">+    def _no(event: E) -&gt; None:</span>
<span class="gi">+        event.app.exit(result=False)</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(Keys.Any)</span>
<span class="gi">+    def _ignore(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Disable inserting of text.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return PromptSession(message, key_bindings=bindings, erase_when_done=True)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/cpr.py b/src/prompt_toolkit/key_binding/bindings/cpr.py</span>
<span class="gh">index 904f58e7..cd9df0a6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/cpr.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/cpr.py</span>
<span class="gu">@@ -1,6 +1,30 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import KeyBindings
<span class="gd">-__all__ = [&#39;load_cpr_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_cpr_bindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_cpr_bindings() -&gt; KeyBindings:</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.CPRResponse, save_before=lambda e: False)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Handle incoming Cursor-Position-Request response.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # The incoming data looks like u&#39;\x1b[35;1R&#39;</span>
<span class="gi">+        # Parse row/col information.</span>
<span class="gi">+        row, col = map(int, event.data[2:-1].split(&quot;;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # Report absolute cursor position to the renderer.</span>
<span class="gi">+        event.app.renderer.report_absolute_cursor_row(row)</span>
<span class="gi">+</span>
<span class="gi">+    return key_bindings</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/emacs.py b/src/prompt_toolkit/key_binding/bindings/emacs.py</span>
<span class="gh">index c03fc0ea..80a66fd2 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/emacs.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/emacs.py</span>
<span class="gu">@@ -1,28 +1,557 @@</span>
<span class="gi">+# pylint: disable=function-redefined</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.buffer import Buffer, indent, unindent
<span class="w"> </span>from prompt_toolkit.completion import CompleteEvent
<span class="gd">-from prompt_toolkit.filters import Condition, emacs_insert_mode, emacs_mode, has_arg, has_selection, in_paste_mode, is_multiline, is_read_only, shift_selection_mode, vi_search_direction_reversed</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    emacs_insert_mode,</span>
<span class="gi">+    emacs_mode,</span>
<span class="gi">+    has_arg,</span>
<span class="gi">+    has_selection,</span>
<span class="gi">+    in_paste_mode,</span>
<span class="gi">+    is_multiline,</span>
<span class="gi">+    is_read_only,</span>
<span class="gi">+    shift_selection_mode,</span>
<span class="gi">+    vi_search_direction_reversed,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import Binding
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.selection import SelectionType
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import ConditionalKeyBindings, KeyBindings, KeyBindingsBase
<span class="w"> </span>from .named_commands import get_by_name
<span class="gd">-__all__ = [&#39;load_emacs_bindings&#39;, &#39;load_emacs_search_bindings&#39;,</span>
<span class="gd">-    &#39;load_emacs_shift_selection_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_emacs_bindings&quot;,</span>
<span class="gi">+    &quot;load_emacs_search_bindings&quot;,</span>
<span class="gi">+    &quot;load_emacs_shift_selection_bindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def load_emacs_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+def load_emacs_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Some e-macs extensions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Overview of Readline emacs commands:</span>
<span class="gi">+    # http://www.catonmat.net/download/readline-emacs-editing-mode-cheat-sheet.pdf</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    insert_mode = emacs_insert_mode</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;)</span>
<span class="gi">+    def _esc(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        By default, ignore escape key.</span>
<span class="gi">+</span>
<span class="gi">+        (If we don&#39;t put this here, and Esc is followed by a key which sequence</span>
<span class="gi">+        is not handled, we&#39;ll insert an Escape character in the input stream.</span>
<span class="gi">+        Something we don&#39;t want and happens to easily in emacs mode.</span>
<span class="gi">+        Further, people can always use ControlQ to do a quoted insert.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-a&quot;)(get_by_name(&quot;beginning-of-line&quot;))</span>
<span class="gi">+    handle(&quot;c-b&quot;)(get_by_name(&quot;backward-char&quot;))</span>
<span class="gi">+    handle(&quot;c-delete&quot;, filter=insert_mode)(get_by_name(&quot;kill-word&quot;))</span>
<span class="gi">+    handle(&quot;c-e&quot;)(get_by_name(&quot;end-of-line&quot;))</span>
<span class="gi">+    handle(&quot;c-f&quot;)(get_by_name(&quot;forward-char&quot;))</span>
<span class="gi">+    handle(&quot;c-left&quot;)(get_by_name(&quot;backward-word&quot;))</span>
<span class="gi">+    handle(&quot;c-right&quot;)(get_by_name(&quot;forward-word&quot;))</span>
<span class="gi">+    handle(&quot;c-x&quot;, &quot;r&quot;, &quot;y&quot;, filter=insert_mode)(get_by_name(&quot;yank&quot;))</span>
<span class="gi">+    handle(&quot;c-y&quot;, filter=insert_mode)(get_by_name(&quot;yank&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;b&quot;)(get_by_name(&quot;backward-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;c&quot;, filter=insert_mode)(get_by_name(&quot;capitalize-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;d&quot;, filter=insert_mode)(get_by_name(&quot;kill-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;f&quot;)(get_by_name(&quot;forward-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;l&quot;, filter=insert_mode)(get_by_name(&quot;downcase-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;u&quot;, filter=insert_mode)(get_by_name(&quot;uppercase-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;y&quot;, filter=insert_mode)(get_by_name(&quot;yank-pop&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;backspace&quot;, filter=insert_mode)(get_by_name(&quot;backward-kill-word&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;\\&quot;, filter=insert_mode)(get_by_name(&quot;delete-horizontal-space&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-home&quot;)(get_by_name(&quot;beginning-of-buffer&quot;))</span>
<span class="gi">+    handle(&quot;c-end&quot;)(get_by_name(&quot;end-of-buffer&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-_&quot;, save_before=(lambda e: False), filter=insert_mode)(</span>
<span class="gi">+        get_by_name(&quot;undo&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-x&quot;, &quot;c-u&quot;, save_before=(lambda e: False), filter=insert_mode)(</span>
<span class="gi">+        get_by_name(&quot;undo&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;&lt;&quot;, filter=~has_selection)(get_by_name(&quot;beginning-of-history&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;&gt;&quot;, filter=~has_selection)(get_by_name(&quot;end-of-history&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;.&quot;, filter=insert_mode)(get_by_name(&quot;yank-last-arg&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;_&quot;, filter=insert_mode)(get_by_name(&quot;yank-last-arg&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;c-y&quot;, filter=insert_mode)(get_by_name(&quot;yank-nth-arg&quot;))</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;#&quot;, filter=insert_mode)(get_by_name(&quot;insert-comment&quot;))</span>
<span class="gi">+    handle(&quot;c-o&quot;)(get_by_name(&quot;operate-and-get-next&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    # ControlQ does a quoted insert. Not that for vt100 terminals, you have to</span>
<span class="gi">+    # disable flow control by running ``stty -ixon``, otherwise Ctrl-Q and</span>
<span class="gi">+    # Ctrl-S are captured by the terminal.</span>
<span class="gi">+    handle(&quot;c-q&quot;, filter=~has_selection)(get_by_name(&quot;quoted-insert&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-x&quot;, &quot;(&quot;)(get_by_name(&quot;start-kbd-macro&quot;))</span>
<span class="gi">+    handle(&quot;c-x&quot;, &quot;)&quot;)(get_by_name(&quot;end-kbd-macro&quot;))</span>
<span class="gi">+    handle(&quot;c-x&quot;, &quot;e&quot;)(get_by_name(&quot;call-last-kbd-macro&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-n&quot;)</span>
<span class="gi">+    def _next(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Next line.&quot;</span>
<span class="gi">+        event.current_buffer.auto_down()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-p&quot;)</span>
<span class="gi">+    def _prev(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Previous line.&quot;</span>
<span class="gi">+        event.current_buffer.auto_up(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    def handle_digit(c: str) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Handle input of arguments.</span>
<span class="gi">+        The first number needs to be preceded by escape.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        @handle(c, filter=has_arg)</span>
<span class="gi">+        @handle(&quot;escape&quot;, c)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            event.append_to_arg_count(c)</span>
<span class="gi">+</span>
<span class="gi">+    for c in &quot;0123456789&quot;:</span>
<span class="gi">+        handle_digit(c)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;-&quot;, filter=~has_arg)</span>
<span class="gi">+    def _meta_dash(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;&quot;&quot;&quot;</span>
<span class="gi">+        if event._arg is None:</span>
<span class="gi">+            event.append_to_arg_count(&quot;-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;-&quot;, filter=Condition(lambda: get_app().key_processor.arg == &quot;-&quot;))</span>
<span class="gi">+    def _dash(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        When &#39;-&#39; is typed again, after exactly &#39;-&#39; has been given as an</span>
<span class="gi">+        argument, ignore this.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.key_processor.arg = &quot;-&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def is_returnable() -&gt; bool:</span>
<span class="gi">+        return get_app().current_buffer.is_returnable</span>
<span class="gi">+</span>
<span class="gi">+    # Meta + Enter: always accept input.</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;enter&quot;, filter=insert_mode &amp; is_returnable)(</span>
<span class="gi">+        get_by_name(&quot;accept-line&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Enter: accept input in single line mode.</span>
<span class="gi">+    handle(&quot;enter&quot;, filter=insert_mode &amp; is_returnable &amp; ~is_multiline)(</span>
<span class="gi">+        get_by_name(&quot;accept-line&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def character_search(buff: Buffer, char: str, count: int) -&gt; None:</span>
<span class="gi">+        if count &lt; 0:</span>
<span class="gi">+            match = buff.document.find_backwards(</span>
<span class="gi">+                char, in_current_line=True, count=-count</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            match = buff.document.find(char, in_current_line=True, count=count)</span>
<span class="gi">+</span>
<span class="gi">+        if match is not None:</span>
<span class="gi">+            buff.cursor_position += match</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-]&quot;, Keys.Any)</span>
<span class="gi">+    def _goto_char(event: E) -&gt; None:</span>
<span class="gi">+        &quot;When Ctl-] + a character is pressed. go to that character.&quot;</span>
<span class="gi">+        # Also named &#39;character-search&#39;</span>
<span class="gi">+        character_search(event.current_buffer, event.data, event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;c-]&quot;, Keys.Any)</span>
<span class="gi">+    def _goto_char_backwards(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Like Ctl-], but backwards.&quot;</span>
<span class="gi">+        # Also named &#39;character-search-backward&#39;</span>
<span class="gi">+        character_search(event.current_buffer, event.data, -event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;a&quot;)</span>
<span class="gi">+    def _prev_sentence(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Previous sentence.&quot;</span>
<span class="gi">+        # TODO:</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;e&quot;)</span>
<span class="gi">+    def _end_of_sentence(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Move to end of sentence.&quot;</span>
<span class="gi">+        # TODO:</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;t&quot;, filter=insert_mode)</span>
<span class="gi">+    def _swap_characters(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Swap the last two words before the cursor.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # TODO</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;*&quot;, filter=insert_mode)</span>
<span class="gi">+    def _insert_all_completions(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        `meta-*`: Insert all possible completions of the preceding text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        # List all completions.</span>
<span class="gi">+        complete_event = CompleteEvent(text_inserted=False, completion_requested=True)</span>
<span class="gi">+        completions = list(</span>
<span class="gi">+            buff.completer.get_completions(buff.document, complete_event)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Insert them.</span>
<span class="gi">+        text_to_insert = &quot; &quot;.join(c.text for c in completions)</span>
<span class="gi">+        buff.insert_text(text_to_insert)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-x&quot;, &quot;c-x&quot;)</span>
<span class="gi">+    def _toggle_start_end(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move cursor back and forth between the start and end of the current</span>
<span class="gi">+        line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if buffer.document.is_cursor_at_the_end_of_line:</span>
<span class="gi">+            buffer.cursor_position += buffer.document.get_start_of_line_position(</span>
<span class="gi">+                after_whitespace=False</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            buffer.cursor_position += buffer.document.get_end_of_line_position()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-@&quot;)  # Control-space or Control-@</span>
<span class="gi">+    def _start_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Start of the selection (if the current buffer is not empty).</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Take the current cursor position as the start of this selection.</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        if buff.text:</span>
<span class="gi">+            buff.start_selection(selection_type=SelectionType.CHARACTERS)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-g&quot;, filter=~has_selection)</span>
<span class="gi">+    def _cancel(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Control + G: Cancel completion menu and validation state.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.complete_state = None</span>
<span class="gi">+        event.current_buffer.validation_error = None</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-g&quot;, filter=has_selection)</span>
<span class="gi">+    def _cancel_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cancel selection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-w&quot;, filter=has_selection)</span>
<span class="gi">+    @handle(&quot;c-x&quot;, &quot;r&quot;, &quot;k&quot;, filter=has_selection)</span>
<span class="gi">+    def _cut(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cut selected text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        data = event.current_buffer.cut_selection()</span>
<span class="gi">+        event.app.clipboard.set_data(data)</span>

<span class="gi">+    @handle(&quot;escape&quot;, &quot;w&quot;, filter=has_selection)</span>
<span class="gi">+    def _copy(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Copy selected text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        data = event.current_buffer.copy_selection()</span>
<span class="gi">+        event.app.clipboard.set_data(data)</span>

<span class="gd">-def load_emacs_shift_selection_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;left&quot;)</span>
<span class="gi">+    def _start_of_word(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cursor to start of previous word.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        buffer.cursor_position += (</span>
<span class="gi">+            buffer.document.find_previous_word_beginning(count=event.arg) or 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;right&quot;)</span>
<span class="gi">+    def _start_next_word(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cursor to start of next word.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        buffer.cursor_position += (</span>
<span class="gi">+            buffer.document.find_next_word_beginning(count=event.arg)</span>
<span class="gi">+            or buffer.document.get_end_of_document_position()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;, &quot;/&quot;, filter=insert_mode)</span>
<span class="gi">+    def _complete(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        M-/: Complete.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        if b.complete_state:</span>
<span class="gi">+            b.complete_next()</span>
<span class="gi">+        else:</span>
<span class="gi">+            b.start_completion(select_first=True)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-c&quot;, &quot;&gt;&quot;, filter=has_selection)</span>
<span class="gi">+    def _indent(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Indent selected text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        buffer.cursor_position += buffer.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        from_, to = buffer.document.selection_range()</span>
<span class="gi">+        from_, _ = buffer.document.translate_index_to_position(from_)</span>
<span class="gi">+        to, _ = buffer.document.translate_index_to_position(to)</span>
<span class="gi">+</span>
<span class="gi">+        indent(buffer, from_, to + 1, count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-c&quot;, &quot;&lt;&quot;, filter=has_selection)</span>
<span class="gi">+    def _unindent(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Unindent selected text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        from_, to = buffer.document.selection_range()</span>
<span class="gi">+        from_, _ = buffer.document.translate_index_to_position(from_)</span>
<span class="gi">+        to, _ = buffer.document.translate_index_to_position(to)</span>
<span class="gi">+</span>
<span class="gi">+        unindent(buffer, from_, to + 1, count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(key_bindings, emacs_mode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_emacs_search_bindings() -&gt; KeyBindingsBase:</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+    from . import search</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: We don&#39;t bind &#39;Escape&#39; to &#39;abort_search&#39;. The reason is that we</span>
<span class="gi">+    #       want Alt+Enter to accept input directly in incremental search mode.</span>
<span class="gi">+    #       Instead, we have double escape.</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-r&quot;)(search.start_reverse_incremental_search)</span>
<span class="gi">+    handle(&quot;c-s&quot;)(search.start_forward_incremental_search)</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-c&quot;)(search.abort_search)</span>
<span class="gi">+    handle(&quot;c-g&quot;)(search.abort_search)</span>
<span class="gi">+    handle(&quot;c-r&quot;)(search.reverse_incremental_search)</span>
<span class="gi">+    handle(&quot;c-s&quot;)(search.forward_incremental_search)</span>
<span class="gi">+    handle(&quot;up&quot;)(search.reverse_incremental_search)</span>
<span class="gi">+    handle(&quot;down&quot;)(search.forward_incremental_search)</span>
<span class="gi">+    handle(&quot;enter&quot;)(search.accept_search)</span>
<span class="gi">+</span>
<span class="gi">+    # Handling of escape.</span>
<span class="gi">+    handle(&quot;escape&quot;, eager=True)(search.accept_search)</span>
<span class="gi">+</span>
<span class="gi">+    # Like Readline, it&#39;s more natural to accept the search when escape has</span>
<span class="gi">+    # been pressed, however instead the following two bindings could be used</span>
<span class="gi">+    # instead.</span>
<span class="gi">+    # #handle(&#39;escape&#39;, &#39;escape&#39;, eager=True)(search.abort_search)</span>
<span class="gi">+    # #handle(&#39;escape&#39;, &#39;enter&#39;, eager=True)(search.accept_search_and_accept_input)</span>
<span class="gi">+</span>
<span class="gi">+    # If Read-only: also include the following key bindings:</span>
<span class="gi">+</span>
<span class="gi">+    # &#39;/&#39; and &#39;?&#39; key bindings for searching, just like Vi mode.</span>
<span class="gi">+    handle(&quot;?&quot;, filter=is_read_only &amp; ~vi_search_direction_reversed)(</span>
<span class="gi">+        search.start_reverse_incremental_search</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(&quot;/&quot;, filter=is_read_only &amp; ~vi_search_direction_reversed)(</span>
<span class="gi">+        search.start_forward_incremental_search</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(&quot;?&quot;, filter=is_read_only &amp; vi_search_direction_reversed)(</span>
<span class="gi">+        search.start_forward_incremental_search</span>
<span class="gi">+    )</span>
<span class="gi">+    handle(&quot;/&quot;, filter=is_read_only &amp; vi_search_direction_reversed)(</span>
<span class="gi">+        search.start_reverse_incremental_search</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;n&quot;, filter=is_read_only)</span>
<span class="gi">+    def _jump_next(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Jump to next match.&quot;</span>
<span class="gi">+        event.current_buffer.apply_search(</span>
<span class="gi">+            event.app.current_search_state,</span>
<span class="gi">+            include_current_position=False,</span>
<span class="gi">+            count=event.arg,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;N&quot;, filter=is_read_only)</span>
<span class="gi">+    def _jump_prev(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Jump to previous match.&quot;</span>
<span class="gi">+        event.current_buffer.apply_search(</span>
<span class="gi">+            ~event.app.current_search_state,</span>
<span class="gi">+            include_current_position=False,</span>
<span class="gi">+            count=event.arg,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(key_bindings, emacs_mode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_emacs_shift_selection_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Bindings to select text with shift + cursor movements
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    def unshift_move(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Used for the shift selection mode. When called with</span>
<span class="gi">+        a shift + movement key press event, moves the cursor</span>
<span class="gi">+        as if shift is not pressed.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        key = event.key_sequence[0].key</span>
<span class="gi">+</span>
<span class="gi">+        if key == Keys.ShiftUp:</span>
<span class="gi">+            event.current_buffer.auto_up(count=event.arg)</span>
<span class="gi">+            return</span>
<span class="gi">+        if key == Keys.ShiftDown:</span>
<span class="gi">+            event.current_buffer.auto_down(count=event.arg)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # the other keys are handled through their readline command</span>
<span class="gi">+        key_to_command: dict[Keys | str, str] = {</span>
<span class="gi">+            Keys.ShiftLeft: &quot;backward-char&quot;,</span>
<span class="gi">+            Keys.ShiftRight: &quot;forward-char&quot;,</span>
<span class="gi">+            Keys.ShiftHome: &quot;beginning-of-line&quot;,</span>
<span class="gi">+            Keys.ShiftEnd: &quot;end-of-line&quot;,</span>
<span class="gi">+            Keys.ControlShiftLeft: &quot;backward-word&quot;,</span>
<span class="gi">+            Keys.ControlShiftRight: &quot;forward-word&quot;,</span>
<span class="gi">+            Keys.ControlShiftHome: &quot;beginning-of-buffer&quot;,</span>
<span class="gi">+            Keys.ControlShiftEnd: &quot;end-of-buffer&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Both the dict lookup and `get_by_name` can raise KeyError.</span>
<span class="gi">+            binding = get_by_name(key_to_command[key])</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:  # (`else` is not really needed here.)</span>
<span class="gi">+            if isinstance(binding, Binding):</span>
<span class="gi">+                # (It should always be a binding here)</span>
<span class="gi">+                binding.call(event)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;s-left&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;s-right&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;s-up&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;s-down&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;s-home&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;s-end&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;c-s-left&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;c-s-right&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;c-s-home&quot;, filter=~has_selection)</span>
<span class="gi">+    @handle(&quot;c-s-end&quot;, filter=~has_selection)</span>
<span class="gi">+    def _start_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Start selection with shift + movement.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Take the current cursor position as the start of this selection.</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        if buff.text:</span>
<span class="gi">+            buff.start_selection(selection_type=SelectionType.CHARACTERS)</span>
<span class="gi">+</span>
<span class="gi">+            if buff.selection_state is not None:</span>
<span class="gi">+                # (`selection_state` should never be `None`, it is created by</span>
<span class="gi">+                # `start_selection`.)</span>
<span class="gi">+                buff.selection_state.enter_shift_mode()</span>
<span class="gi">+</span>
<span class="gi">+            # Then move the cursor</span>
<span class="gi">+            original_position = buff.cursor_position</span>
<span class="gi">+            unshift_move(event)</span>
<span class="gi">+            if buff.cursor_position == original_position:</span>
<span class="gi">+                # Cursor didn&#39;t actually move - so cancel selection</span>
<span class="gi">+                # to avoid having an empty selection</span>
<span class="gi">+                buff.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;s-left&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;s-right&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;s-up&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;s-down&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;s-home&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;s-end&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-s-left&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-s-right&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-s-home&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-s-end&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    def _extend_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Extend the selection</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Just move the cursor, like shift was not pressed</span>
<span class="gi">+        unshift_move(event)</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if buff.selection_state is not None:</span>
<span class="gi">+            if buff.cursor_position == buff.selection_state.original_cursor_position:</span>
<span class="gi">+                # selection is now empty, so cancel selection</span>
<span class="gi">+                buff.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=shift_selection_mode)</span>
<span class="gi">+    def _replace_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Replace selection by what is typed</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cut_selection()</span>
<span class="gi">+        get_by_name(&quot;self-insert&quot;).call(event)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;enter&quot;, filter=shift_selection_mode &amp; is_multiline)</span>
<span class="gi">+    def _newline(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        A newline replaces the selection</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cut_selection()</span>
<span class="gi">+        event.current_buffer.newline(copy_margin=not in_paste_mode())</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;backspace&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    def _delete(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete selection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cut_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-y&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    def _yank(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        In shift selection mode, yanking (pasting) replace the selection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        if buff.selection_state:</span>
<span class="gi">+            buff.cut_selection()</span>
<span class="gi">+        get_by_name(&quot;yank&quot;).call(event)</span>
<span class="gi">+</span>
<span class="gi">+    # moving the cursor in shift selection mode cancels the selection</span>
<span class="gi">+    @handle(&quot;left&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;right&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;up&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;down&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;home&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;end&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-left&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-right&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-home&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    @handle(&quot;c-end&quot;, filter=shift_selection_mode)</span>
<span class="gi">+    def _cancel(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cancel selection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.exit_selection()</span>
<span class="gi">+        # we then process the cursor movement</span>
<span class="gi">+        key_press = event.key_sequence[0]</span>
<span class="gi">+        event.key_processor.feed(key_press, first=True)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(key_bindings, emacs_mode)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/focus.py b/src/prompt_toolkit/key_binding/bindings/focus.py</span>
<span class="gh">index 9d636a30..24aa3ce3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/focus.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/focus.py</span>
<span class="gu">@@ -1,20 +1,26 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="gd">-__all__ = [&#39;focus_next&#39;, &#39;focus_previous&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;focus_next&quot;,</span>
<span class="gi">+    &quot;focus_previous&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def focus_next(event: E) -&gt;None:</span>
<span class="gi">+def focus_next(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Focus the next visible Window.
<span class="w"> </span>    (Often bound to the `Tab` key.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.layout.focus_next()</span>


<span class="gd">-def focus_previous(event: E) -&gt;None:</span>
<span class="gi">+def focus_previous(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Focus the previous visible Window.
<span class="w"> </span>    (Often bound to the `BackTab` key.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.layout.focus_previous()</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/mouse.py b/src/prompt_toolkit/key_binding/bindings/mouse.py</span>
<span class="gh">index 03ff5d6f..cb426ce7 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/mouse.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/mouse.py</span>
<span class="gu">@@ -1,116 +1,348 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.data_structures import Point
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPress, KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="gd">-from prompt_toolkit.mouse_events import MouseButton, MouseEvent, MouseEventType, MouseModifier</span>
<span class="gi">+from prompt_toolkit.mouse_events import (</span>
<span class="gi">+    MouseButton,</span>
<span class="gi">+    MouseEvent,</span>
<span class="gi">+    MouseEventType,</span>
<span class="gi">+    MouseModifier,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import KeyBindings
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.key_binding.key_bindings import NotImplementedOrNone
<span class="gd">-__all__ = [&#39;load_mouse_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_mouse_bindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent
<span class="gd">-SCROLL_UP = MouseEventType.SCROLL_UP</span>
<span class="gi">+</span>
<span class="gi">+# fmt: off</span>
<span class="gi">+SCROLL_UP   = MouseEventType.SCROLL_UP</span>
<span class="w"> </span>SCROLL_DOWN = MouseEventType.SCROLL_DOWN
<span class="gd">-MOUSE_DOWN = MouseEventType.MOUSE_DOWN</span>
<span class="gd">-MOUSE_MOVE = MouseEventType.MOUSE_MOVE</span>
<span class="gd">-MOUSE_UP = MouseEventType.MOUSE_UP</span>
<span class="gd">-NO_MODIFIER: frozenset[MouseModifier] = frozenset()</span>
<span class="gd">-SHIFT: frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT})</span>
<span class="gd">-ALT: frozenset[MouseModifier] = frozenset({MouseModifier.ALT})</span>
<span class="gd">-SHIFT_ALT: frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT,</span>
<span class="gd">-    MouseModifier.ALT})</span>
<span class="gd">-CONTROL: frozenset[MouseModifier] = frozenset({MouseModifier.CONTROL})</span>
<span class="gd">-SHIFT_CONTROL: frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT,</span>
<span class="gd">-    MouseModifier.CONTROL})</span>
<span class="gd">-ALT_CONTROL: frozenset[MouseModifier] = frozenset({MouseModifier.ALT,</span>
<span class="gd">-    MouseModifier.CONTROL})</span>
<span class="gd">-SHIFT_ALT_CONTROL: frozenset[MouseModifier] = frozenset({MouseModifier.</span>
<span class="gd">-    SHIFT, MouseModifier.ALT, MouseModifier.CONTROL})</span>
<span class="gd">-UNKNOWN_MODIFIER: frozenset[MouseModifier] = frozenset()</span>
<span class="gd">-LEFT = MouseButton.LEFT</span>
<span class="gd">-MIDDLE = MouseButton.MIDDLE</span>
<span class="gd">-RIGHT = MouseButton.RIGHT</span>
<span class="gd">-NO_BUTTON = MouseButton.NONE</span>
<span class="gi">+MOUSE_DOWN  = MouseEventType.MOUSE_DOWN</span>
<span class="gi">+MOUSE_MOVE  = MouseEventType.MOUSE_MOVE</span>
<span class="gi">+MOUSE_UP    = MouseEventType.MOUSE_UP</span>
<span class="gi">+</span>
<span class="gi">+NO_MODIFIER      : frozenset[MouseModifier] = frozenset()</span>
<span class="gi">+SHIFT            : frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT})</span>
<span class="gi">+ALT              : frozenset[MouseModifier] = frozenset({MouseModifier.ALT})</span>
<span class="gi">+SHIFT_ALT        : frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT, MouseModifier.ALT})</span>
<span class="gi">+CONTROL          : frozenset[MouseModifier] = frozenset({MouseModifier.CONTROL})</span>
<span class="gi">+SHIFT_CONTROL    : frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT, MouseModifier.CONTROL})</span>
<span class="gi">+ALT_CONTROL      : frozenset[MouseModifier] = frozenset({MouseModifier.ALT, MouseModifier.CONTROL})</span>
<span class="gi">+SHIFT_ALT_CONTROL: frozenset[MouseModifier] = frozenset({MouseModifier.SHIFT, MouseModifier.ALT, MouseModifier.CONTROL})</span>
<span class="gi">+UNKNOWN_MODIFIER : frozenset[MouseModifier] = frozenset()</span>
<span class="gi">+</span>
<span class="gi">+LEFT           = MouseButton.LEFT</span>
<span class="gi">+MIDDLE         = MouseButton.MIDDLE</span>
<span class="gi">+RIGHT          = MouseButton.RIGHT</span>
<span class="gi">+NO_BUTTON      = MouseButton.NONE</span>
<span class="w"> </span>UNKNOWN_BUTTON = MouseButton.UNKNOWN
<span class="gd">-xterm_sgr_mouse_events = {(0, &#39;m&#39;): (LEFT, MOUSE_UP, NO_MODIFIER), (4, &#39;m&#39;):</span>
<span class="gd">-    (LEFT, MOUSE_UP, SHIFT), (8, &#39;m&#39;): (LEFT, MOUSE_UP, ALT), (12, &#39;m&#39;): (</span>
<span class="gd">-    LEFT, MOUSE_UP, SHIFT_ALT), (16, &#39;m&#39;): (LEFT, MOUSE_UP, CONTROL), (20,</span>
<span class="gd">-    &#39;m&#39;): (LEFT, MOUSE_UP, SHIFT_CONTROL), (24, &#39;m&#39;): (LEFT, MOUSE_UP,</span>
<span class="gd">-    ALT_CONTROL), (28, &#39;m&#39;): (LEFT, MOUSE_UP, SHIFT_ALT_CONTROL), (1, &#39;m&#39;):</span>
<span class="gd">-    (MIDDLE, MOUSE_UP, NO_MODIFIER), (5, &#39;m&#39;): (MIDDLE, MOUSE_UP, SHIFT), (</span>
<span class="gd">-    9, &#39;m&#39;): (MIDDLE, MOUSE_UP, ALT), (13, &#39;m&#39;): (MIDDLE, MOUSE_UP,</span>
<span class="gd">-    SHIFT_ALT), (17, &#39;m&#39;): (MIDDLE, MOUSE_UP, CONTROL), (21, &#39;m&#39;): (MIDDLE,</span>
<span class="gd">-    MOUSE_UP, SHIFT_CONTROL), (25, &#39;m&#39;): (MIDDLE, MOUSE_UP, ALT_CONTROL), (</span>
<span class="gd">-    29, &#39;m&#39;): (MIDDLE, MOUSE_UP, SHIFT_ALT_CONTROL), (2, &#39;m&#39;): (RIGHT,</span>
<span class="gd">-    MOUSE_UP, NO_MODIFIER), (6, &#39;m&#39;): (RIGHT, MOUSE_UP, SHIFT), (10, &#39;m&#39;):</span>
<span class="gd">-    (RIGHT, MOUSE_UP, ALT), (14, &#39;m&#39;): (RIGHT, MOUSE_UP, SHIFT_ALT), (18,</span>
<span class="gd">-    &#39;m&#39;): (RIGHT, MOUSE_UP, CONTROL), (22, &#39;m&#39;): (RIGHT, MOUSE_UP,</span>
<span class="gd">-    SHIFT_CONTROL), (26, &#39;m&#39;): (RIGHT, MOUSE_UP, ALT_CONTROL), (30, &#39;m&#39;): (</span>
<span class="gd">-    RIGHT, MOUSE_UP, SHIFT_ALT_CONTROL), (0, &#39;M&#39;): (LEFT, MOUSE_DOWN,</span>
<span class="gd">-    NO_MODIFIER), (4, &#39;M&#39;): (LEFT, MOUSE_DOWN, SHIFT), (8, &#39;M&#39;): (LEFT,</span>
<span class="gd">-    MOUSE_DOWN, ALT), (12, &#39;M&#39;): (LEFT, MOUSE_DOWN, SHIFT_ALT), (16, &#39;M&#39;):</span>
<span class="gd">-    (LEFT, MOUSE_DOWN, CONTROL), (20, &#39;M&#39;): (LEFT, MOUSE_DOWN,</span>
<span class="gd">-    SHIFT_CONTROL), (24, &#39;M&#39;): (LEFT, MOUSE_DOWN, ALT_CONTROL), (28, &#39;M&#39;):</span>
<span class="gd">-    (LEFT, MOUSE_DOWN, SHIFT_ALT_CONTROL), (1, &#39;M&#39;): (MIDDLE, MOUSE_DOWN,</span>
<span class="gd">-    NO_MODIFIER), (5, &#39;M&#39;): (MIDDLE, MOUSE_DOWN, SHIFT), (9, &#39;M&#39;): (MIDDLE,</span>
<span class="gd">-    MOUSE_DOWN, ALT), (13, &#39;M&#39;): (MIDDLE, MOUSE_DOWN, SHIFT_ALT), (17, &#39;M&#39;):</span>
<span class="gd">-    (MIDDLE, MOUSE_DOWN, CONTROL), (21, &#39;M&#39;): (MIDDLE, MOUSE_DOWN,</span>
<span class="gd">-    SHIFT_CONTROL), (25, &#39;M&#39;): (MIDDLE, MOUSE_DOWN, ALT_CONTROL), (29, &#39;M&#39;):</span>
<span class="gd">-    (MIDDLE, MOUSE_DOWN, SHIFT_ALT_CONTROL), (2, &#39;M&#39;): (RIGHT, MOUSE_DOWN,</span>
<span class="gd">-    NO_MODIFIER), (6, &#39;M&#39;): (RIGHT, MOUSE_DOWN, SHIFT), (10, &#39;M&#39;): (RIGHT,</span>
<span class="gd">-    MOUSE_DOWN, ALT), (14, &#39;M&#39;): (RIGHT, MOUSE_DOWN, SHIFT_ALT), (18, &#39;M&#39;):</span>
<span class="gd">-    (RIGHT, MOUSE_DOWN, CONTROL), (22, &#39;M&#39;): (RIGHT, MOUSE_DOWN,</span>
<span class="gd">-    SHIFT_CONTROL), (26, &#39;M&#39;): (RIGHT, MOUSE_DOWN, ALT_CONTROL), (30, &#39;M&#39;):</span>
<span class="gd">-    (RIGHT, MOUSE_DOWN, SHIFT_ALT_CONTROL), (32, &#39;M&#39;): (LEFT, MOUSE_MOVE,</span>
<span class="gd">-    NO_MODIFIER), (36, &#39;M&#39;): (LEFT, MOUSE_MOVE, SHIFT), (40, &#39;M&#39;): (LEFT,</span>
<span class="gd">-    MOUSE_MOVE, ALT), (44, &#39;M&#39;): (LEFT, MOUSE_MOVE, SHIFT_ALT), (48, &#39;M&#39;):</span>
<span class="gd">-    (LEFT, MOUSE_MOVE, CONTROL), (52, &#39;M&#39;): (LEFT, MOUSE_MOVE,</span>
<span class="gd">-    SHIFT_CONTROL), (56, &#39;M&#39;): (LEFT, MOUSE_MOVE, ALT_CONTROL), (60, &#39;M&#39;):</span>
<span class="gd">-    (LEFT, MOUSE_MOVE, SHIFT_ALT_CONTROL), (33, &#39;M&#39;): (MIDDLE, MOUSE_MOVE,</span>
<span class="gd">-    NO_MODIFIER), (37, &#39;M&#39;): (MIDDLE, MOUSE_MOVE, SHIFT), (41, &#39;M&#39;): (</span>
<span class="gd">-    MIDDLE, MOUSE_MOVE, ALT), (45, &#39;M&#39;): (MIDDLE, MOUSE_MOVE, SHIFT_ALT), (</span>
<span class="gd">-    49, &#39;M&#39;): (MIDDLE, MOUSE_MOVE, CONTROL), (53, &#39;M&#39;): (MIDDLE, MOUSE_MOVE,</span>
<span class="gd">-    SHIFT_CONTROL), (57, &#39;M&#39;): (MIDDLE, MOUSE_MOVE, ALT_CONTROL), (61, &#39;M&#39;):</span>
<span class="gd">-    (MIDDLE, MOUSE_MOVE, SHIFT_ALT_CONTROL), (34, &#39;M&#39;): (RIGHT, MOUSE_MOVE,</span>
<span class="gd">-    NO_MODIFIER), (38, &#39;M&#39;): (RIGHT, MOUSE_MOVE, SHIFT), (42, &#39;M&#39;): (RIGHT,</span>
<span class="gd">-    MOUSE_MOVE, ALT), (46, &#39;M&#39;): (RIGHT, MOUSE_MOVE, SHIFT_ALT), (50, &#39;M&#39;):</span>
<span class="gd">-    (RIGHT, MOUSE_MOVE, CONTROL), (54, &#39;M&#39;): (RIGHT, MOUSE_MOVE,</span>
<span class="gd">-    SHIFT_CONTROL), (58, &#39;M&#39;): (RIGHT, MOUSE_MOVE, ALT_CONTROL), (62, &#39;M&#39;):</span>
<span class="gd">-    (RIGHT, MOUSE_MOVE, SHIFT_ALT_CONTROL), (35, &#39;M&#39;): (NO_BUTTON,</span>
<span class="gd">-    MOUSE_MOVE, NO_MODIFIER), (39, &#39;M&#39;): (NO_BUTTON, MOUSE_MOVE, SHIFT), (</span>
<span class="gd">-    43, &#39;M&#39;): (NO_BUTTON, MOUSE_MOVE, ALT), (47, &#39;M&#39;): (NO_BUTTON,</span>
<span class="gd">-    MOUSE_MOVE, SHIFT_ALT), (51, &#39;M&#39;): (NO_BUTTON, MOUSE_MOVE, CONTROL), (</span>
<span class="gd">-    55, &#39;M&#39;): (NO_BUTTON, MOUSE_MOVE, SHIFT_CONTROL), (59, &#39;M&#39;): (NO_BUTTON,</span>
<span class="gd">-    MOUSE_MOVE, ALT_CONTROL), (63, &#39;M&#39;): (NO_BUTTON, MOUSE_MOVE,</span>
<span class="gd">-    SHIFT_ALT_CONTROL), (64, &#39;M&#39;): (NO_BUTTON, SCROLL_UP, NO_MODIFIER), (68,</span>
<span class="gd">-    &#39;M&#39;): (NO_BUTTON, SCROLL_UP, SHIFT), (72, &#39;M&#39;): (NO_BUTTON, SCROLL_UP,</span>
<span class="gd">-    ALT), (76, &#39;M&#39;): (NO_BUTTON, SCROLL_UP, SHIFT_ALT), (80, &#39;M&#39;): (</span>
<span class="gd">-    NO_BUTTON, SCROLL_UP, CONTROL), (84, &#39;M&#39;): (NO_BUTTON, SCROLL_UP,</span>
<span class="gd">-    SHIFT_CONTROL), (88, &#39;M&#39;): (NO_BUTTON, SCROLL_UP, ALT_CONTROL), (92,</span>
<span class="gd">-    &#39;M&#39;): (NO_BUTTON, SCROLL_UP, SHIFT_ALT_CONTROL), (65, &#39;M&#39;): (NO_BUTTON,</span>
<span class="gd">-    SCROLL_DOWN, NO_MODIFIER), (69, &#39;M&#39;): (NO_BUTTON, SCROLL_DOWN, SHIFT),</span>
<span class="gd">-    (73, &#39;M&#39;): (NO_BUTTON, SCROLL_DOWN, ALT), (77, &#39;M&#39;): (NO_BUTTON,</span>
<span class="gd">-    SCROLL_DOWN, SHIFT_ALT), (81, &#39;M&#39;): (NO_BUTTON, SCROLL_DOWN, CONTROL),</span>
<span class="gd">-    (85, &#39;M&#39;): (NO_BUTTON, SCROLL_DOWN, SHIFT_CONTROL), (89, &#39;M&#39;): (</span>
<span class="gd">-    NO_BUTTON, SCROLL_DOWN, ALT_CONTROL), (93, &#39;M&#39;): (NO_BUTTON,</span>
<span class="gd">-    SCROLL_DOWN, SHIFT_ALT_CONTROL)}</span>
<span class="gd">-typical_mouse_events = {(32): (LEFT, MOUSE_DOWN, UNKNOWN_MODIFIER), (33): (</span>
<span class="gd">-    MIDDLE, MOUSE_DOWN, UNKNOWN_MODIFIER), (34): (RIGHT, MOUSE_DOWN,</span>
<span class="gd">-    UNKNOWN_MODIFIER), (35): (UNKNOWN_BUTTON, MOUSE_UP, UNKNOWN_MODIFIER),</span>
<span class="gd">-    (64): (LEFT, MOUSE_MOVE, UNKNOWN_MODIFIER), (65): (MIDDLE, MOUSE_MOVE,</span>
<span class="gd">-    UNKNOWN_MODIFIER), (66): (RIGHT, MOUSE_MOVE, UNKNOWN_MODIFIER), (67): (</span>
<span class="gd">-    NO_BUTTON, MOUSE_MOVE, UNKNOWN_MODIFIER), (96): (NO_BUTTON, SCROLL_UP,</span>
<span class="gd">-    UNKNOWN_MODIFIER), (97): (NO_BUTTON, SCROLL_DOWN, UNKNOWN_MODIFIER)}</span>
<span class="gd">-urxvt_mouse_events = {(32): (UNKNOWN_BUTTON, MOUSE_DOWN, UNKNOWN_MODIFIER),</span>
<span class="gd">-    (35): (UNKNOWN_BUTTON, MOUSE_UP, UNKNOWN_MODIFIER), (96): (NO_BUTTON,</span>
<span class="gd">-    SCROLL_UP, UNKNOWN_MODIFIER), (97): (NO_BUTTON, SCROLL_DOWN,</span>
<span class="gd">-    UNKNOWN_MODIFIER)}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def load_mouse_bindings() -&gt;KeyBindings:</span>
<span class="gi">+</span>
<span class="gi">+xterm_sgr_mouse_events = {</span>
<span class="gi">+    ( 0, &quot;m&quot;) : (LEFT, MOUSE_UP, NO_MODIFIER),                # left_up                       0+ + +  =0</span>
<span class="gi">+    ( 4, &quot;m&quot;) : (LEFT, MOUSE_UP, SHIFT),                      # left_up     Shift             0+4+ +  =4</span>
<span class="gi">+    ( 8, &quot;m&quot;) : (LEFT, MOUSE_UP, ALT),                        # left_up           Alt         0+ +8+  =8</span>
<span class="gi">+    (12, &quot;m&quot;) : (LEFT, MOUSE_UP, SHIFT_ALT),                  # left_up     Shift Alt         0+4+8+  =12</span>
<span class="gi">+    (16, &quot;m&quot;) : (LEFT, MOUSE_UP, CONTROL),                    # left_up               Control 0+ + +16=16</span>
<span class="gi">+    (20, &quot;m&quot;) : (LEFT, MOUSE_UP, SHIFT_CONTROL),              # left_up     Shift     Control 0+4+ +16=20</span>
<span class="gi">+    (24, &quot;m&quot;) : (LEFT, MOUSE_UP, ALT_CONTROL),                # left_up           Alt Control 0+ +8+16=24</span>
<span class="gi">+    (28, &quot;m&quot;) : (LEFT, MOUSE_UP, SHIFT_ALT_CONTROL),          # left_up     Shift Alt Control 0+4+8+16=28</span>
<span class="gi">+</span>
<span class="gi">+    ( 1, &quot;m&quot;) : (MIDDLE, MOUSE_UP, NO_MODIFIER),              # middle_up                     1+ + +  =1</span>
<span class="gi">+    ( 5, &quot;m&quot;) : (MIDDLE, MOUSE_UP, SHIFT),                    # middle_up   Shift             1+4+ +  =5</span>
<span class="gi">+    ( 9, &quot;m&quot;) : (MIDDLE, MOUSE_UP, ALT),                      # middle_up         Alt         1+ +8+  =9</span>
<span class="gi">+    (13, &quot;m&quot;) : (MIDDLE, MOUSE_UP, SHIFT_ALT),                # middle_up   Shift Alt         1+4+8+  =13</span>
<span class="gi">+    (17, &quot;m&quot;) : (MIDDLE, MOUSE_UP, CONTROL),                  # middle_up             Control 1+ + +16=17</span>
<span class="gi">+    (21, &quot;m&quot;) : (MIDDLE, MOUSE_UP, SHIFT_CONTROL),            # middle_up   Shift     Control 1+4+ +16=21</span>
<span class="gi">+    (25, &quot;m&quot;) : (MIDDLE, MOUSE_UP, ALT_CONTROL),              # middle_up         Alt Control 1+ +8+16=25</span>
<span class="gi">+    (29, &quot;m&quot;) : (MIDDLE, MOUSE_UP, SHIFT_ALT_CONTROL),        # middle_up   Shift Alt Control 1+4+8+16=29</span>
<span class="gi">+</span>
<span class="gi">+    ( 2, &quot;m&quot;) : (RIGHT, MOUSE_UP, NO_MODIFIER),               # right_up                      2+ + +  =2</span>
<span class="gi">+    ( 6, &quot;m&quot;) : (RIGHT, MOUSE_UP, SHIFT),                     # right_up    Shift             2+4+ +  =6</span>
<span class="gi">+    (10, &quot;m&quot;) : (RIGHT, MOUSE_UP, ALT),                       # right_up          Alt         2+ +8+  =10</span>
<span class="gi">+    (14, &quot;m&quot;) : (RIGHT, MOUSE_UP, SHIFT_ALT),                 # right_up    Shift Alt         2+4+8+  =14</span>
<span class="gi">+    (18, &quot;m&quot;) : (RIGHT, MOUSE_UP, CONTROL),                   # right_up              Control 2+ + +16=18</span>
<span class="gi">+    (22, &quot;m&quot;) : (RIGHT, MOUSE_UP, SHIFT_CONTROL),             # right_up    Shift     Control 2+4+ +16=22</span>
<span class="gi">+    (26, &quot;m&quot;) : (RIGHT, MOUSE_UP, ALT_CONTROL),               # right_up          Alt Control 2+ +8+16=26</span>
<span class="gi">+    (30, &quot;m&quot;) : (RIGHT, MOUSE_UP, SHIFT_ALT_CONTROL),         # right_up    Shift Alt Control 2+4+8+16=30</span>
<span class="gi">+</span>
<span class="gi">+    ( 0, &quot;M&quot;) : (LEFT, MOUSE_DOWN, NO_MODIFIER),              # left_down                     0+ + +  =0</span>
<span class="gi">+    ( 4, &quot;M&quot;) : (LEFT, MOUSE_DOWN, SHIFT),                    # left_down   Shift             0+4+ +  =4</span>
<span class="gi">+    ( 8, &quot;M&quot;) : (LEFT, MOUSE_DOWN, ALT),                      # left_down         Alt         0+ +8+  =8</span>
<span class="gi">+    (12, &quot;M&quot;) : (LEFT, MOUSE_DOWN, SHIFT_ALT),                # left_down   Shift Alt         0+4+8+  =12</span>
<span class="gi">+    (16, &quot;M&quot;) : (LEFT, MOUSE_DOWN, CONTROL),                  # left_down             Control 0+ + +16=16</span>
<span class="gi">+    (20, &quot;M&quot;) : (LEFT, MOUSE_DOWN, SHIFT_CONTROL),            # left_down   Shift     Control 0+4+ +16=20</span>
<span class="gi">+    (24, &quot;M&quot;) : (LEFT, MOUSE_DOWN, ALT_CONTROL),              # left_down         Alt Control 0+ +8+16=24</span>
<span class="gi">+    (28, &quot;M&quot;) : (LEFT, MOUSE_DOWN, SHIFT_ALT_CONTROL),        # left_down   Shift Alt Control 0+4+8+16=28</span>
<span class="gi">+</span>
<span class="gi">+    ( 1, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, NO_MODIFIER),            # middle_down                   1+ + +  =1</span>
<span class="gi">+    ( 5, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, SHIFT),                  # middle_down Shift             1+4+ +  =5</span>
<span class="gi">+    ( 9, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, ALT),                    # middle_down       Alt         1+ +8+  =9</span>
<span class="gi">+    (13, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, SHIFT_ALT),              # middle_down Shift Alt         1+4+8+  =13</span>
<span class="gi">+    (17, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, CONTROL),                # middle_down           Control 1+ + +16=17</span>
<span class="gi">+    (21, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, SHIFT_CONTROL),          # middle_down Shift     Control 1+4+ +16=21</span>
<span class="gi">+    (25, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, ALT_CONTROL),            # middle_down       Alt Control 1+ +8+16=25</span>
<span class="gi">+    (29, &quot;M&quot;) : (MIDDLE, MOUSE_DOWN, SHIFT_ALT_CONTROL),      # middle_down Shift Alt Control 1+4+8+16=29</span>
<span class="gi">+</span>
<span class="gi">+    ( 2, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, NO_MODIFIER),             # right_down                    2+ + +  =2</span>
<span class="gi">+    ( 6, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, SHIFT),                   # right_down  Shift             2+4+ +  =6</span>
<span class="gi">+    (10, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, ALT),                     # right_down        Alt         2+ +8+  =10</span>
<span class="gi">+    (14, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, SHIFT_ALT),               # right_down  Shift Alt         2+4+8+  =14</span>
<span class="gi">+    (18, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, CONTROL),                 # right_down            Control 2+ + +16=18</span>
<span class="gi">+    (22, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, SHIFT_CONTROL),           # right_down  Shift     Control 2+4+ +16=22</span>
<span class="gi">+    (26, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, ALT_CONTROL),             # right_down        Alt Control 2+ +8+16=26</span>
<span class="gi">+    (30, &quot;M&quot;) : (RIGHT, MOUSE_DOWN, SHIFT_ALT_CONTROL),       # right_down  Shift Alt Control 2+4+8+16=30</span>
<span class="gi">+</span>
<span class="gi">+    (32, &quot;M&quot;) : (LEFT, MOUSE_MOVE, NO_MODIFIER),              # left_drag                     32+ + +  =32</span>
<span class="gi">+    (36, &quot;M&quot;) : (LEFT, MOUSE_MOVE, SHIFT),                    # left_drag   Shift             32+4+ +  =36</span>
<span class="gi">+    (40, &quot;M&quot;) : (LEFT, MOUSE_MOVE, ALT),                      # left_drag         Alt         32+ +8+  =40</span>
<span class="gi">+    (44, &quot;M&quot;) : (LEFT, MOUSE_MOVE, SHIFT_ALT),                # left_drag   Shift Alt         32+4+8+  =44</span>
<span class="gi">+    (48, &quot;M&quot;) : (LEFT, MOUSE_MOVE, CONTROL),                  # left_drag             Control 32+ + +16=48</span>
<span class="gi">+    (52, &quot;M&quot;) : (LEFT, MOUSE_MOVE, SHIFT_CONTROL),            # left_drag   Shift     Control 32+4+ +16=52</span>
<span class="gi">+    (56, &quot;M&quot;) : (LEFT, MOUSE_MOVE, ALT_CONTROL),              # left_drag         Alt Control 32+ +8+16=56</span>
<span class="gi">+    (60, &quot;M&quot;) : (LEFT, MOUSE_MOVE, SHIFT_ALT_CONTROL),        # left_drag   Shift Alt Control 32+4+8+16=60</span>
<span class="gi">+</span>
<span class="gi">+    (33, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, NO_MODIFIER),            # middle_drag                   33+ + +  =33</span>
<span class="gi">+    (37, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, SHIFT),                  # middle_drag Shift             33+4+ +  =37</span>
<span class="gi">+    (41, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, ALT),                    # middle_drag       Alt         33+ +8+  =41</span>
<span class="gi">+    (45, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, SHIFT_ALT),              # middle_drag Shift Alt         33+4+8+  =45</span>
<span class="gi">+    (49, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, CONTROL),                # middle_drag           Control 33+ + +16=49</span>
<span class="gi">+    (53, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, SHIFT_CONTROL),          # middle_drag Shift     Control 33+4+ +16=53</span>
<span class="gi">+    (57, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, ALT_CONTROL),            # middle_drag       Alt Control 33+ +8+16=57</span>
<span class="gi">+    (61, &quot;M&quot;) : (MIDDLE, MOUSE_MOVE, SHIFT_ALT_CONTROL),      # middle_drag Shift Alt Control 33+4+8+16=61</span>
<span class="gi">+</span>
<span class="gi">+    (34, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, NO_MODIFIER),             # right_drag                    34+ + +  =34</span>
<span class="gi">+    (38, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, SHIFT),                   # right_drag  Shift             34+4+ +  =38</span>
<span class="gi">+    (42, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, ALT),                     # right_drag        Alt         34+ +8+  =42</span>
<span class="gi">+    (46, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, SHIFT_ALT),               # right_drag  Shift Alt         34+4+8+  =46</span>
<span class="gi">+    (50, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, CONTROL),                 # right_drag            Control 34+ + +16=50</span>
<span class="gi">+    (54, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, SHIFT_CONTROL),           # right_drag  Shift     Control 34+4+ +16=54</span>
<span class="gi">+    (58, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, ALT_CONTROL),             # right_drag        Alt Control 34+ +8+16=58</span>
<span class="gi">+    (62, &quot;M&quot;) : (RIGHT, MOUSE_MOVE, SHIFT_ALT_CONTROL),       # right_drag  Shift Alt Control 34+4+8+16=62</span>
<span class="gi">+</span>
<span class="gi">+    (35, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, NO_MODIFIER),         # none_drag                     35+ + +  =35</span>
<span class="gi">+    (39, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, SHIFT),               # none_drag   Shift             35+4+ +  =39</span>
<span class="gi">+    (43, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, ALT),                 # none_drag         Alt         35+ +8+  =43</span>
<span class="gi">+    (47, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, SHIFT_ALT),           # none_drag   Shift Alt         35+4+8+  =47</span>
<span class="gi">+    (51, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, CONTROL),             # none_drag             Control 35+ + +16=51</span>
<span class="gi">+    (55, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, SHIFT_CONTROL),       # none_drag   Shift     Control 35+4+ +16=55</span>
<span class="gi">+    (59, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, ALT_CONTROL),         # none_drag         Alt Control 35+ +8+16=59</span>
<span class="gi">+    (63, &quot;M&quot;) : (NO_BUTTON, MOUSE_MOVE, SHIFT_ALT_CONTROL),   # none_drag   Shift Alt Control 35+4+8+16=63</span>
<span class="gi">+</span>
<span class="gi">+    (64, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, NO_MODIFIER),          # scroll_up                     64+ + +  =64</span>
<span class="gi">+    (68, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, SHIFT),                # scroll_up   Shift             64+4+ +  =68</span>
<span class="gi">+    (72, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, ALT),                  # scroll_up         Alt         64+ +8+  =72</span>
<span class="gi">+    (76, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, SHIFT_ALT),            # scroll_up   Shift Alt         64+4+8+  =76</span>
<span class="gi">+    (80, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, CONTROL),              # scroll_up             Control 64+ + +16=80</span>
<span class="gi">+    (84, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, SHIFT_CONTROL),        # scroll_up   Shift     Control 64+4+ +16=84</span>
<span class="gi">+    (88, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, ALT_CONTROL),          # scroll_up         Alt Control 64+ +8+16=88</span>
<span class="gi">+    (92, &quot;M&quot;) : (NO_BUTTON, SCROLL_UP, SHIFT_ALT_CONTROL),    # scroll_up   Shift Alt Control 64+4+8+16=92</span>
<span class="gi">+</span>
<span class="gi">+    (65, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, NO_MODIFIER),        # scroll_down                   64+ + +  =65</span>
<span class="gi">+    (69, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, SHIFT),              # scroll_down Shift             64+4+ +  =69</span>
<span class="gi">+    (73, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, ALT),                # scroll_down       Alt         64+ +8+  =73</span>
<span class="gi">+    (77, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, SHIFT_ALT),          # scroll_down Shift Alt         64+4+8+  =77</span>
<span class="gi">+    (81, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, CONTROL),            # scroll_down           Control 64+ + +16=81</span>
<span class="gi">+    (85, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, SHIFT_CONTROL),      # scroll_down Shift     Control 64+4+ +16=85</span>
<span class="gi">+    (89, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, ALT_CONTROL),        # scroll_down       Alt Control 64+ +8+16=89</span>
<span class="gi">+    (93, &quot;M&quot;) : (NO_BUTTON, SCROLL_DOWN, SHIFT_ALT_CONTROL),  # scroll_down Shift Alt Control 64+4+8+16=93</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+typical_mouse_events = {</span>
<span class="gi">+    32: (LEFT           , MOUSE_DOWN , UNKNOWN_MODIFIER),</span>
<span class="gi">+    33: (MIDDLE         , MOUSE_DOWN , UNKNOWN_MODIFIER),</span>
<span class="gi">+    34: (RIGHT          , MOUSE_DOWN , UNKNOWN_MODIFIER),</span>
<span class="gi">+    35: (UNKNOWN_BUTTON , MOUSE_UP   , UNKNOWN_MODIFIER),</span>
<span class="gi">+</span>
<span class="gi">+    64: (LEFT           , MOUSE_MOVE , UNKNOWN_MODIFIER),</span>
<span class="gi">+    65: (MIDDLE         , MOUSE_MOVE , UNKNOWN_MODIFIER),</span>
<span class="gi">+    66: (RIGHT          , MOUSE_MOVE , UNKNOWN_MODIFIER),</span>
<span class="gi">+    67: (NO_BUTTON      , MOUSE_MOVE , UNKNOWN_MODIFIER),</span>
<span class="gi">+</span>
<span class="gi">+    96: (NO_BUTTON      , SCROLL_UP  , UNKNOWN_MODIFIER),</span>
<span class="gi">+    97: (NO_BUTTON      , SCROLL_DOWN, UNKNOWN_MODIFIER),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+urxvt_mouse_events={</span>
<span class="gi">+    32: (UNKNOWN_BUTTON, MOUSE_DOWN , UNKNOWN_MODIFIER),</span>
<span class="gi">+    35: (UNKNOWN_BUTTON, MOUSE_UP   , UNKNOWN_MODIFIER),</span>
<span class="gi">+    96: (NO_BUTTON     , SCROLL_UP  , UNKNOWN_MODIFIER),</span>
<span class="gi">+    97: (NO_BUTTON     , SCROLL_DOWN, UNKNOWN_MODIFIER),</span>
<span class="gi">+}</span>
<span class="gi">+# fmt:on</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_mouse_bindings() -&gt; KeyBindings:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Key bindings, required for mouse support.
<span class="w"> </span>    (Mouse events enter through the key binding system.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.Vt100MouseEvent)</span>
<span class="gi">+    def _(event: E) -&gt; NotImplementedOrNone:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Handling of incoming mouse event.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # TypicaL:   &quot;eSC[MaB*&quot;</span>
<span class="gi">+        # Urxvt:     &quot;Esc[96;14;13M&quot;</span>
<span class="gi">+        # Xterm SGR: &quot;Esc[&lt;64;85;12M&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Parse incoming packet.</span>
<span class="gi">+        if event.data[2] == &quot;M&quot;:</span>
<span class="gi">+            # Typical.</span>
<span class="gi">+            mouse_event, x, y = map(ord, event.data[3:])</span>
<span class="gi">+</span>
<span class="gi">+            # TODO: Is it possible to add modifiers here?</span>
<span class="gi">+            mouse_button, mouse_event_type, mouse_modifiers = typical_mouse_events[</span>
<span class="gi">+                mouse_event</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+            # Handle situations where `PosixStdinReader` used surrogateescapes.</span>
<span class="gi">+            if x &gt;= 0xDC00:</span>
<span class="gi">+                x -= 0xDC00</span>
<span class="gi">+            if y &gt;= 0xDC00:</span>
<span class="gi">+                y -= 0xDC00</span>
<span class="gi">+</span>
<span class="gi">+            x -= 32</span>
<span class="gi">+            y -= 32</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Urxvt and Xterm SGR.</span>
<span class="gi">+            # When the &#39;&lt;&#39; is not present, we are not using the Xterm SGR mode,</span>
<span class="gi">+            # but Urxvt instead.</span>
<span class="gi">+            data = event.data[2:]</span>
<span class="gi">+            if data[:1] == &quot;&lt;&quot;:</span>
<span class="gi">+                sgr = True</span>
<span class="gi">+                data = data[1:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                sgr = False</span>
<span class="gi">+</span>
<span class="gi">+            # Extract coordinates.</span>
<span class="gi">+            mouse_event, x, y = map(int, data[:-1].split(&quot;;&quot;))</span>
<span class="gi">+            m = data[-1]</span>
<span class="gi">+</span>
<span class="gi">+            # Parse event type.</span>
<span class="gi">+            if sgr:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    (</span>
<span class="gi">+                        mouse_button,</span>
<span class="gi">+                        mouse_event_type,</span>
<span class="gi">+                        mouse_modifiers,</span>
<span class="gi">+                    ) = xterm_sgr_mouse_events[mouse_event, m]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Some other terminals, like urxvt, Hyper terminal, ...</span>
<span class="gi">+                (</span>
<span class="gi">+                    mouse_button,</span>
<span class="gi">+                    mouse_event_type,</span>
<span class="gi">+                    mouse_modifiers,</span>
<span class="gi">+                ) = urxvt_mouse_events.get(</span>
<span class="gi">+                    mouse_event, (UNKNOWN_BUTTON, MOUSE_MOVE, UNKNOWN_MODIFIER)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        x -= 1</span>
<span class="gi">+        y -= 1</span>
<span class="gi">+</span>
<span class="gi">+        # Only handle mouse events when we know the window height.</span>
<span class="gi">+        if event.app.renderer.height_is_known and mouse_event_type is not None:</span>
<span class="gi">+            # Take region above the layout into account. The reported</span>
<span class="gi">+            # coordinates are absolute to the visible part of the terminal.</span>
<span class="gi">+            from prompt_toolkit.renderer import HeightIsUnknownError</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                y -= event.app.renderer.rows_above_layout</span>
<span class="gi">+            except HeightIsUnknownError:</span>
<span class="gi">+                return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+            # Call the mouse handler from the renderer.</span>
<span class="gi">+</span>
<span class="gi">+            # Note: This can return `NotImplemented` if no mouse handler was</span>
<span class="gi">+            #       found for this position, or if no repainting needs to</span>
<span class="gi">+            #       happen. this way, we avoid excessive repaints during mouse</span>
<span class="gi">+            #       movements.</span>
<span class="gi">+            handler = event.app.renderer.mouse_handlers.mouse_handlers[y][x]</span>
<span class="gi">+            return handler(</span>
<span class="gi">+                MouseEvent(</span>
<span class="gi">+                    position=Point(x=x, y=y),</span>
<span class="gi">+                    event_type=mouse_event_type,</span>
<span class="gi">+                    button=mouse_button,</span>
<span class="gi">+                    modifiers=mouse_modifiers,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.ScrollUp)</span>
<span class="gi">+    def _scroll_up(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Scroll up event without cursor position.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # We don&#39;t receive a cursor position, so we don&#39;t know which window to</span>
<span class="gi">+        # scroll. Just send an &#39;up&#39; key press instead.</span>
<span class="gi">+        event.key_processor.feed(KeyPress(Keys.Up), first=True)</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.ScrollDown)</span>
<span class="gi">+    def _scroll_down(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Scroll down event without cursor position.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.key_processor.feed(KeyPress(Keys.Down), first=True)</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.WindowsMouseEvent)</span>
<span class="gi">+    def _mouse(event: E) -&gt; NotImplementedOrNone:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Handling of mouse events for Windows.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # This key binding should only exist for Windows.</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # Parse data.</span>
<span class="gi">+            pieces = event.data.split(&quot;;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            button = MouseButton(pieces[0])</span>
<span class="gi">+            event_type = MouseEventType(pieces[1])</span>
<span class="gi">+            x = int(pieces[2])</span>
<span class="gi">+            y = int(pieces[3])</span>
<span class="gi">+</span>
<span class="gi">+            # Make coordinates absolute to the visible part of the terminal.</span>
<span class="gi">+            output = event.app.renderer.output</span>
<span class="gi">+</span>
<span class="gi">+            from prompt_toolkit.output.win32 import Win32Output</span>
<span class="gi">+            from prompt_toolkit.output.windows10 import Windows10_Output</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(output, (Win32Output, Windows10_Output)):</span>
<span class="gi">+                screen_buffer_info = output.get_win32_screen_buffer_info()</span>
<span class="gi">+                rows_above_cursor = (</span>
<span class="gi">+                    screen_buffer_info.dwCursorPosition.Y</span>
<span class="gi">+                    - event.app.renderer._cursor_pos.y</span>
<span class="gi">+                )</span>
<span class="gi">+                y -= rows_above_cursor</span>
<span class="gi">+</span>
<span class="gi">+                # Call the mouse event handler.</span>
<span class="gi">+                # (Can return `NotImplemented`.)</span>
<span class="gi">+                handler = event.app.renderer.mouse_handlers.mouse_handlers[y][x]</span>
<span class="gi">+</span>
<span class="gi">+                return handler(</span>
<span class="gi">+                    MouseEvent(</span>
<span class="gi">+                        position=Point(x=x, y=y),</span>
<span class="gi">+                        event_type=event_type,</span>
<span class="gi">+                        button=button,</span>
<span class="gi">+                        modifiers=UNKNOWN_MODIFIER,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # No mouse handler found. Return `NotImplemented` so that we don&#39;t</span>
<span class="gi">+        # invalidate the UI.</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    return key_bindings</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/named_commands.py b/src/prompt_toolkit/key_binding/bindings/named_commands.py</span>
<span class="gh">index 5b59883f..d8361169 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/named_commands.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/named_commands.py</span>
<span class="gu">@@ -4,7 +4,9 @@ Key bindings which are also known by GNU Readline by the given names.</span>
<span class="w"> </span>See: http://www.delorie.com/gnu/docs/readline/rlman_13.html
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable, TypeVar, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.enums import EditingMode
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import Binding, key_binding
<span class="gu">@@ -13,103 +15,148 @@ from prompt_toolkit.keys import Keys</span>
<span class="w"> </span>from prompt_toolkit.layout.controls import BufferControl
<span class="w"> </span>from prompt_toolkit.search import SearchDirection
<span class="w"> </span>from prompt_toolkit.selection import PasteMode
<span class="gi">+</span>
<span class="w"> </span>from .completion import display_completions_like_readline, generate_completions
<span class="gd">-__all__ = [&#39;get_by_name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;get_by_name&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Typing.</span>
<span class="w"> </span>_Handler = Callable[[KeyPressEvent], None]
<span class="w"> </span>_HandlerOrBinding = Union[_Handler, Binding]
<span class="gd">-_T = TypeVar(&#39;_T&#39;, bound=_HandlerOrBinding)</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;, bound=_HandlerOrBinding)</span>
<span class="w"> </span>E = KeyPressEvent
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Registry that maps the Readline command names to their handlers.</span>
<span class="w"> </span>_readline_commands: dict[str, Binding] = {}


<span class="gd">-def register(name: str) -&gt;Callable[[_T], _T]:</span>
<span class="gi">+def register(name: str) -&gt; Callable[[_T], _T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Store handler in the `_readline_commands` dictionary.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def decorator(handler: _T) -&gt; _T:</span>
<span class="gi">+        &quot;`handler` is a callable or Binding.&quot;</span>
<span class="gi">+        if isinstance(handler, Binding):</span>
<span class="gi">+            _readline_commands[name] = handler</span>
<span class="gi">+        else:</span>
<span class="gi">+            _readline_commands[name] = key_binding()(cast(_Handler, handler))</span>
<span class="gi">+</span>
<span class="gi">+        return handler</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>

<span class="gd">-def get_by_name(name: str) -&gt;Binding:</span>
<span class="gi">+</span>
<span class="gi">+def get_by_name(name: str) -&gt; Binding:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the handler for the (Readline) command with the given name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _readline_commands[name]</span>
<span class="gi">+    except KeyError as e:</span>
<span class="gi">+        raise KeyError(&quot;Unknown Readline command: %r&quot; % name) from e</span>
<span class="gi">+</span>

<span class="gi">+#</span>
<span class="gi">+# Commands for moving</span>
<span class="gi">+# See: http://www.delorie.com/gnu/docs/readline/rlman_14.html</span>
<span class="gi">+#</span>

<span class="gd">-@register(&#39;beginning-of-buffer&#39;)</span>
<span class="gd">-def beginning_of_buffer(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;beginning-of-buffer&quot;)</span>
<span class="gi">+def beginning_of_buffer(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the start of the buffer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.cursor_position = 0</span>


<span class="gd">-@register(&#39;end-of-buffer&#39;)</span>
<span class="gd">-def end_of_buffer(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;end-of-buffer&quot;)</span>
<span class="gi">+def end_of_buffer(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the end of the buffer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.cursor_position = len(buff.text)</span>


<span class="gd">-@register(&#39;beginning-of-line&#39;)</span>
<span class="gd">-def beginning_of_line(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;beginning-of-line&quot;)</span>
<span class="gi">+def beginning_of_line(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the start of the current line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.cursor_position += buff.document.get_start_of_line_position(</span>
<span class="gi">+        after_whitespace=False</span>
<span class="gi">+    )</span>


<span class="gd">-@register(&#39;end-of-line&#39;)</span>
<span class="gd">-def end_of_line(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;end-of-line&quot;)</span>
<span class="gi">+def end_of_line(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the end of the line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.cursor_position += buff.document.get_end_of_line_position()</span>


<span class="gd">-@register(&#39;forward-char&#39;)</span>
<span class="gd">-def forward_char(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;forward-char&quot;)</span>
<span class="gi">+def forward_char(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move forward a character.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.cursor_position += buff.document.get_cursor_right_position(count=event.arg)</span>


<span class="gd">-@register(&#39;backward-char&#39;)</span>
<span class="gd">-def backward_char(event: E) -&gt;None:</span>
<span class="gd">-    &quot;&quot;&quot;Move back a character.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+@register(&quot;backward-char&quot;)</span>
<span class="gi">+def backward_char(event: E) -&gt; None:</span>
<span class="gi">+    &quot;Move back a character.&quot;</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.cursor_position += buff.document.get_cursor_left_position(count=event.arg)</span>


<span class="gd">-@register(&#39;forward-word&#39;)</span>
<span class="gd">-def forward_word(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;forward-word&quot;)</span>
<span class="gi">+def forward_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move forward to the end of the next word. Words are composed of letters and
<span class="w"> </span>    digits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    pos = buff.document.find_next_word_ending(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    if pos:</span>
<span class="gi">+        buff.cursor_position += pos</span>


<span class="gd">-@register(&#39;backward-word&#39;)</span>
<span class="gd">-def backward_word(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;backward-word&quot;)</span>
<span class="gi">+def backward_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move back to the start of the current or previous word. Words are composed
<span class="w"> </span>    of letters and digits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    pos = buff.document.find_previous_word_beginning(count=event.arg)</span>

<span class="gi">+    if pos:</span>
<span class="gi">+        buff.cursor_position += pos</span>

<span class="gd">-@register(&#39;clear-screen&#39;)</span>
<span class="gd">-def clear_screen(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;clear-screen&quot;)</span>
<span class="gi">+def clear_screen(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clear the screen and redraw everything at the top of the screen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.renderer.clear()</span>


<span class="gd">-@register(&#39;redraw-current-line&#39;)</span>
<span class="gd">-def redraw_current_line(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;redraw-current-line&quot;)</span>
<span class="gi">+def redraw_current_line(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Refresh the current line.
<span class="w"> </span>    (Readline defines this command, but prompt-toolkit doesn&#39;t have it.)
<span class="gu">@@ -117,133 +164,188 @@ def redraw_current_line(event: E) -&gt;None:</span>
<span class="w"> </span>    pass


<span class="gd">-@register(&#39;accept-line&#39;)</span>
<span class="gd">-def accept_line(event: E) -&gt;None:</span>
<span class="gi">+#</span>
<span class="gi">+# Commands for manipulating the history.</span>
<span class="gi">+# See: http://www.delorie.com/gnu/docs/readline/rlman_15.html</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;accept-line&quot;)</span>
<span class="gi">+def accept_line(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept the line regardless of where the cursor is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.validate_and_handle()</span>


<span class="gd">-@register(&#39;previous-history&#39;)</span>
<span class="gd">-def previous_history(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;previous-history&quot;)</span>
<span class="gi">+def previous_history(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move `back` through the history list, fetching the previous command.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.history_backward(count=event.arg)</span>


<span class="gd">-@register(&#39;next-history&#39;)</span>
<span class="gd">-def next_history(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;next-history&quot;)</span>
<span class="gi">+def next_history(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move `forward` through the history list, fetching the next command.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.history_forward(count=event.arg)</span>


<span class="gd">-@register(&#39;beginning-of-history&#39;)</span>
<span class="gd">-def beginning_of_history(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;beginning-of-history&quot;)</span>
<span class="gi">+def beginning_of_history(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the first line in the history.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.go_to_history(0)</span>


<span class="gd">-@register(&#39;end-of-history&#39;)</span>
<span class="gd">-def end_of_history(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;end-of-history&quot;)</span>
<span class="gi">+def end_of_history(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the end of the input history, i.e., the line currently being entered.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.history_forward(count=10**100)</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.go_to_history(len(buff._working_lines) - 1)</span>


<span class="gd">-@register(&#39;reverse-search-history&#39;)</span>
<span class="gd">-def reverse_search_history(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;reverse-search-history&quot;)</span>
<span class="gi">+def reverse_search_history(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Search backward starting at the current line and moving `up` through
<span class="w"> </span>    the history as necessary. This is an incremental search.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    control = event.app.layout.current_control</span>

<span class="gi">+    if isinstance(control, BufferControl) and control.search_buffer_control:</span>
<span class="gi">+        event.app.current_search_state.direction = SearchDirection.BACKWARD</span>
<span class="gi">+        event.app.layout.current_control = control.search_buffer_control</span>

<span class="gd">-@register(&#39;end-of-file&#39;)</span>
<span class="gd">-def end_of_file(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+# Commands for changing text</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;end-of-file&quot;)</span>
<span class="gi">+def end_of_file(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Exit.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.exit()</span>


<span class="gd">-@register(&#39;delete-char&#39;)</span>
<span class="gd">-def delete_char(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;delete-char&quot;)</span>
<span class="gi">+def delete_char(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Delete character before the cursor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deleted = event.current_buffer.delete(count=event.arg)</span>
<span class="gi">+    if not deleted:</span>
<span class="gi">+        event.app.output.bell()</span>


<span class="gd">-@register(&#39;backward-delete-char&#39;)</span>
<span class="gd">-def backward_delete_char(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;backward-delete-char&quot;)</span>
<span class="gi">+def backward_delete_char(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Delete the character behind the cursor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if event.arg &lt; 0:</span>
<span class="gi">+        # When a negative argument has been given, this should delete in front</span>
<span class="gi">+        # of the cursor.</span>
<span class="gi">+        deleted = event.current_buffer.delete(count=-event.arg)</span>
<span class="gi">+    else:</span>
<span class="gi">+        deleted = event.current_buffer.delete_before_cursor(count=event.arg)</span>

<span class="gi">+    if not deleted:</span>
<span class="gi">+        event.app.output.bell()</span>

<span class="gd">-@register(&#39;self-insert&#39;)</span>
<span class="gd">-def self_insert(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;self-insert&quot;)</span>
<span class="gi">+def self_insert(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Insert yourself.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.insert_text(event.data * event.arg)</span>


<span class="gd">-@register(&#39;transpose-chars&#39;)</span>
<span class="gd">-def transpose_chars(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;transpose-chars&quot;)</span>
<span class="gi">+def transpose_chars(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Emulate Emacs transpose-char behavior: at the beginning of the buffer,
<span class="w"> </span>    do nothing.  At the end of a line or buffer, swap the characters before
<span class="w"> </span>    the cursor.  Otherwise, move the cursor right, and then swap the
<span class="w"> </span>    characters before the cursor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b = event.current_buffer</span>
<span class="gi">+    p = b.cursor_position</span>
<span class="gi">+    if p == 0:</span>
<span class="gi">+        return</span>
<span class="gi">+    elif p == len(b.text) or b.text[p] == &quot;\n&quot;:</span>
<span class="gi">+        b.swap_characters_before_cursor()</span>
<span class="gi">+    else:</span>
<span class="gi">+        b.cursor_position += b.document.get_cursor_right_position()</span>
<span class="gi">+        b.swap_characters_before_cursor()</span>


<span class="gd">-@register(&#39;uppercase-word&#39;)</span>
<span class="gd">-def uppercase_word(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;uppercase-word&quot;)</span>
<span class="gi">+def uppercase_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Uppercase the current (or following) word.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>

<span class="gi">+    for i in range(event.arg):</span>
<span class="gi">+        pos = buff.document.find_next_word_ending()</span>
<span class="gi">+        words = buff.document.text_after_cursor[:pos]</span>
<span class="gi">+        buff.insert_text(words.upper(), overwrite=True)</span>

<span class="gd">-@register(&#39;downcase-word&#39;)</span>
<span class="gd">-def downcase_word(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;downcase-word&quot;)</span>
<span class="gi">+def downcase_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Lowercase the current (or following) word.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(event.arg):  # XXX: not DRY: see meta_c and meta_u!!</span>
<span class="gi">+        pos = buff.document.find_next_word_ending()</span>
<span class="gi">+        words = buff.document.text_after_cursor[:pos]</span>
<span class="gi">+        buff.insert_text(words.lower(), overwrite=True)</span>


<span class="gd">-@register(&#39;capitalize-word&#39;)</span>
<span class="gd">-def capitalize_word(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;capitalize-word&quot;)</span>
<span class="gi">+def capitalize_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Capitalize the current (or following) word.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(event.arg):</span>
<span class="gi">+        pos = buff.document.find_next_word_ending()</span>
<span class="gi">+        words = buff.document.text_after_cursor[:pos]</span>
<span class="gi">+        buff.insert_text(words.title(), overwrite=True)</span>


<span class="gd">-@register(&#39;quoted-insert&#39;)</span>
<span class="gd">-def quoted_insert(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;quoted-insert&quot;)</span>
<span class="gi">+def quoted_insert(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Add the next character typed to the line verbatim. This is how to insert
<span class="w"> </span>    key sequences like C-q, for example.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.quoted_insert = True</span>


<span class="gd">-@register(&#39;kill-line&#39;)</span>
<span class="gd">-def kill_line(event: E) -&gt;None:</span>
<span class="gi">+#</span>
<span class="gi">+# Killing and yanking.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;kill-line&quot;)</span>
<span class="gi">+def kill_line(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Kill the text from the cursor to the end of the line.

<span class="gu">@@ -251,132 +353,208 @@ def kill_line(event: E) -&gt;None:</span>
<span class="w"> </span>    (That way, it is possible to delete multiple lines by executing this
<span class="w"> </span>    command multiple times.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    if event.arg &lt; 0:</span>
<span class="gi">+        deleted = buff.delete_before_cursor(</span>
<span class="gi">+            count=-buff.document.get_start_of_line_position()</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        if buff.document.current_char == &quot;\n&quot;:</span>
<span class="gi">+            deleted = buff.delete(1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            deleted = buff.delete(count=buff.document.get_end_of_line_position())</span>
<span class="gi">+    event.app.clipboard.set_text(deleted)</span>


<span class="gd">-@register(&#39;kill-word&#39;)</span>
<span class="gd">-def kill_word(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;kill-word&quot;)</span>
<span class="gi">+def kill_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Kill from point to the end of the current word, or if between words, to the
<span class="w"> </span>    end of the next word. Word boundaries are the same as forward-word.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    pos = buff.document.find_next_word_ending(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    if pos:</span>
<span class="gi">+        deleted = buff.delete(count=pos)</span>
<span class="gi">+</span>
<span class="gi">+        if event.is_repeat:</span>
<span class="gi">+            deleted = event.app.clipboard.get_data().text + deleted</span>
<span class="gi">+</span>
<span class="gi">+        event.app.clipboard.set_text(deleted)</span>


<span class="gd">-@register(&#39;unix-word-rubout&#39;)</span>
<span class="gd">-def unix_word_rubout(event: E, WORD: bool=True) -&gt;None:</span>
<span class="gi">+@register(&quot;unix-word-rubout&quot;)</span>
<span class="gi">+def unix_word_rubout(event: E, WORD: bool = True) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Kill the word behind point, using whitespace as a word boundary.
<span class="w"> </span>    Usually bound to ControlW.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    pos = buff.document.find_start_of_previous_word(count=event.arg, WORD=WORD)</span>
<span class="gi">+</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        # Nothing found? delete until the start of the document.  (The</span>
<span class="gi">+        # input starts with whitespace and no words were found before the</span>
<span class="gi">+        # cursor.)</span>
<span class="gi">+        pos = -buff.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+    if pos:</span>
<span class="gi">+        deleted = buff.delete_before_cursor(count=-pos)</span>

<span class="gi">+        # If the previous key press was also Control-W, concatenate deleted</span>
<span class="gi">+        # text.</span>
<span class="gi">+        if event.is_repeat:</span>
<span class="gi">+            deleted += event.app.clipboard.get_data().text</span>

<span class="gd">-@register(&#39;backward-kill-word&#39;)</span>
<span class="gd">-def backward_kill_word(event: E) -&gt;None:</span>
<span class="gi">+        event.app.clipboard.set_text(deleted)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Nothing to delete. Bell.</span>
<span class="gi">+        event.app.output.bell()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;backward-kill-word&quot;)</span>
<span class="gi">+def backward_kill_word(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Kills the word before point, using &quot;not a letter nor a digit&quot; as a word boundary.
<span class="w"> </span>    Usually bound to M-Del or M-Backspace.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unix_word_rubout(event, WORD=False)</span>


<span class="gd">-@register(&#39;delete-horizontal-space&#39;)</span>
<span class="gd">-def delete_horizontal_space(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;delete-horizontal-space&quot;)</span>
<span class="gi">+def delete_horizontal_space(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Delete all spaces and tabs around point.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    text_before_cursor = buff.document.text_before_cursor</span>
<span class="gi">+    text_after_cursor = buff.document.text_after_cursor</span>

<span class="gi">+    delete_before = len(text_before_cursor) - len(text_before_cursor.rstrip(&quot;\t &quot;))</span>
<span class="gi">+    delete_after = len(text_after_cursor) - len(text_after_cursor.lstrip(&quot;\t &quot;))</span>

<span class="gd">-@register(&#39;unix-line-discard&#39;)</span>
<span class="gd">-def unix_line_discard(event: E) -&gt;None:</span>
<span class="gi">+    buff.delete_before_cursor(count=delete_before)</span>
<span class="gi">+    buff.delete(count=delete_after)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;unix-line-discard&quot;)</span>
<span class="gi">+def unix_line_discard(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Kill backward from the cursor to the beginning of the current line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>

<span class="gi">+    if buff.document.cursor_position_col == 0 and buff.document.cursor_position &gt; 0:</span>
<span class="gi">+        buff.delete_before_cursor(count=1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        deleted = buff.delete_before_cursor(</span>
<span class="gi">+            count=-buff.document.get_start_of_line_position()</span>
<span class="gi">+        )</span>
<span class="gi">+        event.app.clipboard.set_text(deleted)</span>

<span class="gd">-@register(&#39;yank&#39;)</span>
<span class="gd">-def yank(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;yank&quot;)</span>
<span class="gi">+def yank(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Paste before cursor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.paste_clipboard_data(</span>
<span class="gi">+        event.app.clipboard.get_data(), count=event.arg, paste_mode=PasteMode.EMACS</span>
<span class="gi">+    )</span>


<span class="gd">-@register(&#39;yank-nth-arg&#39;)</span>
<span class="gd">-def yank_nth_arg(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;yank-nth-arg&quot;)</span>
<span class="gi">+def yank_nth_arg(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Insert the first argument of the previous command. With an argument, insert
<span class="w"> </span>    the nth word from the previous command (start counting at 0).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = event.arg if event.arg_present else None</span>
<span class="gi">+    event.current_buffer.yank_nth_arg(n)</span>


<span class="gd">-@register(&#39;yank-last-arg&#39;)</span>
<span class="gd">-def yank_last_arg(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;yank-last-arg&quot;)</span>
<span class="gi">+def yank_last_arg(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Like `yank_nth_arg`, but if no argument has been given, yank the last word
<span class="w"> </span>    of each line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = event.arg if event.arg_present else None</span>
<span class="gi">+    event.current_buffer.yank_last_arg(n)</span>


<span class="gd">-@register(&#39;yank-pop&#39;)</span>
<span class="gd">-def yank_pop(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;yank-pop&quot;)</span>
<span class="gi">+def yank_pop(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Rotate the kill ring, and yank the new top. Only works following yank or
<span class="w"> </span>    yank-pop.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    doc_before_paste = buff.document_before_paste</span>
<span class="gi">+    clipboard = event.app.clipboard</span>
<span class="gi">+</span>
<span class="gi">+    if doc_before_paste is not None:</span>
<span class="gi">+        buff.document = doc_before_paste</span>
<span class="gi">+        clipboard.rotate()</span>
<span class="gi">+        buff.paste_clipboard_data(clipboard.get_data(), paste_mode=PasteMode.EMACS)</span>
<span class="gi">+</span>

<span class="gi">+#</span>
<span class="gi">+# Completion.</span>
<span class="gi">+#</span>

<span class="gd">-@register(&#39;complete&#39;)</span>
<span class="gd">-def complete(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;complete&quot;)</span>
<span class="gi">+def complete(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attempt to perform completion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    display_completions_like_readline(event)</span>


<span class="gd">-@register(&#39;menu-complete&#39;)</span>
<span class="gd">-def menu_complete(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;menu-complete&quot;)</span>
<span class="gi">+def menu_complete(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generate completions, or go to the next completion. (This is the default
<span class="w"> </span>    way of completing input in prompt_toolkit.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    generate_completions(event)</span>


<span class="gd">-@register(&#39;menu-complete-backward&#39;)</span>
<span class="gd">-def menu_complete_backward(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;menu-complete-backward&quot;)</span>
<span class="gi">+def menu_complete_backward(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move backward through the list of possible completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.complete_previous()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+# Keyboard macros.</span>
<span class="gi">+#</span>


<span class="gd">-@register(&#39;start-kbd-macro&#39;)</span>
<span class="gd">-def start_kbd_macro(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;start-kbd-macro&quot;)</span>
<span class="gi">+def start_kbd_macro(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Begin saving the characters typed into the current keyboard macro.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.emacs_state.start_macro()</span>


<span class="gd">-@register(&#39;end-kbd-macro&#39;)</span>
<span class="gd">-def end_kbd_macro(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;end-kbd-macro&quot;)</span>
<span class="gi">+def end_kbd_macro(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Stop saving the characters typed into the current keyboard macro and save
<span class="w"> </span>    the definition.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.emacs_state.end_macro()</span>


<span class="gd">-@register(&#39;call-last-kbd-macro&#39;)</span>
<span class="gi">+@register(&quot;call-last-kbd-macro&quot;)</span>
<span class="w"> </span>@key_binding(record_in_macro=False)
<span class="gd">-def call_last_kbd_macro(event: E) -&gt;None:</span>
<span class="gi">+def call_last_kbd_macro(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Re-execute the last keyboard macro defined, by making the characters in the
<span class="w"> </span>    macro appear as if typed at the keyboard.
<span class="gu">@@ -386,53 +564,90 @@ def call_last_kbd_macro(event: E) -&gt;None:</span>
<span class="w"> </span>    the body of the called macro back into the KeyProcessor, so these keys will
<span class="w"> </span>    be added later on to the macro of their handlers have `record_in_macro=True`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Insert the macro.</span>
<span class="gi">+    macro = event.app.emacs_state.macro</span>
<span class="gi">+</span>
<span class="gi">+    if macro:</span>
<span class="gi">+        event.app.key_processor.feed_multiple(macro, first=True)</span>


<span class="gd">-@register(&#39;print-last-kbd-macro&#39;)</span>
<span class="gd">-def print_last_kbd_macro(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;print-last-kbd-macro&quot;)</span>
<span class="gi">+def print_last_kbd_macro(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Print the last keyboard macro.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    # TODO: Make the format suitable for the inputrc file.</span>
<span class="gi">+    def print_macro() -&gt; None:</span>
<span class="gi">+        macro = event.app.emacs_state.macro</span>
<span class="gi">+        if macro:</span>
<span class="gi">+            for k in macro:</span>
<span class="gi">+                print(k)</span>
<span class="gi">+</span>
<span class="gi">+    from prompt_toolkit.application.run_in_terminal import run_in_terminal</span>
<span class="gi">+</span>
<span class="gi">+    run_in_terminal(print_macro)</span>

<span class="gd">-@register(&#39;undo&#39;)</span>
<span class="gd">-def undo(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+# Miscellaneous Commands.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;undo&quot;)</span>
<span class="gi">+def undo(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Incremental undo.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.undo()</span>


<span class="gd">-@register(&#39;insert-comment&#39;)</span>
<span class="gd">-def insert_comment(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;insert-comment&quot;)</span>
<span class="gi">+def insert_comment(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Without numeric argument, comment all lines.
<span class="w"> </span>    With numeric argument, uncomment all lines.
<span class="w"> </span>    In any case accept the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    # Transform all lines.</span>
<span class="gi">+    if event.arg != 1:</span>

<span class="gi">+        def change(line: str) -&gt; str:</span>
<span class="gi">+            return line[1:] if line.startswith(&quot;#&quot;) else line</span>

<span class="gd">-@register(&#39;vi-editing-mode&#39;)</span>
<span class="gd">-def vi_editing_mode(event: E) -&gt;None:</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def change(line: str) -&gt; str:</span>
<span class="gi">+            return &quot;#&quot; + line</span>
<span class="gi">+</span>
<span class="gi">+    buff.document = Document(</span>
<span class="gi">+        text=&quot;\n&quot;.join(map(change, buff.text.splitlines())), cursor_position=0</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Accept input.</span>
<span class="gi">+    buff.validate_and_handle()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;vi-editing-mode&quot;)</span>
<span class="gi">+def vi_editing_mode(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Switch to Vi editing mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.editing_mode = EditingMode.VI</span>


<span class="gd">-@register(&#39;emacs-editing-mode&#39;)</span>
<span class="gd">-def emacs_editing_mode(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;emacs-editing-mode&quot;)</span>
<span class="gi">+def emacs_editing_mode(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Switch to Emacs editing mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.editing_mode = EditingMode.EMACS</span>


<span class="gd">-@register(&#39;prefix-meta&#39;)</span>
<span class="gd">-def prefix_meta(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;prefix-meta&quot;)</span>
<span class="gi">+def prefix_meta(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Metafy the next character typed. This is for keyboards without a meta key.

<span class="gu">@@ -440,21 +655,36 @@ def prefix_meta(event: E) -&gt;None:</span>

<span class="w"> </span>        key_bindings.add_key_binding(&#39;j&#39;, &#39;j&#39;, filter=ViInsertMode())(prefix_meta)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # (&#39;first&#39; should be true, because we want to insert it at the current</span>
<span class="gi">+    # position in the queue.)</span>
<span class="gi">+    event.app.key_processor.feed(KeyPress(Keys.Escape), first=True)</span>


<span class="gd">-@register(&#39;operate-and-get-next&#39;)</span>
<span class="gd">-def operate_and_get_next(event: E) -&gt;None:</span>
<span class="gi">+@register(&quot;operate-and-get-next&quot;)</span>
<span class="gi">+def operate_and_get_next(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept the current line for execution and fetch the next line relative to
<span class="w"> </span>    the current line from the history for editing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    new_index = buff.working_index + 1</span>
<span class="gi">+</span>
<span class="gi">+    # Accept the current input. (This will also redraw the interface in the</span>
<span class="gi">+    # &#39;done&#39; state.)</span>
<span class="gi">+    buff.validate_and_handle()</span>

<span class="gi">+    # Set the new index at the start of the next run.</span>
<span class="gi">+    def set_working_index() -&gt; None:</span>
<span class="gi">+        if new_index &lt; len(buff._working_lines):</span>
<span class="gi">+            buff.working_index = new_index</span>

<span class="gd">-@register(&#39;edit-and-execute-command&#39;)</span>
<span class="gd">-def edit_and_execute(event: E) -&gt;None:</span>
<span class="gi">+    event.app.pre_run_callables.append(set_working_index)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@register(&quot;edit-and-execute-command&quot;)</span>
<span class="gi">+def edit_and_execute(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Invoke an editor on the current command line, and accept the result.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buff = event.current_buffer</span>
<span class="gi">+    buff.open_in_editor(validate_and_handle=True)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/open_in_editor.py b/src/prompt_toolkit/key_binding/bindings/open_in_editor.py</span>
<span class="gh">index 6199de8b..d156424f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/open_in_editor.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/open_in_editor.py</span>
<span class="gu">@@ -2,29 +2,50 @@</span>
<span class="w"> </span>Open in editor key bindings.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.filters import emacs_mode, has_selection, vi_navigation_mode
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import KeyBindings, KeyBindingsBase, merge_key_bindings
<span class="w"> </span>from .named_commands import get_by_name
<span class="gd">-__all__ = [&#39;load_open_in_editor_bindings&#39;,</span>
<span class="gd">-    &#39;load_emacs_open_in_editor_bindings&#39;, &#39;load_vi_open_in_editor_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_open_in_editor_bindings&quot;,</span>
<span class="gi">+    &quot;load_emacs_open_in_editor_bindings&quot;,</span>
<span class="gi">+    &quot;load_vi_open_in_editor_bindings&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def load_open_in_editor_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+def load_open_in_editor_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Load both the Vi and emacs key bindings for handling edit-and-execute-command.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return merge_key_bindings(</span>
<span class="gi">+        [</span>
<span class="gi">+            load_emacs_open_in_editor_bindings(),</span>
<span class="gi">+            load_vi_open_in_editor_bindings(),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>


<span class="gd">-def load_emacs_open_in_editor_bindings() -&gt;KeyBindings:</span>
<span class="gi">+def load_emacs_open_in_editor_bindings() -&gt; KeyBindings:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Pressing C-X C-E will open the buffer in an external editor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    key_bindings.add(&quot;c-x&quot;, &quot;c-e&quot;, filter=emacs_mode &amp; ~has_selection)(</span>
<span class="gi">+        get_by_name(&quot;edit-and-execute-command&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return key_bindings</span>


<span class="gd">-def load_vi_open_in_editor_bindings() -&gt;KeyBindings:</span>
<span class="gi">+def load_vi_open_in_editor_bindings() -&gt; KeyBindings:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Pressing &#39;v&#39; in navigation mode will open the buffer in an external editor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    key_bindings.add(&quot;v&quot;, filter=vi_navigation_mode)(</span>
<span class="gi">+        get_by_name(&quot;edit-and-execute-command&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    return key_bindings</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/page_navigation.py b/src/prompt_toolkit/key_binding/bindings/page_navigation.py</span>
<span class="gh">index 302f662b..3918e141 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/page_navigation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/page_navigation.py</span>
<span class="gu">@@ -3,31 +3,82 @@ Key bindings for extra page navigation: bindings for up/down scrolling through</span>
<span class="w"> </span>long pages, like in Emacs or Vi.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.filters import buffer_has_focus, emacs_mode, vi_mode
<span class="gd">-from prompt_toolkit.key_binding.key_bindings import ConditionalKeyBindings, KeyBindings, KeyBindingsBase, merge_key_bindings</span>
<span class="gd">-from .scroll import scroll_backward, scroll_forward, scroll_half_page_down, scroll_half_page_up, scroll_one_line_down, scroll_one_line_up, scroll_page_down, scroll_page_up</span>
<span class="gd">-__all__ = [&#39;load_page_navigation_bindings&#39;,</span>
<span class="gd">-    &#39;load_emacs_page_navigation_bindings&#39;, &#39;load_vi_page_navigation_bindings&#39;]</span>
<span class="gi">+from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+    ConditionalKeyBindings,</span>
<span class="gi">+    KeyBindings,</span>
<span class="gi">+    KeyBindingsBase,</span>
<span class="gi">+    merge_key_bindings,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+from .scroll import (</span>
<span class="gi">+    scroll_backward,</span>
<span class="gi">+    scroll_forward,</span>
<span class="gi">+    scroll_half_page_down,</span>
<span class="gi">+    scroll_half_page_up,</span>
<span class="gi">+    scroll_one_line_down,</span>
<span class="gi">+    scroll_one_line_up,</span>
<span class="gi">+    scroll_page_down,</span>
<span class="gi">+    scroll_page_up,</span>
<span class="gi">+)</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_page_navigation_bindings&quot;,</span>
<span class="gi">+    &quot;load_emacs_page_navigation_bindings&quot;,</span>
<span class="gi">+    &quot;load_vi_page_navigation_bindings&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-def load_page_navigation_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+</span>
<span class="gi">+def load_page_navigation_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Load both the Vi and Emacs bindings for page navigation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Only enable when a `Buffer` is focused, otherwise, we would catch keys</span>
<span class="gi">+    # when another widget is focused (like for instance `c-d` in a</span>
<span class="gi">+    # ptterm.Terminal).</span>
<span class="gi">+    return ConditionalKeyBindings(</span>
<span class="gi">+        merge_key_bindings(</span>
<span class="gi">+            [</span>
<span class="gi">+                load_emacs_page_navigation_bindings(),</span>
<span class="gi">+                load_vi_page_navigation_bindings(),</span>
<span class="gi">+            ]</span>
<span class="gi">+        ),</span>
<span class="gi">+        buffer_has_focus,</span>
<span class="gi">+    )</span>


<span class="gd">-def load_emacs_page_navigation_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+def load_emacs_page_navigation_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Key bindings, for scrolling up and down through pages.
<span class="w"> </span>    This are separate bindings, because GNU readline doesn&#39;t have them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-v&quot;)(scroll_page_down)</span>
<span class="gi">+    handle(&quot;pagedown&quot;)(scroll_page_down)</span>
<span class="gi">+    handle(&quot;escape&quot;, &quot;v&quot;)(scroll_page_up)</span>
<span class="gi">+    handle(&quot;pageup&quot;)(scroll_page_up)</span>

<span class="gi">+    return ConditionalKeyBindings(key_bindings, emacs_mode)</span>

<span class="gd">-def load_vi_page_navigation_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+</span>
<span class="gi">+def load_vi_page_navigation_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Key bindings, for scrolling up and down through pages.
<span class="w"> </span>    This are separate bindings, because GNU readline doesn&#39;t have them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-f&quot;)(scroll_forward)</span>
<span class="gi">+    handle(&quot;c-b&quot;)(scroll_backward)</span>
<span class="gi">+    handle(&quot;c-d&quot;)(scroll_half_page_down)</span>
<span class="gi">+    handle(&quot;c-u&quot;)(scroll_half_page_up)</span>
<span class="gi">+    handle(&quot;c-e&quot;)(scroll_one_line_down)</span>
<span class="gi">+    handle(&quot;c-y&quot;)(scroll_one_line_up)</span>
<span class="gi">+    handle(&quot;pagedown&quot;)(scroll_page_down)</span>
<span class="gi">+    handle(&quot;pageup&quot;)(scroll_page_up)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(key_bindings, vi_mode)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/scroll.py b/src/prompt_toolkit/key_binding/bindings/scroll.py</span>
<span class="gh">index c1d1ada6..83a4be1f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/scroll.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/scroll.py</span>
<span class="gu">@@ -6,63 +6,184 @@ they are very useful for navigating through long multiline buffers, like in</span>
<span class="w"> </span>Vi, Emacs, etc...
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="gd">-__all__ = [&#39;scroll_forward&#39;, &#39;scroll_backward&#39;, &#39;scroll_half_page_up&#39;,</span>
<span class="gd">-    &#39;scroll_half_page_down&#39;, &#39;scroll_one_line_up&#39;, &#39;scroll_one_line_down&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;scroll_forward&quot;,</span>
<span class="gi">+    &quot;scroll_backward&quot;,</span>
<span class="gi">+    &quot;scroll_half_page_up&quot;,</span>
<span class="gi">+    &quot;scroll_half_page_down&quot;,</span>
<span class="gi">+    &quot;scroll_one_line_up&quot;,</span>
<span class="gi">+    &quot;scroll_one_line_down&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def scroll_forward(event: E, half: bool=False) -&gt;None:</span>
<span class="gi">+def scroll_forward(event: E, half: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll window down.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    if w and w.render_info:</span>
<span class="gi">+        info = w.render_info</span>
<span class="gi">+        ui_content = info.ui_content</span>
<span class="gi">+</span>
<span class="gi">+        # Height to scroll.</span>
<span class="gi">+        scroll_height = info.window_height</span>
<span class="gi">+        if half:</span>
<span class="gi">+            scroll_height //= 2</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate how many lines is equivalent to that vertical space.</span>
<span class="gi">+        y = b.document.cursor_position_row + 1</span>
<span class="gi">+        height = 0</span>
<span class="gi">+        while y &lt; ui_content.line_count:</span>
<span class="gi">+            line_height = info.get_height_for_line(y)</span>

<span class="gi">+            if height + line_height &lt; scroll_height:</span>
<span class="gi">+                height += line_height</span>
<span class="gi">+                y += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>

<span class="gd">-def scroll_backward(event: E, half: bool=False) -&gt;None:</span>
<span class="gi">+        b.cursor_position = b.document.translate_row_col_to_index(y, 0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def scroll_backward(event: E, half: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll window up.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    if w and w.render_info:</span>
<span class="gi">+        info = w.render_info</span>
<span class="gi">+</span>
<span class="gi">+        # Height to scroll.</span>
<span class="gi">+        scroll_height = info.window_height</span>
<span class="gi">+        if half:</span>
<span class="gi">+            scroll_height //= 2</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate how many lines is equivalent to that vertical space.</span>
<span class="gi">+        y = max(0, b.document.cursor_position_row - 1)</span>
<span class="gi">+        height = 0</span>
<span class="gi">+        while y &gt; 0:</span>
<span class="gi">+            line_height = info.get_height_for_line(y)</span>
<span class="gi">+</span>
<span class="gi">+            if height + line_height &lt; scroll_height:</span>
<span class="gi">+                height += line_height</span>
<span class="gi">+                y -= 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>

<span class="gi">+        b.cursor_position = b.document.translate_row_col_to_index(y, 0)</span>

<span class="gd">-def scroll_half_page_down(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def scroll_half_page_down(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Same as ControlF, but only scroll half a page.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scroll_forward(event, half=True)</span>


<span class="gd">-def scroll_half_page_up(event: E) -&gt;None:</span>
<span class="gi">+def scroll_half_page_up(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Same as ControlB, but only scroll half a page.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scroll_backward(event, half=True)</span>


<span class="gd">-def scroll_one_line_down(event: E) -&gt;None:</span>
<span class="gi">+def scroll_one_line_down(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    scroll_offset += 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    if w:</span>
<span class="gi">+        # When the cursor is at the top, move to the next line. (Otherwise, only scroll.)</span>
<span class="gi">+        if w.render_info:</span>
<span class="gi">+            info = w.render_info</span>
<span class="gi">+</span>
<span class="gi">+            if w.vertical_scroll &lt; info.content_height - info.window_height:</span>
<span class="gi">+                if info.cursor_position.y &lt;= info.configured_scroll_offsets.top:</span>
<span class="gi">+                    b.cursor_position += b.document.get_cursor_down_position()</span>

<span class="gi">+                w.vertical_scroll += 1</span>

<span class="gd">-def scroll_one_line_up(event: E) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def scroll_one_line_up(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    scroll_offset -= 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    if w:</span>
<span class="gi">+        # When the cursor is at the bottom, move to the previous line. (Otherwise, only scroll.)</span>
<span class="gi">+        if w.render_info:</span>
<span class="gi">+            info = w.render_info</span>
<span class="gi">+</span>
<span class="gi">+            if w.vertical_scroll &gt; 0:</span>
<span class="gi">+                first_line_height = info.get_height_for_line(info.first_visible_line())</span>

<span class="gi">+                cursor_up = info.cursor_position.y - (</span>
<span class="gi">+                    info.window_height</span>
<span class="gi">+                    - 1</span>
<span class="gi">+                    - first_line_height</span>
<span class="gi">+                    - info.configured_scroll_offsets.bottom</span>
<span class="gi">+                )</span>

<span class="gd">-def scroll_page_down(event: E) -&gt;None:</span>
<span class="gi">+                # Move cursor up, as many steps as the height of the first line.</span>
<span class="gi">+                # TODO: not entirely correct yet, in case of line wrapping and many long lines.</span>
<span class="gi">+                for _ in range(max(0, cursor_up)):</span>
<span class="gi">+                    b.cursor_position += b.document.get_cursor_up_position()</span>
<span class="gi">+</span>
<span class="gi">+                # Scroll window</span>
<span class="gi">+                w.vertical_scroll -= 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def scroll_page_down(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll page down. (Prefer the cursor at the top of the page, after scrolling.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    if w and w.render_info:</span>
<span class="gi">+        # Scroll down one page.</span>
<span class="gi">+        line_index = max(w.render_info.last_visible_line(), w.vertical_scroll + 1)</span>
<span class="gi">+        w.vertical_scroll = line_index</span>
<span class="gi">+</span>
<span class="gi">+        b.cursor_position = b.document.translate_row_col_to_index(line_index, 0)</span>
<span class="gi">+        b.cursor_position += b.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>


<span class="gd">-def scroll_page_up(event: E) -&gt;None:</span>
<span class="gi">+def scroll_page_up(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll page up. (Prefer the cursor at the bottom of the page, after scrolling.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    if w and w.render_info:</span>
<span class="gi">+        # Put cursor at the first visible line. (But make sure that the cursor</span>
<span class="gi">+        # moves at least one line up.)</span>
<span class="gi">+        line_index = max(</span>
<span class="gi">+            0,</span>
<span class="gi">+            min(w.render_info.first_visible_line(), b.document.cursor_position_row - 1),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        b.cursor_position = b.document.translate_row_col_to_index(line_index, 0)</span>
<span class="gi">+        b.cursor_position += b.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Set the scroll offset. We can safely set it to zero; the Window will</span>
<span class="gi">+        # make sure that it scrolls at least until the cursor becomes visible.</span>
<span class="gi">+        w.vertical_scroll = 0</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/search.py b/src/prompt_toolkit/key_binding/bindings/search.py</span>
<span class="gh">index 3df6124e..ba5e117f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/search.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/search.py</span>
<span class="gu">@@ -2,83 +2,94 @@</span>
<span class="w"> </span>Search related key bindings.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit import search
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.filters import Condition, control_is_searchable, is_searching
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import key_binding
<span class="gd">-__all__ = [&#39;abort_search&#39;, &#39;accept_search&#39;,</span>
<span class="gd">-    &#39;start_reverse_incremental_search&#39;, &#39;start_forward_incremental_search&#39;,</span>
<span class="gd">-    &#39;reverse_incremental_search&#39;, &#39;forward_incremental_search&#39;,</span>
<span class="gd">-    &#39;accept_search_and_accept_input&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;abort_search&quot;,</span>
<span class="gi">+    &quot;accept_search&quot;,</span>
<span class="gi">+    &quot;start_reverse_incremental_search&quot;,</span>
<span class="gi">+    &quot;start_forward_incremental_search&quot;,</span>
<span class="gi">+    &quot;reverse_incremental_search&quot;,</span>
<span class="gi">+    &quot;forward_incremental_search&quot;,</span>
<span class="gi">+    &quot;accept_search_and_accept_input&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gd">-def abort_search(event: E) -&gt;None:</span>
<span class="gi">+def abort_search(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Abort an incremental search and restore the original
<span class="w"> </span>    line.
<span class="w"> </span>    (Usually bound to ControlG/ControlC.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.stop_search()</span>


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gd">-def accept_search(event: E) -&gt;None:</span>
<span class="gi">+def accept_search(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    When enter pressed in isearch, quit isearch mode. (Multiline
<span class="w"> </span>    isearch would be too complicated.)
<span class="w"> </span>    (Usually bound to Enter.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.accept_search()</span>


<span class="w"> </span>@key_binding(filter=control_is_searchable)
<span class="gd">-def start_reverse_incremental_search(event: E) -&gt;None:</span>
<span class="gi">+def start_reverse_incremental_search(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enter reverse incremental search.
<span class="w"> </span>    (Usually ControlR.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.start_search(direction=search.SearchDirection.BACKWARD)</span>


<span class="w"> </span>@key_binding(filter=control_is_searchable)
<span class="gd">-def start_forward_incremental_search(event: E) -&gt;None:</span>
<span class="gi">+def start_forward_incremental_search(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enter forward incremental search.
<span class="w"> </span>    (Usually ControlS.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.start_search(direction=search.SearchDirection.FORWARD)</span>


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gd">-def reverse_incremental_search(event: E) -&gt;None:</span>
<span class="gi">+def reverse_incremental_search(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply reverse incremental search, but keep search buffer focused.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.do_incremental_search(search.SearchDirection.BACKWARD, count=event.arg)</span>


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gd">-def forward_incremental_search(event: E) -&gt;None:</span>
<span class="gi">+def forward_incremental_search(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply forward incremental search, but keep search buffer focused.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.do_incremental_search(search.SearchDirection.FORWARD, count=event.arg)</span>


<span class="w"> </span>@Condition
<span class="gd">-def _previous_buffer_is_returnable() -&gt;bool:</span>
<span class="gi">+def _previous_buffer_is_returnable() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True if the previously focused buffer has a return handler.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    prev_control = get_app().layout.search_target_buffer_control</span>
<span class="gi">+    return bool(prev_control and prev_control.buffer.is_returnable)</span>


<span class="w"> </span>@key_binding(filter=is_searching &amp; _previous_buffer_is_returnable)
<span class="gd">-def accept_search_and_accept_input(event: E) -&gt;None:</span>
<span class="gi">+def accept_search_and_accept_input(event: E) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept the search operation first, then accept the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search.accept_search()</span>
<span class="gi">+    event.current_buffer.validate_and_handle()</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/vi.py b/src/prompt_toolkit/key_binding/bindings/vi.py</span>
<span class="gh">index bdf5ffe0..5cc74b4f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/vi.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/vi.py</span>
<span class="gu">@@ -1,15 +1,39 @@</span>
<span class="gi">+# pylint: disable=function-redefined</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import string
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from itertools import accumulate
<span class="w"> </span>from typing import Callable, Iterable, Tuple, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.buffer import Buffer, indent, reshape_text, unindent
<span class="w"> </span>from prompt_toolkit.clipboard import ClipboardData
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="gd">-from prompt_toolkit.filters import Always, Condition, Filter, has_arg, is_read_only, is_searching</span>
<span class="gd">-from prompt_toolkit.filters.app import in_paste_mode, is_multiline, vi_digraph_mode, vi_insert_mode, vi_insert_multiple_mode, vi_mode, vi_navigation_mode, vi_recording_macro, vi_replace_mode, vi_replace_single_mode, vi_search_direction_reversed, vi_selection_mode, vi_waiting_for_text_object_mode</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Always,</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    Filter,</span>
<span class="gi">+    has_arg,</span>
<span class="gi">+    is_read_only,</span>
<span class="gi">+    is_searching,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.filters.app import (</span>
<span class="gi">+    in_paste_mode,</span>
<span class="gi">+    is_multiline,</span>
<span class="gi">+    vi_digraph_mode,</span>
<span class="gi">+    vi_insert_mode,</span>
<span class="gi">+    vi_insert_multiple_mode,</span>
<span class="gi">+    vi_mode,</span>
<span class="gi">+    vi_navigation_mode,</span>
<span class="gi">+    vi_recording_macro,</span>
<span class="gi">+    vi_replace_mode,</span>
<span class="gi">+    vi_replace_single_mode,</span>
<span class="gi">+    vi_search_direction_reversed,</span>
<span class="gi">+    vi_selection_mode,</span>
<span class="gi">+    vi_waiting_for_text_object_mode,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.input.vt100_parser import Vt100Parser
<span class="w"> </span>from prompt_toolkit.key_binding.digraphs import DIGRAPHS
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPress, KeyPressEvent
<span class="gu">@@ -17,19 +41,27 @@ from prompt_toolkit.key_binding.vi_state import CharacterFind, InputMode</span>
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.search import SearchDirection
<span class="w"> </span>from prompt_toolkit.selection import PasteMode, SelectionState, SelectionType
<span class="gi">+</span>
<span class="w"> </span>from ..key_bindings import ConditionalKeyBindings, KeyBindings, KeyBindingsBase
<span class="w"> </span>from .named_commands import get_by_name
<span class="gd">-__all__ = [&#39;load_vi_bindings&#39;, &#39;load_vi_search_bindings&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_vi_bindings&quot;,</span>
<span class="gi">+    &quot;load_vi_search_bindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent
<span class="gi">+</span>
<span class="w"> </span>ascii_lowercase = string.ascii_lowercase
<span class="gd">-vi_register_names = ascii_lowercase + &#39;0123456789&#39;</span>
<span class="gi">+</span>
<span class="gi">+vi_register_names = ascii_lowercase + &quot;0123456789&quot;</span>


<span class="w"> </span>class TextObjectType(Enum):
<span class="gd">-    EXCLUSIVE = &#39;EXCLUSIVE&#39;</span>
<span class="gd">-    INCLUSIVE = &#39;INCLUSIVE&#39;</span>
<span class="gd">-    LINEWISE = &#39;LINEWISE&#39;</span>
<span class="gd">-    BLOCK = &#39;BLOCK&#39;</span>
<span class="gi">+    EXCLUSIVE = &quot;EXCLUSIVE&quot;</span>
<span class="gi">+    INCLUSIVE = &quot;INCLUSIVE&quot;</span>
<span class="gi">+    LINEWISE = &quot;LINEWISE&quot;</span>
<span class="gi">+    BLOCK = &quot;BLOCK&quot;</span>


<span class="w"> </span>class TextObject:
<span class="gu">@@ -38,19 +70,32 @@ class TextObject:</span>
<span class="w"> </span>    Both `start` and `end` are relative to the current cursor position.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, start: int, end: int=0, type: TextObjectType=</span>
<span class="gd">-        TextObjectType.EXCLUSIVE):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, start: int, end: int = 0, type: TextObjectType = TextObjectType.EXCLUSIVE</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.start = start
<span class="w"> </span>        self.end = end
<span class="w"> </span>        self.type = type

<span class="gd">-    def sorted(self) -&gt;tuple[int, int]:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def selection_type(self) -&gt; SelectionType:</span>
<span class="gi">+        if self.type == TextObjectType.LINEWISE:</span>
<span class="gi">+            return SelectionType.LINES</span>
<span class="gi">+        if self.type == TextObjectType.BLOCK:</span>
<span class="gi">+            return SelectionType.BLOCK</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SelectionType.CHARACTERS</span>
<span class="gi">+</span>
<span class="gi">+    def sorted(self) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (start, end) tuple where start &lt;= end.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.start &lt; self.end:</span>
<span class="gi">+            return self.start, self.end</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.end, self.start</span>

<span class="gd">-    def operator_range(self, document: Document) -&gt;tuple[int, int]:</span>
<span class="gi">+    def operator_range(self, document: Document) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (start, end) tuple with start &lt;= end that indicates the range
<span class="w"> </span>        operators should operate on.
<span class="gu">@@ -59,50 +104,2121 @@ class TextObject:</span>
<span class="w"> </span>        This should return something that can be used in a slice, so the `end`
<span class="w"> </span>        position is *not* included.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start, end = self.sorted()</span>
<span class="gi">+        doc = document</span>

<span class="gd">-    def get_line_numbers(self, buffer: Buffer) -&gt;tuple[int, int]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.type == TextObjectType.EXCLUSIVE</span>
<span class="gi">+            and doc.translate_index_to_position(end + doc.cursor_position)[1] == 0</span>
<span class="gi">+        ):</span>
<span class="gi">+            # If the motion is exclusive and the end of motion is on the first</span>
<span class="gi">+            # column, the end position becomes end of previous line.</span>
<span class="gi">+            end -= 1</span>
<span class="gi">+        if self.type == TextObjectType.INCLUSIVE:</span>
<span class="gi">+            end += 1</span>
<span class="gi">+        if self.type == TextObjectType.LINEWISE:</span>
<span class="gi">+            # Select whole lines</span>
<span class="gi">+            row, col = doc.translate_index_to_position(start + doc.cursor_position)</span>
<span class="gi">+            start = doc.translate_row_col_to_index(row, 0) - doc.cursor_position</span>
<span class="gi">+            row, col = doc.translate_index_to_position(end + doc.cursor_position)</span>
<span class="gi">+            end = (</span>
<span class="gi">+                doc.translate_row_col_to_index(row, len(doc.lines[row]))</span>
<span class="gi">+                - doc.cursor_position</span>
<span class="gi">+            )</span>
<span class="gi">+        return start, end</span>
<span class="gi">+</span>
<span class="gi">+    def get_line_numbers(self, buffer: Buffer) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (start_line, end_line) pair.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get absolute cursor positions from the text object.</span>
<span class="gi">+        from_, to = self.operator_range(buffer.document)</span>
<span class="gi">+        from_ += buffer.cursor_position</span>
<span class="gi">+        to += buffer.cursor_position</span>

<span class="gd">-    def cut(self, buffer: Buffer) -&gt;tuple[Document, ClipboardData]:</span>
<span class="gi">+        # Take the start of the lines.</span>
<span class="gi">+        from_, _ = buffer.document.translate_index_to_position(from_)</span>
<span class="gi">+        to, _ = buffer.document.translate_index_to_position(to)</span>
<span class="gi">+</span>
<span class="gi">+        return from_, to</span>
<span class="gi">+</span>
<span class="gi">+    def cut(self, buffer: Buffer) -&gt; tuple[Document, ClipboardData]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Turn text object into `ClipboardData` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from_, to = self.operator_range(buffer.document)</span>
<span class="gi">+</span>
<span class="gi">+        from_ += buffer.cursor_position</span>
<span class="gi">+        to += buffer.cursor_position</span>

<span class="gi">+        # For Vi mode, the SelectionState does include the upper position,</span>
<span class="gi">+        # while `self.operator_range` does not. So, go one to the left, unless</span>
<span class="gi">+        # we&#39;re in the line mode, then we don&#39;t want to risk going to the</span>
<span class="gi">+        # previous line, and missing one line in the selection.</span>
<span class="gi">+        if self.type != TextObjectType.LINEWISE:</span>
<span class="gi">+            to -= 1</span>

<span class="gi">+        document = Document(</span>
<span class="gi">+            buffer.text,</span>
<span class="gi">+            to,</span>
<span class="gi">+            SelectionState(original_cursor_position=from_, type=self.selection_type),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        new_document, clipboard_data = document.cut_selection()</span>
<span class="gi">+        return new_document, clipboard_data</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Typevar for any text object function:</span>
<span class="w"> </span>TextObjectFunction = Callable[[E], TextObject]
<span class="gd">-_TOF = TypeVar(&#39;_TOF&#39;, bound=TextObjectFunction)</span>
<span class="gi">+_TOF = TypeVar(&quot;_TOF&quot;, bound=TextObjectFunction)</span>


<span class="gd">-def create_text_object_decorator(key_bindings: KeyBindings) -&gt;Callable[...,</span>
<span class="gd">-    Callable[[_TOF], _TOF]]:</span>
<span class="gi">+def create_text_object_decorator(</span>
<span class="gi">+    key_bindings: KeyBindings,</span>
<span class="gi">+) -&gt; Callable[..., Callable[[_TOF], _TOF]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a decorator that can be used to register Vi text object implementations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def text_object_decorator(</span>
<span class="gi">+        *keys: Keys | str,</span>
<span class="gi">+        filter: Filter = Always(),</span>
<span class="gi">+        no_move_handler: bool = False,</span>
<span class="gi">+        no_selection_handler: bool = False,</span>
<span class="gi">+        eager: bool = False,</span>
<span class="gi">+    ) -&gt; Callable[[_TOF], _TOF]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Register a text object function.</span>
<span class="gi">+</span>
<span class="gi">+        Usage::</span>
<span class="gi">+</span>
<span class="gi">+            @text_object(&#39;w&#39;, filter=..., no_move_handler=False)</span>
<span class="gi">+            def handler(event):</span>
<span class="gi">+                # Return a text object for this key.</span>
<span class="gi">+                return TextObject(...)</span>
<span class="gi">+</span>
<span class="gi">+        :param no_move_handler: Disable the move handler in navigation mode.</span>
<span class="gi">+            (It&#39;s still active in selection mode.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(text_object_func: _TOF) -&gt; _TOF:</span>
<span class="gi">+            @key_bindings.add(</span>
<span class="gi">+                *keys, filter=vi_waiting_for_text_object_mode &amp; filter, eager=eager</span>
<span class="gi">+            )</span>
<span class="gi">+            def _apply_operator_to_text_object(event: E) -&gt; None:</span>
<span class="gi">+                # Arguments are multiplied.</span>
<span class="gi">+                vi_state = event.app.vi_state</span>
<span class="gi">+                event._arg = str((vi_state.operator_arg or 1) * (event.arg or 1))</span>
<span class="gi">+</span>
<span class="gi">+                # Call the text object handler.</span>
<span class="gi">+                text_obj = text_object_func(event)</span>
<span class="gi">+</span>
<span class="gi">+                # Get the operator function.</span>
<span class="gi">+                # (Should never be None here, given the</span>
<span class="gi">+                # `vi_waiting_for_text_object_mode` filter state.)</span>
<span class="gi">+                operator_func = vi_state.operator_func</span>
<span class="gi">+</span>
<span class="gi">+                if text_obj is not None and operator_func is not None:</span>
<span class="gi">+                    # Call the operator function with the text object.</span>
<span class="gi">+                    operator_func(event, text_obj)</span>
<span class="gi">+</span>
<span class="gi">+                # Clear operator.</span>
<span class="gi">+                event.app.vi_state.operator_func = None</span>
<span class="gi">+                event.app.vi_state.operator_arg = None</span>
<span class="gi">+</span>
<span class="gi">+            # Register a move operation. (Doesn&#39;t need an operator.)</span>
<span class="gi">+            if not no_move_handler:</span>
<span class="gi">+</span>
<span class="gi">+                @key_bindings.add(</span>
<span class="gi">+                    *keys,</span>
<span class="gi">+                    filter=~vi_waiting_for_text_object_mode</span>
<span class="gi">+                    &amp; filter</span>
<span class="gi">+                    &amp; vi_navigation_mode,</span>
<span class="gi">+                    eager=eager,</span>
<span class="gi">+                )</span>
<span class="gi">+                def _move_in_navigation_mode(event: E) -&gt; None:</span>
<span class="gi">+                    &quot;&quot;&quot;</span>
<span class="gi">+                    Move handler for navigation mode.</span>
<span class="gi">+                    &quot;&quot;&quot;</span>
<span class="gi">+                    text_object = text_object_func(event)</span>
<span class="gi">+                    event.current_buffer.cursor_position += text_object.start</span>
<span class="gi">+</span>
<span class="gi">+            # Register a move selection operation.</span>
<span class="gi">+            if not no_selection_handler:</span>

<span class="gi">+                @key_bindings.add(</span>
<span class="gi">+                    *keys,</span>
<span class="gi">+                    filter=~vi_waiting_for_text_object_mode</span>
<span class="gi">+                    &amp; filter</span>
<span class="gi">+                    &amp; vi_selection_mode,</span>
<span class="gi">+                    eager=eager,</span>
<span class="gi">+                )</span>
<span class="gi">+                def _move_in_selection_mode(event: E) -&gt; None:</span>
<span class="gi">+                    &quot;&quot;&quot;</span>
<span class="gi">+                    Move handler for selection mode.</span>
<span class="gi">+                    &quot;&quot;&quot;</span>
<span class="gi">+                    text_object = text_object_func(event)</span>
<span class="gi">+                    buff = event.current_buffer</span>
<span class="gi">+                    selection_state = buff.selection_state</span>
<span class="gi">+</span>
<span class="gi">+                    if selection_state is None:</span>
<span class="gi">+                        return  # Should not happen, because of the `vi_selection_mode` filter.</span>
<span class="gi">+</span>
<span class="gi">+                    # When the text object has both a start and end position, like &#39;i(&#39; or &#39;iw&#39;,</span>
<span class="gi">+                    # Turn this into a selection, otherwise the cursor.</span>
<span class="gi">+                    if text_object.end:</span>
<span class="gi">+                        # Take selection positions from text object.</span>
<span class="gi">+                        start, end = text_object.operator_range(buff.document)</span>
<span class="gi">+                        start += buff.cursor_position</span>
<span class="gi">+                        end += buff.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+                        selection_state.original_cursor_position = start</span>
<span class="gi">+                        buff.cursor_position = end</span>
<span class="gi">+</span>
<span class="gi">+                        # Take selection type from text object.</span>
<span class="gi">+                        if text_object.type == TextObjectType.LINEWISE:</span>
<span class="gi">+                            selection_state.type = SelectionType.LINES</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            selection_state.type = SelectionType.CHARACTERS</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        event.current_buffer.cursor_position += text_object.start</span>
<span class="gi">+</span>
<span class="gi">+            # Make it possible to chain @text_object decorators.</span>
<span class="gi">+            return text_object_func</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    return text_object_decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Typevar for any operator function:</span>
<span class="w"> </span>OperatorFunction = Callable[[E, TextObject], None]
<span class="gd">-_OF = TypeVar(&#39;_OF&#39;, bound=OperatorFunction)</span>
<span class="gi">+_OF = TypeVar(&quot;_OF&quot;, bound=OperatorFunction)</span>


<span class="gd">-def create_operator_decorator(key_bindings: KeyBindings) -&gt;Callable[...,</span>
<span class="gd">-    Callable[[_OF], _OF]]:</span>
<span class="gi">+def create_operator_decorator(</span>
<span class="gi">+    key_bindings: KeyBindings,</span>
<span class="gi">+) -&gt; Callable[..., Callable[[_OF], _OF]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a decorator that can be used for registering Vi operators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def operator_decorator(</span>
<span class="gi">+        *keys: Keys | str, filter: Filter = Always(), eager: bool = False</span>
<span class="gi">+    ) -&gt; Callable[[_OF], _OF]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Register a Vi operator.</span>
<span class="gi">+</span>
<span class="gi">+        Usage::</span>
<span class="gi">+</span>
<span class="gi">+            @operator(&#39;d&#39;, filter=...)</span>
<span class="gi">+            def handler(event, text_object):</span>
<span class="gi">+                # Do something with the text object here.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(operator_func: _OF) -&gt; _OF:</span>
<span class="gi">+            @key_bindings.add(</span>
<span class="gi">+                *keys,</span>
<span class="gi">+                filter=~vi_waiting_for_text_object_mode &amp; filter &amp; vi_navigation_mode,</span>
<span class="gi">+                eager=eager,</span>
<span class="gi">+            )</span>
<span class="gi">+            def _operator_in_navigation(event: E) -&gt; None:</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                Handle operator in navigation mode.</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                # When this key binding is matched, only set the operator</span>
<span class="gi">+                # function in the ViState. We should execute it after a text</span>
<span class="gi">+                # object has been received.</span>
<span class="gi">+                event.app.vi_state.operator_func = operator_func</span>
<span class="gi">+                event.app.vi_state.operator_arg = event.arg</span>
<span class="gi">+</span>
<span class="gi">+            @key_bindings.add(</span>
<span class="gi">+                *keys,</span>
<span class="gi">+                filter=~vi_waiting_for_text_object_mode &amp; filter &amp; vi_selection_mode,</span>
<span class="gi">+                eager=eager,</span>
<span class="gi">+            )</span>
<span class="gi">+            def _operator_in_selection(event: E) -&gt; None:</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                Handle operator in selection mode.</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="gi">+                buff = event.current_buffer</span>
<span class="gi">+                selection_state = buff.selection_state</span>
<span class="gi">+</span>
<span class="gi">+                if selection_state is not None:</span>
<span class="gi">+                    # Create text object from selection.</span>
<span class="gi">+                    if selection_state.type == SelectionType.LINES:</span>
<span class="gi">+                        text_obj_type = TextObjectType.LINEWISE</span>
<span class="gi">+                    elif selection_state.type == SelectionType.BLOCK:</span>
<span class="gi">+                        text_obj_type = TextObjectType.BLOCK</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        text_obj_type = TextObjectType.INCLUSIVE</span>

<span class="gd">-def load_vi_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+                    text_object = TextObject(</span>
<span class="gi">+                        selection_state.original_cursor_position - buff.cursor_position,</span>
<span class="gi">+                        type=text_obj_type,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    # Execute operator.</span>
<span class="gi">+                    operator_func(event, text_object)</span>
<span class="gi">+</span>
<span class="gi">+                    # Quit selection mode.</span>
<span class="gi">+                    buff.selection_state = None</span>
<span class="gi">+</span>
<span class="gi">+            return operator_func</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    return operator_decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_vi_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Vi extensions.

<span class="w"> </span>    # Overview of Readline Vi commands:
<span class="w"> </span>    # http://www.catonmat.net/download/bash-vi-editing-mode-cheat-sheet.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Note: Some key bindings have the &quot;~IsReadOnly()&quot; filter added. This</span>
<span class="gi">+    #       prevents the handler to be executed when the focus is on a</span>
<span class="gi">+    #       read-only buffer.</span>
<span class="gi">+    #       This is however only required for those that change the ViState to</span>
<span class="gi">+    #       INSERT mode. The `Buffer` class itself throws the</span>
<span class="gi">+    #       `EditReadOnlyBuffer` exception for any text operations which is</span>
<span class="gi">+    #       handled correctly. There is no need to add &quot;~IsReadOnly&quot; to all key</span>
<span class="gi">+    #       bindings that do text manipulation.</span>
<span class="gi">+</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+    # (Note: Always take the navigation bindings in read-only mode, even when</span>
<span class="gi">+    #  ViState says different.)</span>
<span class="gi">+</span>
<span class="gi">+    TransformFunction = Tuple[Tuple[str, ...], Filter, Callable[[str], str]]</span>
<span class="gi">+</span>
<span class="gi">+    vi_transform_functions: list[TransformFunction] = [</span>
<span class="gi">+        # Rot 13 transformation</span>
<span class="gi">+        (</span>
<span class="gi">+            (&quot;g&quot;, &quot;?&quot;),</span>
<span class="gi">+            Always(),</span>
<span class="gi">+            lambda string: codecs.encode(string, &quot;rot_13&quot;),</span>
<span class="gi">+        ),</span>
<span class="gi">+        # To lowercase</span>
<span class="gi">+        ((&quot;g&quot;, &quot;u&quot;), Always(), lambda string: string.lower()),</span>
<span class="gi">+        # To uppercase.</span>
<span class="gi">+        ((&quot;g&quot;, &quot;U&quot;), Always(), lambda string: string.upper()),</span>
<span class="gi">+        # Swap case.</span>
<span class="gi">+        ((&quot;g&quot;, &quot;~&quot;), Always(), lambda string: string.swapcase()),</span>
<span class="gi">+        (</span>
<span class="gi">+            (&quot;~&quot;,),</span>
<span class="gi">+            Condition(lambda: get_app().vi_state.tilde_operator),</span>
<span class="gi">+            lambda string: string.swapcase(),</span>
<span class="gi">+        ),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Insert a character literally (quoted insert).</span>
<span class="gi">+    handle(&quot;c-v&quot;, filter=vi_insert_mode)(get_by_name(&quot;quoted-insert&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;escape&quot;)</span>
<span class="gi">+    def _back_to_navigation(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Escape goes to vi navigation mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        vi_state = event.app.vi_state</span>
<span class="gi">+</span>
<span class="gi">+        if vi_state.input_mode in (InputMode.INSERT, InputMode.REPLACE):</span>
<span class="gi">+            buffer.cursor_position += buffer.document.get_cursor_left_position()</span>
<span class="gi">+</span>
<span class="gi">+        vi_state.input_mode = InputMode.NAVIGATION</span>
<span class="gi">+</span>
<span class="gi">+        if bool(buffer.selection_state):</span>
<span class="gi">+            buffer.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;k&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _up_in_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Arrow up in selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cursor_up(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;j&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _down_in_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Arrow down in selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cursor_down(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;up&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    @handle(&quot;c-p&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _up_in_navigation(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Arrow up and ControlP in navigation mode go up.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.auto_up(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;k&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _go_up(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go up, but if we enter a new history entry, move to the start of the</span>
<span class="gi">+        line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.auto_up(</span>
<span class="gi">+            count=event.arg, go_to_start_of_line_if_history_changes=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;down&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    @handle(&quot;c-n&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _go_down(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Arrow down and Control-N in navigation mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.auto_down(count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;j&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _go_down2(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go down, but if we enter a new history entry, go to the start of the line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.auto_down(</span>
<span class="gi">+            count=event.arg, go_to_start_of_line_if_history_changes=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;backspace&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _go_left(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        In navigation-mode, move cursor.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cursor_position += (</span>
<span class="gi">+            event.current_buffer.document.get_cursor_left_position(count=event.arg)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-n&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _complete_next(event: E) -&gt; None:</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if b.complete_state:</span>
<span class="gi">+            b.complete_next()</span>
<span class="gi">+        else:</span>
<span class="gi">+            b.start_completion(select_first=True)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-p&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _complete_prev(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Control-P: To previous completion.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if b.complete_state:</span>
<span class="gi">+            b.complete_previous()</span>
<span class="gi">+        else:</span>
<span class="gi">+            b.start_completion(select_last=True)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-g&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    @handle(&quot;c-y&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _accept_completion(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Accept current completion.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.complete_state = None</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-e&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _cancel_completion(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cancel completion. Go back to originally typed text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.cancel_completion()</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def is_returnable() -&gt; bool:</span>
<span class="gi">+        return get_app().current_buffer.is_returnable</span>
<span class="gi">+</span>
<span class="gi">+    # In navigation mode, pressing enter will always return the input.</span>
<span class="gi">+    handle(&quot;enter&quot;, filter=vi_navigation_mode &amp; is_returnable)(</span>
<span class="gi">+        get_by_name(&quot;accept-line&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # In insert mode, also accept input when enter is pressed, and the buffer</span>
<span class="gi">+    # has been marked as single line.</span>
<span class="gi">+    handle(&quot;enter&quot;, filter=is_returnable &amp; ~is_multiline)(get_by_name(&quot;accept-line&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;enter&quot;, filter=~is_returnable &amp; vi_navigation_mode)</span>
<span class="gi">+    def _start_of_next_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to the beginning of next line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        b.cursor_down(count=event.arg)</span>
<span class="gi">+        b.cursor_position += b.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # ** In navigation mode **</span>
<span class="gi">+</span>
<span class="gi">+    # List of navigation commands: http://hea-www.harvard.edu/~fine/Tech/vi.html</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;insert&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _insert_mode(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Pressing the Insert key.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;insert&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _navigation_mode(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Pressing the Insert key.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.NAVIGATION</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;a&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    # ~IsReadOnly, because we want to stay in navigation mode for</span>
<span class="gi">+    # read-only buffers.</span>
<span class="gi">+    def _a(event: E) -&gt; None:</span>
<span class="gi">+        event.current_buffer.cursor_position += (</span>
<span class="gi">+            event.current_buffer.document.get_cursor_right_position()</span>
<span class="gi">+        )</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;A&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _A(event: E) -&gt; None:</span>
<span class="gi">+        event.current_buffer.cursor_position += (</span>
<span class="gi">+            event.current_buffer.document.get_end_of_line_position()</span>
<span class="gi">+        )</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;C&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _change_until_end_of_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Change to end of line.</span>
<span class="gi">+        Same as &#39;c$&#39; (which is implemented elsewhere.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        deleted = buffer.delete(count=buffer.document.get_end_of_line_position())</span>
<span class="gi">+        event.app.clipboard.set_text(deleted)</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c&quot;, &quot;c&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    @handle(&quot;S&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _change_current_line(event: E) -&gt; None:  # TODO: implement &#39;arg&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Change current line</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        # We copy the whole line.</span>
<span class="gi">+        data = ClipboardData(buffer.document.current_line, SelectionType.LINES)</span>
<span class="gi">+        event.app.clipboard.set_data(data)</span>
<span class="gi">+</span>
<span class="gi">+        # But we delete after the whitespace</span>
<span class="gi">+        buffer.cursor_position += buffer.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+        buffer.delete(count=buffer.document.get_end_of_line_position())</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;D&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _delete_until_end_of_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete from cursor position until the end of the line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        deleted = buffer.delete(count=buffer.document.get_end_of_line_position())</span>
<span class="gi">+        event.app.clipboard.set_text(deleted)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;d&quot;, &quot;d&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _delete_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete line. (Or the following &#39;n&#39; lines.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        # Split string in before/deleted/after text.</span>
<span class="gi">+        lines = buffer.document.lines</span>
<span class="gi">+</span>
<span class="gi">+        before = &quot;\n&quot;.join(lines[: buffer.document.cursor_position_row])</span>
<span class="gi">+        deleted = &quot;\n&quot;.join(</span>
<span class="gi">+            lines[</span>
<span class="gi">+                buffer.document.cursor_position_row : buffer.document.cursor_position_row</span>
<span class="gi">+                + event.arg</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+        after = &quot;\n&quot;.join(lines[buffer.document.cursor_position_row + event.arg :])</span>
<span class="gi">+</span>
<span class="gi">+        # Set new text.</span>
<span class="gi">+        if before and after:</span>
<span class="gi">+            before = before + &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Set text and cursor position.</span>
<span class="gi">+        buffer.document = Document(</span>
<span class="gi">+            text=before + after,</span>
<span class="gi">+            # Cursor At the start of the first &#39;after&#39; line, after the leading whitespace.</span>
<span class="gi">+            cursor_position=len(before) + len(after) - len(after.lstrip(&quot; &quot;)),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Set clipboard data</span>
<span class="gi">+        event.app.clipboard.set_data(ClipboardData(deleted, SelectionType.LINES))</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;x&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _cut(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Cut selection.</span>
<span class="gi">+        (&#39;x&#39; is not an operator.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        clipboard_data = event.current_buffer.cut_selection()</span>
<span class="gi">+        event.app.clipboard.set_data(clipboard_data)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;i&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _i(event: E) -&gt; None:</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;I&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _I(event: E) -&gt; None:</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+        event.current_buffer.cursor_position += (</span>
<span class="gi">+            event.current_buffer.document.get_start_of_line_position(</span>
<span class="gi">+                after_whitespace=True</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def in_block_selection() -&gt; bool:</span>
<span class="gi">+        buff = get_app().current_buffer</span>
<span class="gi">+        return bool(</span>
<span class="gi">+            buff.selection_state and buff.selection_state.type == SelectionType.BLOCK</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;I&quot;, filter=in_block_selection &amp; ~is_read_only)</span>
<span class="gi">+    def insert_in_block_selection(event: E, after: bool = False) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Insert in block selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        # Store all cursor positions.</span>
<span class="gi">+        positions = []</span>
<span class="gi">+</span>
<span class="gi">+        if after:</span>
<span class="gi">+</span>
<span class="gi">+            def get_pos(from_to: tuple[int, int]) -&gt; int:</span>
<span class="gi">+                return from_to[1]</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def get_pos(from_to: tuple[int, int]) -&gt; int:</span>
<span class="gi">+                return from_to[0]</span>
<span class="gi">+</span>
<span class="gi">+        for i, from_to in enumerate(buff.document.selection_ranges()):</span>
<span class="gi">+            positions.append(get_pos(from_to))</span>
<span class="gi">+            if i == 0:</span>
<span class="gi">+                buff.cursor_position = get_pos(from_to)</span>
<span class="gi">+</span>
<span class="gi">+        buff.multiple_cursor_positions = positions</span>
<span class="gi">+</span>
<span class="gi">+        # Go to &#39;INSERT_MULTIPLE&#39; mode.</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT_MULTIPLE</span>
<span class="gi">+        buff.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;A&quot;, filter=in_block_selection &amp; ~is_read_only)</span>
<span class="gi">+    def _append_after_block(event: E) -&gt; None:</span>
<span class="gi">+        insert_in_block_selection(event, after=True)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;J&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _join(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Join lines.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        for i in range(event.arg):</span>
<span class="gi">+            event.current_buffer.join_next_line()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;g&quot;, &quot;J&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _join_nospace(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Join lines without space.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        for i in range(event.arg):</span>
<span class="gi">+            event.current_buffer.join_next_line(separator=&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;J&quot;, filter=vi_selection_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _join_selection(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Join selected lines.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.join_selected_lines()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;g&quot;, &quot;J&quot;, filter=vi_selection_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _join_selection_nospace(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Join selected lines without space.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.join_selected_lines(separator=&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;p&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _paste(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Paste after</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.paste_clipboard_data(</span>
<span class="gi">+            event.app.clipboard.get_data(),</span>
<span class="gi">+            count=event.arg,</span>
<span class="gi">+            paste_mode=PasteMode.VI_AFTER,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;P&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _paste_before(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Paste before</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.paste_clipboard_data(</span>
<span class="gi">+            event.app.clipboard.get_data(),</span>
<span class="gi">+            count=event.arg,</span>
<span class="gi">+            paste_mode=PasteMode.VI_BEFORE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&#39;&quot;&#39;, Keys.Any, &quot;p&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _paste_register(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Paste from named register.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        c = event.key_sequence[1].data</span>
<span class="gi">+        if c in vi_register_names:</span>
<span class="gi">+            data = event.app.vi_state.named_registers.get(c)</span>
<span class="gi">+            if data:</span>
<span class="gi">+                event.current_buffer.paste_clipboard_data(</span>
<span class="gi">+                    data, count=event.arg, paste_mode=PasteMode.VI_AFTER</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&#39;&quot;&#39;, Keys.Any, &quot;P&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _paste_register_before(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Paste (before) from named register.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        c = event.key_sequence[1].data</span>
<span class="gi">+        if c in vi_register_names:</span>
<span class="gi">+            data = event.app.vi_state.named_registers.get(c)</span>
<span class="gi">+            if data:</span>
<span class="gi">+                event.current_buffer.paste_clipboard_data(</span>
<span class="gi">+                    data, count=event.arg, paste_mode=PasteMode.VI_BEFORE</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;r&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _replace(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to &#39;replace-single&#39;-mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.REPLACE_SINGLE</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;R&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _replace_mode(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to &#39;replace&#39;-mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.REPLACE</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;s&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _substitute(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Substitute with new text</span>
<span class="gi">+        (Delete character(s) and go to insert mode.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        text = event.current_buffer.delete(count=event.arg)</span>
<span class="gi">+        event.app.clipboard.set_text(text)</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;u&quot;, filter=vi_navigation_mode, save_before=(lambda e: False))</span>
<span class="gi">+    def _undo(event: E) -&gt; None:</span>
<span class="gi">+        for i in range(event.arg):</span>
<span class="gi">+            event.current_buffer.undo()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;V&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _visual_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Start lines selection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.start_selection(selection_type=SelectionType.LINES)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-v&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _visual_block(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Enter block selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.start_selection(selection_type=SelectionType.BLOCK)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;V&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _visual_line2(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Exit line selection mode, or go from non line selection mode to line</span>
<span class="gi">+        selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        selection_state = event.current_buffer.selection_state</span>
<span class="gi">+</span>
<span class="gi">+        if selection_state is not None:</span>
<span class="gi">+            if selection_state.type != SelectionType.LINES:</span>
<span class="gi">+                selection_state.type = SelectionType.LINES</span>
<span class="gi">+            else:</span>
<span class="gi">+                event.current_buffer.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;v&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _visual(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Enter character selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.start_selection(selection_type=SelectionType.CHARACTERS)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;v&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _visual2(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Exit character selection mode, or go from non-character-selection mode</span>
<span class="gi">+        to character selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        selection_state = event.current_buffer.selection_state</span>
<span class="gi">+</span>
<span class="gi">+        if selection_state is not None:</span>
<span class="gi">+            if selection_state.type != SelectionType.CHARACTERS:</span>
<span class="gi">+                selection_state.type = SelectionType.CHARACTERS</span>
<span class="gi">+            else:</span>
<span class="gi">+                event.current_buffer.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-v&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _visual_block2(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Exit block selection mode, or go from non block selection mode to block</span>
<span class="gi">+        selection mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        selection_state = event.current_buffer.selection_state</span>
<span class="gi">+</span>
<span class="gi">+        if selection_state is not None:</span>
<span class="gi">+            if selection_state.type != SelectionType.BLOCK:</span>
<span class="gi">+                selection_state.type = SelectionType.BLOCK</span>
<span class="gi">+            else:</span>
<span class="gi">+                event.current_buffer.exit_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;a&quot;, &quot;w&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    @handle(&quot;a&quot;, &quot;W&quot;, filter=vi_selection_mode)</span>
<span class="gi">+    def _visual_auto_word(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Switch from visual linewise mode to visual characterwise mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            buffer.selection_state</span>
<span class="gi">+            and buffer.selection_state.type == SelectionType.LINES</span>
<span class="gi">+        ):</span>
<span class="gi">+            buffer.selection_state.type = SelectionType.CHARACTERS</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;x&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _delete(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete character.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        count = min(event.arg, len(buff.document.current_line_after_cursor))</span>
<span class="gi">+        if count:</span>
<span class="gi">+            text = event.current_buffer.delete(count=count)</span>
<span class="gi">+            event.app.clipboard.set_text(text)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;X&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _delete_before_cursor(event: E) -&gt; None:</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        count = min(event.arg, len(buff.document.current_line_before_cursor))</span>
<span class="gi">+        if count:</span>
<span class="gi">+            text = event.current_buffer.delete_before_cursor(count=count)</span>
<span class="gi">+            event.app.clipboard.set_text(text)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;y&quot;, &quot;y&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    @handle(&quot;Y&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _yank_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Yank the whole line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        text = &quot;\n&quot;.join(event.current_buffer.document.lines_from_current[: event.arg])</span>
<span class="gi">+        event.app.clipboard.set_data(ClipboardData(text, SelectionType.LINES))</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;+&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _next_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move to first non whitespace of next line</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        buffer.cursor_position += buffer.document.get_cursor_down_position(</span>
<span class="gi">+            count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        buffer.cursor_position += buffer.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;-&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _prev_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move to first non whitespace of previous line</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        buffer.cursor_position += buffer.document.get_cursor_up_position(</span>
<span class="gi">+            count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        buffer.cursor_position += buffer.document.get_start_of_line_position(</span>
<span class="gi">+            after_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;&gt;&quot;, &quot;&gt;&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    @handle(&quot;c-t&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _indent(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Indent lines.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        current_row = buffer.document.cursor_position_row</span>
<span class="gi">+        indent(buffer, current_row, current_row + event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;&lt;&quot;, &quot;&lt;&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    @handle(&quot;c-d&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _unindent(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Unindent lines.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        current_row = event.current_buffer.document.cursor_position_row</span>
<span class="gi">+        unindent(event.current_buffer, current_row, current_row + event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;O&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _open_above(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Open line above and enter insertion mode</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.insert_line_above(copy_margin=not in_paste_mode())</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;o&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _open_below(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Open line below and enter insertion mode</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.insert_line_below(copy_margin=not in_paste_mode())</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;~&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _reverse_case(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Reverse case of current character and move cursor forward.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+        c = buffer.document.current_char</span>
<span class="gi">+</span>
<span class="gi">+        if c is not None and c != &quot;\n&quot;:</span>
<span class="gi">+            buffer.insert_text(c.swapcase(), overwrite=True)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;g&quot;, &quot;u&quot;, &quot;u&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _lowercase_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Lowercase current line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.transform_current_line(lambda s: s.lower())</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;g&quot;, &quot;U&quot;, &quot;U&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _uppercase_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Uppercase current line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.transform_current_line(lambda s: s.upper())</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;g&quot;, &quot;~&quot;, &quot;~&quot;, filter=vi_navigation_mode &amp; ~is_read_only)</span>
<span class="gi">+    def _swapcase_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Swap case of the current line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.transform_current_line(lambda s: s.swapcase())</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;#&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _prev_occurrence(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to previous occurrence of this word.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        search_state = event.app.current_search_state</span>
<span class="gi">+</span>
<span class="gi">+        search_state.text = b.document.get_word_under_cursor()</span>
<span class="gi">+        search_state.direction = SearchDirection.BACKWARD</span>
<span class="gi">+</span>
<span class="gi">+        b.apply_search(search_state, count=event.arg, include_current_position=False)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;*&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _next_occurrence(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to next occurrence of this word.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        search_state = event.app.current_search_state</span>
<span class="gi">+</span>
<span class="gi">+        search_state.text = b.document.get_word_under_cursor()</span>
<span class="gi">+        search_state.direction = SearchDirection.FORWARD</span>
<span class="gi">+</span>
<span class="gi">+        b.apply_search(search_state, count=event.arg, include_current_position=False)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;(&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _begin_of_sentence(event: E) -&gt; None:</span>
<span class="gi">+        # TODO: go to begin of sentence.</span>
<span class="gi">+        # XXX: should become text_object.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;)&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _end_of_sentence(event: E) -&gt; None:</span>
<span class="gi">+        # TODO: go to end of sentence.</span>
<span class="gi">+        # XXX: should become text_object.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    operator = create_operator_decorator(key_bindings)</span>
<span class="gi">+    text_object = create_text_object_decorator(key_bindings)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=vi_waiting_for_text_object_mode)</span>
<span class="gi">+    def _unknown_text_object(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Unknown key binding while waiting for a text object.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.output.bell()</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # *** Operators ***</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    def create_delete_and_change_operators(</span>
<span class="gi">+        delete_only: bool, with_register: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete and change operators.</span>
<span class="gi">+</span>
<span class="gi">+        :param delete_only: Create an operator that deletes, but doesn&#39;t go to insert mode.</span>
<span class="gi">+        :param with_register: Copy the deleted text to this named register instead of the clipboard.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        handler_keys: Iterable[str]</span>
<span class="gi">+        if with_register:</span>
<span class="gi">+            handler_keys = (&#39;&quot;&#39;, Keys.Any, &quot;cd&quot;[delete_only])</span>
<span class="gi">+        else:</span>
<span class="gi">+            handler_keys = &quot;cd&quot;[delete_only]</span>
<span class="gi">+</span>
<span class="gi">+        @operator(*handler_keys, filter=~is_read_only)</span>
<span class="gi">+        def delete_or_change_operator(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+            clipboard_data = None</span>
<span class="gi">+            buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+            if text_object:</span>
<span class="gi">+                new_document, clipboard_data = text_object.cut(buff)</span>
<span class="gi">+                buff.document = new_document</span>
<span class="gi">+</span>
<span class="gi">+            # Set deleted/changed text to clipboard or named register.</span>
<span class="gi">+            if clipboard_data and clipboard_data.text:</span>
<span class="gi">+                if with_register:</span>
<span class="gi">+                    reg_name = event.key_sequence[1].data</span>
<span class="gi">+                    if reg_name in vi_register_names:</span>
<span class="gi">+                        event.app.vi_state.named_registers[reg_name] = clipboard_data</span>
<span class="gi">+                else:</span>
<span class="gi">+                    event.app.clipboard.set_data(clipboard_data)</span>
<span class="gi">+</span>
<span class="gi">+            # Only go back to insert mode in case of &#39;change&#39;.</span>
<span class="gi">+            if not delete_only:</span>
<span class="gi">+                event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+    create_delete_and_change_operators(False, False)</span>
<span class="gi">+    create_delete_and_change_operators(False, True)</span>
<span class="gi">+    create_delete_and_change_operators(True, False)</span>
<span class="gi">+    create_delete_and_change_operators(True, True)</span>
<span class="gi">+</span>
<span class="gi">+    def create_transform_handler(</span>
<span class="gi">+        filter: Filter, transform_func: Callable[[str], str], *a: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        @operator(*a, filter=filter &amp; ~is_read_only)</span>
<span class="gi">+        def _(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Apply transformation (uppercase, lowercase, rot13, swap case).</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            buff = event.current_buffer</span>
<span class="gi">+            start, end = text_object.operator_range(buff.document)</span>
<span class="gi">+</span>
<span class="gi">+            if start &lt; end:</span>
<span class="gi">+                # Transform.</span>
<span class="gi">+                buff.transform_region(</span>
<span class="gi">+                    buff.cursor_position + start,</span>
<span class="gi">+                    buff.cursor_position + end,</span>
<span class="gi">+                    transform_func,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # Move cursor</span>
<span class="gi">+                buff.cursor_position += text_object.end or text_object.start</span>
<span class="gi">+</span>
<span class="gi">+    for k, f, func in vi_transform_functions:</span>
<span class="gi">+        create_transform_handler(f, func, *k)</span>
<span class="gi">+</span>
<span class="gi">+    @operator(&quot;y&quot;)</span>
<span class="gi">+    def _yank(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Yank operator. (Copy text.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        _, clipboard_data = text_object.cut(event.current_buffer)</span>
<span class="gi">+        if clipboard_data.text:</span>
<span class="gi">+            event.app.clipboard.set_data(clipboard_data)</span>
<span class="gi">+</span>
<span class="gi">+    @operator(&#39;&quot;&#39;, Keys.Any, &quot;y&quot;)</span>
<span class="gi">+    def _yank_to_register(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Yank selection to named register.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        c = event.key_sequence[1].data</span>
<span class="gi">+        if c in vi_register_names:</span>
<span class="gi">+            _, clipboard_data = text_object.cut(event.current_buffer)</span>
<span class="gi">+            event.app.vi_state.named_registers[c] = clipboard_data</span>
<span class="gi">+</span>
<span class="gi">+    @operator(&quot;&gt;&quot;)</span>
<span class="gi">+    def _indent_text_object(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Indent.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        from_, to = text_object.get_line_numbers(buff)</span>
<span class="gi">+        indent(buff, from_, to + 1, count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @operator(&quot;&lt;&quot;)</span>
<span class="gi">+    def _unindent_text_object(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Unindent.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        from_, to = text_object.get_line_numbers(buff)</span>
<span class="gi">+        unindent(buff, from_, to + 1, count=event.arg)</span>
<span class="gi">+</span>
<span class="gi">+    @operator(&quot;g&quot;, &quot;q&quot;)</span>
<span class="gi">+    def _reshape(event: E, text_object: TextObject) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Reshape text.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        from_, to = text_object.get_line_numbers(buff)</span>
<span class="gi">+        reshape_text(buff, from_, to)</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # *** Text objects ***</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;b&quot;)</span>
<span class="gi">+    def _b(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move one word or token left.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.find_start_of_previous_word(count=event.arg)</span>
<span class="gi">+            or 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;B&quot;)</span>
<span class="gi">+    def _B(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move one non-blank word left</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.find_start_of_previous_word(</span>
<span class="gi">+                count=event.arg, WORD=True</span>
<span class="gi">+            )</span>
<span class="gi">+            or 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;$&quot;)</span>
<span class="gi">+    def _dollar(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;c$&#39;, &#39;d$&#39; and &#39;$&#39;:  Delete/change/move until end of line.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(event.current_buffer.document.get_end_of_line_position())</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;w&quot;)</span>
<span class="gi">+    def _word_forward(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;word&#39; forward. &#39;cw&#39;, &#39;dw&#39;, &#39;w&#39;: Delete/change/move one word.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.find_next_word_beginning(count=event.arg)</span>
<span class="gi">+            or event.current_buffer.document.get_end_of_document_position()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;W&quot;)</span>
<span class="gi">+    def _WORD_forward(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;WORD&#39; forward. &#39;cW&#39;, &#39;dW&#39;, &#39;W&#39;: Delete/change/move one WORD.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.find_next_word_beginning(</span>
<span class="gi">+                count=event.arg, WORD=True</span>
<span class="gi">+            )</span>
<span class="gi">+            or event.current_buffer.document.get_end_of_document_position()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;e&quot;)</span>
<span class="gi">+    def _end_of_word(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        End of &#39;word&#39;: &#39;ce&#39;, &#39;de&#39;, &#39;e&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        end = event.current_buffer.document.find_next_word_ending(count=event.arg)</span>
<span class="gi">+        return TextObject(end - 1 if end else 0, type=TextObjectType.INCLUSIVE)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;E&quot;)</span>
<span class="gi">+    def _end_of_WORD(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        End of &#39;WORD&#39;: &#39;cE&#39;, &#39;dE&#39;, &#39;E&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        end = event.current_buffer.document.find_next_word_ending(</span>
<span class="gi">+            count=event.arg, WORD=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(end - 1 if end else 0, type=TextObjectType.INCLUSIVE)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;i&quot;, &quot;w&quot;, no_move_handler=True)</span>
<span class="gi">+    def _inner_word(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Inner &#39;word&#39;: ciw and diw</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        start, end = event.current_buffer.document.find_boundaries_of_current_word()</span>
<span class="gi">+        return TextObject(start, end)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;a&quot;, &quot;w&quot;, no_move_handler=True)</span>
<span class="gi">+    def _a_word(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        A &#39;word&#39;: caw and daw</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        start, end = event.current_buffer.document.find_boundaries_of_current_word(</span>
<span class="gi">+            include_trailing_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(start, end)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;i&quot;, &quot;W&quot;, no_move_handler=True)</span>
<span class="gi">+    def _inner_WORD(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Inner &#39;WORD&#39;: ciW and diW</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        start, end = event.current_buffer.document.find_boundaries_of_current_word(</span>
<span class="gi">+            WORD=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(start, end)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;a&quot;, &quot;W&quot;, no_move_handler=True)</span>
<span class="gi">+    def _a_WORD(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        A &#39;WORD&#39;: caw and daw</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        start, end = event.current_buffer.document.find_boundaries_of_current_word(</span>
<span class="gi">+            WORD=True, include_trailing_whitespace=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(start, end)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;a&quot;, &quot;p&quot;, no_move_handler=True)</span>
<span class="gi">+    def _paragraph(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Auto paragraph.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        start = event.current_buffer.document.start_of_paragraph()</span>
<span class="gi">+        end = event.current_buffer.document.end_of_paragraph(count=event.arg)</span>
<span class="gi">+        return TextObject(start, end)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;^&quot;)</span>
<span class="gi">+    def _start_of_line(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;&#39;c^&#39;, &#39;d^&#39; and &#39;^&#39;: Soft start of line, after whitespace.&quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_start_of_line_position(</span>
<span class="gi">+                after_whitespace=True</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;0&quot;)</span>
<span class="gi">+    def _hard_start_of_line(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;c0&#39;, &#39;d0&#39;: Hard start of line, before whitespace.</span>
<span class="gi">+        (The move &#39;0&#39; key is implemented elsewhere, because a &#39;0&#39; could also change the `arg`.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_start_of_line_position(</span>
<span class="gi">+                after_whitespace=False</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def create_ci_ca_handles(</span>
<span class="gi">+        ci_start: str, ci_end: str, inner: bool, key: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # TODO: &#39;dat&#39;, &#39;dit&#39;, (tags (like xml)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete/Change string between this start and stop character. But keep these characters.</span>
<span class="gi">+        This implements all the ci&quot;, ci&lt;, ci{, ci(, di&quot;, di&lt;, ca&quot;, ca&lt;, ... combinations.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def handler(event: E) -&gt; TextObject:</span>
<span class="gi">+            if ci_start == ci_end:</span>
<span class="gi">+                # Quotes</span>
<span class="gi">+                start = event.current_buffer.document.find_backwards(</span>
<span class="gi">+                    ci_start, in_current_line=False</span>
<span class="gi">+                )</span>
<span class="gi">+                end = event.current_buffer.document.find(ci_end, in_current_line=False)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Brackets</span>
<span class="gi">+                start = event.current_buffer.document.find_enclosing_bracket_left(</span>
<span class="gi">+                    ci_start, ci_end</span>
<span class="gi">+                )</span>
<span class="gi">+                end = event.current_buffer.document.find_enclosing_bracket_right(</span>
<span class="gi">+                    ci_start, ci_end</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if start is not None and end is not None:</span>
<span class="gi">+                offset = 0 if inner else 1</span>
<span class="gi">+                return TextObject(start + 1 - offset, end + offset)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Nothing found.</span>
<span class="gi">+                return TextObject(0)</span>
<span class="gi">+</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            text_object(&quot;ai&quot;[inner], ci_start, no_move_handler=True)(handler)</span>
<span class="gi">+            text_object(&quot;ai&quot;[inner], ci_end, no_move_handler=True)(handler)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text_object(&quot;ai&quot;[inner], key, no_move_handler=True)(handler)</span>
<span class="gi">+</span>
<span class="gi">+    for inner in (False, True):</span>
<span class="gi">+        for ci_start, ci_end in [</span>
<span class="gi">+            (&#39;&quot;&#39;, &#39;&quot;&#39;),</span>
<span class="gi">+            (&quot;&#39;&quot;, &quot;&#39;&quot;),</span>
<span class="gi">+            (&quot;`&quot;, &quot;`&quot;),</span>
<span class="gi">+            (&quot;[&quot;, &quot;]&quot;),</span>
<span class="gi">+            (&quot;&lt;&quot;, &quot;&gt;&quot;),</span>
<span class="gi">+            (&quot;{&quot;, &quot;}&quot;),</span>
<span class="gi">+            (&quot;(&quot;, &quot;)&quot;),</span>
<span class="gi">+        ]:</span>
<span class="gi">+            create_ci_ca_handles(ci_start, ci_end, inner)</span>
<span class="gi">+</span>
<span class="gi">+        create_ci_ca_handles(&quot;(&quot;, &quot;)&quot;, inner, &quot;b&quot;)  # &#39;dab&#39;, &#39;dib&#39;</span>
<span class="gi">+        create_ci_ca_handles(&quot;{&quot;, &quot;}&quot;, inner, &quot;B&quot;)  # &#39;daB&#39;, &#39;diB&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;{&quot;)</span>
<span class="gi">+    def _previous_section(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move to previous blank-line separated section.</span>
<span class="gi">+        Implements &#39;{&#39;, &#39;c{&#39;, &#39;d{&#39;, &#39;y{&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        index = event.current_buffer.document.start_of_paragraph(</span>
<span class="gi">+            count=event.arg, before=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(index)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;}&quot;)</span>
<span class="gi">+    def _next_section(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move to next blank-line separated section.</span>
<span class="gi">+        Implements &#39;}&#39;, &#39;c}&#39;, &#39;d}&#39;, &#39;y}&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        index = event.current_buffer.document.end_of_paragraph(</span>
<span class="gi">+            count=event.arg, after=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(index)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;f&quot;, Keys.Any)</span>
<span class="gi">+    def _find_next_occurrence(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to next occurrence of character. Typing &#39;fx&#39; will move the</span>
<span class="gi">+        cursor to the next occurrence of character. &#39;x&#39;.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.last_character_find = CharacterFind(event.data, False)</span>
<span class="gi">+        match = event.current_buffer.document.find(</span>
<span class="gi">+            event.data, in_current_line=True, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return TextObject(match, type=TextObjectType.INCLUSIVE)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return TextObject(0)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;F&quot;, Keys.Any)</span>
<span class="gi">+    def _find_previous_occurrence(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to previous occurrence of character. Typing &#39;Fx&#39; will move the</span>
<span class="gi">+        cursor to the previous occurrence of character. &#39;x&#39;.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.last_character_find = CharacterFind(event.data, True)</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.find_backwards(</span>
<span class="gi">+                event.data, in_current_line=True, count=event.arg</span>
<span class="gi">+            )</span>
<span class="gi">+            or 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;t&quot;, Keys.Any)</span>
<span class="gi">+    def _t(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move right to the next occurrence of c, then one char backward.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.last_character_find = CharacterFind(event.data, False)</span>
<span class="gi">+        match = event.current_buffer.document.find(</span>
<span class="gi">+            event.data, in_current_line=True, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return TextObject(match - 1, type=TextObjectType.INCLUSIVE)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return TextObject(0)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;T&quot;, Keys.Any)</span>
<span class="gi">+    def _T(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move left to the previous occurrence of c, then one char forward.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.last_character_find = CharacterFind(event.data, True)</span>
<span class="gi">+        match = event.current_buffer.document.find_backwards(</span>
<span class="gi">+            event.data, in_current_line=True, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(match + 1 if match else 0)</span>
<span class="gi">+</span>
<span class="gi">+    def repeat(reverse: bool) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Create &#39;,&#39; and &#39;;&#39; commands.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        @text_object(&quot;,&quot; if reverse else &quot;;&quot;)</span>
<span class="gi">+        def _(event: E) -&gt; TextObject:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Repeat the last &#39;f&#39;/&#39;F&#39;/&#39;t&#39;/&#39;T&#39; command.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            pos: int | None = 0</span>
<span class="gi">+            vi_state = event.app.vi_state</span>
<span class="gi">+</span>
<span class="gi">+            type = TextObjectType.EXCLUSIVE</span>
<span class="gi">+</span>
<span class="gi">+            if vi_state.last_character_find:</span>
<span class="gi">+                char = vi_state.last_character_find.character</span>
<span class="gi">+                backwards = vi_state.last_character_find.backwards</span>
<span class="gi">+</span>
<span class="gi">+                if reverse:</span>
<span class="gi">+                    backwards = not backwards</span>
<span class="gi">+</span>
<span class="gi">+                if backwards:</span>
<span class="gi">+                    pos = event.current_buffer.document.find_backwards(</span>
<span class="gi">+                        char, in_current_line=True, count=event.arg</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    pos = event.current_buffer.document.find(</span>
<span class="gi">+                        char, in_current_line=True, count=event.arg</span>
<span class="gi">+                    )</span>
<span class="gi">+                    type = TextObjectType.INCLUSIVE</span>
<span class="gi">+            if pos:</span>
<span class="gi">+                return TextObject(pos, type=type)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return TextObject(0)</span>
<span class="gi">+</span>
<span class="gi">+    repeat(True)</span>
<span class="gi">+    repeat(False)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;h&quot;)</span>
<span class="gi">+    @text_object(&quot;left&quot;)</span>
<span class="gi">+    def _left(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Implements &#39;ch&#39;, &#39;dh&#39;, &#39;h&#39;: Cursor left.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_cursor_left_position(count=event.arg)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;j&quot;, no_move_handler=True, no_selection_handler=True)</span>
<span class="gi">+    # Note: We also need `no_selection_handler`, because we in</span>
<span class="gi">+    #       selection mode, we prefer the other &#39;j&#39; binding that keeps</span>
<span class="gi">+    #       `buffer.preferred_column`.</span>
<span class="gi">+    def _down(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Implements &#39;cj&#39;, &#39;dj&#39;, &#39;j&#39;, ... Cursor up.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_cursor_down_position(count=event.arg),</span>
<span class="gi">+            type=TextObjectType.LINEWISE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;k&quot;, no_move_handler=True, no_selection_handler=True)</span>
<span class="gi">+    def _up(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Implements &#39;ck&#39;, &#39;dk&#39;, &#39;k&#39;, ... Cursor up.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_cursor_up_position(count=event.arg),</span>
<span class="gi">+            type=TextObjectType.LINEWISE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;l&quot;)</span>
<span class="gi">+    @text_object(&quot; &quot;)</span>
<span class="gi">+    @text_object(&quot;right&quot;)</span>
<span class="gi">+    def _right(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Implements &#39;cl&#39;, &#39;dl&#39;, &#39;l&#39;, &#39;c &#39;, &#39;d &#39;, &#39; &#39;. Cursor right.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_cursor_right_position(count=event.arg)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;H&quot;)</span>
<span class="gi">+    def _top_of_screen(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Moves to the start of the visible region. (Below the scroll offset.)</span>
<span class="gi">+        Implements &#39;cH&#39;, &#39;dH&#39;, &#39;H&#39;.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        w = event.app.layout.current_window</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if w and w.render_info:</span>
<span class="gi">+            # When we find a Window that has BufferControl showing this window,</span>
<span class="gi">+            # move to the start of the visible area.</span>
<span class="gi">+            pos = (</span>
<span class="gi">+                b.document.translate_row_col_to_index(</span>
<span class="gi">+                    w.render_info.first_visible_line(after_scroll_offset=True), 0</span>
<span class="gi">+                )</span>
<span class="gi">+                - b.cursor_position</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, move to the start of the input.</span>
<span class="gi">+            pos = -len(b.document.text_before_cursor)</span>
<span class="gi">+        return TextObject(pos, type=TextObjectType.LINEWISE)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;M&quot;)</span>
<span class="gi">+    def _middle_of_screen(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Moves cursor to the vertical center of the visible region.</span>
<span class="gi">+        Implements &#39;cM&#39;, &#39;dM&#39;, &#39;M&#39;.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        w = event.app.layout.current_window</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if w and w.render_info:</span>
<span class="gi">+            # When we find a Window that has BufferControl showing this window,</span>
<span class="gi">+            # move to the center of the visible area.</span>
<span class="gi">+            pos = (</span>
<span class="gi">+                b.document.translate_row_col_to_index(</span>
<span class="gi">+                    w.render_info.center_visible_line(), 0</span>
<span class="gi">+                )</span>
<span class="gi">+                - b.cursor_position</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, move to the start of the input.</span>
<span class="gi">+            pos = -len(b.document.text_before_cursor)</span>
<span class="gi">+        return TextObject(pos, type=TextObjectType.LINEWISE)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;L&quot;)</span>
<span class="gi">+    def _end_of_screen(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Moves to the end of the visible region. (Above the scroll offset.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        w = event.app.layout.current_window</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if w and w.render_info:</span>
<span class="gi">+            # When we find a Window that has BufferControl showing this window,</span>
<span class="gi">+            # move to the end of the visible area.</span>
<span class="gi">+            pos = (</span>
<span class="gi">+                b.document.translate_row_col_to_index(</span>
<span class="gi">+                    w.render_info.last_visible_line(before_scroll_offset=True), 0</span>
<span class="gi">+                )</span>
<span class="gi">+                - b.cursor_position</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, move to the end of the input.</span>
<span class="gi">+            pos = len(b.document.text_after_cursor)</span>
<span class="gi">+        return TextObject(pos, type=TextObjectType.LINEWISE)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;n&quot;, no_move_handler=True)</span>
<span class="gi">+    def _search_next(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Search next.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        search_state = event.app.current_search_state</span>
<span class="gi">+</span>
<span class="gi">+        cursor_position = buff.get_search_position(</span>
<span class="gi">+            search_state, include_current_position=False, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(cursor_position - buff.cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;n&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _search_next2(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Search next in navigation mode. (This goes through the history.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        search_state = event.app.current_search_state</span>
<span class="gi">+</span>
<span class="gi">+        event.current_buffer.apply_search(</span>
<span class="gi">+            search_state, include_current_position=False, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;N&quot;, no_move_handler=True)</span>
<span class="gi">+    def _search_previous(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Search previous.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        search_state = event.app.current_search_state</span>
<span class="gi">+</span>
<span class="gi">+        cursor_position = buff.get_search_position(</span>
<span class="gi">+            ~search_state, include_current_position=False, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(cursor_position - buff.cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;N&quot;, filter=vi_navigation_mode)</span>
<span class="gi">+    def _search_previous2(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Search previous in navigation mode. (This goes through the history.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        search_state = event.app.current_search_state</span>
<span class="gi">+</span>
<span class="gi">+        event.current_buffer.apply_search(</span>
<span class="gi">+            ~search_state, include_current_position=False, count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;z&quot;, &quot;+&quot;, filter=vi_navigation_mode | vi_selection_mode)</span>
<span class="gi">+    @handle(&quot;z&quot;, &quot;t&quot;, filter=vi_navigation_mode | vi_selection_mode)</span>
<span class="gi">+    @handle(&quot;z&quot;, &quot;enter&quot;, filter=vi_navigation_mode | vi_selection_mode)</span>
<span class="gi">+    def _scroll_top(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Scrolls the window to makes the current line the first line in the visible region.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        event.app.layout.current_window.vertical_scroll = b.document.cursor_position_row</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;z&quot;, &quot;-&quot;, filter=vi_navigation_mode | vi_selection_mode)</span>
<span class="gi">+    @handle(&quot;z&quot;, &quot;b&quot;, filter=vi_navigation_mode | vi_selection_mode)</span>
<span class="gi">+    def _scroll_bottom(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Scrolls the window to makes the current line the last line in the visible region.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # We can safely set the scroll offset to zero; the Window will make</span>
<span class="gi">+        # sure that it scrolls at least enough to make the cursor visible</span>
<span class="gi">+        # again.</span>
<span class="gi">+        event.app.layout.current_window.vertical_scroll = 0</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;z&quot;, &quot;z&quot;, filter=vi_navigation_mode | vi_selection_mode)</span>
<span class="gi">+    def _scroll_center(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Center Window vertically around cursor.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        w = event.app.layout.current_window</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if w and w.render_info:</span>
<span class="gi">+            info = w.render_info</span>
<span class="gi">+</span>
<span class="gi">+            # Calculate the offset that we need in order to position the row</span>
<span class="gi">+            # containing the cursor in the center.</span>
<span class="gi">+            scroll_height = info.window_height // 2</span>
<span class="gi">+</span>
<span class="gi">+            y = max(0, b.document.cursor_position_row - 1)</span>
<span class="gi">+            height = 0</span>
<span class="gi">+            while y &gt; 0:</span>
<span class="gi">+                line_height = info.get_height_for_line(y)</span>
<span class="gi">+</span>
<span class="gi">+                if height + line_height &lt; scroll_height:</span>
<span class="gi">+                    height += line_height</span>
<span class="gi">+                    y -= 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            w.vertical_scroll = y</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;%&quot;)</span>
<span class="gi">+    def _goto_corresponding_bracket(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Implements &#39;c%&#39;, &#39;d%&#39;, &#39;%, &#39;y%&#39; (Move to corresponding bracket.)</span>
<span class="gi">+        If an &#39;arg&#39; has been given, go this this % position in the file.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buffer = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if event._arg:</span>
<span class="gi">+            # If &#39;arg&#39; has been given, the meaning of % is to go to the &#39;x%&#39;</span>
<span class="gi">+            # row in the file.</span>
<span class="gi">+            if 0 &lt; event.arg &lt;= 100:</span>
<span class="gi">+                absolute_index = buffer.document.translate_row_col_to_index(</span>
<span class="gi">+                    int((event.arg * buffer.document.line_count - 1) / 100), 0</span>
<span class="gi">+                )</span>
<span class="gi">+                return TextObject(</span>
<span class="gi">+                    absolute_index - buffer.document.cursor_position,</span>
<span class="gi">+                    type=TextObjectType.LINEWISE,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                return TextObject(0)  # Do nothing.</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Move to the corresponding opening/closing bracket (()&#39;s, []&#39;s and {}&#39;s).</span>
<span class="gi">+            match = buffer.document.find_matching_bracket_position()</span>
<span class="gi">+            if match:</span>
<span class="gi">+                return TextObject(match, type=TextObjectType.INCLUSIVE)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return TextObject(0)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;|&quot;)</span>
<span class="gi">+    def _to_column(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move to the n-th column (you may specify the argument n by typing it on</span>
<span class="gi">+        number keys, for example, 20|).</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.get_column_cursor_position(event.arg - 1)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;g&quot;, &quot;g&quot;)</span>
<span class="gi">+    def _goto_first_line(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to the start of the very first line.</span>
<span class="gi">+        Implements &#39;gg&#39;, &#39;cgg&#39;, &#39;ygg&#39;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        d = event.current_buffer.document</span>
<span class="gi">+</span>
<span class="gi">+        if event._arg:</span>
<span class="gi">+            # Move to the given line.</span>
<span class="gi">+            return TextObject(</span>
<span class="gi">+                d.translate_row_col_to_index(event.arg - 1, 0) - d.cursor_position,</span>
<span class="gi">+                type=TextObjectType.LINEWISE,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Move to the top of the input.</span>
<span class="gi">+            return TextObject(</span>
<span class="gi">+                d.get_start_of_document_position(), type=TextObjectType.LINEWISE</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;g&quot;, &quot;_&quot;)</span>
<span class="gi">+    def _goto_last_line(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to last non-blank of line.</span>
<span class="gi">+        &#39;g_&#39;, &#39;cg_&#39;, &#39;yg_&#39;, etc..</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            event.current_buffer.document.last_non_blank_of_current_line_position(),</span>
<span class="gi">+            type=TextObjectType.INCLUSIVE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;g&quot;, &quot;e&quot;)</span>
<span class="gi">+    def _ge(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to last character of previous word.</span>
<span class="gi">+        &#39;ge&#39;, &#39;cge&#39;, &#39;yge&#39;, etc..</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        prev_end = event.current_buffer.document.find_previous_word_ending(</span>
<span class="gi">+            count=event.arg</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            prev_end - 1 if prev_end is not None else 0, type=TextObjectType.INCLUSIVE</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;g&quot;, &quot;E&quot;)</span>
<span class="gi">+    def _gE(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to last character of previous WORD.</span>
<span class="gi">+        &#39;gE&#39;, &#39;cgE&#39;, &#39;ygE&#39;, etc..</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        prev_end = event.current_buffer.document.find_previous_word_ending(</span>
<span class="gi">+            count=event.arg, WORD=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            prev_end - 1 if prev_end is not None else 0, type=TextObjectType.INCLUSIVE</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;g&quot;, &quot;m&quot;)</span>
<span class="gi">+    def _gm(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Like g0, but half a screenwidth to the right. (Or as much as possible.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        w = event.app.layout.current_window</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if w and w.render_info:</span>
<span class="gi">+            width = w.render_info.window_width</span>
<span class="gi">+            start = buff.document.get_start_of_line_position(after_whitespace=False)</span>
<span class="gi">+            start += int(min(width / 2, len(buff.document.current_line)))</span>
<span class="gi">+</span>
<span class="gi">+            return TextObject(start, type=TextObjectType.INCLUSIVE)</span>
<span class="gi">+        return TextObject(0)</span>
<span class="gi">+</span>
<span class="gi">+    @text_object(&quot;G&quot;)</span>
<span class="gi">+    def _last_line(event: E) -&gt; TextObject:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go to the end of the document. (If no arg has been given.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buf = event.current_buffer</span>
<span class="gi">+        return TextObject(</span>
<span class="gi">+            buf.document.translate_row_col_to_index(buf.document.line_count - 1, 0)</span>
<span class="gi">+            - buf.cursor_position,</span>
<span class="gi">+            type=TextObjectType.LINEWISE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # *** Other ***</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;G&quot;, filter=has_arg)</span>
<span class="gi">+    def _to_nth_history_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        If an argument is given, move to this line in the  history. (for</span>
<span class="gi">+        example, 15G)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.go_to_history(event.arg - 1)</span>
<span class="gi">+</span>
<span class="gi">+    for n in &quot;123456789&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        @handle(</span>
<span class="gi">+            n,</span>
<span class="gi">+            filter=vi_navigation_mode</span>
<span class="gi">+            | vi_selection_mode</span>
<span class="gi">+            | vi_waiting_for_text_object_mode,</span>
<span class="gi">+        )</span>
<span class="gi">+        def _arg(event: E) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Always handle numerics in navigation mode as arg.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            event.append_to_arg_count(event.data)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(</span>
<span class="gi">+        &quot;0&quot;,</span>
<span class="gi">+        filter=(</span>
<span class="gi">+            vi_navigation_mode | vi_selection_mode | vi_waiting_for_text_object_mode</span>
<span class="gi">+        )</span>
<span class="gi">+        &amp; has_arg,</span>
<span class="gi">+    )</span>
<span class="gi">+    def _0_arg(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Zero when an argument was already give.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.append_to_arg_count(event.data)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=vi_replace_mode)</span>
<span class="gi">+    def _insert_text(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Insert data at cursor position.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.insert_text(event.data, overwrite=True)</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=vi_replace_single_mode)</span>
<span class="gi">+    def _replace_single(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Replace single character at cursor position.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.insert_text(event.data, overwrite=True)</span>
<span class="gi">+        event.current_buffer.cursor_position -= 1</span>
<span class="gi">+        event.app.vi_state.input_mode = InputMode.NAVIGATION</span>
<span class="gi">+</span>
<span class="gi">+    @handle(</span>
<span class="gi">+        Keys.Any,</span>
<span class="gi">+        filter=vi_insert_multiple_mode,</span>
<span class="gi">+        save_before=(lambda e: not e.is_repeat),</span>
<span class="gi">+    )</span>
<span class="gi">+    def _insert_text_multiple_cursors(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Insert data at multiple cursor positions at once.</span>
<span class="gi">+        (Usually a result of pressing &#39;I&#39; or &#39;A&#39; in block-selection mode.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        original_text = buff.text</span>
<span class="gi">+</span>
<span class="gi">+        # Construct new text.</span>
<span class="gi">+        text = []</span>
<span class="gi">+        p = 0</span>
<span class="gi">+</span>
<span class="gi">+        for p2 in buff.multiple_cursor_positions:</span>
<span class="gi">+            text.append(original_text[p:p2])</span>
<span class="gi">+            text.append(event.data)</span>
<span class="gi">+            p = p2</span>
<span class="gi">+</span>
<span class="gi">+        text.append(original_text[p:])</span>
<span class="gi">+</span>
<span class="gi">+        # Shift all cursor positions.</span>
<span class="gi">+        new_cursor_positions = [</span>
<span class="gi">+            pos + i + 1 for i, pos in enumerate(buff.multiple_cursor_positions)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Set result.</span>
<span class="gi">+        buff.text = &quot;&quot;.join(text)</span>
<span class="gi">+        buff.multiple_cursor_positions = new_cursor_positions</span>
<span class="gi">+        buff.cursor_position += 1</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;backspace&quot;, filter=vi_insert_multiple_mode)</span>
<span class="gi">+    def _delete_before_multiple_cursors(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Backspace, using multiple cursors.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        original_text = buff.text</span>
<span class="gi">+</span>
<span class="gi">+        # Construct new text.</span>
<span class="gi">+        deleted_something = False</span>
<span class="gi">+        text = []</span>
<span class="gi">+        p = 0</span>
<span class="gi">+</span>
<span class="gi">+        for p2 in buff.multiple_cursor_positions:</span>
<span class="gi">+            if p2 &gt; 0 and original_text[p2 - 1] != &quot;\n&quot;:  # Don&#39;t delete across lines.</span>
<span class="gi">+                text.append(original_text[p : p2 - 1])</span>
<span class="gi">+                deleted_something = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                text.append(original_text[p:p2])</span>
<span class="gi">+            p = p2</span>
<span class="gi">+</span>
<span class="gi">+        text.append(original_text[p:])</span>
<span class="gi">+</span>
<span class="gi">+        if deleted_something:</span>
<span class="gi">+            # Shift all cursor positions.</span>
<span class="gi">+            lengths = [len(part) for part in text[:-1]]</span>
<span class="gi">+            new_cursor_positions = list(accumulate(lengths))</span>
<span class="gi">+</span>
<span class="gi">+            # Set result.</span>
<span class="gi">+            buff.text = &quot;&quot;.join(text)</span>
<span class="gi">+            buff.multiple_cursor_positions = new_cursor_positions</span>
<span class="gi">+            buff.cursor_position -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            event.app.output.bell()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;delete&quot;, filter=vi_insert_multiple_mode)</span>
<span class="gi">+    def _delete_after_multiple_cursors(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Delete, using multiple cursors.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        original_text = buff.text</span>
<span class="gi">+</span>
<span class="gi">+        # Construct new text.</span>
<span class="gi">+        deleted_something = False</span>
<span class="gi">+        text = []</span>
<span class="gi">+        new_cursor_positions = []</span>
<span class="gi">+        p = 0</span>
<span class="gi">+</span>
<span class="gi">+        for p2 in buff.multiple_cursor_positions:</span>
<span class="gi">+            text.append(original_text[p:p2])</span>
<span class="gi">+            if p2 &gt;= len(original_text) or original_text[p2] == &quot;\n&quot;:</span>
<span class="gi">+                # Don&#39;t delete across lines.</span>
<span class="gi">+                p = p2</span>
<span class="gi">+            else:</span>
<span class="gi">+                p = p2 + 1</span>
<span class="gi">+                deleted_something = True</span>
<span class="gi">+</span>
<span class="gi">+        text.append(original_text[p:])</span>
<span class="gi">+</span>
<span class="gi">+        if deleted_something:</span>
<span class="gi">+            # Shift all cursor positions.</span>
<span class="gi">+            lengths = [len(part) for part in text[:-1]]</span>
<span class="gi">+            new_cursor_positions = list(accumulate(lengths))</span>
<span class="gi">+</span>
<span class="gi">+            # Set result.</span>
<span class="gi">+            buff.text = &quot;&quot;.join(text)</span>
<span class="gi">+            buff.multiple_cursor_positions = new_cursor_positions</span>
<span class="gi">+        else:</span>
<span class="gi">+            event.app.output.bell()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;left&quot;, filter=vi_insert_multiple_mode)</span>
<span class="gi">+    def _left_multiple(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move all cursors to the left.</span>
<span class="gi">+        (But keep all cursors on the same line.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        new_positions = []</span>
<span class="gi">+</span>
<span class="gi">+        for p in buff.multiple_cursor_positions:</span>
<span class="gi">+            if buff.document.translate_index_to_position(p)[1] &gt; 0:</span>
<span class="gi">+                p -= 1</span>
<span class="gi">+            new_positions.append(p)</span>
<span class="gi">+</span>
<span class="gi">+        buff.multiple_cursor_positions = new_positions</span>
<span class="gi">+</span>
<span class="gi">+        if buff.document.cursor_position_col &gt; 0:</span>
<span class="gi">+            buff.cursor_position -= 1</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;right&quot;, filter=vi_insert_multiple_mode)</span>
<span class="gi">+    def _right_multiple(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Move all cursors to the right.</span>
<span class="gi">+        (But keep all cursors on the same line.)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        new_positions = []</span>
<span class="gi">+</span>
<span class="gi">+        for p in buff.multiple_cursor_positions:</span>
<span class="gi">+            row, column = buff.document.translate_index_to_position(p)</span>
<span class="gi">+            if column &lt; len(buff.document.lines[row]):</span>
<span class="gi">+                p += 1</span>
<span class="gi">+            new_positions.append(p)</span>
<span class="gi">+</span>
<span class="gi">+        buff.multiple_cursor_positions = new_positions</span>
<span class="gi">+</span>
<span class="gi">+        if not buff.document.is_cursor_at_the_end_of_line:</span>
<span class="gi">+            buff.cursor_position += 1</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;up&quot;, filter=vi_insert_multiple_mode)</span>
<span class="gi">+    @handle(&quot;down&quot;, filter=vi_insert_multiple_mode)</span>
<span class="gi">+    def _updown_multiple(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Ignore all up/down key presses when in multiple cursor mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-x&quot;, &quot;c-l&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _complete_line(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Pressing the ControlX - ControlL sequence in Vi mode does line</span>
<span class="gi">+        completion based on the other lines in the document and the history.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.start_history_lines_completion()</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-x&quot;, &quot;c-f&quot;, filter=vi_insert_mode)</span>
<span class="gi">+    def _complete_filename(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Complete file names.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # TODO</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-k&quot;, filter=vi_insert_mode | vi_replace_mode)</span>
<span class="gi">+    def _digraph(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go into digraph mode.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.waiting_for_digraph = True</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def digraph_symbol_1_given() -&gt; bool:</span>
<span class="gi">+        return get_app().vi_state.digraph_symbol1 is not None</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=vi_digraph_mode &amp; ~digraph_symbol_1_given)</span>
<span class="gi">+    def _digraph1(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        First digraph symbol.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.digraph_symbol1 = event.data</span>
<span class="gi">+</span>
<span class="gi">+    @handle(Keys.Any, filter=vi_digraph_mode &amp; digraph_symbol_1_given)</span>
<span class="gi">+    def _create_digraph(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Insert digraph.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Lookup.</span>
<span class="gi">+            code: tuple[str, str] = (</span>
<span class="gi">+                event.app.vi_state.digraph_symbol1 or &quot;&quot;,</span>
<span class="gi">+                event.data,</span>
<span class="gi">+            )</span>
<span class="gi">+            if code not in DIGRAPHS:</span>
<span class="gi">+                code = code[::-1]  # Try reversing.</span>
<span class="gi">+            symbol = DIGRAPHS[code]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Unknown digraph.</span>
<span class="gi">+            event.app.output.bell()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Insert digraph.</span>
<span class="gi">+            overwrite = event.app.vi_state.input_mode == InputMode.REPLACE</span>
<span class="gi">+            event.current_buffer.insert_text(chr(symbol), overwrite=overwrite)</span>
<span class="gi">+            event.app.vi_state.waiting_for_digraph = False</span>
<span class="gi">+        finally:</span>
<span class="gi">+            event.app.vi_state.waiting_for_digraph = False</span>
<span class="gi">+            event.app.vi_state.digraph_symbol1 = None</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;c-o&quot;, filter=vi_insert_mode | vi_replace_mode)</span>
<span class="gi">+    def _quick_normal_mode(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Go into normal mode for one single action.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        event.app.vi_state.temporary_navigation_mode = True</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;q&quot;, Keys.Any, filter=vi_navigation_mode &amp; ~vi_recording_macro)</span>
<span class="gi">+    def _start_macro(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Start recording macro.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        c = event.key_sequence[1].data</span>
<span class="gi">+        if c in vi_register_names:</span>
<span class="gi">+            vi_state = event.app.vi_state</span>
<span class="gi">+</span>
<span class="gi">+            vi_state.recording_register = c</span>
<span class="gi">+            vi_state.current_recording = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;q&quot;, filter=vi_navigation_mode &amp; vi_recording_macro)</span>
<span class="gi">+    def _stop_macro(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Stop recording macro.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        vi_state = event.app.vi_state</span>
<span class="gi">+</span>
<span class="gi">+        # Store and stop recording.</span>
<span class="gi">+        if vi_state.recording_register:</span>
<span class="gi">+            vi_state.named_registers[vi_state.recording_register] = ClipboardData(</span>
<span class="gi">+                vi_state.current_recording</span>
<span class="gi">+            )</span>
<span class="gi">+            vi_state.recording_register = None</span>
<span class="gi">+            vi_state.current_recording = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @handle(&quot;@&quot;, Keys.Any, filter=vi_navigation_mode, record_in_macro=False)</span>
<span class="gi">+    def _execute_macro(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Execute macro.</span>
<span class="gi">+</span>
<span class="gi">+        Notice that we pass `record_in_macro=False`. This ensures that the `@x`</span>
<span class="gi">+        keys don&#39;t appear in the recording itself. This function inserts the</span>
<span class="gi">+        body of the called macro back into the KeyProcessor, so these keys will</span>
<span class="gi">+        be added later on to the macro of their handlers have</span>
<span class="gi">+        `record_in_macro=True`.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Retrieve macro.</span>
<span class="gi">+        c = event.key_sequence[1].data</span>
<span class="gi">+        try:</span>
<span class="gi">+            macro = event.app.vi_state.named_registers[c]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Expand macro (which is a string in the register), in individual keys.</span>
<span class="gi">+        # Use vt100 parser for this.</span>
<span class="gi">+        keys: list[KeyPress] = []</span>
<span class="gi">+</span>
<span class="gi">+        parser = Vt100Parser(keys.append)</span>
<span class="gi">+        parser.feed(macro.text)</span>
<span class="gi">+        parser.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Now feed keys back to the input processor.</span>
<span class="gi">+        for _ in range(event.arg):</span>
<span class="gi">+            event.app.key_processor.feed_multiple(keys, first=True)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(key_bindings, vi_mode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_vi_search_bindings() -&gt; KeyBindingsBase:</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+    handle = key_bindings.add</span>
<span class="gi">+    from . import search</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def search_buffer_is_empty() -&gt; bool:</span>
<span class="gi">+        &quot;Returns True when the search buffer is empty.&quot;</span>
<span class="gi">+        return get_app().current_buffer.text == &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Vi-style forward search.</span>
<span class="gi">+    handle(</span>
<span class="gi">+        &quot;/&quot;,</span>
<span class="gi">+        filter=(vi_navigation_mode | vi_selection_mode) &amp; ~vi_search_direction_reversed,</span>
<span class="gi">+    )(search.start_forward_incremental_search)</span>
<span class="gi">+    handle(</span>
<span class="gi">+        &quot;?&quot;,</span>
<span class="gi">+        filter=(vi_navigation_mode | vi_selection_mode) &amp; vi_search_direction_reversed,</span>
<span class="gi">+    )(search.start_forward_incremental_search)</span>
<span class="gi">+    handle(&quot;c-s&quot;)(search.start_forward_incremental_search)</span>
<span class="gi">+</span>
<span class="gi">+    # Vi-style backward search.</span>
<span class="gi">+    handle(</span>
<span class="gi">+        &quot;?&quot;,</span>
<span class="gi">+        filter=(vi_navigation_mode | vi_selection_mode) &amp; ~vi_search_direction_reversed,</span>
<span class="gi">+    )(search.start_reverse_incremental_search)</span>
<span class="gi">+    handle(</span>
<span class="gi">+        &quot;/&quot;,</span>
<span class="gi">+        filter=(vi_navigation_mode | vi_selection_mode) &amp; vi_search_direction_reversed,</span>
<span class="gi">+    )(search.start_reverse_incremental_search)</span>
<span class="gi">+    handle(&quot;c-r&quot;)(search.start_reverse_incremental_search)</span>
<span class="gi">+</span>
<span class="gi">+    # Apply the search. (At the / or ? prompt.)</span>
<span class="gi">+    handle(&quot;enter&quot;, filter=is_searching)(search.accept_search)</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-r&quot;, filter=is_searching)(search.reverse_incremental_search)</span>
<span class="gi">+    handle(&quot;c-s&quot;, filter=is_searching)(search.forward_incremental_search)</span>
<span class="gi">+</span>
<span class="gi">+    handle(&quot;c-c&quot;)(search.abort_search)</span>
<span class="gi">+    handle(&quot;c-g&quot;)(search.abort_search)</span>
<span class="gi">+    handle(&quot;backspace&quot;, filter=search_buffer_is_empty)(search.abort_search)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle escape. This should accept the search, just like readline.</span>
<span class="gi">+    # `abort_search` would be a meaningful alternative.</span>
<span class="gi">+    handle(&quot;escape&quot;)(search.accept_search)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(key_bindings, vi_mode)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/defaults.py b/src/prompt_toolkit/key_binding/defaults.py</span>
<span class="gh">index 020b28c1..166da8d4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/defaults.py</span>
<span class="gu">@@ -5,18 +5,58 @@ Default key bindings.::</span>
<span class="w"> </span>    app = Application(key_bindings=key_bindings)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.filters import buffer_has_focus
<span class="w"> </span>from prompt_toolkit.key_binding.bindings.basic import load_basic_bindings
<span class="w"> </span>from prompt_toolkit.key_binding.bindings.cpr import load_cpr_bindings
<span class="gd">-from prompt_toolkit.key_binding.bindings.emacs import load_emacs_bindings, load_emacs_search_bindings, load_emacs_shift_selection_bindings</span>
<span class="gi">+from prompt_toolkit.key_binding.bindings.emacs import (</span>
<span class="gi">+    load_emacs_bindings,</span>
<span class="gi">+    load_emacs_search_bindings,</span>
<span class="gi">+    load_emacs_shift_selection_bindings,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.bindings.mouse import load_mouse_bindings
<span class="gd">-from prompt_toolkit.key_binding.bindings.vi import load_vi_bindings, load_vi_search_bindings</span>
<span class="gd">-from prompt_toolkit.key_binding.key_bindings import ConditionalKeyBindings, KeyBindingsBase, merge_key_bindings</span>
<span class="gd">-__all__ = [&#39;load_key_bindings&#39;]</span>
<span class="gi">+from prompt_toolkit.key_binding.bindings.vi import (</span>
<span class="gi">+    load_vi_bindings,</span>
<span class="gi">+    load_vi_search_bindings,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+    ConditionalKeyBindings,</span>
<span class="gi">+    KeyBindingsBase,</span>
<span class="gi">+    merge_key_bindings,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;load_key_bindings&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def load_key_bindings() -&gt;KeyBindingsBase:</span>
<span class="gi">+def load_key_bindings() -&gt; KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a KeyBindings object that contains the default key bindings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    all_bindings = merge_key_bindings(</span>
<span class="gi">+        [</span>
<span class="gi">+            # Load basic bindings.</span>
<span class="gi">+            load_basic_bindings(),</span>
<span class="gi">+            # Load emacs bindings.</span>
<span class="gi">+            load_emacs_bindings(),</span>
<span class="gi">+            load_emacs_search_bindings(),</span>
<span class="gi">+            load_emacs_shift_selection_bindings(),</span>
<span class="gi">+            # Load Vi bindings.</span>
<span class="gi">+            load_vi_bindings(),</span>
<span class="gi">+            load_vi_search_bindings(),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return merge_key_bindings(</span>
<span class="gi">+        [</span>
<span class="gi">+            # Make sure that the above key bindings are only active if the</span>
<span class="gi">+            # currently focused control is a `BufferControl`. For other controls, we</span>
<span class="gi">+            # don&#39;t want these key bindings to intervene. (This would break &quot;ptterm&quot;</span>
<span class="gi">+            # for instance, which handles &#39;Keys.Any&#39; in the user control itself.)</span>
<span class="gi">+            ConditionalKeyBindings(all_bindings, buffer_has_focus),</span>
<span class="gi">+            # Active, even when no buffer has been focused.</span>
<span class="gi">+            load_mouse_bindings(),</span>
<span class="gi">+            load_cpr_bindings(),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/digraphs.py b/src/prompt_toolkit/key_binding/digraphs.py</span>
<span class="gh">index 3658dd15..1e8a4326 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/digraphs.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/digraphs.py</span>
<span class="gu">@@ -7,344 +7,1371 @@ Taken from Neovim and translated to Python:</span>
<span class="w"> </span>https://raw.githubusercontent.com/neovim/neovim/master/src/nvim/digraph.c
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gd">-__all__ = [&#39;DIGRAPHS&#39;]</span>
<span class="gd">-DIGRAPHS: dict[tuple[str, str], int] = {(&#39;N&#39;, &#39;U&#39;): 0, (&#39;S&#39;, &#39;H&#39;): 1, (&#39;S&#39;,</span>
<span class="gd">-    &#39;X&#39;): 2, (&#39;E&#39;, &#39;X&#39;): 3, (&#39;E&#39;, &#39;T&#39;): 4, (&#39;E&#39;, &#39;Q&#39;): 5, (&#39;A&#39;, &#39;K&#39;): 6, (</span>
<span class="gd">-    &#39;B&#39;, &#39;L&#39;): 7, (&#39;B&#39;, &#39;S&#39;): 8, (&#39;H&#39;, &#39;T&#39;): 9, (&#39;L&#39;, &#39;F&#39;): 10, (&#39;V&#39;, &#39;T&#39;):</span>
<span class="gd">-    11, (&#39;F&#39;, &#39;F&#39;): 12, (&#39;C&#39;, &#39;R&#39;): 13, (&#39;S&#39;, &#39;O&#39;): 14, (&#39;S&#39;, &#39;I&#39;): 15, (</span>
<span class="gd">-    &#39;D&#39;, &#39;L&#39;): 16, (&#39;D&#39;, &#39;1&#39;): 17, (&#39;D&#39;, &#39;2&#39;): 18, (&#39;D&#39;, &#39;3&#39;): 19, (&#39;D&#39;,</span>
<span class="gd">-    &#39;4&#39;): 20, (&#39;N&#39;, &#39;K&#39;): 21, (&#39;S&#39;, &#39;Y&#39;): 22, (&#39;E&#39;, &#39;B&#39;): 23, (&#39;C&#39;, &#39;N&#39;): </span>
<span class="gd">-    24, (&#39;E&#39;, &#39;M&#39;): 25, (&#39;S&#39;, &#39;B&#39;): 26, (&#39;E&#39;, &#39;C&#39;): 27, (&#39;F&#39;, &#39;S&#39;): 28, (</span>
<span class="gd">-    &#39;G&#39;, &#39;S&#39;): 29, (&#39;R&#39;, &#39;S&#39;): 30, (&#39;U&#39;, &#39;S&#39;): 31, (&#39;S&#39;, &#39;P&#39;): 32, (&#39;N&#39;,</span>
<span class="gd">-    &#39;b&#39;): 35, (&#39;D&#39;, &#39;O&#39;): 36, (&#39;A&#39;, &#39;t&#39;): 64, (&#39;&lt;&#39;, &#39;(&#39;): 91, (&#39;/&#39;, &#39;/&#39;): </span>
<span class="gd">-    92, (&#39;)&#39;, &#39;&gt;&#39;): 93, (&quot;&#39;&quot;, &#39;&gt;&#39;): 94, (&quot;&#39;&quot;, &#39;!&#39;): 96, (&#39;(&#39;, &#39;!&#39;): 123, (</span>
<span class="gd">-    &#39;!&#39;, &#39;!&#39;): 124, (&#39;!&#39;, &#39;)&#39;): 125, (&quot;&#39;&quot;, &#39;?&#39;): 126, (&#39;D&#39;, &#39;T&#39;): 127, (&#39;P&#39;,</span>
<span class="gd">-    &#39;A&#39;): 128, (&#39;H&#39;, &#39;O&#39;): 129, (&#39;B&#39;, &#39;H&#39;): 130, (&#39;N&#39;, &#39;H&#39;): 131, (&#39;I&#39;, &#39;N&#39;</span>
<span class="gd">-    ): 132, (&#39;N&#39;, &#39;L&#39;): 133, (&#39;S&#39;, &#39;A&#39;): 134, (&#39;E&#39;, &#39;S&#39;): 135, (&#39;H&#39;, &#39;S&#39;): </span>
<span class="gd">-    136, (&#39;H&#39;, &#39;J&#39;): 137, (&#39;V&#39;, &#39;S&#39;): 138, (&#39;P&#39;, &#39;D&#39;): 139, (&#39;P&#39;, &#39;U&#39;): 140,</span>
<span class="gd">-    (&#39;R&#39;, &#39;I&#39;): 141, (&#39;S&#39;, &#39;2&#39;): 142, (&#39;S&#39;, &#39;3&#39;): 143, (&#39;D&#39;, &#39;C&#39;): 144, (</span>
<span class="gd">-    &#39;P&#39;, &#39;1&#39;): 145, (&#39;P&#39;, &#39;2&#39;): 146, (&#39;T&#39;, &#39;S&#39;): 147, (&#39;C&#39;, &#39;C&#39;): 148, (&#39;M&#39;,</span>
<span class="gd">-    &#39;W&#39;): 149, (&#39;S&#39;, &#39;G&#39;): 150, (&#39;E&#39;, &#39;G&#39;): 151, (&#39;S&#39;, &#39;S&#39;): 152, (&#39;G&#39;, &#39;C&#39;</span>
<span class="gd">-    ): 153, (&#39;S&#39;, &#39;C&#39;): 154, (&#39;C&#39;, &#39;I&#39;): 155, (&#39;S&#39;, &#39;T&#39;): 156, (&#39;O&#39;, &#39;C&#39;): </span>
<span class="gd">-    157, (&#39;P&#39;, &#39;M&#39;): 158, (&#39;A&#39;, &#39;C&#39;): 159, (&#39;N&#39;, &#39;S&#39;): 160, (&#39;!&#39;, &#39;I&#39;): 161,</span>
<span class="gd">-    (&#39;C&#39;, &#39;t&#39;): 162, (&#39;P&#39;, &#39;d&#39;): 163, (&#39;C&#39;, &#39;u&#39;): 164, (&#39;Y&#39;, &#39;e&#39;): 165, (</span>
<span class="gd">-    &#39;B&#39;, &#39;B&#39;): 166, (&#39;S&#39;, &#39;E&#39;): 167, (&quot;&#39;&quot;, &#39;:&#39;): 168, (&#39;C&#39;, &#39;o&#39;): 169, (&#39;-&#39;,</span>
<span class="gd">-    &#39;a&#39;): 170, (&#39;&lt;&#39;, &#39;&lt;&#39;): 171, (&#39;N&#39;, &#39;O&#39;): 172, (&#39;-&#39;, &#39;-&#39;): 173, (&#39;R&#39;, &#39;g&#39;</span>
<span class="gd">-    ): 174, (&quot;&#39;&quot;, &#39;m&#39;): 175, (&#39;D&#39;, &#39;G&#39;): 176, (&#39;+&#39;, &#39;-&#39;): 177, (&#39;2&#39;, &#39;S&#39;): </span>
<span class="gd">-    178, (&#39;3&#39;, &#39;S&#39;): 179, (&quot;&#39;&quot;, &quot;&#39;&quot;): 180, (&#39;M&#39;, &#39;y&#39;): 181, (&#39;P&#39;, &#39;I&#39;): 182,</span>
<span class="gd">-    (&#39;.&#39;, &#39;M&#39;): 183, (&quot;&#39;&quot;, &#39;,&#39;): 184, (&#39;1&#39;, &#39;S&#39;): 185, (&#39;-&#39;, &#39;o&#39;): 186, (</span>
<span class="gd">-    &#39;&gt;&#39;, &#39;&gt;&#39;): 187, (&#39;1&#39;, &#39;4&#39;): 188, (&#39;1&#39;, &#39;2&#39;): 189, (&#39;3&#39;, &#39;4&#39;): 190, (&#39;?&#39;,</span>
<span class="gd">-    &#39;I&#39;): 191, (&#39;A&#39;, &#39;!&#39;): 192, (&#39;A&#39;, &quot;&#39;&quot;): 193, (&#39;A&#39;, &#39;&gt;&#39;): 194, (&#39;A&#39;, &#39;?&#39;</span>
<span class="gd">-    ): 195, (&#39;A&#39;, &#39;:&#39;): 196, (&#39;A&#39;, &#39;A&#39;): 197, (&#39;A&#39;, &#39;E&#39;): 198, (&#39;C&#39;, &#39;,&#39;): </span>
<span class="gd">-    199, (&#39;E&#39;, &#39;!&#39;): 200, (&#39;E&#39;, &quot;&#39;&quot;): 201, (&#39;E&#39;, &#39;&gt;&#39;): 202, (&#39;E&#39;, &#39;:&#39;): 203,</span>
<span class="gd">-    (&#39;I&#39;, &#39;!&#39;): 204, (&#39;I&#39;, &quot;&#39;&quot;): 205, (&#39;I&#39;, &#39;&gt;&#39;): 206, (&#39;I&#39;, &#39;:&#39;): 207, (</span>
<span class="gd">-    &#39;D&#39;, &#39;-&#39;): 208, (&#39;N&#39;, &#39;?&#39;): 209, (&#39;O&#39;, &#39;!&#39;): 210, (&#39;O&#39;, &quot;&#39;&quot;): 211, (&#39;O&#39;,</span>
<span class="gd">-    &#39;&gt;&#39;): 212, (&#39;O&#39;, &#39;?&#39;): 213, (&#39;O&#39;, &#39;:&#39;): 214, (&#39;*&#39;, &#39;X&#39;): 215, (&#39;O&#39;, &#39;/&#39;</span>
<span class="gd">-    ): 216, (&#39;U&#39;, &#39;!&#39;): 217, (&#39;U&#39;, &quot;&#39;&quot;): 218, (&#39;U&#39;, &#39;&gt;&#39;): 219, (&#39;U&#39;, &#39;:&#39;): </span>
<span class="gd">-    220, (&#39;Y&#39;, &quot;&#39;&quot;): 221, (&#39;T&#39;, &#39;H&#39;): 222, (&#39;s&#39;, &#39;s&#39;): 223, (&#39;a&#39;, &#39;!&#39;): 224,</span>
<span class="gd">-    (&#39;a&#39;, &quot;&#39;&quot;): 225, (&#39;a&#39;, &#39;&gt;&#39;): 226, (&#39;a&#39;, &#39;?&#39;): 227, (&#39;a&#39;, &#39;:&#39;): 228, (</span>
<span class="gd">-    &#39;a&#39;, &#39;a&#39;): 229, (&#39;a&#39;, &#39;e&#39;): 230, (&#39;c&#39;, &#39;,&#39;): 231, (&#39;e&#39;, &#39;!&#39;): 232, (&#39;e&#39;,</span>
<span class="gd">-    &quot;&#39;&quot;): 233, (&#39;e&#39;, &#39;&gt;&#39;): 234, (&#39;e&#39;, &#39;:&#39;): 235, (&#39;i&#39;, &#39;!&#39;): 236, (&#39;i&#39;, &quot;&#39;&quot;</span>
<span class="gd">-    ): 237, (&#39;i&#39;, &#39;&gt;&#39;): 238, (&#39;i&#39;, &#39;:&#39;): 239, (&#39;d&#39;, &#39;-&#39;): 240, (&#39;n&#39;, &#39;?&#39;): </span>
<span class="gd">-    241, (&#39;o&#39;, &#39;!&#39;): 242, (&#39;o&#39;, &quot;&#39;&quot;): 243, (&#39;o&#39;, &#39;&gt;&#39;): 244, (&#39;o&#39;, &#39;?&#39;): 245,</span>
<span class="gd">-    (&#39;o&#39;, &#39;:&#39;): 246, (&#39;-&#39;, &#39;:&#39;): 247, (&#39;o&#39;, &#39;/&#39;): 248, (&#39;u&#39;, &#39;!&#39;): 249, (</span>
<span class="gd">-    &#39;u&#39;, &quot;&#39;&quot;): 250, (&#39;u&#39;, &#39;&gt;&#39;): 251, (&#39;u&#39;, &#39;:&#39;): 252, (&#39;y&#39;, &quot;&#39;&quot;): 253, (&#39;t&#39;,</span>
<span class="gd">-    &#39;h&#39;): 254, (&#39;y&#39;, &#39;:&#39;): 255, (&#39;A&#39;, &#39;-&#39;): 256, (&#39;a&#39;, &#39;-&#39;): 257, (&#39;A&#39;, &#39;(&#39;</span>
<span class="gd">-    ): 258, (&#39;a&#39;, &#39;(&#39;): 259, (&#39;A&#39;, &#39;;&#39;): 260, (&#39;a&#39;, &#39;;&#39;): 261, (&#39;C&#39;, &quot;&#39;&quot;): </span>
<span class="gd">-    262, (&#39;c&#39;, &quot;&#39;&quot;): 263, (&#39;C&#39;, &#39;&gt;&#39;): 264, (&#39;c&#39;, &#39;&gt;&#39;): 265, (&#39;C&#39;, &#39;.&#39;): 266,</span>
<span class="gd">-    (&#39;c&#39;, &#39;.&#39;): 267, (&#39;C&#39;, &#39;&lt;&#39;): 268, (&#39;c&#39;, &#39;&lt;&#39;): 269, (&#39;D&#39;, &#39;&lt;&#39;): 270, (</span>
<span class="gd">-    &#39;d&#39;, &#39;&lt;&#39;): 271, (&#39;D&#39;, &#39;/&#39;): 272, (&#39;d&#39;, &#39;/&#39;): 273, (&#39;E&#39;, &#39;-&#39;): 274, (&#39;e&#39;,</span>
<span class="gd">-    &#39;-&#39;): 275, (&#39;E&#39;, &#39;(&#39;): 276, (&#39;e&#39;, &#39;(&#39;): 277, (&#39;E&#39;, &#39;.&#39;): 278, (&#39;e&#39;, &#39;.&#39;</span>
<span class="gd">-    ): 279, (&#39;E&#39;, &#39;;&#39;): 280, (&#39;e&#39;, &#39;;&#39;): 281, (&#39;E&#39;, &#39;&lt;&#39;): 282, (&#39;e&#39;, &#39;&lt;&#39;): </span>
<span class="gd">-    283, (&#39;G&#39;, &#39;&gt;&#39;): 284, (&#39;g&#39;, &#39;&gt;&#39;): 285, (&#39;G&#39;, &#39;(&#39;): 286, (&#39;g&#39;, &#39;(&#39;): 287,</span>
<span class="gd">-    (&#39;G&#39;, &#39;.&#39;): 288, (&#39;g&#39;, &#39;.&#39;): 289, (&#39;G&#39;, &#39;,&#39;): 290, (&#39;g&#39;, &#39;,&#39;): 291, (</span>
<span class="gd">-    &#39;H&#39;, &#39;&gt;&#39;): 292, (&#39;h&#39;, &#39;&gt;&#39;): 293, (&#39;H&#39;, &#39;/&#39;): 294, (&#39;h&#39;, &#39;/&#39;): 295, (&#39;I&#39;,</span>
<span class="gd">-    &#39;?&#39;): 296, (&#39;i&#39;, &#39;?&#39;): 297, (&#39;I&#39;, &#39;-&#39;): 298, (&#39;i&#39;, &#39;-&#39;): 299, (&#39;I&#39;, &#39;(&#39;</span>
<span class="gd">-    ): 300, (&#39;i&#39;, &#39;(&#39;): 301, (&#39;I&#39;, &#39;;&#39;): 302, (&#39;i&#39;, &#39;;&#39;): 303, (&#39;I&#39;, &#39;.&#39;): </span>
<span class="gd">-    304, (&#39;i&#39;, &#39;.&#39;): 305, (&#39;I&#39;, &#39;J&#39;): 306, (&#39;i&#39;, &#39;j&#39;): 307, (&#39;J&#39;, &#39;&gt;&#39;): 308,</span>
<span class="gd">-    (&#39;j&#39;, &#39;&gt;&#39;): 309, (&#39;K&#39;, &#39;,&#39;): 310, (&#39;k&#39;, &#39;,&#39;): 311, (&#39;k&#39;, &#39;k&#39;): 312, (</span>
<span class="gd">-    &#39;L&#39;, &quot;&#39;&quot;): 313, (&#39;l&#39;, &quot;&#39;&quot;): 314, (&#39;L&#39;, &#39;,&#39;): 315, (&#39;l&#39;, &#39;,&#39;): 316, (&#39;L&#39;,</span>
<span class="gd">-    &#39;&lt;&#39;): 317, (&#39;l&#39;, &#39;&lt;&#39;): 318, (&#39;L&#39;, &#39;.&#39;): 319, (&#39;l&#39;, &#39;.&#39;): 320, (&#39;L&#39;, &#39;/&#39;</span>
<span class="gd">-    ): 321, (&#39;l&#39;, &#39;/&#39;): 322, (&#39;N&#39;, &quot;&#39;&quot;): 323, (&#39;n&#39;, &quot;&#39;&quot;): 324, (&#39;N&#39;, &#39;,&#39;): </span>
<span class="gd">-    325, (&#39;n&#39;, &#39;,&#39;): 326, (&#39;N&#39;, &#39;&lt;&#39;): 327, (&#39;n&#39;, &#39;&lt;&#39;): 328, (&quot;&#39;&quot;, &#39;n&#39;): 329,</span>
<span class="gd">-    (&#39;N&#39;, &#39;G&#39;): 330, (&#39;n&#39;, &#39;g&#39;): 331, (&#39;O&#39;, &#39;-&#39;): 332, (&#39;o&#39;, &#39;-&#39;): 333, (</span>
<span class="gd">-    &#39;O&#39;, &#39;(&#39;): 334, (&#39;o&#39;, &#39;(&#39;): 335, (&#39;O&#39;, &#39;&quot;&#39;): 336, (&#39;o&#39;, &#39;&quot;&#39;): 337, (&#39;O&#39;,</span>
<span class="gd">-    &#39;E&#39;): 338, (&#39;o&#39;, &#39;e&#39;): 339, (&#39;R&#39;, &quot;&#39;&quot;): 340, (&#39;r&#39;, &quot;&#39;&quot;): 341, (&#39;R&#39;, &#39;,&#39;</span>
<span class="gd">-    ): 342, (&#39;r&#39;, &#39;,&#39;): 343, (&#39;R&#39;, &#39;&lt;&#39;): 344, (&#39;r&#39;, &#39;&lt;&#39;): 345, (&#39;S&#39;, &quot;&#39;&quot;): </span>
<span class="gd">-    346, (&#39;s&#39;, &quot;&#39;&quot;): 347, (&#39;S&#39;, &#39;&gt;&#39;): 348, (&#39;s&#39;, &#39;&gt;&#39;): 349, (&#39;S&#39;, &#39;,&#39;): 350,</span>
<span class="gd">-    (&#39;s&#39;, &#39;,&#39;): 351, (&#39;S&#39;, &#39;&lt;&#39;): 352, (&#39;s&#39;, &#39;&lt;&#39;): 353, (&#39;T&#39;, &#39;,&#39;): 354, (</span>
<span class="gd">-    &#39;t&#39;, &#39;,&#39;): 355, (&#39;T&#39;, &#39;&lt;&#39;): 356, (&#39;t&#39;, &#39;&lt;&#39;): 357, (&#39;T&#39;, &#39;/&#39;): 358, (&#39;t&#39;,</span>
<span class="gd">-    &#39;/&#39;): 359, (&#39;U&#39;, &#39;?&#39;): 360, (&#39;u&#39;, &#39;?&#39;): 361, (&#39;U&#39;, &#39;-&#39;): 362, (&#39;u&#39;, &#39;-&#39;</span>
<span class="gd">-    ): 363, (&#39;U&#39;, &#39;(&#39;): 364, (&#39;u&#39;, &#39;(&#39;): 365, (&#39;U&#39;, &#39;0&#39;): 366, (&#39;u&#39;, &#39;0&#39;): </span>
<span class="gd">-    367, (&#39;U&#39;, &#39;&quot;&#39;): 368, (&#39;u&#39;, &#39;&quot;&#39;): 369, (&#39;U&#39;, &#39;;&#39;): 370, (&#39;u&#39;, &#39;;&#39;): 371,</span>
<span class="gd">-    (&#39;W&#39;, &#39;&gt;&#39;): 372, (&#39;w&#39;, &#39;&gt;&#39;): 373, (&#39;Y&#39;, &#39;&gt;&#39;): 374, (&#39;y&#39;, &#39;&gt;&#39;): 375, (</span>
<span class="gd">-    &#39;Y&#39;, &#39;:&#39;): 376, (&#39;Z&#39;, &quot;&#39;&quot;): 377, (&#39;z&#39;, &quot;&#39;&quot;): 378, (&#39;Z&#39;, &#39;.&#39;): 379, (&#39;z&#39;,</span>
<span class="gd">-    &#39;.&#39;): 380, (&#39;Z&#39;, &#39;&lt;&#39;): 381, (&#39;z&#39;, &#39;&lt;&#39;): 382, (&#39;O&#39;, &#39;9&#39;): 416, (&#39;o&#39;, &#39;9&#39;</span>
<span class="gd">-    ): 417, (&#39;O&#39;, &#39;I&#39;): 418, (&#39;o&#39;, &#39;i&#39;): 419, (&#39;y&#39;, &#39;r&#39;): 422, (&#39;U&#39;, &#39;9&#39;): </span>
<span class="gd">-    431, (&#39;u&#39;, &#39;9&#39;): 432, (&#39;Z&#39;, &#39;/&#39;): 437, (&#39;z&#39;, &#39;/&#39;): 438, (&#39;E&#39;, &#39;D&#39;): 439,</span>
<span class="gd">-    (&#39;A&#39;, &#39;&lt;&#39;): 461, (&#39;a&#39;, &#39;&lt;&#39;): 462, (&#39;I&#39;, &#39;&lt;&#39;): 463, (&#39;i&#39;, &#39;&lt;&#39;): 464, (</span>
<span class="gd">-    &#39;O&#39;, &#39;&lt;&#39;): 465, (&#39;o&#39;, &#39;&lt;&#39;): 466, (&#39;U&#39;, &#39;&lt;&#39;): 467, (&#39;u&#39;, &#39;&lt;&#39;): 468, (&#39;A&#39;,</span>
<span class="gd">-    &#39;1&#39;): 478, (&#39;a&#39;, &#39;1&#39;): 479, (&#39;A&#39;, &#39;7&#39;): 480, (&#39;a&#39;, &#39;7&#39;): 481, (&#39;A&#39;, &#39;3&#39;</span>
<span class="gd">-    ): 482, (&#39;a&#39;, &#39;3&#39;): 483, (&#39;G&#39;, &#39;/&#39;): 484, (&#39;g&#39;, &#39;/&#39;): 485, (&#39;G&#39;, &#39;&lt;&#39;): </span>
<span class="gd">-    486, (&#39;g&#39;, &#39;&lt;&#39;): 487, (&#39;K&#39;, &#39;&lt;&#39;): 488, (&#39;k&#39;, &#39;&lt;&#39;): 489, (&#39;O&#39;, &#39;;&#39;): 490,</span>
<span class="gd">-    (&#39;o&#39;, &#39;;&#39;): 491, (&#39;O&#39;, &#39;1&#39;): 492, (&#39;o&#39;, &#39;1&#39;): 493, (&#39;E&#39;, &#39;Z&#39;): 494, (</span>
<span class="gd">-    &#39;e&#39;, &#39;z&#39;): 495, (&#39;j&#39;, &#39;&lt;&#39;): 496, (&#39;G&#39;, &quot;&#39;&quot;): 500, (&#39;g&#39;, &quot;&#39;&quot;): 501, (&#39;;&#39;,</span>
<span class="gd">-    &#39;S&#39;): 703, (&quot;&#39;&quot;, &#39;&lt;&#39;): 711, (&quot;&#39;&quot;, &#39;(&#39;): 728, (&quot;&#39;&quot;, &#39;.&#39;): 729, (&quot;&#39;&quot;, &#39;0&#39;</span>
<span class="gd">-    ): 730, (&quot;&#39;&quot;, &#39;;&#39;): 731, (&quot;&#39;&quot;, &#39;&quot;&#39;): 733, (&#39;A&#39;, &#39;%&#39;): 902, (&#39;E&#39;, &#39;%&#39;): </span>
<span class="gd">-    904, (&#39;Y&#39;, &#39;%&#39;): 905, (&#39;I&#39;, &#39;%&#39;): 906, (&#39;O&#39;, &#39;%&#39;): 908, (&#39;U&#39;, &#39;%&#39;): 910,</span>
<span class="gd">-    (&#39;W&#39;, &#39;%&#39;): 911, (&#39;i&#39;, &#39;3&#39;): 912, (&#39;A&#39;, &#39;*&#39;): 913, (&#39;B&#39;, &#39;*&#39;): 914, (</span>
<span class="gd">-    &#39;G&#39;, &#39;*&#39;): 915, (&#39;D&#39;, &#39;*&#39;): 916, (&#39;E&#39;, &#39;*&#39;): 917, (&#39;Z&#39;, &#39;*&#39;): 918, (&#39;Y&#39;,</span>
<span class="gd">-    &#39;*&#39;): 919, (&#39;H&#39;, &#39;*&#39;): 920, (&#39;I&#39;, &#39;*&#39;): 921, (&#39;K&#39;, &#39;*&#39;): 922, (&#39;L&#39;, &#39;*&#39;</span>
<span class="gd">-    ): 923, (&#39;M&#39;, &#39;*&#39;): 924, (&#39;N&#39;, &#39;*&#39;): 925, (&#39;C&#39;, &#39;*&#39;): 926, (&#39;O&#39;, &#39;*&#39;): </span>
<span class="gd">-    927, (&#39;P&#39;, &#39;*&#39;): 928, (&#39;R&#39;, &#39;*&#39;): 929, (&#39;S&#39;, &#39;*&#39;): 931, (&#39;T&#39;, &#39;*&#39;): 932,</span>
<span class="gd">-    (&#39;U&#39;, &#39;*&#39;): 933, (&#39;F&#39;, &#39;*&#39;): 934, (&#39;X&#39;, &#39;*&#39;): 935, (&#39;Q&#39;, &#39;*&#39;): 936, (</span>
<span class="gd">-    &#39;W&#39;, &#39;*&#39;): 937, (&#39;J&#39;, &#39;*&#39;): 938, (&#39;V&#39;, &#39;*&#39;): 939, (&#39;a&#39;, &#39;%&#39;): 940, (&#39;e&#39;,</span>
<span class="gd">-    &#39;%&#39;): 941, (&#39;y&#39;, &#39;%&#39;): 942, (&#39;i&#39;, &#39;%&#39;): 943, (&#39;u&#39;, &#39;3&#39;): 944, (&#39;a&#39;, &#39;*&#39;</span>
<span class="gd">-    ): 945, (&#39;b&#39;, &#39;*&#39;): 946, (&#39;g&#39;, &#39;*&#39;): 947, (&#39;d&#39;, &#39;*&#39;): 948, (&#39;e&#39;, &#39;*&#39;): </span>
<span class="gd">-    949, (&#39;z&#39;, &#39;*&#39;): 950, (&#39;y&#39;, &#39;*&#39;): 951, (&#39;h&#39;, &#39;*&#39;): 952, (&#39;i&#39;, &#39;*&#39;): 953,</span>
<span class="gd">-    (&#39;k&#39;, &#39;*&#39;): 954, (&#39;l&#39;, &#39;*&#39;): 955, (&#39;m&#39;, &#39;*&#39;): 956, (&#39;n&#39;, &#39;*&#39;): 957, (</span>
<span class="gd">-    &#39;c&#39;, &#39;*&#39;): 958, (&#39;o&#39;, &#39;*&#39;): 959, (&#39;p&#39;, &#39;*&#39;): 960, (&#39;r&#39;, &#39;*&#39;): 961, (&#39;*&#39;,</span>
<span class="gd">-    &#39;s&#39;): 962, (&#39;s&#39;, &#39;*&#39;): 963, (&#39;t&#39;, &#39;*&#39;): 964, (&#39;u&#39;, &#39;*&#39;): 965, (&#39;f&#39;, &#39;*&#39;</span>
<span class="gd">-    ): 966, (&#39;x&#39;, &#39;*&#39;): 967, (&#39;q&#39;, &#39;*&#39;): 968, (&#39;w&#39;, &#39;*&#39;): 969, (&#39;j&#39;, &#39;*&#39;): </span>
<span class="gd">-    970, (&#39;v&#39;, &#39;*&#39;): 971, (&#39;o&#39;, &#39;%&#39;): 972, (&#39;u&#39;, &#39;%&#39;): 973, (&#39;w&#39;, &#39;%&#39;): 974,</span>
<span class="gd">-    (&quot;&#39;&quot;, &#39;G&#39;): 984, (&#39;,&#39;, &#39;G&#39;): 985, (&#39;T&#39;, &#39;3&#39;): 986, (&#39;t&#39;, &#39;3&#39;): 987, (</span>
<span class="gd">-    &#39;M&#39;, &#39;3&#39;): 988, (&#39;m&#39;, &#39;3&#39;): 989, (&#39;K&#39;, &#39;3&#39;): 990, (&#39;k&#39;, &#39;3&#39;): 991, (&#39;P&#39;,</span>
<span class="gd">-    &#39;3&#39;): 992, (&#39;p&#39;, &#39;3&#39;): 993, (&quot;&#39;&quot;, &#39;%&#39;): 1012, (&#39;j&#39;, &#39;3&#39;): 1013, (&#39;I&#39;,</span>
<span class="gd">-    &#39;O&#39;): 1025, (&#39;D&#39;, &#39;%&#39;): 1026, (&#39;G&#39;, &#39;%&#39;): 1027, (&#39;I&#39;, &#39;E&#39;): 1028, (&#39;D&#39;,</span>
<span class="gd">-    &#39;S&#39;): 1029, (&#39;I&#39;, &#39;I&#39;): 1030, (&#39;Y&#39;, &#39;I&#39;): 1031, (&#39;J&#39;, &#39;%&#39;): 1032, (&#39;L&#39;,</span>
<span class="gd">-    &#39;J&#39;): 1033, (&#39;N&#39;, &#39;J&#39;): 1034, (&#39;T&#39;, &#39;s&#39;): 1035, (&#39;K&#39;, &#39;J&#39;): 1036, (&#39;V&#39;,</span>
<span class="gd">-    &#39;%&#39;): 1038, (&#39;D&#39;, &#39;Z&#39;): 1039, (&#39;A&#39;, &#39;=&#39;): 1040, (&#39;B&#39;, &#39;=&#39;): 1041, (&#39;V&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1042, (&#39;G&#39;, &#39;=&#39;): 1043, (&#39;D&#39;, &#39;=&#39;): 1044, (&#39;E&#39;, &#39;=&#39;): 1045, (&#39;Z&#39;,</span>
<span class="gd">-    &#39;%&#39;): 1046, (&#39;Z&#39;, &#39;=&#39;): 1047, (&#39;I&#39;, &#39;=&#39;): 1048, (&#39;J&#39;, &#39;=&#39;): 1049, (&#39;K&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1050, (&#39;L&#39;, &#39;=&#39;): 1051, (&#39;M&#39;, &#39;=&#39;): 1052, (&#39;N&#39;, &#39;=&#39;): 1053, (&#39;O&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1054, (&#39;P&#39;, &#39;=&#39;): 1055, (&#39;R&#39;, &#39;=&#39;): 1056, (&#39;S&#39;, &#39;=&#39;): 1057, (&#39;T&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1058, (&#39;U&#39;, &#39;=&#39;): 1059, (&#39;F&#39;, &#39;=&#39;): 1060, (&#39;H&#39;, &#39;=&#39;): 1061, (&#39;C&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1062, (&#39;C&#39;, &#39;%&#39;): 1063, (&#39;S&#39;, &#39;%&#39;): 1064, (&#39;S&#39;, &#39;c&#39;): 1065, (&#39;=&#39;,</span>
<span class="gd">-    &#39;&quot;&#39;): 1066, (&#39;Y&#39;, &#39;=&#39;): 1067, (&#39;%&#39;, &#39;&quot;&#39;): 1068, (&#39;J&#39;, &#39;E&#39;): 1069, (&#39;J&#39;,</span>
<span class="gd">-    &#39;U&#39;): 1070, (&#39;J&#39;, &#39;A&#39;): 1071, (&#39;a&#39;, &#39;=&#39;): 1072, (&#39;b&#39;, &#39;=&#39;): 1073, (&#39;v&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1074, (&#39;g&#39;, &#39;=&#39;): 1075, (&#39;d&#39;, &#39;=&#39;): 1076, (&#39;e&#39;, &#39;=&#39;): 1077, (&#39;z&#39;,</span>
<span class="gd">-    &#39;%&#39;): 1078, (&#39;z&#39;, &#39;=&#39;): 1079, (&#39;i&#39;, &#39;=&#39;): 1080, (&#39;j&#39;, &#39;=&#39;): 1081, (&#39;k&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1082, (&#39;l&#39;, &#39;=&#39;): 1083, (&#39;m&#39;, &#39;=&#39;): 1084, (&#39;n&#39;, &#39;=&#39;): 1085, (&#39;o&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1086, (&#39;p&#39;, &#39;=&#39;): 1087, (&#39;r&#39;, &#39;=&#39;): 1088, (&#39;s&#39;, &#39;=&#39;): 1089, (&#39;t&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1090, (&#39;u&#39;, &#39;=&#39;): 1091, (&#39;f&#39;, &#39;=&#39;): 1092, (&#39;h&#39;, &#39;=&#39;): 1093, (&#39;c&#39;,</span>
<span class="gd">-    &#39;=&#39;): 1094, (&#39;c&#39;, &#39;%&#39;): 1095, (&#39;s&#39;, &#39;%&#39;): 1096, (&#39;s&#39;, &#39;c&#39;): 1097, (&#39;=&#39;,</span>
<span class="gd">-    &quot;&#39;&quot;): 1098, (&#39;y&#39;, &#39;=&#39;): 1099, (&#39;%&#39;, &quot;&#39;&quot;): 1100, (&#39;j&#39;, &#39;e&#39;): 1101, (&#39;j&#39;,</span>
<span class="gd">-    &#39;u&#39;): 1102, (&#39;j&#39;, &#39;a&#39;): 1103, (&#39;i&#39;, &#39;o&#39;): 1105, (&#39;d&#39;, &#39;%&#39;): 1106, (&#39;g&#39;,</span>
<span class="gd">-    &#39;%&#39;): 1107, (&#39;i&#39;, &#39;e&#39;): 1108, (&#39;d&#39;, &#39;s&#39;): 1109, (&#39;i&#39;, &#39;i&#39;): 1110, (&#39;y&#39;,</span>
<span class="gd">-    &#39;i&#39;): 1111, (&#39;j&#39;, &#39;%&#39;): 1112, (&#39;l&#39;, &#39;j&#39;): 1113, (&#39;n&#39;, &#39;j&#39;): 1114, (&#39;t&#39;,</span>
<span class="gd">-    &#39;s&#39;): 1115, (&#39;k&#39;, &#39;j&#39;): 1116, (&#39;v&#39;, &#39;%&#39;): 1118, (&#39;d&#39;, &#39;z&#39;): 1119, (&#39;Y&#39;,</span>
<span class="gd">-    &#39;3&#39;): 1122, (&#39;y&#39;, &#39;3&#39;): 1123, (&#39;O&#39;, &#39;3&#39;): 1130, (&#39;o&#39;, &#39;3&#39;): 1131, (&#39;F&#39;,</span>
<span class="gd">-    &#39;3&#39;): 1138, (&#39;f&#39;, &#39;3&#39;): 1139, (&#39;V&#39;, &#39;3&#39;): 1140, (&#39;v&#39;, &#39;3&#39;): 1141, (&#39;C&#39;,</span>
<span class="gd">-    &#39;3&#39;): 1152, (&#39;c&#39;, &#39;3&#39;): 1153, (&#39;G&#39;, &#39;3&#39;): 1168, (&#39;g&#39;, &#39;3&#39;): 1169, (&#39;A&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1488, (&#39;B&#39;, &#39;+&#39;): 1489, (&#39;G&#39;, &#39;+&#39;): 1490, (&#39;D&#39;, &#39;+&#39;): 1491, (&#39;H&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1492, (&#39;W&#39;, &#39;+&#39;): 1493, (&#39;Z&#39;, &#39;+&#39;): 1494, (&#39;X&#39;, &#39;+&#39;): 1495, (&#39;T&#39;,</span>
<span class="gd">-    &#39;j&#39;): 1496, (&#39;J&#39;, &#39;+&#39;): 1497, (&#39;K&#39;, &#39;%&#39;): 1498, (&#39;K&#39;, &#39;+&#39;): 1499, (&#39;L&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1500, (&#39;M&#39;, &#39;%&#39;): 1501, (&#39;M&#39;, &#39;+&#39;): 1502, (&#39;N&#39;, &#39;%&#39;): 1503, (&#39;N&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1504, (&#39;S&#39;, &#39;+&#39;): 1505, (&#39;E&#39;, &#39;+&#39;): 1506, (&#39;P&#39;, &#39;%&#39;): 1507, (&#39;P&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1508, (&#39;Z&#39;, &#39;j&#39;): 1509, (&#39;Z&#39;, &#39;J&#39;): 1510, (&#39;Q&#39;, &#39;+&#39;): 1511, (&#39;R&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1512, (&#39;S&#39;, &#39;h&#39;): 1513, (&#39;T&#39;, &#39;+&#39;): 1514, (&#39;,&#39;, &#39;+&#39;): 1548, (&#39;;&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1563, (&#39;?&#39;, &#39;+&#39;): 1567, (&#39;H&#39;, &quot;&#39;&quot;): 1569, (&#39;a&#39;, &#39;M&#39;): 1570, (&#39;a&#39;,</span>
<span class="gd">-    &#39;H&#39;): 1571, (&#39;w&#39;, &#39;H&#39;): 1572, (&#39;a&#39;, &#39;h&#39;): 1573, (&#39;y&#39;, &#39;H&#39;): 1574, (&#39;a&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1575, (&#39;b&#39;, &#39;+&#39;): 1576, (&#39;t&#39;, &#39;m&#39;): 1577, (&#39;t&#39;, &#39;+&#39;): 1578, (&#39;t&#39;,</span>
<span class="gd">-    &#39;k&#39;): 1579, (&#39;g&#39;, &#39;+&#39;): 1580, (&#39;h&#39;, &#39;k&#39;): 1581, (&#39;x&#39;, &#39;+&#39;): 1582, (&#39;d&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1583, (&#39;d&#39;, &#39;k&#39;): 1584, (&#39;r&#39;, &#39;+&#39;): 1585, (&#39;z&#39;, &#39;+&#39;): 1586, (&#39;s&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1587, (&#39;s&#39;, &#39;n&#39;): 1588, (&#39;c&#39;, &#39;+&#39;): 1589, (&#39;d&#39;, &#39;d&#39;): 1590, (&#39;t&#39;,</span>
<span class="gd">-    &#39;j&#39;): 1591, (&#39;z&#39;, &#39;H&#39;): 1592, (&#39;e&#39;, &#39;+&#39;): 1593, (&#39;i&#39;, &#39;+&#39;): 1594, (&#39;+&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1600, (&#39;f&#39;, &#39;+&#39;): 1601, (&#39;q&#39;, &#39;+&#39;): 1602, (&#39;k&#39;, &#39;+&#39;): 1603, (&#39;l&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1604, (&#39;m&#39;, &#39;+&#39;): 1605, (&#39;n&#39;, &#39;+&#39;): 1606, (&#39;h&#39;, &#39;+&#39;): 1607, (&#39;w&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1608, (&#39;j&#39;, &#39;+&#39;): 1609, (&#39;y&#39;, &#39;+&#39;): 1610, (&#39;:&#39;, &#39;+&#39;): 1611, (&#39;&quot;&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1612, (&#39;=&#39;, &#39;+&#39;): 1613, (&#39;/&#39;, &#39;+&#39;): 1614, (&quot;&#39;&quot;, &#39;+&#39;): 1615, (&#39;1&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1616, (&#39;3&#39;, &#39;+&#39;): 1617, (&#39;0&#39;, &#39;+&#39;): 1618, (&#39;a&#39;, &#39;S&#39;): 1648, (&#39;p&#39;,</span>
<span class="gd">-    &#39;+&#39;): 1662, (&#39;v&#39;, &#39;+&#39;): 1700, (&#39;g&#39;, &#39;f&#39;): 1711, (&#39;0&#39;, &#39;a&#39;): 1776, (&#39;1&#39;,</span>
<span class="gd">-    &#39;a&#39;): 1777, (&#39;2&#39;, &#39;a&#39;): 1778, (&#39;3&#39;, &#39;a&#39;): 1779, (&#39;4&#39;, &#39;a&#39;): 1780, (&#39;5&#39;,</span>
<span class="gd">-    &#39;a&#39;): 1781, (&#39;6&#39;, &#39;a&#39;): 1782, (&#39;7&#39;, &#39;a&#39;): 1783, (&#39;8&#39;, &#39;a&#39;): 1784, (&#39;9&#39;,</span>
<span class="gd">-    &#39;a&#39;): 1785, (&#39;B&#39;, &#39;.&#39;): 7682, (&#39;b&#39;, &#39;.&#39;): 7683, (&#39;B&#39;, &#39;_&#39;): 7686, (&#39;b&#39;,</span>
<span class="gd">-    &#39;_&#39;): 7687, (&#39;D&#39;, &#39;.&#39;): 7690, (&#39;d&#39;, &#39;.&#39;): 7691, (&#39;D&#39;, &#39;_&#39;): 7694, (&#39;d&#39;,</span>
<span class="gd">-    &#39;_&#39;): 7695, (&#39;D&#39;, &#39;,&#39;): 7696, (&#39;d&#39;, &#39;,&#39;): 7697, (&#39;F&#39;, &#39;.&#39;): 7710, (&#39;f&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7711, (&#39;G&#39;, &#39;-&#39;): 7712, (&#39;g&#39;, &#39;-&#39;): 7713, (&#39;H&#39;, &#39;.&#39;): 7714, (&#39;h&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7715, (&#39;H&#39;, &#39;:&#39;): 7718, (&#39;h&#39;, &#39;:&#39;): 7719, (&#39;H&#39;, &#39;,&#39;): 7720, (&#39;h&#39;,</span>
<span class="gd">-    &#39;,&#39;): 7721, (&#39;K&#39;, &quot;&#39;&quot;): 7728, (&#39;k&#39;, &quot;&#39;&quot;): 7729, (&#39;K&#39;, &#39;_&#39;): 7732, (&#39;k&#39;,</span>
<span class="gd">-    &#39;_&#39;): 7733, (&#39;L&#39;, &#39;_&#39;): 7738, (&#39;l&#39;, &#39;_&#39;): 7739, (&#39;M&#39;, &quot;&#39;&quot;): 7742, (&#39;m&#39;,</span>
<span class="gd">-    &quot;&#39;&quot;): 7743, (&#39;M&#39;, &#39;.&#39;): 7744, (&#39;m&#39;, &#39;.&#39;): 7745, (&#39;N&#39;, &#39;.&#39;): 7748, (&#39;n&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7749, (&#39;N&#39;, &#39;_&#39;): 7752, (&#39;n&#39;, &#39;_&#39;): 7753, (&#39;P&#39;, &quot;&#39;&quot;): 7764, (&#39;p&#39;,</span>
<span class="gd">-    &quot;&#39;&quot;): 7765, (&#39;P&#39;, &#39;.&#39;): 7766, (&#39;p&#39;, &#39;.&#39;): 7767, (&#39;R&#39;, &#39;.&#39;): 7768, (&#39;r&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7769, (&#39;R&#39;, &#39;_&#39;): 7774, (&#39;r&#39;, &#39;_&#39;): 7775, (&#39;S&#39;, &#39;.&#39;): 7776, (&#39;s&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7777, (&#39;T&#39;, &#39;.&#39;): 7786, (&#39;t&#39;, &#39;.&#39;): 7787, (&#39;T&#39;, &#39;_&#39;): 7790, (&#39;t&#39;,</span>
<span class="gd">-    &#39;_&#39;): 7791, (&#39;V&#39;, &#39;?&#39;): 7804, (&#39;v&#39;, &#39;?&#39;): 7805, (&#39;W&#39;, &#39;!&#39;): 7808, (&#39;w&#39;,</span>
<span class="gd">-    &#39;!&#39;): 7809, (&#39;W&#39;, &quot;&#39;&quot;): 7810, (&#39;w&#39;, &quot;&#39;&quot;): 7811, (&#39;W&#39;, &#39;:&#39;): 7812, (&#39;w&#39;,</span>
<span class="gd">-    &#39;:&#39;): 7813, (&#39;W&#39;, &#39;.&#39;): 7814, (&#39;w&#39;, &#39;.&#39;): 7815, (&#39;X&#39;, &#39;.&#39;): 7818, (&#39;x&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7819, (&#39;X&#39;, &#39;:&#39;): 7820, (&#39;x&#39;, &#39;:&#39;): 7821, (&#39;Y&#39;, &#39;.&#39;): 7822, (&#39;y&#39;,</span>
<span class="gd">-    &#39;.&#39;): 7823, (&#39;Z&#39;, &#39;&gt;&#39;): 7824, (&#39;z&#39;, &#39;&gt;&#39;): 7825, (&#39;Z&#39;, &#39;_&#39;): 7828, (&#39;z&#39;,</span>
<span class="gd">-    &#39;_&#39;): 7829, (&#39;h&#39;, &#39;_&#39;): 7830, (&#39;t&#39;, &#39;:&#39;): 7831, (&#39;w&#39;, &#39;0&#39;): 7832, (&#39;y&#39;,</span>
<span class="gd">-    &#39;0&#39;): 7833, (&#39;A&#39;, &#39;2&#39;): 7842, (&#39;a&#39;, &#39;2&#39;): 7843, (&#39;E&#39;, &#39;2&#39;): 7866, (&#39;e&#39;,</span>
<span class="gd">-    &#39;2&#39;): 7867, (&#39;E&#39;, &#39;?&#39;): 7868, (&#39;e&#39;, &#39;?&#39;): 7869, (&#39;I&#39;, &#39;2&#39;): 7880, (&#39;i&#39;,</span>
<span class="gd">-    &#39;2&#39;): 7881, (&#39;O&#39;, &#39;2&#39;): 7886, (&#39;o&#39;, &#39;2&#39;): 7887, (&#39;U&#39;, &#39;2&#39;): 7910, (&#39;u&#39;,</span>
<span class="gd">-    &#39;2&#39;): 7911, (&#39;Y&#39;, &#39;!&#39;): 7922, (&#39;y&#39;, &#39;!&#39;): 7923, (&#39;Y&#39;, &#39;2&#39;): 7926, (&#39;y&#39;,</span>
<span class="gd">-    &#39;2&#39;): 7927, (&#39;Y&#39;, &#39;?&#39;): 7928, (&#39;y&#39;, &#39;?&#39;): 7929, (&#39;;&#39;, &quot;&#39;&quot;): 7936, (&#39;,&#39;,</span>
<span class="gd">-    &quot;&#39;&quot;): 7937, (&#39;;&#39;, &#39;!&#39;): 7938, (&#39;,&#39;, &#39;!&#39;): 7939, (&#39;?&#39;, &#39;;&#39;): 7940, (&#39;?&#39;,</span>
<span class="gd">-    &#39;,&#39;): 7941, (&#39;!&#39;, &#39;:&#39;): 7942, (&#39;?&#39;, &#39;:&#39;): 7943, (&#39;1&#39;, &#39;N&#39;): 8194, (&#39;1&#39;,</span>
<span class="gd">-    &#39;M&#39;): 8195, (&#39;3&#39;, &#39;M&#39;): 8196, (&#39;4&#39;, &#39;M&#39;): 8197, (&#39;6&#39;, &#39;M&#39;): 8198, (&#39;1&#39;,</span>
<span class="gd">-    &#39;T&#39;): 8201, (&#39;1&#39;, &#39;H&#39;): 8202, (&#39;-&#39;, &#39;1&#39;): 8208, (&#39;-&#39;, &#39;N&#39;): 8211, (&#39;-&#39;,</span>
<span class="gd">-    &#39;M&#39;): 8212, (&#39;-&#39;, &#39;3&#39;): 8213, (&#39;!&#39;, &#39;2&#39;): 8214, (&#39;=&#39;, &#39;2&#39;): 8215, (&quot;&#39;&quot;,</span>
<span class="gd">-    &#39;6&#39;): 8216, (&quot;&#39;&quot;, &#39;9&#39;): 8217, (&#39;.&#39;, &#39;9&#39;): 8218, (&#39;9&#39;, &quot;&#39;&quot;): 8219, (&#39;&quot;&#39;,</span>
<span class="gd">-    &#39;6&#39;): 8220, (&#39;&quot;&#39;, &#39;9&#39;): 8221, (&#39;:&#39;, &#39;9&#39;): 8222, (&#39;9&#39;, &#39;&quot;&#39;): 8223, (&#39;/&#39;,</span>
<span class="gd">-    &#39;-&#39;): 8224, (&#39;/&#39;, &#39;=&#39;): 8225, (&#39;.&#39;, &#39;.&#39;): 8229, (&#39;%&#39;, &#39;0&#39;): 8240, (&#39;1&#39;,</span>
<span class="gd">-    &quot;&#39;&quot;): 8242, (&#39;2&#39;, &quot;&#39;&quot;): 8243, (&#39;3&#39;, &quot;&#39;&quot;): 8244, (&#39;1&#39;, &#39;&quot;&#39;): 8245, (&#39;2&#39;,</span>
<span class="gd">-    &#39;&quot;&#39;): 8246, (&#39;3&#39;, &#39;&quot;&#39;): 8247, (&#39;C&#39;, &#39;a&#39;): 8248, (&#39;&lt;&#39;, &#39;1&#39;): 8249, (&#39;&gt;&#39;,</span>
<span class="gd">-    &#39;1&#39;): 8250, (&#39;:&#39;, &#39;X&#39;): 8251, (&quot;&#39;&quot;, &#39;-&#39;): 8254, (&#39;/&#39;, &#39;f&#39;): 8260, (&#39;0&#39;,</span>
<span class="gd">-    &#39;S&#39;): 8304, (&#39;4&#39;, &#39;S&#39;): 8308, (&#39;5&#39;, &#39;S&#39;): 8309, (&#39;6&#39;, &#39;S&#39;): 8310, (&#39;7&#39;,</span>
<span class="gd">-    &#39;S&#39;): 8311, (&#39;8&#39;, &#39;S&#39;): 8312, (&#39;9&#39;, &#39;S&#39;): 8313, (&#39;+&#39;, &#39;S&#39;): 8314, (&#39;-&#39;,</span>
<span class="gd">-    &#39;S&#39;): 8315, (&#39;=&#39;, &#39;S&#39;): 8316, (&#39;(&#39;, &#39;S&#39;): 8317, (&#39;)&#39;, &#39;S&#39;): 8318, (&#39;n&#39;,</span>
<span class="gd">-    &#39;S&#39;): 8319, (&#39;0&#39;, &#39;s&#39;): 8320, (&#39;1&#39;, &#39;s&#39;): 8321, (&#39;2&#39;, &#39;s&#39;): 8322, (&#39;3&#39;,</span>
<span class="gd">-    &#39;s&#39;): 8323, (&#39;4&#39;, &#39;s&#39;): 8324, (&#39;5&#39;, &#39;s&#39;): 8325, (&#39;6&#39;, &#39;s&#39;): 8326, (&#39;7&#39;,</span>
<span class="gd">-    &#39;s&#39;): 8327, (&#39;8&#39;, &#39;s&#39;): 8328, (&#39;9&#39;, &#39;s&#39;): 8329, (&#39;+&#39;, &#39;s&#39;): 8330, (&#39;-&#39;,</span>
<span class="gd">-    &#39;s&#39;): 8331, (&#39;=&#39;, &#39;s&#39;): 8332, (&#39;(&#39;, &#39;s&#39;): 8333, (&#39;)&#39;, &#39;s&#39;): 8334, (&#39;L&#39;,</span>
<span class="gd">-    &#39;i&#39;): 8356, (&#39;P&#39;, &#39;t&#39;): 8359, (&#39;W&#39;, &#39;=&#39;): 8361, (&#39;=&#39;, &#39;e&#39;): 8364, (&#39;E&#39;,</span>
<span class="gd">-    &#39;u&#39;): 8364, (&#39;=&#39;, &#39;R&#39;): 8381, (&#39;=&#39;, &#39;P&#39;): 8381, (&#39;o&#39;, &#39;C&#39;): 8451, (&#39;c&#39;,</span>
<span class="gd">-    &#39;o&#39;): 8453, (&#39;o&#39;, &#39;F&#39;): 8457, (&#39;N&#39;, &#39;0&#39;): 8470, (&#39;P&#39;, &#39;O&#39;): 8471, (&#39;R&#39;,</span>
<span class="gd">-    &#39;x&#39;): 8478, (&#39;S&#39;, &#39;M&#39;): 8480, (&#39;T&#39;, &#39;M&#39;): 8482, (&#39;O&#39;, &#39;m&#39;): 8486, (&#39;A&#39;,</span>
<span class="gd">-    &#39;O&#39;): 8491, (&#39;1&#39;, &#39;3&#39;): 8531, (&#39;2&#39;, &#39;3&#39;): 8532, (&#39;1&#39;, &#39;5&#39;): 8533, (&#39;2&#39;,</span>
<span class="gd">-    &#39;5&#39;): 8534, (&#39;3&#39;, &#39;5&#39;): 8535, (&#39;4&#39;, &#39;5&#39;): 8536, (&#39;1&#39;, &#39;6&#39;): 8537, (&#39;5&#39;,</span>
<span class="gd">-    &#39;6&#39;): 8538, (&#39;1&#39;, &#39;8&#39;): 8539, (&#39;3&#39;, &#39;8&#39;): 8540, (&#39;5&#39;, &#39;8&#39;): 8541, (&#39;7&#39;,</span>
<span class="gd">-    &#39;8&#39;): 8542, (&#39;1&#39;, &#39;R&#39;): 8544, (&#39;2&#39;, &#39;R&#39;): 8545, (&#39;3&#39;, &#39;R&#39;): 8546, (&#39;4&#39;,</span>
<span class="gd">-    &#39;R&#39;): 8547, (&#39;5&#39;, &#39;R&#39;): 8548, (&#39;6&#39;, &#39;R&#39;): 8549, (&#39;7&#39;, &#39;R&#39;): 8550, (&#39;8&#39;,</span>
<span class="gd">-    &#39;R&#39;): 8551, (&#39;9&#39;, &#39;R&#39;): 8552, (&#39;a&#39;, &#39;R&#39;): 8553, (&#39;b&#39;, &#39;R&#39;): 8554, (&#39;c&#39;,</span>
<span class="gd">-    &#39;R&#39;): 8555, (&#39;1&#39;, &#39;r&#39;): 8560, (&#39;2&#39;, &#39;r&#39;): 8561, (&#39;3&#39;, &#39;r&#39;): 8562, (&#39;4&#39;,</span>
<span class="gd">-    &#39;r&#39;): 8563, (&#39;5&#39;, &#39;r&#39;): 8564, (&#39;6&#39;, &#39;r&#39;): 8565, (&#39;7&#39;, &#39;r&#39;): 8566, (&#39;8&#39;,</span>
<span class="gd">-    &#39;r&#39;): 8567, (&#39;9&#39;, &#39;r&#39;): 8568, (&#39;a&#39;, &#39;r&#39;): 8569, (&#39;b&#39;, &#39;r&#39;): 8570, (&#39;c&#39;,</span>
<span class="gd">-    &#39;r&#39;): 8571, (&#39;&lt;&#39;, &#39;-&#39;): 8592, (&#39;-&#39;, &#39;!&#39;): 8593, (&#39;-&#39;, &#39;&gt;&#39;): 8594, (&#39;-&#39;,</span>
<span class="gd">-    &#39;v&#39;): 8595, (&#39;&lt;&#39;, &#39;&gt;&#39;): 8596, (&#39;U&#39;, &#39;D&#39;): 8597, (&#39;&lt;&#39;, &#39;=&#39;): 8656, (&#39;=&#39;,</span>
<span class="gd">-    &#39;&gt;&#39;): 8658, (&#39;=&#39;, &#39;=&#39;): 8660, (&#39;F&#39;, &#39;A&#39;): 8704, (&#39;d&#39;, &#39;P&#39;): 8706, (&#39;T&#39;,</span>
<span class="gd">-    &#39;E&#39;): 8707, (&#39;/&#39;, &#39;0&#39;): 8709, (&#39;D&#39;, &#39;E&#39;): 8710, (&#39;N&#39;, &#39;B&#39;): 8711, (&#39;(&#39;,</span>
<span class="gd">-    &#39;-&#39;): 8712, (&#39;-&#39;, &#39;)&#39;): 8715, (&#39;*&#39;, &#39;P&#39;): 8719, (&#39;+&#39;, &#39;Z&#39;): 8721, (&#39;-&#39;,</span>
<span class="gd">-    &#39;2&#39;): 8722, (&#39;-&#39;, &#39;+&#39;): 8723, (&#39;*&#39;, &#39;-&#39;): 8727, (&#39;O&#39;, &#39;b&#39;): 8728, (&#39;S&#39;,</span>
<span class="gd">-    &#39;b&#39;): 8729, (&#39;R&#39;, &#39;T&#39;): 8730, (&#39;0&#39;, &#39;(&#39;): 8733, (&#39;0&#39;, &#39;0&#39;): 8734, (&#39;-&#39;,</span>
<span class="gd">-    &#39;L&#39;): 8735, (&#39;-&#39;, &#39;V&#39;): 8736, (&#39;P&#39;, &#39;P&#39;): 8741, (&#39;A&#39;, &#39;N&#39;): 8743, (&#39;O&#39;,</span>
<span class="gd">-    &#39;R&#39;): 8744, (&#39;(&#39;, &#39;U&#39;): 8745, (&#39;)&#39;, &#39;U&#39;): 8746, (&#39;I&#39;, &#39;n&#39;): 8747, (&#39;D&#39;,</span>
<span class="gd">-    &#39;I&#39;): 8748, (&#39;I&#39;, &#39;o&#39;): 8750, (&#39;.&#39;, &#39;:&#39;): 8756, (&#39;:&#39;, &#39;.&#39;): 8757, (&#39;:&#39;,</span>
<span class="gd">-    &#39;R&#39;): 8758, (&#39;:&#39;, &#39;:&#39;): 8759, (&#39;?&#39;, &#39;1&#39;): 8764, (&#39;C&#39;, &#39;G&#39;): 8766, (&#39;?&#39;,</span>
<span class="gd">-    &#39;-&#39;): 8771, (&#39;?&#39;, &#39;=&#39;): 8773, (&#39;?&#39;, &#39;2&#39;): 8776, (&#39;=&#39;, &#39;?&#39;): 8780, (&#39;H&#39;,</span>
<span class="gd">-    &#39;I&#39;): 8787, (&#39;!&#39;, &#39;=&#39;): 8800, (&#39;=&#39;, &#39;3&#39;): 8801, (&#39;=&#39;, &#39;&lt;&#39;): 8804, (&#39;&gt;&#39;,</span>
<span class="gd">-    &#39;=&#39;): 8805, (&#39;&lt;&#39;, &#39;*&#39;): 8810, (&#39;*&#39;, &#39;&gt;&#39;): 8811, (&#39;!&#39;, &#39;&lt;&#39;): 8814, (&#39;!&#39;,</span>
<span class="gd">-    &#39;&gt;&#39;): 8815, (&#39;(&#39;, &#39;C&#39;): 8834, (&#39;)&#39;, &#39;C&#39;): 8835, (&#39;(&#39;, &#39;_&#39;): 8838, (&#39;)&#39;,</span>
<span class="gd">-    &#39;_&#39;): 8839, (&#39;0&#39;, &#39;.&#39;): 8857, (&#39;0&#39;, &#39;2&#39;): 8858, (&#39;-&#39;, &#39;T&#39;): 8869, (&#39;.&#39;,</span>
<span class="gd">-    &#39;P&#39;): 8901, (&#39;:&#39;, &#39;3&#39;): 8942, (&#39;.&#39;, &#39;3&#39;): 8943, (&#39;E&#39;, &#39;h&#39;): 8962, (&#39;&lt;&#39;,</span>
<span class="gd">-    &#39;7&#39;): 8968, (&#39;&gt;&#39;, &#39;7&#39;): 8969, (&#39;7&#39;, &#39;&lt;&#39;): 8970, (&#39;7&#39;, &#39;&gt;&#39;): 8971, (&#39;N&#39;,</span>
<span class="gd">-    &#39;I&#39;): 8976, (&#39;(&#39;, &#39;A&#39;): 8978, (&#39;T&#39;, &#39;R&#39;): 8981, (&#39;I&#39;, &#39;u&#39;): 8992, (&#39;I&#39;,</span>
<span class="gd">-    &#39;l&#39;): 8993, (&#39;&lt;&#39;, &#39;/&#39;): 9001, (&#39;/&#39;, &#39;&gt;&#39;): 9002, (&#39;V&#39;, &#39;s&#39;): 9251, (&#39;1&#39;,</span>
<span class="gd">-    &#39;h&#39;): 9280, (&#39;3&#39;, &#39;h&#39;): 9281, (&#39;2&#39;, &#39;h&#39;): 9282, (&#39;4&#39;, &#39;h&#39;): 9283, (&#39;1&#39;,</span>
<span class="gd">-    &#39;j&#39;): 9286, (&#39;2&#39;, &#39;j&#39;): 9287, (&#39;3&#39;, &#39;j&#39;): 9288, (&#39;4&#39;, &#39;j&#39;): 9289, (&#39;1&#39;,</span>
<span class="gd">-    &#39;.&#39;): 9352, (&#39;2&#39;, &#39;.&#39;): 9353, (&#39;3&#39;, &#39;.&#39;): 9354, (&#39;4&#39;, &#39;.&#39;): 9355, (&#39;5&#39;,</span>
<span class="gd">-    &#39;.&#39;): 9356, (&#39;6&#39;, &#39;.&#39;): 9357, (&#39;7&#39;, &#39;.&#39;): 9358, (&#39;8&#39;, &#39;.&#39;): 9359, (&#39;9&#39;,</span>
<span class="gd">-    &#39;.&#39;): 9360, (&#39;h&#39;, &#39;h&#39;): 9472, (&#39;H&#39;, &#39;H&#39;): 9473, (&#39;v&#39;, &#39;v&#39;): 9474, (&#39;V&#39;,</span>
<span class="gd">-    &#39;V&#39;): 9475, (&#39;3&#39;, &#39;-&#39;): 9476, (&#39;3&#39;, &#39;_&#39;): 9477, (&#39;3&#39;, &#39;!&#39;): 9478, (&#39;3&#39;,</span>
<span class="gd">-    &#39;/&#39;): 9479, (&#39;4&#39;, &#39;-&#39;): 9480, (&#39;4&#39;, &#39;_&#39;): 9481, (&#39;4&#39;, &#39;!&#39;): 9482, (&#39;4&#39;,</span>
<span class="gd">-    &#39;/&#39;): 9483, (&#39;d&#39;, &#39;r&#39;): 9484, (&#39;d&#39;, &#39;R&#39;): 9485, (&#39;D&#39;, &#39;r&#39;): 9486, (&#39;D&#39;,</span>
<span class="gd">-    &#39;R&#39;): 9487, (&#39;d&#39;, &#39;l&#39;): 9488, (&#39;d&#39;, &#39;L&#39;): 9489, (&#39;D&#39;, &#39;l&#39;): 9490, (&#39;L&#39;,</span>
<span class="gd">-    &#39;D&#39;): 9491, (&#39;u&#39;, &#39;r&#39;): 9492, (&#39;u&#39;, &#39;R&#39;): 9493, (&#39;U&#39;, &#39;r&#39;): 9494, (&#39;U&#39;,</span>
<span class="gd">-    &#39;R&#39;): 9495, (&#39;u&#39;, &#39;l&#39;): 9496, (&#39;u&#39;, &#39;L&#39;): 9497, (&#39;U&#39;, &#39;l&#39;): 9498, (&#39;U&#39;,</span>
<span class="gd">-    &#39;L&#39;): 9499, (&#39;v&#39;, &#39;r&#39;): 9500, (&#39;v&#39;, &#39;R&#39;): 9501, (&#39;V&#39;, &#39;r&#39;): 9504, (&#39;V&#39;,</span>
<span class="gd">-    &#39;R&#39;): 9507, (&#39;v&#39;, &#39;l&#39;): 9508, (&#39;v&#39;, &#39;L&#39;): 9509, (&#39;V&#39;, &#39;l&#39;): 9512, (&#39;V&#39;,</span>
<span class="gd">-    &#39;L&#39;): 9515, (&#39;d&#39;, &#39;h&#39;): 9516, (&#39;d&#39;, &#39;H&#39;): 9519, (&#39;D&#39;, &#39;h&#39;): 9520, (&#39;D&#39;,</span>
<span class="gd">-    &#39;H&#39;): 9523, (&#39;u&#39;, &#39;h&#39;): 9524, (&#39;u&#39;, &#39;H&#39;): 9527, (&#39;U&#39;, &#39;h&#39;): 9528, (&#39;U&#39;,</span>
<span class="gd">-    &#39;H&#39;): 9531, (&#39;v&#39;, &#39;h&#39;): 9532, (&#39;v&#39;, &#39;H&#39;): 9535, (&#39;V&#39;, &#39;h&#39;): 9538, (&#39;V&#39;,</span>
<span class="gd">-    &#39;H&#39;): 9547, (&#39;F&#39;, &#39;D&#39;): 9585, (&#39;B&#39;, &#39;D&#39;): 9586, (&#39;T&#39;, &#39;B&#39;): 9600, (&#39;L&#39;,</span>
<span class="gd">-    &#39;B&#39;): 9604, (&#39;F&#39;, &#39;B&#39;): 9608, (&#39;l&#39;, &#39;B&#39;): 9612, (&#39;R&#39;, &#39;B&#39;): 9616, (&#39;.&#39;,</span>
<span class="gd">-    &#39;S&#39;): 9617, (&#39;:&#39;, &#39;S&#39;): 9618, (&#39;?&#39;, &#39;S&#39;): 9619, (&#39;f&#39;, &#39;S&#39;): 9632, (&#39;O&#39;,</span>
<span class="gd">-    &#39;S&#39;): 9633, (&#39;R&#39;, &#39;O&#39;): 9634, (&#39;R&#39;, &#39;r&#39;): 9635, (&#39;R&#39;, &#39;F&#39;): 9636, (&#39;R&#39;,</span>
<span class="gd">-    &#39;Y&#39;): 9637, (&#39;R&#39;, &#39;H&#39;): 9638, (&#39;R&#39;, &#39;Z&#39;): 9639, (&#39;R&#39;, &#39;K&#39;): 9640, (&#39;R&#39;,</span>
<span class="gd">-    &#39;X&#39;): 9641, (&#39;s&#39;, &#39;B&#39;): 9642, (&#39;S&#39;, &#39;R&#39;): 9644, (&#39;O&#39;, &#39;r&#39;): 9645, (&#39;U&#39;,</span>
<span class="gd">-    &#39;T&#39;): 9650, (&#39;u&#39;, &#39;T&#39;): 9651, (&#39;P&#39;, &#39;R&#39;): 9654, (&#39;T&#39;, &#39;r&#39;): 9655, (&#39;D&#39;,</span>
<span class="gd">-    &#39;t&#39;): 9660, (&#39;d&#39;, &#39;T&#39;): 9661, (&#39;P&#39;, &#39;L&#39;): 9664, (&#39;T&#39;, &#39;l&#39;): 9665, (&#39;D&#39;,</span>
<span class="gd">-    &#39;b&#39;): 9670, (&#39;D&#39;, &#39;w&#39;): 9671, (&#39;L&#39;, &#39;Z&#39;): 9674, (&#39;0&#39;, &#39;m&#39;): 9675, (&#39;0&#39;,</span>
<span class="gd">-    &#39;o&#39;): 9678, (&#39;0&#39;, &#39;M&#39;): 9679, (&#39;0&#39;, &#39;L&#39;): 9680, (&#39;0&#39;, &#39;R&#39;): 9681, (&#39;S&#39;,</span>
<span class="gd">-    &#39;n&#39;): 9688, (&#39;I&#39;, &#39;c&#39;): 9689, (&#39;F&#39;, &#39;d&#39;): 9698, (&#39;B&#39;, &#39;d&#39;): 9699, (&#39;*&#39;,</span>
<span class="gd">-    &#39;2&#39;): 9733, (&#39;*&#39;, &#39;1&#39;): 9734, (&#39;&lt;&#39;, &#39;H&#39;): 9756, (&#39;&gt;&#39;, &#39;H&#39;): 9758, (&#39;0&#39;,</span>
<span class="gd">-    &#39;u&#39;): 9786, (&#39;0&#39;, &#39;U&#39;): 9787, (&#39;S&#39;, &#39;U&#39;): 9788, (&#39;F&#39;, &#39;m&#39;): 9792, (&#39;M&#39;,</span>
<span class="gd">-    &#39;l&#39;): 9794, (&#39;c&#39;, &#39;S&#39;): 9824, (&#39;c&#39;, &#39;H&#39;): 9825, (&#39;c&#39;, &#39;D&#39;): 9826, (&#39;c&#39;,</span>
<span class="gd">-    &#39;C&#39;): 9827, (&#39;M&#39;, &#39;d&#39;): 9833, (&#39;M&#39;, &#39;8&#39;): 9834, (&#39;M&#39;, &#39;2&#39;): 9835, (&#39;M&#39;,</span>
<span class="gd">-    &#39;b&#39;): 9837, (&#39;M&#39;, &#39;x&#39;): 9838, (&#39;M&#39;, &#39;X&#39;): 9839, (&#39;O&#39;, &#39;K&#39;): 10003, (&#39;X&#39;,</span>
<span class="gd">-    &#39;X&#39;): 10007, (&#39;-&#39;, &#39;X&#39;): 10016, (&#39;I&#39;, &#39;S&#39;): 12288, (&#39;,&#39;, &#39;_&#39;): 12289, (</span>
<span class="gd">-    &#39;.&#39;, &#39;_&#39;): 12290, (&#39;+&#39;, &#39;&quot;&#39;): 12291, (&#39;+&#39;, &#39;_&#39;): 12292, (&#39;*&#39;, &#39;_&#39;): </span>
<span class="gd">-    12293, (&#39;;&#39;, &#39;_&#39;): 12294, (&#39;0&#39;, &#39;_&#39;): 12295, (&#39;&lt;&#39;, &#39;+&#39;): 12298, (&#39;&gt;&#39;,</span>
<span class="gd">-    &#39;+&#39;): 12299, (&#39;&lt;&#39;, &quot;&#39;&quot;): 12300, (&#39;&gt;&#39;, &quot;&#39;&quot;): 12301, (&#39;&lt;&#39;, &#39;&quot;&#39;): 12302, (</span>
<span class="gd">-    &#39;&gt;&#39;, &#39;&quot;&#39;): 12303, (&#39;(&#39;, &#39;&quot;&#39;): 12304, (&#39;)&#39;, &#39;&quot;&#39;): 12305, (&#39;=&#39;, &#39;T&#39;): </span>
<span class="gd">-    12306, (&#39;=&#39;, &#39;_&#39;): 12307, (&#39;(&#39;, &quot;&#39;&quot;): 12308, (&#39;)&#39;, &quot;&#39;&quot;): 12309, (&#39;(&#39;,</span>
<span class="gd">-    &#39;I&#39;): 12310, (&#39;)&#39;, &#39;I&#39;): 12311, (&#39;-&#39;, &#39;?&#39;): 12316, (&#39;A&#39;, &#39;5&#39;): 12353, (</span>
<span class="gd">-    &#39;a&#39;, &#39;5&#39;): 12354, (&#39;I&#39;, &#39;5&#39;): 12355, (&#39;i&#39;, &#39;5&#39;): 12356, (&#39;U&#39;, &#39;5&#39;): </span>
<span class="gd">-    12357, (&#39;u&#39;, &#39;5&#39;): 12358, (&#39;E&#39;, &#39;5&#39;): 12359, (&#39;e&#39;, &#39;5&#39;): 12360, (&#39;O&#39;,</span>
<span class="gd">-    &#39;5&#39;): 12361, (&#39;o&#39;, &#39;5&#39;): 12362, (&#39;k&#39;, &#39;a&#39;): 12363, (&#39;g&#39;, &#39;a&#39;): 12364, (</span>
<span class="gd">-    &#39;k&#39;, &#39;i&#39;): 12365, (&#39;g&#39;, &#39;i&#39;): 12366, (&#39;k&#39;, &#39;u&#39;): 12367, (&#39;g&#39;, &#39;u&#39;): </span>
<span class="gd">-    12368, (&#39;k&#39;, &#39;e&#39;): 12369, (&#39;g&#39;, &#39;e&#39;): 12370, (&#39;k&#39;, &#39;o&#39;): 12371, (&#39;g&#39;,</span>
<span class="gd">-    &#39;o&#39;): 12372, (&#39;s&#39;, &#39;a&#39;): 12373, (&#39;z&#39;, &#39;a&#39;): 12374, (&#39;s&#39;, &#39;i&#39;): 12375, (</span>
<span class="gd">-    &#39;z&#39;, &#39;i&#39;): 12376, (&#39;s&#39;, &#39;u&#39;): 12377, (&#39;z&#39;, &#39;u&#39;): 12378, (&#39;s&#39;, &#39;e&#39;): </span>
<span class="gd">-    12379, (&#39;z&#39;, &#39;e&#39;): 12380, (&#39;s&#39;, &#39;o&#39;): 12381, (&#39;z&#39;, &#39;o&#39;): 12382, (&#39;t&#39;,</span>
<span class="gd">-    &#39;a&#39;): 12383, (&#39;d&#39;, &#39;a&#39;): 12384, (&#39;t&#39;, &#39;i&#39;): 12385, (&#39;d&#39;, &#39;i&#39;): 12386, (</span>
<span class="gd">-    &#39;t&#39;, &#39;U&#39;): 12387, (&#39;t&#39;, &#39;u&#39;): 12388, (&#39;d&#39;, &#39;u&#39;): 12389, (&#39;t&#39;, &#39;e&#39;): </span>
<span class="gd">-    12390, (&#39;d&#39;, &#39;e&#39;): 12391, (&#39;t&#39;, &#39;o&#39;): 12392, (&#39;d&#39;, &#39;o&#39;): 12393, (&#39;n&#39;,</span>
<span class="gd">-    &#39;a&#39;): 12394, (&#39;n&#39;, &#39;i&#39;): 12395, (&#39;n&#39;, &#39;u&#39;): 12396, (&#39;n&#39;, &#39;e&#39;): 12397, (</span>
<span class="gd">-    &#39;n&#39;, &#39;o&#39;): 12398, (&#39;h&#39;, &#39;a&#39;): 12399, (&#39;b&#39;, &#39;a&#39;): 12400, (&#39;p&#39;, &#39;a&#39;): </span>
<span class="gd">-    12401, (&#39;h&#39;, &#39;i&#39;): 12402, (&#39;b&#39;, &#39;i&#39;): 12403, (&#39;p&#39;, &#39;i&#39;): 12404, (&#39;h&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12405, (&#39;b&#39;, &#39;u&#39;): 12406, (&#39;p&#39;, &#39;u&#39;): 12407, (&#39;h&#39;, &#39;e&#39;): 12408, (</span>
<span class="gd">-    &#39;b&#39;, &#39;e&#39;): 12409, (&#39;p&#39;, &#39;e&#39;): 12410, (&#39;h&#39;, &#39;o&#39;): 12411, (&#39;b&#39;, &#39;o&#39;): </span>
<span class="gd">-    12412, (&#39;p&#39;, &#39;o&#39;): 12413, (&#39;m&#39;, &#39;a&#39;): 12414, (&#39;m&#39;, &#39;i&#39;): 12415, (&#39;m&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12416, (&#39;m&#39;, &#39;e&#39;): 12417, (&#39;m&#39;, &#39;o&#39;): 12418, (&#39;y&#39;, &#39;A&#39;): 12419, (</span>
<span class="gd">-    &#39;y&#39;, &#39;a&#39;): 12420, (&#39;y&#39;, &#39;U&#39;): 12421, (&#39;y&#39;, &#39;u&#39;): 12422, (&#39;y&#39;, &#39;O&#39;): </span>
<span class="gd">-    12423, (&#39;y&#39;, &#39;o&#39;): 12424, (&#39;r&#39;, &#39;a&#39;): 12425, (&#39;r&#39;, &#39;i&#39;): 12426, (&#39;r&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12427, (&#39;r&#39;, &#39;e&#39;): 12428, (&#39;r&#39;, &#39;o&#39;): 12429, (&#39;w&#39;, &#39;A&#39;): 12430, (</span>
<span class="gd">-    &#39;w&#39;, &#39;a&#39;): 12431, (&#39;w&#39;, &#39;i&#39;): 12432, (&#39;w&#39;, &#39;e&#39;): 12433, (&#39;w&#39;, &#39;o&#39;): </span>
<span class="gd">-    12434, (&#39;n&#39;, &#39;5&#39;): 12435, (&#39;v&#39;, &#39;u&#39;): 12436, (&#39;&quot;&#39;, &#39;5&#39;): 12443, (&#39;0&#39;,</span>
<span class="gd">-    &#39;5&#39;): 12444, (&#39;*&#39;, &#39;5&#39;): 12445, (&#39;+&#39;, &#39;5&#39;): 12446, (&#39;a&#39;, &#39;6&#39;): 12449, (</span>
<span class="gd">-    &#39;A&#39;, &#39;6&#39;): 12450, (&#39;i&#39;, &#39;6&#39;): 12451, (&#39;I&#39;, &#39;6&#39;): 12452, (&#39;u&#39;, &#39;6&#39;): </span>
<span class="gd">-    12453, (&#39;U&#39;, &#39;6&#39;): 12454, (&#39;e&#39;, &#39;6&#39;): 12455, (&#39;E&#39;, &#39;6&#39;): 12456, (&#39;o&#39;,</span>
<span class="gd">-    &#39;6&#39;): 12457, (&#39;O&#39;, &#39;6&#39;): 12458, (&#39;K&#39;, &#39;a&#39;): 12459, (&#39;G&#39;, &#39;a&#39;): 12460, (</span>
<span class="gd">-    &#39;K&#39;, &#39;i&#39;): 12461, (&#39;G&#39;, &#39;i&#39;): 12462, (&#39;K&#39;, &#39;u&#39;): 12463, (&#39;G&#39;, &#39;u&#39;): </span>
<span class="gd">-    12464, (&#39;K&#39;, &#39;e&#39;): 12465, (&#39;G&#39;, &#39;e&#39;): 12466, (&#39;K&#39;, &#39;o&#39;): 12467, (&#39;G&#39;,</span>
<span class="gd">-    &#39;o&#39;): 12468, (&#39;S&#39;, &#39;a&#39;): 12469, (&#39;Z&#39;, &#39;a&#39;): 12470, (&#39;S&#39;, &#39;i&#39;): 12471, (</span>
<span class="gd">-    &#39;Z&#39;, &#39;i&#39;): 12472, (&#39;S&#39;, &#39;u&#39;): 12473, (&#39;Z&#39;, &#39;u&#39;): 12474, (&#39;S&#39;, &#39;e&#39;): </span>
<span class="gd">-    12475, (&#39;Z&#39;, &#39;e&#39;): 12476, (&#39;S&#39;, &#39;o&#39;): 12477, (&#39;Z&#39;, &#39;o&#39;): 12478, (&#39;T&#39;,</span>
<span class="gd">-    &#39;a&#39;): 12479, (&#39;D&#39;, &#39;a&#39;): 12480, (&#39;T&#39;, &#39;i&#39;): 12481, (&#39;D&#39;, &#39;i&#39;): 12482, (</span>
<span class="gd">-    &#39;T&#39;, &#39;U&#39;): 12483, (&#39;T&#39;, &#39;u&#39;): 12484, (&#39;D&#39;, &#39;u&#39;): 12485, (&#39;T&#39;, &#39;e&#39;): </span>
<span class="gd">-    12486, (&#39;D&#39;, &#39;e&#39;): 12487, (&#39;T&#39;, &#39;o&#39;): 12488, (&#39;D&#39;, &#39;o&#39;): 12489, (&#39;N&#39;,</span>
<span class="gd">-    &#39;a&#39;): 12490, (&#39;N&#39;, &#39;i&#39;): 12491, (&#39;N&#39;, &#39;u&#39;): 12492, (&#39;N&#39;, &#39;e&#39;): 12493, (</span>
<span class="gd">-    &#39;N&#39;, &#39;o&#39;): 12494, (&#39;H&#39;, &#39;a&#39;): 12495, (&#39;B&#39;, &#39;a&#39;): 12496, (&#39;P&#39;, &#39;a&#39;): </span>
<span class="gd">-    12497, (&#39;H&#39;, &#39;i&#39;): 12498, (&#39;B&#39;, &#39;i&#39;): 12499, (&#39;P&#39;, &#39;i&#39;): 12500, (&#39;H&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12501, (&#39;B&#39;, &#39;u&#39;): 12502, (&#39;P&#39;, &#39;u&#39;): 12503, (&#39;H&#39;, &#39;e&#39;): 12504, (</span>
<span class="gd">-    &#39;B&#39;, &#39;e&#39;): 12505, (&#39;P&#39;, &#39;e&#39;): 12506, (&#39;H&#39;, &#39;o&#39;): 12507, (&#39;B&#39;, &#39;o&#39;): </span>
<span class="gd">-    12508, (&#39;P&#39;, &#39;o&#39;): 12509, (&#39;M&#39;, &#39;a&#39;): 12510, (&#39;M&#39;, &#39;i&#39;): 12511, (&#39;M&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12512, (&#39;M&#39;, &#39;e&#39;): 12513, (&#39;M&#39;, &#39;o&#39;): 12514, (&#39;Y&#39;, &#39;A&#39;): 12515, (</span>
<span class="gd">-    &#39;Y&#39;, &#39;a&#39;): 12516, (&#39;Y&#39;, &#39;U&#39;): 12517, (&#39;Y&#39;, &#39;u&#39;): 12518, (&#39;Y&#39;, &#39;O&#39;): </span>
<span class="gd">-    12519, (&#39;Y&#39;, &#39;o&#39;): 12520, (&#39;R&#39;, &#39;a&#39;): 12521, (&#39;R&#39;, &#39;i&#39;): 12522, (&#39;R&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12523, (&#39;R&#39;, &#39;e&#39;): 12524, (&#39;R&#39;, &#39;o&#39;): 12525, (&#39;W&#39;, &#39;A&#39;): 12526, (</span>
<span class="gd">-    &#39;W&#39;, &#39;a&#39;): 12527, (&#39;W&#39;, &#39;i&#39;): 12528, (&#39;W&#39;, &#39;e&#39;): 12529, (&#39;W&#39;, &#39;o&#39;): </span>
<span class="gd">-    12530, (&#39;N&#39;, &#39;6&#39;): 12531, (&#39;V&#39;, &#39;u&#39;): 12532, (&#39;K&#39;, &#39;A&#39;): 12533, (&#39;K&#39;,</span>
<span class="gd">-    &#39;E&#39;): 12534, (&#39;V&#39;, &#39;a&#39;): 12535, (&#39;V&#39;, &#39;i&#39;): 12536, (&#39;V&#39;, &#39;e&#39;): 12537, (</span>
<span class="gd">-    &#39;V&#39;, &#39;o&#39;): 12538, (&#39;.&#39;, &#39;6&#39;): 12539, (&#39;-&#39;, &#39;6&#39;): 12540, (&#39;*&#39;, &#39;6&#39;): </span>
<span class="gd">-    12541, (&#39;+&#39;, &#39;6&#39;): 12542, (&#39;b&#39;, &#39;4&#39;): 12549, (&#39;p&#39;, &#39;4&#39;): 12550, (&#39;m&#39;,</span>
<span class="gd">-    &#39;4&#39;): 12551, (&#39;f&#39;, &#39;4&#39;): 12552, (&#39;d&#39;, &#39;4&#39;): 12553, (&#39;t&#39;, &#39;4&#39;): 12554, (</span>
<span class="gd">-    &#39;n&#39;, &#39;4&#39;): 12555, (&#39;l&#39;, &#39;4&#39;): 12556, (&#39;g&#39;, &#39;4&#39;): 12557, (&#39;k&#39;, &#39;4&#39;): </span>
<span class="gd">-    12558, (&#39;h&#39;, &#39;4&#39;): 12559, (&#39;j&#39;, &#39;4&#39;): 12560, (&#39;q&#39;, &#39;4&#39;): 12561, (&#39;x&#39;,</span>
<span class="gd">-    &#39;4&#39;): 12562, (&#39;z&#39;, &#39;h&#39;): 12563, (&#39;c&#39;, &#39;h&#39;): 12564, (&#39;s&#39;, &#39;h&#39;): 12565, (</span>
<span class="gd">-    &#39;r&#39;, &#39;4&#39;): 12566, (&#39;z&#39;, &#39;4&#39;): 12567, (&#39;c&#39;, &#39;4&#39;): 12568, (&#39;s&#39;, &#39;4&#39;): </span>
<span class="gd">-    12569, (&#39;a&#39;, &#39;4&#39;): 12570, (&#39;o&#39;, &#39;4&#39;): 12571, (&#39;e&#39;, &#39;4&#39;): 12572, (&#39;a&#39;,</span>
<span class="gd">-    &#39;i&#39;): 12574, (&#39;e&#39;, &#39;i&#39;): 12575, (&#39;a&#39;, &#39;u&#39;): 12576, (&#39;o&#39;, &#39;u&#39;): 12577, (</span>
<span class="gd">-    &#39;a&#39;, &#39;n&#39;): 12578, (&#39;e&#39;, &#39;n&#39;): 12579, (&#39;a&#39;, &#39;N&#39;): 12580, (&#39;e&#39;, &#39;N&#39;): </span>
<span class="gd">-    12581, (&#39;e&#39;, &#39;r&#39;): 12582, (&#39;i&#39;, &#39;4&#39;): 12583, (&#39;u&#39;, &#39;4&#39;): 12584, (&#39;i&#39;,</span>
<span class="gd">-    &#39;u&#39;): 12585, (&#39;v&#39;, &#39;4&#39;): 12586, (&#39;n&#39;, &#39;G&#39;): 12587, (&#39;g&#39;, &#39;n&#39;): 12588, (</span>
<span class="gd">-    &#39;1&#39;, &#39;c&#39;): 12832, (&#39;2&#39;, &#39;c&#39;): 12833, (&#39;3&#39;, &#39;c&#39;): 12834, (&#39;4&#39;, &#39;c&#39;): </span>
<span class="gd">-    12835, (&#39;5&#39;, &#39;c&#39;): 12836, (&#39;6&#39;, &#39;c&#39;): 12837, (&#39;7&#39;, &#39;c&#39;): 12838, (&#39;8&#39;,</span>
<span class="gd">-    &#39;c&#39;): 12839, (&#39;9&#39;, &#39;c&#39;): 12840, (&#39;f&#39;, &#39;f&#39;): 64256, (&#39;f&#39;, &#39;i&#39;): 64257, (</span>
<span class="gd">-    &#39;f&#39;, &#39;l&#39;): 64258, (&#39;f&#39;, &#39;t&#39;): 64261, (&#39;s&#39;, &#39;t&#39;): 64262, (&#39;~&#39;, &#39;!&#39;): 161,</span>
<span class="gd">-    (&#39;c&#39;, &#39;|&#39;): 162, (&#39;$&#39;, &#39;$&#39;): 163, (&#39;o&#39;, &#39;x&#39;): 164, (&#39;Y&#39;, &#39;-&#39;): 165, (</span>
<span class="gd">-    &#39;|&#39;, &#39;|&#39;): 166, (&#39;c&#39;, &#39;O&#39;): 169, (&#39;-&#39;, &#39;,&#39;): 172, (&#39;-&#39;, &#39;=&#39;): 175, (&#39;~&#39;,</span>
<span class="gd">-    &#39;o&#39;): 176, (&#39;2&#39;, &#39;2&#39;): 178, (&#39;3&#39;, &#39;3&#39;): 179, (&#39;p&#39;, &#39;p&#39;): 182, (&#39;~&#39;, &#39;.&#39;</span>
<span class="gd">-    ): 183, (&#39;1&#39;, &#39;1&#39;): 185, (&#39;~&#39;, &#39;?&#39;): 191, (&#39;A&#39;, &#39;`&#39;): 192, (&#39;A&#39;, &#39;^&#39;): </span>
<span class="gd">-    194, (&#39;A&#39;, &#39;~&#39;): 195, (&#39;A&#39;, &#39;&quot;&#39;): 196, (&#39;A&#39;, &#39;@&#39;): 197, (&#39;E&#39;, &#39;`&#39;): 200,</span>
<span class="gd">-    (&#39;E&#39;, &#39;^&#39;): 202, (&#39;E&#39;, &#39;&quot;&#39;): 203, (&#39;I&#39;, &#39;`&#39;): 204, (&#39;I&#39;, &#39;^&#39;): 206, (</span>
<span class="gd">-    &#39;I&#39;, &#39;&quot;&#39;): 207, (&#39;N&#39;, &#39;~&#39;): 209, (&#39;O&#39;, &#39;`&#39;): 210, (&#39;O&#39;, &#39;^&#39;): 212, (&#39;O&#39;,</span>
<span class="gd">-    &#39;~&#39;): 213, (&#39;/&#39;, &#39;\\&#39;): 215, (&#39;U&#39;, &#39;`&#39;): 217, (&#39;U&#39;, &#39;^&#39;): 219, (&#39;I&#39;,</span>
<span class="gd">-    &#39;p&#39;): 222, (&#39;a&#39;, &#39;`&#39;): 224, (&#39;a&#39;, &#39;^&#39;): 226, (&#39;a&#39;, &#39;~&#39;): 227, (&#39;a&#39;, &#39;&quot;&#39;</span>
<span class="gd">-    ): 228, (&#39;a&#39;, &#39;@&#39;): 229, (&#39;e&#39;, &#39;`&#39;): 232, (&#39;e&#39;, &#39;^&#39;): 234, (&#39;e&#39;, &#39;&quot;&#39;): </span>
<span class="gd">-    235, (&#39;i&#39;, &#39;`&#39;): 236, (&#39;i&#39;, &#39;^&#39;): 238, (&#39;n&#39;, &#39;~&#39;): 241, (&#39;o&#39;, &#39;`&#39;): 242,</span>
<span class="gd">-    (&#39;o&#39;, &#39;^&#39;): 244, (&#39;o&#39;, &#39;~&#39;): 245, (&#39;u&#39;, &#39;`&#39;): 249, (&#39;u&#39;, &#39;^&#39;): 251, (</span>
<span class="gd">-    &#39;y&#39;, &#39;&quot;&#39;): 255}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;DIGRAPHS&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# digraphs for Unicode from RFC1345</span>
<span class="gi">+# (also work for ISO-8859-1 aka latin1)</span>
<span class="gi">+DIGRAPHS: dict[tuple[str, str], int] = {</span>
<span class="gi">+    (&quot;N&quot;, &quot;U&quot;): 0x00,</span>
<span class="gi">+    (&quot;S&quot;, &quot;H&quot;): 0x01,</span>
<span class="gi">+    (&quot;S&quot;, &quot;X&quot;): 0x02,</span>
<span class="gi">+    (&quot;E&quot;, &quot;X&quot;): 0x03,</span>
<span class="gi">+    (&quot;E&quot;, &quot;T&quot;): 0x04,</span>
<span class="gi">+    (&quot;E&quot;, &quot;Q&quot;): 0x05,</span>
<span class="gi">+    (&quot;A&quot;, &quot;K&quot;): 0x06,</span>
<span class="gi">+    (&quot;B&quot;, &quot;L&quot;): 0x07,</span>
<span class="gi">+    (&quot;B&quot;, &quot;S&quot;): 0x08,</span>
<span class="gi">+    (&quot;H&quot;, &quot;T&quot;): 0x09,</span>
<span class="gi">+    (&quot;L&quot;, &quot;F&quot;): 0x0A,</span>
<span class="gi">+    (&quot;V&quot;, &quot;T&quot;): 0x0B,</span>
<span class="gi">+    (&quot;F&quot;, &quot;F&quot;): 0x0C,</span>
<span class="gi">+    (&quot;C&quot;, &quot;R&quot;): 0x0D,</span>
<span class="gi">+    (&quot;S&quot;, &quot;O&quot;): 0x0E,</span>
<span class="gi">+    (&quot;S&quot;, &quot;I&quot;): 0x0F,</span>
<span class="gi">+    (&quot;D&quot;, &quot;L&quot;): 0x10,</span>
<span class="gi">+    (&quot;D&quot;, &quot;1&quot;): 0x11,</span>
<span class="gi">+    (&quot;D&quot;, &quot;2&quot;): 0x12,</span>
<span class="gi">+    (&quot;D&quot;, &quot;3&quot;): 0x13,</span>
<span class="gi">+    (&quot;D&quot;, &quot;4&quot;): 0x14,</span>
<span class="gi">+    (&quot;N&quot;, &quot;K&quot;): 0x15,</span>
<span class="gi">+    (&quot;S&quot;, &quot;Y&quot;): 0x16,</span>
<span class="gi">+    (&quot;E&quot;, &quot;B&quot;): 0x17,</span>
<span class="gi">+    (&quot;C&quot;, &quot;N&quot;): 0x18,</span>
<span class="gi">+    (&quot;E&quot;, &quot;M&quot;): 0x19,</span>
<span class="gi">+    (&quot;S&quot;, &quot;B&quot;): 0x1A,</span>
<span class="gi">+    (&quot;E&quot;, &quot;C&quot;): 0x1B,</span>
<span class="gi">+    (&quot;F&quot;, &quot;S&quot;): 0x1C,</span>
<span class="gi">+    (&quot;G&quot;, &quot;S&quot;): 0x1D,</span>
<span class="gi">+    (&quot;R&quot;, &quot;S&quot;): 0x1E,</span>
<span class="gi">+    (&quot;U&quot;, &quot;S&quot;): 0x1F,</span>
<span class="gi">+    (&quot;S&quot;, &quot;P&quot;): 0x20,</span>
<span class="gi">+    (&quot;N&quot;, &quot;b&quot;): 0x23,</span>
<span class="gi">+    (&quot;D&quot;, &quot;O&quot;): 0x24,</span>
<span class="gi">+    (&quot;A&quot;, &quot;t&quot;): 0x40,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;(&quot;): 0x5B,</span>
<span class="gi">+    (&quot;/&quot;, &quot;/&quot;): 0x5C,</span>
<span class="gi">+    (&quot;)&quot;, &quot;&gt;&quot;): 0x5D,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;&gt;&quot;): 0x5E,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;!&quot;): 0x60,</span>
<span class="gi">+    (&quot;(&quot;, &quot;!&quot;): 0x7B,</span>
<span class="gi">+    (&quot;!&quot;, &quot;!&quot;): 0x7C,</span>
<span class="gi">+    (&quot;!&quot;, &quot;)&quot;): 0x7D,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;?&quot;): 0x7E,</span>
<span class="gi">+    (&quot;D&quot;, &quot;T&quot;): 0x7F,</span>
<span class="gi">+    (&quot;P&quot;, &quot;A&quot;): 0x80,</span>
<span class="gi">+    (&quot;H&quot;, &quot;O&quot;): 0x81,</span>
<span class="gi">+    (&quot;B&quot;, &quot;H&quot;): 0x82,</span>
<span class="gi">+    (&quot;N&quot;, &quot;H&quot;): 0x83,</span>
<span class="gi">+    (&quot;I&quot;, &quot;N&quot;): 0x84,</span>
<span class="gi">+    (&quot;N&quot;, &quot;L&quot;): 0x85,</span>
<span class="gi">+    (&quot;S&quot;, &quot;A&quot;): 0x86,</span>
<span class="gi">+    (&quot;E&quot;, &quot;S&quot;): 0x87,</span>
<span class="gi">+    (&quot;H&quot;, &quot;S&quot;): 0x88,</span>
<span class="gi">+    (&quot;H&quot;, &quot;J&quot;): 0x89,</span>
<span class="gi">+    (&quot;V&quot;, &quot;S&quot;): 0x8A,</span>
<span class="gi">+    (&quot;P&quot;, &quot;D&quot;): 0x8B,</span>
<span class="gi">+    (&quot;P&quot;, &quot;U&quot;): 0x8C,</span>
<span class="gi">+    (&quot;R&quot;, &quot;I&quot;): 0x8D,</span>
<span class="gi">+    (&quot;S&quot;, &quot;2&quot;): 0x8E,</span>
<span class="gi">+    (&quot;S&quot;, &quot;3&quot;): 0x8F,</span>
<span class="gi">+    (&quot;D&quot;, &quot;C&quot;): 0x90,</span>
<span class="gi">+    (&quot;P&quot;, &quot;1&quot;): 0x91,</span>
<span class="gi">+    (&quot;P&quot;, &quot;2&quot;): 0x92,</span>
<span class="gi">+    (&quot;T&quot;, &quot;S&quot;): 0x93,</span>
<span class="gi">+    (&quot;C&quot;, &quot;C&quot;): 0x94,</span>
<span class="gi">+    (&quot;M&quot;, &quot;W&quot;): 0x95,</span>
<span class="gi">+    (&quot;S&quot;, &quot;G&quot;): 0x96,</span>
<span class="gi">+    (&quot;E&quot;, &quot;G&quot;): 0x97,</span>
<span class="gi">+    (&quot;S&quot;, &quot;S&quot;): 0x98,</span>
<span class="gi">+    (&quot;G&quot;, &quot;C&quot;): 0x99,</span>
<span class="gi">+    (&quot;S&quot;, &quot;C&quot;): 0x9A,</span>
<span class="gi">+    (&quot;C&quot;, &quot;I&quot;): 0x9B,</span>
<span class="gi">+    (&quot;S&quot;, &quot;T&quot;): 0x9C,</span>
<span class="gi">+    (&quot;O&quot;, &quot;C&quot;): 0x9D,</span>
<span class="gi">+    (&quot;P&quot;, &quot;M&quot;): 0x9E,</span>
<span class="gi">+    (&quot;A&quot;, &quot;C&quot;): 0x9F,</span>
<span class="gi">+    (&quot;N&quot;, &quot;S&quot;): 0xA0,</span>
<span class="gi">+    (&quot;!&quot;, &quot;I&quot;): 0xA1,</span>
<span class="gi">+    (&quot;C&quot;, &quot;t&quot;): 0xA2,</span>
<span class="gi">+    (&quot;P&quot;, &quot;d&quot;): 0xA3,</span>
<span class="gi">+    (&quot;C&quot;, &quot;u&quot;): 0xA4,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;e&quot;): 0xA5,</span>
<span class="gi">+    (&quot;B&quot;, &quot;B&quot;): 0xA6,</span>
<span class="gi">+    (&quot;S&quot;, &quot;E&quot;): 0xA7,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;:&quot;): 0xA8,</span>
<span class="gi">+    (&quot;C&quot;, &quot;o&quot;): 0xA9,</span>
<span class="gi">+    (&quot;-&quot;, &quot;a&quot;): 0xAA,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;&lt;&quot;): 0xAB,</span>
<span class="gi">+    (&quot;N&quot;, &quot;O&quot;): 0xAC,</span>
<span class="gi">+    (&quot;-&quot;, &quot;-&quot;): 0xAD,</span>
<span class="gi">+    (&quot;R&quot;, &quot;g&quot;): 0xAE,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;m&quot;): 0xAF,</span>
<span class="gi">+    (&quot;D&quot;, &quot;G&quot;): 0xB0,</span>
<span class="gi">+    (&quot;+&quot;, &quot;-&quot;): 0xB1,</span>
<span class="gi">+    (&quot;2&quot;, &quot;S&quot;): 0xB2,</span>
<span class="gi">+    (&quot;3&quot;, &quot;S&quot;): 0xB3,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;&#39;&quot;): 0xB4,</span>
<span class="gi">+    (&quot;M&quot;, &quot;y&quot;): 0xB5,</span>
<span class="gi">+    (&quot;P&quot;, &quot;I&quot;): 0xB6,</span>
<span class="gi">+    (&quot;.&quot;, &quot;M&quot;): 0xB7,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;,&quot;): 0xB8,</span>
<span class="gi">+    (&quot;1&quot;, &quot;S&quot;): 0xB9,</span>
<span class="gi">+    (&quot;-&quot;, &quot;o&quot;): 0xBA,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;&gt;&quot;): 0xBB,</span>
<span class="gi">+    (&quot;1&quot;, &quot;4&quot;): 0xBC,</span>
<span class="gi">+    (&quot;1&quot;, &quot;2&quot;): 0xBD,</span>
<span class="gi">+    (&quot;3&quot;, &quot;4&quot;): 0xBE,</span>
<span class="gi">+    (&quot;?&quot;, &quot;I&quot;): 0xBF,</span>
<span class="gi">+    (&quot;A&quot;, &quot;!&quot;): 0xC0,</span>
<span class="gi">+    (&quot;A&quot;, &quot;&#39;&quot;): 0xC1,</span>
<span class="gi">+    (&quot;A&quot;, &quot;&gt;&quot;): 0xC2,</span>
<span class="gi">+    (&quot;A&quot;, &quot;?&quot;): 0xC3,</span>
<span class="gi">+    (&quot;A&quot;, &quot;:&quot;): 0xC4,</span>
<span class="gi">+    (&quot;A&quot;, &quot;A&quot;): 0xC5,</span>
<span class="gi">+    (&quot;A&quot;, &quot;E&quot;): 0xC6,</span>
<span class="gi">+    (&quot;C&quot;, &quot;,&quot;): 0xC7,</span>
<span class="gi">+    (&quot;E&quot;, &quot;!&quot;): 0xC8,</span>
<span class="gi">+    (&quot;E&quot;, &quot;&#39;&quot;): 0xC9,</span>
<span class="gi">+    (&quot;E&quot;, &quot;&gt;&quot;): 0xCA,</span>
<span class="gi">+    (&quot;E&quot;, &quot;:&quot;): 0xCB,</span>
<span class="gi">+    (&quot;I&quot;, &quot;!&quot;): 0xCC,</span>
<span class="gi">+    (&quot;I&quot;, &quot;&#39;&quot;): 0xCD,</span>
<span class="gi">+    (&quot;I&quot;, &quot;&gt;&quot;): 0xCE,</span>
<span class="gi">+    (&quot;I&quot;, &quot;:&quot;): 0xCF,</span>
<span class="gi">+    (&quot;D&quot;, &quot;-&quot;): 0xD0,</span>
<span class="gi">+    (&quot;N&quot;, &quot;?&quot;): 0xD1,</span>
<span class="gi">+    (&quot;O&quot;, &quot;!&quot;): 0xD2,</span>
<span class="gi">+    (&quot;O&quot;, &quot;&#39;&quot;): 0xD3,</span>
<span class="gi">+    (&quot;O&quot;, &quot;&gt;&quot;): 0xD4,</span>
<span class="gi">+    (&quot;O&quot;, &quot;?&quot;): 0xD5,</span>
<span class="gi">+    (&quot;O&quot;, &quot;:&quot;): 0xD6,</span>
<span class="gi">+    (&quot;*&quot;, &quot;X&quot;): 0xD7,</span>
<span class="gi">+    (&quot;O&quot;, &quot;/&quot;): 0xD8,</span>
<span class="gi">+    (&quot;U&quot;, &quot;!&quot;): 0xD9,</span>
<span class="gi">+    (&quot;U&quot;, &quot;&#39;&quot;): 0xDA,</span>
<span class="gi">+    (&quot;U&quot;, &quot;&gt;&quot;): 0xDB,</span>
<span class="gi">+    (&quot;U&quot;, &quot;:&quot;): 0xDC,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;&#39;&quot;): 0xDD,</span>
<span class="gi">+    (&quot;T&quot;, &quot;H&quot;): 0xDE,</span>
<span class="gi">+    (&quot;s&quot;, &quot;s&quot;): 0xDF,</span>
<span class="gi">+    (&quot;a&quot;, &quot;!&quot;): 0xE0,</span>
<span class="gi">+    (&quot;a&quot;, &quot;&#39;&quot;): 0xE1,</span>
<span class="gi">+    (&quot;a&quot;, &quot;&gt;&quot;): 0xE2,</span>
<span class="gi">+    (&quot;a&quot;, &quot;?&quot;): 0xE3,</span>
<span class="gi">+    (&quot;a&quot;, &quot;:&quot;): 0xE4,</span>
<span class="gi">+    (&quot;a&quot;, &quot;a&quot;): 0xE5,</span>
<span class="gi">+    (&quot;a&quot;, &quot;e&quot;): 0xE6,</span>
<span class="gi">+    (&quot;c&quot;, &quot;,&quot;): 0xE7,</span>
<span class="gi">+    (&quot;e&quot;, &quot;!&quot;): 0xE8,</span>
<span class="gi">+    (&quot;e&quot;, &quot;&#39;&quot;): 0xE9,</span>
<span class="gi">+    (&quot;e&quot;, &quot;&gt;&quot;): 0xEA,</span>
<span class="gi">+    (&quot;e&quot;, &quot;:&quot;): 0xEB,</span>
<span class="gi">+    (&quot;i&quot;, &quot;!&quot;): 0xEC,</span>
<span class="gi">+    (&quot;i&quot;, &quot;&#39;&quot;): 0xED,</span>
<span class="gi">+    (&quot;i&quot;, &quot;&gt;&quot;): 0xEE,</span>
<span class="gi">+    (&quot;i&quot;, &quot;:&quot;): 0xEF,</span>
<span class="gi">+    (&quot;d&quot;, &quot;-&quot;): 0xF0,</span>
<span class="gi">+    (&quot;n&quot;, &quot;?&quot;): 0xF1,</span>
<span class="gi">+    (&quot;o&quot;, &quot;!&quot;): 0xF2,</span>
<span class="gi">+    (&quot;o&quot;, &quot;&#39;&quot;): 0xF3,</span>
<span class="gi">+    (&quot;o&quot;, &quot;&gt;&quot;): 0xF4,</span>
<span class="gi">+    (&quot;o&quot;, &quot;?&quot;): 0xF5,</span>
<span class="gi">+    (&quot;o&quot;, &quot;:&quot;): 0xF6,</span>
<span class="gi">+    (&quot;-&quot;, &quot;:&quot;): 0xF7,</span>
<span class="gi">+    (&quot;o&quot;, &quot;/&quot;): 0xF8,</span>
<span class="gi">+    (&quot;u&quot;, &quot;!&quot;): 0xF9,</span>
<span class="gi">+    (&quot;u&quot;, &quot;&#39;&quot;): 0xFA,</span>
<span class="gi">+    (&quot;u&quot;, &quot;&gt;&quot;): 0xFB,</span>
<span class="gi">+    (&quot;u&quot;, &quot;:&quot;): 0xFC,</span>
<span class="gi">+    (&quot;y&quot;, &quot;&#39;&quot;): 0xFD,</span>
<span class="gi">+    (&quot;t&quot;, &quot;h&quot;): 0xFE,</span>
<span class="gi">+    (&quot;y&quot;, &quot;:&quot;): 0xFF,</span>
<span class="gi">+    (&quot;A&quot;, &quot;-&quot;): 0x0100,</span>
<span class="gi">+    (&quot;a&quot;, &quot;-&quot;): 0x0101,</span>
<span class="gi">+    (&quot;A&quot;, &quot;(&quot;): 0x0102,</span>
<span class="gi">+    (&quot;a&quot;, &quot;(&quot;): 0x0103,</span>
<span class="gi">+    (&quot;A&quot;, &quot;;&quot;): 0x0104,</span>
<span class="gi">+    (&quot;a&quot;, &quot;;&quot;): 0x0105,</span>
<span class="gi">+    (&quot;C&quot;, &quot;&#39;&quot;): 0x0106,</span>
<span class="gi">+    (&quot;c&quot;, &quot;&#39;&quot;): 0x0107,</span>
<span class="gi">+    (&quot;C&quot;, &quot;&gt;&quot;): 0x0108,</span>
<span class="gi">+    (&quot;c&quot;, &quot;&gt;&quot;): 0x0109,</span>
<span class="gi">+    (&quot;C&quot;, &quot;.&quot;): 0x010A,</span>
<span class="gi">+    (&quot;c&quot;, &quot;.&quot;): 0x010B,</span>
<span class="gi">+    (&quot;C&quot;, &quot;&lt;&quot;): 0x010C,</span>
<span class="gi">+    (&quot;c&quot;, &quot;&lt;&quot;): 0x010D,</span>
<span class="gi">+    (&quot;D&quot;, &quot;&lt;&quot;): 0x010E,</span>
<span class="gi">+    (&quot;d&quot;, &quot;&lt;&quot;): 0x010F,</span>
<span class="gi">+    (&quot;D&quot;, &quot;/&quot;): 0x0110,</span>
<span class="gi">+    (&quot;d&quot;, &quot;/&quot;): 0x0111,</span>
<span class="gi">+    (&quot;E&quot;, &quot;-&quot;): 0x0112,</span>
<span class="gi">+    (&quot;e&quot;, &quot;-&quot;): 0x0113,</span>
<span class="gi">+    (&quot;E&quot;, &quot;(&quot;): 0x0114,</span>
<span class="gi">+    (&quot;e&quot;, &quot;(&quot;): 0x0115,</span>
<span class="gi">+    (&quot;E&quot;, &quot;.&quot;): 0x0116,</span>
<span class="gi">+    (&quot;e&quot;, &quot;.&quot;): 0x0117,</span>
<span class="gi">+    (&quot;E&quot;, &quot;;&quot;): 0x0118,</span>
<span class="gi">+    (&quot;e&quot;, &quot;;&quot;): 0x0119,</span>
<span class="gi">+    (&quot;E&quot;, &quot;&lt;&quot;): 0x011A,</span>
<span class="gi">+    (&quot;e&quot;, &quot;&lt;&quot;): 0x011B,</span>
<span class="gi">+    (&quot;G&quot;, &quot;&gt;&quot;): 0x011C,</span>
<span class="gi">+    (&quot;g&quot;, &quot;&gt;&quot;): 0x011D,</span>
<span class="gi">+    (&quot;G&quot;, &quot;(&quot;): 0x011E,</span>
<span class="gi">+    (&quot;g&quot;, &quot;(&quot;): 0x011F,</span>
<span class="gi">+    (&quot;G&quot;, &quot;.&quot;): 0x0120,</span>
<span class="gi">+    (&quot;g&quot;, &quot;.&quot;): 0x0121,</span>
<span class="gi">+    (&quot;G&quot;, &quot;,&quot;): 0x0122,</span>
<span class="gi">+    (&quot;g&quot;, &quot;,&quot;): 0x0123,</span>
<span class="gi">+    (&quot;H&quot;, &quot;&gt;&quot;): 0x0124,</span>
<span class="gi">+    (&quot;h&quot;, &quot;&gt;&quot;): 0x0125,</span>
<span class="gi">+    (&quot;H&quot;, &quot;/&quot;): 0x0126,</span>
<span class="gi">+    (&quot;h&quot;, &quot;/&quot;): 0x0127,</span>
<span class="gi">+    (&quot;I&quot;, &quot;?&quot;): 0x0128,</span>
<span class="gi">+    (&quot;i&quot;, &quot;?&quot;): 0x0129,</span>
<span class="gi">+    (&quot;I&quot;, &quot;-&quot;): 0x012A,</span>
<span class="gi">+    (&quot;i&quot;, &quot;-&quot;): 0x012B,</span>
<span class="gi">+    (&quot;I&quot;, &quot;(&quot;): 0x012C,</span>
<span class="gi">+    (&quot;i&quot;, &quot;(&quot;): 0x012D,</span>
<span class="gi">+    (&quot;I&quot;, &quot;;&quot;): 0x012E,</span>
<span class="gi">+    (&quot;i&quot;, &quot;;&quot;): 0x012F,</span>
<span class="gi">+    (&quot;I&quot;, &quot;.&quot;): 0x0130,</span>
<span class="gi">+    (&quot;i&quot;, &quot;.&quot;): 0x0131,</span>
<span class="gi">+    (&quot;I&quot;, &quot;J&quot;): 0x0132,</span>
<span class="gi">+    (&quot;i&quot;, &quot;j&quot;): 0x0133,</span>
<span class="gi">+    (&quot;J&quot;, &quot;&gt;&quot;): 0x0134,</span>
<span class="gi">+    (&quot;j&quot;, &quot;&gt;&quot;): 0x0135,</span>
<span class="gi">+    (&quot;K&quot;, &quot;,&quot;): 0x0136,</span>
<span class="gi">+    (&quot;k&quot;, &quot;,&quot;): 0x0137,</span>
<span class="gi">+    (&quot;k&quot;, &quot;k&quot;): 0x0138,</span>
<span class="gi">+    (&quot;L&quot;, &quot;&#39;&quot;): 0x0139,</span>
<span class="gi">+    (&quot;l&quot;, &quot;&#39;&quot;): 0x013A,</span>
<span class="gi">+    (&quot;L&quot;, &quot;,&quot;): 0x013B,</span>
<span class="gi">+    (&quot;l&quot;, &quot;,&quot;): 0x013C,</span>
<span class="gi">+    (&quot;L&quot;, &quot;&lt;&quot;): 0x013D,</span>
<span class="gi">+    (&quot;l&quot;, &quot;&lt;&quot;): 0x013E,</span>
<span class="gi">+    (&quot;L&quot;, &quot;.&quot;): 0x013F,</span>
<span class="gi">+    (&quot;l&quot;, &quot;.&quot;): 0x0140,</span>
<span class="gi">+    (&quot;L&quot;, &quot;/&quot;): 0x0141,</span>
<span class="gi">+    (&quot;l&quot;, &quot;/&quot;): 0x0142,</span>
<span class="gi">+    (&quot;N&quot;, &quot;&#39;&quot;): 0x0143,</span>
<span class="gi">+    (&quot;n&quot;, &quot;&#39;&quot;): 0x0144,</span>
<span class="gi">+    (&quot;N&quot;, &quot;,&quot;): 0x0145,</span>
<span class="gi">+    (&quot;n&quot;, &quot;,&quot;): 0x0146,</span>
<span class="gi">+    (&quot;N&quot;, &quot;&lt;&quot;): 0x0147,</span>
<span class="gi">+    (&quot;n&quot;, &quot;&lt;&quot;): 0x0148,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;n&quot;): 0x0149,</span>
<span class="gi">+    (&quot;N&quot;, &quot;G&quot;): 0x014A,</span>
<span class="gi">+    (&quot;n&quot;, &quot;g&quot;): 0x014B,</span>
<span class="gi">+    (&quot;O&quot;, &quot;-&quot;): 0x014C,</span>
<span class="gi">+    (&quot;o&quot;, &quot;-&quot;): 0x014D,</span>
<span class="gi">+    (&quot;O&quot;, &quot;(&quot;): 0x014E,</span>
<span class="gi">+    (&quot;o&quot;, &quot;(&quot;): 0x014F,</span>
<span class="gi">+    (&quot;O&quot;, &#39;&quot;&#39;): 0x0150,</span>
<span class="gi">+    (&quot;o&quot;, &#39;&quot;&#39;): 0x0151,</span>
<span class="gi">+    (&quot;O&quot;, &quot;E&quot;): 0x0152,</span>
<span class="gi">+    (&quot;o&quot;, &quot;e&quot;): 0x0153,</span>
<span class="gi">+    (&quot;R&quot;, &quot;&#39;&quot;): 0x0154,</span>
<span class="gi">+    (&quot;r&quot;, &quot;&#39;&quot;): 0x0155,</span>
<span class="gi">+    (&quot;R&quot;, &quot;,&quot;): 0x0156,</span>
<span class="gi">+    (&quot;r&quot;, &quot;,&quot;): 0x0157,</span>
<span class="gi">+    (&quot;R&quot;, &quot;&lt;&quot;): 0x0158,</span>
<span class="gi">+    (&quot;r&quot;, &quot;&lt;&quot;): 0x0159,</span>
<span class="gi">+    (&quot;S&quot;, &quot;&#39;&quot;): 0x015A,</span>
<span class="gi">+    (&quot;s&quot;, &quot;&#39;&quot;): 0x015B,</span>
<span class="gi">+    (&quot;S&quot;, &quot;&gt;&quot;): 0x015C,</span>
<span class="gi">+    (&quot;s&quot;, &quot;&gt;&quot;): 0x015D,</span>
<span class="gi">+    (&quot;S&quot;, &quot;,&quot;): 0x015E,</span>
<span class="gi">+    (&quot;s&quot;, &quot;,&quot;): 0x015F,</span>
<span class="gi">+    (&quot;S&quot;, &quot;&lt;&quot;): 0x0160,</span>
<span class="gi">+    (&quot;s&quot;, &quot;&lt;&quot;): 0x0161,</span>
<span class="gi">+    (&quot;T&quot;, &quot;,&quot;): 0x0162,</span>
<span class="gi">+    (&quot;t&quot;, &quot;,&quot;): 0x0163,</span>
<span class="gi">+    (&quot;T&quot;, &quot;&lt;&quot;): 0x0164,</span>
<span class="gi">+    (&quot;t&quot;, &quot;&lt;&quot;): 0x0165,</span>
<span class="gi">+    (&quot;T&quot;, &quot;/&quot;): 0x0166,</span>
<span class="gi">+    (&quot;t&quot;, &quot;/&quot;): 0x0167,</span>
<span class="gi">+    (&quot;U&quot;, &quot;?&quot;): 0x0168,</span>
<span class="gi">+    (&quot;u&quot;, &quot;?&quot;): 0x0169,</span>
<span class="gi">+    (&quot;U&quot;, &quot;-&quot;): 0x016A,</span>
<span class="gi">+    (&quot;u&quot;, &quot;-&quot;): 0x016B,</span>
<span class="gi">+    (&quot;U&quot;, &quot;(&quot;): 0x016C,</span>
<span class="gi">+    (&quot;u&quot;, &quot;(&quot;): 0x016D,</span>
<span class="gi">+    (&quot;U&quot;, &quot;0&quot;): 0x016E,</span>
<span class="gi">+    (&quot;u&quot;, &quot;0&quot;): 0x016F,</span>
<span class="gi">+    (&quot;U&quot;, &#39;&quot;&#39;): 0x0170,</span>
<span class="gi">+    (&quot;u&quot;, &#39;&quot;&#39;): 0x0171,</span>
<span class="gi">+    (&quot;U&quot;, &quot;;&quot;): 0x0172,</span>
<span class="gi">+    (&quot;u&quot;, &quot;;&quot;): 0x0173,</span>
<span class="gi">+    (&quot;W&quot;, &quot;&gt;&quot;): 0x0174,</span>
<span class="gi">+    (&quot;w&quot;, &quot;&gt;&quot;): 0x0175,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;&gt;&quot;): 0x0176,</span>
<span class="gi">+    (&quot;y&quot;, &quot;&gt;&quot;): 0x0177,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;:&quot;): 0x0178,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;&#39;&quot;): 0x0179,</span>
<span class="gi">+    (&quot;z&quot;, &quot;&#39;&quot;): 0x017A,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;.&quot;): 0x017B,</span>
<span class="gi">+    (&quot;z&quot;, &quot;.&quot;): 0x017C,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;&lt;&quot;): 0x017D,</span>
<span class="gi">+    (&quot;z&quot;, &quot;&lt;&quot;): 0x017E,</span>
<span class="gi">+    (&quot;O&quot;, &quot;9&quot;): 0x01A0,</span>
<span class="gi">+    (&quot;o&quot;, &quot;9&quot;): 0x01A1,</span>
<span class="gi">+    (&quot;O&quot;, &quot;I&quot;): 0x01A2,</span>
<span class="gi">+    (&quot;o&quot;, &quot;i&quot;): 0x01A3,</span>
<span class="gi">+    (&quot;y&quot;, &quot;r&quot;): 0x01A6,</span>
<span class="gi">+    (&quot;U&quot;, &quot;9&quot;): 0x01AF,</span>
<span class="gi">+    (&quot;u&quot;, &quot;9&quot;): 0x01B0,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;/&quot;): 0x01B5,</span>
<span class="gi">+    (&quot;z&quot;, &quot;/&quot;): 0x01B6,</span>
<span class="gi">+    (&quot;E&quot;, &quot;D&quot;): 0x01B7,</span>
<span class="gi">+    (&quot;A&quot;, &quot;&lt;&quot;): 0x01CD,</span>
<span class="gi">+    (&quot;a&quot;, &quot;&lt;&quot;): 0x01CE,</span>
<span class="gi">+    (&quot;I&quot;, &quot;&lt;&quot;): 0x01CF,</span>
<span class="gi">+    (&quot;i&quot;, &quot;&lt;&quot;): 0x01D0,</span>
<span class="gi">+    (&quot;O&quot;, &quot;&lt;&quot;): 0x01D1,</span>
<span class="gi">+    (&quot;o&quot;, &quot;&lt;&quot;): 0x01D2,</span>
<span class="gi">+    (&quot;U&quot;, &quot;&lt;&quot;): 0x01D3,</span>
<span class="gi">+    (&quot;u&quot;, &quot;&lt;&quot;): 0x01D4,</span>
<span class="gi">+    (&quot;A&quot;, &quot;1&quot;): 0x01DE,</span>
<span class="gi">+    (&quot;a&quot;, &quot;1&quot;): 0x01DF,</span>
<span class="gi">+    (&quot;A&quot;, &quot;7&quot;): 0x01E0,</span>
<span class="gi">+    (&quot;a&quot;, &quot;7&quot;): 0x01E1,</span>
<span class="gi">+    (&quot;A&quot;, &quot;3&quot;): 0x01E2,</span>
<span class="gi">+    (&quot;a&quot;, &quot;3&quot;): 0x01E3,</span>
<span class="gi">+    (&quot;G&quot;, &quot;/&quot;): 0x01E4,</span>
<span class="gi">+    (&quot;g&quot;, &quot;/&quot;): 0x01E5,</span>
<span class="gi">+    (&quot;G&quot;, &quot;&lt;&quot;): 0x01E6,</span>
<span class="gi">+    (&quot;g&quot;, &quot;&lt;&quot;): 0x01E7,</span>
<span class="gi">+    (&quot;K&quot;, &quot;&lt;&quot;): 0x01E8,</span>
<span class="gi">+    (&quot;k&quot;, &quot;&lt;&quot;): 0x01E9,</span>
<span class="gi">+    (&quot;O&quot;, &quot;;&quot;): 0x01EA,</span>
<span class="gi">+    (&quot;o&quot;, &quot;;&quot;): 0x01EB,</span>
<span class="gi">+    (&quot;O&quot;, &quot;1&quot;): 0x01EC,</span>
<span class="gi">+    (&quot;o&quot;, &quot;1&quot;): 0x01ED,</span>
<span class="gi">+    (&quot;E&quot;, &quot;Z&quot;): 0x01EE,</span>
<span class="gi">+    (&quot;e&quot;, &quot;z&quot;): 0x01EF,</span>
<span class="gi">+    (&quot;j&quot;, &quot;&lt;&quot;): 0x01F0,</span>
<span class="gi">+    (&quot;G&quot;, &quot;&#39;&quot;): 0x01F4,</span>
<span class="gi">+    (&quot;g&quot;, &quot;&#39;&quot;): 0x01F5,</span>
<span class="gi">+    (&quot;;&quot;, &quot;S&quot;): 0x02BF,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;&lt;&quot;): 0x02C7,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;(&quot;): 0x02D8,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;.&quot;): 0x02D9,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;0&quot;): 0x02DA,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;;&quot;): 0x02DB,</span>
<span class="gi">+    (&quot;&#39;&quot;, &#39;&quot;&#39;): 0x02DD,</span>
<span class="gi">+    (&quot;A&quot;, &quot;%&quot;): 0x0386,</span>
<span class="gi">+    (&quot;E&quot;, &quot;%&quot;): 0x0388,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;%&quot;): 0x0389,</span>
<span class="gi">+    (&quot;I&quot;, &quot;%&quot;): 0x038A,</span>
<span class="gi">+    (&quot;O&quot;, &quot;%&quot;): 0x038C,</span>
<span class="gi">+    (&quot;U&quot;, &quot;%&quot;): 0x038E,</span>
<span class="gi">+    (&quot;W&quot;, &quot;%&quot;): 0x038F,</span>
<span class="gi">+    (&quot;i&quot;, &quot;3&quot;): 0x0390,</span>
<span class="gi">+    (&quot;A&quot;, &quot;*&quot;): 0x0391,</span>
<span class="gi">+    (&quot;B&quot;, &quot;*&quot;): 0x0392,</span>
<span class="gi">+    (&quot;G&quot;, &quot;*&quot;): 0x0393,</span>
<span class="gi">+    (&quot;D&quot;, &quot;*&quot;): 0x0394,</span>
<span class="gi">+    (&quot;E&quot;, &quot;*&quot;): 0x0395,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;*&quot;): 0x0396,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;*&quot;): 0x0397,</span>
<span class="gi">+    (&quot;H&quot;, &quot;*&quot;): 0x0398,</span>
<span class="gi">+    (&quot;I&quot;, &quot;*&quot;): 0x0399,</span>
<span class="gi">+    (&quot;K&quot;, &quot;*&quot;): 0x039A,</span>
<span class="gi">+    (&quot;L&quot;, &quot;*&quot;): 0x039B,</span>
<span class="gi">+    (&quot;M&quot;, &quot;*&quot;): 0x039C,</span>
<span class="gi">+    (&quot;N&quot;, &quot;*&quot;): 0x039D,</span>
<span class="gi">+    (&quot;C&quot;, &quot;*&quot;): 0x039E,</span>
<span class="gi">+    (&quot;O&quot;, &quot;*&quot;): 0x039F,</span>
<span class="gi">+    (&quot;P&quot;, &quot;*&quot;): 0x03A0,</span>
<span class="gi">+    (&quot;R&quot;, &quot;*&quot;): 0x03A1,</span>
<span class="gi">+    (&quot;S&quot;, &quot;*&quot;): 0x03A3,</span>
<span class="gi">+    (&quot;T&quot;, &quot;*&quot;): 0x03A4,</span>
<span class="gi">+    (&quot;U&quot;, &quot;*&quot;): 0x03A5,</span>
<span class="gi">+    (&quot;F&quot;, &quot;*&quot;): 0x03A6,</span>
<span class="gi">+    (&quot;X&quot;, &quot;*&quot;): 0x03A7,</span>
<span class="gi">+    (&quot;Q&quot;, &quot;*&quot;): 0x03A8,</span>
<span class="gi">+    (&quot;W&quot;, &quot;*&quot;): 0x03A9,</span>
<span class="gi">+    (&quot;J&quot;, &quot;*&quot;): 0x03AA,</span>
<span class="gi">+    (&quot;V&quot;, &quot;*&quot;): 0x03AB,</span>
<span class="gi">+    (&quot;a&quot;, &quot;%&quot;): 0x03AC,</span>
<span class="gi">+    (&quot;e&quot;, &quot;%&quot;): 0x03AD,</span>
<span class="gi">+    (&quot;y&quot;, &quot;%&quot;): 0x03AE,</span>
<span class="gi">+    (&quot;i&quot;, &quot;%&quot;): 0x03AF,</span>
<span class="gi">+    (&quot;u&quot;, &quot;3&quot;): 0x03B0,</span>
<span class="gi">+    (&quot;a&quot;, &quot;*&quot;): 0x03B1,</span>
<span class="gi">+    (&quot;b&quot;, &quot;*&quot;): 0x03B2,</span>
<span class="gi">+    (&quot;g&quot;, &quot;*&quot;): 0x03B3,</span>
<span class="gi">+    (&quot;d&quot;, &quot;*&quot;): 0x03B4,</span>
<span class="gi">+    (&quot;e&quot;, &quot;*&quot;): 0x03B5,</span>
<span class="gi">+    (&quot;z&quot;, &quot;*&quot;): 0x03B6,</span>
<span class="gi">+    (&quot;y&quot;, &quot;*&quot;): 0x03B7,</span>
<span class="gi">+    (&quot;h&quot;, &quot;*&quot;): 0x03B8,</span>
<span class="gi">+    (&quot;i&quot;, &quot;*&quot;): 0x03B9,</span>
<span class="gi">+    (&quot;k&quot;, &quot;*&quot;): 0x03BA,</span>
<span class="gi">+    (&quot;l&quot;, &quot;*&quot;): 0x03BB,</span>
<span class="gi">+    (&quot;m&quot;, &quot;*&quot;): 0x03BC,</span>
<span class="gi">+    (&quot;n&quot;, &quot;*&quot;): 0x03BD,</span>
<span class="gi">+    (&quot;c&quot;, &quot;*&quot;): 0x03BE,</span>
<span class="gi">+    (&quot;o&quot;, &quot;*&quot;): 0x03BF,</span>
<span class="gi">+    (&quot;p&quot;, &quot;*&quot;): 0x03C0,</span>
<span class="gi">+    (&quot;r&quot;, &quot;*&quot;): 0x03C1,</span>
<span class="gi">+    (&quot;*&quot;, &quot;s&quot;): 0x03C2,</span>
<span class="gi">+    (&quot;s&quot;, &quot;*&quot;): 0x03C3,</span>
<span class="gi">+    (&quot;t&quot;, &quot;*&quot;): 0x03C4,</span>
<span class="gi">+    (&quot;u&quot;, &quot;*&quot;): 0x03C5,</span>
<span class="gi">+    (&quot;f&quot;, &quot;*&quot;): 0x03C6,</span>
<span class="gi">+    (&quot;x&quot;, &quot;*&quot;): 0x03C7,</span>
<span class="gi">+    (&quot;q&quot;, &quot;*&quot;): 0x03C8,</span>
<span class="gi">+    (&quot;w&quot;, &quot;*&quot;): 0x03C9,</span>
<span class="gi">+    (&quot;j&quot;, &quot;*&quot;): 0x03CA,</span>
<span class="gi">+    (&quot;v&quot;, &quot;*&quot;): 0x03CB,</span>
<span class="gi">+    (&quot;o&quot;, &quot;%&quot;): 0x03CC,</span>
<span class="gi">+    (&quot;u&quot;, &quot;%&quot;): 0x03CD,</span>
<span class="gi">+    (&quot;w&quot;, &quot;%&quot;): 0x03CE,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;G&quot;): 0x03D8,</span>
<span class="gi">+    (&quot;,&quot;, &quot;G&quot;): 0x03D9,</span>
<span class="gi">+    (&quot;T&quot;, &quot;3&quot;): 0x03DA,</span>
<span class="gi">+    (&quot;t&quot;, &quot;3&quot;): 0x03DB,</span>
<span class="gi">+    (&quot;M&quot;, &quot;3&quot;): 0x03DC,</span>
<span class="gi">+    (&quot;m&quot;, &quot;3&quot;): 0x03DD,</span>
<span class="gi">+    (&quot;K&quot;, &quot;3&quot;): 0x03DE,</span>
<span class="gi">+    (&quot;k&quot;, &quot;3&quot;): 0x03DF,</span>
<span class="gi">+    (&quot;P&quot;, &quot;3&quot;): 0x03E0,</span>
<span class="gi">+    (&quot;p&quot;, &quot;3&quot;): 0x03E1,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;%&quot;): 0x03F4,</span>
<span class="gi">+    (&quot;j&quot;, &quot;3&quot;): 0x03F5,</span>
<span class="gi">+    (&quot;I&quot;, &quot;O&quot;): 0x0401,</span>
<span class="gi">+    (&quot;D&quot;, &quot;%&quot;): 0x0402,</span>
<span class="gi">+    (&quot;G&quot;, &quot;%&quot;): 0x0403,</span>
<span class="gi">+    (&quot;I&quot;, &quot;E&quot;): 0x0404,</span>
<span class="gi">+    (&quot;D&quot;, &quot;S&quot;): 0x0405,</span>
<span class="gi">+    (&quot;I&quot;, &quot;I&quot;): 0x0406,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;I&quot;): 0x0407,</span>
<span class="gi">+    (&quot;J&quot;, &quot;%&quot;): 0x0408,</span>
<span class="gi">+    (&quot;L&quot;, &quot;J&quot;): 0x0409,</span>
<span class="gi">+    (&quot;N&quot;, &quot;J&quot;): 0x040A,</span>
<span class="gi">+    (&quot;T&quot;, &quot;s&quot;): 0x040B,</span>
<span class="gi">+    (&quot;K&quot;, &quot;J&quot;): 0x040C,</span>
<span class="gi">+    (&quot;V&quot;, &quot;%&quot;): 0x040E,</span>
<span class="gi">+    (&quot;D&quot;, &quot;Z&quot;): 0x040F,</span>
<span class="gi">+    (&quot;A&quot;, &quot;=&quot;): 0x0410,</span>
<span class="gi">+    (&quot;B&quot;, &quot;=&quot;): 0x0411,</span>
<span class="gi">+    (&quot;V&quot;, &quot;=&quot;): 0x0412,</span>
<span class="gi">+    (&quot;G&quot;, &quot;=&quot;): 0x0413,</span>
<span class="gi">+    (&quot;D&quot;, &quot;=&quot;): 0x0414,</span>
<span class="gi">+    (&quot;E&quot;, &quot;=&quot;): 0x0415,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;%&quot;): 0x0416,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;=&quot;): 0x0417,</span>
<span class="gi">+    (&quot;I&quot;, &quot;=&quot;): 0x0418,</span>
<span class="gi">+    (&quot;J&quot;, &quot;=&quot;): 0x0419,</span>
<span class="gi">+    (&quot;K&quot;, &quot;=&quot;): 0x041A,</span>
<span class="gi">+    (&quot;L&quot;, &quot;=&quot;): 0x041B,</span>
<span class="gi">+    (&quot;M&quot;, &quot;=&quot;): 0x041C,</span>
<span class="gi">+    (&quot;N&quot;, &quot;=&quot;): 0x041D,</span>
<span class="gi">+    (&quot;O&quot;, &quot;=&quot;): 0x041E,</span>
<span class="gi">+    (&quot;P&quot;, &quot;=&quot;): 0x041F,</span>
<span class="gi">+    (&quot;R&quot;, &quot;=&quot;): 0x0420,</span>
<span class="gi">+    (&quot;S&quot;, &quot;=&quot;): 0x0421,</span>
<span class="gi">+    (&quot;T&quot;, &quot;=&quot;): 0x0422,</span>
<span class="gi">+    (&quot;U&quot;, &quot;=&quot;): 0x0423,</span>
<span class="gi">+    (&quot;F&quot;, &quot;=&quot;): 0x0424,</span>
<span class="gi">+    (&quot;H&quot;, &quot;=&quot;): 0x0425,</span>
<span class="gi">+    (&quot;C&quot;, &quot;=&quot;): 0x0426,</span>
<span class="gi">+    (&quot;C&quot;, &quot;%&quot;): 0x0427,</span>
<span class="gi">+    (&quot;S&quot;, &quot;%&quot;): 0x0428,</span>
<span class="gi">+    (&quot;S&quot;, &quot;c&quot;): 0x0429,</span>
<span class="gi">+    (&quot;=&quot;, &#39;&quot;&#39;): 0x042A,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;=&quot;): 0x042B,</span>
<span class="gi">+    (&quot;%&quot;, &#39;&quot;&#39;): 0x042C,</span>
<span class="gi">+    (&quot;J&quot;, &quot;E&quot;): 0x042D,</span>
<span class="gi">+    (&quot;J&quot;, &quot;U&quot;): 0x042E,</span>
<span class="gi">+    (&quot;J&quot;, &quot;A&quot;): 0x042F,</span>
<span class="gi">+    (&quot;a&quot;, &quot;=&quot;): 0x0430,</span>
<span class="gi">+    (&quot;b&quot;, &quot;=&quot;): 0x0431,</span>
<span class="gi">+    (&quot;v&quot;, &quot;=&quot;): 0x0432,</span>
<span class="gi">+    (&quot;g&quot;, &quot;=&quot;): 0x0433,</span>
<span class="gi">+    (&quot;d&quot;, &quot;=&quot;): 0x0434,</span>
<span class="gi">+    (&quot;e&quot;, &quot;=&quot;): 0x0435,</span>
<span class="gi">+    (&quot;z&quot;, &quot;%&quot;): 0x0436,</span>
<span class="gi">+    (&quot;z&quot;, &quot;=&quot;): 0x0437,</span>
<span class="gi">+    (&quot;i&quot;, &quot;=&quot;): 0x0438,</span>
<span class="gi">+    (&quot;j&quot;, &quot;=&quot;): 0x0439,</span>
<span class="gi">+    (&quot;k&quot;, &quot;=&quot;): 0x043A,</span>
<span class="gi">+    (&quot;l&quot;, &quot;=&quot;): 0x043B,</span>
<span class="gi">+    (&quot;m&quot;, &quot;=&quot;): 0x043C,</span>
<span class="gi">+    (&quot;n&quot;, &quot;=&quot;): 0x043D,</span>
<span class="gi">+    (&quot;o&quot;, &quot;=&quot;): 0x043E,</span>
<span class="gi">+    (&quot;p&quot;, &quot;=&quot;): 0x043F,</span>
<span class="gi">+    (&quot;r&quot;, &quot;=&quot;): 0x0440,</span>
<span class="gi">+    (&quot;s&quot;, &quot;=&quot;): 0x0441,</span>
<span class="gi">+    (&quot;t&quot;, &quot;=&quot;): 0x0442,</span>
<span class="gi">+    (&quot;u&quot;, &quot;=&quot;): 0x0443,</span>
<span class="gi">+    (&quot;f&quot;, &quot;=&quot;): 0x0444,</span>
<span class="gi">+    (&quot;h&quot;, &quot;=&quot;): 0x0445,</span>
<span class="gi">+    (&quot;c&quot;, &quot;=&quot;): 0x0446,</span>
<span class="gi">+    (&quot;c&quot;, &quot;%&quot;): 0x0447,</span>
<span class="gi">+    (&quot;s&quot;, &quot;%&quot;): 0x0448,</span>
<span class="gi">+    (&quot;s&quot;, &quot;c&quot;): 0x0449,</span>
<span class="gi">+    (&quot;=&quot;, &quot;&#39;&quot;): 0x044A,</span>
<span class="gi">+    (&quot;y&quot;, &quot;=&quot;): 0x044B,</span>
<span class="gi">+    (&quot;%&quot;, &quot;&#39;&quot;): 0x044C,</span>
<span class="gi">+    (&quot;j&quot;, &quot;e&quot;): 0x044D,</span>
<span class="gi">+    (&quot;j&quot;, &quot;u&quot;): 0x044E,</span>
<span class="gi">+    (&quot;j&quot;, &quot;a&quot;): 0x044F,</span>
<span class="gi">+    (&quot;i&quot;, &quot;o&quot;): 0x0451,</span>
<span class="gi">+    (&quot;d&quot;, &quot;%&quot;): 0x0452,</span>
<span class="gi">+    (&quot;g&quot;, &quot;%&quot;): 0x0453,</span>
<span class="gi">+    (&quot;i&quot;, &quot;e&quot;): 0x0454,</span>
<span class="gi">+    (&quot;d&quot;, &quot;s&quot;): 0x0455,</span>
<span class="gi">+    (&quot;i&quot;, &quot;i&quot;): 0x0456,</span>
<span class="gi">+    (&quot;y&quot;, &quot;i&quot;): 0x0457,</span>
<span class="gi">+    (&quot;j&quot;, &quot;%&quot;): 0x0458,</span>
<span class="gi">+    (&quot;l&quot;, &quot;j&quot;): 0x0459,</span>
<span class="gi">+    (&quot;n&quot;, &quot;j&quot;): 0x045A,</span>
<span class="gi">+    (&quot;t&quot;, &quot;s&quot;): 0x045B,</span>
<span class="gi">+    (&quot;k&quot;, &quot;j&quot;): 0x045C,</span>
<span class="gi">+    (&quot;v&quot;, &quot;%&quot;): 0x045E,</span>
<span class="gi">+    (&quot;d&quot;, &quot;z&quot;): 0x045F,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;3&quot;): 0x0462,</span>
<span class="gi">+    (&quot;y&quot;, &quot;3&quot;): 0x0463,</span>
<span class="gi">+    (&quot;O&quot;, &quot;3&quot;): 0x046A,</span>
<span class="gi">+    (&quot;o&quot;, &quot;3&quot;): 0x046B,</span>
<span class="gi">+    (&quot;F&quot;, &quot;3&quot;): 0x0472,</span>
<span class="gi">+    (&quot;f&quot;, &quot;3&quot;): 0x0473,</span>
<span class="gi">+    (&quot;V&quot;, &quot;3&quot;): 0x0474,</span>
<span class="gi">+    (&quot;v&quot;, &quot;3&quot;): 0x0475,</span>
<span class="gi">+    (&quot;C&quot;, &quot;3&quot;): 0x0480,</span>
<span class="gi">+    (&quot;c&quot;, &quot;3&quot;): 0x0481,</span>
<span class="gi">+    (&quot;G&quot;, &quot;3&quot;): 0x0490,</span>
<span class="gi">+    (&quot;g&quot;, &quot;3&quot;): 0x0491,</span>
<span class="gi">+    (&quot;A&quot;, &quot;+&quot;): 0x05D0,</span>
<span class="gi">+    (&quot;B&quot;, &quot;+&quot;): 0x05D1,</span>
<span class="gi">+    (&quot;G&quot;, &quot;+&quot;): 0x05D2,</span>
<span class="gi">+    (&quot;D&quot;, &quot;+&quot;): 0x05D3,</span>
<span class="gi">+    (&quot;H&quot;, &quot;+&quot;): 0x05D4,</span>
<span class="gi">+    (&quot;W&quot;, &quot;+&quot;): 0x05D5,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;+&quot;): 0x05D6,</span>
<span class="gi">+    (&quot;X&quot;, &quot;+&quot;): 0x05D7,</span>
<span class="gi">+    (&quot;T&quot;, &quot;j&quot;): 0x05D8,</span>
<span class="gi">+    (&quot;J&quot;, &quot;+&quot;): 0x05D9,</span>
<span class="gi">+    (&quot;K&quot;, &quot;%&quot;): 0x05DA,</span>
<span class="gi">+    (&quot;K&quot;, &quot;+&quot;): 0x05DB,</span>
<span class="gi">+    (&quot;L&quot;, &quot;+&quot;): 0x05DC,</span>
<span class="gi">+    (&quot;M&quot;, &quot;%&quot;): 0x05DD,</span>
<span class="gi">+    (&quot;M&quot;, &quot;+&quot;): 0x05DE,</span>
<span class="gi">+    (&quot;N&quot;, &quot;%&quot;): 0x05DF,</span>
<span class="gi">+    (&quot;N&quot;, &quot;+&quot;): 0x05E0,</span>
<span class="gi">+    (&quot;S&quot;, &quot;+&quot;): 0x05E1,</span>
<span class="gi">+    (&quot;E&quot;, &quot;+&quot;): 0x05E2,</span>
<span class="gi">+    (&quot;P&quot;, &quot;%&quot;): 0x05E3,</span>
<span class="gi">+    (&quot;P&quot;, &quot;+&quot;): 0x05E4,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;j&quot;): 0x05E5,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;J&quot;): 0x05E6,</span>
<span class="gi">+    (&quot;Q&quot;, &quot;+&quot;): 0x05E7,</span>
<span class="gi">+    (&quot;R&quot;, &quot;+&quot;): 0x05E8,</span>
<span class="gi">+    (&quot;S&quot;, &quot;h&quot;): 0x05E9,</span>
<span class="gi">+    (&quot;T&quot;, &quot;+&quot;): 0x05EA,</span>
<span class="gi">+    (&quot;,&quot;, &quot;+&quot;): 0x060C,</span>
<span class="gi">+    (&quot;;&quot;, &quot;+&quot;): 0x061B,</span>
<span class="gi">+    (&quot;?&quot;, &quot;+&quot;): 0x061F,</span>
<span class="gi">+    (&quot;H&quot;, &quot;&#39;&quot;): 0x0621,</span>
<span class="gi">+    (&quot;a&quot;, &quot;M&quot;): 0x0622,</span>
<span class="gi">+    (&quot;a&quot;, &quot;H&quot;): 0x0623,</span>
<span class="gi">+    (&quot;w&quot;, &quot;H&quot;): 0x0624,</span>
<span class="gi">+    (&quot;a&quot;, &quot;h&quot;): 0x0625,</span>
<span class="gi">+    (&quot;y&quot;, &quot;H&quot;): 0x0626,</span>
<span class="gi">+    (&quot;a&quot;, &quot;+&quot;): 0x0627,</span>
<span class="gi">+    (&quot;b&quot;, &quot;+&quot;): 0x0628,</span>
<span class="gi">+    (&quot;t&quot;, &quot;m&quot;): 0x0629,</span>
<span class="gi">+    (&quot;t&quot;, &quot;+&quot;): 0x062A,</span>
<span class="gi">+    (&quot;t&quot;, &quot;k&quot;): 0x062B,</span>
<span class="gi">+    (&quot;g&quot;, &quot;+&quot;): 0x062C,</span>
<span class="gi">+    (&quot;h&quot;, &quot;k&quot;): 0x062D,</span>
<span class="gi">+    (&quot;x&quot;, &quot;+&quot;): 0x062E,</span>
<span class="gi">+    (&quot;d&quot;, &quot;+&quot;): 0x062F,</span>
<span class="gi">+    (&quot;d&quot;, &quot;k&quot;): 0x0630,</span>
<span class="gi">+    (&quot;r&quot;, &quot;+&quot;): 0x0631,</span>
<span class="gi">+    (&quot;z&quot;, &quot;+&quot;): 0x0632,</span>
<span class="gi">+    (&quot;s&quot;, &quot;+&quot;): 0x0633,</span>
<span class="gi">+    (&quot;s&quot;, &quot;n&quot;): 0x0634,</span>
<span class="gi">+    (&quot;c&quot;, &quot;+&quot;): 0x0635,</span>
<span class="gi">+    (&quot;d&quot;, &quot;d&quot;): 0x0636,</span>
<span class="gi">+    (&quot;t&quot;, &quot;j&quot;): 0x0637,</span>
<span class="gi">+    (&quot;z&quot;, &quot;H&quot;): 0x0638,</span>
<span class="gi">+    (&quot;e&quot;, &quot;+&quot;): 0x0639,</span>
<span class="gi">+    (&quot;i&quot;, &quot;+&quot;): 0x063A,</span>
<span class="gi">+    (&quot;+&quot;, &quot;+&quot;): 0x0640,</span>
<span class="gi">+    (&quot;f&quot;, &quot;+&quot;): 0x0641,</span>
<span class="gi">+    (&quot;q&quot;, &quot;+&quot;): 0x0642,</span>
<span class="gi">+    (&quot;k&quot;, &quot;+&quot;): 0x0643,</span>
<span class="gi">+    (&quot;l&quot;, &quot;+&quot;): 0x0644,</span>
<span class="gi">+    (&quot;m&quot;, &quot;+&quot;): 0x0645,</span>
<span class="gi">+    (&quot;n&quot;, &quot;+&quot;): 0x0646,</span>
<span class="gi">+    (&quot;h&quot;, &quot;+&quot;): 0x0647,</span>
<span class="gi">+    (&quot;w&quot;, &quot;+&quot;): 0x0648,</span>
<span class="gi">+    (&quot;j&quot;, &quot;+&quot;): 0x0649,</span>
<span class="gi">+    (&quot;y&quot;, &quot;+&quot;): 0x064A,</span>
<span class="gi">+    (&quot;:&quot;, &quot;+&quot;): 0x064B,</span>
<span class="gi">+    (&#39;&quot;&#39;, &quot;+&quot;): 0x064C,</span>
<span class="gi">+    (&quot;=&quot;, &quot;+&quot;): 0x064D,</span>
<span class="gi">+    (&quot;/&quot;, &quot;+&quot;): 0x064E,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;+&quot;): 0x064F,</span>
<span class="gi">+    (&quot;1&quot;, &quot;+&quot;): 0x0650,</span>
<span class="gi">+    (&quot;3&quot;, &quot;+&quot;): 0x0651,</span>
<span class="gi">+    (&quot;0&quot;, &quot;+&quot;): 0x0652,</span>
<span class="gi">+    (&quot;a&quot;, &quot;S&quot;): 0x0670,</span>
<span class="gi">+    (&quot;p&quot;, &quot;+&quot;): 0x067E,</span>
<span class="gi">+    (&quot;v&quot;, &quot;+&quot;): 0x06A4,</span>
<span class="gi">+    (&quot;g&quot;, &quot;f&quot;): 0x06AF,</span>
<span class="gi">+    (&quot;0&quot;, &quot;a&quot;): 0x06F0,</span>
<span class="gi">+    (&quot;1&quot;, &quot;a&quot;): 0x06F1,</span>
<span class="gi">+    (&quot;2&quot;, &quot;a&quot;): 0x06F2,</span>
<span class="gi">+    (&quot;3&quot;, &quot;a&quot;): 0x06F3,</span>
<span class="gi">+    (&quot;4&quot;, &quot;a&quot;): 0x06F4,</span>
<span class="gi">+    (&quot;5&quot;, &quot;a&quot;): 0x06F5,</span>
<span class="gi">+    (&quot;6&quot;, &quot;a&quot;): 0x06F6,</span>
<span class="gi">+    (&quot;7&quot;, &quot;a&quot;): 0x06F7,</span>
<span class="gi">+    (&quot;8&quot;, &quot;a&quot;): 0x06F8,</span>
<span class="gi">+    (&quot;9&quot;, &quot;a&quot;): 0x06F9,</span>
<span class="gi">+    (&quot;B&quot;, &quot;.&quot;): 0x1E02,</span>
<span class="gi">+    (&quot;b&quot;, &quot;.&quot;): 0x1E03,</span>
<span class="gi">+    (&quot;B&quot;, &quot;_&quot;): 0x1E06,</span>
<span class="gi">+    (&quot;b&quot;, &quot;_&quot;): 0x1E07,</span>
<span class="gi">+    (&quot;D&quot;, &quot;.&quot;): 0x1E0A,</span>
<span class="gi">+    (&quot;d&quot;, &quot;.&quot;): 0x1E0B,</span>
<span class="gi">+    (&quot;D&quot;, &quot;_&quot;): 0x1E0E,</span>
<span class="gi">+    (&quot;d&quot;, &quot;_&quot;): 0x1E0F,</span>
<span class="gi">+    (&quot;D&quot;, &quot;,&quot;): 0x1E10,</span>
<span class="gi">+    (&quot;d&quot;, &quot;,&quot;): 0x1E11,</span>
<span class="gi">+    (&quot;F&quot;, &quot;.&quot;): 0x1E1E,</span>
<span class="gi">+    (&quot;f&quot;, &quot;.&quot;): 0x1E1F,</span>
<span class="gi">+    (&quot;G&quot;, &quot;-&quot;): 0x1E20,</span>
<span class="gi">+    (&quot;g&quot;, &quot;-&quot;): 0x1E21,</span>
<span class="gi">+    (&quot;H&quot;, &quot;.&quot;): 0x1E22,</span>
<span class="gi">+    (&quot;h&quot;, &quot;.&quot;): 0x1E23,</span>
<span class="gi">+    (&quot;H&quot;, &quot;:&quot;): 0x1E26,</span>
<span class="gi">+    (&quot;h&quot;, &quot;:&quot;): 0x1E27,</span>
<span class="gi">+    (&quot;H&quot;, &quot;,&quot;): 0x1E28,</span>
<span class="gi">+    (&quot;h&quot;, &quot;,&quot;): 0x1E29,</span>
<span class="gi">+    (&quot;K&quot;, &quot;&#39;&quot;): 0x1E30,</span>
<span class="gi">+    (&quot;k&quot;, &quot;&#39;&quot;): 0x1E31,</span>
<span class="gi">+    (&quot;K&quot;, &quot;_&quot;): 0x1E34,</span>
<span class="gi">+    (&quot;k&quot;, &quot;_&quot;): 0x1E35,</span>
<span class="gi">+    (&quot;L&quot;, &quot;_&quot;): 0x1E3A,</span>
<span class="gi">+    (&quot;l&quot;, &quot;_&quot;): 0x1E3B,</span>
<span class="gi">+    (&quot;M&quot;, &quot;&#39;&quot;): 0x1E3E,</span>
<span class="gi">+    (&quot;m&quot;, &quot;&#39;&quot;): 0x1E3F,</span>
<span class="gi">+    (&quot;M&quot;, &quot;.&quot;): 0x1E40,</span>
<span class="gi">+    (&quot;m&quot;, &quot;.&quot;): 0x1E41,</span>
<span class="gi">+    (&quot;N&quot;, &quot;.&quot;): 0x1E44,</span>
<span class="gi">+    (&quot;n&quot;, &quot;.&quot;): 0x1E45,</span>
<span class="gi">+    (&quot;N&quot;, &quot;_&quot;): 0x1E48,</span>
<span class="gi">+    (&quot;n&quot;, &quot;_&quot;): 0x1E49,</span>
<span class="gi">+    (&quot;P&quot;, &quot;&#39;&quot;): 0x1E54,</span>
<span class="gi">+    (&quot;p&quot;, &quot;&#39;&quot;): 0x1E55,</span>
<span class="gi">+    (&quot;P&quot;, &quot;.&quot;): 0x1E56,</span>
<span class="gi">+    (&quot;p&quot;, &quot;.&quot;): 0x1E57,</span>
<span class="gi">+    (&quot;R&quot;, &quot;.&quot;): 0x1E58,</span>
<span class="gi">+    (&quot;r&quot;, &quot;.&quot;): 0x1E59,</span>
<span class="gi">+    (&quot;R&quot;, &quot;_&quot;): 0x1E5E,</span>
<span class="gi">+    (&quot;r&quot;, &quot;_&quot;): 0x1E5F,</span>
<span class="gi">+    (&quot;S&quot;, &quot;.&quot;): 0x1E60,</span>
<span class="gi">+    (&quot;s&quot;, &quot;.&quot;): 0x1E61,</span>
<span class="gi">+    (&quot;T&quot;, &quot;.&quot;): 0x1E6A,</span>
<span class="gi">+    (&quot;t&quot;, &quot;.&quot;): 0x1E6B,</span>
<span class="gi">+    (&quot;T&quot;, &quot;_&quot;): 0x1E6E,</span>
<span class="gi">+    (&quot;t&quot;, &quot;_&quot;): 0x1E6F,</span>
<span class="gi">+    (&quot;V&quot;, &quot;?&quot;): 0x1E7C,</span>
<span class="gi">+    (&quot;v&quot;, &quot;?&quot;): 0x1E7D,</span>
<span class="gi">+    (&quot;W&quot;, &quot;!&quot;): 0x1E80,</span>
<span class="gi">+    (&quot;w&quot;, &quot;!&quot;): 0x1E81,</span>
<span class="gi">+    (&quot;W&quot;, &quot;&#39;&quot;): 0x1E82,</span>
<span class="gi">+    (&quot;w&quot;, &quot;&#39;&quot;): 0x1E83,</span>
<span class="gi">+    (&quot;W&quot;, &quot;:&quot;): 0x1E84,</span>
<span class="gi">+    (&quot;w&quot;, &quot;:&quot;): 0x1E85,</span>
<span class="gi">+    (&quot;W&quot;, &quot;.&quot;): 0x1E86,</span>
<span class="gi">+    (&quot;w&quot;, &quot;.&quot;): 0x1E87,</span>
<span class="gi">+    (&quot;X&quot;, &quot;.&quot;): 0x1E8A,</span>
<span class="gi">+    (&quot;x&quot;, &quot;.&quot;): 0x1E8B,</span>
<span class="gi">+    (&quot;X&quot;, &quot;:&quot;): 0x1E8C,</span>
<span class="gi">+    (&quot;x&quot;, &quot;:&quot;): 0x1E8D,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;.&quot;): 0x1E8E,</span>
<span class="gi">+    (&quot;y&quot;, &quot;.&quot;): 0x1E8F,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;&gt;&quot;): 0x1E90,</span>
<span class="gi">+    (&quot;z&quot;, &quot;&gt;&quot;): 0x1E91,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;_&quot;): 0x1E94,</span>
<span class="gi">+    (&quot;z&quot;, &quot;_&quot;): 0x1E95,</span>
<span class="gi">+    (&quot;h&quot;, &quot;_&quot;): 0x1E96,</span>
<span class="gi">+    (&quot;t&quot;, &quot;:&quot;): 0x1E97,</span>
<span class="gi">+    (&quot;w&quot;, &quot;0&quot;): 0x1E98,</span>
<span class="gi">+    (&quot;y&quot;, &quot;0&quot;): 0x1E99,</span>
<span class="gi">+    (&quot;A&quot;, &quot;2&quot;): 0x1EA2,</span>
<span class="gi">+    (&quot;a&quot;, &quot;2&quot;): 0x1EA3,</span>
<span class="gi">+    (&quot;E&quot;, &quot;2&quot;): 0x1EBA,</span>
<span class="gi">+    (&quot;e&quot;, &quot;2&quot;): 0x1EBB,</span>
<span class="gi">+    (&quot;E&quot;, &quot;?&quot;): 0x1EBC,</span>
<span class="gi">+    (&quot;e&quot;, &quot;?&quot;): 0x1EBD,</span>
<span class="gi">+    (&quot;I&quot;, &quot;2&quot;): 0x1EC8,</span>
<span class="gi">+    (&quot;i&quot;, &quot;2&quot;): 0x1EC9,</span>
<span class="gi">+    (&quot;O&quot;, &quot;2&quot;): 0x1ECE,</span>
<span class="gi">+    (&quot;o&quot;, &quot;2&quot;): 0x1ECF,</span>
<span class="gi">+    (&quot;U&quot;, &quot;2&quot;): 0x1EE6,</span>
<span class="gi">+    (&quot;u&quot;, &quot;2&quot;): 0x1EE7,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;!&quot;): 0x1EF2,</span>
<span class="gi">+    (&quot;y&quot;, &quot;!&quot;): 0x1EF3,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;2&quot;): 0x1EF6,</span>
<span class="gi">+    (&quot;y&quot;, &quot;2&quot;): 0x1EF7,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;?&quot;): 0x1EF8,</span>
<span class="gi">+    (&quot;y&quot;, &quot;?&quot;): 0x1EF9,</span>
<span class="gi">+    (&quot;;&quot;, &quot;&#39;&quot;): 0x1F00,</span>
<span class="gi">+    (&quot;,&quot;, &quot;&#39;&quot;): 0x1F01,</span>
<span class="gi">+    (&quot;;&quot;, &quot;!&quot;): 0x1F02,</span>
<span class="gi">+    (&quot;,&quot;, &quot;!&quot;): 0x1F03,</span>
<span class="gi">+    (&quot;?&quot;, &quot;;&quot;): 0x1F04,</span>
<span class="gi">+    (&quot;?&quot;, &quot;,&quot;): 0x1F05,</span>
<span class="gi">+    (&quot;!&quot;, &quot;:&quot;): 0x1F06,</span>
<span class="gi">+    (&quot;?&quot;, &quot;:&quot;): 0x1F07,</span>
<span class="gi">+    (&quot;1&quot;, &quot;N&quot;): 0x2002,</span>
<span class="gi">+    (&quot;1&quot;, &quot;M&quot;): 0x2003,</span>
<span class="gi">+    (&quot;3&quot;, &quot;M&quot;): 0x2004,</span>
<span class="gi">+    (&quot;4&quot;, &quot;M&quot;): 0x2005,</span>
<span class="gi">+    (&quot;6&quot;, &quot;M&quot;): 0x2006,</span>
<span class="gi">+    (&quot;1&quot;, &quot;T&quot;): 0x2009,</span>
<span class="gi">+    (&quot;1&quot;, &quot;H&quot;): 0x200A,</span>
<span class="gi">+    (&quot;-&quot;, &quot;1&quot;): 0x2010,</span>
<span class="gi">+    (&quot;-&quot;, &quot;N&quot;): 0x2013,</span>
<span class="gi">+    (&quot;-&quot;, &quot;M&quot;): 0x2014,</span>
<span class="gi">+    (&quot;-&quot;, &quot;3&quot;): 0x2015,</span>
<span class="gi">+    (&quot;!&quot;, &quot;2&quot;): 0x2016,</span>
<span class="gi">+    (&quot;=&quot;, &quot;2&quot;): 0x2017,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;6&quot;): 0x2018,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;9&quot;): 0x2019,</span>
<span class="gi">+    (&quot;.&quot;, &quot;9&quot;): 0x201A,</span>
<span class="gi">+    (&quot;9&quot;, &quot;&#39;&quot;): 0x201B,</span>
<span class="gi">+    (&#39;&quot;&#39;, &quot;6&quot;): 0x201C,</span>
<span class="gi">+    (&#39;&quot;&#39;, &quot;9&quot;): 0x201D,</span>
<span class="gi">+    (&quot;:&quot;, &quot;9&quot;): 0x201E,</span>
<span class="gi">+    (&quot;9&quot;, &#39;&quot;&#39;): 0x201F,</span>
<span class="gi">+    (&quot;/&quot;, &quot;-&quot;): 0x2020,</span>
<span class="gi">+    (&quot;/&quot;, &quot;=&quot;): 0x2021,</span>
<span class="gi">+    (&quot;.&quot;, &quot;.&quot;): 0x2025,</span>
<span class="gi">+    (&quot;%&quot;, &quot;0&quot;): 0x2030,</span>
<span class="gi">+    (&quot;1&quot;, &quot;&#39;&quot;): 0x2032,</span>
<span class="gi">+    (&quot;2&quot;, &quot;&#39;&quot;): 0x2033,</span>
<span class="gi">+    (&quot;3&quot;, &quot;&#39;&quot;): 0x2034,</span>
<span class="gi">+    (&quot;1&quot;, &#39;&quot;&#39;): 0x2035,</span>
<span class="gi">+    (&quot;2&quot;, &#39;&quot;&#39;): 0x2036,</span>
<span class="gi">+    (&quot;3&quot;, &#39;&quot;&#39;): 0x2037,</span>
<span class="gi">+    (&quot;C&quot;, &quot;a&quot;): 0x2038,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;1&quot;): 0x2039,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;1&quot;): 0x203A,</span>
<span class="gi">+    (&quot;:&quot;, &quot;X&quot;): 0x203B,</span>
<span class="gi">+    (&quot;&#39;&quot;, &quot;-&quot;): 0x203E,</span>
<span class="gi">+    (&quot;/&quot;, &quot;f&quot;): 0x2044,</span>
<span class="gi">+    (&quot;0&quot;, &quot;S&quot;): 0x2070,</span>
<span class="gi">+    (&quot;4&quot;, &quot;S&quot;): 0x2074,</span>
<span class="gi">+    (&quot;5&quot;, &quot;S&quot;): 0x2075,</span>
<span class="gi">+    (&quot;6&quot;, &quot;S&quot;): 0x2076,</span>
<span class="gi">+    (&quot;7&quot;, &quot;S&quot;): 0x2077,</span>
<span class="gi">+    (&quot;8&quot;, &quot;S&quot;): 0x2078,</span>
<span class="gi">+    (&quot;9&quot;, &quot;S&quot;): 0x2079,</span>
<span class="gi">+    (&quot;+&quot;, &quot;S&quot;): 0x207A,</span>
<span class="gi">+    (&quot;-&quot;, &quot;S&quot;): 0x207B,</span>
<span class="gi">+    (&quot;=&quot;, &quot;S&quot;): 0x207C,</span>
<span class="gi">+    (&quot;(&quot;, &quot;S&quot;): 0x207D,</span>
<span class="gi">+    (&quot;)&quot;, &quot;S&quot;): 0x207E,</span>
<span class="gi">+    (&quot;n&quot;, &quot;S&quot;): 0x207F,</span>
<span class="gi">+    (&quot;0&quot;, &quot;s&quot;): 0x2080,</span>
<span class="gi">+    (&quot;1&quot;, &quot;s&quot;): 0x2081,</span>
<span class="gi">+    (&quot;2&quot;, &quot;s&quot;): 0x2082,</span>
<span class="gi">+    (&quot;3&quot;, &quot;s&quot;): 0x2083,</span>
<span class="gi">+    (&quot;4&quot;, &quot;s&quot;): 0x2084,</span>
<span class="gi">+    (&quot;5&quot;, &quot;s&quot;): 0x2085,</span>
<span class="gi">+    (&quot;6&quot;, &quot;s&quot;): 0x2086,</span>
<span class="gi">+    (&quot;7&quot;, &quot;s&quot;): 0x2087,</span>
<span class="gi">+    (&quot;8&quot;, &quot;s&quot;): 0x2088,</span>
<span class="gi">+    (&quot;9&quot;, &quot;s&quot;): 0x2089,</span>
<span class="gi">+    (&quot;+&quot;, &quot;s&quot;): 0x208A,</span>
<span class="gi">+    (&quot;-&quot;, &quot;s&quot;): 0x208B,</span>
<span class="gi">+    (&quot;=&quot;, &quot;s&quot;): 0x208C,</span>
<span class="gi">+    (&quot;(&quot;, &quot;s&quot;): 0x208D,</span>
<span class="gi">+    (&quot;)&quot;, &quot;s&quot;): 0x208E,</span>
<span class="gi">+    (&quot;L&quot;, &quot;i&quot;): 0x20A4,</span>
<span class="gi">+    (&quot;P&quot;, &quot;t&quot;): 0x20A7,</span>
<span class="gi">+    (&quot;W&quot;, &quot;=&quot;): 0x20A9,</span>
<span class="gi">+    (&quot;=&quot;, &quot;e&quot;): 0x20AC,  # euro</span>
<span class="gi">+    (&quot;E&quot;, &quot;u&quot;): 0x20AC,  # euro</span>
<span class="gi">+    (&quot;=&quot;, &quot;R&quot;): 0x20BD,  # rouble</span>
<span class="gi">+    (&quot;=&quot;, &quot;P&quot;): 0x20BD,  # rouble</span>
<span class="gi">+    (&quot;o&quot;, &quot;C&quot;): 0x2103,</span>
<span class="gi">+    (&quot;c&quot;, &quot;o&quot;): 0x2105,</span>
<span class="gi">+    (&quot;o&quot;, &quot;F&quot;): 0x2109,</span>
<span class="gi">+    (&quot;N&quot;, &quot;0&quot;): 0x2116,</span>
<span class="gi">+    (&quot;P&quot;, &quot;O&quot;): 0x2117,</span>
<span class="gi">+    (&quot;R&quot;, &quot;x&quot;): 0x211E,</span>
<span class="gi">+    (&quot;S&quot;, &quot;M&quot;): 0x2120,</span>
<span class="gi">+    (&quot;T&quot;, &quot;M&quot;): 0x2122,</span>
<span class="gi">+    (&quot;O&quot;, &quot;m&quot;): 0x2126,</span>
<span class="gi">+    (&quot;A&quot;, &quot;O&quot;): 0x212B,</span>
<span class="gi">+    (&quot;1&quot;, &quot;3&quot;): 0x2153,</span>
<span class="gi">+    (&quot;2&quot;, &quot;3&quot;): 0x2154,</span>
<span class="gi">+    (&quot;1&quot;, &quot;5&quot;): 0x2155,</span>
<span class="gi">+    (&quot;2&quot;, &quot;5&quot;): 0x2156,</span>
<span class="gi">+    (&quot;3&quot;, &quot;5&quot;): 0x2157,</span>
<span class="gi">+    (&quot;4&quot;, &quot;5&quot;): 0x2158,</span>
<span class="gi">+    (&quot;1&quot;, &quot;6&quot;): 0x2159,</span>
<span class="gi">+    (&quot;5&quot;, &quot;6&quot;): 0x215A,</span>
<span class="gi">+    (&quot;1&quot;, &quot;8&quot;): 0x215B,</span>
<span class="gi">+    (&quot;3&quot;, &quot;8&quot;): 0x215C,</span>
<span class="gi">+    (&quot;5&quot;, &quot;8&quot;): 0x215D,</span>
<span class="gi">+    (&quot;7&quot;, &quot;8&quot;): 0x215E,</span>
<span class="gi">+    (&quot;1&quot;, &quot;R&quot;): 0x2160,</span>
<span class="gi">+    (&quot;2&quot;, &quot;R&quot;): 0x2161,</span>
<span class="gi">+    (&quot;3&quot;, &quot;R&quot;): 0x2162,</span>
<span class="gi">+    (&quot;4&quot;, &quot;R&quot;): 0x2163,</span>
<span class="gi">+    (&quot;5&quot;, &quot;R&quot;): 0x2164,</span>
<span class="gi">+    (&quot;6&quot;, &quot;R&quot;): 0x2165,</span>
<span class="gi">+    (&quot;7&quot;, &quot;R&quot;): 0x2166,</span>
<span class="gi">+    (&quot;8&quot;, &quot;R&quot;): 0x2167,</span>
<span class="gi">+    (&quot;9&quot;, &quot;R&quot;): 0x2168,</span>
<span class="gi">+    (&quot;a&quot;, &quot;R&quot;): 0x2169,</span>
<span class="gi">+    (&quot;b&quot;, &quot;R&quot;): 0x216A,</span>
<span class="gi">+    (&quot;c&quot;, &quot;R&quot;): 0x216B,</span>
<span class="gi">+    (&quot;1&quot;, &quot;r&quot;): 0x2170,</span>
<span class="gi">+    (&quot;2&quot;, &quot;r&quot;): 0x2171,</span>
<span class="gi">+    (&quot;3&quot;, &quot;r&quot;): 0x2172,</span>
<span class="gi">+    (&quot;4&quot;, &quot;r&quot;): 0x2173,</span>
<span class="gi">+    (&quot;5&quot;, &quot;r&quot;): 0x2174,</span>
<span class="gi">+    (&quot;6&quot;, &quot;r&quot;): 0x2175,</span>
<span class="gi">+    (&quot;7&quot;, &quot;r&quot;): 0x2176,</span>
<span class="gi">+    (&quot;8&quot;, &quot;r&quot;): 0x2177,</span>
<span class="gi">+    (&quot;9&quot;, &quot;r&quot;): 0x2178,</span>
<span class="gi">+    (&quot;a&quot;, &quot;r&quot;): 0x2179,</span>
<span class="gi">+    (&quot;b&quot;, &quot;r&quot;): 0x217A,</span>
<span class="gi">+    (&quot;c&quot;, &quot;r&quot;): 0x217B,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;-&quot;): 0x2190,</span>
<span class="gi">+    (&quot;-&quot;, &quot;!&quot;): 0x2191,</span>
<span class="gi">+    (&quot;-&quot;, &quot;&gt;&quot;): 0x2192,</span>
<span class="gi">+    (&quot;-&quot;, &quot;v&quot;): 0x2193,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;&gt;&quot;): 0x2194,</span>
<span class="gi">+    (&quot;U&quot;, &quot;D&quot;): 0x2195,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;=&quot;): 0x21D0,</span>
<span class="gi">+    (&quot;=&quot;, &quot;&gt;&quot;): 0x21D2,</span>
<span class="gi">+    (&quot;=&quot;, &quot;=&quot;): 0x21D4,</span>
<span class="gi">+    (&quot;F&quot;, &quot;A&quot;): 0x2200,</span>
<span class="gi">+    (&quot;d&quot;, &quot;P&quot;): 0x2202,</span>
<span class="gi">+    (&quot;T&quot;, &quot;E&quot;): 0x2203,</span>
<span class="gi">+    (&quot;/&quot;, &quot;0&quot;): 0x2205,</span>
<span class="gi">+    (&quot;D&quot;, &quot;E&quot;): 0x2206,</span>
<span class="gi">+    (&quot;N&quot;, &quot;B&quot;): 0x2207,</span>
<span class="gi">+    (&quot;(&quot;, &quot;-&quot;): 0x2208,</span>
<span class="gi">+    (&quot;-&quot;, &quot;)&quot;): 0x220B,</span>
<span class="gi">+    (&quot;*&quot;, &quot;P&quot;): 0x220F,</span>
<span class="gi">+    (&quot;+&quot;, &quot;Z&quot;): 0x2211,</span>
<span class="gi">+    (&quot;-&quot;, &quot;2&quot;): 0x2212,</span>
<span class="gi">+    (&quot;-&quot;, &quot;+&quot;): 0x2213,</span>
<span class="gi">+    (&quot;*&quot;, &quot;-&quot;): 0x2217,</span>
<span class="gi">+    (&quot;O&quot;, &quot;b&quot;): 0x2218,</span>
<span class="gi">+    (&quot;S&quot;, &quot;b&quot;): 0x2219,</span>
<span class="gi">+    (&quot;R&quot;, &quot;T&quot;): 0x221A,</span>
<span class="gi">+    (&quot;0&quot;, &quot;(&quot;): 0x221D,</span>
<span class="gi">+    (&quot;0&quot;, &quot;0&quot;): 0x221E,</span>
<span class="gi">+    (&quot;-&quot;, &quot;L&quot;): 0x221F,</span>
<span class="gi">+    (&quot;-&quot;, &quot;V&quot;): 0x2220,</span>
<span class="gi">+    (&quot;P&quot;, &quot;P&quot;): 0x2225,</span>
<span class="gi">+    (&quot;A&quot;, &quot;N&quot;): 0x2227,</span>
<span class="gi">+    (&quot;O&quot;, &quot;R&quot;): 0x2228,</span>
<span class="gi">+    (&quot;(&quot;, &quot;U&quot;): 0x2229,</span>
<span class="gi">+    (&quot;)&quot;, &quot;U&quot;): 0x222A,</span>
<span class="gi">+    (&quot;I&quot;, &quot;n&quot;): 0x222B,</span>
<span class="gi">+    (&quot;D&quot;, &quot;I&quot;): 0x222C,</span>
<span class="gi">+    (&quot;I&quot;, &quot;o&quot;): 0x222E,</span>
<span class="gi">+    (&quot;.&quot;, &quot;:&quot;): 0x2234,</span>
<span class="gi">+    (&quot;:&quot;, &quot;.&quot;): 0x2235,</span>
<span class="gi">+    (&quot;:&quot;, &quot;R&quot;): 0x2236,</span>
<span class="gi">+    (&quot;:&quot;, &quot;:&quot;): 0x2237,</span>
<span class="gi">+    (&quot;?&quot;, &quot;1&quot;): 0x223C,</span>
<span class="gi">+    (&quot;C&quot;, &quot;G&quot;): 0x223E,</span>
<span class="gi">+    (&quot;?&quot;, &quot;-&quot;): 0x2243,</span>
<span class="gi">+    (&quot;?&quot;, &quot;=&quot;): 0x2245,</span>
<span class="gi">+    (&quot;?&quot;, &quot;2&quot;): 0x2248,</span>
<span class="gi">+    (&quot;=&quot;, &quot;?&quot;): 0x224C,</span>
<span class="gi">+    (&quot;H&quot;, &quot;I&quot;): 0x2253,</span>
<span class="gi">+    (&quot;!&quot;, &quot;=&quot;): 0x2260,</span>
<span class="gi">+    (&quot;=&quot;, &quot;3&quot;): 0x2261,</span>
<span class="gi">+    (&quot;=&quot;, &quot;&lt;&quot;): 0x2264,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;=&quot;): 0x2265,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;*&quot;): 0x226A,</span>
<span class="gi">+    (&quot;*&quot;, &quot;&gt;&quot;): 0x226B,</span>
<span class="gi">+    (&quot;!&quot;, &quot;&lt;&quot;): 0x226E,</span>
<span class="gi">+    (&quot;!&quot;, &quot;&gt;&quot;): 0x226F,</span>
<span class="gi">+    (&quot;(&quot;, &quot;C&quot;): 0x2282,</span>
<span class="gi">+    (&quot;)&quot;, &quot;C&quot;): 0x2283,</span>
<span class="gi">+    (&quot;(&quot;, &quot;_&quot;): 0x2286,</span>
<span class="gi">+    (&quot;)&quot;, &quot;_&quot;): 0x2287,</span>
<span class="gi">+    (&quot;0&quot;, &quot;.&quot;): 0x2299,</span>
<span class="gi">+    (&quot;0&quot;, &quot;2&quot;): 0x229A,</span>
<span class="gi">+    (&quot;-&quot;, &quot;T&quot;): 0x22A5,</span>
<span class="gi">+    (&quot;.&quot;, &quot;P&quot;): 0x22C5,</span>
<span class="gi">+    (&quot;:&quot;, &quot;3&quot;): 0x22EE,</span>
<span class="gi">+    (&quot;.&quot;, &quot;3&quot;): 0x22EF,</span>
<span class="gi">+    (&quot;E&quot;, &quot;h&quot;): 0x2302,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;7&quot;): 0x2308,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;7&quot;): 0x2309,</span>
<span class="gi">+    (&quot;7&quot;, &quot;&lt;&quot;): 0x230A,</span>
<span class="gi">+    (&quot;7&quot;, &quot;&gt;&quot;): 0x230B,</span>
<span class="gi">+    (&quot;N&quot;, &quot;I&quot;): 0x2310,</span>
<span class="gi">+    (&quot;(&quot;, &quot;A&quot;): 0x2312,</span>
<span class="gi">+    (&quot;T&quot;, &quot;R&quot;): 0x2315,</span>
<span class="gi">+    (&quot;I&quot;, &quot;u&quot;): 0x2320,</span>
<span class="gi">+    (&quot;I&quot;, &quot;l&quot;): 0x2321,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;/&quot;): 0x2329,</span>
<span class="gi">+    (&quot;/&quot;, &quot;&gt;&quot;): 0x232A,</span>
<span class="gi">+    (&quot;V&quot;, &quot;s&quot;): 0x2423,</span>
<span class="gi">+    (&quot;1&quot;, &quot;h&quot;): 0x2440,</span>
<span class="gi">+    (&quot;3&quot;, &quot;h&quot;): 0x2441,</span>
<span class="gi">+    (&quot;2&quot;, &quot;h&quot;): 0x2442,</span>
<span class="gi">+    (&quot;4&quot;, &quot;h&quot;): 0x2443,</span>
<span class="gi">+    (&quot;1&quot;, &quot;j&quot;): 0x2446,</span>
<span class="gi">+    (&quot;2&quot;, &quot;j&quot;): 0x2447,</span>
<span class="gi">+    (&quot;3&quot;, &quot;j&quot;): 0x2448,</span>
<span class="gi">+    (&quot;4&quot;, &quot;j&quot;): 0x2449,</span>
<span class="gi">+    (&quot;1&quot;, &quot;.&quot;): 0x2488,</span>
<span class="gi">+    (&quot;2&quot;, &quot;.&quot;): 0x2489,</span>
<span class="gi">+    (&quot;3&quot;, &quot;.&quot;): 0x248A,</span>
<span class="gi">+    (&quot;4&quot;, &quot;.&quot;): 0x248B,</span>
<span class="gi">+    (&quot;5&quot;, &quot;.&quot;): 0x248C,</span>
<span class="gi">+    (&quot;6&quot;, &quot;.&quot;): 0x248D,</span>
<span class="gi">+    (&quot;7&quot;, &quot;.&quot;): 0x248E,</span>
<span class="gi">+    (&quot;8&quot;, &quot;.&quot;): 0x248F,</span>
<span class="gi">+    (&quot;9&quot;, &quot;.&quot;): 0x2490,</span>
<span class="gi">+    (&quot;h&quot;, &quot;h&quot;): 0x2500,</span>
<span class="gi">+    (&quot;H&quot;, &quot;H&quot;): 0x2501,</span>
<span class="gi">+    (&quot;v&quot;, &quot;v&quot;): 0x2502,</span>
<span class="gi">+    (&quot;V&quot;, &quot;V&quot;): 0x2503,</span>
<span class="gi">+    (&quot;3&quot;, &quot;-&quot;): 0x2504,</span>
<span class="gi">+    (&quot;3&quot;, &quot;_&quot;): 0x2505,</span>
<span class="gi">+    (&quot;3&quot;, &quot;!&quot;): 0x2506,</span>
<span class="gi">+    (&quot;3&quot;, &quot;/&quot;): 0x2507,</span>
<span class="gi">+    (&quot;4&quot;, &quot;-&quot;): 0x2508,</span>
<span class="gi">+    (&quot;4&quot;, &quot;_&quot;): 0x2509,</span>
<span class="gi">+    (&quot;4&quot;, &quot;!&quot;): 0x250A,</span>
<span class="gi">+    (&quot;4&quot;, &quot;/&quot;): 0x250B,</span>
<span class="gi">+    (&quot;d&quot;, &quot;r&quot;): 0x250C,</span>
<span class="gi">+    (&quot;d&quot;, &quot;R&quot;): 0x250D,</span>
<span class="gi">+    (&quot;D&quot;, &quot;r&quot;): 0x250E,</span>
<span class="gi">+    (&quot;D&quot;, &quot;R&quot;): 0x250F,</span>
<span class="gi">+    (&quot;d&quot;, &quot;l&quot;): 0x2510,</span>
<span class="gi">+    (&quot;d&quot;, &quot;L&quot;): 0x2511,</span>
<span class="gi">+    (&quot;D&quot;, &quot;l&quot;): 0x2512,</span>
<span class="gi">+    (&quot;L&quot;, &quot;D&quot;): 0x2513,</span>
<span class="gi">+    (&quot;u&quot;, &quot;r&quot;): 0x2514,</span>
<span class="gi">+    (&quot;u&quot;, &quot;R&quot;): 0x2515,</span>
<span class="gi">+    (&quot;U&quot;, &quot;r&quot;): 0x2516,</span>
<span class="gi">+    (&quot;U&quot;, &quot;R&quot;): 0x2517,</span>
<span class="gi">+    (&quot;u&quot;, &quot;l&quot;): 0x2518,</span>
<span class="gi">+    (&quot;u&quot;, &quot;L&quot;): 0x2519,</span>
<span class="gi">+    (&quot;U&quot;, &quot;l&quot;): 0x251A,</span>
<span class="gi">+    (&quot;U&quot;, &quot;L&quot;): 0x251B,</span>
<span class="gi">+    (&quot;v&quot;, &quot;r&quot;): 0x251C,</span>
<span class="gi">+    (&quot;v&quot;, &quot;R&quot;): 0x251D,</span>
<span class="gi">+    (&quot;V&quot;, &quot;r&quot;): 0x2520,</span>
<span class="gi">+    (&quot;V&quot;, &quot;R&quot;): 0x2523,</span>
<span class="gi">+    (&quot;v&quot;, &quot;l&quot;): 0x2524,</span>
<span class="gi">+    (&quot;v&quot;, &quot;L&quot;): 0x2525,</span>
<span class="gi">+    (&quot;V&quot;, &quot;l&quot;): 0x2528,</span>
<span class="gi">+    (&quot;V&quot;, &quot;L&quot;): 0x252B,</span>
<span class="gi">+    (&quot;d&quot;, &quot;h&quot;): 0x252C,</span>
<span class="gi">+    (&quot;d&quot;, &quot;H&quot;): 0x252F,</span>
<span class="gi">+    (&quot;D&quot;, &quot;h&quot;): 0x2530,</span>
<span class="gi">+    (&quot;D&quot;, &quot;H&quot;): 0x2533,</span>
<span class="gi">+    (&quot;u&quot;, &quot;h&quot;): 0x2534,</span>
<span class="gi">+    (&quot;u&quot;, &quot;H&quot;): 0x2537,</span>
<span class="gi">+    (&quot;U&quot;, &quot;h&quot;): 0x2538,</span>
<span class="gi">+    (&quot;U&quot;, &quot;H&quot;): 0x253B,</span>
<span class="gi">+    (&quot;v&quot;, &quot;h&quot;): 0x253C,</span>
<span class="gi">+    (&quot;v&quot;, &quot;H&quot;): 0x253F,</span>
<span class="gi">+    (&quot;V&quot;, &quot;h&quot;): 0x2542,</span>
<span class="gi">+    (&quot;V&quot;, &quot;H&quot;): 0x254B,</span>
<span class="gi">+    (&quot;F&quot;, &quot;D&quot;): 0x2571,</span>
<span class="gi">+    (&quot;B&quot;, &quot;D&quot;): 0x2572,</span>
<span class="gi">+    (&quot;T&quot;, &quot;B&quot;): 0x2580,</span>
<span class="gi">+    (&quot;L&quot;, &quot;B&quot;): 0x2584,</span>
<span class="gi">+    (&quot;F&quot;, &quot;B&quot;): 0x2588,</span>
<span class="gi">+    (&quot;l&quot;, &quot;B&quot;): 0x258C,</span>
<span class="gi">+    (&quot;R&quot;, &quot;B&quot;): 0x2590,</span>
<span class="gi">+    (&quot;.&quot;, &quot;S&quot;): 0x2591,</span>
<span class="gi">+    (&quot;:&quot;, &quot;S&quot;): 0x2592,</span>
<span class="gi">+    (&quot;?&quot;, &quot;S&quot;): 0x2593,</span>
<span class="gi">+    (&quot;f&quot;, &quot;S&quot;): 0x25A0,</span>
<span class="gi">+    (&quot;O&quot;, &quot;S&quot;): 0x25A1,</span>
<span class="gi">+    (&quot;R&quot;, &quot;O&quot;): 0x25A2,</span>
<span class="gi">+    (&quot;R&quot;, &quot;r&quot;): 0x25A3,</span>
<span class="gi">+    (&quot;R&quot;, &quot;F&quot;): 0x25A4,</span>
<span class="gi">+    (&quot;R&quot;, &quot;Y&quot;): 0x25A5,</span>
<span class="gi">+    (&quot;R&quot;, &quot;H&quot;): 0x25A6,</span>
<span class="gi">+    (&quot;R&quot;, &quot;Z&quot;): 0x25A7,</span>
<span class="gi">+    (&quot;R&quot;, &quot;K&quot;): 0x25A8,</span>
<span class="gi">+    (&quot;R&quot;, &quot;X&quot;): 0x25A9,</span>
<span class="gi">+    (&quot;s&quot;, &quot;B&quot;): 0x25AA,</span>
<span class="gi">+    (&quot;S&quot;, &quot;R&quot;): 0x25AC,</span>
<span class="gi">+    (&quot;O&quot;, &quot;r&quot;): 0x25AD,</span>
<span class="gi">+    (&quot;U&quot;, &quot;T&quot;): 0x25B2,</span>
<span class="gi">+    (&quot;u&quot;, &quot;T&quot;): 0x25B3,</span>
<span class="gi">+    (&quot;P&quot;, &quot;R&quot;): 0x25B6,</span>
<span class="gi">+    (&quot;T&quot;, &quot;r&quot;): 0x25B7,</span>
<span class="gi">+    (&quot;D&quot;, &quot;t&quot;): 0x25BC,</span>
<span class="gi">+    (&quot;d&quot;, &quot;T&quot;): 0x25BD,</span>
<span class="gi">+    (&quot;P&quot;, &quot;L&quot;): 0x25C0,</span>
<span class="gi">+    (&quot;T&quot;, &quot;l&quot;): 0x25C1,</span>
<span class="gi">+    (&quot;D&quot;, &quot;b&quot;): 0x25C6,</span>
<span class="gi">+    (&quot;D&quot;, &quot;w&quot;): 0x25C7,</span>
<span class="gi">+    (&quot;L&quot;, &quot;Z&quot;): 0x25CA,</span>
<span class="gi">+    (&quot;0&quot;, &quot;m&quot;): 0x25CB,</span>
<span class="gi">+    (&quot;0&quot;, &quot;o&quot;): 0x25CE,</span>
<span class="gi">+    (&quot;0&quot;, &quot;M&quot;): 0x25CF,</span>
<span class="gi">+    (&quot;0&quot;, &quot;L&quot;): 0x25D0,</span>
<span class="gi">+    (&quot;0&quot;, &quot;R&quot;): 0x25D1,</span>
<span class="gi">+    (&quot;S&quot;, &quot;n&quot;): 0x25D8,</span>
<span class="gi">+    (&quot;I&quot;, &quot;c&quot;): 0x25D9,</span>
<span class="gi">+    (&quot;F&quot;, &quot;d&quot;): 0x25E2,</span>
<span class="gi">+    (&quot;B&quot;, &quot;d&quot;): 0x25E3,</span>
<span class="gi">+    (&quot;*&quot;, &quot;2&quot;): 0x2605,</span>
<span class="gi">+    (&quot;*&quot;, &quot;1&quot;): 0x2606,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;H&quot;): 0x261C,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;H&quot;): 0x261E,</span>
<span class="gi">+    (&quot;0&quot;, &quot;u&quot;): 0x263A,</span>
<span class="gi">+    (&quot;0&quot;, &quot;U&quot;): 0x263B,</span>
<span class="gi">+    (&quot;S&quot;, &quot;U&quot;): 0x263C,</span>
<span class="gi">+    (&quot;F&quot;, &quot;m&quot;): 0x2640,</span>
<span class="gi">+    (&quot;M&quot;, &quot;l&quot;): 0x2642,</span>
<span class="gi">+    (&quot;c&quot;, &quot;S&quot;): 0x2660,</span>
<span class="gi">+    (&quot;c&quot;, &quot;H&quot;): 0x2661,</span>
<span class="gi">+    (&quot;c&quot;, &quot;D&quot;): 0x2662,</span>
<span class="gi">+    (&quot;c&quot;, &quot;C&quot;): 0x2663,</span>
<span class="gi">+    (&quot;M&quot;, &quot;d&quot;): 0x2669,</span>
<span class="gi">+    (&quot;M&quot;, &quot;8&quot;): 0x266A,</span>
<span class="gi">+    (&quot;M&quot;, &quot;2&quot;): 0x266B,</span>
<span class="gi">+    (&quot;M&quot;, &quot;b&quot;): 0x266D,</span>
<span class="gi">+    (&quot;M&quot;, &quot;x&quot;): 0x266E,</span>
<span class="gi">+    (&quot;M&quot;, &quot;X&quot;): 0x266F,</span>
<span class="gi">+    (&quot;O&quot;, &quot;K&quot;): 0x2713,</span>
<span class="gi">+    (&quot;X&quot;, &quot;X&quot;): 0x2717,</span>
<span class="gi">+    (&quot;-&quot;, &quot;X&quot;): 0x2720,</span>
<span class="gi">+    (&quot;I&quot;, &quot;S&quot;): 0x3000,</span>
<span class="gi">+    (&quot;,&quot;, &quot;_&quot;): 0x3001,</span>
<span class="gi">+    (&quot;.&quot;, &quot;_&quot;): 0x3002,</span>
<span class="gi">+    (&quot;+&quot;, &#39;&quot;&#39;): 0x3003,</span>
<span class="gi">+    (&quot;+&quot;, &quot;_&quot;): 0x3004,</span>
<span class="gi">+    (&quot;*&quot;, &quot;_&quot;): 0x3005,</span>
<span class="gi">+    (&quot;;&quot;, &quot;_&quot;): 0x3006,</span>
<span class="gi">+    (&quot;0&quot;, &quot;_&quot;): 0x3007,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;+&quot;): 0x300A,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;+&quot;): 0x300B,</span>
<span class="gi">+    (&quot;&lt;&quot;, &quot;&#39;&quot;): 0x300C,</span>
<span class="gi">+    (&quot;&gt;&quot;, &quot;&#39;&quot;): 0x300D,</span>
<span class="gi">+    (&quot;&lt;&quot;, &#39;&quot;&#39;): 0x300E,</span>
<span class="gi">+    (&quot;&gt;&quot;, &#39;&quot;&#39;): 0x300F,</span>
<span class="gi">+    (&quot;(&quot;, &#39;&quot;&#39;): 0x3010,</span>
<span class="gi">+    (&quot;)&quot;, &#39;&quot;&#39;): 0x3011,</span>
<span class="gi">+    (&quot;=&quot;, &quot;T&quot;): 0x3012,</span>
<span class="gi">+    (&quot;=&quot;, &quot;_&quot;): 0x3013,</span>
<span class="gi">+    (&quot;(&quot;, &quot;&#39;&quot;): 0x3014,</span>
<span class="gi">+    (&quot;)&quot;, &quot;&#39;&quot;): 0x3015,</span>
<span class="gi">+    (&quot;(&quot;, &quot;I&quot;): 0x3016,</span>
<span class="gi">+    (&quot;)&quot;, &quot;I&quot;): 0x3017,</span>
<span class="gi">+    (&quot;-&quot;, &quot;?&quot;): 0x301C,</span>
<span class="gi">+    (&quot;A&quot;, &quot;5&quot;): 0x3041,</span>
<span class="gi">+    (&quot;a&quot;, &quot;5&quot;): 0x3042,</span>
<span class="gi">+    (&quot;I&quot;, &quot;5&quot;): 0x3043,</span>
<span class="gi">+    (&quot;i&quot;, &quot;5&quot;): 0x3044,</span>
<span class="gi">+    (&quot;U&quot;, &quot;5&quot;): 0x3045,</span>
<span class="gi">+    (&quot;u&quot;, &quot;5&quot;): 0x3046,</span>
<span class="gi">+    (&quot;E&quot;, &quot;5&quot;): 0x3047,</span>
<span class="gi">+    (&quot;e&quot;, &quot;5&quot;): 0x3048,</span>
<span class="gi">+    (&quot;O&quot;, &quot;5&quot;): 0x3049,</span>
<span class="gi">+    (&quot;o&quot;, &quot;5&quot;): 0x304A,</span>
<span class="gi">+    (&quot;k&quot;, &quot;a&quot;): 0x304B,</span>
<span class="gi">+    (&quot;g&quot;, &quot;a&quot;): 0x304C,</span>
<span class="gi">+    (&quot;k&quot;, &quot;i&quot;): 0x304D,</span>
<span class="gi">+    (&quot;g&quot;, &quot;i&quot;): 0x304E,</span>
<span class="gi">+    (&quot;k&quot;, &quot;u&quot;): 0x304F,</span>
<span class="gi">+    (&quot;g&quot;, &quot;u&quot;): 0x3050,</span>
<span class="gi">+    (&quot;k&quot;, &quot;e&quot;): 0x3051,</span>
<span class="gi">+    (&quot;g&quot;, &quot;e&quot;): 0x3052,</span>
<span class="gi">+    (&quot;k&quot;, &quot;o&quot;): 0x3053,</span>
<span class="gi">+    (&quot;g&quot;, &quot;o&quot;): 0x3054,</span>
<span class="gi">+    (&quot;s&quot;, &quot;a&quot;): 0x3055,</span>
<span class="gi">+    (&quot;z&quot;, &quot;a&quot;): 0x3056,</span>
<span class="gi">+    (&quot;s&quot;, &quot;i&quot;): 0x3057,</span>
<span class="gi">+    (&quot;z&quot;, &quot;i&quot;): 0x3058,</span>
<span class="gi">+    (&quot;s&quot;, &quot;u&quot;): 0x3059,</span>
<span class="gi">+    (&quot;z&quot;, &quot;u&quot;): 0x305A,</span>
<span class="gi">+    (&quot;s&quot;, &quot;e&quot;): 0x305B,</span>
<span class="gi">+    (&quot;z&quot;, &quot;e&quot;): 0x305C,</span>
<span class="gi">+    (&quot;s&quot;, &quot;o&quot;): 0x305D,</span>
<span class="gi">+    (&quot;z&quot;, &quot;o&quot;): 0x305E,</span>
<span class="gi">+    (&quot;t&quot;, &quot;a&quot;): 0x305F,</span>
<span class="gi">+    (&quot;d&quot;, &quot;a&quot;): 0x3060,</span>
<span class="gi">+    (&quot;t&quot;, &quot;i&quot;): 0x3061,</span>
<span class="gi">+    (&quot;d&quot;, &quot;i&quot;): 0x3062,</span>
<span class="gi">+    (&quot;t&quot;, &quot;U&quot;): 0x3063,</span>
<span class="gi">+    (&quot;t&quot;, &quot;u&quot;): 0x3064,</span>
<span class="gi">+    (&quot;d&quot;, &quot;u&quot;): 0x3065,</span>
<span class="gi">+    (&quot;t&quot;, &quot;e&quot;): 0x3066,</span>
<span class="gi">+    (&quot;d&quot;, &quot;e&quot;): 0x3067,</span>
<span class="gi">+    (&quot;t&quot;, &quot;o&quot;): 0x3068,</span>
<span class="gi">+    (&quot;d&quot;, &quot;o&quot;): 0x3069,</span>
<span class="gi">+    (&quot;n&quot;, &quot;a&quot;): 0x306A,</span>
<span class="gi">+    (&quot;n&quot;, &quot;i&quot;): 0x306B,</span>
<span class="gi">+    (&quot;n&quot;, &quot;u&quot;): 0x306C,</span>
<span class="gi">+    (&quot;n&quot;, &quot;e&quot;): 0x306D,</span>
<span class="gi">+    (&quot;n&quot;, &quot;o&quot;): 0x306E,</span>
<span class="gi">+    (&quot;h&quot;, &quot;a&quot;): 0x306F,</span>
<span class="gi">+    (&quot;b&quot;, &quot;a&quot;): 0x3070,</span>
<span class="gi">+    (&quot;p&quot;, &quot;a&quot;): 0x3071,</span>
<span class="gi">+    (&quot;h&quot;, &quot;i&quot;): 0x3072,</span>
<span class="gi">+    (&quot;b&quot;, &quot;i&quot;): 0x3073,</span>
<span class="gi">+    (&quot;p&quot;, &quot;i&quot;): 0x3074,</span>
<span class="gi">+    (&quot;h&quot;, &quot;u&quot;): 0x3075,</span>
<span class="gi">+    (&quot;b&quot;, &quot;u&quot;): 0x3076,</span>
<span class="gi">+    (&quot;p&quot;, &quot;u&quot;): 0x3077,</span>
<span class="gi">+    (&quot;h&quot;, &quot;e&quot;): 0x3078,</span>
<span class="gi">+    (&quot;b&quot;, &quot;e&quot;): 0x3079,</span>
<span class="gi">+    (&quot;p&quot;, &quot;e&quot;): 0x307A,</span>
<span class="gi">+    (&quot;h&quot;, &quot;o&quot;): 0x307B,</span>
<span class="gi">+    (&quot;b&quot;, &quot;o&quot;): 0x307C,</span>
<span class="gi">+    (&quot;p&quot;, &quot;o&quot;): 0x307D,</span>
<span class="gi">+    (&quot;m&quot;, &quot;a&quot;): 0x307E,</span>
<span class="gi">+    (&quot;m&quot;, &quot;i&quot;): 0x307F,</span>
<span class="gi">+    (&quot;m&quot;, &quot;u&quot;): 0x3080,</span>
<span class="gi">+    (&quot;m&quot;, &quot;e&quot;): 0x3081,</span>
<span class="gi">+    (&quot;m&quot;, &quot;o&quot;): 0x3082,</span>
<span class="gi">+    (&quot;y&quot;, &quot;A&quot;): 0x3083,</span>
<span class="gi">+    (&quot;y&quot;, &quot;a&quot;): 0x3084,</span>
<span class="gi">+    (&quot;y&quot;, &quot;U&quot;): 0x3085,</span>
<span class="gi">+    (&quot;y&quot;, &quot;u&quot;): 0x3086,</span>
<span class="gi">+    (&quot;y&quot;, &quot;O&quot;): 0x3087,</span>
<span class="gi">+    (&quot;y&quot;, &quot;o&quot;): 0x3088,</span>
<span class="gi">+    (&quot;r&quot;, &quot;a&quot;): 0x3089,</span>
<span class="gi">+    (&quot;r&quot;, &quot;i&quot;): 0x308A,</span>
<span class="gi">+    (&quot;r&quot;, &quot;u&quot;): 0x308B,</span>
<span class="gi">+    (&quot;r&quot;, &quot;e&quot;): 0x308C,</span>
<span class="gi">+    (&quot;r&quot;, &quot;o&quot;): 0x308D,</span>
<span class="gi">+    (&quot;w&quot;, &quot;A&quot;): 0x308E,</span>
<span class="gi">+    (&quot;w&quot;, &quot;a&quot;): 0x308F,</span>
<span class="gi">+    (&quot;w&quot;, &quot;i&quot;): 0x3090,</span>
<span class="gi">+    (&quot;w&quot;, &quot;e&quot;): 0x3091,</span>
<span class="gi">+    (&quot;w&quot;, &quot;o&quot;): 0x3092,</span>
<span class="gi">+    (&quot;n&quot;, &quot;5&quot;): 0x3093,</span>
<span class="gi">+    (&quot;v&quot;, &quot;u&quot;): 0x3094,</span>
<span class="gi">+    (&#39;&quot;&#39;, &quot;5&quot;): 0x309B,</span>
<span class="gi">+    (&quot;0&quot;, &quot;5&quot;): 0x309C,</span>
<span class="gi">+    (&quot;*&quot;, &quot;5&quot;): 0x309D,</span>
<span class="gi">+    (&quot;+&quot;, &quot;5&quot;): 0x309E,</span>
<span class="gi">+    (&quot;a&quot;, &quot;6&quot;): 0x30A1,</span>
<span class="gi">+    (&quot;A&quot;, &quot;6&quot;): 0x30A2,</span>
<span class="gi">+    (&quot;i&quot;, &quot;6&quot;): 0x30A3,</span>
<span class="gi">+    (&quot;I&quot;, &quot;6&quot;): 0x30A4,</span>
<span class="gi">+    (&quot;u&quot;, &quot;6&quot;): 0x30A5,</span>
<span class="gi">+    (&quot;U&quot;, &quot;6&quot;): 0x30A6,</span>
<span class="gi">+    (&quot;e&quot;, &quot;6&quot;): 0x30A7,</span>
<span class="gi">+    (&quot;E&quot;, &quot;6&quot;): 0x30A8,</span>
<span class="gi">+    (&quot;o&quot;, &quot;6&quot;): 0x30A9,</span>
<span class="gi">+    (&quot;O&quot;, &quot;6&quot;): 0x30AA,</span>
<span class="gi">+    (&quot;K&quot;, &quot;a&quot;): 0x30AB,</span>
<span class="gi">+    (&quot;G&quot;, &quot;a&quot;): 0x30AC,</span>
<span class="gi">+    (&quot;K&quot;, &quot;i&quot;): 0x30AD,</span>
<span class="gi">+    (&quot;G&quot;, &quot;i&quot;): 0x30AE,</span>
<span class="gi">+    (&quot;K&quot;, &quot;u&quot;): 0x30AF,</span>
<span class="gi">+    (&quot;G&quot;, &quot;u&quot;): 0x30B0,</span>
<span class="gi">+    (&quot;K&quot;, &quot;e&quot;): 0x30B1,</span>
<span class="gi">+    (&quot;G&quot;, &quot;e&quot;): 0x30B2,</span>
<span class="gi">+    (&quot;K&quot;, &quot;o&quot;): 0x30B3,</span>
<span class="gi">+    (&quot;G&quot;, &quot;o&quot;): 0x30B4,</span>
<span class="gi">+    (&quot;S&quot;, &quot;a&quot;): 0x30B5,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;a&quot;): 0x30B6,</span>
<span class="gi">+    (&quot;S&quot;, &quot;i&quot;): 0x30B7,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;i&quot;): 0x30B8,</span>
<span class="gi">+    (&quot;S&quot;, &quot;u&quot;): 0x30B9,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;u&quot;): 0x30BA,</span>
<span class="gi">+    (&quot;S&quot;, &quot;e&quot;): 0x30BB,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;e&quot;): 0x30BC,</span>
<span class="gi">+    (&quot;S&quot;, &quot;o&quot;): 0x30BD,</span>
<span class="gi">+    (&quot;Z&quot;, &quot;o&quot;): 0x30BE,</span>
<span class="gi">+    (&quot;T&quot;, &quot;a&quot;): 0x30BF,</span>
<span class="gi">+    (&quot;D&quot;, &quot;a&quot;): 0x30C0,</span>
<span class="gi">+    (&quot;T&quot;, &quot;i&quot;): 0x30C1,</span>
<span class="gi">+    (&quot;D&quot;, &quot;i&quot;): 0x30C2,</span>
<span class="gi">+    (&quot;T&quot;, &quot;U&quot;): 0x30C3,</span>
<span class="gi">+    (&quot;T&quot;, &quot;u&quot;): 0x30C4,</span>
<span class="gi">+    (&quot;D&quot;, &quot;u&quot;): 0x30C5,</span>
<span class="gi">+    (&quot;T&quot;, &quot;e&quot;): 0x30C6,</span>
<span class="gi">+    (&quot;D&quot;, &quot;e&quot;): 0x30C7,</span>
<span class="gi">+    (&quot;T&quot;, &quot;o&quot;): 0x30C8,</span>
<span class="gi">+    (&quot;D&quot;, &quot;o&quot;): 0x30C9,</span>
<span class="gi">+    (&quot;N&quot;, &quot;a&quot;): 0x30CA,</span>
<span class="gi">+    (&quot;N&quot;, &quot;i&quot;): 0x30CB,</span>
<span class="gi">+    (&quot;N&quot;, &quot;u&quot;): 0x30CC,</span>
<span class="gi">+    (&quot;N&quot;, &quot;e&quot;): 0x30CD,</span>
<span class="gi">+    (&quot;N&quot;, &quot;o&quot;): 0x30CE,</span>
<span class="gi">+    (&quot;H&quot;, &quot;a&quot;): 0x30CF,</span>
<span class="gi">+    (&quot;B&quot;, &quot;a&quot;): 0x30D0,</span>
<span class="gi">+    (&quot;P&quot;, &quot;a&quot;): 0x30D1,</span>
<span class="gi">+    (&quot;H&quot;, &quot;i&quot;): 0x30D2,</span>
<span class="gi">+    (&quot;B&quot;, &quot;i&quot;): 0x30D3,</span>
<span class="gi">+    (&quot;P&quot;, &quot;i&quot;): 0x30D4,</span>
<span class="gi">+    (&quot;H&quot;, &quot;u&quot;): 0x30D5,</span>
<span class="gi">+    (&quot;B&quot;, &quot;u&quot;): 0x30D6,</span>
<span class="gi">+    (&quot;P&quot;, &quot;u&quot;): 0x30D7,</span>
<span class="gi">+    (&quot;H&quot;, &quot;e&quot;): 0x30D8,</span>
<span class="gi">+    (&quot;B&quot;, &quot;e&quot;): 0x30D9,</span>
<span class="gi">+    (&quot;P&quot;, &quot;e&quot;): 0x30DA,</span>
<span class="gi">+    (&quot;H&quot;, &quot;o&quot;): 0x30DB,</span>
<span class="gi">+    (&quot;B&quot;, &quot;o&quot;): 0x30DC,</span>
<span class="gi">+    (&quot;P&quot;, &quot;o&quot;): 0x30DD,</span>
<span class="gi">+    (&quot;M&quot;, &quot;a&quot;): 0x30DE,</span>
<span class="gi">+    (&quot;M&quot;, &quot;i&quot;): 0x30DF,</span>
<span class="gi">+    (&quot;M&quot;, &quot;u&quot;): 0x30E0,</span>
<span class="gi">+    (&quot;M&quot;, &quot;e&quot;): 0x30E1,</span>
<span class="gi">+    (&quot;M&quot;, &quot;o&quot;): 0x30E2,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;A&quot;): 0x30E3,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;a&quot;): 0x30E4,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;U&quot;): 0x30E5,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;u&quot;): 0x30E6,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;O&quot;): 0x30E7,</span>
<span class="gi">+    (&quot;Y&quot;, &quot;o&quot;): 0x30E8,</span>
<span class="gi">+    (&quot;R&quot;, &quot;a&quot;): 0x30E9,</span>
<span class="gi">+    (&quot;R&quot;, &quot;i&quot;): 0x30EA,</span>
<span class="gi">+    (&quot;R&quot;, &quot;u&quot;): 0x30EB,</span>
<span class="gi">+    (&quot;R&quot;, &quot;e&quot;): 0x30EC,</span>
<span class="gi">+    (&quot;R&quot;, &quot;o&quot;): 0x30ED,</span>
<span class="gi">+    (&quot;W&quot;, &quot;A&quot;): 0x30EE,</span>
<span class="gi">+    (&quot;W&quot;, &quot;a&quot;): 0x30EF,</span>
<span class="gi">+    (&quot;W&quot;, &quot;i&quot;): 0x30F0,</span>
<span class="gi">+    (&quot;W&quot;, &quot;e&quot;): 0x30F1,</span>
<span class="gi">+    (&quot;W&quot;, &quot;o&quot;): 0x30F2,</span>
<span class="gi">+    (&quot;N&quot;, &quot;6&quot;): 0x30F3,</span>
<span class="gi">+    (&quot;V&quot;, &quot;u&quot;): 0x30F4,</span>
<span class="gi">+    (&quot;K&quot;, &quot;A&quot;): 0x30F5,</span>
<span class="gi">+    (&quot;K&quot;, &quot;E&quot;): 0x30F6,</span>
<span class="gi">+    (&quot;V&quot;, &quot;a&quot;): 0x30F7,</span>
<span class="gi">+    (&quot;V&quot;, &quot;i&quot;): 0x30F8,</span>
<span class="gi">+    (&quot;V&quot;, &quot;e&quot;): 0x30F9,</span>
<span class="gi">+    (&quot;V&quot;, &quot;o&quot;): 0x30FA,</span>
<span class="gi">+    (&quot;.&quot;, &quot;6&quot;): 0x30FB,</span>
<span class="gi">+    (&quot;-&quot;, &quot;6&quot;): 0x30FC,</span>
<span class="gi">+    (&quot;*&quot;, &quot;6&quot;): 0x30FD,</span>
<span class="gi">+    (&quot;+&quot;, &quot;6&quot;): 0x30FE,</span>
<span class="gi">+    (&quot;b&quot;, &quot;4&quot;): 0x3105,</span>
<span class="gi">+    (&quot;p&quot;, &quot;4&quot;): 0x3106,</span>
<span class="gi">+    (&quot;m&quot;, &quot;4&quot;): 0x3107,</span>
<span class="gi">+    (&quot;f&quot;, &quot;4&quot;): 0x3108,</span>
<span class="gi">+    (&quot;d&quot;, &quot;4&quot;): 0x3109,</span>
<span class="gi">+    (&quot;t&quot;, &quot;4&quot;): 0x310A,</span>
<span class="gi">+    (&quot;n&quot;, &quot;4&quot;): 0x310B,</span>
<span class="gi">+    (&quot;l&quot;, &quot;4&quot;): 0x310C,</span>
<span class="gi">+    (&quot;g&quot;, &quot;4&quot;): 0x310D,</span>
<span class="gi">+    (&quot;k&quot;, &quot;4&quot;): 0x310E,</span>
<span class="gi">+    (&quot;h&quot;, &quot;4&quot;): 0x310F,</span>
<span class="gi">+    (&quot;j&quot;, &quot;4&quot;): 0x3110,</span>
<span class="gi">+    (&quot;q&quot;, &quot;4&quot;): 0x3111,</span>
<span class="gi">+    (&quot;x&quot;, &quot;4&quot;): 0x3112,</span>
<span class="gi">+    (&quot;z&quot;, &quot;h&quot;): 0x3113,</span>
<span class="gi">+    (&quot;c&quot;, &quot;h&quot;): 0x3114,</span>
<span class="gi">+    (&quot;s&quot;, &quot;h&quot;): 0x3115,</span>
<span class="gi">+    (&quot;r&quot;, &quot;4&quot;): 0x3116,</span>
<span class="gi">+    (&quot;z&quot;, &quot;4&quot;): 0x3117,</span>
<span class="gi">+    (&quot;c&quot;, &quot;4&quot;): 0x3118,</span>
<span class="gi">+    (&quot;s&quot;, &quot;4&quot;): 0x3119,</span>
<span class="gi">+    (&quot;a&quot;, &quot;4&quot;): 0x311A,</span>
<span class="gi">+    (&quot;o&quot;, &quot;4&quot;): 0x311B,</span>
<span class="gi">+    (&quot;e&quot;, &quot;4&quot;): 0x311C,</span>
<span class="gi">+    (&quot;a&quot;, &quot;i&quot;): 0x311E,</span>
<span class="gi">+    (&quot;e&quot;, &quot;i&quot;): 0x311F,</span>
<span class="gi">+    (&quot;a&quot;, &quot;u&quot;): 0x3120,</span>
<span class="gi">+    (&quot;o&quot;, &quot;u&quot;): 0x3121,</span>
<span class="gi">+    (&quot;a&quot;, &quot;n&quot;): 0x3122,</span>
<span class="gi">+    (&quot;e&quot;, &quot;n&quot;): 0x3123,</span>
<span class="gi">+    (&quot;a&quot;, &quot;N&quot;): 0x3124,</span>
<span class="gi">+    (&quot;e&quot;, &quot;N&quot;): 0x3125,</span>
<span class="gi">+    (&quot;e&quot;, &quot;r&quot;): 0x3126,</span>
<span class="gi">+    (&quot;i&quot;, &quot;4&quot;): 0x3127,</span>
<span class="gi">+    (&quot;u&quot;, &quot;4&quot;): 0x3128,</span>
<span class="gi">+    (&quot;i&quot;, &quot;u&quot;): 0x3129,</span>
<span class="gi">+    (&quot;v&quot;, &quot;4&quot;): 0x312A,</span>
<span class="gi">+    (&quot;n&quot;, &quot;G&quot;): 0x312B,</span>
<span class="gi">+    (&quot;g&quot;, &quot;n&quot;): 0x312C,</span>
<span class="gi">+    (&quot;1&quot;, &quot;c&quot;): 0x3220,</span>
<span class="gi">+    (&quot;2&quot;, &quot;c&quot;): 0x3221,</span>
<span class="gi">+    (&quot;3&quot;, &quot;c&quot;): 0x3222,</span>
<span class="gi">+    (&quot;4&quot;, &quot;c&quot;): 0x3223,</span>
<span class="gi">+    (&quot;5&quot;, &quot;c&quot;): 0x3224,</span>
<span class="gi">+    (&quot;6&quot;, &quot;c&quot;): 0x3225,</span>
<span class="gi">+    (&quot;7&quot;, &quot;c&quot;): 0x3226,</span>
<span class="gi">+    (&quot;8&quot;, &quot;c&quot;): 0x3227,</span>
<span class="gi">+    (&quot;9&quot;, &quot;c&quot;): 0x3228,</span>
<span class="gi">+    # code points 0xe000 - 0xefff excluded, they have no assigned</span>
<span class="gi">+    # characters, only used in proposals.</span>
<span class="gi">+    (&quot;f&quot;, &quot;f&quot;): 0xFB00,</span>
<span class="gi">+    (&quot;f&quot;, &quot;i&quot;): 0xFB01,</span>
<span class="gi">+    (&quot;f&quot;, &quot;l&quot;): 0xFB02,</span>
<span class="gi">+    (&quot;f&quot;, &quot;t&quot;): 0xFB05,</span>
<span class="gi">+    (&quot;s&quot;, &quot;t&quot;): 0xFB06,</span>
<span class="gi">+    # Vim 5.x compatible digraphs that don&#39;t conflict with the above</span>
<span class="gi">+    (&quot;~&quot;, &quot;!&quot;): 161,</span>
<span class="gi">+    (&quot;c&quot;, &quot;|&quot;): 162,</span>
<span class="gi">+    (&quot;$&quot;, &quot;$&quot;): 163,</span>
<span class="gi">+    (&quot;o&quot;, &quot;x&quot;): 164,  # currency symbol in ISO 8859-1</span>
<span class="gi">+    (&quot;Y&quot;, &quot;-&quot;): 165,</span>
<span class="gi">+    (&quot;|&quot;, &quot;|&quot;): 166,</span>
<span class="gi">+    (&quot;c&quot;, &quot;O&quot;): 169,</span>
<span class="gi">+    (&quot;-&quot;, &quot;,&quot;): 172,</span>
<span class="gi">+    (&quot;-&quot;, &quot;=&quot;): 175,</span>
<span class="gi">+    (&quot;~&quot;, &quot;o&quot;): 176,</span>
<span class="gi">+    (&quot;2&quot;, &quot;2&quot;): 178,</span>
<span class="gi">+    (&quot;3&quot;, &quot;3&quot;): 179,</span>
<span class="gi">+    (&quot;p&quot;, &quot;p&quot;): 182,</span>
<span class="gi">+    (&quot;~&quot;, &quot;.&quot;): 183,</span>
<span class="gi">+    (&quot;1&quot;, &quot;1&quot;): 185,</span>
<span class="gi">+    (&quot;~&quot;, &quot;?&quot;): 191,</span>
<span class="gi">+    (&quot;A&quot;, &quot;`&quot;): 192,</span>
<span class="gi">+    (&quot;A&quot;, &quot;^&quot;): 194,</span>
<span class="gi">+    (&quot;A&quot;, &quot;~&quot;): 195,</span>
<span class="gi">+    (&quot;A&quot;, &#39;&quot;&#39;): 196,</span>
<span class="gi">+    (&quot;A&quot;, &quot;@&quot;): 197,</span>
<span class="gi">+    (&quot;E&quot;, &quot;`&quot;): 200,</span>
<span class="gi">+    (&quot;E&quot;, &quot;^&quot;): 202,</span>
<span class="gi">+    (&quot;E&quot;, &#39;&quot;&#39;): 203,</span>
<span class="gi">+    (&quot;I&quot;, &quot;`&quot;): 204,</span>
<span class="gi">+    (&quot;I&quot;, &quot;^&quot;): 206,</span>
<span class="gi">+    (&quot;I&quot;, &#39;&quot;&#39;): 207,</span>
<span class="gi">+    (&quot;N&quot;, &quot;~&quot;): 209,</span>
<span class="gi">+    (&quot;O&quot;, &quot;`&quot;): 210,</span>
<span class="gi">+    (&quot;O&quot;, &quot;^&quot;): 212,</span>
<span class="gi">+    (&quot;O&quot;, &quot;~&quot;): 213,</span>
<span class="gi">+    (&quot;/&quot;, &quot;\\&quot;): 215,  # multiplication symbol in ISO 8859-1</span>
<span class="gi">+    (&quot;U&quot;, &quot;`&quot;): 217,</span>
<span class="gi">+    (&quot;U&quot;, &quot;^&quot;): 219,</span>
<span class="gi">+    (&quot;I&quot;, &quot;p&quot;): 222,</span>
<span class="gi">+    (&quot;a&quot;, &quot;`&quot;): 224,</span>
<span class="gi">+    (&quot;a&quot;, &quot;^&quot;): 226,</span>
<span class="gi">+    (&quot;a&quot;, &quot;~&quot;): 227,</span>
<span class="gi">+    (&quot;a&quot;, &#39;&quot;&#39;): 228,</span>
<span class="gi">+    (&quot;a&quot;, &quot;@&quot;): 229,</span>
<span class="gi">+    (&quot;e&quot;, &quot;`&quot;): 232,</span>
<span class="gi">+    (&quot;e&quot;, &quot;^&quot;): 234,</span>
<span class="gi">+    (&quot;e&quot;, &#39;&quot;&#39;): 235,</span>
<span class="gi">+    (&quot;i&quot;, &quot;`&quot;): 236,</span>
<span class="gi">+    (&quot;i&quot;, &quot;^&quot;): 238,</span>
<span class="gi">+    (&quot;n&quot;, &quot;~&quot;): 241,</span>
<span class="gi">+    (&quot;o&quot;, &quot;`&quot;): 242,</span>
<span class="gi">+    (&quot;o&quot;, &quot;^&quot;): 244,</span>
<span class="gi">+    (&quot;o&quot;, &quot;~&quot;): 245,</span>
<span class="gi">+    (&quot;u&quot;, &quot;`&quot;): 249,</span>
<span class="gi">+    (&quot;u&quot;, &quot;^&quot;): 251,</span>
<span class="gi">+    (&quot;y&quot;, &#39;&quot;&#39;): 255,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/emacs_state.py b/src/prompt_toolkit/key_binding/emacs_state.py</span>
<span class="gh">index d60cbeb7..6a2ebf46 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/emacs_state.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/emacs_state.py</span>
<span class="gu">@@ -1,6 +1,10 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from .key_processor import KeyPress
<span class="gd">-__all__ = [&#39;EmacsState&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;EmacsState&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class EmacsState:
<span class="gu">@@ -8,19 +12,25 @@ class EmacsState:</span>
<span class="w"> </span>    Mutable class to hold Emacs specific state.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # Simple macro recording. (Like Readline does.)</span>
<span class="gi">+        # (For Emacs mode.)</span>
<span class="w"> </span>        self.macro: list[KeyPress] | None = []
<span class="w"> </span>        self.current_recording: list[KeyPress] | None = None

<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.current_recording = None</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def is_recording(self) -&gt;bool:</span>
<span class="gd">-        &quot;&quot;&quot;Tell whether we are recording a macro.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def is_recording(self) -&gt; bool:</span>
<span class="gi">+        &quot;Tell whether we are recording a macro.&quot;</span>
<span class="gi">+        return self.current_recording is not None</span>

<span class="gd">-    def start_macro(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Start recording macro.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def start_macro(self) -&gt; None:</span>
<span class="gi">+        &quot;Start recording macro.&quot;</span>
<span class="gi">+        self.current_recording = []</span>

<span class="gd">-    def end_macro(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;End recording macro.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def end_macro(self) -&gt; None:</span>
<span class="gi">+        &quot;End recording macro.&quot;</span>
<span class="gi">+        self.macro = self.current_recording</span>
<span class="gi">+        self.current_recording = None</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/key_bindings.py b/src/prompt_toolkit/key_binding/key_bindings.py</span>
<span class="gh">index 9d241939..62530f2b 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/key_bindings.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/key_bindings.py</span>
<span class="gu">@@ -35,20 +35,64 @@ been assigned, through the `key_binding` decorator.::</span>
<span class="w"> </span>    kb.add(Keys.A, my_key_binding)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod, abstractproperty
<span class="w"> </span>from inspect import isawaitable
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Coroutine, Hashable, Sequence, Tuple, TypeVar, Union, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Coroutine,</span>
<span class="gi">+    Hashable,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cache import SimpleCache
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, Never, to_filter
<span class="w"> </span>from prompt_toolkit.keys import KEY_ALIASES, Keys
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gi">+    # Avoid circular imports.</span>
<span class="w"> </span>    from .key_processor import KeyPressEvent
<span class="gi">+</span>
<span class="gi">+    # The only two return values for a mouse handler (and key bindings) are</span>
<span class="gi">+    # `None` and `NotImplemented`. For the type checker it&#39;s best to annotate</span>
<span class="gi">+    # this as `object`. (The consumer never expects a more specific instance:</span>
<span class="gi">+    # checking for NotImplemented can be done using `is NotImplemented`.)</span>
<span class="w"> </span>    NotImplementedOrNone = object
<span class="gd">-__all__ = [&#39;NotImplementedOrNone&#39;, &#39;Binding&#39;, &#39;KeyBindingsBase&#39;,</span>
<span class="gd">-    &#39;KeyBindings&#39;, &#39;ConditionalKeyBindings&#39;, &#39;merge_key_bindings&#39;,</span>
<span class="gd">-    &#39;DynamicKeyBindings&#39;, &#39;GlobalOnlyKeyBindings&#39;]</span>
<span class="gd">-KeyHandlerCallable = Callable[[&#39;KeyPressEvent&#39;], Union[</span>
<span class="gd">-    &#39;NotImplementedOrNone&#39;, Coroutine[Any, Any, &#39;NotImplementedOrNone&#39;]]]</span>
<span class="gi">+    # Other non-working options are:</span>
<span class="gi">+    # * Optional[Literal[NotImplemented]]</span>
<span class="gi">+    #      --&gt; Doesn&#39;t work, Literal can&#39;t take an Any.</span>
<span class="gi">+    # * None</span>
<span class="gi">+    #      --&gt; Doesn&#39;t work. We can&#39;t assign the result of a function that</span>
<span class="gi">+    #          returns `None` to a variable.</span>
<span class="gi">+    # * Any</span>
<span class="gi">+    #      --&gt; Works, but too broad.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;NotImplementedOrNone&quot;,</span>
<span class="gi">+    &quot;Binding&quot;,</span>
<span class="gi">+    &quot;KeyBindingsBase&quot;,</span>
<span class="gi">+    &quot;KeyBindings&quot;,</span>
<span class="gi">+    &quot;ConditionalKeyBindings&quot;,</span>
<span class="gi">+    &quot;merge_key_bindings&quot;,</span>
<span class="gi">+    &quot;DynamicKeyBindings&quot;,</span>
<span class="gi">+    &quot;GlobalOnlyKeyBindings&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Key bindings can be regular functions or coroutines.</span>
<span class="gi">+# In both cases, if they return `NotImplemented`, the UI won&#39;t be invalidated.</span>
<span class="gi">+# This is mainly used in case of mouse move events, to prevent excessive</span>
<span class="gi">+# repainting during mouse move events.</span>
<span class="gi">+KeyHandlerCallable = Callable[</span>
<span class="gi">+    [&quot;KeyPressEvent&quot;],</span>
<span class="gi">+    Union[&quot;NotImplementedOrNone&quot;, Coroutine[Any, Any, &quot;NotImplementedOrNone&quot;]],</span>
<span class="gi">+]</span>


<span class="w"> </span>class Binding:
<span class="gu">@@ -60,11 +104,16 @@ class Binding:</span>
<span class="w"> </span>        macro is recorded.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, keys: tuple[Keys | str, ...], handler:</span>
<span class="gd">-        KeyHandlerCallable, filter: FilterOrBool=True, eager: FilterOrBool=</span>
<span class="gd">-        False, is_global: FilterOrBool=False, save_before: Callable[[</span>
<span class="gd">-        KeyPressEvent], bool]=lambda e: True, record_in_macro: FilterOrBool</span>
<span class="gd">-        =True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        keys: tuple[Keys | str, ...],</span>
<span class="gi">+        handler: KeyHandlerCallable,</span>
<span class="gi">+        filter: FilterOrBool = True,</span>
<span class="gi">+        eager: FilterOrBool = False,</span>
<span class="gi">+        is_global: FilterOrBool = False,</span>
<span class="gi">+        save_before: Callable[[KeyPressEvent], bool] = (lambda e: True),</span>
<span class="gi">+        record_in_macro: FilterOrBool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.keys = keys
<span class="w"> </span>        self.handler = handler
<span class="w"> </span>        self.filter = to_filter(filter)
<span class="gu">@@ -73,11 +122,32 @@ class Binding:</span>
<span class="w"> </span>        self.save_before = save_before
<span class="w"> </span>        self.record_in_macro = to_filter(record_in_macro)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(keys={!r}, handler={!r})&#39;.format(self.__class__.__name__,</span>
<span class="gd">-            self.keys, self.handler)</span>
<span class="gi">+    def call(self, event: KeyPressEvent) -&gt; None:</span>
<span class="gi">+        result = self.handler(event)</span>
<span class="gi">+</span>
<span class="gi">+        # If the handler is a coroutine, create an asyncio task.</span>
<span class="gi">+        if isawaitable(result):</span>
<span class="gi">+            awaitable = cast(Coroutine[Any, Any, &quot;NotImplementedOrNone&quot;], result)</span>
<span class="gi">+</span>
<span class="gi">+            async def bg_task() -&gt; None:</span>
<span class="gi">+                result = await awaitable</span>
<span class="gi">+                if result != NotImplemented:</span>
<span class="gi">+                    event.app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+            event.app.create_background_task(bg_task())</span>
<span class="gi">+</span>
<span class="gi">+        elif result != NotImplemented:</span>
<span class="gi">+            event.app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(keys={!r}, handler={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.keys,</span>
<span class="gi">+            self.handler,</span>
<span class="gi">+        )</span>


<span class="gi">+# Sequence of keys presses.</span>
<span class="w"> </span>KeysTuple = Tuple[Union[Keys, str], ...]


<span class="gu">@@ -87,15 +157,15 @@ class KeyBindingsBase(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractproperty
<span class="gd">-    def _version(self) -&gt;Hashable:</span>
<span class="gi">+    def _version(self) -&gt; Hashable:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For cache invalidation. - This should increase every time that
<span class="w"> </span>        something changes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_bindings_for_keys(self, keys: KeysTuple) -&gt;list[Binding]:</span>
<span class="gi">+    def get_bindings_for_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of key bindings that can handle these keys.
<span class="w"> </span>        (This return also inactive bindings, so the `filter` still has to be
<span class="gu">@@ -103,10 +173,10 @@ class KeyBindingsBase(metaclass=ABCMeta):</span>

<span class="w"> </span>        :param keys: tuple of keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt;list[Binding]:</span>
<span class="gi">+    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of key bindings that handle a key sequence starting with
<span class="w"> </span>        `keys`. (It does only return bindings for which the sequences are
<span class="gu">@@ -115,19 +185,21 @@ class KeyBindingsBase(metaclass=ABCMeta):</span>

<span class="w"> </span>        :param keys: tuple of keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    @abstractproperty
<span class="gd">-    def bindings(self) -&gt;list[Binding]:</span>
<span class="gi">+    def bindings(self) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        List of `Binding` objects.
<span class="w"> </span>        (These need to be exposed, so that `KeyBindings` objects can be merged
<span class="w"> </span>        together.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="gi">+    # `add` and `remove` don&#39;t have to be part of this interface.</span>

<span class="gd">-T = TypeVar(&#39;T&#39;, bound=Union[KeyHandlerCallable, Binding])</span>
<span class="gi">+</span>
<span class="gi">+T = TypeVar(&quot;T&quot;, bound=Union[KeyHandlerCallable, Binding])</span>


<span class="w"> </span>class KeyBindings(KeyBindingsBase):
<span class="gu">@@ -152,18 +224,38 @@ class KeyBindings(KeyBindingsBase):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._bindings: list[Binding] = []
<span class="gd">-        self._get_bindings_for_keys_cache: SimpleCache[KeysTuple, list[Binding]</span>
<span class="gd">-            ] = SimpleCache(maxsize=10000)</span>
<span class="gd">-        self._get_bindings_starting_with_keys_cache: SimpleCache[KeysTuple,</span>
<span class="gd">-            list[Binding]] = SimpleCache(maxsize=1000)</span>
<span class="gd">-        self.__version = 0</span>
<span class="gd">-</span>
<span class="gd">-    def add(self, *keys: (Keys | str), filter: FilterOrBool=True, eager:</span>
<span class="gd">-        FilterOrBool=False, is_global: FilterOrBool=False, save_before:</span>
<span class="gd">-        Callable[[KeyPressEvent], bool]=lambda e: True, record_in_macro:</span>
<span class="gd">-        FilterOrBool=True) -&gt;Callable[[T], T]:</span>
<span class="gi">+        self._get_bindings_for_keys_cache: SimpleCache[</span>
<span class="gi">+            KeysTuple, list[Binding]</span>
<span class="gi">+        ] = SimpleCache(maxsize=10000)</span>
<span class="gi">+        self._get_bindings_starting_with_keys_cache: SimpleCache[</span>
<span class="gi">+            KeysTuple, list[Binding]</span>
<span class="gi">+        ] = SimpleCache(maxsize=1000)</span>
<span class="gi">+        self.__version = 0  # For cache invalidation.</span>
<span class="gi">+</span>
<span class="gi">+    def _clear_cache(self) -&gt; None:</span>
<span class="gi">+        self.__version += 1</span>
<span class="gi">+        self._get_bindings_for_keys_cache.clear()</span>
<span class="gi">+        self._get_bindings_starting_with_keys_cache.clear()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def bindings(self) -&gt; list[Binding]:</span>
<span class="gi">+        return self._bindings</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _version(self) -&gt; Hashable:</span>
<span class="gi">+        return self.__version</span>
<span class="gi">+</span>
<span class="gi">+    def add(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *keys: Keys | str,</span>
<span class="gi">+        filter: FilterOrBool = True,</span>
<span class="gi">+        eager: FilterOrBool = False,</span>
<span class="gi">+        is_global: FilterOrBool = False,</span>
<span class="gi">+        save_before: Callable[[KeyPressEvent], bool] = (lambda e: True),</span>
<span class="gi">+        record_in_macro: FilterOrBool = True,</span>
<span class="gi">+    ) -&gt; Callable[[T], T]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Decorator for adding a key bindings.

<span class="gu">@@ -182,9 +274,52 @@ class KeyBindings(KeyBindingsBase):</span>
<span class="w"> </span>        :param record_in_macro: Record these key bindings when a macro is
<span class="w"> </span>            being recorded. (True by default.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def remove(self, *args: (Keys | str | KeyHandlerCallable)) -&gt;None:</span>
<span class="gi">+        assert keys</span>
<span class="gi">+</span>
<span class="gi">+        keys = tuple(_parse_key(k) for k in keys)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(filter, Never):</span>
<span class="gi">+            # When a filter is Never, it will always stay disabled, so in that</span>
<span class="gi">+            # case don&#39;t bother putting it in the key bindings. It will slow</span>
<span class="gi">+            # down every key press otherwise.</span>
<span class="gi">+            def decorator(func: T) -&gt; T:</span>
<span class="gi">+                return func</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def decorator(func: T) -&gt; T:</span>
<span class="gi">+                if isinstance(func, Binding):</span>
<span class="gi">+                    # We&#39;re adding an existing Binding object.</span>
<span class="gi">+                    self.bindings.append(</span>
<span class="gi">+                        Binding(</span>
<span class="gi">+                            keys,</span>
<span class="gi">+                            func.handler,</span>
<span class="gi">+                            filter=func.filter &amp; to_filter(filter),</span>
<span class="gi">+                            eager=to_filter(eager) | func.eager,</span>
<span class="gi">+                            is_global=to_filter(is_global) | func.is_global,</span>
<span class="gi">+                            save_before=func.save_before,</span>
<span class="gi">+                            record_in_macro=func.record_in_macro,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.bindings.append(</span>
<span class="gi">+                        Binding(</span>
<span class="gi">+                            keys,</span>
<span class="gi">+                            cast(KeyHandlerCallable, func),</span>
<span class="gi">+                            filter=filter,</span>
<span class="gi">+                            eager=eager,</span>
<span class="gi">+                            is_global=is_global,</span>
<span class="gi">+                            save_before=save_before,</span>
<span class="gi">+                            record_in_macro=record_in_macro,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                self._clear_cache()</span>
<span class="gi">+</span>
<span class="gi">+                return func</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    def remove(self, *args: Keys | str | KeyHandlerCallable) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove a key binding.

<span class="gu">@@ -198,11 +333,41 @@ class KeyBindings(KeyBindingsBase):</span>
<span class="w"> </span>            remove(handler)  # Pass handler.
<span class="w"> </span>            remove(&#39;c-x&#39;, &#39;c-a&#39;)  # Or pass the key bindings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        found = False</span>
<span class="gi">+</span>
<span class="gi">+        if callable(args[0]):</span>
<span class="gi">+            assert len(args) == 1</span>
<span class="gi">+            function = args[0]</span>
<span class="gi">+</span>
<span class="gi">+            # Remove the given function.</span>
<span class="gi">+            for b in self.bindings:</span>
<span class="gi">+                if b.handler == function:</span>
<span class="gi">+                    self.bindings.remove(b)</span>
<span class="gi">+                    found = True</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert len(args) &gt; 0</span>
<span class="gi">+            args = cast(Tuple[Union[Keys, str]], args)</span>
<span class="gi">+</span>
<span class="gi">+            # Remove this sequence of key bindings.</span>
<span class="gi">+            keys = tuple(_parse_key(k) for k in args)</span>
<span class="gi">+</span>
<span class="gi">+            for b in self.bindings:</span>
<span class="gi">+                if b.keys == keys:</span>
<span class="gi">+                    self.bindings.remove(b)</span>
<span class="gi">+                    found = True</span>
<span class="gi">+</span>
<span class="gi">+        if found:</span>
<span class="gi">+            self._clear_cache()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # No key binding found for this function. Raise ValueError.</span>
<span class="gi">+            raise ValueError(f&quot;Binding not found: {function!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # For backwards-compatibility.</span>
<span class="w"> </span>    add_binding = add
<span class="w"> </span>    remove_binding = remove

<span class="gd">-    def get_bindings_for_keys(self, keys: KeysTuple) -&gt;list[Binding]:</span>
<span class="gi">+    def get_bindings_for_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of key bindings that can handle this key.
<span class="w"> </span>        (This return also inactive bindings, so the `filter` still has to be
<span class="gu">@@ -210,9 +375,34 @@ class KeyBindings(KeyBindingsBase):</span>

<span class="w"> </span>        :param keys: tuple of keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt;list[Binding]:</span>
<span class="gi">+        def get() -&gt; list[Binding]:</span>
<span class="gi">+            result: list[tuple[int, Binding]] = []</span>
<span class="gi">+</span>
<span class="gi">+            for b in self.bindings:</span>
<span class="gi">+                if len(keys) == len(b.keys):</span>
<span class="gi">+                    match = True</span>
<span class="gi">+                    any_count = 0</span>
<span class="gi">+</span>
<span class="gi">+                    for i, j in zip(b.keys, keys):</span>
<span class="gi">+                        if i != j and i != Keys.Any:</span>
<span class="gi">+                            match = False</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                        if i == Keys.Any:</span>
<span class="gi">+                            any_count += 1</span>
<span class="gi">+</span>
<span class="gi">+                    if match:</span>
<span class="gi">+                        result.append((any_count, b))</span>
<span class="gi">+</span>
<span class="gi">+            # Place bindings that have more &#39;Any&#39; occurrences in them at the end.</span>
<span class="gi">+            result = sorted(result, key=lambda item: -item[0])</span>
<span class="gi">+</span>
<span class="gi">+            return [item[1] for item in result]</span>
<span class="gi">+</span>
<span class="gi">+        return self._get_bindings_for_keys_cache.get(keys, get)</span>
<span class="gi">+</span>
<span class="gi">+    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of key bindings that handle a key sequence starting with
<span class="w"> </span>        `keys`. (It does only return bindings for which the sequences are
<span class="gu">@@ -221,25 +411,83 @@ class KeyBindings(KeyBindingsBase):</span>

<span class="w"> </span>        :param keys: tuple of keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gi">+        def get() -&gt; list[Binding]:</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for b in self.bindings:</span>
<span class="gi">+                if len(keys) &lt; len(b.keys):</span>
<span class="gi">+                    match = True</span>
<span class="gi">+                    for i, j in zip(b.keys, keys):</span>
<span class="gi">+                        if i != j and i != Keys.Any:</span>
<span class="gi">+                            match = False</span>
<span class="gi">+                            break</span>
<span class="gi">+                    if match:</span>
<span class="gi">+                        result.append(b)</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return self._get_bindings_starting_with_keys_cache.get(keys, get)</span>

<span class="gd">-def _parse_key(key: (Keys | str)) -&gt;(str | Keys):</span>
<span class="gi">+</span>
<span class="gi">+def _parse_key(key: Keys | str) -&gt; str | Keys:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace key by alias and verify whether it&#39;s a valid one.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Already a parse key? -&gt; Return it.</span>
<span class="gi">+    if isinstance(key, Keys):</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    # Lookup aliases.</span>
<span class="gi">+    key = KEY_ALIASES.get(key, key)</span>
<span class="gi">+</span>
<span class="gi">+    # Replace &#39;space&#39; by &#39; &#39;</span>
<span class="gi">+    if key == &quot;space&quot;:</span>
<span class="gi">+        key = &quot; &quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Return as `Key` object when it&#39;s a special key.</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Keys(key)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Final validation.</span>
<span class="gi">+    if len(key) != 1:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid key: {key}&quot;)</span>

<span class="gi">+    return key</span>

<span class="gd">-def key_binding(filter: FilterOrBool=True, eager: FilterOrBool=False,</span>
<span class="gd">-    is_global: FilterOrBool=False, save_before: Callable[[KeyPressEvent],</span>
<span class="gd">-    bool]=lambda event: True, record_in_macro: FilterOrBool=True) -&gt;Callable[</span>
<span class="gd">-    [KeyHandlerCallable], Binding]:</span>
<span class="gi">+</span>
<span class="gi">+def key_binding(</span>
<span class="gi">+    filter: FilterOrBool = True,</span>
<span class="gi">+    eager: FilterOrBool = False,</span>
<span class="gi">+    is_global: FilterOrBool = False,</span>
<span class="gi">+    save_before: Callable[[KeyPressEvent], bool] = (lambda event: True),</span>
<span class="gi">+    record_in_macro: FilterOrBool = True,</span>
<span class="gi">+) -&gt; Callable[[KeyHandlerCallable], Binding]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decorator that turn a function into a `Binding` object. This can be added
<span class="w"> </span>    to a `KeyBindings` object when a key binding is assigned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert save_before is None or callable(save_before)</span>
<span class="gi">+</span>
<span class="gi">+    filter = to_filter(filter)</span>
<span class="gi">+    eager = to_filter(eager)</span>
<span class="gi">+    is_global = to_filter(is_global)</span>
<span class="gi">+    save_before = save_before</span>
<span class="gi">+    record_in_macro = to_filter(record_in_macro)</span>
<span class="gi">+    keys = ()</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(function: KeyHandlerCallable) -&gt; Binding:</span>
<span class="gi">+        return Binding(</span>
<span class="gi">+            keys,</span>
<span class="gi">+            function,</span>
<span class="gi">+            filter=filter,</span>
<span class="gi">+            eager=eager,</span>
<span class="gi">+            is_global=is_global,</span>
<span class="gi">+            save_before=save_before,</span>
<span class="gi">+            record_in_macro=record_in_macro,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>class _Proxy(KeyBindingsBase):
<span class="gu">@@ -247,16 +495,37 @@ class _Proxy(KeyBindingsBase):</span>
<span class="w"> </span>    Common part for ConditionalKeyBindings and _MergedKeyBindings.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # `KeyBindings` to be synchronized with all the others.</span>
<span class="w"> </span>        self._bindings2: KeyBindingsBase = KeyBindings()
<span class="w"> </span>        self._last_version: Hashable = ()

<span class="gd">-    def _update_cache(self) -&gt;None:</span>
<span class="gi">+    def _update_cache(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If `self._last_version` is outdated, then this should update
<span class="w"> </span>        the version and `self._bindings2`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    # Proxy methods to self._bindings2.</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def bindings(self) -&gt; list[Binding]:</span>
<span class="gi">+        self._update_cache()</span>
<span class="gi">+        return self._bindings2.bindings</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _version(self) -&gt; Hashable:</span>
<span class="gi">+        self._update_cache()</span>
<span class="gi">+        return self._last_version</span>
<span class="gi">+</span>
<span class="gi">+    def get_bindings_for_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="gi">+        self._update_cache()</span>
<span class="gi">+        return self._bindings2.get_bindings_for_keys(keys)</span>
<span class="gi">+</span>
<span class="gi">+    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt; list[Binding]:</span>
<span class="gi">+        self._update_cache()</span>
<span class="gi">+        return self._bindings2.get_bindings_starting_with_keys(keys)</span>


<span class="w"> </span>class ConditionalKeyBindings(_Proxy):
<span class="gu">@@ -277,15 +546,37 @@ class ConditionalKeyBindings(_Proxy):</span>
<span class="w"> </span>    :param filter: :class:`~prompt_toolkit.filters.Filter` object.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, key_bindings: KeyBindingsBase, filter: FilterOrBool=True</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, key_bindings: KeyBindingsBase, filter: FilterOrBool = True</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        _Proxy.__init__(self)
<span class="gi">+</span>
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gd">-    def _update_cache(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;If the original key bindings was changed. Update our copy version.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _update_cache(self) -&gt; None:</span>
<span class="gi">+        &quot;If the original key bindings was changed. Update our copy version.&quot;</span>
<span class="gi">+        expected_version = self.key_bindings._version</span>
<span class="gi">+</span>
<span class="gi">+        if self._last_version != expected_version:</span>
<span class="gi">+            bindings2 = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+            # Copy all bindings from `self.key_bindings`, adding our condition.</span>
<span class="gi">+            for b in self.key_bindings.bindings:</span>
<span class="gi">+                bindings2.bindings.append(</span>
<span class="gi">+                    Binding(</span>
<span class="gi">+                        keys=b.keys,</span>
<span class="gi">+                        handler=b.handler,</span>
<span class="gi">+                        filter=self.filter &amp; b.filter,</span>
<span class="gi">+                        eager=b.eager,</span>
<span class="gi">+                        is_global=b.is_global,</span>
<span class="gi">+                        save_before=b.save_before,</span>
<span class="gi">+                        record_in_macro=b.record_in_macro,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            self._bindings2 = bindings2</span>
<span class="gi">+            self._last_version = expected_version</span>


<span class="w"> </span>class _MergedKeyBindings(_Proxy):
<span class="gu">@@ -298,20 +589,28 @@ class _MergedKeyBindings(_Proxy):</span>
<span class="w"> </span>    :param registries: List of :class:`.KeyBindings` objects.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, registries: Sequence[KeyBindingsBase]) -&gt;None:</span>
<span class="gi">+    def __init__(self, registries: Sequence[KeyBindingsBase]) -&gt; None:</span>
<span class="w"> </span>        _Proxy.__init__(self)
<span class="w"> </span>        self.registries = registries

<span class="gd">-    def _update_cache(self) -&gt;None:</span>
<span class="gi">+    def _update_cache(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If one of the original registries was changed. Update our merged
<span class="w"> </span>        version.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expected_version = tuple(r._version for r in self.registries)</span>
<span class="gi">+</span>
<span class="gi">+        if self._last_version != expected_version:</span>
<span class="gi">+            bindings2 = KeyBindings()</span>

<span class="gi">+            for reg in self.registries:</span>
<span class="gi">+                bindings2.bindings.extend(reg.bindings)</span>

<span class="gd">-def merge_key_bindings(bindings: Sequence[KeyBindingsBase]</span>
<span class="gd">-    ) -&gt;_MergedKeyBindings:</span>
<span class="gi">+            self._bindings2 = bindings2</span>
<span class="gi">+            self._last_version = expected_version</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge_key_bindings(bindings: Sequence[KeyBindingsBase]) -&gt; _MergedKeyBindings:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple :class:`.Keybinding` objects together.

<span class="gu">@@ -319,7 +618,7 @@ def merge_key_bindings(bindings: Sequence[KeyBindingsBase]</span>

<span class="w"> </span>        bindings = merge_key_bindings([bindings1, bindings2, ...])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _MergedKeyBindings(bindings)</span>


<span class="w"> </span>class DynamicKeyBindings(_Proxy):
<span class="gu">@@ -329,12 +628,19 @@ class DynamicKeyBindings(_Proxy):</span>
<span class="w"> </span>    :param get_key_bindings: Callable that returns a :class:`.KeyBindings` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_key_bindings: Callable[[], KeyBindingsBase | None]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_key_bindings: Callable[[], KeyBindingsBase | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_key_bindings = get_key_bindings
<span class="w"> </span>        self.__version = 0
<span class="w"> </span>        self._last_child_version = None
<span class="gd">-        self._dummy = KeyBindings()</span>
<span class="gi">+        self._dummy = KeyBindings()  # Empty key bindings.</span>
<span class="gi">+</span>
<span class="gi">+    def _update_cache(self) -&gt; None:</span>
<span class="gi">+        key_bindings = self.get_key_bindings() or self._dummy</span>
<span class="gi">+        assert isinstance(key_bindings, KeyBindingsBase)</span>
<span class="gi">+        version = id(key_bindings), key_bindings._version</span>
<span class="gi">+</span>
<span class="gi">+        self._bindings2 = key_bindings</span>
<span class="gi">+        self._last_version = version</span>


<span class="w"> </span>class GlobalOnlyKeyBindings(_Proxy):
<span class="gu">@@ -343,13 +649,23 @@ class GlobalOnlyKeyBindings(_Proxy):</span>
<span class="w"> </span>    key bindings.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, key_bindings: KeyBindingsBase) -&gt;None:</span>
<span class="gi">+    def __init__(self, key_bindings: KeyBindingsBase) -&gt; None:</span>
<span class="w"> </span>        _Proxy.__init__(self)
<span class="w"> </span>        self.key_bindings = key_bindings

<span class="gd">-    def _update_cache(self) -&gt;None:</span>
<span class="gi">+    def _update_cache(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If one of the original registries was changed. Update our merged
<span class="w"> </span>        version.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expected_version = self.key_bindings._version</span>
<span class="gi">+</span>
<span class="gi">+        if self._last_version != expected_version:</span>
<span class="gi">+            bindings2 = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+            for b in self.key_bindings.bindings:</span>
<span class="gi">+                if b.is_global():</span>
<span class="gi">+                    bindings2.bindings.append(b)</span>
<span class="gi">+</span>
<span class="gi">+            self._bindings2 = bindings2</span>
<span class="gi">+            self._last_version = expected_version</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/key_processor.py b/src/prompt_toolkit/key_binding/key_processor.py</span>
<span class="gh">index 4104a4f6..4c4f0d15 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/key_processor.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/key_processor.py</span>
<span class="gu">@@ -6,20 +6,30 @@ The `KeyProcessor` will according to the implemented keybindings call the</span>
<span class="w"> </span>correct callbacks when new key presses are feed through `feed`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import weakref
<span class="w"> </span>from asyncio import Task, sleep
<span class="w"> </span>from collections import deque
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Generator
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.enums import EditingMode
<span class="w"> </span>from prompt_toolkit.filters.app import vi_navigation_mode
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.utils import Event
<span class="gi">+</span>
<span class="w"> </span>from .key_bindings import Binding, KeyBindingsBase
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.application import Application
<span class="w"> </span>    from prompt_toolkit.buffer import Buffer
<span class="gd">-__all__ = [&#39;KeyProcessor&#39;, &#39;KeyPress&#39;, &#39;KeyPressEvent&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;KeyProcessor&quot;,</span>
<span class="gi">+    &quot;KeyPress&quot;,</span>
<span class="gi">+    &quot;KeyPressEvent&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class KeyPress:
<span class="gu">@@ -28,21 +38,22 @@ class KeyPress:</span>
<span class="w"> </span>    :param data: The received string on stdin. (Often vt100 escape codes.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, key: (Keys | str), data: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, key: Keys | str, data: str | None = None) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(key, Keys) or len(key) == 1
<span class="gi">+</span>
<span class="w"> </span>        if data is None:
<span class="w"> </span>            if isinstance(key, Keys):
<span class="w"> </span>                data = key.value
<span class="w"> </span>            else:
<span class="gd">-                data = key</span>
<span class="gi">+                data = key  # &#39;key&#39; is a one character string.</span>
<span class="gi">+</span>
<span class="w"> </span>        self.key = key
<span class="w"> </span>        self.data = data

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}(key={self.key!r}, data={self.data!r})&#39;)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(key={self.key!r}, data={self.data!r})&quot;</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, KeyPress):
<span class="w"> </span>            return False
<span class="w"> </span>        return self.key == other.key and self.data == other.data
<span class="gu">@@ -52,7 +63,7 @@ class KeyPress:</span>
<span class="w"> </span>Helper object to indicate flush operation in the KeyProcessor.
<span class="w"> </span>NOTE: the implementation is very similar to the VT100 parser.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-_Flush = KeyPress(&#39;?&#39;, data=&#39;_Flush&#39;)</span>
<span class="gi">+_Flush = KeyPress(&quot;?&quot;, data=&quot;_Flush&quot;)</span>


<span class="w"> </span>class KeyProcessor:
<span class="gu">@@ -65,8 +76,8 @@ class KeyProcessor:</span>
<span class="w"> </span>        p = KeyProcessor(key_bindings)

<span class="w"> </span>        # Send keys into the processor.
<span class="gd">-        p.feed(KeyPress(Keys.ControlX, &#39;&#39;))</span>
<span class="gd">-        p.feed(KeyPress(Keys.ControlC, &#39;&#39;)</span>
<span class="gi">+        p.feed(KeyPress(Keys.ControlX, &#39;\x18&#39;))</span>
<span class="gi">+        p.feed(KeyPress(Keys.ControlC, &#39;\x03&#39;)</span>

<span class="w"> </span>        # Process all the keys in the queue.
<span class="w"> </span>        p.process_keys()
<span class="gu">@@ -77,51 +88,144 @@ class KeyProcessor:</span>
<span class="w"> </span>    :param key_bindings: `KeyBindingsBase` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, key_bindings: KeyBindingsBase) -&gt;None:</span>
<span class="gi">+    def __init__(self, key_bindings: KeyBindingsBase) -&gt; None:</span>
<span class="w"> </span>        self._bindings = key_bindings
<span class="gi">+</span>
<span class="w"> </span>        self.before_key_press = Event(self)
<span class="w"> </span>        self.after_key_press = Event(self)
<span class="gi">+</span>
<span class="w"> </span>        self._flush_wait_task: Task[None] | None = None
<span class="gi">+</span>
<span class="w"> </span>        self.reset()

<span class="gd">-    def _get_matches(self, key_presses: list[KeyPress]) -&gt;list[Binding]:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self._previous_key_sequence: list[KeyPress] = []</span>
<span class="gi">+        self._previous_handler: Binding | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # The queue of keys not yet send to our _process generator/state machine.</span>
<span class="gi">+        self.input_queue: deque[KeyPress] = deque()</span>
<span class="gi">+</span>
<span class="gi">+        # The key buffer that is matched in the generator state machine.</span>
<span class="gi">+        # (This is at at most the amount of keys that make up for one key binding.)</span>
<span class="gi">+        self.key_buffer: list[KeyPress] = []</span>
<span class="gi">+</span>
<span class="gi">+        #: Readline argument (for repetition of commands.)</span>
<span class="gi">+        #: https://www.gnu.org/software/bash/manual/html_node/Readline-Arguments.html</span>
<span class="gi">+        self.arg: str | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # Start the processor coroutine.</span>
<span class="gi">+        self._process_coroutine = self._process()</span>
<span class="gi">+        self._process_coroutine.send(None)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _get_matches(self, key_presses: list[KeyPress]) -&gt; list[Binding]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For a list of :class:`KeyPress` instances. Give the matching handlers
<span class="w"> </span>        that would handle this.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        keys = tuple(k.key for k in key_presses)</span>
<span class="gi">+</span>
<span class="gi">+        # Try match, with mode flag</span>
<span class="gi">+        return [b for b in self._bindings.get_bindings_for_keys(keys) if b.filter()]</span>

<span class="gd">-    def _is_prefix_of_longer_match(self, key_presses: list[KeyPress]) -&gt;bool:</span>
<span class="gi">+    def _is_prefix_of_longer_match(self, key_presses: list[KeyPress]) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For a list of :class:`KeyPress` instances. Return True if there is any
<span class="w"> </span>        handler that is bound to a suffix of this keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        keys = tuple(k.key for k in key_presses)</span>

<span class="gd">-    def _process(self) -&gt;Generator[None, KeyPress, None]:</span>
<span class="gi">+        # Get the filters for all the key bindings that have a longer match.</span>
<span class="gi">+        # Note that we transform it into a `set`, because we don&#39;t care about</span>
<span class="gi">+        # the actual bindings and executing it more than once doesn&#39;t make</span>
<span class="gi">+        # sense. (Many key bindings share the same filter.)</span>
<span class="gi">+        filters = {</span>
<span class="gi">+            b.filter for b in self._bindings.get_bindings_starting_with_keys(keys)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # When any key binding is active, return True.</span>
<span class="gi">+        return any(f() for f in filters)</span>
<span class="gi">+</span>
<span class="gi">+    def _process(self) -&gt; Generator[None, KeyPress, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine implementing the key match algorithm. Key strokes are sent
<span class="w"> </span>        into this generator, and it calls the appropriate handlers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buffer = self.key_buffer</span>
<span class="gi">+        retry = False</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            flush = False</span>

<span class="gd">-    def feed(self, key_press: KeyPress, first: bool=False) -&gt;None:</span>
<span class="gi">+            if retry:</span>
<span class="gi">+                retry = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                key = yield</span>
<span class="gi">+                if key is _Flush:</span>
<span class="gi">+                    flush = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    buffer.append(key)</span>
<span class="gi">+</span>
<span class="gi">+            # If we have some key presses, check for matches.</span>
<span class="gi">+            if buffer:</span>
<span class="gi">+                matches = self._get_matches(buffer)</span>
<span class="gi">+</span>
<span class="gi">+                if flush:</span>
<span class="gi">+                    is_prefix_of_longer_match = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    is_prefix_of_longer_match = self._is_prefix_of_longer_match(buffer)</span>
<span class="gi">+</span>
<span class="gi">+                # When eager matches were found, give priority to them and also</span>
<span class="gi">+                # ignore all the longer matches.</span>
<span class="gi">+                eager_matches = [m for m in matches if m.eager()]</span>
<span class="gi">+</span>
<span class="gi">+                if eager_matches:</span>
<span class="gi">+                    matches = eager_matches</span>
<span class="gi">+                    is_prefix_of_longer_match = False</span>
<span class="gi">+</span>
<span class="gi">+                # Exact matches found, call handler.</span>
<span class="gi">+                if not is_prefix_of_longer_match and matches:</span>
<span class="gi">+                    self._call_handler(matches[-1], key_sequence=buffer[:])</span>
<span class="gi">+                    del buffer[:]  # Keep reference.</span>
<span class="gi">+</span>
<span class="gi">+                # No match found.</span>
<span class="gi">+                elif not is_prefix_of_longer_match and not matches:</span>
<span class="gi">+                    retry = True</span>
<span class="gi">+                    found = False</span>
<span class="gi">+</span>
<span class="gi">+                    # Loop over the input, try longest match first and shift.</span>
<span class="gi">+                    for i in range(len(buffer), 0, -1):</span>
<span class="gi">+                        matches = self._get_matches(buffer[:i])</span>
<span class="gi">+                        if matches:</span>
<span class="gi">+                            self._call_handler(matches[-1], key_sequence=buffer[:i])</span>
<span class="gi">+                            del buffer[:i]</span>
<span class="gi">+                            found = True</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                    if not found:</span>
<span class="gi">+                        del buffer[:1]</span>
<span class="gi">+</span>
<span class="gi">+    def feed(self, key_press: KeyPress, first: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a new :class:`KeyPress` to the input queue.
<span class="w"> </span>        (Don&#39;t forget to call `process_keys` in order to process the queue.)

<span class="w"> </span>        :param first: If true, insert before everything else.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if first:</span>
<span class="gi">+            self.input_queue.appendleft(key_press)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.input_queue.append(key_press)</span>

<span class="gd">-    def feed_multiple(self, key_presses: list[KeyPress], first: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def feed_multiple(self, key_presses: list[KeyPress], first: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param first: If true, insert before everything else.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if first:</span>
<span class="gi">+            self.input_queue.extendleft(reversed(key_presses))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.input_queue.extend(key_presses)</span>

<span class="gd">-    def process_keys(self) -&gt;None:</span>
<span class="gi">+    def process_keys(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Process all the keys in the `input_queue`.
<span class="w"> </span>        (To be called after `feed`.)
<span class="gu">@@ -130,30 +234,152 @@ class KeyProcessor:</span>
<span class="w"> </span>              possible to call `feed` from inside a key binding.
<span class="w"> </span>              This function keeps looping until the queue is empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+</span>
<span class="gi">+        def not_empty() -&gt; bool:</span>
<span class="gi">+            # When the application result is set, stop processing keys.  (E.g.</span>
<span class="gi">+            # if ENTER was received, followed by a few additional key strokes,</span>
<span class="gi">+            # leave the other keys in the queue.)</span>
<span class="gi">+            if app.is_done:</span>
<span class="gi">+                # But if there are still CPRResponse keys in the queue, these</span>
<span class="gi">+                # need to be processed.</span>
<span class="gi">+                return any(k for k in self.input_queue if k.key == Keys.CPRResponse)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return bool(self.input_queue)</span>
<span class="gi">+</span>
<span class="gi">+        def get_next() -&gt; KeyPress:</span>
<span class="gi">+            if app.is_done:</span>
<span class="gi">+                # Only process CPR responses. Everything else is typeahead.</span>
<span class="gi">+                cpr = [k for k in self.input_queue if k.key == Keys.CPRResponse][0]</span>
<span class="gi">+                self.input_queue.remove(cpr)</span>
<span class="gi">+                return cpr</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.input_queue.popleft()</span>
<span class="gi">+</span>
<span class="gi">+        is_flush = False</span>
<span class="gi">+</span>
<span class="gi">+        while not_empty():</span>
<span class="gi">+            # Process next key.</span>
<span class="gi">+            key_press = get_next()</span>

<span class="gd">-    def empty_queue(self) -&gt;list[KeyPress]:</span>
<span class="gi">+            is_flush = key_press is _Flush</span>
<span class="gi">+            is_cpr = key_press.key == Keys.CPRResponse</span>
<span class="gi">+</span>
<span class="gi">+            if not is_flush and not is_cpr:</span>
<span class="gi">+                self.before_key_press.fire()</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._process_coroutine.send(key_press)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                # If for some reason something goes wrong in the parser, (maybe</span>
<span class="gi">+                # an exception was raised) restart the processor for next time.</span>
<span class="gi">+                self.reset()</span>
<span class="gi">+                self.empty_queue()</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            if not is_flush and not is_cpr:</span>
<span class="gi">+                self.after_key_press.fire()</span>
<span class="gi">+</span>
<span class="gi">+        # Skip timeout if the last key was flush.</span>
<span class="gi">+        if not is_flush:</span>
<span class="gi">+            self._start_timeout()</span>
<span class="gi">+</span>
<span class="gi">+    def empty_queue(self) -&gt; list[KeyPress]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Empty the input queue. Return the unprocessed input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _fix_vi_cursor_position(self, event: KeyPressEvent) -&gt;None:</span>
<span class="gi">+        key_presses = list(self.input_queue)</span>
<span class="gi">+        self.input_queue.clear()</span>
<span class="gi">+</span>
<span class="gi">+        # Filter out CPRs. We don&#39;t want to return these.</span>
<span class="gi">+        key_presses = [k for k in key_presses if k.key != Keys.CPRResponse]</span>
<span class="gi">+        return key_presses</span>
<span class="gi">+</span>
<span class="gi">+    def _call_handler(self, handler: Binding, key_sequence: list[KeyPress]) -&gt; None:</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        was_recording_emacs = app.emacs_state.is_recording</span>
<span class="gi">+        was_recording_vi = bool(app.vi_state.recording_register)</span>
<span class="gi">+        was_temporary_navigation_mode = app.vi_state.temporary_navigation_mode</span>
<span class="gi">+        arg = self.arg</span>
<span class="gi">+        self.arg = None</span>
<span class="gi">+</span>
<span class="gi">+        event = KeyPressEvent(</span>
<span class="gi">+            weakref.ref(self),</span>
<span class="gi">+            arg=arg,</span>
<span class="gi">+            key_sequence=key_sequence,</span>
<span class="gi">+            previous_key_sequence=self._previous_key_sequence,</span>
<span class="gi">+            is_repeat=(handler == self._previous_handler),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Save the state of the current buffer.</span>
<span class="gi">+        if handler.save_before(event):</span>
<span class="gi">+            event.app.current_buffer.save_to_undo_stack()</span>
<span class="gi">+</span>
<span class="gi">+        # Call handler.</span>
<span class="gi">+        from prompt_toolkit.buffer import EditReadOnlyBuffer</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            handler.call(event)</span>
<span class="gi">+            self._fix_vi_cursor_position(event)</span>
<span class="gi">+</span>
<span class="gi">+        except EditReadOnlyBuffer:</span>
<span class="gi">+            # When a key binding does an attempt to change a buffer which is</span>
<span class="gi">+            # read-only, we can ignore that. We sound a bell and go on.</span>
<span class="gi">+            app.output.bell()</span>
<span class="gi">+</span>
<span class="gi">+        if was_temporary_navigation_mode:</span>
<span class="gi">+            self._leave_vi_temp_navigation_mode(event)</span>
<span class="gi">+</span>
<span class="gi">+        self._previous_key_sequence = key_sequence</span>
<span class="gi">+        self._previous_handler = handler</span>
<span class="gi">+</span>
<span class="gi">+        # Record the key sequence in our macro. (Only if we&#39;re in macro mode</span>
<span class="gi">+        # before and after executing the key.)</span>
<span class="gi">+        if handler.record_in_macro():</span>
<span class="gi">+            if app.emacs_state.is_recording and was_recording_emacs:</span>
<span class="gi">+                recording = app.emacs_state.current_recording</span>
<span class="gi">+                if recording is not None:  # Should always be true, given that</span>
<span class="gi">+                    # `was_recording_emacs` is set.</span>
<span class="gi">+                    recording.extend(key_sequence)</span>
<span class="gi">+</span>
<span class="gi">+            if app.vi_state.recording_register and was_recording_vi:</span>
<span class="gi">+                for k in key_sequence:</span>
<span class="gi">+                    app.vi_state.current_recording += k.data</span>
<span class="gi">+</span>
<span class="gi">+    def _fix_vi_cursor_position(self, event: KeyPressEvent) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        After every command, make sure that if we are in Vi navigation mode, we
<span class="w"> </span>        never put the cursor after the last character of a line. (Unless it&#39;s
<span class="w"> </span>        an empty line.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = event.app</span>
<span class="gi">+        buff = app.current_buffer</span>
<span class="gi">+        preferred_column = buff.preferred_column</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            vi_navigation_mode()</span>
<span class="gi">+            and buff.document.is_cursor_at_the_end_of_line</span>
<span class="gi">+            and len(buff.document.current_line) &gt; 0</span>
<span class="gi">+        ):</span>
<span class="gi">+            buff.cursor_position -= 1</span>

<span class="gd">-    def _leave_vi_temp_navigation_mode(self, event: KeyPressEvent) -&gt;None:</span>
<span class="gi">+            # Set the preferred_column for arrow up/down again.</span>
<span class="gi">+            # (This was cleared after changing the cursor position.)</span>
<span class="gi">+            buff.preferred_column = preferred_column</span>
<span class="gi">+</span>
<span class="gi">+    def _leave_vi_temp_navigation_mode(self, event: KeyPressEvent) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If we&#39;re in Vi temporary navigation (normal) mode, return to
<span class="w"> </span>        insert/replace mode after executing one action.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = event.app</span>
<span class="gi">+</span>
<span class="gi">+        if app.editing_mode == EditingMode.VI:</span>
<span class="gi">+            # Not waiting for a text object and no argument has been given.</span>
<span class="gi">+            if app.vi_state.operator_func is None and self.arg is None:</span>
<span class="gi">+                app.vi_state.temporary_navigation_mode = False</span>

<span class="gd">-    def _start_timeout(self) -&gt;None:</span>
<span class="gi">+    def _start_timeout(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start auto flush timeout. Similar to Vim&#39;s `timeoutlen` option.

<span class="gu">@@ -161,13 +387,37 @@ class KeyProcessor:</span>
<span class="w"> </span>        and no key was pressed in the meantime, we flush all data in the queue
<span class="w"> </span>        and call the appropriate key binding handlers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        timeout = app.timeoutlen</span>
<span class="gi">+</span>
<span class="gi">+        if timeout is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        async def wait() -&gt; None:</span>
<span class="gi">+            &quot;Wait for timeout.&quot;</span>
<span class="gi">+            # This sleep can be cancelled. In that case we don&#39;t flush.</span>
<span class="gi">+            await sleep(timeout)</span>
<span class="gi">+</span>
<span class="gi">+            if len(self.key_buffer) &gt; 0:</span>
<span class="gi">+                # (No keys pressed in the meantime.)</span>
<span class="gi">+                flush_keys()</span>
<span class="gi">+</span>
<span class="gi">+        def flush_keys() -&gt; None:</span>
<span class="gi">+            &quot;Flush keys.&quot;</span>
<span class="gi">+            self.feed(_Flush)</span>
<span class="gi">+            self.process_keys()</span>

<span class="gd">-    def send_sigint(self) -&gt;None:</span>
<span class="gi">+        # Automatically flush keys.</span>
<span class="gi">+        if self._flush_wait_task:</span>
<span class="gi">+            self._flush_wait_task.cancel()</span>
<span class="gi">+        self._flush_wait_task = app.create_background_task(wait())</span>
<span class="gi">+</span>
<span class="gi">+    def send_sigint(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send SIGINT. Immediately call the SIGINT key handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.feed(KeyPress(key=Keys.SIGINT), first=True)</span>
<span class="gi">+        self.process_keys()</span>


<span class="w"> </span>class KeyPressEvent:
<span class="gu">@@ -181,57 +431,99 @@ class KeyPressEvent:</span>
<span class="w"> </span>    :param is_repeat: True when the previous event was delivered to the same handler.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, key_processor_ref: weakref.ReferenceType[</span>
<span class="gd">-        KeyProcessor], arg: (str | None), key_sequence: list[KeyPress],</span>
<span class="gd">-        previous_key_sequence: list[KeyPress], is_repeat: bool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        key_processor_ref: weakref.ReferenceType[KeyProcessor],</span>
<span class="gi">+        arg: str | None,</span>
<span class="gi">+        key_sequence: list[KeyPress],</span>
<span class="gi">+        previous_key_sequence: list[KeyPress],</span>
<span class="gi">+        is_repeat: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._key_processor_ref = key_processor_ref
<span class="w"> </span>        self.key_sequence = key_sequence
<span class="w"> </span>        self.previous_key_sequence = previous_key_sequence
<span class="gi">+</span>
<span class="gi">+        #: True when the previous key sequence was handled by the same handler.</span>
<span class="w"> </span>        self.is_repeat = is_repeat
<span class="gi">+</span>
<span class="w"> </span>        self._arg = arg
<span class="w"> </span>        self._app = get_app()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (&#39;KeyPressEvent(arg={!r}, key_sequence={!r}, is_repeat={!r})&#39;</span>
<span class="gd">-            .format(self.arg, self.key_sequence, self.is_repeat))</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;KeyPressEvent(arg={!r}, key_sequence={!r}, is_repeat={!r})&quot;.format(</span>
<span class="gi">+            self.arg,</span>
<span class="gi">+            self.key_sequence,</span>
<span class="gi">+            self.is_repeat,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def data(self) -&gt; str:</span>
<span class="gi">+        return self.key_sequence[-1].data</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def key_processor(self) -&gt; KeyProcessor:</span>
<span class="gi">+        processor = self._key_processor_ref()</span>
<span class="gi">+        if processor is None:</span>
<span class="gi">+            raise Exception(&quot;KeyProcessor was lost. This should not happen.&quot;)</span>
<span class="gi">+        return processor</span>

<span class="w"> </span>    @property
<span class="gd">-    def app(self) -&gt;Application[Any]:</span>
<span class="gi">+    def app(self) -&gt; Application[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The current `Application` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._app</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_buffer(self) -&gt;Buffer:</span>
<span class="gi">+    def current_buffer(self) -&gt; Buffer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The current buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.app.current_buffer</span>

<span class="w"> </span>    @property
<span class="gd">-    def arg(self) -&gt;int:</span>
<span class="gi">+    def arg(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Repetition argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._arg == &quot;-&quot;:</span>
<span class="gi">+            return -1</span>
<span class="gi">+</span>
<span class="gi">+        result = int(self._arg or 1)</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t exceed a million.</span>
<span class="gi">+        if int(result) &gt;= 1000000:</span>
<span class="gi">+            result = 1</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    @property
<span class="gd">-    def arg_present(self) -&gt;bool:</span>
<span class="gi">+    def arg_present(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True if repetition argument was explicitly provided.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._arg is not None</span>

<span class="gd">-    def append_to_arg_count(self, data: str) -&gt;None:</span>
<span class="gi">+    def append_to_arg_count(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add digit to the input argument.

<span class="w"> </span>        :param data: the typed digit as string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert data in &quot;-0123456789&quot;</span>
<span class="gi">+        current = self._arg</span>
<span class="gi">+</span>
<span class="gi">+        if data == &quot;-&quot;:</span>
<span class="gi">+            assert current is None or current == &quot;-&quot;</span>
<span class="gi">+            result = data</span>
<span class="gi">+        elif current is None:</span>
<span class="gi">+            result = data</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = f&quot;{current}{data}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self.key_processor.arg = result</span>

<span class="w"> </span>    @property
<span class="gd">-    def cli(self) -&gt;Application[Any]:</span>
<span class="gd">-        &quot;&quot;&quot;For backward-compatibility.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cli(self) -&gt; Application[Any]:</span>
<span class="gi">+        &quot;For backward-compatibility.&quot;</span>
<span class="gi">+        return self.app</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/vi_state.py b/src/prompt_toolkit/key_binding/vi_state.py</span>
<span class="gh">index be95b80e..7ec552fa 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/vi_state.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/vi_state.py</span>
<span class="gu">@@ -1,25 +1,33 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.clipboard import ClipboardData
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .key_bindings.vi import TextObject
<span class="w"> </span>    from .key_processor import KeyPressEvent
<span class="gd">-__all__ = [&#39;InputMode&#39;, &#39;CharacterFind&#39;, &#39;ViState&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;InputMode&quot;,</span>
<span class="gi">+    &quot;CharacterFind&quot;,</span>
<span class="gi">+    &quot;ViState&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class InputMode(str, Enum):
<span class="w"> </span>    value: str
<span class="gd">-    INSERT = &#39;vi-insert&#39;</span>
<span class="gd">-    INSERT_MULTIPLE = &#39;vi-insert-multiple&#39;</span>
<span class="gd">-    NAVIGATION = &#39;vi-navigation&#39;</span>
<span class="gd">-    REPLACE = &#39;vi-replace&#39;</span>
<span class="gd">-    REPLACE_SINGLE = &#39;vi-replace-single&#39;</span>

<span class="gi">+    INSERT = &quot;vi-insert&quot;</span>
<span class="gi">+    INSERT_MULTIPLE = &quot;vi-insert-multiple&quot;</span>
<span class="gi">+    NAVIGATION = &quot;vi-navigation&quot;  # Normal mode.</span>
<span class="gi">+    REPLACE = &quot;vi-replace&quot;</span>
<span class="gi">+    REPLACE_SINGLE = &quot;vi-replace-single&quot;</span>

<span class="gd">-class CharacterFind:</span>

<span class="gd">-    def __init__(self, character: str, backwards: bool=False) -&gt;None:</span>
<span class="gi">+class CharacterFind:</span>
<span class="gi">+    def __init__(self, character: str, backwards: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.character = character
<span class="w"> </span>        self.backwards = backwards

<span class="gu">@@ -29,32 +37,71 @@ class ViState:</span>
<span class="w"> </span>    Mutable class to hold the state of the Vi navigation.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        #: None or CharacterFind instance. (This is used to repeat the last</span>
<span class="gi">+        #: search in Vi mode, by pressing the &#39;n&#39; or &#39;N&#39; in navigation mode.)</span>
<span class="w"> </span>        self.last_character_find: CharacterFind | None = None
<span class="gd">-        self.operator_func: None | Callable[[KeyPressEvent, TextObject], None</span>
<span class="gd">-            ] = None</span>
<span class="gi">+</span>
<span class="gi">+        # When an operator is given and we are waiting for text object,</span>
<span class="gi">+        # -- e.g. in the case of &#39;dw&#39;, after the &#39;d&#39; --, an operator callback</span>
<span class="gi">+        # is set here.</span>
<span class="gi">+        self.operator_func: None | (Callable[[KeyPressEvent, TextObject], None]) = None</span>
<span class="w"> </span>        self.operator_arg: int | None = None
<span class="gi">+</span>
<span class="gi">+        #: Named registers. Maps register name (e.g. &#39;a&#39;) to</span>
<span class="gi">+        #: :class:`ClipboardData` instances.</span>
<span class="w"> </span>        self.named_registers: dict[str, ClipboardData] = {}
<span class="gi">+</span>
<span class="gi">+        #: The Vi mode we&#39;re currently in to.</span>
<span class="w"> </span>        self.__input_mode = InputMode.INSERT
<span class="gi">+</span>
<span class="gi">+        #: Waiting for digraph.</span>
<span class="w"> </span>        self.waiting_for_digraph = False
<span class="gd">-        self.digraph_symbol1: str | None = None</span>
<span class="gi">+        self.digraph_symbol1: str | None = None  # (None or a symbol.)</span>
<span class="gi">+</span>
<span class="gi">+        #: When true, make ~ act as an operator.</span>
<span class="w"> </span>        self.tilde_operator = False
<span class="gi">+</span>
<span class="gi">+        #: Register in which we are recording a macro.</span>
<span class="gi">+        #: `None` when not recording anything.</span>
<span class="gi">+        # Note that the recording is only stored in the register after the</span>
<span class="gi">+        # recording is stopped. So we record in a separate `current_recording`</span>
<span class="gi">+        # variable.</span>
<span class="w"> </span>        self.recording_register: str | None = None
<span class="gd">-        self.current_recording: str = &#39;&#39;</span>
<span class="gi">+        self.current_recording: str = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Temporary navigation (normal) mode.</span>
<span class="gi">+        # This happens when control-o has been pressed in insert or replace</span>
<span class="gi">+        # mode. The user can now do one navigation action and we&#39;ll return back</span>
<span class="gi">+        # to insert/replace.</span>
<span class="w"> </span>        self.temporary_navigation_mode = False

<span class="w"> </span>    @property
<span class="gd">-    def input_mode(self) -&gt;InputMode:</span>
<span class="gd">-        &quot;&quot;&quot;Get `InputMode`.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def input_mode(self) -&gt; InputMode:</span>
<span class="gi">+        &quot;Get `InputMode`.&quot;</span>
<span class="gi">+        return self.__input_mode</span>

<span class="w"> </span>    @input_mode.setter
<span class="gd">-    def input_mode(self, value: InputMode) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Set `InputMode`.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def input_mode(self, value: InputMode) -&gt; None:</span>
<span class="gi">+        &quot;Set `InputMode`.&quot;</span>
<span class="gi">+        if value == InputMode.NAVIGATION:</span>
<span class="gi">+            self.waiting_for_digraph = False</span>
<span class="gi">+            self.operator_func = None</span>
<span class="gi">+            self.operator_arg = None</span>

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+        self.__input_mode = value</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reset state, go back to the given mode. INSERT by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Go back to insert mode.</span>
<span class="gi">+        self.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+        self.waiting_for_digraph = False</span>
<span class="gi">+        self.operator_func = None</span>
<span class="gi">+        self.operator_arg = None</span>
<span class="gi">+</span>
<span class="gi">+        # Reset recording state.</span>
<span class="gi">+        self.recording_register = None</span>
<span class="gi">+        self.current_recording = &quot;&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/keys.py b/src/prompt_toolkit/keys.py</span>
<span class="gh">index ce6ce6bd..ee52aee8 100644</span>
<span class="gd">--- a/src/prompt_toolkit/keys.py</span>
<span class="gi">+++ b/src/prompt_toolkit/keys.py</span>
<span class="gu">@@ -1,6 +1,11 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from enum import Enum
<span class="gd">-__all__ = [&#39;Keys&#39;, &#39;ALL_KEYS&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Keys&quot;,</span>
<span class="gi">+    &quot;ALL_KEYS&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Keys(str, Enum):
<span class="gu">@@ -10,162 +15,190 @@ class Keys(str, Enum):</span>
<span class="w"> </span>    Note that this is an &quot;StrEnum&quot;, all values can be compared against
<span class="w"> </span>    strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    value: str
<span class="gd">-    Escape = &#39;escape&#39;</span>
<span class="gd">-    ShiftEscape = &#39;s-escape&#39;</span>
<span class="gd">-    ControlAt = &#39;c-@&#39;</span>
<span class="gd">-    ControlA = &#39;c-a&#39;</span>
<span class="gd">-    ControlB = &#39;c-b&#39;</span>
<span class="gd">-    ControlC = &#39;c-c&#39;</span>
<span class="gd">-    ControlD = &#39;c-d&#39;</span>
<span class="gd">-    ControlE = &#39;c-e&#39;</span>
<span class="gd">-    ControlF = &#39;c-f&#39;</span>
<span class="gd">-    ControlG = &#39;c-g&#39;</span>
<span class="gd">-    ControlH = &#39;c-h&#39;</span>
<span class="gd">-    ControlI = &#39;c-i&#39;</span>
<span class="gd">-    ControlJ = &#39;c-j&#39;</span>
<span class="gd">-    ControlK = &#39;c-k&#39;</span>
<span class="gd">-    ControlL = &#39;c-l&#39;</span>
<span class="gd">-    ControlM = &#39;c-m&#39;</span>
<span class="gd">-    ControlN = &#39;c-n&#39;</span>
<span class="gd">-    ControlO = &#39;c-o&#39;</span>
<span class="gd">-    ControlP = &#39;c-p&#39;</span>
<span class="gd">-    ControlQ = &#39;c-q&#39;</span>
<span class="gd">-    ControlR = &#39;c-r&#39;</span>
<span class="gd">-    ControlS = &#39;c-s&#39;</span>
<span class="gd">-    ControlT = &#39;c-t&#39;</span>
<span class="gd">-    ControlU = &#39;c-u&#39;</span>
<span class="gd">-    ControlV = &#39;c-v&#39;</span>
<span class="gd">-    ControlW = &#39;c-w&#39;</span>
<span class="gd">-    ControlX = &#39;c-x&#39;</span>
<span class="gd">-    ControlY = &#39;c-y&#39;</span>
<span class="gd">-    ControlZ = &#39;c-z&#39;</span>
<span class="gd">-    Control1 = &#39;c-1&#39;</span>
<span class="gd">-    Control2 = &#39;c-2&#39;</span>
<span class="gd">-    Control3 = &#39;c-3&#39;</span>
<span class="gd">-    Control4 = &#39;c-4&#39;</span>
<span class="gd">-    Control5 = &#39;c-5&#39;</span>
<span class="gd">-    Control6 = &#39;c-6&#39;</span>
<span class="gd">-    Control7 = &#39;c-7&#39;</span>
<span class="gd">-    Control8 = &#39;c-8&#39;</span>
<span class="gd">-    Control9 = &#39;c-9&#39;</span>
<span class="gd">-    Control0 = &#39;c-0&#39;</span>
<span class="gd">-    ControlShift1 = &#39;c-s-1&#39;</span>
<span class="gd">-    ControlShift2 = &#39;c-s-2&#39;</span>
<span class="gd">-    ControlShift3 = &#39;c-s-3&#39;</span>
<span class="gd">-    ControlShift4 = &#39;c-s-4&#39;</span>
<span class="gd">-    ControlShift5 = &#39;c-s-5&#39;</span>
<span class="gd">-    ControlShift6 = &#39;c-s-6&#39;</span>
<span class="gd">-    ControlShift7 = &#39;c-s-7&#39;</span>
<span class="gd">-    ControlShift8 = &#39;c-s-8&#39;</span>
<span class="gd">-    ControlShift9 = &#39;c-s-9&#39;</span>
<span class="gd">-    ControlShift0 = &#39;c-s-0&#39;</span>
<span class="gd">-    ControlBackslash = &#39;c-\\&#39;</span>
<span class="gd">-    ControlSquareClose = &#39;c-]&#39;</span>
<span class="gd">-    ControlCircumflex = &#39;c-^&#39;</span>
<span class="gd">-    ControlUnderscore = &#39;c-_&#39;</span>
<span class="gd">-    Left = &#39;left&#39;</span>
<span class="gd">-    Right = &#39;right&#39;</span>
<span class="gd">-    Up = &#39;up&#39;</span>
<span class="gd">-    Down = &#39;down&#39;</span>
<span class="gd">-    Home = &#39;home&#39;</span>
<span class="gd">-    End = &#39;end&#39;</span>
<span class="gd">-    Insert = &#39;insert&#39;</span>
<span class="gd">-    Delete = &#39;delete&#39;</span>
<span class="gd">-    PageUp = &#39;pageup&#39;</span>
<span class="gd">-    PageDown = &#39;pagedown&#39;</span>
<span class="gd">-    ControlLeft = &#39;c-left&#39;</span>
<span class="gd">-    ControlRight = &#39;c-right&#39;</span>
<span class="gd">-    ControlUp = &#39;c-up&#39;</span>
<span class="gd">-    ControlDown = &#39;c-down&#39;</span>
<span class="gd">-    ControlHome = &#39;c-home&#39;</span>
<span class="gd">-    ControlEnd = &#39;c-end&#39;</span>
<span class="gd">-    ControlInsert = &#39;c-insert&#39;</span>
<span class="gd">-    ControlDelete = &#39;c-delete&#39;</span>
<span class="gd">-    ControlPageUp = &#39;c-pageup&#39;</span>
<span class="gd">-    ControlPageDown = &#39;c-pagedown&#39;</span>
<span class="gd">-    ShiftLeft = &#39;s-left&#39;</span>
<span class="gd">-    ShiftRight = &#39;s-right&#39;</span>
<span class="gd">-    ShiftUp = &#39;s-up&#39;</span>
<span class="gd">-    ShiftDown = &#39;s-down&#39;</span>
<span class="gd">-    ShiftHome = &#39;s-home&#39;</span>
<span class="gd">-    ShiftEnd = &#39;s-end&#39;</span>
<span class="gd">-    ShiftInsert = &#39;s-insert&#39;</span>
<span class="gd">-    ShiftDelete = &#39;s-delete&#39;</span>
<span class="gd">-    ShiftPageUp = &#39;s-pageup&#39;</span>
<span class="gd">-    ShiftPageDown = &#39;s-pagedown&#39;</span>
<span class="gd">-    ControlShiftLeft = &#39;c-s-left&#39;</span>
<span class="gd">-    ControlShiftRight = &#39;c-s-right&#39;</span>
<span class="gd">-    ControlShiftUp = &#39;c-s-up&#39;</span>
<span class="gd">-    ControlShiftDown = &#39;c-s-down&#39;</span>
<span class="gd">-    ControlShiftHome = &#39;c-s-home&#39;</span>
<span class="gd">-    ControlShiftEnd = &#39;c-s-end&#39;</span>
<span class="gd">-    ControlShiftInsert = &#39;c-s-insert&#39;</span>
<span class="gd">-    ControlShiftDelete = &#39;c-s-delete&#39;</span>
<span class="gd">-    ControlShiftPageUp = &#39;c-s-pageup&#39;</span>
<span class="gd">-    ControlShiftPageDown = &#39;c-s-pagedown&#39;</span>
<span class="gd">-    BackTab = &#39;s-tab&#39;</span>
<span class="gd">-    F1 = &#39;f1&#39;</span>
<span class="gd">-    F2 = &#39;f2&#39;</span>
<span class="gd">-    F3 = &#39;f3&#39;</span>
<span class="gd">-    F4 = &#39;f4&#39;</span>
<span class="gd">-    F5 = &#39;f5&#39;</span>
<span class="gd">-    F6 = &#39;f6&#39;</span>
<span class="gd">-    F7 = &#39;f7&#39;</span>
<span class="gd">-    F8 = &#39;f8&#39;</span>
<span class="gd">-    F9 = &#39;f9&#39;</span>
<span class="gd">-    F10 = &#39;f10&#39;</span>
<span class="gd">-    F11 = &#39;f11&#39;</span>
<span class="gd">-    F12 = &#39;f12&#39;</span>
<span class="gd">-    F13 = &#39;f13&#39;</span>
<span class="gd">-    F14 = &#39;f14&#39;</span>
<span class="gd">-    F15 = &#39;f15&#39;</span>
<span class="gd">-    F16 = &#39;f16&#39;</span>
<span class="gd">-    F17 = &#39;f17&#39;</span>
<span class="gd">-    F18 = &#39;f18&#39;</span>
<span class="gd">-    F19 = &#39;f19&#39;</span>
<span class="gd">-    F20 = &#39;f20&#39;</span>
<span class="gd">-    F21 = &#39;f21&#39;</span>
<span class="gd">-    F22 = &#39;f22&#39;</span>
<span class="gd">-    F23 = &#39;f23&#39;</span>
<span class="gd">-    F24 = &#39;f24&#39;</span>
<span class="gd">-    ControlF1 = &#39;c-f1&#39;</span>
<span class="gd">-    ControlF2 = &#39;c-f2&#39;</span>
<span class="gd">-    ControlF3 = &#39;c-f3&#39;</span>
<span class="gd">-    ControlF4 = &#39;c-f4&#39;</span>
<span class="gd">-    ControlF5 = &#39;c-f5&#39;</span>
<span class="gd">-    ControlF6 = &#39;c-f6&#39;</span>
<span class="gd">-    ControlF7 = &#39;c-f7&#39;</span>
<span class="gd">-    ControlF8 = &#39;c-f8&#39;</span>
<span class="gd">-    ControlF9 = &#39;c-f9&#39;</span>
<span class="gd">-    ControlF10 = &#39;c-f10&#39;</span>
<span class="gd">-    ControlF11 = &#39;c-f11&#39;</span>
<span class="gd">-    ControlF12 = &#39;c-f12&#39;</span>
<span class="gd">-    ControlF13 = &#39;c-f13&#39;</span>
<span class="gd">-    ControlF14 = &#39;c-f14&#39;</span>
<span class="gd">-    ControlF15 = &#39;c-f15&#39;</span>
<span class="gd">-    ControlF16 = &#39;c-f16&#39;</span>
<span class="gd">-    ControlF17 = &#39;c-f17&#39;</span>
<span class="gd">-    ControlF18 = &#39;c-f18&#39;</span>
<span class="gd">-    ControlF19 = &#39;c-f19&#39;</span>
<span class="gd">-    ControlF20 = &#39;c-f20&#39;</span>
<span class="gd">-    ControlF21 = &#39;c-f21&#39;</span>
<span class="gd">-    ControlF22 = &#39;c-f22&#39;</span>
<span class="gd">-    ControlF23 = &#39;c-f23&#39;</span>
<span class="gd">-    ControlF24 = &#39;c-f24&#39;</span>
<span class="gd">-    Any = &#39;&lt;any&gt;&#39;</span>
<span class="gd">-    ScrollUp = &#39;&lt;scroll-up&gt;&#39;</span>
<span class="gd">-    ScrollDown = &#39;&lt;scroll-down&gt;&#39;</span>
<span class="gd">-    CPRResponse = &#39;&lt;cursor-position-response&gt;&#39;</span>
<span class="gd">-    Vt100MouseEvent = &#39;&lt;vt100-mouse-event&gt;&#39;</span>
<span class="gd">-    WindowsMouseEvent = &#39;&lt;windows-mouse-event&gt;&#39;</span>
<span class="gd">-    BracketedPaste = &#39;&lt;bracketed-paste&gt;&#39;</span>
<span class="gd">-    SIGINT = &#39;&lt;sigint&gt;&#39;</span>
<span class="gd">-    Ignore = &#39;&lt;ignore&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    Escape = &quot;escape&quot;  # Also Control-[</span>
<span class="gi">+    ShiftEscape = &quot;s-escape&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ControlAt = &quot;c-@&quot;  # Also Control-Space.</span>
<span class="gi">+</span>
<span class="gi">+    ControlA = &quot;c-a&quot;</span>
<span class="gi">+    ControlB = &quot;c-b&quot;</span>
<span class="gi">+    ControlC = &quot;c-c&quot;</span>
<span class="gi">+    ControlD = &quot;c-d&quot;</span>
<span class="gi">+    ControlE = &quot;c-e&quot;</span>
<span class="gi">+    ControlF = &quot;c-f&quot;</span>
<span class="gi">+    ControlG = &quot;c-g&quot;</span>
<span class="gi">+    ControlH = &quot;c-h&quot;</span>
<span class="gi">+    ControlI = &quot;c-i&quot;  # Tab</span>
<span class="gi">+    ControlJ = &quot;c-j&quot;  # Newline</span>
<span class="gi">+    ControlK = &quot;c-k&quot;</span>
<span class="gi">+    ControlL = &quot;c-l&quot;</span>
<span class="gi">+    ControlM = &quot;c-m&quot;  # Carriage return</span>
<span class="gi">+    ControlN = &quot;c-n&quot;</span>
<span class="gi">+    ControlO = &quot;c-o&quot;</span>
<span class="gi">+    ControlP = &quot;c-p&quot;</span>
<span class="gi">+    ControlQ = &quot;c-q&quot;</span>
<span class="gi">+    ControlR = &quot;c-r&quot;</span>
<span class="gi">+    ControlS = &quot;c-s&quot;</span>
<span class="gi">+    ControlT = &quot;c-t&quot;</span>
<span class="gi">+    ControlU = &quot;c-u&quot;</span>
<span class="gi">+    ControlV = &quot;c-v&quot;</span>
<span class="gi">+    ControlW = &quot;c-w&quot;</span>
<span class="gi">+    ControlX = &quot;c-x&quot;</span>
<span class="gi">+    ControlY = &quot;c-y&quot;</span>
<span class="gi">+    ControlZ = &quot;c-z&quot;</span>
<span class="gi">+</span>
<span class="gi">+    Control1 = &quot;c-1&quot;</span>
<span class="gi">+    Control2 = &quot;c-2&quot;</span>
<span class="gi">+    Control3 = &quot;c-3&quot;</span>
<span class="gi">+    Control4 = &quot;c-4&quot;</span>
<span class="gi">+    Control5 = &quot;c-5&quot;</span>
<span class="gi">+    Control6 = &quot;c-6&quot;</span>
<span class="gi">+    Control7 = &quot;c-7&quot;</span>
<span class="gi">+    Control8 = &quot;c-8&quot;</span>
<span class="gi">+    Control9 = &quot;c-9&quot;</span>
<span class="gi">+    Control0 = &quot;c-0&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ControlShift1 = &quot;c-s-1&quot;</span>
<span class="gi">+    ControlShift2 = &quot;c-s-2&quot;</span>
<span class="gi">+    ControlShift3 = &quot;c-s-3&quot;</span>
<span class="gi">+    ControlShift4 = &quot;c-s-4&quot;</span>
<span class="gi">+    ControlShift5 = &quot;c-s-5&quot;</span>
<span class="gi">+    ControlShift6 = &quot;c-s-6&quot;</span>
<span class="gi">+    ControlShift7 = &quot;c-s-7&quot;</span>
<span class="gi">+    ControlShift8 = &quot;c-s-8&quot;</span>
<span class="gi">+    ControlShift9 = &quot;c-s-9&quot;</span>
<span class="gi">+    ControlShift0 = &quot;c-s-0&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ControlBackslash = &quot;c-\\&quot;</span>
<span class="gi">+    ControlSquareClose = &quot;c-]&quot;</span>
<span class="gi">+    ControlCircumflex = &quot;c-^&quot;</span>
<span class="gi">+    ControlUnderscore = &quot;c-_&quot;</span>
<span class="gi">+</span>
<span class="gi">+    Left = &quot;left&quot;</span>
<span class="gi">+    Right = &quot;right&quot;</span>
<span class="gi">+    Up = &quot;up&quot;</span>
<span class="gi">+    Down = &quot;down&quot;</span>
<span class="gi">+    Home = &quot;home&quot;</span>
<span class="gi">+    End = &quot;end&quot;</span>
<span class="gi">+    Insert = &quot;insert&quot;</span>
<span class="gi">+    Delete = &quot;delete&quot;</span>
<span class="gi">+    PageUp = &quot;pageup&quot;</span>
<span class="gi">+    PageDown = &quot;pagedown&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ControlLeft = &quot;c-left&quot;</span>
<span class="gi">+    ControlRight = &quot;c-right&quot;</span>
<span class="gi">+    ControlUp = &quot;c-up&quot;</span>
<span class="gi">+    ControlDown = &quot;c-down&quot;</span>
<span class="gi">+    ControlHome = &quot;c-home&quot;</span>
<span class="gi">+    ControlEnd = &quot;c-end&quot;</span>
<span class="gi">+    ControlInsert = &quot;c-insert&quot;</span>
<span class="gi">+    ControlDelete = &quot;c-delete&quot;</span>
<span class="gi">+    ControlPageUp = &quot;c-pageup&quot;</span>
<span class="gi">+    ControlPageDown = &quot;c-pagedown&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ShiftLeft = &quot;s-left&quot;</span>
<span class="gi">+    ShiftRight = &quot;s-right&quot;</span>
<span class="gi">+    ShiftUp = &quot;s-up&quot;</span>
<span class="gi">+    ShiftDown = &quot;s-down&quot;</span>
<span class="gi">+    ShiftHome = &quot;s-home&quot;</span>
<span class="gi">+    ShiftEnd = &quot;s-end&quot;</span>
<span class="gi">+    ShiftInsert = &quot;s-insert&quot;</span>
<span class="gi">+    ShiftDelete = &quot;s-delete&quot;</span>
<span class="gi">+    ShiftPageUp = &quot;s-pageup&quot;</span>
<span class="gi">+    ShiftPageDown = &quot;s-pagedown&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ControlShiftLeft = &quot;c-s-left&quot;</span>
<span class="gi">+    ControlShiftRight = &quot;c-s-right&quot;</span>
<span class="gi">+    ControlShiftUp = &quot;c-s-up&quot;</span>
<span class="gi">+    ControlShiftDown = &quot;c-s-down&quot;</span>
<span class="gi">+    ControlShiftHome = &quot;c-s-home&quot;</span>
<span class="gi">+    ControlShiftEnd = &quot;c-s-end&quot;</span>
<span class="gi">+    ControlShiftInsert = &quot;c-s-insert&quot;</span>
<span class="gi">+    ControlShiftDelete = &quot;c-s-delete&quot;</span>
<span class="gi">+    ControlShiftPageUp = &quot;c-s-pageup&quot;</span>
<span class="gi">+    ControlShiftPageDown = &quot;c-s-pagedown&quot;</span>
<span class="gi">+</span>
<span class="gi">+    BackTab = &quot;s-tab&quot;  # shift + tab</span>
<span class="gi">+</span>
<span class="gi">+    F1 = &quot;f1&quot;</span>
<span class="gi">+    F2 = &quot;f2&quot;</span>
<span class="gi">+    F3 = &quot;f3&quot;</span>
<span class="gi">+    F4 = &quot;f4&quot;</span>
<span class="gi">+    F5 = &quot;f5&quot;</span>
<span class="gi">+    F6 = &quot;f6&quot;</span>
<span class="gi">+    F7 = &quot;f7&quot;</span>
<span class="gi">+    F8 = &quot;f8&quot;</span>
<span class="gi">+    F9 = &quot;f9&quot;</span>
<span class="gi">+    F10 = &quot;f10&quot;</span>
<span class="gi">+    F11 = &quot;f11&quot;</span>
<span class="gi">+    F12 = &quot;f12&quot;</span>
<span class="gi">+    F13 = &quot;f13&quot;</span>
<span class="gi">+    F14 = &quot;f14&quot;</span>
<span class="gi">+    F15 = &quot;f15&quot;</span>
<span class="gi">+    F16 = &quot;f16&quot;</span>
<span class="gi">+    F17 = &quot;f17&quot;</span>
<span class="gi">+    F18 = &quot;f18&quot;</span>
<span class="gi">+    F19 = &quot;f19&quot;</span>
<span class="gi">+    F20 = &quot;f20&quot;</span>
<span class="gi">+    F21 = &quot;f21&quot;</span>
<span class="gi">+    F22 = &quot;f22&quot;</span>
<span class="gi">+    F23 = &quot;f23&quot;</span>
<span class="gi">+    F24 = &quot;f24&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ControlF1 = &quot;c-f1&quot;</span>
<span class="gi">+    ControlF2 = &quot;c-f2&quot;</span>
<span class="gi">+    ControlF3 = &quot;c-f3&quot;</span>
<span class="gi">+    ControlF4 = &quot;c-f4&quot;</span>
<span class="gi">+    ControlF5 = &quot;c-f5&quot;</span>
<span class="gi">+    ControlF6 = &quot;c-f6&quot;</span>
<span class="gi">+    ControlF7 = &quot;c-f7&quot;</span>
<span class="gi">+    ControlF8 = &quot;c-f8&quot;</span>
<span class="gi">+    ControlF9 = &quot;c-f9&quot;</span>
<span class="gi">+    ControlF10 = &quot;c-f10&quot;</span>
<span class="gi">+    ControlF11 = &quot;c-f11&quot;</span>
<span class="gi">+    ControlF12 = &quot;c-f12&quot;</span>
<span class="gi">+    ControlF13 = &quot;c-f13&quot;</span>
<span class="gi">+    ControlF14 = &quot;c-f14&quot;</span>
<span class="gi">+    ControlF15 = &quot;c-f15&quot;</span>
<span class="gi">+    ControlF16 = &quot;c-f16&quot;</span>
<span class="gi">+    ControlF17 = &quot;c-f17&quot;</span>
<span class="gi">+    ControlF18 = &quot;c-f18&quot;</span>
<span class="gi">+    ControlF19 = &quot;c-f19&quot;</span>
<span class="gi">+    ControlF20 = &quot;c-f20&quot;</span>
<span class="gi">+    ControlF21 = &quot;c-f21&quot;</span>
<span class="gi">+    ControlF22 = &quot;c-f22&quot;</span>
<span class="gi">+    ControlF23 = &quot;c-f23&quot;</span>
<span class="gi">+    ControlF24 = &quot;c-f24&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Matches any key.</span>
<span class="gi">+    Any = &quot;&lt;any&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Special.</span>
<span class="gi">+    ScrollUp = &quot;&lt;scroll-up&gt;&quot;</span>
<span class="gi">+    ScrollDown = &quot;&lt;scroll-down&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    CPRResponse = &quot;&lt;cursor-position-response&gt;&quot;</span>
<span class="gi">+    Vt100MouseEvent = &quot;&lt;vt100-mouse-event&gt;&quot;</span>
<span class="gi">+    WindowsMouseEvent = &quot;&lt;windows-mouse-event&gt;&quot;</span>
<span class="gi">+    BracketedPaste = &quot;&lt;bracketed-paste&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SIGINT = &quot;&lt;sigint&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # For internal use: key which is ignored.</span>
<span class="gi">+    # (The key binding for this key should not do anything.)</span>
<span class="gi">+    Ignore = &quot;&lt;ignore&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Some &#39;Key&#39; aliases (for backwards-compatibility).</span>
<span class="w"> </span>    ControlSpace = ControlAt
<span class="w"> </span>    Tab = ControlI
<span class="w"> </span>    Enter = ControlM
<span class="w"> </span>    Backspace = ControlH
<span class="gi">+</span>
<span class="gi">+    # ShiftControl was renamed to ControlShift in</span>
<span class="gi">+    # 888fcb6fa4efea0de8333177e1bbc792f3ff3c24 (20 Feb 2020).</span>
<span class="w"> </span>    ShiftControlLeft = ControlShiftLeft
<span class="w"> </span>    ShiftControlRight = ControlShiftRight
<span class="w"> </span>    ShiftControlHome = ControlShiftHome
<span class="gu">@@ -173,6 +206,17 @@ class Keys(str, Enum):</span>


<span class="w"> </span>ALL_KEYS: list[str] = [k.value for k in Keys]
<span class="gd">-KEY_ALIASES: dict[str, str] = {&#39;backspace&#39;: &#39;c-h&#39;, &#39;c-space&#39;: &#39;c-@&#39;,</span>
<span class="gd">-    &#39;enter&#39;: &#39;c-m&#39;, &#39;tab&#39;: &#39;c-i&#39;, &#39;s-c-left&#39;: &#39;c-s-left&#39;, &#39;s-c-right&#39;:</span>
<span class="gd">-    &#39;c-s-right&#39;, &#39;s-c-home&#39;: &#39;c-s-home&#39;, &#39;s-c-end&#39;: &#39;c-s-end&#39;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Aliases.</span>
<span class="gi">+KEY_ALIASES: dict[str, str] = {</span>
<span class="gi">+    &quot;backspace&quot;: &quot;c-h&quot;,</span>
<span class="gi">+    &quot;c-space&quot;: &quot;c-@&quot;,</span>
<span class="gi">+    &quot;enter&quot;: &quot;c-m&quot;,</span>
<span class="gi">+    &quot;tab&quot;: &quot;c-i&quot;,</span>
<span class="gi">+    # ShiftControl was renamed to ControlShift.</span>
<span class="gi">+    &quot;s-c-left&quot;: &quot;c-s-left&quot;,</span>
<span class="gi">+    &quot;s-c-right&quot;: &quot;c-s-right&quot;,</span>
<span class="gi">+    &quot;s-c-home&quot;: &quot;c-s-home&quot;,</span>
<span class="gi">+    &quot;s-c-end&quot;: &quot;c-s-end&quot;,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/containers.py b/src/prompt_toolkit/layout/containers.py</span>
<span class="gh">index 52be90da..100d4aae 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/containers.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/containers.py</span>
<span class="gu">@@ -3,33 +3,79 @@ Container for the layout.</span>
<span class="w"> </span>(Containers can contain other containers or user interface controls.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import TYPE_CHECKING, Callable, Sequence, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.cache import SimpleCache
<span class="w"> </span>from prompt_toolkit.data_structures import Point
<span class="gd">-from prompt_toolkit.filters import FilterOrBool, emacs_insert_mode, to_filter, vi_insert_mode</span>
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, to_formatted_text</span>
<span class="gd">-from prompt_toolkit.formatted_text.utils import fragment_list_to_text, fragment_list_width</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    FilterOrBool,</span>
<span class="gi">+    emacs_insert_mode,</span>
<span class="gi">+    to_filter,</span>
<span class="gi">+    vi_insert_mode,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text.utils import (</span>
<span class="gi">+    fragment_list_to_text,</span>
<span class="gi">+    fragment_list_width,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding import KeyBindingsBase
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent, MouseEventType
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth, take_using_weights, to_int, to_str
<span class="gd">-from .controls import DummyControl, FormattedTextControl, GetLinePrefixCallable, UIContent, UIControl</span>
<span class="gd">-from .dimension import AnyDimension, Dimension, max_layout_dimensions, sum_layout_dimensions, to_dimension</span>
<span class="gi">+</span>
<span class="gi">+from .controls import (</span>
<span class="gi">+    DummyControl,</span>
<span class="gi">+    FormattedTextControl,</span>
<span class="gi">+    GetLinePrefixCallable,</span>
<span class="gi">+    UIContent,</span>
<span class="gi">+    UIControl,</span>
<span class="gi">+)</span>
<span class="gi">+from .dimension import (</span>
<span class="gi">+    AnyDimension,</span>
<span class="gi">+    Dimension,</span>
<span class="gi">+    max_layout_dimensions,</span>
<span class="gi">+    sum_layout_dimensions,</span>
<span class="gi">+    to_dimension,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .margins import Margin
<span class="w"> </span>from .mouse_handlers import MouseHandlers
<span class="w"> </span>from .screen import _CHAR_CACHE, Screen, WritePosition
<span class="w"> </span>from .utils import explode_text_fragments
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Protocol, TypeGuard
<span class="gi">+</span>
<span class="w"> </span>    from prompt_toolkit.key_binding.key_bindings import NotImplementedOrNone
<span class="gd">-__all__ = [&#39;AnyContainer&#39;, &#39;Container&#39;, &#39;HorizontalAlign&#39;, &#39;VerticalAlign&#39;,</span>
<span class="gd">-    &#39;HSplit&#39;, &#39;VSplit&#39;, &#39;FloatContainer&#39;, &#39;Float&#39;, &#39;WindowAlign&#39;, &#39;Window&#39;,</span>
<span class="gd">-    &#39;WindowRenderInfo&#39;, &#39;ConditionalContainer&#39;, &#39;ScrollOffsets&#39;,</span>
<span class="gd">-    &#39;ColorColumn&#39;, &#39;to_container&#39;, &#39;to_window&#39;, &#39;is_container&#39;,</span>
<span class="gd">-    &#39;DynamicContainer&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;AnyContainer&quot;,</span>
<span class="gi">+    &quot;Container&quot;,</span>
<span class="gi">+    &quot;HorizontalAlign&quot;,</span>
<span class="gi">+    &quot;VerticalAlign&quot;,</span>
<span class="gi">+    &quot;HSplit&quot;,</span>
<span class="gi">+    &quot;VSplit&quot;,</span>
<span class="gi">+    &quot;FloatContainer&quot;,</span>
<span class="gi">+    &quot;Float&quot;,</span>
<span class="gi">+    &quot;WindowAlign&quot;,</span>
<span class="gi">+    &quot;Window&quot;,</span>
<span class="gi">+    &quot;WindowRenderInfo&quot;,</span>
<span class="gi">+    &quot;ConditionalContainer&quot;,</span>
<span class="gi">+    &quot;ScrollOffsets&quot;,</span>
<span class="gi">+    &quot;ColorColumn&quot;,</span>
<span class="gi">+    &quot;to_container&quot;,</span>
<span class="gi">+    &quot;to_window&quot;,</span>
<span class="gi">+    &quot;is_container&quot;,</span>
<span class="gi">+    &quot;DynamicContainer&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Container(metaclass=ABCMeta):
<span class="gu">@@ -38,34 +84,36 @@ class Container(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reset the state of this container and all the children.
<span class="w"> </span>        (E.g. reset scroll offsets, etc...)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def preferred_width(self, max_available_width: int) -&gt;Dimension:</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a :class:`~prompt_toolkit.layout.Dimension` that represents the
<span class="w"> </span>        desired width for this container.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def preferred_height(self, width: int, max_available_height: int</span>
<span class="gd">-        ) -&gt;Dimension:</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a :class:`~prompt_toolkit.layout.Dimension` that represents the
<span class="w"> </span>        desired height for this container.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,</span>
<span class="gd">-        write_position: WritePosition, parent_style: str, erase_bg: bool,</span>
<span class="gd">-        z_index: (int | None)) -&gt;None:</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write the actual content to the screen.

<span class="gu">@@ -77,63 +125,67 @@ class Container(metaclass=ABCMeta):</span>
<span class="w"> </span>            style down to the windows that they contain.
<span class="w"> </span>        :param z_index: Used for propagating z_index from parent to child.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def is_modal(self) -&gt;bool:</span>
<span class="gi">+    def is_modal(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When this container is modal, key bindings from parent containers are
<span class="w"> </span>        not taken into account if a user control in this container is focused.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="gd">-    def get_key_bindings(self) -&gt;(KeyBindingsBase | None):</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a :class:`.KeyBindings` object. These bindings become active when any
<span class="w"> </span>        user control in this container has the focus, except if any containers
<span class="w"> </span>        between this container and the focused user control is modal.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_children(self) -&gt;list[Container]:</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the list of child :class:`.Container` objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>


<span class="w"> </span>if TYPE_CHECKING:

<span class="gd">-</span>
<span class="w"> </span>    class MagicContainer(Protocol):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Any object that implements ``__pt_container__`` represents a container.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def __pt_container__(self) -&gt;AnyContainer:</span>
<span class="gi">+        def __pt_container__(self) -&gt; AnyContainer:</span>
<span class="w"> </span>            ...
<span class="gd">-AnyContainer = Union[Container, &#39;MagicContainer&#39;]</span>


<span class="gd">-def _window_too_small() -&gt;Window:</span>
<span class="gd">-    &quot;&quot;&quot;Create a `Window` that displays the &#39;Window too small&#39; text.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+AnyContainer = Union[Container, &quot;MagicContainer&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _window_too_small() -&gt; Window:</span>
<span class="gi">+    &quot;Create a `Window` that displays the &#39;Window too small&#39; text.&quot;</span>
<span class="gi">+    return Window(</span>
<span class="gi">+        FormattedTextControl(text=[(&quot;class:window-too-small&quot;, &quot; Window too small... &quot;)])</span>
<span class="gi">+    )</span>


<span class="w"> </span>class VerticalAlign(Enum):
<span class="gd">-    &quot;&quot;&quot;Alignment for `HSplit`.&quot;&quot;&quot;</span>
<span class="gd">-    TOP = &#39;TOP&#39;</span>
<span class="gd">-    CENTER = &#39;CENTER&#39;</span>
<span class="gd">-    BOTTOM = &#39;BOTTOM&#39;</span>
<span class="gd">-    JUSTIFY = &#39;JUSTIFY&#39;</span>
<span class="gi">+    &quot;Alignment for `HSplit`.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    TOP = &quot;TOP&quot;</span>
<span class="gi">+    CENTER = &quot;CENTER&quot;</span>
<span class="gi">+    BOTTOM = &quot;BOTTOM&quot;</span>
<span class="gi">+    JUSTIFY = &quot;JUSTIFY&quot;</span>


<span class="w"> </span>class HorizontalAlign(Enum):
<span class="gd">-    &quot;&quot;&quot;Alignment for `VSplit`.&quot;&quot;&quot;</span>
<span class="gd">-    LEFT = &#39;LEFT&#39;</span>
<span class="gd">-    CENTER = &#39;CENTER&#39;</span>
<span class="gd">-    RIGHT = &#39;RIGHT&#39;</span>
<span class="gd">-    JUSTIFY = &#39;JUSTIFY&#39;</span>
<span class="gi">+    &quot;Alignment for `VSplit`.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    LEFT = &quot;LEFT&quot;</span>
<span class="gi">+    CENTER = &quot;CENTER&quot;</span>
<span class="gi">+    RIGHT = &quot;RIGHT&quot;</span>
<span class="gi">+    JUSTIFY = &quot;JUSTIFY&quot;</span>


<span class="w"> </span>class _Split(Container):
<span class="gu">@@ -141,24 +193,43 @@ class _Split(Container):</span>
<span class="w"> </span>    The common parts of `VSplit` and `HSplit`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, children: Sequence[AnyContainer], window_too_small:</span>
<span class="gd">-        (Container | None)=None, padding: AnyDimension=Dimension.exact(0),</span>
<span class="gd">-        padding_char: (str | None)=None, padding_style: str=&#39;&#39;, width:</span>
<span class="gd">-        AnyDimension=None, height: AnyDimension=None, z_index: (int | None)</span>
<span class="gd">-        =None, modal: bool=False, key_bindings: (KeyBindingsBase | None)=</span>
<span class="gd">-        None, style: (str | Callable[[], str])=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        children: Sequence[AnyContainer],</span>
<span class="gi">+        window_too_small: Container | None = None,</span>
<span class="gi">+        padding: AnyDimension = Dimension.exact(0),</span>
<span class="gi">+        padding_char: str | None = None,</span>
<span class="gi">+        padding_style: str = &quot;&quot;,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        z_index: int | None = None,</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        style: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.children = [to_container(c) for c in children]
<span class="w"> </span>        self.window_too_small = window_too_small or _window_too_small()
<span class="w"> </span>        self.padding = padding
<span class="w"> </span>        self.padding_char = padding_char
<span class="w"> </span>        self.padding_style = padding_style
<span class="gi">+</span>
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.height = height
<span class="w"> </span>        self.z_index = z_index
<span class="gi">+</span>
<span class="w"> </span>        self.modal = modal
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self.style = style

<span class="gi">+    def is_modal(self) -&gt; bool:</span>
<span class="gi">+        return self.modal</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="gi">+        return self.key_bindings</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="gi">+        return self.children</span>
<span class="gi">+</span>

<span class="w"> </span>class HSplit(_Split):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -194,48 +265,208 @@ class HSplit(_Split):</span>
<span class="w"> </span>    :param padding_style: Style to applied to the padding.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, children: Sequence[AnyContainer], window_too_small:</span>
<span class="gd">-        (Container | None)=None, align: VerticalAlign=VerticalAlign.JUSTIFY,</span>
<span class="gd">-        padding: AnyDimension=0, padding_char: (str | None)=None,</span>
<span class="gd">-        padding_style: str=&#39;&#39;, width: AnyDimension=None, height:</span>
<span class="gd">-        AnyDimension=None, z_index: (int | None)=None, modal: bool=False,</span>
<span class="gd">-        key_bindings: (KeyBindingsBase | None)=None, style: (str | Callable</span>
<span class="gd">-        [[], str])=&#39;&#39;) -&gt;None:</span>
<span class="gd">-        super().__init__(children=children, window_too_small=</span>
<span class="gd">-            window_too_small, padding=padding, padding_char=padding_char,</span>
<span class="gd">-            padding_style=padding_style, width=width, height=height,</span>
<span class="gd">-            z_index=z_index, modal=modal, key_bindings=key_bindings, style=</span>
<span class="gd">-            style)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        children: Sequence[AnyContainer],</span>
<span class="gi">+        window_too_small: Container | None = None,</span>
<span class="gi">+        align: VerticalAlign = VerticalAlign.JUSTIFY,</span>
<span class="gi">+        padding: AnyDimension = 0,</span>
<span class="gi">+        padding_char: str | None = None,</span>
<span class="gi">+        padding_style: str = &quot;&quot;,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        z_index: int | None = None,</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        style: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            children=children,</span>
<span class="gi">+            window_too_small=window_too_small,</span>
<span class="gi">+            padding=padding,</span>
<span class="gi">+            padding_char=padding_char,</span>
<span class="gi">+            padding_style=padding_style,</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            height=height,</span>
<span class="gi">+            z_index=z_index,</span>
<span class="gi">+            modal=modal,</span>
<span class="gi">+            key_bindings=key_bindings,</span>
<span class="gi">+            style=style,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.align = align
<span class="gd">-        self._children_cache: SimpleCache[tuple[Container, ...], list[</span>
<span class="gd">-            Container]] = SimpleCache(maxsize=1)</span>
<span class="gd">-        self._remaining_space_window = Window()</span>
<span class="gi">+</span>
<span class="gi">+        self._children_cache: SimpleCache[</span>
<span class="gi">+            tuple[Container, ...], list[Container]</span>
<span class="gi">+        ] = SimpleCache(maxsize=1)</span>
<span class="gi">+        self._remaining_space_window = Window()  # Dummy window.</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="gi">+        if self.width is not None:</span>
<span class="gi">+            return to_dimension(self.width)</span>
<span class="gi">+</span>
<span class="gi">+        if self.children:</span>
<span class="gi">+            dimensions = [c.preferred_width(max_available_width) for c in self.children]</span>
<span class="gi">+            return max_layout_dimensions(dimensions)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Dimension()</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="gi">+        if self.height is not None:</span>
<span class="gi">+            return to_dimension(self.height)</span>
<span class="gi">+</span>
<span class="gi">+        dimensions = [</span>
<span class="gi">+            c.preferred_height(width, max_available_height) for c in self._all_children</span>
<span class="gi">+        ]</span>
<span class="gi">+        return sum_layout_dimensions(dimensions)</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        for c in self.children:</span>
<span class="gi">+            c.reset()</span>

<span class="w"> </span>    @property
<span class="gd">-    def _all_children(self) -&gt;list[Container]:</span>
<span class="gi">+    def _all_children(self) -&gt; list[Container]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        List of child objects, including padding.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,</span>
<span class="gd">-        write_position: WritePosition, parent_style: str, erase_bg: bool,</span>
<span class="gd">-        z_index: (int | None)) -&gt;None:</span>
<span class="gi">+        def get() -&gt; list[Container]:</span>
<span class="gi">+            result: list[Container] = []</span>
<span class="gi">+</span>
<span class="gi">+            # Padding Top.</span>
<span class="gi">+            if self.align in (VerticalAlign.CENTER, VerticalAlign.BOTTOM):</span>
<span class="gi">+                result.append(Window(width=Dimension(preferred=0)))</span>
<span class="gi">+</span>
<span class="gi">+            # The children with padding.</span>
<span class="gi">+            for child in self.children:</span>
<span class="gi">+                result.append(child)</span>
<span class="gi">+                result.append(</span>
<span class="gi">+                    Window(</span>
<span class="gi">+                        height=self.padding,</span>
<span class="gi">+                        char=self.padding_char,</span>
<span class="gi">+                        style=self.padding_style,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            if result:</span>
<span class="gi">+                result.pop()</span>
<span class="gi">+</span>
<span class="gi">+            # Padding right.</span>
<span class="gi">+            if self.align in (VerticalAlign.CENTER, VerticalAlign.TOP):</span>
<span class="gi">+                result.append(Window(width=Dimension(preferred=0)))</span>
<span class="gi">+</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return self._children_cache.get(tuple(self.children), get)</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Render the prompt to a `Screen` instance.

<span class="w"> </span>        :param screen: The :class:`~prompt_toolkit.layout.screen.Screen` class
<span class="w"> </span>            to which the output has to be written.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _divide_heights(self, write_position: WritePosition) -&gt;(list[int] |</span>
<span class="gd">-        None):</span>
<span class="gi">+        sizes = self._divide_heights(write_position)</span>
<span class="gi">+        style = parent_style + &quot; &quot; + to_str(self.style)</span>
<span class="gi">+        z_index = z_index if self.z_index is None else self.z_index</span>
<span class="gi">+</span>
<span class="gi">+        if sizes is None:</span>
<span class="gi">+            self.window_too_small.write_to_screen(</span>
<span class="gi">+                screen, mouse_handlers, write_position, style, erase_bg, z_index</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            #</span>
<span class="gi">+            ypos = write_position.ypos</span>
<span class="gi">+            xpos = write_position.xpos</span>
<span class="gi">+            width = write_position.width</span>
<span class="gi">+</span>
<span class="gi">+            # Draw child panes.</span>
<span class="gi">+            for s, c in zip(sizes, self._all_children):</span>
<span class="gi">+                c.write_to_screen(</span>
<span class="gi">+                    screen,</span>
<span class="gi">+                    mouse_handlers,</span>
<span class="gi">+                    WritePosition(xpos, ypos, width, s),</span>
<span class="gi">+                    style,</span>
<span class="gi">+                    erase_bg,</span>
<span class="gi">+                    z_index,</span>
<span class="gi">+                )</span>
<span class="gi">+                ypos += s</span>
<span class="gi">+</span>
<span class="gi">+            # Fill in the remaining space. This happens when a child control</span>
<span class="gi">+            # refuses to take more space and we don&#39;t have any padding. Adding a</span>
<span class="gi">+            # dummy child control for this (in `self._all_children`) is not</span>
<span class="gi">+            # desired, because in some situations, it would take more space, even</span>
<span class="gi">+            # when it&#39;s not required. This is required to apply the styling.</span>
<span class="gi">+            remaining_height = write_position.ypos + write_position.height - ypos</span>
<span class="gi">+            if remaining_height &gt; 0:</span>
<span class="gi">+                self._remaining_space_window.write_to_screen(</span>
<span class="gi">+                    screen,</span>
<span class="gi">+                    mouse_handlers,</span>
<span class="gi">+                    WritePosition(xpos, ypos, width, remaining_height),</span>
<span class="gi">+                    style,</span>
<span class="gi">+                    erase_bg,</span>
<span class="gi">+                    z_index,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _divide_heights(self, write_position: WritePosition) -&gt; list[int] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the heights for all rows.
<span class="w"> </span>        Or None when there is not enough space.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.children:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        width = write_position.width</span>
<span class="gi">+        height = write_position.height</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate heights.</span>
<span class="gi">+        dimensions = [c.preferred_height(width, height) for c in self._all_children]</span>
<span class="gi">+</span>
<span class="gi">+        # Sum dimensions</span>
<span class="gi">+        sum_dimensions = sum_layout_dimensions(dimensions)</span>
<span class="gi">+</span>
<span class="gi">+        # If there is not enough space for both.</span>
<span class="gi">+        # Don&#39;t do anything.</span>
<span class="gi">+        if sum_dimensions.min &gt; height:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # Find optimal sizes. (Start with minimal size, increase until we cover</span>
<span class="gi">+        # the whole height.)</span>
<span class="gi">+        sizes = [d.min for d in dimensions]</span>
<span class="gi">+</span>
<span class="gi">+        child_generator = take_using_weights(</span>
<span class="gi">+            items=list(range(len(dimensions))), weights=[d.weight for d in dimensions]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        i = next(child_generator)</span>
<span class="gi">+</span>
<span class="gi">+        # Increase until we meet at least the &#39;preferred&#39; size.</span>
<span class="gi">+        preferred_stop = min(height, sum_dimensions.preferred)</span>
<span class="gi">+        preferred_dimensions = [d.preferred for d in dimensions]</span>
<span class="gi">+</span>
<span class="gi">+        while sum(sizes) &lt; preferred_stop:</span>
<span class="gi">+            if sizes[i] &lt; preferred_dimensions[i]:</span>
<span class="gi">+                sizes[i] += 1</span>
<span class="gi">+            i = next(child_generator)</span>
<span class="gi">+</span>
<span class="gi">+        # Increase until we use all the available space. (or until &quot;max&quot;)</span>
<span class="gi">+        if not get_app().is_done:</span>
<span class="gi">+            max_stop = min(height, sum_dimensions.max)</span>
<span class="gi">+            max_dimensions = [d.max for d in dimensions]</span>
<span class="gi">+</span>
<span class="gi">+            while sum(sizes) &lt; max_stop:</span>
<span class="gi">+                if sizes[i] &lt; max_dimensions[i]:</span>
<span class="gi">+                    sizes[i] += 1</span>
<span class="gi">+                i = next(child_generator)</span>
<span class="gi">+</span>
<span class="gi">+        return sizes</span>


<span class="w"> </span>class VSplit(_Split):
<span class="gu">@@ -271,47 +502,234 @@ class VSplit(_Split):</span>
<span class="w"> </span>    :param padding_style: Style to applied to the padding.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, children: Sequence[AnyContainer], window_too_small:</span>
<span class="gd">-        (Container | None)=None, align: HorizontalAlign=HorizontalAlign.</span>
<span class="gd">-        JUSTIFY, padding: AnyDimension=0, padding_char: (str | None)=None,</span>
<span class="gd">-        padding_style: str=&#39;&#39;, width: AnyDimension=None, height:</span>
<span class="gd">-        AnyDimension=None, z_index: (int | None)=None, modal: bool=False,</span>
<span class="gd">-        key_bindings: (KeyBindingsBase | None)=None, style: (str | Callable</span>
<span class="gd">-        [[], str])=&#39;&#39;) -&gt;None:</span>
<span class="gd">-        super().__init__(children=children, window_too_small=</span>
<span class="gd">-            window_too_small, padding=padding, padding_char=padding_char,</span>
<span class="gd">-            padding_style=padding_style, width=width, height=height,</span>
<span class="gd">-            z_index=z_index, modal=modal, key_bindings=key_bindings, style=</span>
<span class="gd">-            style)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        children: Sequence[AnyContainer],</span>
<span class="gi">+        window_too_small: Container | None = None,</span>
<span class="gi">+        align: HorizontalAlign = HorizontalAlign.JUSTIFY,</span>
<span class="gi">+        padding: AnyDimension = 0,</span>
<span class="gi">+        padding_char: str | None = None,</span>
<span class="gi">+        padding_style: str = &quot;&quot;,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        z_index: int | None = None,</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        style: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            children=children,</span>
<span class="gi">+            window_too_small=window_too_small,</span>
<span class="gi">+            padding=padding,</span>
<span class="gi">+            padding_char=padding_char,</span>
<span class="gi">+            padding_style=padding_style,</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            height=height,</span>
<span class="gi">+            z_index=z_index,</span>
<span class="gi">+            modal=modal,</span>
<span class="gi">+            key_bindings=key_bindings,</span>
<span class="gi">+            style=style,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.align = align
<span class="gd">-        self._children_cache: SimpleCache[tuple[Container, ...], list[</span>
<span class="gd">-            Container]] = SimpleCache(maxsize=1)</span>
<span class="gd">-        self._remaining_space_window = Window()</span>
<span class="gi">+</span>
<span class="gi">+        self._children_cache: SimpleCache[</span>
<span class="gi">+            tuple[Container, ...], list[Container]</span>
<span class="gi">+        ] = SimpleCache(maxsize=1)</span>
<span class="gi">+        self._remaining_space_window = Window()  # Dummy window.</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="gi">+        if self.width is not None:</span>
<span class="gi">+            return to_dimension(self.width)</span>
<span class="gi">+</span>
<span class="gi">+        dimensions = [</span>
<span class="gi">+            c.preferred_width(max_available_width) for c in self._all_children</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        return sum_layout_dimensions(dimensions)</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="gi">+        if self.height is not None:</span>
<span class="gi">+            return to_dimension(self.height)</span>
<span class="gi">+</span>
<span class="gi">+        # At the point where we want to calculate the heights, the widths have</span>
<span class="gi">+        # already been decided. So we can trust `width` to be the actual</span>
<span class="gi">+        # `width` that&#39;s going to be used for the rendering. So,</span>
<span class="gi">+        # `divide_widths` is supposed to use all of the available width.</span>
<span class="gi">+        # Using only the `preferred` width caused a bug where the reported</span>
<span class="gi">+        # height was more than required. (we had a `BufferControl` which did</span>
<span class="gi">+        # wrap lines because of the smaller width returned by `_divide_widths`.</span>
<span class="gi">+</span>
<span class="gi">+        sizes = self._divide_widths(width)</span>
<span class="gi">+        children = self._all_children</span>
<span class="gi">+</span>
<span class="gi">+        if sizes is None:</span>
<span class="gi">+            return Dimension()</span>
<span class="gi">+        else:</span>
<span class="gi">+            dimensions = [</span>
<span class="gi">+                c.preferred_height(s, max_available_height)</span>
<span class="gi">+                for s, c in zip(sizes, children)</span>
<span class="gi">+            ]</span>
<span class="gi">+            return max_layout_dimensions(dimensions)</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        for c in self.children:</span>
<span class="gi">+            c.reset()</span>

<span class="w"> </span>    @property
<span class="gd">-    def _all_children(self) -&gt;list[Container]:</span>
<span class="gi">+    def _all_children(self) -&gt; list[Container]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        List of child objects, including padding.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _divide_widths(self, width: int) -&gt;(list[int] | None):</span>
<span class="gi">+        def get() -&gt; list[Container]:</span>
<span class="gi">+            result: list[Container] = []</span>
<span class="gi">+</span>
<span class="gi">+            # Padding left.</span>
<span class="gi">+            if self.align in (HorizontalAlign.CENTER, HorizontalAlign.RIGHT):</span>
<span class="gi">+                result.append(Window(width=Dimension(preferred=0)))</span>
<span class="gi">+</span>
<span class="gi">+            # The children with padding.</span>
<span class="gi">+            for child in self.children:</span>
<span class="gi">+                result.append(child)</span>
<span class="gi">+                result.append(</span>
<span class="gi">+                    Window(</span>
<span class="gi">+                        width=self.padding,</span>
<span class="gi">+                        char=self.padding_char,</span>
<span class="gi">+                        style=self.padding_style,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            if result:</span>
<span class="gi">+                result.pop()</span>
<span class="gi">+</span>
<span class="gi">+            # Padding right.</span>
<span class="gi">+            if self.align in (HorizontalAlign.CENTER, HorizontalAlign.LEFT):</span>
<span class="gi">+                result.append(Window(width=Dimension(preferred=0)))</span>
<span class="gi">+</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return self._children_cache.get(tuple(self.children), get)</span>
<span class="gi">+</span>
<span class="gi">+    def _divide_widths(self, width: int) -&gt; list[int] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the widths for all columns.
<span class="w"> </span>        Or None when there is not enough space.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        children = self._all_children</span>
<span class="gi">+</span>
<span class="gi">+        if not children:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate widths.</span>
<span class="gi">+        dimensions = [c.preferred_width(width) for c in children]</span>
<span class="gi">+        preferred_dimensions = [d.preferred for d in dimensions]</span>
<span class="gi">+</span>
<span class="gi">+        # Sum dimensions</span>
<span class="gi">+        sum_dimensions = sum_layout_dimensions(dimensions)</span>
<span class="gi">+</span>
<span class="gi">+        # If there is not enough space for both.</span>
<span class="gi">+        # Don&#39;t do anything.</span>
<span class="gi">+        if sum_dimensions.min &gt; width:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # Find optimal sizes. (Start with minimal size, increase until we cover</span>
<span class="gi">+        # the whole width.)</span>
<span class="gi">+        sizes = [d.min for d in dimensions]</span>
<span class="gi">+</span>
<span class="gi">+        child_generator = take_using_weights(</span>
<span class="gi">+            items=list(range(len(dimensions))), weights=[d.weight for d in dimensions]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        i = next(child_generator)</span>
<span class="gi">+</span>
<span class="gi">+        # Increase until we meet at least the &#39;preferred&#39; size.</span>
<span class="gi">+        preferred_stop = min(width, sum_dimensions.preferred)</span>
<span class="gi">+</span>
<span class="gi">+        while sum(sizes) &lt; preferred_stop:</span>
<span class="gi">+            if sizes[i] &lt; preferred_dimensions[i]:</span>
<span class="gi">+                sizes[i] += 1</span>
<span class="gi">+            i = next(child_generator)</span>
<span class="gi">+</span>
<span class="gi">+        # Increase until we use all the available space.</span>
<span class="gi">+        max_dimensions = [d.max for d in dimensions]</span>
<span class="gi">+        max_stop = min(width, sum_dimensions.max)</span>
<span class="gi">+</span>
<span class="gi">+        while sum(sizes) &lt; max_stop:</span>
<span class="gi">+            if sizes[i] &lt; max_dimensions[i]:</span>
<span class="gi">+                sizes[i] += 1</span>
<span class="gi">+            i = next(child_generator)</span>

<span class="gd">-    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,</span>
<span class="gd">-        write_position: WritePosition, parent_style: str, erase_bg: bool,</span>
<span class="gd">-        z_index: (int | None)) -&gt;None:</span>
<span class="gi">+        return sizes</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Render the prompt to a `Screen` instance.

<span class="w"> </span>        :param screen: The :class:`~prompt_toolkit.layout.screen.Screen` class
<span class="w"> </span>            to which the output has to be written.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.children:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        children = self._all_children</span>
<span class="gi">+        sizes = self._divide_widths(write_position.width)</span>
<span class="gi">+        style = parent_style + &quot; &quot; + to_str(self.style)</span>
<span class="gi">+        z_index = z_index if self.z_index is None else self.z_index</span>
<span class="gi">+</span>
<span class="gi">+        # If there is not enough space.</span>
<span class="gi">+        if sizes is None:</span>
<span class="gi">+            self.window_too_small.write_to_screen(</span>
<span class="gi">+                screen, mouse_handlers, write_position, style, erase_bg, z_index</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate heights, take the largest possible, but not larger than</span>
<span class="gi">+        # write_position.height.</span>
<span class="gi">+        heights = [</span>
<span class="gi">+            child.preferred_height(width, write_position.height).preferred</span>
<span class="gi">+            for width, child in zip(sizes, children)</span>
<span class="gi">+        ]</span>
<span class="gi">+        height = max(write_position.height, min(write_position.height, max(heights)))</span>
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        xpos = write_position.xpos</span>
<span class="gi">+</span>
<span class="gi">+        # Draw all child panes.</span>
<span class="gi">+        for s, c in zip(sizes, children):</span>
<span class="gi">+            c.write_to_screen(</span>
<span class="gi">+                screen,</span>
<span class="gi">+                mouse_handlers,</span>
<span class="gi">+                WritePosition(xpos, ypos, s, height),</span>
<span class="gi">+                style,</span>
<span class="gi">+                erase_bg,</span>
<span class="gi">+                z_index,</span>
<span class="gi">+            )</span>
<span class="gi">+            xpos += s</span>
<span class="gi">+</span>
<span class="gi">+        # Fill in the remaining space. This happens when a child control</span>
<span class="gi">+        # refuses to take more space and we don&#39;t have any padding. Adding a</span>
<span class="gi">+        # dummy child control for this (in `self._all_children`) is not</span>
<span class="gi">+        # desired, because in some situations, it would take more space, even</span>
<span class="gi">+        # when it&#39;s not required. This is required to apply the styling.</span>
<span class="gi">+        remaining_width = write_position.xpos + write_position.width - xpos</span>
<span class="gi">+        if remaining_width &gt; 0:</span>
<span class="gi">+            self._remaining_space_window.write_to_screen(</span>
<span class="gi">+                screen,</span>
<span class="gi">+                mouse_handlers,</span>
<span class="gi">+                WritePosition(xpos, ypos, remaining_width, height),</span>
<span class="gi">+                style,</span>
<span class="gi">+                erase_bg,</span>
<span class="gi">+                z_index,</span>
<span class="gi">+            )</span>


<span class="w"> </span>class FloatContainer(Container):
<span class="gu">@@ -333,38 +751,269 @@ class FloatContainer(Container):</span>
<span class="w"> </span>        This is the z_index for the whole `Float` container as a whole.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, content: AnyContainer, floats: list[Float], modal:</span>
<span class="gd">-        bool=False, key_bindings: (KeyBindingsBase | None)=None, style: (</span>
<span class="gd">-        str | Callable[[], str])=&#39;&#39;, z_index: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        content: AnyContainer,</span>
<span class="gi">+        floats: list[Float],</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        style: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+        z_index: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.content = to_container(content)
<span class="w"> </span>        self.floats = floats
<span class="gi">+</span>
<span class="w"> </span>        self.modal = modal
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.z_index = z_index

<span class="gd">-    def preferred_height(self, width: int, max_available_height: int</span>
<span class="gd">-        ) -&gt;Dimension:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.content.reset()</span>
<span class="gi">+</span>
<span class="gi">+        for f in self.floats:</span>
<span class="gi">+            f.content.reset()</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="gi">+        return self.content.preferred_width(max_available_width)</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the preferred height of the float container.
<span class="w"> </span>        (We don&#39;t care about the height of the floats, they should always fit
<span class="w"> </span>        into the dimensions provided by the container.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _draw_float(self, fl: Float, screen: Screen, mouse_handlers:</span>
<span class="gd">-        MouseHandlers, write_position: WritePosition, style: str, erase_bg:</span>
<span class="gd">-        bool, z_index: (int | None)) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Draw a single Float.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _area_is_empty(self, screen: Screen, write_position: WritePosition</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+        return self.content.preferred_height(width, max_available_height)</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        style = parent_style + &quot; &quot; + to_str(self.style)</span>
<span class="gi">+        z_index = z_index if self.z_index is None else self.z_index</span>
<span class="gi">+</span>
<span class="gi">+        self.content.write_to_screen(</span>
<span class="gi">+            screen, mouse_handlers, write_position, style, erase_bg, z_index</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for number, fl in enumerate(self.floats):</span>
<span class="gi">+            # z_index of a Float is computed by summing the z_index of the</span>
<span class="gi">+            # container and the `Float`.</span>
<span class="gi">+            new_z_index = (z_index or 0) + fl.z_index</span>
<span class="gi">+            style = parent_style + &quot; &quot; + to_str(self.style)</span>
<span class="gi">+</span>
<span class="gi">+            # If the float that we have here, is positioned relative to the</span>
<span class="gi">+            # cursor position, but the Window that specifies the cursor</span>
<span class="gi">+            # position is not drawn yet, because it&#39;s a Float itself, we have</span>
<span class="gi">+            # to postpone this calculation. (This is a work-around, but good</span>
<span class="gi">+            # enough for now.)</span>
<span class="gi">+            postpone = fl.xcursor is not None or fl.ycursor is not None</span>
<span class="gi">+</span>
<span class="gi">+            if postpone:</span>
<span class="gi">+                new_z_index = (</span>
<span class="gi">+                    number + 10**8</span>
<span class="gi">+                )  # Draw as late as possible, but keep the order.</span>
<span class="gi">+                screen.draw_with_z_index(</span>
<span class="gi">+                    z_index=new_z_index,</span>
<span class="gi">+                    draw_func=partial(</span>
<span class="gi">+                        self._draw_float,</span>
<span class="gi">+                        fl,</span>
<span class="gi">+                        screen,</span>
<span class="gi">+                        mouse_handlers,</span>
<span class="gi">+                        write_position,</span>
<span class="gi">+                        style,</span>
<span class="gi">+                        erase_bg,</span>
<span class="gi">+                        new_z_index,</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._draw_float(</span>
<span class="gi">+                    fl,</span>
<span class="gi">+                    screen,</span>
<span class="gi">+                    mouse_handlers,</span>
<span class="gi">+                    write_position,</span>
<span class="gi">+                    style,</span>
<span class="gi">+                    erase_bg,</span>
<span class="gi">+                    new_z_index,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _draw_float(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fl: Float,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        &quot;Draw a single Float.&quot;</span>
<span class="gi">+        # When a menu_position was given, use this instead of the cursor</span>
<span class="gi">+        # position. (These cursor positions are absolute, translate again</span>
<span class="gi">+        # relative to the write_position.)</span>
<span class="gi">+        # Note: This should be inside the for-loop, because one float could</span>
<span class="gi">+        #       set the cursor position to be used for the next one.</span>
<span class="gi">+        cpos = screen.get_menu_position(</span>
<span class="gi">+            fl.attach_to_window or get_app().layout.current_window</span>
<span class="gi">+        )</span>
<span class="gi">+        cursor_position = Point(</span>
<span class="gi">+            x=cpos.x - write_position.xpos, y=cpos.y - write_position.ypos</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        fl_width = fl.get_width()</span>
<span class="gi">+        fl_height = fl.get_height()</span>
<span class="gi">+        width: int</span>
<span class="gi">+        height: int</span>
<span class="gi">+        xpos: int</span>
<span class="gi">+        ypos: int</span>
<span class="gi">+</span>
<span class="gi">+        # Left &amp; width given.</span>
<span class="gi">+        if fl.left is not None and fl_width is not None:</span>
<span class="gi">+            xpos = fl.left</span>
<span class="gi">+            width = fl_width</span>
<span class="gi">+        # Left &amp; right given -&gt; calculate width.</span>
<span class="gi">+        elif fl.left is not None and fl.right is not None:</span>
<span class="gi">+            xpos = fl.left</span>
<span class="gi">+            width = write_position.width - fl.left - fl.right</span>
<span class="gi">+        # Width &amp; right given -&gt; calculate left.</span>
<span class="gi">+        elif fl_width is not None and fl.right is not None:</span>
<span class="gi">+            xpos = write_position.width - fl.right - fl_width</span>
<span class="gi">+            width = fl_width</span>
<span class="gi">+        # Near x position of cursor.</span>
<span class="gi">+        elif fl.xcursor:</span>
<span class="gi">+            if fl_width is None:</span>
<span class="gi">+                width = fl.content.preferred_width(write_position.width).preferred</span>
<span class="gi">+                width = min(write_position.width, width)</span>
<span class="gi">+            else:</span>
<span class="gi">+                width = fl_width</span>
<span class="gi">+</span>
<span class="gi">+            xpos = cursor_position.x</span>
<span class="gi">+            if xpos + width &gt; write_position.width:</span>
<span class="gi">+                xpos = max(0, write_position.width - width)</span>
<span class="gi">+        # Only width given -&gt; center horizontally.</span>
<span class="gi">+        elif fl_width:</span>
<span class="gi">+            xpos = int((write_position.width - fl_width) / 2)</span>
<span class="gi">+            width = fl_width</span>
<span class="gi">+        # Otherwise, take preferred width from float content.</span>
<span class="gi">+        else:</span>
<span class="gi">+            width = fl.content.preferred_width(write_position.width).preferred</span>
<span class="gi">+</span>
<span class="gi">+            if fl.left is not None:</span>
<span class="gi">+                xpos = fl.left</span>
<span class="gi">+            elif fl.right is not None:</span>
<span class="gi">+                xpos = max(0, write_position.width - width - fl.right)</span>
<span class="gi">+            else:  # Center horizontally.</span>
<span class="gi">+                xpos = max(0, int((write_position.width - width) / 2))</span>
<span class="gi">+</span>
<span class="gi">+            # Trim.</span>
<span class="gi">+            width = min(width, write_position.width - xpos)</span>
<span class="gi">+</span>
<span class="gi">+        # Top &amp; height given.</span>
<span class="gi">+        if fl.top is not None and fl_height is not None:</span>
<span class="gi">+            ypos = fl.top</span>
<span class="gi">+            height = fl_height</span>
<span class="gi">+        # Top &amp; bottom given -&gt; calculate height.</span>
<span class="gi">+        elif fl.top is not None and fl.bottom is not None:</span>
<span class="gi">+            ypos = fl.top</span>
<span class="gi">+            height = write_position.height - fl.top - fl.bottom</span>
<span class="gi">+        # Height &amp; bottom given -&gt; calculate top.</span>
<span class="gi">+        elif fl_height is not None and fl.bottom is not None:</span>
<span class="gi">+            ypos = write_position.height - fl_height - fl.bottom</span>
<span class="gi">+            height = fl_height</span>
<span class="gi">+        # Near cursor.</span>
<span class="gi">+        elif fl.ycursor:</span>
<span class="gi">+            ypos = cursor_position.y + (0 if fl.allow_cover_cursor else 1)</span>
<span class="gi">+</span>
<span class="gi">+            if fl_height is None:</span>
<span class="gi">+                height = fl.content.preferred_height(</span>
<span class="gi">+                    width, write_position.height</span>
<span class="gi">+                ).preferred</span>
<span class="gi">+            else:</span>
<span class="gi">+                height = fl_height</span>
<span class="gi">+</span>
<span class="gi">+            # Reduce height if not enough space. (We can use the height</span>
<span class="gi">+            # when the content requires it.)</span>
<span class="gi">+            if height &gt; write_position.height - ypos:</span>
<span class="gi">+                if write_position.height - ypos + 1 &gt;= ypos:</span>
<span class="gi">+                    # When the space below the cursor is more than</span>
<span class="gi">+                    # the space above, just reduce the height.</span>
<span class="gi">+                    height = write_position.height - ypos</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Otherwise, fit the float above the cursor.</span>
<span class="gi">+                    height = min(height, cursor_position.y)</span>
<span class="gi">+                    ypos = cursor_position.y - height</span>
<span class="gi">+</span>
<span class="gi">+        # Only height given -&gt; center vertically.</span>
<span class="gi">+        elif fl_height:</span>
<span class="gi">+            ypos = int((write_position.height - fl_height) / 2)</span>
<span class="gi">+            height = fl_height</span>
<span class="gi">+        # Otherwise, take preferred height from content.</span>
<span class="gi">+        else:</span>
<span class="gi">+            height = fl.content.preferred_height(width, write_position.height).preferred</span>
<span class="gi">+</span>
<span class="gi">+            if fl.top is not None:</span>
<span class="gi">+                ypos = fl.top</span>
<span class="gi">+            elif fl.bottom is not None:</span>
<span class="gi">+                ypos = max(0, write_position.height - height - fl.bottom)</span>
<span class="gi">+            else:  # Center vertically.</span>
<span class="gi">+                ypos = max(0, int((write_position.height - height) / 2))</span>
<span class="gi">+</span>
<span class="gi">+            # Trim.</span>
<span class="gi">+            height = min(height, write_position.height - ypos)</span>
<span class="gi">+</span>
<span class="gi">+        # Write float.</span>
<span class="gi">+        # (xpos and ypos can be negative: a float can be partially visible.)</span>
<span class="gi">+        if height &gt; 0 and width &gt; 0:</span>
<span class="gi">+            wp = WritePosition(</span>
<span class="gi">+                xpos=xpos + write_position.xpos,</span>
<span class="gi">+                ypos=ypos + write_position.ypos,</span>
<span class="gi">+                width=width,</span>
<span class="gi">+                height=height,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if not fl.hide_when_covering_content or self._area_is_empty(screen, wp):</span>
<span class="gi">+                fl.content.write_to_screen(</span>
<span class="gi">+                    screen,</span>
<span class="gi">+                    mouse_handlers,</span>
<span class="gi">+                    wp,</span>
<span class="gi">+                    style,</span>
<span class="gi">+                    erase_bg=not fl.transparent(),</span>
<span class="gi">+                    z_index=z_index,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _area_is_empty(self, screen: Screen, write_position: WritePosition) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return True when the area below the write position is still empty.
<span class="w"> </span>        (For floats that should not hide content underneath.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        wp = write_position</span>
<span class="gi">+</span>
<span class="gi">+        for y in range(wp.ypos, wp.ypos + wp.height):</span>
<span class="gi">+            if y in screen.data_buffer:</span>
<span class="gi">+                row = screen.data_buffer[y]</span>
<span class="gi">+</span>
<span class="gi">+                for x in range(wp.xpos, wp.xpos + wp.width):</span>
<span class="gi">+                    c = row[x]</span>
<span class="gi">+                    if c.char != &quot; &quot;:</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def is_modal(self) -&gt; bool:</span>
<span class="gi">+        return self.modal</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="gi">+        return self.key_bindings</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="gi">+        children = [self.content]</span>
<span class="gi">+        children.extend(f.content for f in self.floats)</span>
<span class="gi">+        return children</span>


<span class="w"> </span>class Float:
<span class="gu">@@ -393,32 +1042,58 @@ class Float:</span>
<span class="w"> </span>        drawn transparently.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, content: AnyContainer, top: (int | None)=None, right:</span>
<span class="gd">-        (int | None)=None, bottom: (int | None)=None, left: (int | None)=</span>
<span class="gd">-        None, width: (int | Callable[[], int] | None)=None, height: (int |</span>
<span class="gd">-        Callable[[], int] | None)=None, xcursor: bool=False, ycursor: bool=</span>
<span class="gd">-        False, attach_to_window: (AnyContainer | None)=None,</span>
<span class="gd">-        hide_when_covering_content: bool=False, allow_cover_cursor: bool=</span>
<span class="gd">-        False, z_index: int=1, transparent: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        content: AnyContainer,</span>
<span class="gi">+        top: int | None = None,</span>
<span class="gi">+        right: int | None = None,</span>
<span class="gi">+        bottom: int | None = None,</span>
<span class="gi">+        left: int | None = None,</span>
<span class="gi">+        width: int | Callable[[], int] | None = None,</span>
<span class="gi">+        height: int | Callable[[], int] | None = None,</span>
<span class="gi">+        xcursor: bool = False,</span>
<span class="gi">+        ycursor: bool = False,</span>
<span class="gi">+        attach_to_window: AnyContainer | None = None,</span>
<span class="gi">+        hide_when_covering_content: bool = False,</span>
<span class="gi">+        allow_cover_cursor: bool = False,</span>
<span class="gi">+        z_index: int = 1,</span>
<span class="gi">+        transparent: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert z_index &gt;= 1
<span class="gi">+</span>
<span class="w"> </span>        self.left = left
<span class="w"> </span>        self.right = right
<span class="w"> </span>        self.top = top
<span class="w"> </span>        self.bottom = bottom
<span class="gi">+</span>
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.height = height
<span class="gi">+</span>
<span class="w"> </span>        self.xcursor = xcursor
<span class="w"> </span>        self.ycursor = ycursor
<span class="gd">-        self.attach_to_window = to_window(attach_to_window</span>
<span class="gd">-            ) if attach_to_window else None</span>
<span class="gi">+</span>
<span class="gi">+        self.attach_to_window = (</span>
<span class="gi">+            to_window(attach_to_window) if attach_to_window else None</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.content = to_container(content)
<span class="w"> </span>        self.hide_when_covering_content = hide_when_covering_content
<span class="w"> </span>        self.allow_cover_cursor = allow_cover_cursor
<span class="w"> </span>        self.z_index = z_index
<span class="w"> </span>        self.transparent = to_filter(transparent)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Float(content=%r)&#39; % self.content</span>
<span class="gi">+    def get_width(self) -&gt; int | None:</span>
<span class="gi">+        if callable(self.width):</span>
<span class="gi">+            return self.width()</span>
<span class="gi">+        return self.width</span>
<span class="gi">+</span>
<span class="gi">+    def get_height(self) -&gt; int | None:</span>
<span class="gi">+        if callable(self.height):</span>
<span class="gi">+            return self.height()</span>
<span class="gi">+        return self.height</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Float(content=%r)&quot; % self.content</span>


<span class="w"> </span>class WindowRenderInfo:
<span class="gu">@@ -448,121 +1123,197 @@ class WindowRenderInfo:</span>
<span class="w"> </span>        the rendered screen.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, window: Window, ui_content: UIContent,</span>
<span class="gd">-        horizontal_scroll: int, vertical_scroll: int, window_width: int,</span>
<span class="gd">-        window_height: int, configured_scroll_offsets: ScrollOffsets,</span>
<span class="gd">-        visible_line_to_row_col: dict[int, tuple[int, int]], rowcol_to_yx:</span>
<span class="gd">-        dict[tuple[int, int], tuple[int, int]], x_offset: int, y_offset:</span>
<span class="gd">-        int, wrap_lines: bool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        window: Window,</span>
<span class="gi">+        ui_content: UIContent,</span>
<span class="gi">+        horizontal_scroll: int,</span>
<span class="gi">+        vertical_scroll: int,</span>
<span class="gi">+        window_width: int,</span>
<span class="gi">+        window_height: int,</span>
<span class="gi">+        configured_scroll_offsets: ScrollOffsets,</span>
<span class="gi">+        visible_line_to_row_col: dict[int, tuple[int, int]],</span>
<span class="gi">+        rowcol_to_yx: dict[tuple[int, int], tuple[int, int]],</span>
<span class="gi">+        x_offset: int,</span>
<span class="gi">+        y_offset: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.window = window
<span class="w"> </span>        self.ui_content = ui_content
<span class="w"> </span>        self.vertical_scroll = vertical_scroll
<span class="gd">-        self.window_width = window_width</span>
<span class="gi">+        self.window_width = window_width  # Width without margins.</span>
<span class="w"> </span>        self.window_height = window_height
<span class="gi">+</span>
<span class="w"> </span>        self.configured_scroll_offsets = configured_scroll_offsets
<span class="w"> </span>        self.visible_line_to_row_col = visible_line_to_row_col
<span class="w"> </span>        self.wrap_lines = wrap_lines
<span class="gd">-        self._rowcol_to_yx = rowcol_to_yx</span>
<span class="gi">+</span>
<span class="gi">+        self._rowcol_to_yx = rowcol_to_yx  # row/col from input to absolute y/x</span>
<span class="gi">+        # screen coordinates.</span>
<span class="w"> </span>        self._x_offset = x_offset
<span class="w"> </span>        self._y_offset = y_offset

<span class="w"> </span>    @property
<span class="gd">-    def cursor_position(self) -&gt;Point:</span>
<span class="gi">+    def visible_line_to_input_line(self) -&gt; dict[int, int]:</span>
<span class="gi">+        return {</span>
<span class="gi">+            visible_line: rowcol[0]</span>
<span class="gi">+            for visible_line, rowcol in self.visible_line_to_row_col.items()</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def cursor_position(self) -&gt; Point:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the cursor position coordinates, relative to the left/top corner
<span class="w"> </span>        of the rendered screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cpos = self.ui_content.cursor_position</span>
<span class="gi">+        try:</span>
<span class="gi">+            y, x = self._rowcol_to_yx[cpos.y, cpos.x]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # For `DummyControl` for instance, the content can be empty, and so</span>
<span class="gi">+            # will `_rowcol_to_yx` be. Return 0/0 by default.</span>
<span class="gi">+            return Point(x=0, y=0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Point(x=x - self._x_offset, y=y - self._y_offset)</span>

<span class="w"> </span>    @property
<span class="gd">-    def applied_scroll_offsets(self) -&gt;ScrollOffsets:</span>
<span class="gi">+    def applied_scroll_offsets(self) -&gt; ScrollOffsets:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a :class:`.ScrollOffsets` instance that indicates the actual
<span class="w"> </span>        offset. This can be less than or equal to what&#39;s configured. E.g, when
<span class="w"> </span>        the cursor is completely at the top, the top offset will be zero rather
<span class="w"> </span>        than what&#39;s configured.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.displayed_lines[0] == 0:</span>
<span class="gi">+            top = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Get row where the cursor is displayed.</span>
<span class="gi">+            y = self.input_line_to_visible_line[self.ui_content.cursor_position.y]</span>
<span class="gi">+            top = min(y, self.configured_scroll_offsets.top)</span>
<span class="gi">+</span>
<span class="gi">+        return ScrollOffsets(</span>
<span class="gi">+            top=top,</span>
<span class="gi">+            bottom=min(</span>
<span class="gi">+                self.ui_content.line_count - self.displayed_lines[-1] - 1,</span>
<span class="gi">+                self.configured_scroll_offsets.bottom,</span>
<span class="gi">+            ),</span>
<span class="gi">+            # For left/right, it probably doesn&#39;t make sense to return something.</span>
<span class="gi">+            # (We would have to calculate the widths of all the lines and keep</span>
<span class="gi">+            # double width characters in mind.)</span>
<span class="gi">+            left=0,</span>
<span class="gi">+            right=0,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def displayed_lines(self) -&gt;list[int]:</span>
<span class="gi">+    def displayed_lines(self) -&gt; list[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        List of all the visible rows. (Line numbers of the input buffer.)
<span class="w"> </span>        The last line may not be entirely visible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sorted(row for row, col in self.visible_line_to_row_col.values())</span>

<span class="w"> </span>    @property
<span class="gd">-    def input_line_to_visible_line(self) -&gt;dict[int, int]:</span>
<span class="gi">+    def input_line_to_visible_line(self) -&gt; dict[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the dictionary mapping the line numbers of the input buffer to
<span class="w"> </span>        the lines of the screen. When a line spans several rows at the screen,
<span class="w"> </span>        the first row appears in the dictionary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result: dict[int, int] = {}</span>
<span class="gi">+        for k, v in self.visible_line_to_input_line.items():</span>
<span class="gi">+            if v in result:</span>
<span class="gi">+                result[v] = min(result[v], k)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[v] = k</span>
<span class="gi">+        return result</span>

<span class="gd">-    def first_visible_line(self, after_scroll_offset: bool=False) -&gt;int:</span>
<span class="gi">+    def first_visible_line(self, after_scroll_offset: bool = False) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the line number (0 based) of the input document that corresponds
<span class="w"> </span>        with the first visible line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if after_scroll_offset:</span>
<span class="gi">+            return self.displayed_lines[self.applied_scroll_offsets.top]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.displayed_lines[0]</span>

<span class="gd">-    def last_visible_line(self, before_scroll_offset: bool=False) -&gt;int:</span>
<span class="gi">+    def last_visible_line(self, before_scroll_offset: bool = False) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like `first_visible_line`, but for the last visible line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if before_scroll_offset:</span>
<span class="gi">+            return self.displayed_lines[-1 - self.applied_scroll_offsets.bottom]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.displayed_lines[-1]</span>

<span class="gd">-    def center_visible_line(self, before_scroll_offset: bool=False,</span>
<span class="gd">-        after_scroll_offset: bool=False) -&gt;int:</span>
<span class="gi">+    def center_visible_line(</span>
<span class="gi">+        self, before_scroll_offset: bool = False, after_scroll_offset: bool = False</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like `first_visible_line`, but for the center visible line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.first_visible_line(after_scroll_offset)</span>
<span class="gi">+            + (</span>
<span class="gi">+                self.last_visible_line(before_scroll_offset)</span>
<span class="gi">+                - self.first_visible_line(after_scroll_offset)</span>
<span class="gi">+            )</span>
<span class="gi">+            // 2</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def content_height(self) -&gt;int:</span>
<span class="gi">+    def content_height(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The full height of the user control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.ui_content.line_count</span>

<span class="w"> </span>    @property
<span class="gd">-    def full_height_visible(self) -&gt;bool:</span>
<span class="gi">+    def full_height_visible(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when the full height is visible (There is no vertical scroll.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.vertical_scroll == 0</span>
<span class="gi">+            and self.last_visible_line() == self.content_height</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def top_visible(self) -&gt;bool:</span>
<span class="gi">+    def top_visible(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when the top of the buffer is visible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.vertical_scroll == 0</span>

<span class="w"> </span>    @property
<span class="gd">-    def bottom_visible(self) -&gt;bool:</span>
<span class="gi">+    def bottom_visible(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when the bottom of the buffer is visible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.last_visible_line() == self.content_height - 1</span>

<span class="w"> </span>    @property
<span class="gd">-    def vertical_scroll_percentage(self) -&gt;int:</span>
<span class="gi">+    def vertical_scroll_percentage(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Vertical scroll as a percentage. (0 means: the top is visible,
<span class="w"> </span>        100 means: the bottom is visible.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.bottom_visible:</span>
<span class="gi">+            return 100</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 100 * self.vertical_scroll // self.content_height</span>

<span class="gd">-    def get_height_for_line(self, lineno: int) -&gt;int:</span>
<span class="gi">+    def get_height_for_line(self, lineno: int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the height of the given line.
<span class="w"> </span>        (The height that it would take, if this line became visible.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.wrap_lines:</span>
<span class="gi">+            return self.ui_content.get_height_for_line(</span>
<span class="gi">+                lineno, self.window_width, self.window.get_line_prefix</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 1</span>


<span class="w"> </span>class ScrollOffsets:
<span class="gu">@@ -572,17 +1323,41 @@ class ScrollOffsets:</span>
<span class="w"> </span>    Note that left/right offsets only make sense if line wrapping is disabled.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, top: (int | Callable[[], int])=0, bottom: (int |</span>
<span class="gd">-        Callable[[], int])=0, left: (int | Callable[[], int])=0, right: (</span>
<span class="gd">-        int | Callable[[], int])=0) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        top: int | Callable[[], int] = 0,</span>
<span class="gi">+        bottom: int | Callable[[], int] = 0,</span>
<span class="gi">+        left: int | Callable[[], int] = 0,</span>
<span class="gi">+        right: int | Callable[[], int] = 0,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._top = top
<span class="w"> </span>        self._bottom = bottom
<span class="w"> </span>        self._left = left
<span class="w"> </span>        self._right = right

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (&#39;ScrollOffsets(top={!r}, bottom={!r}, left={!r}, right={!r})&#39;</span>
<span class="gd">-            .format(self._top, self._bottom, self._left, self._right))</span>
<span class="gi">+    @property</span>
<span class="gi">+    def top(self) -&gt; int:</span>
<span class="gi">+        return to_int(self._top)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def bottom(self) -&gt; int:</span>
<span class="gi">+        return to_int(self._bottom)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def left(self) -&gt; int:</span>
<span class="gi">+        return to_int(self._left)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def right(self) -&gt; int:</span>
<span class="gi">+        return to_int(self._right)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;ScrollOffsets(top={!r}, bottom={!r}, left={!r}, right={!r})&quot;.format(</span>
<span class="gi">+            self._top,</span>
<span class="gi">+            self._bottom,</span>
<span class="gi">+            self._left,</span>
<span class="gi">+            self._right,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ColorColumn:
<span class="gu">@@ -590,7 +1365,7 @@ class ColorColumn:</span>
<span class="w"> </span>    Column for a :class:`.Window` to be colored.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, position: int, style: str=&#39;class:color-column&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, position: int, style: str = &quot;class:color-column&quot;) -&gt; None:</span>
<span class="w"> </span>        self.position = position
<span class="w"> </span>        self.style = style

<span class="gu">@@ -606,9 +1381,10 @@ class WindowAlign(Enum):</span>
<span class="w"> </span>    which are used for the alignment of the child containers in respectively
<span class="w"> </span>    `VSplit` and `HSplit`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    LEFT = &#39;LEFT&#39;</span>
<span class="gd">-    RIGHT = &#39;RIGHT&#39;</span>
<span class="gd">-    CENTER = &#39;CENTER&#39;</span>
<span class="gi">+</span>
<span class="gi">+    LEFT = &quot;LEFT&quot;</span>
<span class="gi">+    RIGHT = &quot;RIGHT&quot;</span>
<span class="gi">+    CENTER = &quot;CENTER&quot;</span>


<span class="w"> </span>class Window(Container):
<span class="gu">@@ -673,28 +1449,40 @@ class Window(Container):</span>
<span class="w"> </span>        so on.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, content: (UIControl | None)=None, width:</span>
<span class="gd">-        AnyDimension=None, height: AnyDimension=None, z_index: (int | None)</span>
<span class="gd">-        =None, dont_extend_width: FilterOrBool=False, dont_extend_height:</span>
<span class="gd">-        FilterOrBool=False, ignore_content_width: FilterOrBool=False,</span>
<span class="gd">-        ignore_content_height: FilterOrBool=False, left_margins: (Sequence[</span>
<span class="gd">-        Margin] | None)=None, right_margins: (Sequence[Margin] | None)=None,</span>
<span class="gd">-        scroll_offsets: (ScrollOffsets | None)=None,</span>
<span class="gd">-        allow_scroll_beyond_bottom: FilterOrBool=False, wrap_lines:</span>
<span class="gd">-        FilterOrBool=False, get_vertical_scroll: (Callable[[Window], int] |</span>
<span class="gd">-        None)=None, get_horizontal_scroll: (Callable[[Window], int] | None)</span>
<span class="gd">-        =None, always_hide_cursor: FilterOrBool=False, cursorline:</span>
<span class="gd">-        FilterOrBool=False, cursorcolumn: FilterOrBool=False, colorcolumns:</span>
<span class="gd">-        (None | list[ColorColumn] | Callable[[], list[ColorColumn]])=None,</span>
<span class="gd">-        align: (WindowAlign | Callable[[], WindowAlign])=WindowAlign.LEFT,</span>
<span class="gd">-        style: (str | Callable[[], str])=&#39;&#39;, char: (None | str | Callable[[</span>
<span class="gd">-        ], str])=None, get_line_prefix: (GetLinePrefixCallable | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        content: UIControl | None = None,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        z_index: int | None = None,</span>
<span class="gi">+        dont_extend_width: FilterOrBool = False,</span>
<span class="gi">+        dont_extend_height: FilterOrBool = False,</span>
<span class="gi">+        ignore_content_width: FilterOrBool = False,</span>
<span class="gi">+        ignore_content_height: FilterOrBool = False,</span>
<span class="gi">+        left_margins: Sequence[Margin] | None = None,</span>
<span class="gi">+        right_margins: Sequence[Margin] | None = None,</span>
<span class="gi">+        scroll_offsets: ScrollOffsets | None = None,</span>
<span class="gi">+        allow_scroll_beyond_bottom: FilterOrBool = False,</span>
<span class="gi">+        wrap_lines: FilterOrBool = False,</span>
<span class="gi">+        get_vertical_scroll: Callable[[Window], int] | None = None,</span>
<span class="gi">+        get_horizontal_scroll: Callable[[Window], int] | None = None,</span>
<span class="gi">+        always_hide_cursor: FilterOrBool = False,</span>
<span class="gi">+        cursorline: FilterOrBool = False,</span>
<span class="gi">+        cursorcolumn: FilterOrBool = False,</span>
<span class="gi">+        colorcolumns: (</span>
<span class="gi">+            None | list[ColorColumn] | Callable[[], list[ColorColumn]]</span>
<span class="gi">+        ) = None,</span>
<span class="gi">+        align: WindowAlign | Callable[[], WindowAlign] = WindowAlign.LEFT,</span>
<span class="gi">+        style: str | Callable[[], str] = &quot;&quot;,</span>
<span class="gi">+        char: None | str | Callable[[], str] = None,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.allow_scroll_beyond_bottom = to_filter(allow_scroll_beyond_bottom)
<span class="w"> </span>        self.always_hide_cursor = to_filter(always_hide_cursor)
<span class="w"> </span>        self.wrap_lines = to_filter(wrap_lines)
<span class="w"> </span>        self.cursorline = to_filter(cursorline)
<span class="w"> </span>        self.cursorcolumn = to_filter(cursorcolumn)
<span class="gi">+</span>
<span class="w"> </span>        self.content = content or DummyControl()
<span class="w"> </span>        self.dont_extend_width = to_filter(dont_extend_width)
<span class="w"> </span>        self.dont_extend_height = to_filter(dont_extend_height)
<span class="gu">@@ -710,81 +1498,450 @@ class Window(Container):</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.char = char
<span class="w"> </span>        self.get_line_prefix = get_line_prefix
<span class="gi">+</span>
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.height = height
<span class="w"> </span>        self.z_index = z_index
<span class="gd">-        self._ui_content_cache: SimpleCache[tuple[int, int, int], UIContent</span>
<span class="gd">-            ] = SimpleCache(maxsize=8)</span>
<span class="gd">-        self._margin_width_cache: SimpleCache[tuple[Margin, int], int</span>
<span class="gd">-            ] = SimpleCache(maxsize=1)</span>
<span class="gi">+</span>
<span class="gi">+        # Cache for the screens generated by the margin.</span>
<span class="gi">+        self._ui_content_cache: SimpleCache[</span>
<span class="gi">+            tuple[int, int, int], UIContent</span>
<span class="gi">+        ] = SimpleCache(maxsize=8)</span>
<span class="gi">+        self._margin_width_cache: SimpleCache[tuple[Margin, int], int] = SimpleCache(</span>
<span class="gi">+            maxsize=1</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.reset()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Window(content=%r)&#39; % self.content</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Window(content=%r)&quot; % self.content</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.content.reset()</span>
<span class="gi">+</span>
<span class="gi">+        #: Scrolling position of the main content.</span>
<span class="gi">+        self.vertical_scroll = 0</span>
<span class="gi">+        self.horizontal_scroll = 0</span>
<span class="gi">+</span>
<span class="gi">+        # Vertical scroll 2: this is the vertical offset that a line is</span>
<span class="gi">+        # scrolled if a single line (the one that contains the cursor) consumes</span>
<span class="gi">+        # all of the vertical space.</span>
<span class="gi">+        self.vertical_scroll_2 = 0</span>

<span class="gd">-    def _get_margin_width(self, margin: Margin) -&gt;int:</span>
<span class="gi">+        #: Keep render information (mappings between buffer input and render</span>
<span class="gi">+        #: output.)</span>
<span class="gi">+        self.render_info: WindowRenderInfo | None = None</span>
<span class="gi">+</span>
<span class="gi">+    def _get_margin_width(self, margin: Margin) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width for this margin.
<span class="w"> </span>        (Calculate only once per render time.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _get_total_margin_width(self) -&gt;int:</span>
<span class="gi">+        # Margin.get_width, needs to have a UIContent instance.</span>
<span class="gi">+        def get_ui_content() -&gt; UIContent:</span>
<span class="gi">+            return self._get_ui_content(width=0, height=0)</span>
<span class="gi">+</span>
<span class="gi">+        def get_width() -&gt; int:</span>
<span class="gi">+            return margin.get_width(get_ui_content)</span>
<span class="gi">+</span>
<span class="gi">+        key = (margin, get_app().render_counter)</span>
<span class="gi">+        return self._margin_width_cache.get(key, get_width)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_total_margin_width(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Calculate and return the width of the margin (left + right).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(self._get_margin_width(m) for m in self.left_margins) + sum(</span>
<span class="gi">+            self._get_margin_width(m) for m in self.right_margins</span>
<span class="gi">+        )</span>

<span class="gd">-    def preferred_width(self, max_available_width: int) -&gt;Dimension:</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Calculate the preferred width for this window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def preferred_height(self, width: int, max_available_height: int</span>
<span class="gd">-        ) -&gt;Dimension:</span>
<span class="gi">+        def preferred_content_width() -&gt; int | None:</span>
<span class="gi">+            &quot;&quot;&quot;Content width: is only calculated if no exact width for the</span>
<span class="gi">+            window was given.&quot;&quot;&quot;</span>
<span class="gi">+            if self.ignore_content_width():</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            # Calculate the width of the margin.</span>
<span class="gi">+            total_margin_width = self._get_total_margin_width()</span>
<span class="gi">+</span>
<span class="gi">+            # Window of the content. (Can be `None`.)</span>
<span class="gi">+            preferred_width = self.content.preferred_width(</span>
<span class="gi">+                max_available_width - total_margin_width</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if preferred_width is not None:</span>
<span class="gi">+                # Include width of the margins.</span>
<span class="gi">+                preferred_width += total_margin_width</span>
<span class="gi">+            return preferred_width</span>
<span class="gi">+</span>
<span class="gi">+        # Merge.</span>
<span class="gi">+        return self._merge_dimensions(</span>
<span class="gi">+            dimension=to_dimension(self.width),</span>
<span class="gi">+            get_preferred=preferred_content_width,</span>
<span class="gi">+            dont_extend=self.dont_extend_width(),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Calculate the preferred height for this window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def preferred_content_height() -&gt; int | None:</span>
<span class="gi">+            &quot;&quot;&quot;Content height: is only calculated if no exact height for the</span>
<span class="gi">+            window was given.&quot;&quot;&quot;</span>
<span class="gi">+            if self.ignore_content_height():</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            total_margin_width = self._get_total_margin_width()</span>
<span class="gi">+            wrap_lines = self.wrap_lines()</span>
<span class="gi">+</span>
<span class="gi">+            return self.content.preferred_height(</span>
<span class="gi">+                width - total_margin_width,</span>
<span class="gi">+                max_available_height,</span>
<span class="gi">+                wrap_lines,</span>
<span class="gi">+                self.get_line_prefix,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return self._merge_dimensions(</span>
<span class="gi">+            dimension=to_dimension(self.height),</span>
<span class="gi">+            get_preferred=preferred_content_height,</span>
<span class="gi">+            dont_extend=self.dont_extend_height(),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _merge_dimensions(dimension: (Dimension | None), get_preferred:</span>
<span class="gd">-        Callable[[], int | None], dont_extend: bool=False) -&gt;Dimension:</span>
<span class="gi">+    def _merge_dimensions(</span>
<span class="gi">+        dimension: Dimension | None,</span>
<span class="gi">+        get_preferred: Callable[[], int | None],</span>
<span class="gi">+        dont_extend: bool = False,</span>
<span class="gi">+    ) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Take the Dimension from this `Window` class and the received preferred
<span class="w"> </span>        size from the `UIControl` and return a `Dimension` to report to the
<span class="w"> </span>        parent container.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dimension = dimension or Dimension()</span>

<span class="gd">-    def _get_ui_content(self, width: int, height: int) -&gt;UIContent:</span>
<span class="gi">+        # When a preferred dimension was explicitly given to the Window,</span>
<span class="gi">+        # ignore the UIControl.</span>
<span class="gi">+        preferred: int | None</span>
<span class="gi">+</span>
<span class="gi">+        if dimension.preferred_specified:</span>
<span class="gi">+            preferred = dimension.preferred</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, calculate the preferred dimension from the UI control</span>
<span class="gi">+            # content.</span>
<span class="gi">+            preferred = get_preferred()</span>
<span class="gi">+</span>
<span class="gi">+        # When a &#39;preferred&#39; dimension is given by the UIControl, make sure</span>
<span class="gi">+        # that it stays within the bounds of the Window.</span>
<span class="gi">+        if preferred is not None:</span>
<span class="gi">+            if dimension.max_specified:</span>
<span class="gi">+                preferred = min(preferred, dimension.max)</span>
<span class="gi">+</span>
<span class="gi">+            if dimension.min_specified:</span>
<span class="gi">+                preferred = max(preferred, dimension.min)</span>
<span class="gi">+</span>
<span class="gi">+        # When a `dont_extend` flag has been given, use the preferred dimension</span>
<span class="gi">+        # also as the max dimension.</span>
<span class="gi">+        max_: int | None</span>
<span class="gi">+        min_: int | None</span>
<span class="gi">+</span>
<span class="gi">+        if dont_extend and preferred is not None:</span>
<span class="gi">+            max_ = min(dimension.max, preferred)</span>
<span class="gi">+        else:</span>
<span class="gi">+            max_ = dimension.max if dimension.max_specified else None</span>
<span class="gi">+</span>
<span class="gi">+        min_ = dimension.min if dimension.min_specified else None</span>
<span class="gi">+</span>
<span class="gi">+        return Dimension(</span>
<span class="gi">+            min=min_, max=max_, preferred=preferred, weight=dimension.weight</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_ui_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a `UIContent` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_digraph_char(self) -&gt;(str | None):</span>
<span class="gd">-        &quot;&quot;&quot;Return `False`, or the Digraph symbol to be used.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>

<span class="gd">-    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,</span>
<span class="gd">-        write_position: WritePosition, parent_style: str, erase_bg: bool,</span>
<span class="gd">-        z_index: (int | None)) -&gt;None:</span>
<span class="gi">+        def get_content() -&gt; UIContent:</span>
<span class="gi">+            return self.content.create_content(width=width, height=height)</span>
<span class="gi">+</span>
<span class="gi">+        key = (get_app().render_counter, width, height)</span>
<span class="gi">+        return self._ui_content_cache.get(key, get_content)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_digraph_char(self) -&gt; str | None:</span>
<span class="gi">+        &quot;Return `False`, or the Digraph symbol to be used.&quot;</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        if app.quoted_insert:</span>
<span class="gi">+            return &quot;^&quot;</span>
<span class="gi">+        if app.vi_state.waiting_for_digraph:</span>
<span class="gi">+            if app.vi_state.digraph_symbol1:</span>
<span class="gi">+                return app.vi_state.digraph_symbol1</span>
<span class="gi">+            return &quot;?&quot;</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write window to screen. This renders the user control, the margins and
<span class="w"> </span>        copies everything over to the absolute position at the given screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _copy_body(self, ui_content: UIContent, new_screen: Screen,</span>
<span class="gd">-        write_position: WritePosition, move_x: int, width: int,</span>
<span class="gd">-        vertical_scroll: int=0, horizontal_scroll: int=0, wrap_lines: bool=</span>
<span class="gd">-        False, highlight_lines: bool=False, vertical_scroll_2: int=0,</span>
<span class="gd">-        always_hide_cursor: bool=False, has_focus: bool=False, align:</span>
<span class="gd">-        WindowAlign=WindowAlign.LEFT, get_line_prefix: (Callable[[int, int],</span>
<span class="gd">-        AnyFormattedText] | None)=None) -&gt;tuple[dict[int, tuple[int, int]],</span>
<span class="gd">-        dict[tuple[int, int], tuple[int, int]]]:</span>
<span class="gi">+        # If dont_extend_width/height was given. Then reduce width/height in</span>
<span class="gi">+        # WritePosition if the parent wanted us to paint in a bigger area.</span>
<span class="gi">+        # (This happens if this window is bundled with another window in a</span>
<span class="gi">+        # HSplit/VSplit, but with different size requirements.)</span>
<span class="gi">+        write_position = WritePosition(</span>
<span class="gi">+            xpos=write_position.xpos,</span>
<span class="gi">+            ypos=write_position.ypos,</span>
<span class="gi">+            width=write_position.width,</span>
<span class="gi">+            height=write_position.height,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.dont_extend_width():</span>
<span class="gi">+            write_position.width = min(</span>
<span class="gi">+                write_position.width,</span>
<span class="gi">+                self.preferred_width(write_position.width).preferred,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.dont_extend_height():</span>
<span class="gi">+            write_position.height = min(</span>
<span class="gi">+                write_position.height,</span>
<span class="gi">+                self.preferred_height(</span>
<span class="gi">+                    write_position.width, write_position.height</span>
<span class="gi">+                ).preferred,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Draw</span>
<span class="gi">+        z_index = z_index if self.z_index is None else self.z_index</span>
<span class="gi">+</span>
<span class="gi">+        draw_func = partial(</span>
<span class="gi">+            self._write_to_screen_at_index,</span>
<span class="gi">+            screen,</span>
<span class="gi">+            mouse_handlers,</span>
<span class="gi">+            write_position,</span>
<span class="gi">+            parent_style,</span>
<span class="gi">+            erase_bg,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if z_index is None or z_index &lt;= 0:</span>
<span class="gi">+            # When no z_index is given, draw right away.</span>
<span class="gi">+            draw_func()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, postpone.</span>
<span class="gi">+            screen.draw_with_z_index(z_index=z_index, draw_func=draw_func)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_to_screen_at_index(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Don&#39;t bother writing invisible windows.</span>
<span class="gi">+        # (We save some time, but also avoid applying last-line styling.)</span>
<span class="gi">+        if write_position.height &lt;= 0 or write_position.width &lt;= 0:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate margin sizes.</span>
<span class="gi">+        left_margin_widths = [self._get_margin_width(m) for m in self.left_margins]</span>
<span class="gi">+        right_margin_widths = [self._get_margin_width(m) for m in self.right_margins]</span>
<span class="gi">+        total_margin_width = sum(left_margin_widths + right_margin_widths)</span>
<span class="gi">+</span>
<span class="gi">+        # Render UserControl.</span>
<span class="gi">+        ui_content = self.content.create_content(</span>
<span class="gi">+            write_position.width - total_margin_width, write_position.height</span>
<span class="gi">+        )</span>
<span class="gi">+        assert isinstance(ui_content, UIContent)</span>
<span class="gi">+</span>
<span class="gi">+        # Scroll content.</span>
<span class="gi">+        wrap_lines = self.wrap_lines()</span>
<span class="gi">+        self._scroll(</span>
<span class="gi">+            ui_content, write_position.width - total_margin_width, write_position.height</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Erase background and fill with `char`.</span>
<span class="gi">+        self._fill_bg(screen, write_position, erase_bg)</span>
<span class="gi">+</span>
<span class="gi">+        # Resolve `align` attribute.</span>
<span class="gi">+        align = self.align() if callable(self.align) else self.align</span>
<span class="gi">+</span>
<span class="gi">+        # Write body</span>
<span class="gi">+        visible_line_to_row_col, rowcol_to_yx = self._copy_body(</span>
<span class="gi">+            ui_content,</span>
<span class="gi">+            screen,</span>
<span class="gi">+            write_position,</span>
<span class="gi">+            sum(left_margin_widths),</span>
<span class="gi">+            write_position.width - total_margin_width,</span>
<span class="gi">+            self.vertical_scroll,</span>
<span class="gi">+            self.horizontal_scroll,</span>
<span class="gi">+            wrap_lines=wrap_lines,</span>
<span class="gi">+            highlight_lines=True,</span>
<span class="gi">+            vertical_scroll_2=self.vertical_scroll_2,</span>
<span class="gi">+            always_hide_cursor=self.always_hide_cursor(),</span>
<span class="gi">+            has_focus=get_app().layout.current_control == self.content,</span>
<span class="gi">+            align=align,</span>
<span class="gi">+            get_line_prefix=self.get_line_prefix,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Remember render info. (Set before generating the margins. They need this.)</span>
<span class="gi">+        x_offset = write_position.xpos + sum(left_margin_widths)</span>
<span class="gi">+        y_offset = write_position.ypos</span>
<span class="gi">+</span>
<span class="gi">+        render_info = WindowRenderInfo(</span>
<span class="gi">+            window=self,</span>
<span class="gi">+            ui_content=ui_content,</span>
<span class="gi">+            horizontal_scroll=self.horizontal_scroll,</span>
<span class="gi">+            vertical_scroll=self.vertical_scroll,</span>
<span class="gi">+            window_width=write_position.width - total_margin_width,</span>
<span class="gi">+            window_height=write_position.height,</span>
<span class="gi">+            configured_scroll_offsets=self.scroll_offsets,</span>
<span class="gi">+            visible_line_to_row_col=visible_line_to_row_col,</span>
<span class="gi">+            rowcol_to_yx=rowcol_to_yx,</span>
<span class="gi">+            x_offset=x_offset,</span>
<span class="gi">+            y_offset=y_offset,</span>
<span class="gi">+            wrap_lines=wrap_lines,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.render_info = render_info</span>
<span class="gi">+</span>
<span class="gi">+        # Set mouse handlers.</span>
<span class="gi">+        def mouse_handler(mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Wrapper around the mouse_handler of the `UIControl` that turns</span>
<span class="gi">+            screen coordinates into line coordinates.</span>
<span class="gi">+            Returns `NotImplemented` if no UI invalidation should be done.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            # Don&#39;t handle mouse events outside of the current modal part of</span>
<span class="gi">+            # the UI.</span>
<span class="gi">+            if self not in get_app().layout.walk_through_modal_area():</span>
<span class="gi">+                return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+            # Find row/col position first.</span>
<span class="gi">+            yx_to_rowcol = {v: k for k, v in rowcol_to_yx.items()}</span>
<span class="gi">+            y = mouse_event.position.y</span>
<span class="gi">+            x = mouse_event.position.x</span>
<span class="gi">+</span>
<span class="gi">+            # If clicked below the content area, look for a position in the</span>
<span class="gi">+            # last line instead.</span>
<span class="gi">+            max_y = write_position.ypos + len(visible_line_to_row_col) - 1</span>
<span class="gi">+            y = min(max_y, y)</span>
<span class="gi">+            result: NotImplementedOrNone</span>
<span class="gi">+</span>
<span class="gi">+            while x &gt;= 0:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    row, col = yx_to_rowcol[y, x]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    # Try again. (When clicking on the right side of double</span>
<span class="gi">+                    # width characters, or on the right side of the input.)</span>
<span class="gi">+                    x -= 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Found position, call handler of UIControl.</span>
<span class="gi">+                    result = self.content.mouse_handler(</span>
<span class="gi">+                        MouseEvent(</span>
<span class="gi">+                            position=Point(x=col, y=row),</span>
<span class="gi">+                            event_type=mouse_event.event_type,</span>
<span class="gi">+                            button=mouse_event.button,</span>
<span class="gi">+                            modifiers=mouse_event.modifiers,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # nobreak.</span>
<span class="gi">+                # (No x/y coordinate found for the content. This happens in</span>
<span class="gi">+                # case of a DummyControl, that does not have any content.</span>
<span class="gi">+                # Report (0,0) instead.)</span>
<span class="gi">+                result = self.content.mouse_handler(</span>
<span class="gi">+                    MouseEvent(</span>
<span class="gi">+                        position=Point(x=0, y=0),</span>
<span class="gi">+                        event_type=mouse_event.event_type,</span>
<span class="gi">+                        button=mouse_event.button,</span>
<span class="gi">+                        modifiers=mouse_event.modifiers,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # If it returns NotImplemented, handle it here.</span>
<span class="gi">+            if result == NotImplemented:</span>
<span class="gi">+                result = self._mouse_handler(mouse_event)</span>
<span class="gi">+</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        mouse_handlers.set_mouse_handler_for_range(</span>
<span class="gi">+            x_min=write_position.xpos + sum(left_margin_widths),</span>
<span class="gi">+            x_max=write_position.xpos + write_position.width - total_margin_width,</span>
<span class="gi">+            y_min=write_position.ypos,</span>
<span class="gi">+            y_max=write_position.ypos + write_position.height,</span>
<span class="gi">+            handler=mouse_handler,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Render and copy margins.</span>
<span class="gi">+        move_x = 0</span>
<span class="gi">+</span>
<span class="gi">+        def render_margin(m: Margin, width: int) -&gt; UIContent:</span>
<span class="gi">+            &quot;Render margin. Return `Screen`.&quot;</span>
<span class="gi">+            # Retrieve margin fragments.</span>
<span class="gi">+            fragments = m.create_margin(render_info, width, write_position.height)</span>
<span class="gi">+</span>
<span class="gi">+            # Turn it into a UIContent object.</span>
<span class="gi">+            # already rendered those fragments using this size.)</span>
<span class="gi">+            return FormattedTextControl(fragments).create_content(</span>
<span class="gi">+                width + 1, write_position.height</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for m, width in zip(self.left_margins, left_margin_widths):</span>
<span class="gi">+            if width &gt; 0:  # (ConditionalMargin returns a zero width. -- Don&#39;t render.)</span>
<span class="gi">+                # Create screen for margin.</span>
<span class="gi">+                margin_content = render_margin(m, width)</span>
<span class="gi">+</span>
<span class="gi">+                # Copy and shift X.</span>
<span class="gi">+                self._copy_margin(margin_content, screen, write_position, move_x, width)</span>
<span class="gi">+                move_x += width</span>
<span class="gi">+</span>
<span class="gi">+        move_x = write_position.width - sum(right_margin_widths)</span>
<span class="gi">+</span>
<span class="gi">+        for m, width in zip(self.right_margins, right_margin_widths):</span>
<span class="gi">+            # Create screen for margin.</span>
<span class="gi">+            margin_content = render_margin(m, width)</span>
<span class="gi">+</span>
<span class="gi">+            # Copy and shift X.</span>
<span class="gi">+            self._copy_margin(margin_content, screen, write_position, move_x, width)</span>
<span class="gi">+            move_x += width</span>
<span class="gi">+</span>
<span class="gi">+        # Apply &#39;self.style&#39;</span>
<span class="gi">+        self._apply_style(screen, write_position, parent_style)</span>
<span class="gi">+</span>
<span class="gi">+        # Tell the screen that this user control has been painted at this</span>
<span class="gi">+        # position.</span>
<span class="gi">+        screen.visible_windows_to_write_positions[self] = write_position</span>
<span class="gi">+</span>
<span class="gi">+    def _copy_body(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ui_content: UIContent,</span>
<span class="gi">+        new_screen: Screen,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        move_x: int,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        vertical_scroll: int = 0,</span>
<span class="gi">+        horizontal_scroll: int = 0,</span>
<span class="gi">+        wrap_lines: bool = False,</span>
<span class="gi">+        highlight_lines: bool = False,</span>
<span class="gi">+        vertical_scroll_2: int = 0,</span>
<span class="gi">+        always_hide_cursor: bool = False,</span>
<span class="gi">+        has_focus: bool = False,</span>
<span class="gi">+        align: WindowAlign = WindowAlign.LEFT,</span>
<span class="gi">+        get_line_prefix: Callable[[int, int], AnyFormattedText] | None = None,</span>
<span class="gi">+    ) -&gt; tuple[dict[int, tuple[int, int]], dict[tuple[int, int], tuple[int, int]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy the UIContent into the output screen.
<span class="w"> </span>        Return (visible_line_to_row_col, rowcol_to_yx) tuple.
<span class="gu">@@ -792,24 +1949,277 @@ class Window(Container):</span>
<span class="w"> </span>        :param get_line_prefix: None or a callable that takes a line number
<span class="w"> </span>            (int) and a wrap_count (int) and returns formatted text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _fill_bg(self, screen: Screen, write_position: WritePosition,</span>
<span class="gd">-        erase_bg: bool) -&gt;None:</span>
<span class="gi">+        xpos = write_position.xpos + move_x</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        line_count = ui_content.line_count</span>
<span class="gi">+        new_buffer = new_screen.data_buffer</span>
<span class="gi">+        empty_char = _CHAR_CACHE[&quot;&quot;, &quot;&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # Map visible line number to (row, col) of input.</span>
<span class="gi">+        # &#39;col&#39; will always be zero if line wrapping is off.</span>
<span class="gi">+        visible_line_to_row_col: dict[int, tuple[int, int]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Maps (row, col) from the input to (y, x) screen coordinates.</span>
<span class="gi">+        rowcol_to_yx: dict[tuple[int, int], tuple[int, int]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def copy_line(</span>
<span class="gi">+            line: StyleAndTextTuples,</span>
<span class="gi">+            lineno: int,</span>
<span class="gi">+            x: int,</span>
<span class="gi">+            y: int,</span>
<span class="gi">+            is_input: bool = False,</span>
<span class="gi">+        ) -&gt; tuple[int, int]:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Copy over a single line to the output screen. This can wrap over</span>
<span class="gi">+            multiple lines in the output. It will call the prefix (prompt)</span>
<span class="gi">+            function before every line.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if is_input:</span>
<span class="gi">+                current_rowcol_to_yx = rowcol_to_yx</span>
<span class="gi">+            else:</span>
<span class="gi">+                current_rowcol_to_yx = {}  # Throwaway dictionary.</span>
<span class="gi">+</span>
<span class="gi">+            # Draw line prefix.</span>
<span class="gi">+            if is_input and get_line_prefix:</span>
<span class="gi">+                prompt = to_formatted_text(get_line_prefix(lineno, 0))</span>
<span class="gi">+                x, y = copy_line(prompt, lineno, x, y, is_input=False)</span>
<span class="gi">+</span>
<span class="gi">+            # Scroll horizontally.</span>
<span class="gi">+            skipped = 0  # Characters skipped because of horizontal scrolling.</span>
<span class="gi">+            if horizontal_scroll and is_input:</span>
<span class="gi">+                h_scroll = horizontal_scroll</span>
<span class="gi">+                line = explode_text_fragments(line)</span>
<span class="gi">+                while h_scroll &gt; 0 and line:</span>
<span class="gi">+                    h_scroll -= get_cwidth(line[0][1])</span>
<span class="gi">+                    skipped += 1</span>
<span class="gi">+                    del line[:1]  # Remove first character.</span>
<span class="gi">+</span>
<span class="gi">+                x -= h_scroll  # When scrolling over double width character,</span>
<span class="gi">+                # this can end up being negative.</span>
<span class="gi">+</span>
<span class="gi">+            # Align this line. (Note that this doesn&#39;t work well when we use</span>
<span class="gi">+            # get_line_prefix and that function returns variable width prefixes.)</span>
<span class="gi">+            if align == WindowAlign.CENTER:</span>
<span class="gi">+                line_width = fragment_list_width(line)</span>
<span class="gi">+                if line_width &lt; width:</span>
<span class="gi">+                    x += (width - line_width) // 2</span>
<span class="gi">+            elif align == WindowAlign.RIGHT:</span>
<span class="gi">+                line_width = fragment_list_width(line)</span>
<span class="gi">+                if line_width &lt; width:</span>
<span class="gi">+                    x += width - line_width</span>
<span class="gi">+</span>
<span class="gi">+            col = 0</span>
<span class="gi">+            wrap_count = 0</span>
<span class="gi">+            for style, text, *_ in line:</span>
<span class="gi">+                new_buffer_row = new_buffer[y + ypos]</span>
<span class="gi">+</span>
<span class="gi">+                # Remember raw VT escape sequences. (E.g. FinalTerm&#39;s</span>
<span class="gi">+                # escape sequences.)</span>
<span class="gi">+                if &quot;[ZeroWidthEscape]&quot; in style:</span>
<span class="gi">+                    new_screen.zero_width_escapes[y + ypos][x + xpos] += text</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for c in text:</span>
<span class="gi">+                    char = _CHAR_CACHE[c, style]</span>
<span class="gi">+                    char_width = char.width</span>
<span class="gi">+</span>
<span class="gi">+                    # Wrap when the line width is exceeded.</span>
<span class="gi">+                    if wrap_lines and x + char_width &gt; width:</span>
<span class="gi">+                        visible_line_to_row_col[y + 1] = (</span>
<span class="gi">+                            lineno,</span>
<span class="gi">+                            visible_line_to_row_col[y][1] + x,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        y += 1</span>
<span class="gi">+                        wrap_count += 1</span>
<span class="gi">+                        x = 0</span>
<span class="gi">+</span>
<span class="gi">+                        # Insert line prefix (continuation prompt).</span>
<span class="gi">+                        if is_input and get_line_prefix:</span>
<span class="gi">+                            prompt = to_formatted_text(</span>
<span class="gi">+                                get_line_prefix(lineno, wrap_count)</span>
<span class="gi">+                            )</span>
<span class="gi">+                            x, y = copy_line(prompt, lineno, x, y, is_input=False)</span>
<span class="gi">+</span>
<span class="gi">+                        new_buffer_row = new_buffer[y + ypos]</span>
<span class="gi">+</span>
<span class="gi">+                        if y &gt;= write_position.height:</span>
<span class="gi">+                            return x, y  # Break out of all for loops.</span>
<span class="gi">+</span>
<span class="gi">+                    # Set character in screen and shift &#39;x&#39;.</span>
<span class="gi">+                    if x &gt;= 0 and y &gt;= 0 and x &lt; width:</span>
<span class="gi">+                        new_buffer_row[x + xpos] = char</span>
<span class="gi">+</span>
<span class="gi">+                        # When we print a multi width character, make sure</span>
<span class="gi">+                        # to erase the neighbors positions in the screen.</span>
<span class="gi">+                        # (The empty string if different from everything,</span>
<span class="gi">+                        # so next redraw this cell will repaint anyway.)</span>
<span class="gi">+                        if char_width &gt; 1:</span>
<span class="gi">+                            for i in range(1, char_width):</span>
<span class="gi">+                                new_buffer_row[x + xpos + i] = empty_char</span>
<span class="gi">+</span>
<span class="gi">+                        # If this is a zero width characters, then it&#39;s</span>
<span class="gi">+                        # probably part of a decomposed unicode character.</span>
<span class="gi">+                        # See: https://en.wikipedia.org/wiki/Unicode_equivalence</span>
<span class="gi">+                        # Merge it in the previous cell.</span>
<span class="gi">+                        elif char_width == 0:</span>
<span class="gi">+                            # Handle all character widths. If the previous</span>
<span class="gi">+                            # character is a multiwidth character, then</span>
<span class="gi">+                            # merge it two positions back.</span>
<span class="gi">+                            for pw in [2, 1]:  # Previous character width.</span>
<span class="gi">+                                if (</span>
<span class="gi">+                                    x - pw &gt;= 0</span>
<span class="gi">+                                    and new_buffer_row[x + xpos - pw].width == pw</span>
<span class="gi">+                                ):</span>
<span class="gi">+                                    prev_char = new_buffer_row[x + xpos - pw]</span>
<span class="gi">+                                    char2 = _CHAR_CACHE[</span>
<span class="gi">+                                        prev_char.char + c, prev_char.style</span>
<span class="gi">+                                    ]</span>
<span class="gi">+                                    new_buffer_row[x + xpos - pw] = char2</span>
<span class="gi">+</span>
<span class="gi">+                        # Keep track of write position for each character.</span>
<span class="gi">+                        current_rowcol_to_yx[lineno, col + skipped] = (</span>
<span class="gi">+                            y + ypos,</span>
<span class="gi">+                            x + xpos,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+                    col += 1</span>
<span class="gi">+                    x += char_width</span>
<span class="gi">+            return x, y</span>
<span class="gi">+</span>
<span class="gi">+        # Copy content.</span>
<span class="gi">+        def copy() -&gt; int:</span>
<span class="gi">+            y = -vertical_scroll_2</span>
<span class="gi">+            lineno = vertical_scroll</span>
<span class="gi">+</span>
<span class="gi">+            while y &lt; write_position.height and lineno &lt; line_count:</span>
<span class="gi">+                # Take the next line and copy it in the real screen.</span>
<span class="gi">+                line = ui_content.get_line(lineno)</span>
<span class="gi">+</span>
<span class="gi">+                visible_line_to_row_col[y] = (lineno, horizontal_scroll)</span>
<span class="gi">+</span>
<span class="gi">+                # Copy margin and actual line.</span>
<span class="gi">+                x = 0</span>
<span class="gi">+                x, y = copy_line(line, lineno, x, y, is_input=True)</span>
<span class="gi">+</span>
<span class="gi">+                lineno += 1</span>
<span class="gi">+                y += 1</span>
<span class="gi">+            return y</span>
<span class="gi">+</span>
<span class="gi">+        copy()</span>
<span class="gi">+</span>
<span class="gi">+        def cursor_pos_to_screen_pos(row: int, col: int) -&gt; Point:</span>
<span class="gi">+            &quot;Translate row/col from UIContent to real Screen coordinates.&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                y, x = rowcol_to_yx[row, col]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # Normally this should never happen. (It is a bug, if it happens.)</span>
<span class="gi">+                # But to be sure, return (0, 0)</span>
<span class="gi">+                return Point(x=0, y=0)</span>
<span class="gi">+</span>
<span class="gi">+                # raise ValueError(</span>
<span class="gi">+                #     &#39;Invalid position. row=%r col=%r, vertical_scroll=%r, &#39;</span>
<span class="gi">+                #     &#39;horizontal_scroll=%r, height=%r&#39; %</span>
<span class="gi">+                #     (row, col, vertical_scroll, horizontal_scroll, write_position.height))</span>
<span class="gi">+            else:</span>
<span class="gi">+                return Point(x=x, y=y)</span>
<span class="gi">+</span>
<span class="gi">+        # Set cursor and menu positions.</span>
<span class="gi">+        if ui_content.cursor_position:</span>
<span class="gi">+            screen_cursor_position = cursor_pos_to_screen_pos(</span>
<span class="gi">+                ui_content.cursor_position.y, ui_content.cursor_position.x</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if has_focus:</span>
<span class="gi">+                new_screen.set_cursor_position(self, screen_cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+                if always_hide_cursor:</span>
<span class="gi">+                    new_screen.show_cursor = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    new_screen.show_cursor = ui_content.show_cursor</span>
<span class="gi">+</span>
<span class="gi">+                self._highlight_digraph(new_screen)</span>
<span class="gi">+</span>
<span class="gi">+            if highlight_lines:</span>
<span class="gi">+                self._highlight_cursorlines(</span>
<span class="gi">+                    new_screen,</span>
<span class="gi">+                    screen_cursor_position,</span>
<span class="gi">+                    xpos,</span>
<span class="gi">+                    ypos,</span>
<span class="gi">+                    width,</span>
<span class="gi">+                    write_position.height,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # Draw input characters from the input processor queue.</span>
<span class="gi">+        if has_focus and ui_content.cursor_position:</span>
<span class="gi">+            self._show_key_processor_key_buffer(new_screen)</span>
<span class="gi">+</span>
<span class="gi">+        # Set menu position.</span>
<span class="gi">+        if ui_content.menu_position:</span>
<span class="gi">+            new_screen.set_menu_position(</span>
<span class="gi">+                self,</span>
<span class="gi">+                cursor_pos_to_screen_pos(</span>
<span class="gi">+                    ui_content.menu_position.y, ui_content.menu_position.x</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Update output screen height.</span>
<span class="gi">+        new_screen.height = max(new_screen.height, ypos + write_position.height)</span>
<span class="gi">+</span>
<span class="gi">+        return visible_line_to_row_col, rowcol_to_yx</span>
<span class="gi">+</span>
<span class="gi">+    def _fill_bg(</span>
<span class="gi">+        self, screen: Screen, write_position: WritePosition, erase_bg: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erase/fill the background.
<span class="w"> </span>        (Useful for floats and when a `char` has been given.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _highlight_digraph(self, new_screen: Screen) -&gt;None:</span>
<span class="gi">+        char: str | None</span>
<span class="gi">+        if callable(self.char):</span>
<span class="gi">+            char = self.char()</span>
<span class="gi">+        else:</span>
<span class="gi">+            char = self.char</span>
<span class="gi">+</span>
<span class="gi">+        if erase_bg or char:</span>
<span class="gi">+            wp = write_position</span>
<span class="gi">+            char_obj = _CHAR_CACHE[char or &quot; &quot;, &quot;&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            for y in range(wp.ypos, wp.ypos + wp.height):</span>
<span class="gi">+                row = screen.data_buffer[y]</span>
<span class="gi">+                for x in range(wp.xpos, wp.xpos + wp.width):</span>
<span class="gi">+                    row[x] = char_obj</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_style(</span>
<span class="gi">+        self, new_screen: Screen, write_position: WritePosition, parent_style: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Apply `self.style`.</span>
<span class="gi">+        style = parent_style + &quot; &quot; + to_str(self.style)</span>
<span class="gi">+</span>
<span class="gi">+        new_screen.fill_area(write_position, style=style, after=False)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply the &#39;last-line&#39; class to the last line of each Window. This can</span>
<span class="gi">+        # be used to apply an &#39;underline&#39; to the user control.</span>
<span class="gi">+        wp = WritePosition(</span>
<span class="gi">+            write_position.xpos,</span>
<span class="gi">+            write_position.ypos + write_position.height - 1,</span>
<span class="gi">+            write_position.width,</span>
<span class="gi">+            1,</span>
<span class="gi">+        )</span>
<span class="gi">+        new_screen.fill_area(wp, &quot;class:last-line&quot;, after=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _highlight_digraph(self, new_screen: Screen) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When we are in Vi digraph mode, put a question mark underneath the
<span class="w"> </span>        cursor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        digraph_char = self._get_digraph_char()</span>
<span class="gi">+        if digraph_char:</span>
<span class="gi">+            cpos = new_screen.get_cursor_position(self)</span>
<span class="gi">+            new_screen.data_buffer[cpos.y][cpos.x] = _CHAR_CACHE[</span>
<span class="gi">+                digraph_char, &quot;class:digraph&quot;</span>
<span class="gi">+            ]</span>

<span class="gd">-    def _show_key_processor_key_buffer(self, new_screen: Screen) -&gt;None:</span>
<span class="gi">+    def _show_key_processor_key_buffer(self, new_screen: Screen) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When the user is typing a key binding that consists of several keys,
<span class="w"> </span>        display the last pressed key if the user is in insert mode and the key
<span class="gu">@@ -817,49 +2227,324 @@ class Window(Container):</span>
<span class="w"> </span>        E.g. Some people want to bind &#39;jj&#39; to escape in Vi insert mode. But the
<span class="w"> </span>             first &#39;j&#39; needs to be displayed in order to get some feedback.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        key_buffer = app.key_processor.key_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if key_buffer and _in_insert_mode() and not app.is_done:</span>
<span class="gi">+            # The textual data for the given key. (Can be a VT100 escape</span>
<span class="gi">+            # sequence.)</span>
<span class="gi">+            data = key_buffer[-1].data</span>
<span class="gi">+</span>
<span class="gi">+            # Display only if this is a 1 cell width character.</span>
<span class="gi">+            if get_cwidth(data) == 1:</span>
<span class="gi">+                cpos = new_screen.get_cursor_position(self)</span>
<span class="gi">+                new_screen.data_buffer[cpos.y][cpos.x] = _CHAR_CACHE[</span>
<span class="gi">+                    data, &quot;class:partial-key-binding&quot;</span>
<span class="gi">+                ]</span>

<span class="gd">-    def _highlight_cursorlines(self, new_screen: Screen, cpos: Point, x:</span>
<span class="gd">-        int, y: int, width: int, height: int) -&gt;None:</span>
<span class="gi">+    def _highlight_cursorlines(</span>
<span class="gi">+        self, new_screen: Screen, cpos: Point, x: int, y: int, width: int, height: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Highlight cursor row/column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _copy_margin(self, margin_content: UIContent, new_screen: Screen,</span>
<span class="gd">-        write_position: WritePosition, move_x: int, width: int) -&gt;None:</span>
<span class="gi">+        cursor_line_style = &quot; class:cursor-line &quot;</span>
<span class="gi">+        cursor_column_style = &quot; class:cursor-column &quot;</span>
<span class="gi">+</span>
<span class="gi">+        data_buffer = new_screen.data_buffer</span>
<span class="gi">+</span>
<span class="gi">+        # Highlight cursor line.</span>
<span class="gi">+        if self.cursorline():</span>
<span class="gi">+            row = data_buffer[cpos.y]</span>
<span class="gi">+            for x in range(x, x + width):</span>
<span class="gi">+                original_char = row[x]</span>
<span class="gi">+                row[x] = _CHAR_CACHE[</span>
<span class="gi">+                    original_char.char, original_char.style + cursor_line_style</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+        # Highlight cursor column.</span>
<span class="gi">+        if self.cursorcolumn():</span>
<span class="gi">+            for y2 in range(y, y + height):</span>
<span class="gi">+                row = data_buffer[y2]</span>
<span class="gi">+                original_char = row[cpos.x]</span>
<span class="gi">+                row[cpos.x] = _CHAR_CACHE[</span>
<span class="gi">+                    original_char.char, original_char.style + cursor_column_style</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+        # Highlight color columns</span>
<span class="gi">+        colorcolumns = self.colorcolumns</span>
<span class="gi">+        if callable(colorcolumns):</span>
<span class="gi">+            colorcolumns = colorcolumns()</span>
<span class="gi">+</span>
<span class="gi">+        for cc in colorcolumns:</span>
<span class="gi">+            assert isinstance(cc, ColorColumn)</span>
<span class="gi">+            column = cc.position</span>
<span class="gi">+</span>
<span class="gi">+            if column &lt; x + width:  # Only draw when visible.</span>
<span class="gi">+                color_column_style = &quot; &quot; + cc.style</span>
<span class="gi">+</span>
<span class="gi">+                for y2 in range(y, y + height):</span>
<span class="gi">+                    row = data_buffer[y2]</span>
<span class="gi">+                    original_char = row[column + x]</span>
<span class="gi">+                    row[column + x] = _CHAR_CACHE[</span>
<span class="gi">+                        original_char.char, original_char.style + color_column_style</span>
<span class="gi">+                    ]</span>
<span class="gi">+</span>
<span class="gi">+    def _copy_margin(</span>
<span class="gi">+        self,</span>
<span class="gi">+        margin_content: UIContent,</span>
<span class="gi">+        new_screen: Screen,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        move_x: int,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy characters from the margin screen to the real screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        xpos = write_position.xpos + move_x</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+</span>
<span class="gi">+        margin_write_position = WritePosition(xpos, ypos, width, write_position.height)</span>
<span class="gi">+        self._copy_body(margin_content, new_screen, margin_write_position, 0, width)</span>

<span class="gd">-    def _scroll(self, ui_content: UIContent, width: int, height: int) -&gt;None:</span>
<span class="gi">+    def _scroll(self, ui_content: UIContent, width: int, height: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Scroll body. Ensure that the cursor is visible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.wrap_lines():</span>
<span class="gi">+            func = self._scroll_when_linewrapping</span>
<span class="gi">+        else:</span>
<span class="gi">+            func = self._scroll_without_linewrapping</span>

<span class="gd">-    def _scroll_when_linewrapping(self, ui_content: UIContent, width: int,</span>
<span class="gd">-        height: int) -&gt;None:</span>
<span class="gi">+        func(ui_content, width, height)</span>
<span class="gi">+</span>
<span class="gi">+    def _scroll_when_linewrapping(</span>
<span class="gi">+        self, ui_content: UIContent, width: int, height: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Scroll to make sure the cursor position is visible and that we maintain
<span class="w"> </span>        the requested scroll offset.

<span class="w"> </span>        Set `self.horizontal_scroll/vertical_scroll`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _scroll_without_linewrapping(self, ui_content: UIContent, width:</span>
<span class="gd">-        int, height: int) -&gt;None:</span>
<span class="gi">+        scroll_offsets_bottom = self.scroll_offsets.bottom</span>
<span class="gi">+        scroll_offsets_top = self.scroll_offsets.top</span>
<span class="gi">+</span>
<span class="gi">+        # We don&#39;t have horizontal scrolling.</span>
<span class="gi">+        self.horizontal_scroll = 0</span>
<span class="gi">+</span>
<span class="gi">+        def get_line_height(lineno: int) -&gt; int:</span>
<span class="gi">+            return ui_content.get_height_for_line(lineno, width, self.get_line_prefix)</span>
<span class="gi">+</span>
<span class="gi">+        # When there is no space, reset `vertical_scroll_2` to zero and abort.</span>
<span class="gi">+        # This can happen if the margin is bigger than the window width.</span>
<span class="gi">+        # Otherwise the text height will become &quot;infinite&quot; (a big number) and</span>
<span class="gi">+        # the copy_line will spend a huge amount of iterations trying to render</span>
<span class="gi">+        # nothing.</span>
<span class="gi">+        if width &lt;= 0:</span>
<span class="gi">+            self.vertical_scroll = ui_content.cursor_position.y</span>
<span class="gi">+            self.vertical_scroll_2 = 0</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If the current line consumes more than the whole window height,</span>
<span class="gi">+        # then we have to scroll vertically inside this line. (We don&#39;t take</span>
<span class="gi">+        # the scroll offsets into account for this.)</span>
<span class="gi">+        # Also, ignore the scroll offsets in this case. Just set the vertical</span>
<span class="gi">+        # scroll to this line.</span>
<span class="gi">+        line_height = get_line_height(ui_content.cursor_position.y)</span>
<span class="gi">+        if line_height &gt; height - scroll_offsets_top:</span>
<span class="gi">+            # Calculate the height of the text before the cursor (including</span>
<span class="gi">+            # line prefixes).</span>
<span class="gi">+            text_before_height = ui_content.get_height_for_line(</span>
<span class="gi">+                ui_content.cursor_position.y,</span>
<span class="gi">+                width,</span>
<span class="gi">+                self.get_line_prefix,</span>
<span class="gi">+                slice_stop=ui_content.cursor_position.x,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Adjust scroll offset.</span>
<span class="gi">+            self.vertical_scroll = ui_content.cursor_position.y</span>
<span class="gi">+            self.vertical_scroll_2 = min(</span>
<span class="gi">+                text_before_height - 1,  # Keep the cursor visible.</span>
<span class="gi">+                line_height</span>
<span class="gi">+                - height,  # Avoid blank lines at the bottom when scrolling up again.</span>
<span class="gi">+                self.vertical_scroll_2,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.vertical_scroll_2 = max(</span>
<span class="gi">+                0, text_before_height - height, self.vertical_scroll_2</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.vertical_scroll_2 = 0</span>
<span class="gi">+</span>
<span class="gi">+        # Current line doesn&#39;t consume the whole height. Take scroll offsets into account.</span>
<span class="gi">+        def get_min_vertical_scroll() -&gt; int:</span>
<span class="gi">+            # Make sure that the cursor line is not below the bottom.</span>
<span class="gi">+            # (Calculate how many lines can be shown between the cursor and the .)</span>
<span class="gi">+            used_height = 0</span>
<span class="gi">+            prev_lineno = ui_content.cursor_position.y</span>
<span class="gi">+</span>
<span class="gi">+            for lineno in range(ui_content.cursor_position.y, -1, -1):</span>
<span class="gi">+                used_height += get_line_height(lineno)</span>
<span class="gi">+</span>
<span class="gi">+                if used_height &gt; height - scroll_offsets_bottom:</span>
<span class="gi">+                    return prev_lineno</span>
<span class="gi">+                else:</span>
<span class="gi">+                    prev_lineno = lineno</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        def get_max_vertical_scroll() -&gt; int:</span>
<span class="gi">+            # Make sure that the cursor line is not above the top.</span>
<span class="gi">+            prev_lineno = ui_content.cursor_position.y</span>
<span class="gi">+            used_height = 0</span>
<span class="gi">+</span>
<span class="gi">+            for lineno in range(ui_content.cursor_position.y - 1, -1, -1):</span>
<span class="gi">+                used_height += get_line_height(lineno)</span>
<span class="gi">+</span>
<span class="gi">+                if used_height &gt; scroll_offsets_top:</span>
<span class="gi">+                    return prev_lineno</span>
<span class="gi">+                else:</span>
<span class="gi">+                    prev_lineno = lineno</span>
<span class="gi">+            return prev_lineno</span>
<span class="gi">+</span>
<span class="gi">+        def get_topmost_visible() -&gt; int:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Calculate the upper most line that can be visible, while the bottom</span>
<span class="gi">+            is still visible. We should not allow scroll more than this if</span>
<span class="gi">+            `allow_scroll_beyond_bottom` is false.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            prev_lineno = ui_content.line_count - 1</span>
<span class="gi">+            used_height = 0</span>
<span class="gi">+            for lineno in range(ui_content.line_count - 1, -1, -1):</span>
<span class="gi">+                used_height += get_line_height(lineno)</span>
<span class="gi">+                if used_height &gt; height:</span>
<span class="gi">+                    return prev_lineno</span>
<span class="gi">+                else:</span>
<span class="gi">+                    prev_lineno = lineno</span>
<span class="gi">+            return prev_lineno</span>
<span class="gi">+</span>
<span class="gi">+        # Scroll vertically. (Make sure that the whole line which contains the</span>
<span class="gi">+        # cursor is visible.</span>
<span class="gi">+        topmost_visible = get_topmost_visible()</span>
<span class="gi">+</span>
<span class="gi">+        # Note: the `min(topmost_visible, ...)` is to make sure that we</span>
<span class="gi">+        # don&#39;t require scrolling up because of the bottom scroll offset,</span>
<span class="gi">+        # when we are at the end of the document.</span>
<span class="gi">+        self.vertical_scroll = max(</span>
<span class="gi">+            self.vertical_scroll, min(topmost_visible, get_min_vertical_scroll())</span>
<span class="gi">+        )</span>
<span class="gi">+        self.vertical_scroll = min(self.vertical_scroll, get_max_vertical_scroll())</span>
<span class="gi">+</span>
<span class="gi">+        # Disallow scrolling beyond bottom?</span>
<span class="gi">+        if not self.allow_scroll_beyond_bottom():</span>
<span class="gi">+            self.vertical_scroll = min(self.vertical_scroll, topmost_visible)</span>
<span class="gi">+</span>
<span class="gi">+    def _scroll_without_linewrapping(</span>
<span class="gi">+        self, ui_content: UIContent, width: int, height: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Scroll to make sure the cursor position is visible and that we maintain
<span class="w"> </span>        the requested scroll offset.

<span class="w"> </span>        Set `self.horizontal_scroll/vertical_scroll`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+        cursor_position = ui_content.cursor_position or Point(x=0, y=0)</span>
<span class="gi">+</span>
<span class="gi">+        # Without line wrapping, we will never have to scroll vertically inside</span>
<span class="gi">+        # a single line.</span>
<span class="gi">+        self.vertical_scroll_2 = 0</span>
<span class="gi">+</span>
<span class="gi">+        if ui_content.line_count == 0:</span>
<span class="gi">+            self.vertical_scroll = 0</span>
<span class="gi">+            self.horizontal_scroll = 0</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            current_line_text = fragment_list_to_text(</span>
<span class="gi">+                ui_content.get_line(cursor_position.y)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        def do_scroll(</span>
<span class="gi">+            current_scroll: int,</span>
<span class="gi">+            scroll_offset_start: int,</span>
<span class="gi">+            scroll_offset_end: int,</span>
<span class="gi">+            cursor_pos: int,</span>
<span class="gi">+            window_size: int,</span>
<span class="gi">+            content_size: int,</span>
<span class="gi">+        ) -&gt; int:</span>
<span class="gi">+            &quot;Scrolling algorithm. Used for both horizontal and vertical scrolling.&quot;</span>
<span class="gi">+            # Calculate the scroll offset to apply.</span>
<span class="gi">+            # This can obviously never be more than have the screen size. Also, when the</span>
<span class="gi">+            # cursor appears at the top or bottom, we don&#39;t apply the offset.</span>
<span class="gi">+            scroll_offset_start = int(</span>
<span class="gi">+                min(scroll_offset_start, window_size / 2, cursor_pos)</span>
<span class="gi">+            )</span>
<span class="gi">+            scroll_offset_end = int(</span>
<span class="gi">+                min(scroll_offset_end, window_size / 2, content_size - 1 - cursor_pos)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Prevent negative scroll offsets.</span>
<span class="gi">+            if current_scroll &lt; 0:</span>
<span class="gi">+                current_scroll = 0</span>
<span class="gi">+</span>
<span class="gi">+            # Scroll back if we scrolled to much and there&#39;s still space to show more of the document.</span>
<span class="gi">+            if (</span>
<span class="gi">+                not self.allow_scroll_beyond_bottom()</span>
<span class="gi">+                and current_scroll &gt; content_size - window_size</span>
<span class="gi">+            ):</span>
<span class="gi">+                current_scroll = max(0, content_size - window_size)</span>
<span class="gi">+</span>
<span class="gi">+            # Scroll up if cursor is before visible part.</span>
<span class="gi">+            if current_scroll &gt; cursor_pos - scroll_offset_start:</span>
<span class="gi">+                current_scroll = max(0, cursor_pos - scroll_offset_start)</span>
<span class="gi">+</span>
<span class="gi">+            # Scroll down if cursor is after visible part.</span>
<span class="gi">+            if current_scroll &lt; (cursor_pos + 1) - window_size + scroll_offset_end:</span>
<span class="gi">+                current_scroll = (cursor_pos + 1) - window_size + scroll_offset_end</span>
<span class="gi">+</span>
<span class="gi">+            return current_scroll</span>
<span class="gi">+</span>
<span class="gi">+        # When a preferred scroll is given, take that first into account.</span>
<span class="gi">+        if self.get_vertical_scroll:</span>
<span class="gi">+            self.vertical_scroll = self.get_vertical_scroll(self)</span>
<span class="gi">+            assert isinstance(self.vertical_scroll, int)</span>
<span class="gi">+        if self.get_horizontal_scroll:</span>
<span class="gi">+            self.horizontal_scroll = self.get_horizontal_scroll(self)</span>
<span class="gi">+            assert isinstance(self.horizontal_scroll, int)</span>
<span class="gi">+</span>
<span class="gi">+        # Update horizontal/vertical scroll to make sure that the cursor</span>
<span class="gi">+        # remains visible.</span>
<span class="gi">+        offsets = self.scroll_offsets</span>
<span class="gi">+</span>
<span class="gi">+        self.vertical_scroll = do_scroll(</span>
<span class="gi">+            current_scroll=self.vertical_scroll,</span>
<span class="gi">+            scroll_offset_start=offsets.top,</span>
<span class="gi">+            scroll_offset_end=offsets.bottom,</span>
<span class="gi">+            cursor_pos=ui_content.cursor_position.y,</span>
<span class="gi">+            window_size=height,</span>
<span class="gi">+            content_size=ui_content.line_count,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.get_line_prefix:</span>
<span class="gi">+            current_line_prefix_width = fragment_list_width(</span>
<span class="gi">+                to_formatted_text(self.get_line_prefix(ui_content.cursor_position.y, 0))</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            current_line_prefix_width = 0</span>
<span class="gi">+</span>
<span class="gi">+        self.horizontal_scroll = do_scroll(</span>
<span class="gi">+            current_scroll=self.horizontal_scroll,</span>
<span class="gi">+            scroll_offset_start=offsets.left,</span>
<span class="gi">+            scroll_offset_end=offsets.right,</span>
<span class="gi">+            cursor_pos=get_cwidth(current_line_text[: ui_content.cursor_position.x]),</span>
<span class="gi">+            window_size=width - current_line_prefix_width,</span>
<span class="gi">+            # We can only analyze the current line. Calculating the width off</span>
<span class="gi">+            # all the lines is too expensive.</span>
<span class="gi">+            content_size=max(</span>
<span class="gi">+                get_cwidth(current_line_text), self.horizontal_scroll + width</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _mouse_handler(self, mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mouse handler. Called when the UI control doesn&#39;t handle this
<span class="w"> </span>        particular event.
<span class="gu">@@ -867,15 +2552,50 @@ class Window(Container):</span>
<span class="w"> </span>        Return `NotImplemented` if nothing was done as a consequence of this
<span class="w"> </span>        key binding (no UI invalidate required in that case).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mouse_event.event_type == MouseEventType.SCROLL_DOWN:</span>
<span class="gi">+            self._scroll_down()</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.SCROLL_UP:</span>
<span class="gi">+            self._scroll_up()</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    def _scroll_down(self) -&gt; None:</span>
<span class="gi">+        &quot;Scroll window down.&quot;</span>
<span class="gi">+        info = self.render_info</span>
<span class="gi">+</span>
<span class="gi">+        if info is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.vertical_scroll &lt; info.content_height - info.window_height:</span>
<span class="gi">+            if info.cursor_position.y &lt;= info.configured_scroll_offsets.top:</span>
<span class="gi">+                self.content.move_cursor_down()</span>
<span class="gi">+</span>
<span class="gi">+            self.vertical_scroll += 1</span>
<span class="gi">+</span>
<span class="gi">+    def _scroll_up(self) -&gt; None:</span>
<span class="gi">+        &quot;Scroll window up.&quot;</span>
<span class="gi">+        info = self.render_info</span>
<span class="gi">+</span>
<span class="gi">+        if info is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if info.vertical_scroll &gt; 0:</span>
<span class="gi">+            # TODO: not entirely correct yet in case of line wrapping and long lines.</span>
<span class="gi">+            if (</span>
<span class="gi">+                info.cursor_position.y</span>
<span class="gi">+                &gt;= info.window_height - 1 - info.configured_scroll_offsets.bottom</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.content.move_cursor_up()</span>

<span class="gd">-    def _scroll_down(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Scroll window down.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+            self.vertical_scroll -= 1</span>

<span class="gd">-    def _scroll_up(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Scroll window up.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="gi">+        return self.content.get_key_bindings()</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class ConditionalContainer(Container):
<span class="gu">@@ -888,13 +2608,44 @@ class ConditionalContainer(Container):</span>
<span class="w"> </span>    :param filter: :class:`.Filter` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, content: AnyContainer, filter: FilterOrBool) -&gt;None:</span>
<span class="gi">+    def __init__(self, content: AnyContainer, filter: FilterOrBool) -&gt; None:</span>
<span class="w"> </span>        self.content = to_container(content)
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;ConditionalContainer({self.content!r}, filter={self.filter!r})&#39;)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;ConditionalContainer({self.content!r}, filter={self.filter!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.content.reset()</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.content.preferred_width(max_available_width)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Dimension.zero()</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.content.preferred_height(width, max_available_height)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Dimension.zero()</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.content.write_to_screen(</span>
<span class="gi">+                screen, mouse_handlers, write_position, parent_style, erase_bg, z_index</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="gi">+        return [self.content]</span>


<span class="w"> </span>class DynamicContainer(Container):
<span class="gu">@@ -905,36 +2656,88 @@ class DynamicContainer(Container):</span>
<span class="w"> </span>        or any widget with a ``__pt_container__`` method.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_container: Callable[[], AnyContainer]) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_container: Callable[[], AnyContainer]) -&gt; None:</span>
<span class="w"> </span>        self.get_container = get_container

<span class="gd">-    def _get_container(self) -&gt;Container:</span>
<span class="gi">+    def _get_container(self) -&gt; Container:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the current container object.

<span class="w"> </span>        We call `to_container`, because `get_container` can also return a
<span class="w"> </span>        widget with a ``__pt_container__`` method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj = self.get_container()</span>
<span class="gi">+        return to_container(obj)</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self._get_container().reset()</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="gi">+        return self._get_container().preferred_width(max_available_width)</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="gi">+        return self._get_container().preferred_height(width, max_available_height)</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._get_container().write_to_screen(</span>
<span class="gi">+            screen, mouse_handlers, write_position, parent_style, erase_bg, z_index</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def is_modal(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="gi">+        # Key bindings will be collected when `layout.walk()` finds the child</span>
<span class="gi">+        # container.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="gi">+        # Here we have to return the current active container itself, not its</span>
<span class="gi">+        # children. Otherwise, we run into issues where `layout.walk()` will</span>
<span class="gi">+        # never see an object of type `Window` if this contains a window. We</span>
<span class="gi">+        # can&#39;t/shouldn&#39;t proxy the &quot;isinstance&quot; check.</span>
<span class="gi">+        return [self._get_container()]</span>


<span class="gd">-def to_container(container: AnyContainer) -&gt;Container:</span>
<span class="gi">+def to_container(container: AnyContainer) -&gt; Container:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make sure that the given object is a :class:`.Container`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(container, Container):</span>
<span class="gi">+        return container</span>
<span class="gi">+    elif hasattr(container, &quot;__pt_container__&quot;):</span>
<span class="gi">+        return to_container(container.__pt_container__())</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Not a container object: {container!r}&quot;)</span>


<span class="gd">-def to_window(container: AnyContainer) -&gt;Window:</span>
<span class="gi">+def to_window(container: AnyContainer) -&gt; Window:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make sure that the given argument is a :class:`.Window`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(container, Window):</span>
<span class="gi">+        return container</span>
<span class="gi">+    elif hasattr(container, &quot;__pt_container__&quot;):</span>
<span class="gi">+        return to_window(cast(&quot;MagicContainer&quot;, container).__pt_container__())</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Not a Window object: {container!r}.&quot;)</span>


<span class="gd">-def is_container(value: object) -&gt;TypeGuard[AnyContainer]:</span>
<span class="gi">+def is_container(value: object) -&gt; TypeGuard[AnyContainer]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks whether the given value is a container object
<span class="w"> </span>    (for use in assert statements).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, Container):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if hasattr(value, &quot;__pt_container__&quot;):</span>
<span class="gi">+        return is_container(cast(&quot;MagicContainer&quot;, value).__pt_container__())</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/controls.py b/src/prompt_toolkit/layout/controls.py</span>
<span class="gh">index d76f0c21..c30c0eff 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/controls.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/controls.py</span>
<span class="gu">@@ -2,28 +2,60 @@</span>
<span class="w"> </span>User interface Controls for the layout.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import time
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING, Callable, Hashable, Iterable, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.buffer import Buffer
<span class="w"> </span>from prompt_toolkit.cache import SimpleCache
<span class="w"> </span>from prompt_toolkit.data_structures import Point
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, to_formatted_text</span>
<span class="gd">-from prompt_toolkit.formatted_text.utils import fragment_list_to_text, fragment_list_width, split_lines</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text.utils import (</span>
<span class="gi">+    fragment_list_to_text,</span>
<span class="gi">+    fragment_list_width,</span>
<span class="gi">+    split_lines,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.lexers import Lexer, SimpleLexer
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseButton, MouseEvent, MouseEventType
<span class="w"> </span>from prompt_toolkit.search import SearchState
<span class="w"> </span>from prompt_toolkit.selection import SelectionType
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gd">-from .processors import DisplayMultipleCursors, HighlightIncrementalSearchProcessor, HighlightSearchProcessor, HighlightSelectionProcessor, Processor, TransformationInput, merge_processors</span>
<span class="gi">+</span>
<span class="gi">+from .processors import (</span>
<span class="gi">+    DisplayMultipleCursors,</span>
<span class="gi">+    HighlightIncrementalSearchProcessor,</span>
<span class="gi">+    HighlightSearchProcessor,</span>
<span class="gi">+    HighlightSelectionProcessor,</span>
<span class="gi">+    Processor,</span>
<span class="gi">+    TransformationInput,</span>
<span class="gi">+    merge_processors,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from prompt_toolkit.key_binding.key_bindings import KeyBindingsBase, NotImplementedOrNone</span>
<span class="gi">+    from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+        KeyBindingsBase,</span>
<span class="gi">+        NotImplementedOrNone,</span>
<span class="gi">+    )</span>
<span class="w"> </span>    from prompt_toolkit.utils import Event
<span class="gd">-__all__ = [&#39;BufferControl&#39;, &#39;SearchBufferControl&#39;, &#39;DummyControl&#39;,</span>
<span class="gd">-    &#39;FormattedTextControl&#39;, &#39;UIControl&#39;, &#39;UIContent&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;BufferControl&quot;,</span>
<span class="gi">+    &quot;SearchBufferControl&quot;,</span>
<span class="gi">+    &quot;DummyControl&quot;,</span>
<span class="gi">+    &quot;FormattedTextControl&quot;,</span>
<span class="gi">+    &quot;UIControl&quot;,</span>
<span class="gi">+    &quot;UIContent&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>GetLinePrefixCallable = Callable[[int, int], AnyFormattedText]


<span class="gu">@@ -32,22 +64,37 @@ class UIControl(metaclass=ABCMeta):</span>
<span class="w"> </span>    Base class for all user interface controls.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def is_focusable(self) -&gt;bool:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        # Default reset. (Doesn&#39;t have to be implemented.)</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; int | None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        max_available_height: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def is_focusable(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Tell whether this user control is focusable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def create_content(self, width: int, height: int) -&gt;UIContent:</span>
<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate the content for this user control.

<span class="w"> </span>        Returns a :class:`.UIContent` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+    def mouse_handler(self, mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle mouse events.

<span class="gu">@@ -57,38 +104,35 @@ class UIControl(metaclass=ABCMeta):</span>

<span class="w"> </span>        :param mouse_event: `MouseEvent` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NotImplemented</span>

<span class="gd">-    def move_cursor_down(self) -&gt;None:</span>
<span class="gi">+    def move_cursor_down(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Request to move the cursor down.
<span class="w"> </span>        This happens when scrolling down and the cursor is completely at the
<span class="w"> </span>        top.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def move_cursor_up(self) -&gt;None:</span>
<span class="gi">+    def move_cursor_up(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Request to move the cursor up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_key_bindings(self) -&gt;(KeyBindingsBase | None):</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The key bindings that are specific for this user control.

<span class="w"> </span>        Return a :class:`.KeyBindings` object if some key bindings are
<span class="w"> </span>        specified, or `None` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_invalidate_events(self) -&gt;Iterable[Event[object]]:</span>
<span class="gi">+    def get_invalidate_events(self) -&gt; Iterable[Event[object]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of `Event` objects. This can be a generator.
<span class="w"> </span>        (The application collects all these events, in order to bind redraw
<span class="w"> </span>        handlers to these events.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class UIContent:
<span class="gu">@@ -104,25 +148,37 @@ class UIContent:</span>
<span class="w"> </span>    :param show_cursor: Make the cursor visible.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_line: Callable[[int], StyleAndTextTuples]=lambda</span>
<span class="gd">-        i: [], line_count: int=0, cursor_position: (Point | None)=None,</span>
<span class="gd">-        menu_position: (Point | None)=None, show_cursor: bool=True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_line: Callable[[int], StyleAndTextTuples] = (lambda i: []),</span>
<span class="gi">+        line_count: int = 0,</span>
<span class="gi">+        cursor_position: Point | None = None,</span>
<span class="gi">+        menu_position: Point | None = None,</span>
<span class="gi">+        show_cursor: bool = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.get_line = get_line
<span class="w"> </span>        self.line_count = line_count
<span class="w"> </span>        self.cursor_position = cursor_position or Point(x=0, y=0)
<span class="w"> </span>        self.menu_position = menu_position
<span class="w"> </span>        self.show_cursor = show_cursor
<span class="gi">+</span>
<span class="gi">+        # Cache for line heights. Maps cache key -&gt; height</span>
<span class="w"> </span>        self._line_heights_cache: dict[Hashable, int] = {}

<span class="gd">-    def __getitem__(self, lineno: int) -&gt;StyleAndTextTuples:</span>
<span class="gd">-        &quot;&quot;&quot;Make it iterable (iterate line by line).&quot;&quot;&quot;</span>
<span class="gi">+    def __getitem__(self, lineno: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        &quot;Make it iterable (iterate line by line).&quot;</span>
<span class="w"> </span>        if lineno &lt; self.line_count:
<span class="w"> </span>            return self.get_line(lineno)
<span class="w"> </span>        else:
<span class="w"> </span>            raise IndexError

<span class="gd">-    def get_height_for_line(self, lineno: int, width: int, get_line_prefix:</span>
<span class="gd">-        (GetLinePrefixCallable | None), slice_stop: (int | None)=None) -&gt;int:</span>
<span class="gi">+    def get_height_for_line(</span>
<span class="gi">+        self,</span>
<span class="gi">+        lineno: int,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+        slice_stop: int | None = None,</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the height that a given line would need if it is rendered in a
<span class="w"> </span>        space with the given width (using line wrapping).
<span class="gu">@@ -134,7 +190,60 @@ class UIContent:</span>
<span class="w"> </span>            when line wrapping.
<span class="w"> </span>        :returns: The computed height.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Instead of using `get_line_prefix` as key, we use render_counter</span>
<span class="gi">+        # instead. This is more reliable, because this function could still be</span>
<span class="gi">+        # the same, while the content would change over time.</span>
<span class="gi">+        key = get_app().render_counter, lineno, width, slice_stop</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._line_heights_cache[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if width == 0:</span>
<span class="gi">+                height = 10**8</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Calculate line width first.</span>
<span class="gi">+                line = fragment_list_to_text(self.get_line(lineno))[:slice_stop]</span>
<span class="gi">+                text_width = get_cwidth(line)</span>
<span class="gi">+</span>
<span class="gi">+                if get_line_prefix:</span>
<span class="gi">+                    # Add prefix width.</span>
<span class="gi">+                    text_width += fragment_list_width(</span>
<span class="gi">+                        to_formatted_text(get_line_prefix(lineno, 0))</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    # Slower path: compute path when there&#39;s a line prefix.</span>
<span class="gi">+                    height = 1</span>
<span class="gi">+</span>
<span class="gi">+                    # Keep wrapping as long as the line doesn&#39;t fit.</span>
<span class="gi">+                    # Keep adding new prefixes for every wrapped line.</span>
<span class="gi">+                    while text_width &gt; width:</span>
<span class="gi">+                        height += 1</span>
<span class="gi">+                        text_width -= width</span>
<span class="gi">+</span>
<span class="gi">+                        fragments2 = to_formatted_text(</span>
<span class="gi">+                            get_line_prefix(lineno, height - 1)</span>
<span class="gi">+                        )</span>
<span class="gi">+                        prefix_width = get_cwidth(fragment_list_to_text(fragments2))</span>
<span class="gi">+</span>
<span class="gi">+                        if prefix_width &gt;= width:  # Prefix doesn&#39;t fit.</span>
<span class="gi">+                            height = 10**8</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                        text_width += prefix_width</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Fast path: compute height when there&#39;s no line prefix.</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        quotient, remainder = divmod(text_width, width)</span>
<span class="gi">+                    except ZeroDivisionError:</span>
<span class="gi">+                        height = 10**8</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if remainder:</span>
<span class="gi">+                            quotient += 1  # Like math.ceil.</span>
<span class="gi">+                        height = max(1, quotient)</span>
<span class="gi">+</span>
<span class="gi">+            # Cache and return</span>
<span class="gi">+            self._line_heights_cache[key] = height</span>
<span class="gi">+            return height</span>


<span class="w"> </span>class FormattedTextControl(UIControl):
<span class="gu">@@ -180,50 +289,136 @@ class FormattedTextControl(UIControl):</span>
<span class="w"> </span>        a `Point` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: AnyFormattedText=&#39;&#39;, style: str=&#39;&#39;, focusable:</span>
<span class="gd">-        FilterOrBool=False, key_bindings: (KeyBindingsBase | None)=None,</span>
<span class="gd">-        show_cursor: bool=True, modal: bool=False, get_cursor_position: (</span>
<span class="gd">-        Callable[[], Point | None] | None)=None) -&gt;None:</span>
<span class="gd">-        self.text = text</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+        focusable: FilterOrBool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        show_cursor: bool = True,</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+        get_cursor_position: Callable[[], Point | None] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.text = text  # No type check on &#39;text&#39;. This is done dynamically.</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.focusable = to_filter(focusable)
<span class="gi">+</span>
<span class="gi">+        # Key bindings.</span>
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self.show_cursor = show_cursor
<span class="w"> </span>        self.modal = modal
<span class="w"> </span>        self.get_cursor_position = get_cursor_position
<span class="gd">-        self._content_cache: SimpleCache[Hashable, UIContent] = SimpleCache(</span>
<span class="gd">-            maxsize=18)</span>
<span class="gd">-        self._fragment_cache: SimpleCache[int, StyleAndTextTuples</span>
<span class="gd">-            ] = SimpleCache(maxsize=1)</span>
<span class="gi">+</span>
<span class="gi">+        #: Cache for the content.</span>
<span class="gi">+        self._content_cache: SimpleCache[Hashable, UIContent] = SimpleCache(maxsize=18)</span>
<span class="gi">+        self._fragment_cache: SimpleCache[int, StyleAndTextTuples] = SimpleCache(</span>
<span class="gi">+            maxsize=1</span>
<span class="gi">+        )</span>
<span class="gi">+        # Only cache one fragment list. We don&#39;t need the previous item.</span>
<span class="gi">+</span>
<span class="gi">+        # Render info for the mouse support.</span>
<span class="w"> </span>        self._fragments: StyleAndTextTuples | None = None

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.text!r})&#39;</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self._fragments = None</span>
<span class="gi">+</span>
<span class="gi">+    def is_focusable(self) -&gt; bool:</span>
<span class="gi">+        return self.focusable()</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.text!r})&quot;</span>

<span class="gd">-    def _get_formatted_text_cached(self) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def _get_formatted_text_cached(self) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get fragments, but only retrieve fragments once during one render run.
<span class="w"> </span>        (This function is called several times during one rendering, because
<span class="w"> </span>        we also need those for calculating the dimensions.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._fragment_cache.get(</span>
<span class="gi">+            get_app().render_counter, lambda: to_formatted_text(self.text, self.style)</span>
<span class="gi">+        )</span>

<span class="gd">-    def preferred_width(self, max_available_width: int) -&gt;int:</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the preferred width for this control.
<span class="w"> </span>        That is the width of the longest line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        text = fragment_list_to_text(self._get_formatted_text_cached())</span>
<span class="gi">+        line_lengths = [get_cwidth(l) for l in text.split(&quot;\n&quot;)]</span>
<span class="gi">+        return max(line_lengths)</span>

<span class="gd">-    def preferred_height(self, width: int, max_available_height: int,</span>
<span class="gd">-        wrap_lines: bool, get_line_prefix: (GetLinePrefixCallable | None)) -&gt;(</span>
<span class="gd">-        int | None):</span>
<span class="gi">+    def preferred_height(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        max_available_height: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the preferred height for this control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        content = self.create_content(width, None)</span>
<span class="gi">+        if wrap_lines:</span>
<span class="gi">+            height = 0</span>
<span class="gi">+            for i in range(content.line_count):</span>
<span class="gi">+                height += content.get_height_for_line(i, width, get_line_prefix)</span>
<span class="gi">+                if height &gt;= max_available_height:</span>
<span class="gi">+                    return max_available_height</span>
<span class="gi">+            return height</span>
<span class="gi">+        else:</span>
<span class="gi">+            return content.line_count</span>
<span class="gi">+</span>
<span class="gi">+    def create_content(self, width: int, height: int | None) -&gt; UIContent:</span>
<span class="gi">+        # Get fragments</span>
<span class="gi">+        fragments_with_mouse_handlers = self._get_formatted_text_cached()</span>
<span class="gi">+        fragment_lines_with_mouse_handlers = list(</span>
<span class="gi">+            split_lines(fragments_with_mouse_handlers)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Strip mouse handlers from fragments.</span>
<span class="gi">+        fragment_lines: list[StyleAndTextTuples] = [</span>
<span class="gi">+            [(item[0], item[1]) for item in line]</span>
<span class="gi">+            for line in fragment_lines_with_mouse_handlers</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Keep track of the fragments with mouse handler, for later use in</span>
<span class="gi">+        # `mouse_handler`.</span>
<span class="gi">+        self._fragments = fragments_with_mouse_handlers</span>
<span class="gi">+</span>
<span class="gi">+        # If there is a `[SetCursorPosition]` in the fragment list, set the</span>
<span class="gi">+        # cursor position here.</span>
<span class="gi">+        def get_cursor_position(</span>
<span class="gi">+            fragment: str = &quot;[SetCursorPosition]&quot;,</span>
<span class="gi">+        ) -&gt; Point | None:</span>
<span class="gi">+            for y, line in enumerate(fragment_lines):</span>
<span class="gi">+                x = 0</span>
<span class="gi">+                for style_str, text, *_ in line:</span>
<span class="gi">+                    if fragment in style_str:</span>
<span class="gi">+                        return Point(x=x, y=y)</span>
<span class="gi">+                    x += len(text)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # If there is a `[SetMenuPosition]`, set the menu over here.</span>
<span class="gi">+        def get_menu_position() -&gt; Point | None:</span>
<span class="gi">+            return get_cursor_position(&quot;[SetMenuPosition]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        cursor_position = (self.get_cursor_position or get_cursor_position)()</span>
<span class="gi">+</span>
<span class="gi">+        # Create content, or take it from the cache.</span>
<span class="gi">+        key = (tuple(fragments_with_mouse_handlers), width, cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+        def get_content() -&gt; UIContent:</span>
<span class="gi">+            return UIContent(</span>
<span class="gi">+                get_line=lambda i: fragment_lines[i],</span>
<span class="gi">+                line_count=len(fragment_lines),</span>
<span class="gi">+                show_cursor=self.show_cursor,</span>
<span class="gi">+                cursor_position=cursor_position,</span>
<span class="gi">+                menu_position=get_menu_position(),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return self._content_cache.get(key, get_content)</span>

<span class="gd">-    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+    def mouse_handler(self, mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle mouse events.

<span class="gu">@@ -233,7 +428,40 @@ class FormattedTextControl(UIControl):</span>
<span class="w"> </span>        :class:`~prompt_toolkit.layout.Window` to handle this particular
<span class="w"> </span>        event.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._fragments:</span>
<span class="gi">+            # Read the generator.</span>
<span class="gi">+            fragments_for_line = list(split_lines(self._fragments))</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                fragments = fragments_for_line[mouse_event.position.y]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                return NotImplemented</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Find position in the fragment list.</span>
<span class="gi">+                xpos = mouse_event.position.x</span>
<span class="gi">+</span>
<span class="gi">+                # Find mouse handler for this character.</span>
<span class="gi">+                count = 0</span>
<span class="gi">+                for item in fragments:</span>
<span class="gi">+                    count += len(item[1])</span>
<span class="gi">+                    if count &gt; xpos:</span>
<span class="gi">+                        if len(item) &gt;= 3:</span>
<span class="gi">+                            # Handler found. Call it.</span>
<span class="gi">+                            # (Handler can return NotImplemented, so return</span>
<span class="gi">+                            # that result.)</span>
<span class="gi">+                            handler = item[2]</span>
<span class="gi">+                            return handler(mouse_event)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, don&#39;t handle here.</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    def is_modal(self) -&gt; bool:</span>
<span class="gi">+        return self.modal</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="gi">+        return self.key_bindings</span>


<span class="w"> </span>class DummyControl(UIControl):
<span class="gu">@@ -245,6 +473,15 @@ class DummyControl(UIControl):</span>
<span class="w"> </span>    define the filling.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent(get_line=get_line, line_count=100**100)  # Something very big.</span>
<span class="gi">+</span>
<span class="gi">+    def is_focusable(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>

<span class="w"> </span>class _ProcessedLine(NamedTuple):
<span class="w"> </span>    fragments: StyleAndTextTuples
<span class="gu">@@ -272,50 +509,92 @@ class BufferControl(UIControl):</span>
<span class="w"> </span>    :param key_bindings: a :class:`.KeyBindings` object.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, buffer: (Buffer | None)=None, input_processors: (</span>
<span class="gd">-        list[Processor] | None)=None, include_default_input_processors:</span>
<span class="gd">-        bool=True, lexer: (Lexer | None)=None, preview_search: FilterOrBool</span>
<span class="gd">-        =False, focusable: FilterOrBool=True, search_buffer_control: (None |</span>
<span class="gd">-        SearchBufferControl | Callable[[], SearchBufferControl])=None,</span>
<span class="gd">-        menu_position: (Callable[[], int | None] | None)=None,</span>
<span class="gd">-        focus_on_click: FilterOrBool=False, key_bindings: (KeyBindingsBase |</span>
<span class="gd">-        None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        buffer: Buffer | None = None,</span>
<span class="gi">+        input_processors: list[Processor] | None = None,</span>
<span class="gi">+        include_default_input_processors: bool = True,</span>
<span class="gi">+        lexer: Lexer | None = None,</span>
<span class="gi">+        preview_search: FilterOrBool = False,</span>
<span class="gi">+        focusable: FilterOrBool = True,</span>
<span class="gi">+        search_buffer_control: (</span>
<span class="gi">+            None | SearchBufferControl | Callable[[], SearchBufferControl]</span>
<span class="gi">+        ) = None,</span>
<span class="gi">+        menu_position: Callable[[], int | None] | None = None,</span>
<span class="gi">+        focus_on_click: FilterOrBool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.input_processors = input_processors
<span class="gd">-        self.include_default_input_processors = (</span>
<span class="gd">-            include_default_input_processors)</span>
<span class="gd">-        self.default_input_processors = [HighlightSearchProcessor(),</span>
<span class="gi">+        self.include_default_input_processors = include_default_input_processors</span>
<span class="gi">+</span>
<span class="gi">+        self.default_input_processors = [</span>
<span class="gi">+            HighlightSearchProcessor(),</span>
<span class="w"> </span>            HighlightIncrementalSearchProcessor(),
<span class="gd">-            HighlightSelectionProcessor(), DisplayMultipleCursors()]</span>
<span class="gi">+            HighlightSelectionProcessor(),</span>
<span class="gi">+            DisplayMultipleCursors(),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="w"> </span>        self.preview_search = to_filter(preview_search)
<span class="w"> </span>        self.focusable = to_filter(focusable)
<span class="w"> </span>        self.focus_on_click = to_filter(focus_on_click)
<span class="gi">+</span>
<span class="w"> </span>        self.buffer = buffer or Buffer()
<span class="w"> </span>        self.menu_position = menu_position
<span class="w"> </span>        self.lexer = lexer or SimpleLexer()
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self._search_buffer_control = search_buffer_control
<span class="gd">-        self._fragment_cache: SimpleCache[Hashable, Callable[[int],</span>
<span class="gd">-            StyleAndTextTuples]] = SimpleCache(maxsize=8)</span>
<span class="gi">+</span>
<span class="gi">+        #: Cache for the lexer.</span>
<span class="gi">+        #: Often, due to cursor movement, undo/redo and window resizing</span>
<span class="gi">+        #: operations, it happens that a short time, the same document has to be</span>
<span class="gi">+        #: lexed. This is a fairly easy way to cache such an expensive operation.</span>
<span class="gi">+        self._fragment_cache: SimpleCache[</span>
<span class="gi">+            Hashable, Callable[[int], StyleAndTextTuples]</span>
<span class="gi">+        ] = SimpleCache(maxsize=8)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._last_click_timestamp: float | None = None
<span class="gd">-        self._last_get_processed_line: Callable[[int], _ProcessedLine</span>
<span class="gd">-            ] | None = None</span>
<span class="gi">+        self._last_get_processed_line: Callable[[int], _ProcessedLine] | None = None</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;{self.__class__.__name__} buffer={self.buffer!r} at {id(self)!r}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__} buffer={self.buffer!r} at {id(self)!r}&gt;&quot;</span>

<span class="w"> </span>    @property
<span class="gd">-    def search_state(self) -&gt;SearchState:</span>
<span class="gi">+    def search_buffer_control(self) -&gt; SearchBufferControl | None:</span>
<span class="gi">+        result: SearchBufferControl | None</span>
<span class="gi">+</span>
<span class="gi">+        if callable(self._search_buffer_control):</span>
<span class="gi">+            result = self._search_buffer_control()</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = self._search_buffer_control</span>
<span class="gi">+</span>
<span class="gi">+        assert result is None or isinstance(result, SearchBufferControl)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def search_buffer(self) -&gt; Buffer | None:</span>
<span class="gi">+        control = self.search_buffer_control</span>
<span class="gi">+        if control is not None:</span>
<span class="gi">+            return control.buffer</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def search_state(self) -&gt; SearchState:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `SearchState` for searching this `BufferControl`. This is
<span class="w"> </span>        always associated with the search control. If one search bar is used
<span class="w"> </span>        for searching multiple `BufferControls`, then they share the same
<span class="w"> </span>        `SearchState`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        search_buffer_control = self.search_buffer_control</span>
<span class="gi">+        if search_buffer_control:</span>
<span class="gi">+            return search_buffer_control.searcher_search_state</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SearchState()</span>
<span class="gi">+</span>
<span class="gi">+    def is_focusable(self) -&gt; bool:</span>
<span class="gi">+        return self.focusable()</span>

<span class="gd">-    def preferred_width(self, max_available_width: int) -&gt;(int | None):</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This should return the preferred width.

<span class="gu">@@ -326,48 +605,313 @@ class BufferControl(UIControl):</span>
<span class="w"> </span>              unfeasible for a larger document, and doing it for small
<span class="w"> </span>              documents only would result in inconsistent behavior.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        max_available_height: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="gi">+        # Calculate the content height, if it was drawn on a screen with the</span>
<span class="gi">+        # given width.</span>
<span class="gi">+        height = 0</span>
<span class="gi">+        content = self.create_content(width, height=1)  # Pass a dummy &#39;1&#39; as height.</span>
<span class="gi">+</span>
<span class="gi">+        # When line wrapping is off, the height should be equal to the amount</span>
<span class="gi">+        # of lines.</span>
<span class="gi">+        if not wrap_lines:</span>
<span class="gi">+            return content.line_count</span>

<span class="gd">-    def _get_formatted_text_for_line_func(self, document: Document) -&gt;Callable[</span>
<span class="gd">-        [int], StyleAndTextTuples]:</span>
<span class="gi">+        # When the number of lines exceeds the max_available_height, just</span>
<span class="gi">+        # return max_available_height. No need to calculate anything.</span>
<span class="gi">+        if content.line_count &gt;= max_available_height:</span>
<span class="gi">+            return max_available_height</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(content.line_count):</span>
<span class="gi">+            height += content.get_height_for_line(i, width, get_line_prefix)</span>
<span class="gi">+</span>
<span class="gi">+            if height &gt;= max_available_height:</span>
<span class="gi">+                return max_available_height</span>
<span class="gi">+</span>
<span class="gi">+        return height</span>
<span class="gi">+</span>
<span class="gi">+    def _get_formatted_text_for_line_func(</span>
<span class="gi">+        self, document: Document</span>
<span class="gi">+    ) -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a function that returns the fragments for a given line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _create_get_processed_line_func(self, document: Document, width:</span>
<span class="gd">-        int, height: int) -&gt;Callable[[int], _ProcessedLine]:</span>
<span class="gi">+        # Cache using `document.text`.</span>
<span class="gi">+        def get_formatted_text_for_line() -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="gi">+            return self.lexer.lex_document(document)</span>
<span class="gi">+</span>
<span class="gi">+        key = (document.text, self.lexer.invalidation_hash())</span>
<span class="gi">+        return self._fragment_cache.get(key, get_formatted_text_for_line)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_get_processed_line_func(</span>
<span class="gi">+        self, document: Document, width: int, height: int</span>
<span class="gi">+    ) -&gt; Callable[[int], _ProcessedLine]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a function that takes a line number of the current document and
<span class="w"> </span>        returns a _ProcessedLine(processed_fragments, source_to_display, display_to_source)
<span class="w"> </span>        tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Merge all input processors together.</span>
<span class="gi">+        input_processors = self.input_processors or []</span>
<span class="gi">+        if self.include_default_input_processors:</span>
<span class="gi">+            input_processors = self.default_input_processors + input_processors</span>
<span class="gi">+</span>
<span class="gi">+        merged_processor = merge_processors(input_processors)</span>
<span class="gi">+</span>
<span class="gi">+        def transform(lineno: int, fragments: StyleAndTextTuples) -&gt; _ProcessedLine:</span>
<span class="gi">+            &quot;Transform the fragments for a given line number.&quot;</span>

<span class="gd">-    def create_content(self, width: int, height: int, preview_search: bool=</span>
<span class="gd">-        False) -&gt;UIContent:</span>
<span class="gi">+            # Get cursor position at this line.</span>
<span class="gi">+            def source_to_display(i: int) -&gt; int:</span>
<span class="gi">+                &quot;&quot;&quot;X position from the buffer to the x position in the</span>
<span class="gi">+                processed fragment list. By default, we start from the &#39;identity&#39;</span>
<span class="gi">+                operation.&quot;&quot;&quot;</span>
<span class="gi">+                return i</span>
<span class="gi">+</span>
<span class="gi">+            transformation = merged_processor.apply_transformation(</span>
<span class="gi">+                TransformationInput(</span>
<span class="gi">+                    self, document, lineno, source_to_display, fragments, width, height</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            return _ProcessedLine(</span>
<span class="gi">+                transformation.fragments,</span>
<span class="gi">+                transformation.source_to_display,</span>
<span class="gi">+                transformation.display_to_source,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        def create_func() -&gt; Callable[[int], _ProcessedLine]:</span>
<span class="gi">+            get_line = self._get_formatted_text_for_line_func(document)</span>
<span class="gi">+            cache: dict[int, _ProcessedLine] = {}</span>
<span class="gi">+</span>
<span class="gi">+            def get_processed_line(i: int) -&gt; _ProcessedLine:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return cache[i]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    processed_line = transform(i, get_line(i))</span>
<span class="gi">+                    cache[i] = processed_line</span>
<span class="gi">+                    return processed_line</span>
<span class="gi">+</span>
<span class="gi">+            return get_processed_line</span>
<span class="gi">+</span>
<span class="gi">+        return create_func()</span>
<span class="gi">+</span>
<span class="gi">+    def create_content(</span>
<span class="gi">+        self, width: int, height: int, preview_search: bool = False</span>
<span class="gi">+    ) -&gt; UIContent:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a UIContent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+        buffer = self.buffer</span>
<span class="gi">+</span>
<span class="gi">+        # Trigger history loading of the buffer. We do this during the</span>
<span class="gi">+        # rendering of the UI here, because it needs to happen when an</span>
<span class="gi">+        # `Application` with its event loop is running. During the rendering of</span>
<span class="gi">+        # the buffer control is the earliest place we can achieve this, where</span>
<span class="gi">+        # we&#39;re sure the right event loop is active, and don&#39;t require user</span>
<span class="gi">+        # interaction (like in a key binding).</span>
<span class="gi">+        buffer.load_history_if_not_yet_loaded()</span>
<span class="gi">+</span>
<span class="gi">+        # Get the document to be shown. If we are currently searching (the</span>
<span class="gi">+        # search buffer has focus, and the preview_search filter is enabled),</span>
<span class="gi">+        # then use the search document, which has possibly a different</span>
<span class="gi">+        # text/cursor position.)</span>
<span class="gi">+        search_control = self.search_buffer_control</span>
<span class="gi">+        preview_now = preview_search or bool(</span>
<span class="gi">+            # Only if this feature is enabled.</span>
<span class="gi">+            self.preview_search()</span>
<span class="gi">+            and</span>
<span class="gi">+            # And something was typed in the associated search field.</span>
<span class="gi">+            search_control</span>
<span class="gi">+            and search_control.buffer.text</span>
<span class="gi">+            and</span>
<span class="gi">+            # And we are searching in this control. (Many controls can point to</span>
<span class="gi">+            # the same search field, like in Pyvim.)</span>
<span class="gi">+            get_app().layout.search_target_buffer_control == self</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if preview_now and search_control is not None:</span>
<span class="gi">+            ss = self.search_state</span>
<span class="gi">+</span>
<span class="gi">+            document = buffer.document_for_search(</span>
<span class="gi">+                SearchState(</span>
<span class="gi">+                    text=search_control.buffer.text,</span>
<span class="gi">+                    direction=ss.direction,</span>
<span class="gi">+                    ignore_case=ss.ignore_case,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            document = buffer.document</span>
<span class="gi">+</span>
<span class="gi">+        get_processed_line = self._create_get_processed_line_func(</span>
<span class="gi">+            document, width, height</span>
<span class="gi">+        )</span>
<span class="gi">+        self._last_get_processed_line = get_processed_line</span>
<span class="gi">+</span>
<span class="gi">+        def translate_rowcol(row: int, col: int) -&gt; Point:</span>
<span class="gi">+            &quot;Return the content column for this coordinate.&quot;</span>
<span class="gi">+            return Point(x=get_processed_line(row).source_to_display(col), y=row)</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            &quot;Return the fragments for a given line number.&quot;</span>
<span class="gi">+            fragments = get_processed_line(i).fragments</span>
<span class="gi">+</span>
<span class="gi">+            # Add a space at the end, because that is a possible cursor</span>
<span class="gi">+            # position. (When inserting after the input.) We should do this on</span>
<span class="gi">+            # all the lines, not just the line containing the cursor. (Because</span>
<span class="gi">+            # otherwise, line wrapping/scrolling could change when moving the</span>
<span class="gi">+            # cursor around.)</span>
<span class="gi">+            fragments = fragments + [(&quot;&quot;, &quot; &quot;)]</span>
<span class="gi">+            return fragments</span>
<span class="gi">+</span>
<span class="gi">+        content = UIContent(</span>
<span class="gi">+            get_line=get_line,</span>
<span class="gi">+            line_count=document.line_count,</span>
<span class="gi">+            cursor_position=translate_rowcol(</span>
<span class="gi">+                document.cursor_position_row, document.cursor_position_col</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # If there is an auto completion going on, use that start point for a</span>
<span class="gi">+        # pop-up menu position. (But only when this buffer has the focus --</span>
<span class="gi">+        # there is only one place for a menu, determined by the focused buffer.)</span>
<span class="gi">+        if get_app().layout.current_control == self:</span>
<span class="gi">+            menu_position = self.menu_position() if self.menu_position else None</span>
<span class="gi">+            if menu_position is not None:</span>
<span class="gi">+                assert isinstance(menu_position, int)</span>
<span class="gi">+                menu_row, menu_col = buffer.document.translate_index_to_position(</span>
<span class="gi">+                    menu_position</span>
<span class="gi">+                )</span>
<span class="gi">+                content.menu_position = translate_rowcol(menu_row, menu_col)</span>
<span class="gi">+            elif buffer.complete_state:</span>
<span class="gi">+                # Position for completion menu.</span>
<span class="gi">+                # Note: We use &#39;min&#39;, because the original cursor position could be</span>
<span class="gi">+                #       behind the input string when the actual completion is for</span>
<span class="gi">+                #       some reason shorter than the text we had before. (A completion</span>
<span class="gi">+                #       can change and shorten the input.)</span>
<span class="gi">+                menu_row, menu_col = buffer.document.translate_index_to_position(</span>
<span class="gi">+                    min(</span>
<span class="gi">+                        buffer.cursor_position,</span>
<span class="gi">+                        buffer.complete_state.original_document.cursor_position,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                content.menu_position = translate_rowcol(menu_row, menu_col)</span>
<span class="gi">+            else:</span>
<span class="gi">+                content.menu_position = None</span>
<span class="gi">+</span>
<span class="gi">+        return content</span>
<span class="gi">+</span>
<span class="gi">+    def mouse_handler(self, mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mouse handler for this control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buffer = self.buffer</span>
<span class="gi">+        position = mouse_event.position</span>
<span class="gi">+</span>
<span class="gi">+        # Focus buffer when clicked.</span>
<span class="gi">+        if get_app().layout.current_control == self:</span>
<span class="gi">+            if self._last_get_processed_line:</span>
<span class="gi">+                processed_line = self._last_get_processed_line(position.y)</span>
<span class="gi">+</span>
<span class="gi">+                # Translate coordinates back to the cursor position of the</span>
<span class="gi">+                # original input.</span>
<span class="gi">+                xpos = processed_line.display_to_source(position.x)</span>
<span class="gi">+                index = buffer.document.translate_row_col_to_index(position.y, xpos)</span>
<span class="gi">+</span>
<span class="gi">+                # Set the cursor position.</span>
<span class="gi">+                if mouse_event.event_type == MouseEventType.MOUSE_DOWN:</span>
<span class="gi">+                    buffer.exit_selection()</span>
<span class="gi">+                    buffer.cursor_position = index</span>
<span class="gi">+</span>
<span class="gi">+                elif (</span>
<span class="gi">+                    mouse_event.event_type == MouseEventType.MOUSE_MOVE</span>
<span class="gi">+                    and mouse_event.button != MouseButton.NONE</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Click and drag to highlight a selection</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        buffer.selection_state is None</span>
<span class="gi">+                        and abs(buffer.cursor_position - index) &gt; 0</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        buffer.start_selection(selection_type=SelectionType.CHARACTERS)</span>
<span class="gi">+                    buffer.cursor_position = index</span>
<span class="gi">+</span>
<span class="gi">+                elif mouse_event.event_type == MouseEventType.MOUSE_UP:</span>
<span class="gi">+                    # When the cursor was moved to another place, select the text.</span>
<span class="gi">+                    # (The &gt;1 is actually a small but acceptable workaround for</span>
<span class="gi">+                    # selecting text in Vi navigation mode. In navigation mode,</span>
<span class="gi">+                    # the cursor can never be after the text, so the cursor</span>
<span class="gi">+                    # will be repositioned automatically.)</span>
<span class="gi">+                    if abs(buffer.cursor_position - index) &gt; 1:</span>
<span class="gi">+                        if buffer.selection_state is None:</span>
<span class="gi">+                            buffer.start_selection(</span>
<span class="gi">+                                selection_type=SelectionType.CHARACTERS</span>
<span class="gi">+                            )</span>
<span class="gi">+                        buffer.cursor_position = index</span>
<span class="gi">+</span>
<span class="gi">+                    # Select word around cursor on double click.</span>
<span class="gi">+                    # Two MOUSE_UP events in a short timespan are considered a double click.</span>
<span class="gi">+                    double_click = (</span>
<span class="gi">+                        self._last_click_timestamp</span>
<span class="gi">+                        and time.time() - self._last_click_timestamp &lt; 0.3</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self._last_click_timestamp = time.time()</span>
<span class="gi">+</span>
<span class="gi">+                    if double_click:</span>
<span class="gi">+                        start, end = buffer.document.find_boundaries_of_current_word()</span>
<span class="gi">+                        buffer.cursor_position += start</span>
<span class="gi">+                        buffer.start_selection(selection_type=SelectionType.CHARACTERS)</span>
<span class="gi">+                        buffer.cursor_position += end - start</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Don&#39;t handle scroll events here.</span>
<span class="gi">+                    return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        # Not focused, but focusing on click events.</span>
<span class="gi">+        else:</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.focus_on_click()</span>
<span class="gi">+                and mouse_event.event_type == MouseEventType.MOUSE_UP</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Focus happens on mouseup. (If we did this on mousedown, the</span>
<span class="gi">+                # up event will be received at the point where this widget is</span>
<span class="gi">+                # focused and be handled anyway.)</span>
<span class="gi">+                get_app().layout.current_control = self</span>
<span class="gi">+            else:</span>
<span class="gi">+                return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_key_bindings(self) -&gt;(KeyBindingsBase | None):</span>
<span class="gi">+    def move_cursor_down(self) -&gt; None:</span>
<span class="gi">+        b = self.buffer</span>
<span class="gi">+        b.cursor_position += b.document.get_cursor_down_position()</span>
<span class="gi">+</span>
<span class="gi">+    def move_cursor_up(self) -&gt; None:</span>
<span class="gi">+        b = self.buffer</span>
<span class="gi">+        b.cursor_position += b.document.get_cursor_up_position()</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When additional key bindings are given. Return these.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.key_bindings</span>

<span class="gd">-    def get_invalidate_events(self) -&gt;Iterable[Event[object]]:</span>
<span class="gi">+    def get_invalidate_events(self) -&gt; Iterable[Event[object]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the Window invalidate events.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Whenever the buffer changes, the UI has to be updated.</span>
<span class="gi">+        yield self.buffer.on_text_changed</span>
<span class="gi">+        yield self.buffer.on_cursor_position_changed</span>
<span class="gi">+</span>
<span class="gi">+        yield self.buffer.on_completions_changed</span>
<span class="gi">+        yield self.buffer.on_suggestion_set</span>


<span class="w"> </span>class SearchBufferControl(BufferControl):
<span class="gu">@@ -378,11 +922,23 @@ class SearchBufferControl(BufferControl):</span>
<span class="w"> </span>    :param ignore_case: Search case insensitive.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, buffer: (Buffer | None)=None, input_processors: (</span>
<span class="gd">-        list[Processor] | None)=None, lexer: (Lexer | None)=None,</span>
<span class="gd">-        focus_on_click: FilterOrBool=False, key_bindings: (KeyBindingsBase |</span>
<span class="gd">-        None)=None, ignore_case: FilterOrBool=False):</span>
<span class="gd">-        super().__init__(buffer=buffer, input_processors=input_processors,</span>
<span class="gd">-            lexer=lexer, focus_on_click=focus_on_click, key_bindings=</span>
<span class="gd">-            key_bindings)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        buffer: Buffer | None = None,</span>
<span class="gi">+        input_processors: list[Processor] | None = None,</span>
<span class="gi">+        lexer: Lexer | None = None,</span>
<span class="gi">+        focus_on_click: FilterOrBool = False,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        ignore_case: FilterOrBool = False,</span>
<span class="gi">+    ):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            buffer=buffer,</span>
<span class="gi">+            input_processors=input_processors,</span>
<span class="gi">+            lexer=lexer,</span>
<span class="gi">+            focus_on_click=focus_on_click,</span>
<span class="gi">+            key_bindings=key_bindings,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # If this BufferControl is used as a search field for one or more other</span>
<span class="gi">+        # BufferControls, then represents the search state.</span>
<span class="w"> </span>        self.searcher_search_state = SearchState(ignore_case=ignore_case)
<span class="gh">diff --git a/src/prompt_toolkit/layout/dimension.py b/src/prompt_toolkit/layout/dimension.py</span>
<span class="gh">index 27439360..c1f05f94 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/dimension.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/dimension.py</span>
<span class="gu">@@ -3,9 +3,19 @@ Layout dimensions are used to give the minimum, maximum and preferred</span>
<span class="w"> </span>dimensions for containers and controls.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Union
<span class="gd">-__all__ = [&#39;Dimension&#39;, &#39;D&#39;, &#39;sum_layout_dimensions&#39;,</span>
<span class="gd">-    &#39;max_layout_dimensions&#39;, &#39;AnyDimension&#39;, &#39;to_dimension&#39;, &#39;is_dimension&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Dimension&quot;,</span>
<span class="gi">+    &quot;D&quot;,</span>
<span class="gi">+    &quot;sum_layout_dimensions&quot;,</span>
<span class="gi">+    &quot;max_layout_dimensions&quot;,</span>
<span class="gi">+    &quot;AnyDimension&quot;,</span>
<span class="gi">+    &quot;to_dimension&quot;,</span>
<span class="gi">+    &quot;is_dimension&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import TypeGuard

<span class="gu">@@ -28,101 +38,182 @@ class Dimension:</span>
<span class="w"> </span>    :param preferred: Preferred size.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, min: (int | None)=None, max: (int | None)=None,</span>
<span class="gd">-        weight: (int | None)=None, preferred: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min: int | None = None,</span>
<span class="gi">+        max: int | None = None,</span>
<span class="gi">+        weight: int | None = None,</span>
<span class="gi">+        preferred: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if weight is not None:
<span class="gd">-            assert weight &gt;= 0</span>
<span class="gi">+            assert weight &gt;= 0  # Also cannot be a float.</span>
<span class="gi">+</span>
<span class="w"> </span>        assert min is None or min &gt;= 0
<span class="w"> </span>        assert max is None or max &gt;= 0
<span class="w"> </span>        assert preferred is None or preferred &gt;= 0
<span class="gi">+</span>
<span class="w"> </span>        self.min_specified = min is not None
<span class="w"> </span>        self.max_specified = max is not None
<span class="w"> </span>        self.preferred_specified = preferred is not None
<span class="w"> </span>        self.weight_specified = weight is not None
<span class="gi">+</span>
<span class="w"> </span>        if min is None:
<span class="gd">-            min = 0</span>
<span class="gd">-        if max is None:</span>
<span class="gd">-            max = 1000 ** 10</span>
<span class="gi">+            min = 0  # Smallest possible value.</span>
<span class="gi">+        if max is None:  # 0-values are allowed, so use &quot;is None&quot;</span>
<span class="gi">+            max = 1000**10  # Something huge.</span>
<span class="w"> </span>        if preferred is None:
<span class="w"> </span>            preferred = min
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            weight = 1
<span class="gi">+</span>
<span class="w"> </span>        self.min = min
<span class="w"> </span>        self.max = max
<span class="w"> </span>        self.preferred = preferred
<span class="w"> </span>        self.weight = weight
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t allow situations where max &lt; min. (This would be a bug.)</span>
<span class="w"> </span>        if max &lt; min:
<span class="gd">-            raise ValueError(&#39;Invalid Dimension: max &lt; min.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Invalid Dimension: max &lt; min.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure that the &#39;preferred&#39; size is always in the min..max range.</span>
<span class="w"> </span>        if self.preferred &lt; self.min:
<span class="w"> </span>            self.preferred = self.min
<span class="gi">+</span>
<span class="w"> </span>        if self.preferred &gt; self.max:
<span class="w"> </span>            self.preferred = self.max

<span class="w"> </span>    @classmethod
<span class="gd">-    def exact(cls, amount: int) -&gt;Dimension:</span>
<span class="gi">+    def exact(cls, amount: int) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a :class:`.Dimension` with an exact size. (min, max and
<span class="w"> </span>        preferred set to ``amount``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(min=amount, max=amount, preferred=amount)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def zero(cls) -&gt;Dimension:</span>
<span class="gi">+    def zero(cls) -&gt; Dimension:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a dimension that represents a zero size. (Used for &#39;invisible&#39;
<span class="w"> </span>        controls.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls.exact(amount=0)</span>

<span class="gd">-    def is_zero(self) -&gt;bool:</span>
<span class="gd">-        &quot;&quot;&quot;True if this `Dimension` represents a zero size.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def is_zero(self) -&gt; bool:</span>
<span class="gi">+        &quot;True if this `Dimension` represents a zero size.&quot;</span>
<span class="gi">+        return self.preferred == 0 or self.max == 0</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        fields = []
<span class="w"> </span>        if self.min_specified:
<span class="gd">-            fields.append(&#39;min=%r&#39; % self.min)</span>
<span class="gi">+            fields.append(&quot;min=%r&quot; % self.min)</span>
<span class="w"> </span>        if self.max_specified:
<span class="gd">-            fields.append(&#39;max=%r&#39; % self.max)</span>
<span class="gi">+            fields.append(&quot;max=%r&quot; % self.max)</span>
<span class="w"> </span>        if self.preferred_specified:
<span class="gd">-            fields.append(&#39;preferred=%r&#39; % self.preferred)</span>
<span class="gi">+            fields.append(&quot;preferred=%r&quot; % self.preferred)</span>
<span class="w"> </span>        if self.weight_specified:
<span class="gd">-            fields.append(&#39;weight=%r&#39; % self.weight)</span>
<span class="gd">-        return &#39;Dimension(%s)&#39; % &#39;, &#39;.join(fields)</span>
<span class="gi">+            fields.append(&quot;weight=%r&quot; % self.weight)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;Dimension(%s)&quot; % &quot;, &quot;.join(fields)</span>


<span class="gd">-def sum_layout_dimensions(dimensions: list[Dimension]) -&gt;Dimension:</span>
<span class="gi">+def sum_layout_dimensions(dimensions: list[Dimension]) -&gt; Dimension:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Sum a list of :class:`.Dimension` instances.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    min = sum(d.min for d in dimensions)</span>
<span class="gi">+    max = sum(d.max for d in dimensions)</span>
<span class="gi">+    preferred = sum(d.preferred for d in dimensions)</span>
<span class="gi">+</span>
<span class="gi">+    return Dimension(min=min, max=max, preferred=preferred)</span>


<span class="gd">-def max_layout_dimensions(dimensions: list[Dimension]) -&gt;Dimension:</span>
<span class="gi">+def max_layout_dimensions(dimensions: list[Dimension]) -&gt; Dimension:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take the maximum of a list of :class:`.Dimension` instances.
<span class="w"> </span>    Used when we have a HSplit/VSplit, and we want to get the best width/height.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-AnyDimension = Union[None, int, Dimension, Callable[[], Any]]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def to_dimension(value: AnyDimension) -&gt;Dimension:</span>
<span class="gi">+    if not len(dimensions):</span>
<span class="gi">+        return Dimension.zero()</span>
<span class="gi">+</span>
<span class="gi">+    # If all dimensions are size zero. Return zero.</span>
<span class="gi">+    # (This is important for HSplit/VSplit, to report the right values to their</span>
<span class="gi">+    # parent when all children are invisible.)</span>
<span class="gi">+    if all(d.is_zero() for d in dimensions):</span>
<span class="gi">+        return dimensions[0]</span>
<span class="gi">+</span>
<span class="gi">+    # Ignore empty dimensions. (They should not reduce the size of others.)</span>
<span class="gi">+    dimensions = [d for d in dimensions if not d.is_zero()]</span>
<span class="gi">+</span>
<span class="gi">+    if dimensions:</span>
<span class="gi">+        # Take the highest minimum dimension.</span>
<span class="gi">+        min_ = max(d.min for d in dimensions)</span>
<span class="gi">+</span>
<span class="gi">+        # For the maximum, we would prefer not to go larger than then smallest</span>
<span class="gi">+        # &#39;max&#39; value, unless other dimensions have a bigger preferred value.</span>
<span class="gi">+        # This seems to work best:</span>
<span class="gi">+        #  - We don&#39;t want that a widget with a small height in a VSplit would</span>
<span class="gi">+        #    shrink other widgets in the split.</span>
<span class="gi">+        # If it doesn&#39;t work well enough, then it&#39;s up to the UI designer to</span>
<span class="gi">+        # explicitly pass dimensions.</span>
<span class="gi">+        max_ = min(d.max for d in dimensions)</span>
<span class="gi">+        max_ = max(max_, max(d.preferred for d in dimensions))</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure that min&gt;=max. In some scenarios, when certain min..max</span>
<span class="gi">+        # ranges don&#39;t have any overlap, we can end up in such an impossible</span>
<span class="gi">+        # situation. In that case, give priority to the max value.</span>
<span class="gi">+        # E.g. taking (1..5) and (8..9) would return (8..5). Instead take (8..8).</span>
<span class="gi">+        if min_ &gt; max_:</span>
<span class="gi">+            max_ = min_</span>
<span class="gi">+</span>
<span class="gi">+        preferred = max(d.preferred for d in dimensions)</span>
<span class="gi">+</span>
<span class="gi">+        return Dimension(min=min_, max=max_, preferred=preferred)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return Dimension()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Anything that can be converted to a dimension.</span>
<span class="gi">+AnyDimension = Union[</span>
<span class="gi">+    None,  # None is a valid dimension that will fit anything.</span>
<span class="gi">+    int,</span>
<span class="gi">+    Dimension,</span>
<span class="gi">+    # Callable[[], &#39;AnyDimension&#39;]  # Recursive definition not supported by mypy.</span>
<span class="gi">+    Callable[[], Any],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_dimension(value: AnyDimension) -&gt; Dimension:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn the given object into a `Dimension` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return Dimension()</span>
<span class="gi">+    if isinstance(value, int):</span>
<span class="gi">+        return Dimension.exact(value)</span>
<span class="gi">+    if isinstance(value, Dimension):</span>
<span class="gi">+        return value</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return to_dimension(value())</span>

<span class="gi">+    raise ValueError(&quot;Not an integer or Dimension object.&quot;)</span>

<span class="gd">-def is_dimension(value: object) -&gt;TypeGuard[AnyDimension]:</span>
<span class="gi">+</span>
<span class="gi">+def is_dimension(value: object) -&gt; TypeGuard[AnyDimension]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Test whether the given value could be a valid dimension.
<span class="w"> </span>    (For usage in an assertion. It&#39;s not guaranteed in case of a callable.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return True  # Assume it&#39;s a callable that doesn&#39;t take arguments.</span>
<span class="gi">+    if isinstance(value, (int, Dimension)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="gi">+# Common alias.</span>
<span class="w"> </span>D = Dimension
<span class="gi">+</span>
<span class="gi">+# For backward-compatibility.</span>
<span class="w"> </span>LayoutDimension = Dimension
<span class="gh">diff --git a/src/prompt_toolkit/layout/dummy.py b/src/prompt_toolkit/layout/dummy.py</span>
<span class="gh">index 5c47d1f0..139f3115 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/dummy.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/dummy.py</span>
<span class="gu">@@ -3,20 +3,37 @@ Dummy layout. Used when somebody creates an `Application` without specifying a</span>
<span class="w"> </span>`Layout`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.formatted_text import HTML
<span class="w"> </span>from prompt_toolkit.key_binding import KeyBindings
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="gi">+</span>
<span class="w"> </span>from .containers import Window
<span class="w"> </span>from .controls import FormattedTextControl
<span class="w"> </span>from .dimension import D
<span class="w"> </span>from .layout import Layout
<span class="gd">-__all__ = [&#39;create_dummy_layout&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;create_dummy_layout&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def create_dummy_layout() -&gt;Layout:</span>
<span class="gi">+def create_dummy_layout() -&gt; Layout:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a dummy layout for use in an &#39;Application&#39; that doesn&#39;t have a
<span class="w"> </span>    layout specified. When ENTER is pressed, the application quits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&quot;enter&quot;)</span>
<span class="gi">+    def enter(event: E) -&gt; None:</span>
<span class="gi">+        event.app.exit()</span>
<span class="gi">+</span>
<span class="gi">+    control = FormattedTextControl(</span>
<span class="gi">+        HTML(&quot;No layout specified. Press &lt;reverse&gt;ENTER&lt;/reverse&gt; to quit.&quot;),</span>
<span class="gi">+        key_bindings=kb,</span>
<span class="gi">+    )</span>
<span class="gi">+    window = Window(content=control, height=D(min=1))</span>
<span class="gi">+    return Layout(container=window, focused_element=window)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/layout.py b/src/prompt_toolkit/layout/layout.py</span>
<span class="gh">index e6a57ed0..a5e7a80e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/layout.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/layout.py</span>
<span class="gu">@@ -2,11 +2,26 @@</span>
<span class="w"> </span>Wrapper for the layout.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Generator, Iterable, Union
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.buffer import Buffer
<span class="gd">-from .containers import AnyContainer, ConditionalContainer, Container, Window, to_container</span>
<span class="gi">+</span>
<span class="gi">+from .containers import (</span>
<span class="gi">+    AnyContainer,</span>
<span class="gi">+    ConditionalContainer,</span>
<span class="gi">+    Container,</span>
<span class="gi">+    Window,</span>
<span class="gi">+    to_container,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .controls import BufferControl, SearchBufferControl, UIControl
<span class="gd">-__all__ = [&#39;Layout&#39;, &#39;InvalidLayoutError&#39;, &#39;walk&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Layout&quot;,</span>
<span class="gi">+    &quot;InvalidLayoutError&quot;,</span>
<span class="gi">+    &quot;walk&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>FocusableElement = Union[str, Buffer, UIControl, AnyContainer]


<span class="gu">@@ -21,35 +36,56 @@ class Layout:</span>
<span class="w"> </span>        the `focus` function accepts.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, container: AnyContainer, focused_element: (</span>
<span class="gd">-        FocusableElement | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        container: AnyContainer,</span>
<span class="gi">+        focused_element: FocusableElement | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.container = to_container(container)
<span class="w"> </span>        self._stack: list[Window] = []
<span class="gi">+</span>
<span class="gi">+        # Map search BufferControl back to the original BufferControl.</span>
<span class="gi">+        # This is used to keep track of when exactly we are searching, and for</span>
<span class="gi">+        # applying the search.</span>
<span class="gi">+        # When a link exists in this dictionary, that means the search is</span>
<span class="gi">+        # currently active.</span>
<span class="gi">+        # Map: search_buffer_control -&gt; original buffer control.</span>
<span class="w"> </span>        self.search_links: dict[SearchBufferControl, BufferControl] = {}
<span class="gi">+</span>
<span class="gi">+        # Mapping that maps the children in the layout to their parent.</span>
<span class="gi">+        # This relationship is calculated dynamically, each time when the UI</span>
<span class="gi">+        # is rendered.  (UI elements have only references to their children.)</span>
<span class="w"> </span>        self._child_to_parent: dict[Container, Container] = {}
<span class="gi">+</span>
<span class="w"> </span>        if focused_element is None:
<span class="w"> </span>            try:
<span class="w"> </span>                self._stack.append(next(self.find_all_windows()))
<span class="w"> </span>            except StopIteration as e:
<span class="w"> </span>                raise InvalidLayoutError(
<span class="gd">-                    &#39;Invalid layout. The layout does not contain any Window object.&#39;</span>
<span class="gd">-                    ) from e</span>
<span class="gi">+                    &quot;Invalid layout. The layout does not contain any Window object.&quot;</span>
<span class="gi">+                ) from e</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.focus(focused_element)
<span class="gd">-        self.visible_windows: list[Window] = []</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;Layout({self.container!r}, current_window={self.current_window!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        # List of visible windows.</span>
<span class="gi">+        self.visible_windows: list[Window] = []  # List of `Window` objects.</span>

<span class="gd">-    def find_all_windows(self) -&gt;Generator[Window, None, None]:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;Layout({self.container!r}, current_window={self.current_window!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def find_all_windows(self) -&gt; Generator[Window, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find all the :class:`.UIControl` objects in this layout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in self.walk():</span>
<span class="gi">+            if isinstance(item, Window):</span>
<span class="gi">+                yield item</span>
<span class="gi">+</span>
<span class="gi">+    def find_all_controls(self) -&gt; Iterable[UIControl]:</span>
<span class="gi">+        for container in self.find_all_windows():</span>
<span class="gi">+            yield container.content</span>

<span class="gd">-    def focus(self, value: FocusableElement) -&gt;None:</span>
<span class="gi">+    def focus(self, value: FocusableElement) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Focus the given UI element.

<span class="gu">@@ -62,145 +98,314 @@ class Layout:</span>
<span class="w"> </span>          from this container that was focused most recent, or the very first
<span class="w"> </span>          focusable :class:`.Window` of the container.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def has_focus(self, value: FocusableElement) -&gt;bool:</span>
<span class="gi">+        # BufferControl by buffer name.</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            for control in self.find_all_controls():</span>
<span class="gi">+                if isinstance(control, BufferControl) and control.buffer.name == value:</span>
<span class="gi">+                    self.focus(control)</span>
<span class="gi">+                    return</span>
<span class="gi">+            raise ValueError(f&quot;Couldn&#39;t find Buffer in the current layout: {value!r}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # BufferControl by buffer object.</span>
<span class="gi">+        elif isinstance(value, Buffer):</span>
<span class="gi">+            for control in self.find_all_controls():</span>
<span class="gi">+                if isinstance(control, BufferControl) and control.buffer == value:</span>
<span class="gi">+                    self.focus(control)</span>
<span class="gi">+                    return</span>
<span class="gi">+            raise ValueError(f&quot;Couldn&#39;t find Buffer in the current layout: {value!r}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Focus UIControl.</span>
<span class="gi">+        elif isinstance(value, UIControl):</span>
<span class="gi">+            if value not in self.find_all_controls():</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Invalid value. Container does not appear in the layout.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if not value.is_focusable():</span>
<span class="gi">+                raise ValueError(&quot;Invalid value. UIControl is not focusable.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self.current_control = value</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, expecting any Container object.</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = to_container(value)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(value, Window):</span>
<span class="gi">+                # This is a `Window`: focus that.</span>
<span class="gi">+                if value not in self.find_all_windows():</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        f&quot;Invalid value. Window does not appear in the layout: {value!r}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                self.current_window = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Focus a window in this container.</span>
<span class="gi">+                # If we have many windows as part of this container, and some</span>
<span class="gi">+                # of them have been focused before, take the last focused</span>
<span class="gi">+                # item. (This is very useful when the UI is composed of more</span>
<span class="gi">+                # complex sub components.)</span>
<span class="gi">+                windows = []</span>
<span class="gi">+                for c in walk(value, skip_hidden=True):</span>
<span class="gi">+                    if isinstance(c, Window) and c.content.is_focusable():</span>
<span class="gi">+                        windows.append(c)</span>
<span class="gi">+</span>
<span class="gi">+                # Take the first one that was focused before.</span>
<span class="gi">+                for w in reversed(self._stack):</span>
<span class="gi">+                    if w in windows:</span>
<span class="gi">+                        self.current_window = w</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                # None was focused before: take the very first focusable window.</span>
<span class="gi">+                if windows:</span>
<span class="gi">+                    self.current_window = windows[0]</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;Invalid value. Container cannot be focused: {value!r}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def has_focus(self, value: FocusableElement) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Check whether the given control has the focus.
<span class="w"> </span>        :param value: :class:`.UIControl` or :class:`.Window` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            if self.current_buffer is None:</span>
<span class="gi">+                return False</span>
<span class="gi">+            return self.current_buffer.name == value</span>
<span class="gi">+        if isinstance(value, Buffer):</span>
<span class="gi">+            return self.current_buffer == value</span>
<span class="gi">+        if isinstance(value, UIControl):</span>
<span class="gi">+            return self.current_control == value</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = to_container(value)</span>
<span class="gi">+            if isinstance(value, Window):</span>
<span class="gi">+                return self.current_window == value</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Check whether this &quot;container&quot; is focused. This is true if</span>
<span class="gi">+                # one of the elements inside is focused.</span>
<span class="gi">+                for element in walk(value):</span>
<span class="gi">+                    if element == self.current_window:</span>
<span class="gi">+                        return True</span>
<span class="gi">+                return False</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_control(self) -&gt;UIControl:</span>
<span class="gi">+    def current_control(self) -&gt; UIControl:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the :class:`.UIControl` to currently has the focus.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._stack[-1].content</span>

<span class="w"> </span>    @current_control.setter
<span class="gd">-    def current_control(self, control: UIControl) -&gt;None:</span>
<span class="gi">+    def current_control(self, control: UIControl) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the :class:`.UIControl` to receive the focus.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for window in self.find_all_windows():</span>
<span class="gi">+            if window.content == control:</span>
<span class="gi">+                self.current_window = window</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        raise ValueError(&quot;Control not found in the user interface.&quot;)</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_window(self) -&gt;Window:</span>
<span class="gd">-        &quot;&quot;&quot;Return the :class:`.Window` object that is currently focused.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def current_window(self) -&gt; Window:</span>
<span class="gi">+        &quot;Return the :class:`.Window` object that is currently focused.&quot;</span>
<span class="gi">+        return self._stack[-1]</span>

<span class="w"> </span>    @current_window.setter
<span class="gd">-    def current_window(self, value: Window) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Set the :class:`.Window` object to be currently focused.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def current_window(self, value: Window) -&gt; None:</span>
<span class="gi">+        &quot;Set the :class:`.Window` object to be currently focused.&quot;</span>
<span class="gi">+        self._stack.append(value)</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_searching(self) -&gt;bool:</span>
<span class="gd">-        &quot;&quot;&quot;True if we are searching right now.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def is_searching(self) -&gt; bool:</span>
<span class="gi">+        &quot;True if we are searching right now.&quot;</span>
<span class="gi">+        return self.current_control in self.search_links</span>

<span class="w"> </span>    @property
<span class="gd">-    def search_target_buffer_control(self) -&gt;(BufferControl | None):</span>
<span class="gi">+    def search_target_buffer_control(self) -&gt; BufferControl | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the :class:`.BufferControl` in which we are searching or `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Not every `UIControl` is a `BufferControl`. This only applies to</span>
<span class="gi">+        # `BufferControl`.</span>
<span class="gi">+        control = self.current_control</span>

<span class="gd">-    def get_focusable_windows(self) -&gt;Iterable[Window]:</span>
<span class="gi">+        if isinstance(control, SearchBufferControl):</span>
<span class="gi">+            return self.search_links.get(control)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_focusable_windows(self) -&gt; Iterable[Window]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return all the :class:`.Window` objects which are focusable (in the
<span class="w"> </span>        &#39;modal&#39; area).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for w in self.walk_through_modal_area():</span>
<span class="gi">+            if isinstance(w, Window) and w.content.is_focusable():</span>
<span class="gi">+                yield w</span>

<span class="gd">-    def get_visible_focusable_windows(self) -&gt;list[Window]:</span>
<span class="gi">+    def get_visible_focusable_windows(self) -&gt; list[Window]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of :class:`.Window` objects that are focusable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # focusable windows are windows that are visible, but also part of the</span>
<span class="gi">+        # modal container. Make sure to keep the ordering.</span>
<span class="gi">+        visible_windows = self.visible_windows</span>
<span class="gi">+        return [w for w in self.get_focusable_windows() if w in visible_windows]</span>

<span class="w"> </span>    @property
<span class="gd">-    def current_buffer(self) -&gt;(Buffer | None):</span>
<span class="gi">+    def current_buffer(self) -&gt; Buffer | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The currently focused :class:`~.Buffer` or `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ui_control = self.current_control</span>
<span class="gi">+        if isinstance(ui_control, BufferControl):</span>
<span class="gi">+            return ui_control.buffer</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_buffer_by_name(self, buffer_name: str) -&gt;(Buffer | None):</span>
<span class="gi">+    def get_buffer_by_name(self, buffer_name: str) -&gt; Buffer | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Look in the layout for a buffer with the given name.
<span class="w"> </span>        Return `None` when nothing was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for w in self.walk():</span>
<span class="gi">+            if isinstance(w, Window) and isinstance(w.content, BufferControl):</span>
<span class="gi">+                if w.content.buffer.name == buffer_name:</span>
<span class="gi">+                    return w.content.buffer</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="gd">-    def buffer_has_focus(self) -&gt;bool:</span>
<span class="gi">+    def buffer_has_focus(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return `True` if the currently focused control is a
<span class="w"> </span>        :class:`.BufferControl`. (For instance, used to determine whether the
<span class="w"> </span>        default key bindings should be active or not.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ui_control = self.current_control</span>
<span class="gi">+        return isinstance(ui_control, BufferControl)</span>

<span class="w"> </span>    @property
<span class="gd">-    def previous_control(self) -&gt;UIControl:</span>
<span class="gi">+    def previous_control(self) -&gt; UIControl:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the :class:`.UIControl` to previously had the focus.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._stack[-2].content</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return self._stack[-1].content</span>

<span class="gd">-    def focus_last(self) -&gt;None:</span>
<span class="gi">+    def focus_last(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Give the focus to the last focused control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self._stack) &gt; 1:</span>
<span class="gi">+            self._stack = self._stack[:-1]</span>

<span class="gd">-    def focus_next(self) -&gt;None:</span>
<span class="gi">+    def focus_next(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Focus the next visible/focusable Window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        windows = self.get_visible_focusable_windows()</span>
<span class="gi">+</span>
<span class="gi">+        if len(windows) &gt; 0:</span>
<span class="gi">+            try:</span>
<span class="gi">+                index = windows.index(self.current_window)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                index = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                index = (index + 1) % len(windows)</span>
<span class="gi">+</span>
<span class="gi">+            self.focus(windows[index])</span>

<span class="gd">-    def focus_previous(self) -&gt;None:</span>
<span class="gi">+    def focus_previous(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Focus the previous visible/focusable Window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        windows = self.get_visible_focusable_windows()</span>
<span class="gi">+</span>
<span class="gi">+        if len(windows) &gt; 0:</span>
<span class="gi">+            try:</span>
<span class="gi">+                index = windows.index(self.current_window)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                index = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                index = (index - 1) % len(windows)</span>
<span class="gi">+</span>
<span class="gi">+            self.focus(windows[index])</span>

<span class="gd">-    def walk(self) -&gt;Iterable[Container]:</span>
<span class="gi">+    def walk(self) -&gt; Iterable[Container]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Walk through all the layout nodes (and their children) and yield them.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        yield from walk(self.container)</span>

<span class="gd">-    def walk_through_modal_area(self) -&gt;Iterable[Container]:</span>
<span class="gi">+    def walk_through_modal_area(self) -&gt; Iterable[Container]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Walk through all the containers which are in the current &#39;modal&#39; part
<span class="w"> </span>        of the layout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Go up in the tree, and find the root. (it will be a part of the</span>
<span class="gi">+        # layout, if the focus is in a modal part.)</span>
<span class="gi">+        root: Container = self.current_window</span>
<span class="gi">+        while not root.is_modal() and root in self._child_to_parent:</span>
<span class="gi">+            root = self._child_to_parent[root]</span>

<span class="gd">-    def update_parents_relations(self) -&gt;None:</span>
<span class="gi">+        yield from walk(root)</span>
<span class="gi">+</span>
<span class="gi">+    def update_parents_relations(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Update child-&gt;parent relationships mapping.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parents = {}</span>
<span class="gi">+</span>
<span class="gi">+        def walk(e: Container) -&gt; None:</span>
<span class="gi">+            for c in e.get_children():</span>
<span class="gi">+                parents[c] = e</span>
<span class="gi">+                walk(c)</span>
<span class="gi">+</span>
<span class="gi">+        walk(self.container)</span>
<span class="gi">+</span>
<span class="gi">+        self._child_to_parent = parents</span>

<span class="gd">-    def get_parent(self, container: Container) -&gt;(Container | None):</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        # Remove all search links when the UI starts.</span>
<span class="gi">+        # (Important, for instance when control-c is been pressed while</span>
<span class="gi">+        #  searching. The prompt cancels, but next `run()` call the search</span>
<span class="gi">+        #  links are still there.)</span>
<span class="gi">+        self.search_links.clear()</span>
<span class="gi">+</span>
<span class="gi">+        self.container.reset()</span>
<span class="gi">+</span>
<span class="gi">+    def get_parent(self, container: Container) -&gt; Container | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the parent container for the given container, or ``None``, if it
<span class="w"> </span>        wasn&#39;t found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._child_to_parent[container]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>class InvalidLayoutError(Exception):
<span class="w"> </span>    pass


<span class="gd">-def walk(container: Container, skip_hidden: bool=False) -&gt;Iterable[Container]:</span>
<span class="gi">+def walk(container: Container, skip_hidden: bool = False) -&gt; Iterable[Container]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Walk through layout, starting at this container.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # When `skip_hidden` is set, don&#39;t go into disabled ConditionalContainer containers.</span>
<span class="gi">+    if (</span>
<span class="gi">+        skip_hidden</span>
<span class="gi">+        and isinstance(container, ConditionalContainer)</span>
<span class="gi">+        and not container.filter()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    yield container</span>
<span class="gi">+</span>
<span class="gi">+    for c in container.get_children():</span>
<span class="gi">+        # yield from walk(c)</span>
<span class="gi">+        yield from walk(c, skip_hidden=skip_hidden)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/margins.py b/src/prompt_toolkit/layout/margins.py</span>
<span class="gh">index 221ae7c0..cc9dd964 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/margins.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/margins.py</span>
<span class="gu">@@ -2,16 +2,30 @@</span>
<span class="w"> </span>Margin implementations for a :class:`~prompt_toolkit.layout.containers.Window`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="gd">-from prompt_toolkit.formatted_text import StyleAndTextTuples, fragment_list_to_text, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    fragment_list_to_text,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gi">+</span>
<span class="w"> </span>from .controls import UIContent
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .containers import WindowRenderInfo
<span class="gd">-__all__ = [&#39;Margin&#39;, &#39;NumberedMargin&#39;, &#39;ScrollbarMargin&#39;,</span>
<span class="gd">-    &#39;ConditionalMargin&#39;, &#39;PromptMargin&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Margin&quot;,</span>
<span class="gi">+    &quot;NumberedMargin&quot;,</span>
<span class="gi">+    &quot;ScrollbarMargin&quot;,</span>
<span class="gi">+    &quot;ConditionalMargin&quot;,</span>
<span class="gi">+    &quot;PromptMargin&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Margin(metaclass=ABCMeta):
<span class="gu">@@ -20,7 +34,7 @@ class Margin(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt;int:</span>
<span class="gi">+    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width that this margin is going to consume.

<span class="gu">@@ -28,11 +42,12 @@ class Margin(metaclass=ABCMeta):</span>
<span class="w"> </span>            a :class:`.UIContent` instance. This can be used for instance to
<span class="w"> </span>            obtain the number of lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def create_margin(self, window_render_info: WindowRenderInfo, width:</span>
<span class="gd">-        int, height: int) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def create_margin(</span>
<span class="gi">+        self, window_render_info: WindowRenderInfo, width: int, height: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Creates a margin.
<span class="w"> </span>        This should return a list of (style_str, text) tuples.
<span class="gu">@@ -47,7 +62,7 @@ class Margin(metaclass=ABCMeta):</span>
<span class="w"> </span>        :param height: The height that&#39;s available for this margin. (The height
<span class="w"> </span>            of the :class:`~prompt_toolkit.layout.containers.Window`.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class NumberedMargin(Margin):
<span class="gu">@@ -60,21 +75,87 @@ class NumberedMargin(Margin):</span>
<span class="w"> </span>        like Vi does.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, relative: FilterOrBool=False, display_tildes:</span>
<span class="gd">-        FilterOrBool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, relative: FilterOrBool = False, display_tildes: FilterOrBool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.relative = to_filter(relative)
<span class="w"> </span>        self.display_tildes = to_filter(display_tildes)

<span class="gi">+    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt; int:</span>
<span class="gi">+        line_count = get_ui_content().line_count</span>
<span class="gi">+        return max(3, len(&quot;%s&quot; % line_count) + 1)</span>
<span class="gi">+</span>
<span class="gi">+    def create_margin(</span>
<span class="gi">+        self, window_render_info: WindowRenderInfo, width: int, height: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        relative = self.relative()</span>
<span class="gi">+</span>
<span class="gi">+        style = &quot;class:line-number&quot;</span>
<span class="gi">+        style_current = &quot;class:line-number.current&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Get current line number.</span>
<span class="gi">+        current_lineno = window_render_info.ui_content.cursor_position.y</span>
<span class="gi">+</span>
<span class="gi">+        # Construct margin.</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+        last_lineno = None</span>
<span class="gi">+</span>
<span class="gi">+        for y, lineno in enumerate(window_render_info.displayed_lines):</span>
<span class="gi">+            # Only display line number if this line is not a continuation of the previous line.</span>
<span class="gi">+            if lineno != last_lineno:</span>
<span class="gi">+                if lineno is None:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif lineno == current_lineno:</span>
<span class="gi">+                    # Current line.</span>
<span class="gi">+                    if relative:</span>
<span class="gi">+                        # Left align current number in relative mode.</span>
<span class="gi">+                        result.append((style_current, &quot;%i&quot; % (lineno + 1)))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        result.append(</span>
<span class="gi">+                            (style_current, (&quot;%i &quot; % (lineno + 1)).rjust(width))</span>
<span class="gi">+                        )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Other lines.</span>
<span class="gi">+                    if relative:</span>
<span class="gi">+                        lineno = abs(lineno - current_lineno) - 1</span>
<span class="gi">+</span>
<span class="gi">+                    result.append((style, (&quot;%i &quot; % (lineno + 1)).rjust(width)))</span>
<span class="gi">+</span>
<span class="gi">+            last_lineno = lineno</span>
<span class="gi">+            result.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # Fill with tildes.</span>
<span class="gi">+        if self.display_tildes():</span>
<span class="gi">+            while y &lt; window_render_info.window_height:</span>
<span class="gi">+                result.append((&quot;class:tilde&quot;, &quot;~\n&quot;))</span>
<span class="gi">+                y += 1</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class ConditionalMargin(Margin):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Wrapper around other :class:`.Margin` classes to show/hide them.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, margin: Margin, filter: FilterOrBool) -&gt;None:</span>
<span class="gi">+    def __init__(self, margin: Margin, filter: FilterOrBool) -&gt; None:</span>
<span class="w"> </span>        self.margin = margin
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gi">+    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt; int:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.margin.get_width(get_ui_content)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def create_margin(</span>
<span class="gi">+        self, window_render_info: WindowRenderInfo, width: int, height: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        if width and self.filter():</span>
<span class="gi">+            return self.margin.create_margin(window_render_info, width, height)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>

<span class="w"> </span>class ScrollbarMargin(Margin):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -83,12 +164,84 @@ class ScrollbarMargin(Margin):</span>
<span class="w"> </span>    :param display_arrows: Display scroll up/down arrows.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, display_arrows: FilterOrBool=False, up_arrow_symbol:</span>
<span class="gd">-        str=&#39;^&#39;, down_arrow_symbol: str=&#39;v&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        display_arrows: FilterOrBool = False,</span>
<span class="gi">+        up_arrow_symbol: str = &quot;^&quot;,</span>
<span class="gi">+        down_arrow_symbol: str = &quot;v&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.display_arrows = to_filter(display_arrows)
<span class="w"> </span>        self.up_arrow_symbol = up_arrow_symbol
<span class="w"> </span>        self.down_arrow_symbol = down_arrow_symbol

<span class="gi">+    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt; int:</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    def create_margin(</span>
<span class="gi">+        self, window_render_info: WindowRenderInfo, width: int, height: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        content_height = window_render_info.content_height</span>
<span class="gi">+        window_height = window_render_info.window_height</span>
<span class="gi">+        display_arrows = self.display_arrows()</span>
<span class="gi">+</span>
<span class="gi">+        if display_arrows:</span>
<span class="gi">+            window_height -= 2</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            fraction_visible = len(window_render_info.displayed_lines) / float(</span>
<span class="gi">+                content_height</span>
<span class="gi">+            )</span>
<span class="gi">+            fraction_above = window_render_info.vertical_scroll / float(content_height)</span>
<span class="gi">+</span>
<span class="gi">+            scrollbar_height = int(</span>
<span class="gi">+                min(window_height, max(1, window_height * fraction_visible))</span>
<span class="gi">+            )</span>
<span class="gi">+            scrollbar_top = int(window_height * fraction_above)</span>
<span class="gi">+        except ZeroDivisionError:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def is_scroll_button(row: int) -&gt; bool:</span>
<span class="gi">+                &quot;True if we should display a button on this row.&quot;</span>
<span class="gi">+                return scrollbar_top &lt;= row &lt;= scrollbar_top + scrollbar_height</span>
<span class="gi">+</span>
<span class="gi">+            # Up arrow.</span>
<span class="gi">+            result: StyleAndTextTuples = []</span>
<span class="gi">+            if display_arrows:</span>
<span class="gi">+                result.extend(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        (&quot;class:scrollbar.arrow&quot;, self.up_arrow_symbol),</span>
<span class="gi">+                        (&quot;class:scrollbar&quot;, &quot;\n&quot;),</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # Scrollbar body.</span>
<span class="gi">+            scrollbar_background = &quot;class:scrollbar.background&quot;</span>
<span class="gi">+            scrollbar_background_start = &quot;class:scrollbar.background,scrollbar.start&quot;</span>
<span class="gi">+            scrollbar_button = &quot;class:scrollbar.button&quot;</span>
<span class="gi">+            scrollbar_button_end = &quot;class:scrollbar.button,scrollbar.end&quot;</span>
<span class="gi">+</span>
<span class="gi">+            for i in range(window_height):</span>
<span class="gi">+                if is_scroll_button(i):</span>
<span class="gi">+                    if not is_scroll_button(i + 1):</span>
<span class="gi">+                        # Give the last cell a different style, because we</span>
<span class="gi">+                        # want to underline this.</span>
<span class="gi">+                        result.append((scrollbar_button_end, &quot; &quot;))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        result.append((scrollbar_button, &quot; &quot;))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if is_scroll_button(i + 1):</span>
<span class="gi">+                        result.append((scrollbar_background_start, &quot; &quot;))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        result.append((scrollbar_background, &quot; &quot;))</span>
<span class="gi">+                result.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            # Down arrow</span>
<span class="gi">+            if display_arrows:</span>
<span class="gi">+                result.append((&quot;class:scrollbar.arrow&quot;, self.down_arrow_symbol))</span>
<span class="gi">+</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>

<span class="w"> </span>class PromptMargin(Margin):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -112,12 +265,39 @@ class PromptMargin(Margin):</span>
<span class="w"> </span>        input.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_prompt: Callable[[], StyleAndTextTuples],</span>
<span class="gd">-        get_continuation: (None | Callable[[int, int, bool],</span>
<span class="gd">-        StyleAndTextTuples])=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_prompt: Callable[[], StyleAndTextTuples],</span>
<span class="gi">+        get_continuation: None</span>
<span class="gi">+        | (Callable[[int, int, bool], StyleAndTextTuples]) = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.get_prompt = get_prompt
<span class="w"> </span>        self.get_continuation = get_continuation

<span class="gd">-    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;Width to report to the `Window`.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt; int:</span>
<span class="gi">+        &quot;Width to report to the `Window`.&quot;</span>
<span class="gi">+        # Take the width from the first line.</span>
<span class="gi">+        text = fragment_list_to_text(self.get_prompt())</span>
<span class="gi">+        return get_cwidth(text)</span>
<span class="gi">+</span>
<span class="gi">+    def create_margin(</span>
<span class="gi">+        self, window_render_info: WindowRenderInfo, width: int, height: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        get_continuation = self.get_continuation</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+</span>
<span class="gi">+        # First line.</span>
<span class="gi">+        result.extend(to_formatted_text(self.get_prompt()))</span>
<span class="gi">+</span>
<span class="gi">+        # Next lines.</span>
<span class="gi">+        if get_continuation:</span>
<span class="gi">+            last_y = None</span>
<span class="gi">+</span>
<span class="gi">+            for y in window_render_info.displayed_lines[1:]:</span>
<span class="gi">+                result.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+                result.extend(</span>
<span class="gi">+                    to_formatted_text(get_continuation(width, y, y == last_y))</span>
<span class="gi">+                )</span>
<span class="gi">+                last_y = y</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/menus.py b/src/prompt_toolkit/layout/menus.py</span>
<span class="gh">index 8231f28b..2c2ccb64 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/menus.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/menus.py</span>
<span class="gu">@@ -1,25 +1,48 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>from itertools import zip_longest
<span class="w"> </span>from typing import TYPE_CHECKING, Callable, Iterable, Sequence, TypeVar, cast
<span class="w"> </span>from weakref import WeakKeyDictionary
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.buffer import CompletionState
<span class="w"> </span>from prompt_toolkit.completion import Completion
<span class="w"> </span>from prompt_toolkit.data_structures import Point
<span class="gd">-from prompt_toolkit.filters import Condition, FilterOrBool, has_completions, is_done, to_filter</span>
<span class="gd">-from prompt_toolkit.formatted_text import StyleAndTextTuples, fragment_list_width, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    FilterOrBool,</span>
<span class="gi">+    has_completions,</span>
<span class="gi">+    is_done,</span>
<span class="gi">+    to_filter,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    fragment_list_width,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.layout.utils import explode_text_fragments
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent, MouseEventType
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gi">+</span>
<span class="w"> </span>from .containers import ConditionalContainer, HSplit, ScrollOffsets, Window
<span class="w"> </span>from .controls import GetLinePrefixCallable, UIContent, UIControl
<span class="w"> </span>from .dimension import Dimension
<span class="w"> </span>from .margins import ScrollbarMargin
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from prompt_toolkit.key_binding.key_bindings import KeyBindings, NotImplementedOrNone</span>
<span class="gd">-__all__ = [&#39;CompletionsMenu&#39;, &#39;MultiColumnCompletionsMenu&#39;]</span>
<span class="gi">+    from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+        KeyBindings,</span>
<span class="gi">+        NotImplementedOrNone,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CompletionsMenu&quot;,</span>
<span class="gi">+    &quot;MultiColumnCompletionsMenu&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gu">@@ -32,73 +55,242 @@ class CompletionsMenuControl(UIControl):</span>
<span class="w"> </span>        is a very high number, the current completion will be shown in the
<span class="w"> </span>        middle most of the time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Preferred minimum size of the menu control.</span>
<span class="gi">+    # The CompletionsMenu class defines a width of 8, and there is a scrollbar</span>
<span class="gi">+    # of 1.)</span>
<span class="w"> </span>    MIN_WIDTH = 7

<span class="gd">-    def create_content(self, width: int, height: int) -&gt;UIContent:</span>
<span class="gi">+    def has_focus(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; int | None:</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state:</span>
<span class="gi">+            menu_width = self._get_menu_width(500, complete_state)</span>
<span class="gi">+            menu_meta_width = self._get_menu_meta_width(500, complete_state)</span>
<span class="gi">+</span>
<span class="gi">+            return menu_width + menu_meta_width</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        max_available_height: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state:</span>
<span class="gi">+            return len(complete_state.completions)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a UIContent object for this control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _show_meta(self, complete_state: CompletionState) -&gt;bool:</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state:</span>
<span class="gi">+            completions = complete_state.completions</span>
<span class="gi">+            index = complete_state.complete_index  # Can be None!</span>
<span class="gi">+</span>
<span class="gi">+            # Calculate width of completions menu.</span>
<span class="gi">+            menu_width = self._get_menu_width(width, complete_state)</span>
<span class="gi">+            menu_meta_width = self._get_menu_meta_width(</span>
<span class="gi">+                width - menu_width, complete_state</span>
<span class="gi">+            )</span>
<span class="gi">+            show_meta = self._show_meta(complete_state)</span>
<span class="gi">+</span>
<span class="gi">+            def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+                c = completions[i]</span>
<span class="gi">+                is_current_completion = i == index</span>
<span class="gi">+                result = _get_menu_item_fragments(</span>
<span class="gi">+                    c, is_current_completion, menu_width, space_after=True</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if show_meta:</span>
<span class="gi">+                    result += self._get_menu_item_meta_fragments(</span>
<span class="gi">+                        c, is_current_completion, menu_meta_width</span>
<span class="gi">+                    )</span>
<span class="gi">+                return result</span>
<span class="gi">+</span>
<span class="gi">+            return UIContent(</span>
<span class="gi">+                get_line=get_line,</span>
<span class="gi">+                cursor_position=Point(x=0, y=index or 0),</span>
<span class="gi">+                line_count=len(completions),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent()</span>
<span class="gi">+</span>
<span class="gi">+    def _show_meta(self, complete_state: CompletionState) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return ``True`` if we need to show a column with meta information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(c.display_meta_text for c in complete_state.completions)</span>

<span class="gd">-    def _get_menu_width(self, max_width: int, complete_state: CompletionState</span>
<span class="gd">-        ) -&gt;int:</span>
<span class="gi">+    def _get_menu_width(self, max_width: int, complete_state: CompletionState) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width of the main column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_menu_meta_width(self, max_width: int, complete_state:</span>
<span class="gd">-        CompletionState) -&gt;int:</span>
<span class="gi">+        return min(</span>
<span class="gi">+            max_width,</span>
<span class="gi">+            max(</span>
<span class="gi">+                self.MIN_WIDTH,</span>
<span class="gi">+                max(get_cwidth(c.display_text) for c in complete_state.completions) + 2,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_menu_meta_width(</span>
<span class="gi">+        self, max_width: int, complete_state: CompletionState</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width of the meta column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+        def meta_width(completion: Completion) -&gt; int:</span>
<span class="gi">+            return get_cwidth(completion.display_meta_text)</span>
<span class="gi">+</span>
<span class="gi">+        if self._show_meta(complete_state):</span>
<span class="gi">+            # If the amount of completions is over 200, compute the width based</span>
<span class="gi">+            # on the first 200 completions, otherwise this can be very slow.</span>
<span class="gi">+            completions = complete_state.completions</span>
<span class="gi">+            if len(completions) &gt; 200:</span>
<span class="gi">+                completions = completions[:200]</span>
<span class="gi">+</span>
<span class="gi">+            return min(max_width, max(meta_width(c) for c in completions) + 2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def _get_menu_item_meta_fragments(</span>
<span class="gi">+        self, completion: Completion, is_current_completion: bool, width: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        if is_current_completion:</span>
<span class="gi">+            style_str = &quot;class:completion-menu.meta.completion.current&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            style_str = &quot;class:completion-menu.meta.completion&quot;</span>
<span class="gi">+</span>
<span class="gi">+        text, tw = _trim_formatted_text(completion.display_meta, width - 2)</span>
<span class="gi">+        padding = &quot; &quot; * (width - 1 - tw)</span>
<span class="gi">+</span>
<span class="gi">+        return to_formatted_text(</span>
<span class="gi">+            cast(StyleAndTextTuples, []) + [(&quot;&quot;, &quot; &quot;)] + text + [(&quot;&quot;, padding)],</span>
<span class="gi">+            style=style_str,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def mouse_handler(self, mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle mouse events: clicking and scrolling.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = get_app().current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        if mouse_event.event_type == MouseEventType.MOUSE_UP:</span>
<span class="gi">+            # Select completion.</span>
<span class="gi">+            b.go_to_completion(mouse_event.position.y)</span>
<span class="gi">+            b.complete_state = None</span>
<span class="gi">+</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.SCROLL_DOWN:</span>
<span class="gi">+            # Scroll up.</span>
<span class="gi">+            b.complete_next(count=3, disable_wrap_around=True)</span>

<span class="gi">+        elif mouse_event.event_type == MouseEventType.SCROLL_UP:</span>
<span class="gi">+            # Scroll down.</span>
<span class="gi">+            b.complete_previous(count=3, disable_wrap_around=True)</span>

<span class="gd">-def _get_menu_item_fragments(completion: Completion, is_current_completion:</span>
<span class="gd">-    bool, width: int, space_after: bool=False) -&gt;StyleAndTextTuples:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_menu_item_fragments(</span>
<span class="gi">+    completion: Completion,</span>
<span class="gi">+    is_current_completion: bool,</span>
<span class="gi">+    width: int,</span>
<span class="gi">+    space_after: bool = False,</span>
<span class="gi">+) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the style/text tuples for a menu item, styled and trimmed to the given
<span class="w"> </span>    width.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_current_completion:</span>
<span class="gi">+        style_str = &quot;class:completion-menu.completion.current {} {}&quot;.format(</span>
<span class="gi">+            completion.style,</span>
<span class="gi">+            completion.selected_style,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        style_str = &quot;class:completion-menu.completion &quot; + completion.style</span>
<span class="gi">+</span>
<span class="gi">+    text, tw = _trim_formatted_text(</span>
<span class="gi">+        completion.display, (width - 2 if space_after else width - 1)</span>
<span class="gi">+    )</span>

<span class="gi">+    padding = &quot; &quot; * (width - 1 - tw)</span>

<span class="gd">-def _trim_formatted_text(formatted_text: StyleAndTextTuples, max_width: int</span>
<span class="gd">-    ) -&gt;tuple[StyleAndTextTuples, int]:</span>
<span class="gi">+    return to_formatted_text(</span>
<span class="gi">+        cast(StyleAndTextTuples, []) + [(&quot;&quot;, &quot; &quot;)] + text + [(&quot;&quot;, padding)],</span>
<span class="gi">+        style=style_str,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _trim_formatted_text(</span>
<span class="gi">+    formatted_text: StyleAndTextTuples, max_width: int</span>
<span class="gi">+) -&gt; tuple[StyleAndTextTuples, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Trim the text to `max_width`, append dots when the text is too long.
<span class="w"> </span>    Returns (text, width) tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    width = fragment_list_width(formatted_text)</span>

<span class="gi">+    # When the text is too wide, trim it.</span>
<span class="gi">+    if width &gt; max_width:</span>
<span class="gi">+        result = []  # Text fragments.</span>
<span class="gi">+        remaining_width = max_width - 3</span>
<span class="gi">+</span>
<span class="gi">+        for style_and_ch in explode_text_fragments(formatted_text):</span>
<span class="gi">+            ch_width = get_cwidth(style_and_ch[1])</span>
<span class="gi">+</span>
<span class="gi">+            if ch_width &lt;= remaining_width:</span>
<span class="gi">+                result.append(style_and_ch)</span>
<span class="gi">+                remaining_width -= ch_width</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        result.append((&quot;&quot;, &quot;...&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        return result, max_width - remaining_width</span>
<span class="gi">+    else:</span>
<span class="gi">+        return formatted_text, width</span>

<span class="gd">-class CompletionsMenu(ConditionalContainer):</span>

<span class="gd">-    def __init__(self, max_height: (int | None)=None, scroll_offset: (int |</span>
<span class="gd">-        Callable[[], int])=0, extra_filter: FilterOrBool=True,</span>
<span class="gd">-        display_arrows: FilterOrBool=False, z_index: int=10 ** 8) -&gt;None:</span>
<span class="gi">+class CompletionsMenu(ConditionalContainer):</span>
<span class="gi">+    # NOTE: We use a pretty big z_index by default. Menus are supposed to be</span>
<span class="gi">+    #       above anything else. We also want to make sure that the content is</span>
<span class="gi">+    #       visible at the point where we draw this menu.</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        max_height: int | None = None,</span>
<span class="gi">+        scroll_offset: int | Callable[[], int] = 0,</span>
<span class="gi">+        extra_filter: FilterOrBool = True,</span>
<span class="gi">+        display_arrows: FilterOrBool = False,</span>
<span class="gi">+        z_index: int = 10**8,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        extra_filter = to_filter(extra_filter)
<span class="w"> </span>        display_arrows = to_filter(display_arrows)
<span class="gd">-        super().__init__(content=Window(content=CompletionsMenuControl(),</span>
<span class="gd">-            width=Dimension(min=8), height=Dimension(min=1, max=max_height),</span>
<span class="gd">-            scroll_offsets=ScrollOffsets(top=scroll_offset, bottom=</span>
<span class="gd">-            scroll_offset), right_margins=[ScrollbarMargin(display_arrows=</span>
<span class="gd">-            display_arrows)], dont_extend_width=True, style=</span>
<span class="gd">-            &#39;class:completion-menu&#39;, z_index=z_index), filter=extra_filter &amp;</span>
<span class="gd">-            has_completions &amp; ~is_done)</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            content=Window(</span>
<span class="gi">+                content=CompletionsMenuControl(),</span>
<span class="gi">+                width=Dimension(min=8),</span>
<span class="gi">+                height=Dimension(min=1, max=max_height),</span>
<span class="gi">+                scroll_offsets=ScrollOffsets(top=scroll_offset, bottom=scroll_offset),</span>
<span class="gi">+                right_margins=[ScrollbarMargin(display_arrows=display_arrows)],</span>
<span class="gi">+                dont_extend_width=True,</span>
<span class="gi">+                style=&quot;class:completion-menu&quot;,</span>
<span class="gi">+                z_index=z_index,</span>
<span class="gi">+            ),</span>
<span class="gi">+            # Show when there are completions but not at the point we are</span>
<span class="gi">+            # returning the input.</span>
<span class="gi">+            filter=extra_filter &amp; has_completions &amp; ~is_done,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class MultiColumnCompletionMenuControl(UIControl):
<span class="gu">@@ -123,16 +315,27 @@ class MultiColumnCompletionMenuControl(UIControl):</span>
<span class="w"> </span>        if there is one very wide completion, that it doesn&#39;t significantly
<span class="w"> </span>        reduce the amount of columns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _required_margin = 3</span>

<span class="gd">-    def __init__(self, min_rows: int=3, suggested_max_column_width: int=30</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    _required_margin = 3  # One extra padding on the right + space for arrows.</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, min_rows: int = 3, suggested_max_column_width: int = 30) -&gt; None:</span>
<span class="w"> </span>        assert min_rows &gt;= 1
<span class="gi">+</span>
<span class="w"> </span>        self.min_rows = min_rows
<span class="w"> </span>        self.suggested_max_column_width = suggested_max_column_width
<span class="w"> </span>        self.scroll = 0
<span class="gi">+</span>
<span class="gi">+        # Cache for column width computations. This computation is not cheap,</span>
<span class="gi">+        # so we don&#39;t want to do it over and over again while the user</span>
<span class="gi">+        # navigates through the completions.</span>
<span class="gi">+        # (map `completion_state` to `(completion_count, width)`. We remember</span>
<span class="gi">+        # the count, because a completer can add new completions to the</span>
<span class="gi">+        # `CompletionState` while loading.)</span>
<span class="w"> </span>        self._column_width_for_completion_state: WeakKeyDictionary[
<span class="gd">-            CompletionState, tuple[int, int]] = WeakKeyDictionary()</span>
<span class="gi">+            CompletionState, tuple[int, int]</span>
<span class="gi">+        ] = WeakKeyDictionary()</span>
<span class="gi">+</span>
<span class="gi">+        # Info of last rendering.</span>
<span class="w"> </span>        self._rendered_rows = 0
<span class="w"> </span>        self._rendered_columns = 0
<span class="w"> </span>        self._total_columns = 0
<span class="gu">@@ -141,45 +344,287 @@ class MultiColumnCompletionMenuControl(UIControl):</span>
<span class="w"> </span>        self._render_right_arrow = False
<span class="w"> </span>        self._render_width = 0

<span class="gd">-    def preferred_width(self, max_available_width: int) -&gt;(int | None):</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.scroll = 0</span>
<span class="gi">+</span>
<span class="gi">+    def has_focus(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Preferred width: prefer to use at least min_rows, but otherwise as much
<span class="w"> </span>        as possible horizontally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def preferred_height(self, width: int, max_available_height: int,</span>
<span class="gd">-        wrap_lines: bool, get_line_prefix: (GetLinePrefixCallable | None)) -&gt;(</span>
<span class="gd">-        int | None):</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        column_width = self._get_column_width(complete_state)</span>
<span class="gi">+        result = int(</span>
<span class="gi">+            column_width</span>
<span class="gi">+            * math.ceil(len(complete_state.completions) / float(self.min_rows))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # When the desired width is still more than the maximum available,</span>
<span class="gi">+        # reduce by removing columns until we are less than the available</span>
<span class="gi">+        # width.</span>
<span class="gi">+        while (</span>
<span class="gi">+            result &gt; column_width</span>
<span class="gi">+            and result &gt; max_available_width - self._required_margin</span>
<span class="gi">+        ):</span>
<span class="gi">+            result -= column_width</span>
<span class="gi">+        return result + self._required_margin</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        max_available_height: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Preferred height: as much as needed in order to display all the completions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        column_width = self._get_column_width(complete_state)</span>
<span class="gi">+        column_count = max(1, (width - self._required_margin) // column_width)</span>

<span class="gd">-    def create_content(self, width: int, height: int) -&gt;UIContent:</span>
<span class="gi">+        return int(math.ceil(len(complete_state.completions) / float(column_count)))</span>
<span class="gi">+</span>
<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a UIContent object for this menu.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_column_width(self, completion_state: CompletionState) -&gt;int:</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return UIContent()</span>
<span class="gi">+</span>
<span class="gi">+        column_width = self._get_column_width(complete_state)</span>
<span class="gi">+        self._render_pos_to_completion = {}</span>
<span class="gi">+</span>
<span class="gi">+        _T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def grouper(</span>
<span class="gi">+            n: int, iterable: Iterable[_T], fillvalue: _T | None = None</span>
<span class="gi">+        ) -&gt; Iterable[Sequence[_T | None]]:</span>
<span class="gi">+            &quot;grouper(3, &#39;ABCDEFG&#39;, &#39;x&#39;) --&gt; ABC DEF Gxx&quot;</span>
<span class="gi">+            args = [iter(iterable)] * n</span>
<span class="gi">+            return zip_longest(fillvalue=fillvalue, *args)</span>
<span class="gi">+</span>
<span class="gi">+        def is_current_completion(completion: Completion) -&gt; bool:</span>
<span class="gi">+            &quot;Returns True when this completion is the currently selected one.&quot;</span>
<span class="gi">+            return (</span>
<span class="gi">+                complete_state is not None</span>
<span class="gi">+                and complete_state.complete_index is not None</span>
<span class="gi">+                and c == complete_state.current_completion</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Space required outside of the regular columns, for displaying the</span>
<span class="gi">+        # left and right arrow.</span>
<span class="gi">+        HORIZONTAL_MARGIN_REQUIRED = 3</span>
<span class="gi">+</span>
<span class="gi">+        # There should be at least one column, but it cannot be wider than</span>
<span class="gi">+        # the available width.</span>
<span class="gi">+        column_width = min(width - HORIZONTAL_MARGIN_REQUIRED, column_width)</span>
<span class="gi">+</span>
<span class="gi">+        # However, when the columns tend to be very wide, because there are</span>
<span class="gi">+        # some very wide entries, shrink it anyway.</span>
<span class="gi">+        if column_width &gt; self.suggested_max_column_width:</span>
<span class="gi">+            # `column_width` can still be bigger that `suggested_max_column_width`,</span>
<span class="gi">+            # but if there is place for two columns, we divide by two.</span>
<span class="gi">+            column_width //= column_width // self.suggested_max_column_width</span>
<span class="gi">+</span>
<span class="gi">+        visible_columns = max(1, (width - self._required_margin) // column_width)</span>
<span class="gi">+</span>
<span class="gi">+        columns_ = list(grouper(height, complete_state.completions))</span>
<span class="gi">+        rows_ = list(zip(*columns_))</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure the current completion is always visible: update scroll offset.</span>
<span class="gi">+        selected_column = (complete_state.complete_index or 0) // height</span>
<span class="gi">+        self.scroll = min(</span>
<span class="gi">+            selected_column, max(self.scroll, selected_column - visible_columns + 1)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        render_left_arrow = self.scroll &gt; 0</span>
<span class="gi">+        render_right_arrow = self.scroll &lt; len(rows_[0]) - visible_columns</span>
<span class="gi">+</span>
<span class="gi">+        # Write completions to screen.</span>
<span class="gi">+        fragments_for_line = []</span>
<span class="gi">+</span>
<span class="gi">+        for row_index, row in enumerate(rows_):</span>
<span class="gi">+            fragments: StyleAndTextTuples = []</span>
<span class="gi">+            middle_row = row_index == len(rows_) // 2</span>
<span class="gi">+</span>
<span class="gi">+            # Draw left arrow if we have hidden completions on the left.</span>
<span class="gi">+            if render_left_arrow:</span>
<span class="gi">+                fragments.append((&quot;class:scrollbar&quot;, &quot;&lt;&quot; if middle_row else &quot; &quot;))</span>
<span class="gi">+            elif render_right_arrow:</span>
<span class="gi">+                # Reserve one column empty space. (If there is a right</span>
<span class="gi">+                # arrow right now, there can be a left arrow as well.)</span>
<span class="gi">+                fragments.append((&quot;&quot;, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+            # Draw row content.</span>
<span class="gi">+            for column_index, c in enumerate(row[self.scroll :][:visible_columns]):</span>
<span class="gi">+                if c is not None:</span>
<span class="gi">+                    fragments += _get_menu_item_fragments(</span>
<span class="gi">+                        c, is_current_completion(c), column_width, space_after=False</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    # Remember render position for mouse click handler.</span>
<span class="gi">+                    for x in range(column_width):</span>
<span class="gi">+                        self._render_pos_to_completion[</span>
<span class="gi">+                            (column_index * column_width + x, row_index)</span>
<span class="gi">+                        ] = c</span>
<span class="gi">+                else:</span>
<span class="gi">+                    fragments.append((&quot;class:completion&quot;, &quot; &quot; * column_width))</span>
<span class="gi">+</span>
<span class="gi">+            # Draw trailing padding for this row.</span>
<span class="gi">+            # (_get_menu_item_fragments only returns padding on the left.)</span>
<span class="gi">+            if render_left_arrow or render_right_arrow:</span>
<span class="gi">+                fragments.append((&quot;class:completion&quot;, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+            # Draw right arrow if we have hidden completions on the right.</span>
<span class="gi">+            if render_right_arrow:</span>
<span class="gi">+                fragments.append((&quot;class:scrollbar&quot;, &quot;&gt;&quot; if middle_row else &quot; &quot;))</span>
<span class="gi">+            elif render_left_arrow:</span>
<span class="gi">+                fragments.append((&quot;class:completion&quot;, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+            # Add line.</span>
<span class="gi">+            fragments_for_line.append(</span>
<span class="gi">+                to_formatted_text(fragments, style=&quot;class:completion-menu&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self._rendered_rows = height</span>
<span class="gi">+        self._rendered_columns = visible_columns</span>
<span class="gi">+        self._total_columns = len(columns_)</span>
<span class="gi">+        self._render_left_arrow = render_left_arrow</span>
<span class="gi">+        self._render_right_arrow = render_right_arrow</span>
<span class="gi">+        self._render_width = (</span>
<span class="gi">+            column_width * visible_columns + render_left_arrow + render_right_arrow + 1</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            return fragments_for_line[i]</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent(get_line=get_line, line_count=len(rows_))</span>
<span class="gi">+</span>
<span class="gi">+    def _get_column_width(self, completion_state: CompletionState) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width of each column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+        try:</span>
<span class="gi">+            count, width = self._column_width_for_completion_state[completion_state]</span>
<span class="gi">+            if count != len(completion_state.completions):</span>
<span class="gi">+                # Number of completions changed, recompute.</span>
<span class="gi">+                raise KeyError</span>
<span class="gi">+            return width</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            result = (</span>
<span class="gi">+                max(get_cwidth(c.display_text) for c in completion_state.completions)</span>
<span class="gi">+                + 1</span>
<span class="gi">+            )</span>
<span class="gi">+            self._column_width_for_completion_state[completion_state] = (</span>
<span class="gi">+                len(completion_state.completions),</span>
<span class="gi">+                result,</span>
<span class="gi">+            )</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+    def mouse_handler(self, mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle scroll and click events.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = get_app().current_buffer</span>
<span class="gi">+</span>
<span class="gi">+        def scroll_left() -&gt; None:</span>
<span class="gi">+            b.complete_previous(count=self._rendered_rows, disable_wrap_around=True)</span>
<span class="gi">+            self.scroll = max(0, self.scroll - 1)</span>
<span class="gi">+</span>
<span class="gi">+        def scroll_right() -&gt; None:</span>
<span class="gi">+            b.complete_next(count=self._rendered_rows, disable_wrap_around=True)</span>
<span class="gi">+            self.scroll = min(</span>
<span class="gi">+                self._total_columns - self._rendered_columns, self.scroll + 1</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if mouse_event.event_type == MouseEventType.SCROLL_DOWN:</span>
<span class="gi">+            scroll_right()</span>
<span class="gi">+</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.SCROLL_UP:</span>
<span class="gi">+            scroll_left()</span>
<span class="gi">+</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.MOUSE_UP:</span>
<span class="gi">+            x = mouse_event.position.x</span>
<span class="gi">+            y = mouse_event.position.y</span>
<span class="gi">+</span>
<span class="gi">+            # Mouse click on left arrow.</span>
<span class="gi">+            if x == 0:</span>
<span class="gi">+                if self._render_left_arrow:</span>
<span class="gi">+                    scroll_left()</span>
<span class="gi">+</span>
<span class="gi">+            # Mouse click on right arrow.</span>
<span class="gi">+            elif x == self._render_width - 1:</span>
<span class="gi">+                if self._render_right_arrow:</span>
<span class="gi">+                    scroll_right()</span>
<span class="gi">+</span>
<span class="gi">+            # Mouse click on completion.</span>
<span class="gi">+            else:</span>
<span class="gi">+                completion = self._render_pos_to_completion.get((x, y))</span>
<span class="gi">+                if completion:</span>
<span class="gi">+                    b.apply_completion(completion)</span>

<span class="gd">-    def get_key_bindings(self) -&gt;KeyBindings:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindings:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Expose key bindings that handle the left/right arrow keys when the menu
<span class="w"> </span>        is displayed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from prompt_toolkit.key_binding.key_bindings import KeyBindings</span>
<span class="gi">+</span>
<span class="gi">+        kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def filter() -&gt; bool:</span>
<span class="gi">+            &quot;Only handle key bindings if this menu is visible.&quot;</span>
<span class="gi">+            app = get_app()</span>
<span class="gi">+            complete_state = app.current_buffer.complete_state</span>
<span class="gi">+</span>
<span class="gi">+            # There need to be completions, and one needs to be selected.</span>
<span class="gi">+            if complete_state is None or complete_state.complete_index is None:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            # This menu needs to be visible.</span>
<span class="gi">+            return any(window.content == self for window in app.layout.visible_windows)</span>
<span class="gi">+</span>
<span class="gi">+        def move(right: bool = False) -&gt; None:</span>
<span class="gi">+            buff = get_app().current_buffer</span>
<span class="gi">+            complete_state = buff.complete_state</span>
<span class="gi">+</span>
<span class="gi">+            if complete_state is not None and complete_state.complete_index is not None:</span>
<span class="gi">+                # Calculate new complete index.</span>
<span class="gi">+                new_index = complete_state.complete_index</span>
<span class="gi">+                if right:</span>
<span class="gi">+                    new_index += self._rendered_rows</span>
<span class="gi">+                else:</span>
<span class="gi">+                    new_index -= self._rendered_rows</span>
<span class="gi">+</span>
<span class="gi">+                if 0 &lt;= new_index &lt; len(complete_state.completions):</span>
<span class="gi">+                    buff.go_to_completion(new_index)</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: the is_global is required because the completion menu will</span>
<span class="gi">+        #       never be focussed.</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot;left&quot;, is_global=True, filter=filter)</span>
<span class="gi">+        def _left(event: E) -&gt; None:</span>
<span class="gi">+            move()</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot;right&quot;, is_global=True, filter=filter)</span>
<span class="gi">+        def _right(event: E) -&gt; None:</span>
<span class="gi">+            move(True)</span>
<span class="gi">+</span>
<span class="gi">+        return kb</span>


<span class="w"> </span>class MultiColumnCompletionsMenu(HSplit):
<span class="gu">@@ -189,25 +634,52 @@ class MultiColumnCompletionsMenu(HSplit):</span>
<span class="w"> </span>    to True, it shows the meta information at the bottom.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, min_rows: int=3, suggested_max_column_width: int=30,</span>
<span class="gd">-        show_meta: FilterOrBool=True, extra_filter: FilterOrBool=True,</span>
<span class="gd">-        z_index: int=10 ** 8) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min_rows: int = 3,</span>
<span class="gi">+        suggested_max_column_width: int = 30,</span>
<span class="gi">+        show_meta: FilterOrBool = True,</span>
<span class="gi">+        extra_filter: FilterOrBool = True,</span>
<span class="gi">+        z_index: int = 10**8,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        show_meta = to_filter(show_meta)
<span class="w"> </span>        extra_filter = to_filter(extra_filter)
<span class="gi">+</span>
<span class="gi">+        # Display filter: show when there are completions but not at the point</span>
<span class="gi">+        # we are returning the input.</span>
<span class="w"> </span>        full_filter = extra_filter &amp; has_completions &amp; ~is_done

<span class="w"> </span>        @Condition
<span class="gd">-        def any_completion_has_meta() -&gt;bool:</span>
<span class="gi">+        def any_completion_has_meta() -&gt; bool:</span>
<span class="w"> </span>            complete_state = get_app().current_buffer.complete_state
<span class="gd">-            return complete_state is not None and any(c.display_meta for c in</span>
<span class="gd">-                complete_state.completions)</span>
<span class="gd">-        completions_window = ConditionalContainer(content=Window(content=</span>
<span class="gd">-            MultiColumnCompletionMenuControl(min_rows=min_rows,</span>
<span class="gd">-            suggested_max_column_width=suggested_max_column_width), width=</span>
<span class="gd">-            Dimension(min=8), height=Dimension(min=1)), filter=full_filter)</span>
<span class="gd">-        meta_window = ConditionalContainer(content=Window(content=</span>
<span class="gd">-            _SelectedCompletionMetaControl()), filter=full_filter &amp;</span>
<span class="gd">-            show_meta &amp; any_completion_has_meta)</span>
<span class="gi">+            return complete_state is not None and any(</span>
<span class="gi">+                c.display_meta for c in complete_state.completions</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Create child windows.</span>
<span class="gi">+        # NOTE: We don&#39;t set style=&#39;class:completion-menu&#39; to the</span>
<span class="gi">+        #       `MultiColumnCompletionMenuControl`, because this is used in a</span>
<span class="gi">+        #       Float that is made transparent, and the size of the control</span>
<span class="gi">+        #       doesn&#39;t always correspond exactly with the size of the</span>
<span class="gi">+        #       generated content.</span>
<span class="gi">+        completions_window = ConditionalContainer(</span>
<span class="gi">+            content=Window(</span>
<span class="gi">+                content=MultiColumnCompletionMenuControl(</span>
<span class="gi">+                    min_rows=min_rows,</span>
<span class="gi">+                    suggested_max_column_width=suggested_max_column_width,</span>
<span class="gi">+                ),</span>
<span class="gi">+                width=Dimension(min=8),</span>
<span class="gi">+                height=Dimension(min=1),</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=full_filter,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        meta_window = ConditionalContainer(</span>
<span class="gi">+            content=Window(content=_SelectedCompletionMetaControl()),</span>
<span class="gi">+            filter=full_filter &amp; show_meta &amp; any_completion_has_meta,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Initialize split.</span>
<span class="w"> </span>        super().__init__([completions_window, meta_window], z_index=z_index)


<span class="gu">@@ -216,7 +688,7 @@ class _SelectedCompletionMetaControl(UIControl):</span>
<span class="w"> </span>    Control that shows the meta information of the selected completion.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def preferred_width(self, max_available_width: int) -&gt;(int | None):</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Report the width of the longest meta text as the preferred width of this control.

<span class="gu">@@ -224,4 +696,56 @@ class _SelectedCompletionMetaControl(UIControl):</span>
<span class="w"> </span>        layout doesn&#39;t change when we select another completion (E.g. that
<span class="w"> </span>        completions are suddenly shown in more or fewer columns.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        if app.current_buffer.complete_state:</span>
<span class="gi">+            state = app.current_buffer.complete_state</span>
<span class="gi">+</span>
<span class="gi">+            if len(state.completions) &gt;= 30:</span>
<span class="gi">+                # When there are many completions, calling `get_cwidth` for</span>
<span class="gi">+                # every `display_meta_text` is too expensive. In this case,</span>
<span class="gi">+                # just return the max available width. There will be enough</span>
<span class="gi">+                # columns anyway so that the whole screen is filled with</span>
<span class="gi">+                # completions and `create_content` will then take up as much</span>
<span class="gi">+                # space as needed.</span>
<span class="gi">+                return max_available_width</span>
<span class="gi">+</span>
<span class="gi">+            return 2 + max(</span>
<span class="gi">+                get_cwidth(c.display_meta_text) for c in state.completions[:100]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        max_available_height: int,</span>
<span class="gi">+        wrap_lines: bool,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None,</span>
<span class="gi">+    ) -&gt; int | None:</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="gi">+        fragments = self._get_text_fragments()</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            return fragments</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent(get_line=get_line, line_count=1 if fragments else 0)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_text_fragments(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        style = &quot;class:completion-menu.multi-column-meta&quot;</span>
<span class="gi">+        state = get_app().current_buffer.complete_state</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            state</span>
<span class="gi">+            and state.current_completion</span>
<span class="gi">+            and state.current_completion.display_meta_text</span>
<span class="gi">+        ):</span>
<span class="gi">+            return to_formatted_text(</span>
<span class="gi">+                cast(StyleAndTextTuples, [(&quot;&quot;, &quot; &quot;)])</span>
<span class="gi">+                + state.current_completion.display_meta</span>
<span class="gi">+                + [(&quot;&quot;, &quot; &quot;)],</span>
<span class="gi">+                style=style,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return []</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/mouse_handlers.py b/src/prompt_toolkit/layout/mouse_handlers.py</span>
<span class="gh">index 52c54dc6..56a4eddd 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/mouse_handlers.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/mouse_handlers.py</span>
<span class="gu">@@ -1,11 +1,20 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.key_binding.key_bindings import NotImplementedOrNone
<span class="gd">-__all__ = [&#39;MouseHandler&#39;, &#39;MouseHandlers&#39;]</span>
<span class="gd">-MouseHandler = Callable[[MouseEvent], &#39;NotImplementedOrNone&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;MouseHandler&quot;,</span>
<span class="gi">+    &quot;MouseHandlers&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MouseHandler = Callable[[MouseEvent], &quot;NotImplementedOrNone&quot;]</span>


<span class="w"> </span>class MouseHandlers:
<span class="gu">@@ -13,20 +22,35 @@ class MouseHandlers:</span>
<span class="w"> </span>    Two dimensional raster of callbacks for mouse events.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-</span>
<span class="gd">-        def dummy_callback(mouse_event: MouseEvent) -&gt;NotImplementedOrNone:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        def dummy_callback(mouse_event: MouseEvent) -&gt; NotImplementedOrNone:</span>
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            :param mouse_event: `MouseEvent` instance.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            return NotImplemented
<span class="gd">-        self.mouse_handlers: defaultdict[int, defaultdict[int, MouseHandler]</span>
<span class="gd">-            ] = defaultdict(lambda : defaultdict(lambda : dummy_callback))</span>

<span class="gd">-    def set_mouse_handler_for_range(self, x_min: int, x_max: int, y_min:</span>
<span class="gd">-        int, y_max: int, handler: Callable[[MouseEvent], NotImplementedOrNone]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # NOTE: Previously, the data structure was a dictionary mapping (x,y)</span>
<span class="gi">+        # to the handlers. This however would be more inefficient when copying</span>
<span class="gi">+        # over the mouse handlers of the visible region in the scrollable pane.</span>
<span class="gi">+</span>
<span class="gi">+        # Map y (row) to x (column) to handlers.</span>
<span class="gi">+        self.mouse_handlers: defaultdict[</span>
<span class="gi">+            int, defaultdict[int, MouseHandler]</span>
<span class="gi">+        ] = defaultdict(lambda: defaultdict(lambda: dummy_callback))</span>
<span class="gi">+</span>
<span class="gi">+    def set_mouse_handler_for_range(</span>
<span class="gi">+        self,</span>
<span class="gi">+        x_min: int,</span>
<span class="gi">+        x_max: int,</span>
<span class="gi">+        y_min: int,</span>
<span class="gi">+        y_max: int,</span>
<span class="gi">+        handler: Callable[[MouseEvent], NotImplementedOrNone],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set mouse handler for a region.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for y in range(y_min, y_max):</span>
<span class="gi">+            row = self.mouse_handlers[y]</span>
<span class="gi">+</span>
<span class="gi">+            for x in range(x_min, x_max):</span>
<span class="gi">+                row[x] = handler</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/processors.py b/src/prompt_toolkit/layout/processors.py</span>
<span class="gh">index 71fc93e2..b7376115 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/processors.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/processors.py</span>
<span class="gu">@@ -6,29 +6,52 @@ They can insert fragments before or after, or highlight fragments by replacing t</span>
<span class="w"> </span>fragment types.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING, Callable, Hashable, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.cache import SimpleCache
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter, vi_insert_multiple_mode
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.formatted_text.utils import fragment_list_len, fragment_list_to_text
<span class="w"> </span>from prompt_toolkit.search import SearchDirection
<span class="w"> </span>from prompt_toolkit.utils import to_int, to_str
<span class="gi">+</span>
<span class="w"> </span>from .utils import explode_text_fragments
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .controls import BufferControl, UIContent
<span class="gd">-__all__ = [&#39;Processor&#39;, &#39;TransformationInput&#39;, &#39;Transformation&#39;,</span>
<span class="gd">-    &#39;DummyProcessor&#39;, &#39;HighlightSearchProcessor&#39;,</span>
<span class="gd">-    &#39;HighlightIncrementalSearchProcessor&#39;, &#39;HighlightSelectionProcessor&#39;,</span>
<span class="gd">-    &#39;PasswordProcessor&#39;, &#39;HighlightMatchingBracketProcessor&#39;,</span>
<span class="gd">-    &#39;DisplayMultipleCursors&#39;, &#39;BeforeInput&#39;, &#39;ShowArg&#39;, &#39;AfterInput&#39;,</span>
<span class="gd">-    &#39;AppendAutoSuggestion&#39;, &#39;ConditionalProcessor&#39;,</span>
<span class="gd">-    &#39;ShowLeadingWhiteSpaceProcessor&#39;, &#39;ShowTrailingWhiteSpaceProcessor&#39;,</span>
<span class="gd">-    &#39;TabsProcessor&#39;, &#39;ReverseSearchProcessor&#39;, &#39;DynamicProcessor&#39;,</span>
<span class="gd">-    &#39;merge_processors&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Processor&quot;,</span>
<span class="gi">+    &quot;TransformationInput&quot;,</span>
<span class="gi">+    &quot;Transformation&quot;,</span>
<span class="gi">+    &quot;DummyProcessor&quot;,</span>
<span class="gi">+    &quot;HighlightSearchProcessor&quot;,</span>
<span class="gi">+    &quot;HighlightIncrementalSearchProcessor&quot;,</span>
<span class="gi">+    &quot;HighlightSelectionProcessor&quot;,</span>
<span class="gi">+    &quot;PasswordProcessor&quot;,</span>
<span class="gi">+    &quot;HighlightMatchingBracketProcessor&quot;,</span>
<span class="gi">+    &quot;DisplayMultipleCursors&quot;,</span>
<span class="gi">+    &quot;BeforeInput&quot;,</span>
<span class="gi">+    &quot;ShowArg&quot;,</span>
<span class="gi">+    &quot;AfterInput&quot;,</span>
<span class="gi">+    &quot;AppendAutoSuggestion&quot;,</span>
<span class="gi">+    &quot;ConditionalProcessor&quot;,</span>
<span class="gi">+    &quot;ShowLeadingWhiteSpaceProcessor&quot;,</span>
<span class="gi">+    &quot;ShowTrailingWhiteSpaceProcessor&quot;,</span>
<span class="gi">+    &quot;TabsProcessor&quot;,</span>
<span class="gi">+    &quot;ReverseSearchProcessor&quot;,</span>
<span class="gi">+    &quot;DynamicProcessor&quot;,</span>
<span class="gi">+    &quot;merge_processors&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Processor(metaclass=ABCMeta):
<span class="gu">@@ -38,14 +61,15 @@ class Processor(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def apply_transformation(self, transformation_input: TransformationInput</span>
<span class="gd">-        ) -&gt;Transformation:</span>
<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Apply transformation. Returns a :class:`.Transformation` instance.

<span class="w"> </span>        :param transformation_input: :class:`.TransformationInput` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Transformation(transformation_input.fragments)</span>


<span class="w"> </span>SourceToDisplay = Callable[[int], int]
<span class="gu">@@ -63,9 +87,16 @@ class TransformationInput:</span>
<span class="w"> </span>        previous processor.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, buffer_control: BufferControl, document: Document,</span>
<span class="gd">-        lineno: int, source_to_display: SourceToDisplay, fragments:</span>
<span class="gd">-        StyleAndTextTuples, width: int, height: int) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        buffer_control: BufferControl,</span>
<span class="gi">+        document: Document,</span>
<span class="gi">+        lineno: int,</span>
<span class="gi">+        source_to_display: SourceToDisplay,</span>
<span class="gi">+        fragments: StyleAndTextTuples,</span>
<span class="gi">+        width: int,</span>
<span class="gi">+        height: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.buffer_control = buffer_control
<span class="w"> </span>        self.document = document
<span class="w"> </span>        self.lineno = lineno
<span class="gu">@@ -74,6 +105,21 @@ class TransformationInput:</span>
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.height = height

<span class="gi">+    def unpack(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; tuple[</span>
<span class="gi">+        BufferControl, Document, int, SourceToDisplay, StyleAndTextTuples, int, int</span>
<span class="gi">+    ]:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.buffer_control,</span>
<span class="gi">+            self.document,</span>
<span class="gi">+            self.lineno,</span>
<span class="gi">+            self.source_to_display,</span>
<span class="gi">+            self.fragments,</span>
<span class="gi">+            self.width,</span>
<span class="gi">+            self.height,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class Transformation:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -90,9 +136,12 @@ class Transformation:</span>
<span class="w"> </span>        original string.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, fragments: StyleAndTextTuples, source_to_display: (</span>
<span class="gd">-        SourceToDisplay | None)=None, display_to_source: (DisplayToSource |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fragments: StyleAndTextTuples,</span>
<span class="gi">+        source_to_display: SourceToDisplay | None = None,</span>
<span class="gi">+        display_to_source: DisplayToSource | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.fragments = fragments
<span class="w"> </span>        self.source_to_display = source_to_display or (lambda i: i)
<span class="w"> </span>        self.display_to_source = display_to_source or (lambda i: i)
<span class="gu">@@ -103,6 +152,11 @@ class DummyProcessor(Processor):</span>
<span class="w"> </span>    A `Processor` that doesn&#39;t do anything.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="gi">+        return Transformation(transformation_input.fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class HighlightSearchProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -112,14 +166,70 @@ class HighlightSearchProcessor(Processor):</span>
<span class="w"> </span>    The style classes &#39;search&#39; and &#39;search.current&#39; will be applied to the
<span class="w"> </span>    content.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _classname = &#39;search&#39;</span>
<span class="gd">-    _classname_current = &#39;search.current&#39;</span>

<span class="gd">-    def _get_search_text(self, buffer_control: BufferControl) -&gt;str:</span>
<span class="gi">+    _classname = &quot;search&quot;</span>
<span class="gi">+    _classname_current = &quot;search.current&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _get_search_text(self, buffer_control: BufferControl) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The text we are searching for.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return buffer_control.search_state.text</span>
<span class="gi">+</span>
<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="gi">+        (</span>
<span class="gi">+            buffer_control,</span>
<span class="gi">+            document,</span>
<span class="gi">+            lineno,</span>
<span class="gi">+            source_to_display,</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            _,</span>
<span class="gi">+            _,</span>
<span class="gi">+        ) = transformation_input.unpack()</span>
<span class="gi">+</span>
<span class="gi">+        search_text = self._get_search_text(buffer_control)</span>
<span class="gi">+        searchmatch_fragment = f&quot; class:{self._classname} &quot;</span>
<span class="gi">+        searchmatch_current_fragment = f&quot; class:{self._classname_current} &quot;</span>
<span class="gi">+</span>
<span class="gi">+        if search_text and not get_app().is_done:</span>
<span class="gi">+            # For each search match, replace the style string.</span>
<span class="gi">+            line_text = fragment_list_to_text(fragments)</span>
<span class="gi">+            fragments = explode_text_fragments(fragments)</span>
<span class="gi">+</span>
<span class="gi">+            if buffer_control.search_state.ignore_case():</span>
<span class="gi">+                flags = re.IGNORECASE</span>
<span class="gi">+            else:</span>
<span class="gi">+                flags = re.RegexFlag(0)</span>
<span class="gi">+</span>
<span class="gi">+            # Get cursor column.</span>
<span class="gi">+            cursor_column: int | None</span>
<span class="gi">+            if document.cursor_position_row == lineno:</span>
<span class="gi">+                cursor_column = source_to_display(document.cursor_position_col)</span>
<span class="gi">+            else:</span>
<span class="gi">+                cursor_column = None</span>
<span class="gi">+</span>
<span class="gi">+            for match in re.finditer(re.escape(search_text), line_text, flags=flags):</span>
<span class="gi">+                if cursor_column is not None:</span>
<span class="gi">+                    on_cursor = match.start() &lt;= cursor_column &lt; match.end()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    on_cursor = False</span>
<span class="gi">+</span>
<span class="gi">+                for i in range(match.start(), match.end()):</span>
<span class="gi">+                    old_fragment, text, *_ = fragments[i]</span>
<span class="gi">+                    if on_cursor:</span>
<span class="gi">+                        fragments[i] = (</span>
<span class="gi">+                            old_fragment + searchmatch_current_fragment,</span>
<span class="gi">+                            fragments[i][1],</span>
<span class="gi">+                        )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        fragments[i] = (</span>
<span class="gi">+                            old_fragment + searchmatch_fragment,</span>
<span class="gi">+                            fragments[i][1],</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments)</span>


<span class="w"> </span>class HighlightIncrementalSearchProcessor(HighlightSearchProcessor):
<span class="gu">@@ -131,14 +241,19 @@ class HighlightIncrementalSearchProcessor(HighlightSearchProcessor):</span>
<span class="w"> </span>    `BufferControl`. Otherwise, the cursor position won&#39;t be set to the search
<span class="w"> </span>    match while searching, and nothing happens.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _classname = &#39;incsearch&#39;</span>
<span class="gd">-    _classname_current = &#39;incsearch.current&#39;</span>

<span class="gd">-    def _get_search_text(self, buffer_control: BufferControl) -&gt;str:</span>
<span class="gi">+    _classname = &quot;incsearch&quot;</span>
<span class="gi">+    _classname_current = &quot;incsearch.current&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _get_search_text(self, buffer_control: BufferControl) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The text we are searching for.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # When the search buffer has focus, take that text.</span>
<span class="gi">+        search_buffer = buffer_control.search_buffer</span>
<span class="gi">+        if search_buffer is not None and search_buffer.text:</span>
<span class="gi">+            return search_buffer.text</span>
<span class="gi">+        return &quot;&quot;</span>


<span class="w"> </span>class HighlightSelectionProcessor(Processor):
<span class="gu">@@ -146,6 +261,45 @@ class HighlightSelectionProcessor(Processor):</span>
<span class="w"> </span>    Processor that highlights the selection in the document.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="gi">+        (</span>
<span class="gi">+            buffer_control,</span>
<span class="gi">+            document,</span>
<span class="gi">+            lineno,</span>
<span class="gi">+            source_to_display,</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            _,</span>
<span class="gi">+            _,</span>
<span class="gi">+        ) = transformation_input.unpack()</span>
<span class="gi">+</span>
<span class="gi">+        selected_fragment = &quot; class:selected &quot;</span>
<span class="gi">+</span>
<span class="gi">+        # In case of selection, highlight all matches.</span>
<span class="gi">+        selection_at_line = document.selection_range_at_line(lineno)</span>
<span class="gi">+</span>
<span class="gi">+        if selection_at_line:</span>
<span class="gi">+            from_, to = selection_at_line</span>
<span class="gi">+            from_ = source_to_display(from_)</span>
<span class="gi">+            to = source_to_display(to)</span>
<span class="gi">+</span>
<span class="gi">+            fragments = explode_text_fragments(fragments)</span>
<span class="gi">+</span>
<span class="gi">+            if from_ == 0 and to == 0 and len(fragments) == 0:</span>
<span class="gi">+                # When this is an empty line, insert a space in order to</span>
<span class="gi">+                # visualize the selection.</span>
<span class="gi">+                return Transformation([(selected_fragment, &quot; &quot;)])</span>
<span class="gi">+            else:</span>
<span class="gi">+                for i in range(from_, to):</span>
<span class="gi">+                    if i &lt; len(fragments):</span>
<span class="gi">+                        old_fragment, old_text, *_ = fragments[i]</span>
<span class="gi">+                        fragments[i] = (old_fragment + selected_fragment, old_text)</span>
<span class="gi">+                    elif i == len(fragments):</span>
<span class="gi">+                        fragments.append((selected_fragment, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class PasswordProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -154,9 +308,20 @@ class PasswordProcessor(Processor):</span>
<span class="w"> </span>    :param char: (string) Character to be used. &quot;*&quot; by default.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, char: str=&#39;*&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, char: str = &quot;*&quot;) -&gt; None:</span>
<span class="w"> </span>        self.char = char

<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        fragments: StyleAndTextTuples = cast(</span>
<span class="gi">+            StyleAndTextTuples,</span>
<span class="gi">+            [</span>
<span class="gi">+                (style, self.char * len(text), *handler)</span>
<span class="gi">+                for style, text, *handler in ti.fragments</span>
<span class="gi">+            ],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class HighlightMatchingBracketProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -169,21 +334,97 @@ class HighlightMatchingBracketProcessor(Processor):</span>
<span class="w"> </span>        to scan the whole document for matching brackets on each key press, so
<span class="w"> </span>        we limit to this value.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _closing_braces = &#39;])}&gt;&#39;</span>

<span class="gd">-    def __init__(self, chars: str=&#39;[](){}&lt;&gt;&#39;, max_cursor_distance: int=1000</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    _closing_braces = &quot;])}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, chars: str = &quot;[](){}&lt;&gt;&quot;, max_cursor_distance: int = 1000</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.chars = chars
<span class="w"> </span>        self.max_cursor_distance = max_cursor_distance
<span class="gd">-        self._positions_cache: SimpleCache[Hashable, list[tuple[int, int]]</span>
<span class="gd">-            ] = SimpleCache(maxsize=8)</span>

<span class="gd">-    def _get_positions_to_highlight(self, document: Document) -&gt;list[tuple[</span>
<span class="gd">-        int, int]]:</span>
<span class="gi">+        self._positions_cache: SimpleCache[</span>
<span class="gi">+            Hashable, list[tuple[int, int]]</span>
<span class="gi">+        ] = SimpleCache(maxsize=8)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_positions_to_highlight(self, document: Document) -&gt; list[tuple[int, int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of (row, col) tuples that need to be highlighted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pos: int | None</span>
<span class="gi">+</span>
<span class="gi">+        # Try for the character under the cursor.</span>
<span class="gi">+        if document.current_char and document.current_char in self.chars:</span>
<span class="gi">+            pos = document.find_matching_bracket_position(</span>
<span class="gi">+                start_pos=document.cursor_position - self.max_cursor_distance,</span>
<span class="gi">+                end_pos=document.cursor_position + self.max_cursor_distance,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Try for the character before the cursor.</span>
<span class="gi">+        elif (</span>
<span class="gi">+            document.char_before_cursor</span>
<span class="gi">+            and document.char_before_cursor in self._closing_braces</span>
<span class="gi">+            and document.char_before_cursor in self.chars</span>
<span class="gi">+        ):</span>
<span class="gi">+            document = Document(document.text, document.cursor_position - 1)</span>
<span class="gi">+</span>
<span class="gi">+            pos = document.find_matching_bracket_position(</span>
<span class="gi">+                start_pos=document.cursor_position - self.max_cursor_distance,</span>
<span class="gi">+                end_pos=document.cursor_position + self.max_cursor_distance,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            pos = None</span>
<span class="gi">+</span>
<span class="gi">+        # Return a list of (row, col) tuples that need to be highlighted.</span>
<span class="gi">+        if pos:</span>
<span class="gi">+            pos += document.cursor_position  # pos is relative.</span>
<span class="gi">+            row, col = document.translate_index_to_position(pos)</span>
<span class="gi">+            return [</span>
<span class="gi">+                (row, col),</span>
<span class="gi">+                (document.cursor_position_row, document.cursor_position_col),</span>
<span class="gi">+            ]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="gi">+        (</span>
<span class="gi">+            buffer_control,</span>
<span class="gi">+            document,</span>
<span class="gi">+            lineno,</span>
<span class="gi">+            source_to_display,</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            _,</span>
<span class="gi">+            _,</span>
<span class="gi">+        ) = transformation_input.unpack()</span>
<span class="gi">+</span>
<span class="gi">+        # When the application is in the &#39;done&#39; state, don&#39;t highlight.</span>
<span class="gi">+        if get_app().is_done:</span>
<span class="gi">+            return Transformation(fragments)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the highlight positions.</span>
<span class="gi">+        key = (get_app().render_counter, document.text, document.cursor_position)</span>
<span class="gi">+        positions = self._positions_cache.get(</span>
<span class="gi">+            key, lambda: self._get_positions_to_highlight(document)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Apply if positions were found at this line.</span>
<span class="gi">+        if positions:</span>
<span class="gi">+            for row, col in positions:</span>
<span class="gi">+                if row == lineno:</span>
<span class="gi">+                    col = source_to_display(col)</span>
<span class="gi">+                    fragments = explode_text_fragments(fragments)</span>
<span class="gi">+                    style, text, *_ = fragments[col]</span>
<span class="gi">+</span>
<span class="gi">+                    if col == document.cursor_position_col:</span>
<span class="gi">+                        style += &quot; class:matching-bracket.cursor &quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        style += &quot; class:matching-bracket.other &quot;</span>
<span class="gi">+</span>
<span class="gi">+                    fragments[col] = (style, text)</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments)</span>


<span class="w"> </span>class DisplayMultipleCursors(Processor):
<span class="gu">@@ -191,6 +432,49 @@ class DisplayMultipleCursors(Processor):</span>
<span class="w"> </span>    When we&#39;re in Vi block insert mode, display all the cursors.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="gi">+        (</span>
<span class="gi">+            buffer_control,</span>
<span class="gi">+            document,</span>
<span class="gi">+            lineno,</span>
<span class="gi">+            source_to_display,</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            _,</span>
<span class="gi">+            _,</span>
<span class="gi">+        ) = transformation_input.unpack()</span>
<span class="gi">+</span>
<span class="gi">+        buff = buffer_control.buffer</span>
<span class="gi">+</span>
<span class="gi">+        if vi_insert_multiple_mode():</span>
<span class="gi">+            cursor_positions = buff.multiple_cursor_positions</span>
<span class="gi">+            fragments = explode_text_fragments(fragments)</span>
<span class="gi">+</span>
<span class="gi">+            # If any cursor appears on the current line, highlight that.</span>
<span class="gi">+            start_pos = document.translate_row_col_to_index(lineno, 0)</span>
<span class="gi">+            end_pos = start_pos + len(document.lines[lineno])</span>
<span class="gi">+</span>
<span class="gi">+            fragment_suffix = &quot; class:multiple-cursors&quot;</span>
<span class="gi">+</span>
<span class="gi">+            for p in cursor_positions:</span>
<span class="gi">+                if start_pos &lt;= p &lt;= end_pos:</span>
<span class="gi">+                    column = source_to_display(p - start_pos)</span>
<span class="gi">+</span>
<span class="gi">+                    # Replace fragment.</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        style, text, *_ = fragments[column]</span>
<span class="gi">+                    except IndexError:</span>
<span class="gi">+                        # Cursor needs to be displayed after the current text.</span>
<span class="gi">+                        fragments.append((fragment_suffix, &quot; &quot;))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        style += fragment_suffix</span>
<span class="gi">+                        fragments[column] = (style, text)</span>
<span class="gi">+</span>
<span class="gi">+            return Transformation(fragments)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Transformation(fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class BeforeInput(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -201,12 +485,35 @@ class BeforeInput(Processor):</span>
<span class="w"> </span>    :param style: style to be applied to this prompt/prefix.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: AnyFormattedText, style: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, text: AnyFormattedText, style: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.style = style

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;BeforeInput({self.text!r}, {self.style!r})&#39;</span>
<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        source_to_display: SourceToDisplay | None</span>
<span class="gi">+        display_to_source: DisplayToSource | None</span>
<span class="gi">+</span>
<span class="gi">+        if ti.lineno == 0:</span>
<span class="gi">+            # Get fragments.</span>
<span class="gi">+            fragments_before = to_formatted_text(self.text, self.style)</span>
<span class="gi">+            fragments = fragments_before + ti.fragments</span>
<span class="gi">+</span>
<span class="gi">+            shift_position = fragment_list_len(fragments_before)</span>
<span class="gi">+            source_to_display = lambda i: i + shift_position</span>
<span class="gi">+            display_to_source = lambda i: i - shift_position</span>
<span class="gi">+        else:</span>
<span class="gi">+            fragments = ti.fragments</span>
<span class="gi">+            source_to_display = None</span>
<span class="gi">+            display_to_source = None</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            source_to_display=source_to_display,</span>
<span class="gi">+            display_to_source=display_to_source,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;BeforeInput({self.text!r}, {self.style!r})&quot;</span>


<span class="w"> </span>class ShowArg(BeforeInput):
<span class="gu">@@ -217,11 +524,24 @@ class ShowArg(BeforeInput):</span>
<span class="w"> </span>    `Window.get_line_prefix` function instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__(self._get_text_fragments)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;ShowArg()&#39;</span>
<span class="gi">+    def _get_text_fragments(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        if app.key_processor.arg is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            arg = app.key_processor.arg</span>
<span class="gi">+</span>
<span class="gi">+            return [</span>
<span class="gi">+                (&quot;class:prompt.arg&quot;, &quot;(arg: &quot;),</span>
<span class="gi">+                (&quot;class:prompt.arg.text&quot;, str(arg)),</span>
<span class="gi">+                (&quot;class:prompt.arg&quot;, &quot;) &quot;),</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;ShowArg()&quot;</span>


<span class="w"> </span>class AfterInput(Processor):
<span class="gu">@@ -233,13 +553,21 @@ class AfterInput(Processor):</span>
<span class="w"> </span>    :param style: style to be applied to this prompt/prefix.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: AnyFormattedText, style: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, text: AnyFormattedText, style: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.style = style

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}({self.text!r}, style={self.style!r})&#39;)</span>
<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        # Insert fragments after the last line.</span>
<span class="gi">+        if ti.lineno == ti.document.line_count - 1:</span>
<span class="gi">+            # Get fragments.</span>
<span class="gi">+            fragments_after = to_formatted_text(self.text, self.style)</span>
<span class="gi">+            return Transformation(fragments=ti.fragments + fragments_after)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Transformation(fragments=ti.fragments)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.text!r}, style={self.style!r})&quot;</span>


<span class="w"> </span>class AppendAutoSuggestion(Processor):
<span class="gu">@@ -248,9 +576,23 @@ class AppendAutoSuggestion(Processor):</span>
<span class="w"> </span>    (The user can then press the right arrow the insert the suggestion.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, style: str=&#39;class:auto-suggestion&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, style: str = &quot;class:auto-suggestion&quot;) -&gt; None:</span>
<span class="w"> </span>        self.style = style

<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        # Insert fragments after the last line.</span>
<span class="gi">+        if ti.lineno == ti.document.line_count - 1:</span>
<span class="gi">+            buffer = ti.buffer_control.buffer</span>
<span class="gi">+</span>
<span class="gi">+            if buffer.suggestion and ti.document.is_cursor_at_the_end:</span>
<span class="gi">+                suggestion = buffer.suggestion.text</span>
<span class="gi">+            else:</span>
<span class="gi">+                suggestion = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+            return Transformation(fragments=ti.fragments + [(self.style, suggestion)])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Transformation(fragments=ti.fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class ShowLeadingWhiteSpaceProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -259,17 +601,36 @@ class ShowLeadingWhiteSpaceProcessor(Processor):</span>
<span class="w"> </span>    :param get_char: Callable that returns one character.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_char: (Callable[[], str] | None)=None, style:</span>
<span class="gd">-        str=&#39;class:leading-whitespace&#39;) -&gt;None:</span>
<span class="gd">-</span>
<span class="gd">-        def default_get_char() -&gt;str:</span>
<span class="gd">-            if &#39;·&#39;.encode(get_app().output.encoding(), &#39;replace&#39;) == b&#39;?&#39;:</span>
<span class="gd">-                return &#39;.&#39;</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_char: Callable[[], str] | None = None,</span>
<span class="gi">+        style: str = &quot;class:leading-whitespace&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        def default_get_char() -&gt; str:</span>
<span class="gi">+            if &quot;\xb7&quot;.encode(get_app().output.encoding(), &quot;replace&quot;) == b&quot;?&quot;:</span>
<span class="gi">+                return &quot;.&quot;</span>
<span class="w"> </span>            else:
<span class="gd">-                return &#39;·&#39;</span>
<span class="gi">+                return &quot;\xb7&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.get_char = get_char or default_get_char

<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        fragments = ti.fragments</span>
<span class="gi">+</span>
<span class="gi">+        # Walk through all te fragments.</span>
<span class="gi">+        if fragments and fragment_list_to_text(fragments).startswith(&quot; &quot;):</span>
<span class="gi">+            t = (self.style, self.get_char())</span>
<span class="gi">+            fragments = explode_text_fragments(fragments)</span>
<span class="gi">+</span>
<span class="gi">+            for i in range(len(fragments)):</span>
<span class="gi">+                if fragments[i][1] == &quot; &quot;:</span>
<span class="gi">+                    fragments[i] = t</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class ShowTrailingWhiteSpaceProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -278,17 +639,37 @@ class ShowTrailingWhiteSpaceProcessor(Processor):</span>
<span class="w"> </span>    :param get_char: Callable that returns one character.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_char: (Callable[[], str] | None)=None, style:</span>
<span class="gd">-        str=&#39;class:training-whitespace&#39;) -&gt;None:</span>
<span class="gd">-</span>
<span class="gd">-        def default_get_char() -&gt;str:</span>
<span class="gd">-            if &#39;·&#39;.encode(get_app().output.encoding(), &#39;replace&#39;) == b&#39;?&#39;:</span>
<span class="gd">-                return &#39;.&#39;</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_char: Callable[[], str] | None = None,</span>
<span class="gi">+        style: str = &quot;class:training-whitespace&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        def default_get_char() -&gt; str:</span>
<span class="gi">+            if &quot;\xb7&quot;.encode(get_app().output.encoding(), &quot;replace&quot;) == b&quot;?&quot;:</span>
<span class="gi">+                return &quot;.&quot;</span>
<span class="w"> </span>            else:
<span class="gd">-                return &#39;·&#39;</span>
<span class="gi">+                return &quot;\xb7&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.get_char = get_char or default_get_char

<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        fragments = ti.fragments</span>
<span class="gi">+</span>
<span class="gi">+        if fragments and fragments[-1][1].endswith(&quot; &quot;):</span>
<span class="gi">+            t = (self.style, self.get_char())</span>
<span class="gi">+            fragments = explode_text_fragments(fragments)</span>
<span class="gi">+</span>
<span class="gi">+            # Walk backwards through all te fragments and replace whitespace.</span>
<span class="gi">+            for i in range(len(fragments) - 1, -1, -1):</span>
<span class="gi">+                char = fragments[i][1]</span>
<span class="gi">+                if char == &quot; &quot;:</span>
<span class="gi">+                    fragments[i] = t</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments)</span>
<span class="gi">+</span>

<span class="w"> </span>class TabsProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -302,14 +683,76 @@ class TabsProcessor(Processor):</span>
<span class="w"> </span>    :param char2: Like `char1`, but for the rest of the space.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, tabstop: (int | Callable[[], int])=4, char1: (str |</span>
<span class="gd">-        Callable[[], str])=&#39;|&#39;, char2: (str | Callable[[], str])=&#39;┈&#39;, style:</span>
<span class="gd">-        str=&#39;class:tab&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        tabstop: int | Callable[[], int] = 4,</span>
<span class="gi">+        char1: str | Callable[[], str] = &quot;|&quot;,</span>
<span class="gi">+        char2: str | Callable[[], str] = &quot;\u2508&quot;,</span>
<span class="gi">+        style: str = &quot;class:tab&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.char1 = char1
<span class="w"> </span>        self.char2 = char2
<span class="w"> </span>        self.tabstop = tabstop
<span class="w"> </span>        self.style = style

<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        tabstop = to_int(self.tabstop)</span>
<span class="gi">+        style = self.style</span>
<span class="gi">+</span>
<span class="gi">+        # Create separator for tabs.</span>
<span class="gi">+        separator1 = to_str(self.char1)</span>
<span class="gi">+        separator2 = to_str(self.char2)</span>
<span class="gi">+</span>
<span class="gi">+        # Transform fragments.</span>
<span class="gi">+        fragments = explode_text_fragments(ti.fragments)</span>
<span class="gi">+</span>
<span class="gi">+        position_mappings = {}</span>
<span class="gi">+        result_fragments: StyleAndTextTuples = []</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+</span>
<span class="gi">+        for i, fragment_and_text in enumerate(fragments):</span>
<span class="gi">+            position_mappings[i] = pos</span>
<span class="gi">+</span>
<span class="gi">+            if fragment_and_text[1] == &quot;\t&quot;:</span>
<span class="gi">+                # Calculate how many characters we have to insert.</span>
<span class="gi">+                count = tabstop - (pos % tabstop)</span>
<span class="gi">+                if count == 0:</span>
<span class="gi">+                    count = tabstop</span>
<span class="gi">+</span>
<span class="gi">+                # Insert tab.</span>
<span class="gi">+                result_fragments.append((style, separator1))</span>
<span class="gi">+                result_fragments.append((style, separator2 * (count - 1)))</span>
<span class="gi">+                pos += count</span>
<span class="gi">+            else:</span>
<span class="gi">+                result_fragments.append(fragment_and_text)</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+</span>
<span class="gi">+        position_mappings[len(fragments)] = pos</span>
<span class="gi">+        # Add `pos+1` to mapping, because the cursor can be right after the</span>
<span class="gi">+        # line as well.</span>
<span class="gi">+        position_mappings[len(fragments) + 1] = pos + 1</span>
<span class="gi">+</span>
<span class="gi">+        def source_to_display(from_position: int) -&gt; int:</span>
<span class="gi">+            &quot;Maps original cursor position to the new one.&quot;</span>
<span class="gi">+            return position_mappings[from_position]</span>
<span class="gi">+</span>
<span class="gi">+        def display_to_source(display_pos: int) -&gt; int:</span>
<span class="gi">+            &quot;Maps display cursor position to the original one.&quot;</span>
<span class="gi">+            position_mappings_reversed = {v: k for k, v in position_mappings.items()}</span>
<span class="gi">+</span>
<span class="gi">+            while display_pos &gt;= 0:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return position_mappings_reversed[display_pos]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    display_pos -= 1</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(</span>
<span class="gi">+            result_fragments,</span>
<span class="gi">+            source_to_display=source_to_display,</span>
<span class="gi">+            display_to_source=display_to_source,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class ReverseSearchProcessor(Processor):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -319,9 +762,133 @@ class ReverseSearchProcessor(Processor):</span>
<span class="w"> </span>    Note: This processor is meant to be applied to the BufferControl that
<span class="w"> </span>    contains the search buffer, it&#39;s not meant for the original input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _excluded_input_processors: list[type[Processor]] = [
<span class="gd">-        HighlightSearchProcessor, HighlightSelectionProcessor, BeforeInput,</span>
<span class="gd">-        AfterInput]</span>
<span class="gi">+        HighlightSearchProcessor,</span>
<span class="gi">+        HighlightSelectionProcessor,</span>
<span class="gi">+        BeforeInput,</span>
<span class="gi">+        AfterInput,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_main_buffer(self, buffer_control: BufferControl) -&gt; BufferControl | None:</span>
<span class="gi">+        from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+</span>
<span class="gi">+        prev_control = get_app().layout.search_target_buffer_control</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(prev_control, BufferControl)</span>
<span class="gi">+            and prev_control.search_buffer_control == buffer_control</span>
<span class="gi">+        ):</span>
<span class="gi">+            return prev_control</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _content(</span>
<span class="gi">+        self, main_control: BufferControl, ti: TransformationInput</span>
<span class="gi">+    ) -&gt; UIContent:</span>
<span class="gi">+        from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+</span>
<span class="gi">+        # Emulate the BufferControl through which we are searching.</span>
<span class="gi">+        # For this we filter out some of the input processors.</span>
<span class="gi">+        excluded_processors = tuple(self._excluded_input_processors)</span>
<span class="gi">+</span>
<span class="gi">+        def filter_processor(item: Processor) -&gt; Processor | None:</span>
<span class="gi">+            &quot;&quot;&quot;Filter processors from the main control that we want to disable</span>
<span class="gi">+            here. This returns either an accepted processor or None.&quot;&quot;&quot;</span>
<span class="gi">+            # For a `_MergedProcessor`, check each individual processor, recursively.</span>
<span class="gi">+            if isinstance(item, _MergedProcessor):</span>
<span class="gi">+                accepted_processors = [filter_processor(p) for p in item.processors]</span>
<span class="gi">+                return merge_processors(</span>
<span class="gi">+                    [p for p in accepted_processors if p is not None]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # For a `ConditionalProcessor`, check the body.</span>
<span class="gi">+            elif isinstance(item, ConditionalProcessor):</span>
<span class="gi">+                p = filter_processor(item.processor)</span>
<span class="gi">+                if p:</span>
<span class="gi">+                    return ConditionalProcessor(p, item.filter)</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise, check the processor itself.</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not isinstance(item, excluded_processors):</span>
<span class="gi">+                    return item</span>
<span class="gi">+</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        filtered_processor = filter_processor(</span>
<span class="gi">+            merge_processors(main_control.input_processors or [])</span>
<span class="gi">+        )</span>
<span class="gi">+        highlight_processor = HighlightIncrementalSearchProcessor()</span>
<span class="gi">+</span>
<span class="gi">+        if filtered_processor:</span>
<span class="gi">+            new_processors = [filtered_processor, highlight_processor]</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_processors = [highlight_processor]</span>
<span class="gi">+</span>
<span class="gi">+        from .controls import SearchBufferControl</span>
<span class="gi">+</span>
<span class="gi">+        assert isinstance(ti.buffer_control, SearchBufferControl)</span>
<span class="gi">+</span>
<span class="gi">+        buffer_control = BufferControl(</span>
<span class="gi">+            buffer=main_control.buffer,</span>
<span class="gi">+            input_processors=new_processors,</span>
<span class="gi">+            include_default_input_processors=False,</span>
<span class="gi">+            lexer=main_control.lexer,</span>
<span class="gi">+            preview_search=True,</span>
<span class="gi">+            search_buffer_control=ti.buffer_control,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return buffer_control.create_content(ti.width, ti.height, preview_search=True)</span>
<span class="gi">+</span>
<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        from .controls import SearchBufferControl</span>
<span class="gi">+</span>
<span class="gi">+        assert isinstance(</span>
<span class="gi">+            ti.buffer_control, SearchBufferControl</span>
<span class="gi">+        ), &quot;`ReverseSearchProcessor` should be applied to a `SearchBufferControl` only.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        source_to_display: SourceToDisplay | None</span>
<span class="gi">+        display_to_source: DisplayToSource | None</span>
<span class="gi">+</span>
<span class="gi">+        main_control = self._get_main_buffer(ti.buffer_control)</span>
<span class="gi">+</span>
<span class="gi">+        if ti.lineno == 0 and main_control:</span>
<span class="gi">+            content = self._content(main_control, ti)</span>
<span class="gi">+</span>
<span class="gi">+            # Get the line from the original document for this search.</span>
<span class="gi">+            line_fragments = content.get_line(content.cursor_position.y)</span>
<span class="gi">+</span>
<span class="gi">+            if main_control.search_state.direction == SearchDirection.FORWARD:</span>
<span class="gi">+                direction_text = &quot;i-search&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                direction_text = &quot;reverse-i-search&quot;</span>
<span class="gi">+</span>
<span class="gi">+            fragments_before: StyleAndTextTuples = [</span>
<span class="gi">+                (&quot;class:prompt.search&quot;, &quot;(&quot;),</span>
<span class="gi">+                (&quot;class:prompt.search&quot;, direction_text),</span>
<span class="gi">+                (&quot;class:prompt.search&quot;, &quot;)`&quot;),</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+            fragments = (</span>
<span class="gi">+                fragments_before</span>
<span class="gi">+                + [</span>
<span class="gi">+                    (&quot;class:prompt.search.text&quot;, fragment_list_to_text(ti.fragments)),</span>
<span class="gi">+                    (&quot;&quot;, &quot;&#39;: &quot;),</span>
<span class="gi">+                ]</span>
<span class="gi">+                + line_fragments</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            shift_position = fragment_list_len(fragments_before)</span>
<span class="gi">+            source_to_display = lambda i: i + shift_position</span>
<span class="gi">+            display_to_source = lambda i: i - shift_position</span>
<span class="gi">+        else:</span>
<span class="gi">+            source_to_display = None</span>
<span class="gi">+            display_to_source = None</span>
<span class="gi">+            fragments = ti.fragments</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            source_to_display=source_to_display,</span>
<span class="gi">+            display_to_source=display_to_source,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ConditionalProcessor(Processor):
<span class="gu">@@ -343,13 +910,25 @@ class ConditionalProcessor(Processor):</span>
<span class="w"> </span>    :param filter: :class:`~prompt_toolkit.filters.Filter` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, processor: Processor, filter: FilterOrBool) -&gt;None:</span>
<span class="gi">+    def __init__(self, processor: Processor, filter: FilterOrBool) -&gt; None:</span>
<span class="w"> </span>        self.processor = processor
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(processor={!r}, filter={!r})&#39;.format(self.__class__.</span>
<span class="gd">-            __name__, self.processor, self.filter)</span>
<span class="gi">+    def apply_transformation(</span>
<span class="gi">+        self, transformation_input: TransformationInput</span>
<span class="gi">+    ) -&gt; Transformation:</span>
<span class="gi">+        # Run processor when enabled.</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.processor.apply_transformation(transformation_input)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Transformation(transformation_input.fragments)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(processor={!r}, filter={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.processor,</span>
<span class="gi">+            self.filter,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class DynamicProcessor(Processor):
<span class="gu">@@ -359,15 +938,25 @@ class DynamicProcessor(Processor):</span>
<span class="w"> </span>    :param get_processor: Callable that returns a :class:`.Processor` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_processor: Callable[[], Processor | None]) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_processor: Callable[[], Processor | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_processor = get_processor

<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        processor = self.get_processor() or DummyProcessor()</span>
<span class="gi">+        return processor.apply_transformation(ti)</span>
<span class="gi">+</span>

<span class="gd">-def merge_processors(processors: list[Processor]) -&gt;Processor:</span>
<span class="gi">+def merge_processors(processors: list[Processor]) -&gt; Processor:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple `Processor` objects into one.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(processors) == 0:</span>
<span class="gi">+        return DummyProcessor()</span>
<span class="gi">+</span>
<span class="gi">+    if len(processors) == 1:</span>
<span class="gi">+        return processors[0]  # Nothing to merge.</span>
<span class="gi">+</span>
<span class="gi">+    return _MergedProcessor(processors)</span>


<span class="w"> </span>class _MergedProcessor(Processor):
<span class="gu">@@ -378,3 +967,47 @@ class _MergedProcessor(Processor):</span>

<span class="w"> </span>    def __init__(self, processors: list[Processor]):
<span class="w"> </span>        self.processors = processors
<span class="gi">+</span>
<span class="gi">+    def apply_transformation(self, ti: TransformationInput) -&gt; Transformation:</span>
<span class="gi">+        source_to_display_functions = [ti.source_to_display]</span>
<span class="gi">+        display_to_source_functions = []</span>
<span class="gi">+        fragments = ti.fragments</span>
<span class="gi">+</span>
<span class="gi">+        def source_to_display(i: int) -&gt; int:</span>
<span class="gi">+            &quot;&quot;&quot;Translate x position from the buffer to the x position in the</span>
<span class="gi">+            processor fragments list.&quot;&quot;&quot;</span>
<span class="gi">+            for f in source_to_display_functions:</span>
<span class="gi">+                i = f(i)</span>
<span class="gi">+            return i</span>
<span class="gi">+</span>
<span class="gi">+        for p in self.processors:</span>
<span class="gi">+            transformation = p.apply_transformation(</span>
<span class="gi">+                TransformationInput(</span>
<span class="gi">+                    ti.buffer_control,</span>
<span class="gi">+                    ti.document,</span>
<span class="gi">+                    ti.lineno,</span>
<span class="gi">+                    source_to_display,</span>
<span class="gi">+                    fragments,</span>
<span class="gi">+                    ti.width,</span>
<span class="gi">+                    ti.height,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            fragments = transformation.fragments</span>
<span class="gi">+            display_to_source_functions.append(transformation.display_to_source)</span>
<span class="gi">+            source_to_display_functions.append(transformation.source_to_display)</span>
<span class="gi">+</span>
<span class="gi">+        def display_to_source(i: int) -&gt; int:</span>
<span class="gi">+            for f in reversed(display_to_source_functions):</span>
<span class="gi">+                i = f(i)</span>
<span class="gi">+            return i</span>
<span class="gi">+</span>
<span class="gi">+        # In the case of a nested _MergedProcessor, each processor wants to</span>
<span class="gi">+        # receive a &#39;source_to_display&#39; function (as part of the</span>
<span class="gi">+        # TransformationInput) that has everything in the chain before</span>
<span class="gi">+        # included, because it can be called as part of the</span>
<span class="gi">+        # `apply_transformation` function. However, this first</span>
<span class="gi">+        # `source_to_display` should not be part of the output that we are</span>
<span class="gi">+        # returning. (This is the most consistent with `display_to_source`.)</span>
<span class="gi">+        del source_to_display_functions[:1]</span>
<span class="gi">+</span>
<span class="gi">+        return Transformation(fragments, source_to_display, display_to_source)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/screen.py b/src/prompt_toolkit/layout/screen.py</span>
<span class="gh">index 29cbf2a9..49aebbd6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/screen.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/screen.py</span>
<span class="gu">@@ -1,12 +1,20 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cache import FastDictCache
<span class="w"> </span>from prompt_toolkit.data_structures import Point
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .containers import Window
<span class="gd">-__all__ = [&#39;Screen&#39;, &#39;Char&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Screen&quot;,</span>
<span class="gi">+    &quot;Char&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Char:
<span class="gu">@@ -18,45 +26,125 @@ class Char:</span>
<span class="w"> </span>    :param char: A single character (can be a double-width character).
<span class="w"> </span>    :param style: A style string. (Can contain classnames.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;char&#39;, &#39;style&#39;, &#39;width&#39;</span>
<span class="gd">-    display_mappings: dict[str, str] = {&#39;\x00&#39;: &#39;^@&#39;, &#39;\x01&#39;: &#39;^A&#39;, &#39;\x02&#39;:</span>
<span class="gd">-        &#39;^B&#39;, &#39;\x03&#39;: &#39;^C&#39;, &#39;\x04&#39;: &#39;^D&#39;, &#39;\x05&#39;: &#39;^E&#39;, &#39;\x06&#39;: &#39;^F&#39;,</span>
<span class="gd">-        &#39;\x07&#39;: &#39;^G&#39;, &#39;\x08&#39;: &#39;^H&#39;, &#39;\t&#39;: &#39;^I&#39;, &#39;\n&#39;: &#39;^J&#39;, &#39;\x0b&#39;: &#39;^K&#39;,</span>
<span class="gd">-        &#39;\x0c&#39;: &#39;^L&#39;, &#39;\r&#39;: &#39;^M&#39;, &#39;\x0e&#39;: &#39;^N&#39;, &#39;\x0f&#39;: &#39;^O&#39;, &#39;\x10&#39;: &#39;^P&#39;,</span>
<span class="gd">-        &#39;\x11&#39;: &#39;^Q&#39;, &#39;\x12&#39;: &#39;^R&#39;, &#39;\x13&#39;: &#39;^S&#39;, &#39;\x14&#39;: &#39;^T&#39;, &#39;\x15&#39;:</span>
<span class="gd">-        &#39;^U&#39;, &#39;\x16&#39;: &#39;^V&#39;, &#39;\x17&#39;: &#39;^W&#39;, &#39;\x18&#39;: &#39;^X&#39;, &#39;\x19&#39;: &#39;^Y&#39;,</span>
<span class="gd">-        &#39;\x1a&#39;: &#39;^Z&#39;, &#39;\x1b&#39;: &#39;^[&#39;, &#39;\x1c&#39;: &#39;^\\&#39;, &#39;\x1d&#39;: &#39;^]&#39;, &#39;\x1e&#39;:</span>
<span class="gd">-        &#39;^^&#39;, &#39;\x1f&#39;: &#39;^_&#39;, &#39;\x7f&#39;: &#39;^?&#39;, &#39;\x80&#39;: &#39;&lt;80&gt;&#39;, &#39;\x81&#39;: &#39;&lt;81&gt;&#39;,</span>
<span class="gd">-        &#39;\x82&#39;: &#39;&lt;82&gt;&#39;, &#39;\x83&#39;: &#39;&lt;83&gt;&#39;, &#39;\x84&#39;: &#39;&lt;84&gt;&#39;, &#39;\x85&#39;: &#39;&lt;85&gt;&#39;,</span>
<span class="gd">-        &#39;\x86&#39;: &#39;&lt;86&gt;&#39;, &#39;\x87&#39;: &#39;&lt;87&gt;&#39;, &#39;\x88&#39;: &#39;&lt;88&gt;&#39;, &#39;\x89&#39;: &#39;&lt;89&gt;&#39;,</span>
<span class="gd">-        &#39;\x8a&#39;: &#39;&lt;8a&gt;&#39;, &#39;\x8b&#39;: &#39;&lt;8b&gt;&#39;, &#39;\x8c&#39;: &#39;&lt;8c&gt;&#39;, &#39;\x8d&#39;: &#39;&lt;8d&gt;&#39;,</span>
<span class="gd">-        &#39;\x8e&#39;: &#39;&lt;8e&gt;&#39;, &#39;\x8f&#39;: &#39;&lt;8f&gt;&#39;, &#39;\x90&#39;: &#39;&lt;90&gt;&#39;, &#39;\x91&#39;: &#39;&lt;91&gt;&#39;,</span>
<span class="gd">-        &#39;\x92&#39;: &#39;&lt;92&gt;&#39;, &#39;\x93&#39;: &#39;&lt;93&gt;&#39;, &#39;\x94&#39;: &#39;&lt;94&gt;&#39;, &#39;\x95&#39;: &#39;&lt;95&gt;&#39;,</span>
<span class="gd">-        &#39;\x96&#39;: &#39;&lt;96&gt;&#39;, &#39;\x97&#39;: &#39;&lt;97&gt;&#39;, &#39;\x98&#39;: &#39;&lt;98&gt;&#39;, &#39;\x99&#39;: &#39;&lt;99&gt;&#39;,</span>
<span class="gd">-        &#39;\x9a&#39;: &#39;&lt;9a&gt;&#39;, &#39;\x9b&#39;: &#39;&lt;9b&gt;&#39;, &#39;\x9c&#39;: &#39;&lt;9c&gt;&#39;, &#39;\x9d&#39;: &#39;&lt;9d&gt;&#39;,</span>
<span class="gd">-        &#39;\x9e&#39;: &#39;&lt;9e&gt;&#39;, &#39;\x9f&#39;: &#39;&lt;9f&gt;&#39;, &#39;\xa0&#39;: &#39; &#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, char: str=&#39; &#39;, style: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;char&quot;, &quot;style&quot;, &quot;width&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # If we end up having one of these special control sequences in the input string,</span>
<span class="gi">+    # we should display them as follows:</span>
<span class="gi">+    # Usually this happens after a &quot;quoted insert&quot;.</span>
<span class="gi">+    display_mappings: dict[str, str] = {</span>
<span class="gi">+        &quot;\x00&quot;: &quot;^@&quot;,  # Control space</span>
<span class="gi">+        &quot;\x01&quot;: &quot;^A&quot;,</span>
<span class="gi">+        &quot;\x02&quot;: &quot;^B&quot;,</span>
<span class="gi">+        &quot;\x03&quot;: &quot;^C&quot;,</span>
<span class="gi">+        &quot;\x04&quot;: &quot;^D&quot;,</span>
<span class="gi">+        &quot;\x05&quot;: &quot;^E&quot;,</span>
<span class="gi">+        &quot;\x06&quot;: &quot;^F&quot;,</span>
<span class="gi">+        &quot;\x07&quot;: &quot;^G&quot;,</span>
<span class="gi">+        &quot;\x08&quot;: &quot;^H&quot;,</span>
<span class="gi">+        &quot;\x09&quot;: &quot;^I&quot;,</span>
<span class="gi">+        &quot;\x0a&quot;: &quot;^J&quot;,</span>
<span class="gi">+        &quot;\x0b&quot;: &quot;^K&quot;,</span>
<span class="gi">+        &quot;\x0c&quot;: &quot;^L&quot;,</span>
<span class="gi">+        &quot;\x0d&quot;: &quot;^M&quot;,</span>
<span class="gi">+        &quot;\x0e&quot;: &quot;^N&quot;,</span>
<span class="gi">+        &quot;\x0f&quot;: &quot;^O&quot;,</span>
<span class="gi">+        &quot;\x10&quot;: &quot;^P&quot;,</span>
<span class="gi">+        &quot;\x11&quot;: &quot;^Q&quot;,</span>
<span class="gi">+        &quot;\x12&quot;: &quot;^R&quot;,</span>
<span class="gi">+        &quot;\x13&quot;: &quot;^S&quot;,</span>
<span class="gi">+        &quot;\x14&quot;: &quot;^T&quot;,</span>
<span class="gi">+        &quot;\x15&quot;: &quot;^U&quot;,</span>
<span class="gi">+        &quot;\x16&quot;: &quot;^V&quot;,</span>
<span class="gi">+        &quot;\x17&quot;: &quot;^W&quot;,</span>
<span class="gi">+        &quot;\x18&quot;: &quot;^X&quot;,</span>
<span class="gi">+        &quot;\x19&quot;: &quot;^Y&quot;,</span>
<span class="gi">+        &quot;\x1a&quot;: &quot;^Z&quot;,</span>
<span class="gi">+        &quot;\x1b&quot;: &quot;^[&quot;,  # Escape</span>
<span class="gi">+        &quot;\x1c&quot;: &quot;^\\&quot;,</span>
<span class="gi">+        &quot;\x1d&quot;: &quot;^]&quot;,</span>
<span class="gi">+        &quot;\x1e&quot;: &quot;^^&quot;,</span>
<span class="gi">+        &quot;\x1f&quot;: &quot;^_&quot;,</span>
<span class="gi">+        &quot;\x7f&quot;: &quot;^?&quot;,  # ASCII Delete (backspace).</span>
<span class="gi">+        # Special characters. All visualized like Vim does.</span>
<span class="gi">+        &quot;\x80&quot;: &quot;&lt;80&gt;&quot;,</span>
<span class="gi">+        &quot;\x81&quot;: &quot;&lt;81&gt;&quot;,</span>
<span class="gi">+        &quot;\x82&quot;: &quot;&lt;82&gt;&quot;,</span>
<span class="gi">+        &quot;\x83&quot;: &quot;&lt;83&gt;&quot;,</span>
<span class="gi">+        &quot;\x84&quot;: &quot;&lt;84&gt;&quot;,</span>
<span class="gi">+        &quot;\x85&quot;: &quot;&lt;85&gt;&quot;,</span>
<span class="gi">+        &quot;\x86&quot;: &quot;&lt;86&gt;&quot;,</span>
<span class="gi">+        &quot;\x87&quot;: &quot;&lt;87&gt;&quot;,</span>
<span class="gi">+        &quot;\x88&quot;: &quot;&lt;88&gt;&quot;,</span>
<span class="gi">+        &quot;\x89&quot;: &quot;&lt;89&gt;&quot;,</span>
<span class="gi">+        &quot;\x8a&quot;: &quot;&lt;8a&gt;&quot;,</span>
<span class="gi">+        &quot;\x8b&quot;: &quot;&lt;8b&gt;&quot;,</span>
<span class="gi">+        &quot;\x8c&quot;: &quot;&lt;8c&gt;&quot;,</span>
<span class="gi">+        &quot;\x8d&quot;: &quot;&lt;8d&gt;&quot;,</span>
<span class="gi">+        &quot;\x8e&quot;: &quot;&lt;8e&gt;&quot;,</span>
<span class="gi">+        &quot;\x8f&quot;: &quot;&lt;8f&gt;&quot;,</span>
<span class="gi">+        &quot;\x90&quot;: &quot;&lt;90&gt;&quot;,</span>
<span class="gi">+        &quot;\x91&quot;: &quot;&lt;91&gt;&quot;,</span>
<span class="gi">+        &quot;\x92&quot;: &quot;&lt;92&gt;&quot;,</span>
<span class="gi">+        &quot;\x93&quot;: &quot;&lt;93&gt;&quot;,</span>
<span class="gi">+        &quot;\x94&quot;: &quot;&lt;94&gt;&quot;,</span>
<span class="gi">+        &quot;\x95&quot;: &quot;&lt;95&gt;&quot;,</span>
<span class="gi">+        &quot;\x96&quot;: &quot;&lt;96&gt;&quot;,</span>
<span class="gi">+        &quot;\x97&quot;: &quot;&lt;97&gt;&quot;,</span>
<span class="gi">+        &quot;\x98&quot;: &quot;&lt;98&gt;&quot;,</span>
<span class="gi">+        &quot;\x99&quot;: &quot;&lt;99&gt;&quot;,</span>
<span class="gi">+        &quot;\x9a&quot;: &quot;&lt;9a&gt;&quot;,</span>
<span class="gi">+        &quot;\x9b&quot;: &quot;&lt;9b&gt;&quot;,</span>
<span class="gi">+        &quot;\x9c&quot;: &quot;&lt;9c&gt;&quot;,</span>
<span class="gi">+        &quot;\x9d&quot;: &quot;&lt;9d&gt;&quot;,</span>
<span class="gi">+        &quot;\x9e&quot;: &quot;&lt;9e&gt;&quot;,</span>
<span class="gi">+        &quot;\x9f&quot;: &quot;&lt;9f&gt;&quot;,</span>
<span class="gi">+        # For the non-breaking space: visualize like Emacs does by default.</span>
<span class="gi">+        # (Print a space, but attach the &#39;nbsp&#39; class that applies the</span>
<span class="gi">+        # underline style.)</span>
<span class="gi">+        &quot;\xa0&quot;: &quot; &quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, char: str = &quot; &quot;, style: str = &quot;&quot;) -&gt; None:</span>
<span class="gi">+        # If this character has to be displayed otherwise, take that one.</span>
<span class="w"> </span>        if char in self.display_mappings:
<span class="gd">-            if char == &#39;\xa0&#39;:</span>
<span class="gd">-                style += &#39; class:nbsp &#39;</span>
<span class="gi">+            if char == &quot;\xa0&quot;:</span>
<span class="gi">+                style += &quot; class:nbsp &quot;  # Will be underlined.</span>
<span class="w"> </span>            else:
<span class="gd">-                style += &#39; class:control-character &#39;</span>
<span class="gi">+                style += &quot; class:control-character &quot;</span>
<span class="gi">+</span>
<span class="w"> </span>            char = self.display_mappings[char]
<span class="gi">+</span>
<span class="w"> </span>        self.char = char
<span class="w"> </span>        self.style = style
<span class="gi">+</span>
<span class="gi">+        # Calculate width. (We always need this, so better to store it directly</span>
<span class="gi">+        # as a member for performance.)</span>
<span class="w"> </span>        self.width = get_cwidth(char)
<span class="gi">+</span>
<span class="gi">+    # In theory, `other` can be any type of object, but because of performance</span>
<span class="gi">+    # we don&#39;t want to do an `isinstance` check every time. We assume &quot;other&quot;</span>
<span class="gi">+    # is always a &quot;Char&quot;.</span>
<span class="gi">+    def _equal(self, other: Char) -&gt; bool:</span>
<span class="gi">+        return self.char == other.char and self.style == other.style</span>
<span class="gi">+</span>
<span class="gi">+    def _not_equal(self, other: Char) -&gt; bool:</span>
<span class="gi">+        # Not equal: We don&#39;t do `not char.__eq__` here, because of the</span>
<span class="gi">+        # performance of calling yet another function.</span>
<span class="gi">+        return self.char != other.char or self.style != other.style</span>
<span class="gi">+</span>
<span class="w"> </span>    if not TYPE_CHECKING:
<span class="w"> </span>        __eq__ = _equal
<span class="w"> </span>        __ne__ = _not_equal

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.char!r}, {self.style!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.char!r}, {self.style!r})&quot;</span>


<span class="gd">-_CHAR_CACHE: FastDictCache[tuple[str, str], Char] = FastDictCache(Char,</span>
<span class="gd">-    size=1000 * 1000)</span>
<span class="gd">-Transparent = &#39;[transparent]&#39;</span>
<span class="gi">+_CHAR_CACHE: FastDictCache[tuple[str, str], Char] = FastDictCache(</span>
<span class="gi">+    Char, size=1000 * 1000</span>
<span class="gi">+)</span>
<span class="gi">+Transparent = &quot;[transparent]&quot;</span>


<span class="w"> </span>class Screen:
<span class="gu">@@ -64,91 +152,178 @@ class Screen:</span>
<span class="w"> </span>    Two dimensional buffer of :class:`.Char` instances.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, default_char: (Char | None)=None, initial_width: int</span>
<span class="gd">-        =0, initial_height: int=0) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        default_char: Char | None = None,</span>
<span class="gi">+        initial_width: int = 0,</span>
<span class="gi">+        initial_height: int = 0,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if default_char is None:
<span class="gd">-            default_char2 = _CHAR_CACHE[&#39; &#39;, Transparent]</span>
<span class="gi">+            default_char2 = _CHAR_CACHE[&quot; &quot;, Transparent]</span>
<span class="w"> </span>        else:
<span class="w"> </span>            default_char2 = default_char
<span class="gd">-        self.data_buffer: defaultdict[int, defaultdict[int, Char]</span>
<span class="gd">-            ] = defaultdict(lambda : defaultdict(lambda : default_char2))</span>
<span class="gd">-        self.zero_width_escapes: defaultdict[int, defaultdict[int, str]</span>
<span class="gd">-            ] = defaultdict(lambda : defaultdict(lambda : &#39;&#39;))</span>
<span class="gd">-        self.cursor_positions: dict[Window, Point] = {}</span>
<span class="gi">+</span>
<span class="gi">+        self.data_buffer: defaultdict[int, defaultdict[int, Char]] = defaultdict(</span>
<span class="gi">+            lambda: defaultdict(lambda: default_char2)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        #: Escape sequences to be injected.</span>
<span class="gi">+        self.zero_width_escapes: defaultdict[int, defaultdict[int, str]] = defaultdict(</span>
<span class="gi">+            lambda: defaultdict(lambda: &quot;&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        #: Position of the cursor.</span>
<span class="gi">+        self.cursor_positions: dict[</span>
<span class="gi">+            Window, Point</span>
<span class="gi">+        ] = {}  # Map `Window` objects to `Point` objects.</span>
<span class="gi">+</span>
<span class="gi">+        #: Visibility of the cursor.</span>
<span class="w"> </span>        self.show_cursor = True
<span class="gd">-        self.menu_positions: dict[Window, Point] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: (Optional) Where to position the menu. E.g. at the start of a completion.</span>
<span class="gi">+        #: (We can&#39;t use the cursor position, because we don&#39;t want the</span>
<span class="gi">+        #: completion menu to change its position when we browse through all the</span>
<span class="gi">+        #: completions.)</span>
<span class="gi">+        self.menu_positions: dict[</span>
<span class="gi">+            Window, Point</span>
<span class="gi">+        ] = {}  # Map `Window` objects to `Point` objects.</span>
<span class="gi">+</span>
<span class="gi">+        #: Currently used width/height of the screen. This will increase when</span>
<span class="gi">+        #: data is written to the screen.</span>
<span class="w"> </span>        self.width = initial_width or 0
<span class="w"> </span>        self.height = initial_height or 0
<span class="gd">-        self.visible_windows_to_write_positions: dict[Window, WritePosition</span>
<span class="gd">-            ] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Windows that have been drawn. (Each `Window` class will add itself to</span>
<span class="gi">+        # this list.)</span>
<span class="gi">+        self.visible_windows_to_write_positions: dict[Window, WritePosition] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # List of (z_index, draw_func)</span>
<span class="w"> </span>        self._draw_float_functions: list[tuple[int, Callable[[], None]]] = []

<span class="gd">-    def set_cursor_position(self, window: Window, position: Point) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def visible_windows(self) -&gt; list[Window]:</span>
<span class="gi">+        return list(self.visible_windows_to_write_positions.keys())</span>
<span class="gi">+</span>
<span class="gi">+    def set_cursor_position(self, window: Window, position: Point) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the cursor position for a given window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cursor_positions[window] = position</span>

<span class="gd">-    def set_menu_position(self, window: Window, position: Point) -&gt;None:</span>
<span class="gi">+    def set_menu_position(self, window: Window, position: Point) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the cursor position for a given window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.menu_positions[window] = position</span>

<span class="gd">-    def get_cursor_position(self, window: Window) -&gt;Point:</span>
<span class="gi">+    def get_cursor_position(self, window: Window) -&gt; Point:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the cursor position for a given window.
<span class="w"> </span>        Returns a `Point`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.cursor_positions[window]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return Point(x=0, y=0)</span>

<span class="gd">-    def get_menu_position(self, window: Window) -&gt;Point:</span>
<span class="gi">+    def get_menu_position(self, window: Window) -&gt; Point:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the menu position for a given window.
<span class="w"> </span>        (This falls back to the cursor position if no menu position was set.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.menu_positions[window]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.cursor_positions[window]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                return Point(x=0, y=0)</span>

<span class="gd">-    def draw_with_z_index(self, z_index: int, draw_func: Callable[[], None]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def draw_with_z_index(self, z_index: int, draw_func: Callable[[], None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a draw-function for a `Window` which has a &gt;= 0 z_index.
<span class="w"> </span>        This will be postponed until `draw_all_floats` is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._draw_float_functions.append((z_index, draw_func))</span>

<span class="gd">-    def draw_all_floats(self) -&gt;None:</span>
<span class="gi">+    def draw_all_floats(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Draw all float functions in order of z-index.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We keep looping because some draw functions could add new functions</span>
<span class="gi">+        # to this list. See `FloatContainer`.</span>
<span class="gi">+        while self._draw_float_functions:</span>
<span class="gi">+            # Sort the floats that we have so far by z_index.</span>
<span class="gi">+            functions = sorted(self._draw_float_functions, key=lambda item: item[0])</span>
<span class="gi">+</span>
<span class="gi">+            # Draw only one at a time, then sort everything again. Now floats</span>
<span class="gi">+            # might have been added.</span>
<span class="gi">+            self._draw_float_functions = functions[1:]</span>
<span class="gi">+            functions[0][1]()</span>

<span class="gd">-    def append_style_to_content(self, style_str: str) -&gt;None:</span>
<span class="gi">+    def append_style_to_content(self, style_str: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For all the characters in the screen.
<span class="w"> </span>        Set the style string to the given `style_str`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = self.data_buffer</span>
<span class="gi">+        char_cache = _CHAR_CACHE</span>

<span class="gd">-    def fill_area(self, write_position: WritePosition, style: str=&#39;&#39;, after:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+        append_style = &quot; &quot; + style_str</span>
<span class="gi">+</span>
<span class="gi">+        for y, row in b.items():</span>
<span class="gi">+            for x, char in row.items():</span>
<span class="gi">+                row[x] = char_cache[char.char, char.style + append_style]</span>
<span class="gi">+</span>
<span class="gi">+    def fill_area(</span>
<span class="gi">+        self, write_position: WritePosition, style: str = &quot;&quot;, after: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fill the content of this area, using the given `style`.
<span class="w"> </span>        The style is prepended before whatever was here before.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not style.strip():</span>
<span class="gi">+            return</span>

<span class="gi">+        xmin = write_position.xpos</span>
<span class="gi">+        xmax = write_position.xpos + write_position.width</span>
<span class="gi">+        char_cache = _CHAR_CACHE</span>
<span class="gi">+        data_buffer = self.data_buffer</span>

<span class="gd">-class WritePosition:</span>
<span class="gi">+        if after:</span>
<span class="gi">+            append_style = &quot; &quot; + style</span>
<span class="gi">+            prepend_style = &quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            append_style = &quot;&quot;</span>
<span class="gi">+            prepend_style = style + &quot; &quot;</span>

<span class="gd">-    def __init__(self, xpos: int, ypos: int, width: int, height: int) -&gt;None:</span>
<span class="gi">+        for y in range(</span>
<span class="gi">+            write_position.ypos, write_position.ypos + write_position.height</span>
<span class="gi">+        ):</span>
<span class="gi">+            row = data_buffer[y]</span>
<span class="gi">+            for x in range(xmin, xmax):</span>
<span class="gi">+                cell = row[x]</span>
<span class="gi">+                row[x] = char_cache[</span>
<span class="gi">+                    cell.char, prepend_style + cell.style + append_style</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class WritePosition:</span>
<span class="gi">+    def __init__(self, xpos: int, ypos: int, width: int, height: int) -&gt; None:</span>
<span class="w"> </span>        assert height &gt;= 0
<span class="w"> </span>        assert width &gt;= 0
<span class="gi">+        # xpos and ypos can be negative. (A float can be partially visible.)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.xpos = xpos
<span class="w"> </span>        self.ypos = ypos
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.height = height

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(x={!r}, y={!r}, width={!r}, height={!r})&#39;.format(self.</span>
<span class="gd">-            __class__.__name__, self.xpos, self.ypos, self.width, self.height)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(x={!r}, y={!r}, width={!r}, height={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.xpos,</span>
<span class="gi">+            self.ypos,</span>
<span class="gi">+            self.width,</span>
<span class="gi">+            self.height,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/scrollable_pane.py b/src/prompt_toolkit/layout/scrollable_pane.py</span>
<span class="gh">index 22c7047e..e38fd761 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/scrollable_pane.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/scrollable_pane.py</span>
<span class="gu">@@ -1,14 +1,19 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.data_structures import Point
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="w"> </span>from prompt_toolkit.key_binding import KeyBindingsBase
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent
<span class="gi">+</span>
<span class="w"> </span>from .containers import Container, ScrollOffsets
<span class="w"> </span>from .dimension import AnyDimension, Dimension, sum_layout_dimensions, to_dimension
<span class="w"> </span>from .mouse_handlers import MouseHandler, MouseHandlers
<span class="w"> </span>from .screen import Char, Screen, WritePosition
<span class="gd">-__all__ = [&#39;ScrollablePane&#39;]</span>
<span class="gd">-MAX_AVAILABLE_HEIGHT = 10000</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;ScrollablePane&quot;]</span>
<span class="gi">+</span>
<span class="gi">+# Never go beyond this height, because performance will degrade.</span>
<span class="gi">+MAX_AVAILABLE_HEIGHT = 10_000</span>


<span class="w"> </span>class ScrollablePane(Container):
<span class="gu">@@ -44,18 +49,24 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>    :param show_scrollbar: When `True` display a scrollbar on the right.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, content: Container, scroll_offsets: (ScrollOffsets |</span>
<span class="gd">-        None)=None, keep_cursor_visible: FilterOrBool=True,</span>
<span class="gd">-        keep_focused_window_visible: FilterOrBool=True,</span>
<span class="gd">-        max_available_height: int=MAX_AVAILABLE_HEIGHT, width: AnyDimension</span>
<span class="gd">-        =None, height: AnyDimension=None, show_scrollbar: FilterOrBool=True,</span>
<span class="gd">-        display_arrows: FilterOrBool=True, up_arrow_symbol: str=&#39;^&#39;,</span>
<span class="gd">-        down_arrow_symbol: str=&#39;v&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        content: Container,</span>
<span class="gi">+        scroll_offsets: ScrollOffsets | None = None,</span>
<span class="gi">+        keep_cursor_visible: FilterOrBool = True,</span>
<span class="gi">+        keep_focused_window_visible: FilterOrBool = True,</span>
<span class="gi">+        max_available_height: int = MAX_AVAILABLE_HEIGHT,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        show_scrollbar: FilterOrBool = True,</span>
<span class="gi">+        display_arrows: FilterOrBool = True,</span>
<span class="gi">+        up_arrow_symbol: str = &quot;^&quot;,</span>
<span class="gi">+        down_arrow_symbol: str = &quot;v&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.content = content
<span class="w"> </span>        self.scroll_offsets = scroll_offsets or ScrollOffsets(top=1, bottom=1)
<span class="w"> </span>        self.keep_cursor_visible = to_filter(keep_cursor_visible)
<span class="gd">-        self.keep_focused_window_visible = to_filter(</span>
<span class="gd">-            keep_focused_window_visible)</span>
<span class="gi">+        self.keep_focused_window_visible = to_filter(keep_focused_window_visible)</span>
<span class="w"> </span>        self.max_available_height = max_available_height
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.height = height
<span class="gu">@@ -63,57 +74,293 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>        self.display_arrows = to_filter(display_arrows)
<span class="w"> </span>        self.up_arrow_symbol = up_arrow_symbol
<span class="w"> </span>        self.down_arrow_symbol = down_arrow_symbol
<span class="gi">+</span>
<span class="w"> </span>        self.vertical_scroll = 0

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;ScrollablePane({self.content!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;ScrollablePane({self.content!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.content.reset()</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_width(self, max_available_width: int) -&gt; Dimension:</span>
<span class="gi">+        if self.width is not None:</span>
<span class="gi">+            return to_dimension(self.width)</span>
<span class="gi">+</span>
<span class="gi">+        # We&#39;re only scrolling vertical. So the preferred width is equal to</span>
<span class="gi">+        # that of the content.</span>
<span class="gi">+        content_width = self.content.preferred_width(max_available_width)</span>

<span class="gd">-    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,</span>
<span class="gd">-        write_position: WritePosition, parent_style: str, erase_bg: bool,</span>
<span class="gd">-        z_index: (int | None)) -&gt;None:</span>
<span class="gi">+        # If a scrollbar needs to be displayed, add +1 to the content width.</span>
<span class="gi">+        if self.show_scrollbar():</span>
<span class="gi">+            return sum_layout_dimensions([Dimension.exact(1), content_width])</span>
<span class="gi">+</span>
<span class="gi">+        return content_width</span>
<span class="gi">+</span>
<span class="gi">+    def preferred_height(self, width: int, max_available_height: int) -&gt; Dimension:</span>
<span class="gi">+        if self.height is not None:</span>
<span class="gi">+            return to_dimension(self.height)</span>
<span class="gi">+</span>
<span class="gi">+        # Prefer a height large enough so that it fits all the content. If not,</span>
<span class="gi">+        # we&#39;ll make the pane scrollable.</span>
<span class="gi">+        if self.show_scrollbar():</span>
<span class="gi">+            # If `show_scrollbar` is set. Always reserve space for the scrollbar.</span>
<span class="gi">+            width -= 1</span>
<span class="gi">+</span>
<span class="gi">+        dimension = self.content.preferred_height(width, self.max_available_height)</span>
<span class="gi">+</span>
<span class="gi">+        # Only take &#39;preferred&#39; into account. Min/max can be anything.</span>
<span class="gi">+        return Dimension(min=0, preferred=dimension.preferred)</span>
<span class="gi">+</span>
<span class="gi">+    def write_to_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        parent_style: str,</span>
<span class="gi">+        erase_bg: bool,</span>
<span class="gi">+        z_index: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Render scrollable pane content.

<span class="w"> </span>        This works by rendering on an off-screen canvas, and copying over the
<span class="w"> </span>        visible region.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        show_scrollbar = self.show_scrollbar()</span>
<span class="gi">+</span>
<span class="gi">+        if show_scrollbar:</span>
<span class="gi">+            virtual_width = write_position.width - 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            virtual_width = write_position.width</span>
<span class="gi">+</span>
<span class="gi">+        # Compute preferred height again.</span>
<span class="gi">+        virtual_height = self.content.preferred_height(</span>
<span class="gi">+            virtual_width, self.max_available_height</span>
<span class="gi">+        ).preferred</span>
<span class="gi">+</span>
<span class="gi">+        # Ensure virtual height is at least the available height.</span>
<span class="gi">+        virtual_height = max(virtual_height, write_position.height)</span>
<span class="gi">+        virtual_height = min(virtual_height, self.max_available_height)</span>
<span class="gi">+</span>
<span class="gi">+        # First, write the content to a virtual screen, then copy over the</span>
<span class="gi">+        # visible part to the real screen.</span>
<span class="gi">+        temp_screen = Screen(default_char=Char(char=&quot; &quot;, style=parent_style))</span>
<span class="gi">+        temp_screen.show_cursor = screen.show_cursor</span>
<span class="gi">+        temp_write_position = WritePosition(</span>
<span class="gi">+            xpos=0, ypos=0, width=virtual_width, height=virtual_height</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        temp_mouse_handlers = MouseHandlers()</span>
<span class="gi">+</span>
<span class="gi">+        self.content.write_to_screen(</span>
<span class="gi">+            temp_screen,</span>
<span class="gi">+            temp_mouse_handlers,</span>
<span class="gi">+            temp_write_position,</span>
<span class="gi">+            parent_style,</span>
<span class="gi">+            erase_bg,</span>
<span class="gi">+            z_index,</span>
<span class="gi">+        )</span>
<span class="gi">+        temp_screen.draw_all_floats()</span>
<span class="gi">+</span>
<span class="gi">+        # If anything in the virtual screen is focused, move vertical scroll to</span>
<span class="gi">+        from prompt_toolkit.application import get_app</span>
<span class="gi">+</span>
<span class="gi">+        focused_window = get_app().layout.current_window</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            visible_win_write_pos = temp_screen.visible_windows_to_write_positions[</span>
<span class="gi">+                focused_window</span>
<span class="gi">+            ]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass  # No window focused here. Don&#39;t scroll.</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Make sure this window is visible.</span>
<span class="gi">+            self._make_window_visible(</span>
<span class="gi">+                write_position.height,</span>
<span class="gi">+                virtual_height,</span>
<span class="gi">+                visible_win_write_pos,</span>
<span class="gi">+                temp_screen.cursor_positions.get(focused_window),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Copy over virtual screen and zero width escapes to real screen.</span>
<span class="gi">+        self._copy_over_screen(screen, temp_screen, write_position, virtual_width)</span>
<span class="gi">+</span>
<span class="gi">+        # Copy over mouse handlers.</span>
<span class="gi">+        self._copy_over_mouse_handlers(</span>
<span class="gi">+            mouse_handlers, temp_mouse_handlers, write_position, virtual_width</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Set screen.width/height.</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        xpos = write_position.xpos</span>
<span class="gi">+</span>
<span class="gi">+        screen.width = max(screen.width, xpos + virtual_width)</span>
<span class="gi">+        screen.height = max(screen.height, ypos + write_position.height)</span>
<span class="gi">+</span>
<span class="gi">+        # Copy over window write positions.</span>
<span class="gi">+        self._copy_over_write_positions(screen, temp_screen, write_position)</span>
<span class="gi">+</span>
<span class="gi">+        if temp_screen.show_cursor:</span>
<span class="gi">+            screen.show_cursor = True</span>
<span class="gi">+</span>
<span class="gi">+        # Copy over cursor positions, if they are visible.</span>
<span class="gi">+        for window, point in temp_screen.cursor_positions.items():</span>
<span class="gi">+            if (</span>
<span class="gi">+                0 &lt;= point.x &lt; write_position.width</span>
<span class="gi">+                and self.vertical_scroll</span>
<span class="gi">+                &lt;= point.y</span>
<span class="gi">+                &lt; write_position.height + self.vertical_scroll</span>
<span class="gi">+            ):</span>
<span class="gi">+                screen.cursor_positions[window] = Point(</span>
<span class="gi">+                    x=point.x + xpos, y=point.y + ypos - self.vertical_scroll</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # Copy over menu positions, but clip them to the visible area.</span>
<span class="gi">+        for window, point in temp_screen.menu_positions.items():</span>
<span class="gi">+            screen.menu_positions[window] = self._clip_point_to_visible_area(</span>
<span class="gi">+                Point(x=point.x + xpos, y=point.y + ypos - self.vertical_scroll),</span>
<span class="gi">+                write_position,</span>
<span class="gi">+            )</span>

<span class="gd">-    def _clip_point_to_visible_area(self, point: Point, write_position:</span>
<span class="gd">-        WritePosition) -&gt;Point:</span>
<span class="gi">+        # Draw scrollbar.</span>
<span class="gi">+        if show_scrollbar:</span>
<span class="gi">+            self._draw_scrollbar(</span>
<span class="gi">+                write_position,</span>
<span class="gi">+                virtual_height,</span>
<span class="gi">+                screen,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _clip_point_to_visible_area(</span>
<span class="gi">+        self, point: Point, write_position: WritePosition</span>
<span class="gi">+    ) -&gt; Point:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Ensure that the cursor and menu positions always are always reported
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if point.x &lt; write_position.xpos:</span>
<span class="gi">+            point = point._replace(x=write_position.xpos)</span>
<span class="gi">+        if point.y &lt; write_position.ypos:</span>
<span class="gi">+            point = point._replace(y=write_position.ypos)</span>
<span class="gi">+        if point.x &gt;= write_position.xpos + write_position.width:</span>
<span class="gi">+            point = point._replace(x=write_position.xpos + write_position.width - 1)</span>
<span class="gi">+        if point.y &gt;= write_position.ypos + write_position.height:</span>
<span class="gi">+            point = point._replace(y=write_position.ypos + write_position.height - 1)</span>
<span class="gi">+</span>
<span class="gi">+        return point</span>

<span class="gd">-    def _copy_over_screen(self, screen: Screen, temp_screen: Screen,</span>
<span class="gd">-        write_position: WritePosition, virtual_width: int) -&gt;None:</span>
<span class="gi">+    def _copy_over_screen(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen: Screen,</span>
<span class="gi">+        temp_screen: Screen,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        virtual_width: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy over visible screen content and &quot;zero width escape sequences&quot;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        xpos = write_position.xpos</span>
<span class="gi">+</span>
<span class="gi">+        for y in range(write_position.height):</span>
<span class="gi">+            temp_row = temp_screen.data_buffer[y + self.vertical_scroll]</span>
<span class="gi">+            row = screen.data_buffer[y + ypos]</span>
<span class="gi">+            temp_zero_width_escapes = temp_screen.zero_width_escapes[</span>
<span class="gi">+                y + self.vertical_scroll</span>
<span class="gi">+            ]</span>
<span class="gi">+            zero_width_escapes = screen.zero_width_escapes[y + ypos]</span>
<span class="gi">+</span>
<span class="gi">+            for x in range(virtual_width):</span>
<span class="gi">+                row[x + xpos] = temp_row[x]</span>

<span class="gd">-    def _copy_over_mouse_handlers(self, mouse_handlers: MouseHandlers,</span>
<span class="gd">-        temp_mouse_handlers: MouseHandlers, write_position: WritePosition,</span>
<span class="gd">-        virtual_width: int) -&gt;None:</span>
<span class="gi">+                if x in temp_zero_width_escapes:</span>
<span class="gi">+                    zero_width_escapes[x + xpos] = temp_zero_width_escapes[x]</span>
<span class="gi">+</span>
<span class="gi">+    def _copy_over_mouse_handlers(</span>
<span class="gi">+        self,</span>
<span class="gi">+        mouse_handlers: MouseHandlers,</span>
<span class="gi">+        temp_mouse_handlers: MouseHandlers,</span>
<span class="gi">+        write_position: WritePosition,</span>
<span class="gi">+        virtual_width: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy over mouse handlers from virtual screen to real screen.

<span class="w"> </span>        Note: we take `virtual_width` because we don&#39;t want to copy over mouse
<span class="w"> </span>              handlers that we possibly have behind the scrollbar.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        xpos = write_position.xpos</span>
<span class="gi">+</span>
<span class="gi">+        # Cache mouse handlers when wrapping them. Very often the same mouse</span>
<span class="gi">+        # handler is registered for many positions.</span>
<span class="gi">+        mouse_handler_wrappers: dict[MouseHandler, MouseHandler] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def wrap_mouse_handler(handler: MouseHandler) -&gt; MouseHandler:</span>
<span class="gi">+            &quot;Wrap mouse handler. Translate coordinates in `MouseEvent`.&quot;</span>
<span class="gi">+            if handler not in mouse_handler_wrappers:</span>
<span class="gi">+</span>
<span class="gi">+                def new_handler(event: MouseEvent) -&gt; None:</span>
<span class="gi">+                    new_event = MouseEvent(</span>
<span class="gi">+                        position=Point(</span>
<span class="gi">+                            x=event.position.x - xpos,</span>
<span class="gi">+                            y=event.position.y + self.vertical_scroll - ypos,</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        event_type=event.event_type,</span>
<span class="gi">+                        button=event.button,</span>
<span class="gi">+                        modifiers=event.modifiers,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    handler(new_event)</span>

<span class="gd">-    def _copy_over_write_positions(self, screen: Screen, temp_screen:</span>
<span class="gd">-        Screen, write_position: WritePosition) -&gt;None:</span>
<span class="gi">+                mouse_handler_wrappers[handler] = new_handler</span>
<span class="gi">+            return mouse_handler_wrappers[handler]</span>
<span class="gi">+</span>
<span class="gi">+        # Copy handlers.</span>
<span class="gi">+        mouse_handlers_dict = mouse_handlers.mouse_handlers</span>
<span class="gi">+        temp_mouse_handlers_dict = temp_mouse_handlers.mouse_handlers</span>
<span class="gi">+</span>
<span class="gi">+        for y in range(write_position.height):</span>
<span class="gi">+            if y in temp_mouse_handlers_dict:</span>
<span class="gi">+                temp_mouse_row = temp_mouse_handlers_dict[y + self.vertical_scroll]</span>
<span class="gi">+                mouse_row = mouse_handlers_dict[y + ypos]</span>
<span class="gi">+                for x in range(virtual_width):</span>
<span class="gi">+                    if x in temp_mouse_row:</span>
<span class="gi">+                        mouse_row[x + xpos] = wrap_mouse_handler(temp_mouse_row[x])</span>
<span class="gi">+</span>
<span class="gi">+    def _copy_over_write_positions(</span>
<span class="gi">+        self, screen: Screen, temp_screen: Screen, write_position: WritePosition</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy over window write positions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        xpos = write_position.xpos</span>
<span class="gi">+</span>
<span class="gi">+        for win, write_pos in temp_screen.visible_windows_to_write_positions.items():</span>
<span class="gi">+            screen.visible_windows_to_write_positions[win] = WritePosition(</span>
<span class="gi">+                xpos=write_pos.xpos + xpos,</span>
<span class="gi">+                ypos=write_pos.ypos + ypos - self.vertical_scroll,</span>
<span class="gi">+                # TODO: if the window is only partly visible, then truncate width/height.</span>
<span class="gi">+                #       This could be important if we have nested ScrollablePanes.</span>
<span class="gi">+                height=write_pos.height,</span>
<span class="gi">+                width=write_pos.width,</span>
<span class="gi">+            )</span>

<span class="gd">-    def _make_window_visible(self, visible_height: int, virtual_height: int,</span>
<span class="gd">-        visible_win_write_pos: WritePosition, cursor_position: (Point | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def is_modal(self) -&gt; bool:</span>
<span class="gi">+        return self.content.is_modal()</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindingsBase | None:</span>
<span class="gi">+        return self.content.get_key_bindings()</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[Container]:</span>
<span class="gi">+        return [self.content]</span>
<span class="gi">+</span>
<span class="gi">+    def _make_window_visible(</span>
<span class="gi">+        self,</span>
<span class="gi">+        visible_height: int,</span>
<span class="gi">+        virtual_height: int,</span>
<span class="gi">+        visible_win_write_pos: WritePosition,</span>
<span class="gi">+        cursor_position: Point | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Scroll the scrollable pane, so that this window becomes visible.

<span class="gu">@@ -124,14 +371,124 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>        :param cursor_position: The location of the cursor position of this
<span class="w"> </span>            window on the temp screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Start with maximum allowed scroll range, and then reduce according to</span>
<span class="gi">+        # the focused window and cursor position.</span>
<span class="gi">+        min_scroll = 0</span>
<span class="gi">+        max_scroll = virtual_height - visible_height</span>
<span class="gi">+</span>
<span class="gi">+        if self.keep_cursor_visible():</span>
<span class="gi">+            # Reduce min/max scroll according to the cursor in the focused window.</span>
<span class="gi">+            if cursor_position is not None:</span>
<span class="gi">+                offsets = self.scroll_offsets</span>
<span class="gi">+                cpos_min_scroll = (</span>
<span class="gi">+                    cursor_position.y - visible_height + 1 + offsets.bottom</span>
<span class="gi">+                )</span>
<span class="gi">+                cpos_max_scroll = cursor_position.y - offsets.top</span>
<span class="gi">+                min_scroll = max(min_scroll, cpos_min_scroll)</span>
<span class="gi">+                max_scroll = max(0, min(max_scroll, cpos_max_scroll))</span>

<span class="gd">-    def _draw_scrollbar(self, write_position: WritePosition, content_height:</span>
<span class="gd">-        int, screen: Screen) -&gt;None:</span>
<span class="gi">+        if self.keep_focused_window_visible():</span>
<span class="gi">+            # Reduce min/max scroll according to focused window position.</span>
<span class="gi">+            # If the window is small enough, bot the top and bottom of the window</span>
<span class="gi">+            # should be visible.</span>
<span class="gi">+            if visible_win_write_pos.height &lt;= visible_height:</span>
<span class="gi">+                window_min_scroll = (</span>
<span class="gi">+                    visible_win_write_pos.ypos</span>
<span class="gi">+                    + visible_win_write_pos.height</span>
<span class="gi">+                    - visible_height</span>
<span class="gi">+                )</span>
<span class="gi">+                window_max_scroll = visible_win_write_pos.ypos</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Window does not fit on the screen. Make sure at least the whole</span>
<span class="gi">+                # screen is occupied with this window, and nothing else is shown.</span>
<span class="gi">+                window_min_scroll = visible_win_write_pos.ypos</span>
<span class="gi">+                window_max_scroll = (</span>
<span class="gi">+                    visible_win_write_pos.ypos</span>
<span class="gi">+                    + visible_win_write_pos.height</span>
<span class="gi">+                    - visible_height</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            min_scroll = max(min_scroll, window_min_scroll)</span>
<span class="gi">+            max_scroll = min(max_scroll, window_max_scroll)</span>
<span class="gi">+</span>
<span class="gi">+        if min_scroll &gt; max_scroll:</span>
<span class="gi">+            min_scroll = max_scroll  # Should not happen.</span>
<span class="gi">+</span>
<span class="gi">+        # Finally, properly clip the vertical scroll.</span>
<span class="gi">+        if self.vertical_scroll &gt; max_scroll:</span>
<span class="gi">+            self.vertical_scroll = max_scroll</span>
<span class="gi">+        if self.vertical_scroll &lt; min_scroll:</span>
<span class="gi">+            self.vertical_scroll = min_scroll</span>
<span class="gi">+</span>
<span class="gi">+    def _draw_scrollbar(</span>
<span class="gi">+        self, write_position: WritePosition, content_height: int, screen: Screen</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Draw the scrollbar on the screen.

<span class="w"> </span>        Note: There is some code duplication with the `ScrollbarMargin`
<span class="w"> </span>              implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        window_height = write_position.height</span>
<span class="gi">+        display_arrows = self.display_arrows()</span>
<span class="gi">+</span>
<span class="gi">+        if display_arrows:</span>
<span class="gi">+            window_height -= 2</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            fraction_visible = write_position.height / float(content_height)</span>
<span class="gi">+            fraction_above = self.vertical_scroll / float(content_height)</span>
<span class="gi">+</span>
<span class="gi">+            scrollbar_height = int(</span>
<span class="gi">+                min(window_height, max(1, window_height * fraction_visible))</span>
<span class="gi">+            )</span>
<span class="gi">+            scrollbar_top = int(window_height * fraction_above)</span>
<span class="gi">+        except ZeroDivisionError:</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def is_scroll_button(row: int) -&gt; bool:</span>
<span class="gi">+                &quot;True if we should display a button on this row.&quot;</span>
<span class="gi">+                return scrollbar_top &lt;= row &lt;= scrollbar_top + scrollbar_height</span>
<span class="gi">+</span>
<span class="gi">+            xpos = write_position.xpos + write_position.width - 1</span>
<span class="gi">+            ypos = write_position.ypos</span>
<span class="gi">+            data_buffer = screen.data_buffer</span>
<span class="gi">+</span>
<span class="gi">+            # Up arrow.</span>
<span class="gi">+            if display_arrows:</span>
<span class="gi">+                data_buffer[ypos][xpos] = Char(</span>
<span class="gi">+                    self.up_arrow_symbol, &quot;class:scrollbar.arrow&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                ypos += 1</span>
<span class="gi">+</span>
<span class="gi">+            # Scrollbar body.</span>
<span class="gi">+            scrollbar_background = &quot;class:scrollbar.background&quot;</span>
<span class="gi">+            scrollbar_background_start = &quot;class:scrollbar.background,scrollbar.start&quot;</span>
<span class="gi">+            scrollbar_button = &quot;class:scrollbar.button&quot;</span>
<span class="gi">+            scrollbar_button_end = &quot;class:scrollbar.button,scrollbar.end&quot;</span>
<span class="gi">+</span>
<span class="gi">+            for i in range(window_height):</span>
<span class="gi">+                style = &quot;&quot;</span>
<span class="gi">+                if is_scroll_button(i):</span>
<span class="gi">+                    if not is_scroll_button(i + 1):</span>
<span class="gi">+                        # Give the last cell a different style, because we want</span>
<span class="gi">+                        # to underline this.</span>
<span class="gi">+                        style = scrollbar_button_end</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        style = scrollbar_button</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if is_scroll_button(i + 1):</span>
<span class="gi">+                        style = scrollbar_background_start</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        style = scrollbar_background</span>
<span class="gi">+</span>
<span class="gi">+                data_buffer[ypos][xpos] = Char(&quot; &quot;, style)</span>
<span class="gi">+                ypos += 1</span>
<span class="gi">+</span>
<span class="gi">+            # Down arrow</span>
<span class="gi">+            if display_arrows:</span>
<span class="gi">+                data_buffer[ypos][xpos] = Char(</span>
<span class="gi">+                    self.down_arrow_symbol, &quot;class:scrollbar.arrow&quot;</span>
<span class="gi">+                )</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/utils.py b/src/prompt_toolkit/layout/utils.py</span>
<span class="gh">index b4df4dc7..0f78f371 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/utils.py</span>
<span class="gu">@@ -1,10 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Iterable, List, TypeVar, cast, overload
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.formatted_text.base import OneStyleAndTextTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import SupportsIndex
<span class="gd">-__all__ = [&#39;explode_text_fragments&#39;]</span>
<span class="gd">-_T = TypeVar(&#39;_T&#39;, bound=OneStyleAndTextTuple)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;explode_text_fragments&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;, bound=OneStyleAndTextTuple)</span>


<span class="w"> </span>class _ExplodedList(List[_T]):
<span class="gu">@@ -14,18 +21,31 @@ class _ExplodedList(List[_T]):</span>
<span class="w"> </span>    As soon as items are added or the list is extended, the new items are
<span class="w"> </span>    automatically exploded as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    exploded = True

<span class="gi">+    def append(self, item: _T) -&gt; None:</span>
<span class="gi">+        self.extend([item])</span>
<span class="gi">+</span>
<span class="gi">+    def extend(self, lst: Iterable[_T]) -&gt; None:</span>
<span class="gi">+        super().extend(explode_text_fragments(lst))</span>
<span class="gi">+</span>
<span class="gi">+    def insert(self, index: SupportsIndex, item: _T) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError  # TODO</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: When creating a copy() or [:], return also an _ExplodedList.</span>
<span class="gi">+</span>
<span class="w"> </span>    @overload
<span class="gd">-    def __setitem__(self, index: SupportsIndex, value: _T) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, index: SupportsIndex, value: _T) -&gt; None:</span>
<span class="w"> </span>        ...

<span class="w"> </span>    @overload
<span class="gd">-    def __setitem__(self, index: slice, value: Iterable[_T]) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, index: slice, value: Iterable[_T]) -&gt; None:</span>
<span class="w"> </span>        ...

<span class="gd">-    def __setitem__(self, index: (SupportsIndex | slice), value: (_T |</span>
<span class="gd">-        Iterable[_T])) -&gt;None:</span>
<span class="gi">+    def __setitem__(</span>
<span class="gi">+        self, index: SupportsIndex | slice, value: _T | Iterable[_T]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Ensure that when `(style_str, &#39;long string&#39;)` is set, the string will be
<span class="w"> </span>        exploded.
<span class="gu">@@ -33,12 +53,13 @@ class _ExplodedList(List[_T]):</span>
<span class="w"> </span>        if not isinstance(index, slice):
<span class="w"> </span>            int_index = index.__index__()
<span class="w"> </span>            index = slice(int_index, int_index + 1)
<span class="gd">-        if isinstance(value, tuple):</span>
<span class="gd">-            value = cast(&#39;List[_T]&#39;, [value])</span>
<span class="gi">+        if isinstance(value, tuple):  # In case of `OneStyleAndTextTuple`.</span>
<span class="gi">+            value = cast(&quot;List[_T]&quot;, [value])</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__setitem__(index, explode_text_fragments(value))


<span class="gd">-def explode_text_fragments(fragments: Iterable[_T]) -&gt;_ExplodedList[_T]:</span>
<span class="gi">+def explode_text_fragments(fragments: Iterable[_T]) -&gt; _ExplodedList[_T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn a list of (style_str, text) tuples into another list where each string is
<span class="w"> </span>    exactly one character.
<span class="gu">@@ -48,4 +69,14 @@ def explode_text_fragments(fragments: Iterable[_T]) -&gt;_ExplodedList[_T]:</span>

<span class="w"> </span>    :param fragments: List of (style, text) tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # When the fragments is already exploded, don&#39;t explode again.</span>
<span class="gi">+    if isinstance(fragments, _ExplodedList):</span>
<span class="gi">+        return fragments</span>
<span class="gi">+</span>
<span class="gi">+    result: list[_T] = []</span>
<span class="gi">+</span>
<span class="gi">+    for style, string, *rest in fragments:</span>
<span class="gi">+        for c in string:</span>
<span class="gi">+            result.append((style, c, *rest))  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return _ExplodedList(result)</span>
<span class="gh">diff --git a/src/prompt_toolkit/lexers/base.py b/src/prompt_toolkit/lexers/base.py</span>
<span class="gh">index a6b501bd..3f65f8e7 100644</span>
<span class="gd">--- a/src/prompt_toolkit/lexers/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/lexers/base.py</span>
<span class="gu">@@ -2,11 +2,18 @@</span>
<span class="w"> </span>Base classes for prompt_toolkit lexers.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import Callable, Hashable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.formatted_text.base import StyleAndTextTuples
<span class="gd">-__all__ = [&#39;Lexer&#39;, &#39;SimpleLexer&#39;, &#39;DynamicLexer&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Lexer&quot;,</span>
<span class="gi">+    &quot;SimpleLexer&quot;,</span>
<span class="gi">+    &quot;DynamicLexer&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Lexer(metaclass=ABCMeta):
<span class="gu">@@ -15,8 +22,7 @@ class Lexer(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def lex_document(self, document: Document) -&gt;Callable[[int],</span>
<span class="gd">-        StyleAndTextTuples]:</span>
<span class="gi">+    def lex_document(self, document: Document) -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Takes a :class:`~prompt_toolkit.document.Document` and returns a
<span class="w"> </span>        callable that takes a line number and returns a list of
<span class="gu">@@ -25,14 +31,13 @@ class Lexer(metaclass=ABCMeta):</span>
<span class="w"> </span>        XXX: Note that in the past, this was supposed to return a list
<span class="w"> </span>             of ``(Token, text)`` tuples, just like a Pygments lexer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When this changes, `lex_document` could give a different output.
<span class="w"> </span>        (Only used for `DynamicLexer`.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return id(self)</span>


<span class="w"> </span>class SimpleLexer(Lexer):
<span class="gu">@@ -43,9 +48,21 @@ class SimpleLexer(Lexer):</span>
<span class="w"> </span>    :param style: The style string for this lexer.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, style: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, style: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        self.style = style

<span class="gi">+    def lex_document(self, document: Document) -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="gi">+        lines = document.lines</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(lineno: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            &quot;Return the tokens for the given line.&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                return [(self.style, lines[lineno])]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+        return get_line</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicLexer(Lexer):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -54,6 +71,14 @@ class DynamicLexer(Lexer):</span>
<span class="w"> </span>    :param get_lexer: Callable that returns a :class:`.Lexer` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_lexer: Callable[[], Lexer | None]) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_lexer: Callable[[], Lexer | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_lexer = get_lexer
<span class="w"> </span>        self._dummy = SimpleLexer()
<span class="gi">+</span>
<span class="gi">+    def lex_document(self, document: Document) -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="gi">+        lexer = self.get_lexer() or self._dummy</span>
<span class="gi">+        return lexer.lex_document(document)</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        lexer = self.get_lexer() or self._dummy</span>
<span class="gi">+        return id(lexer)</span>
<span class="gh">diff --git a/src/prompt_toolkit/lexers/pygments.py b/src/prompt_toolkit/lexers/pygments.py</span>
<span class="gh">index 79f8caa1..4721d730 100644</span>
<span class="gd">--- a/src/prompt_toolkit/lexers/pygments.py</span>
<span class="gi">+++ b/src/prompt_toolkit/lexers/pygments.py</span>
<span class="gu">@@ -5,18 +5,28 @@ This includes syntax synchronization code, so that we don&#39;t have to start</span>
<span class="w"> </span>lexing at the beginning of a document, when displaying a very large text.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING, Callable, Dict, Generator, Iterable, Tuple
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="w"> </span>from prompt_toolkit.formatted_text.base import StyleAndTextTuples
<span class="w"> </span>from prompt_toolkit.formatted_text.utils import split_lines
<span class="w"> </span>from prompt_toolkit.styles.pygments import pygments_token_to_classname
<span class="gi">+</span>
<span class="w"> </span>from .base import Lexer, SimpleLexer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pygments.lexer import Lexer as PygmentsLexerCls
<span class="gd">-__all__ = [&#39;PygmentsLexer&#39;, &#39;SyntaxSync&#39;, &#39;SyncFromStart&#39;, &#39;RegexSync&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PygmentsLexer&quot;,</span>
<span class="gi">+    &quot;SyntaxSync&quot;,</span>
<span class="gi">+    &quot;SyncFromStart&quot;,</span>
<span class="gi">+    &quot;RegexSync&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class SyntaxSync(metaclass=ABCMeta):
<span class="gu">@@ -28,8 +38,9 @@ class SyntaxSync(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_sync_start_position(self, document: Document, lineno: int) -&gt;tuple[</span>
<span class="gd">-        int, int]:</span>
<span class="gi">+    def get_sync_start_position(</span>
<span class="gi">+        self, document: Document, lineno: int</span>
<span class="gi">+    ) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the position from where we can start lexing as a (row, column)
<span class="w"> </span>        tuple.
<span class="gu">@@ -38,7 +49,6 @@ class SyntaxSync(metaclass=ABCMeta):</span>
<span class="w"> </span>        :param lineno: The line that we want to highlight. (We need to return
<span class="w"> </span>            this line, or an earlier position.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class SyncFromStart(SyntaxSync):
<span class="gu">@@ -46,30 +56,70 @@ class SyncFromStart(SyntaxSync):</span>
<span class="w"> </span>    Always start the syntax highlighting from the beginning.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_sync_start_position(</span>
<span class="gi">+        self, document: Document, lineno: int</span>
<span class="gi">+    ) -&gt; tuple[int, int]:</span>
<span class="gi">+        return 0, 0</span>
<span class="gi">+</span>

<span class="w"> </span>class RegexSync(SyntaxSync):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Synchronize by starting at a line that matches the given regex pattern.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Never go more than this amount of lines backwards for synchronization.</span>
<span class="gi">+    # That would be too CPU intensive.</span>
<span class="w"> </span>    MAX_BACKWARDS = 500
<span class="gi">+</span>
<span class="gi">+    # Start lexing at the start, if we are in the first &#39;n&#39; lines and no</span>
<span class="gi">+    # synchronization position was found.</span>
<span class="w"> </span>    FROM_START_IF_NO_SYNC_POS_FOUND = 100

<span class="gd">-    def __init__(self, pattern: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, pattern: str) -&gt; None:</span>
<span class="w"> </span>        self._compiled_pattern = re.compile(pattern)

<span class="gd">-    def get_sync_start_position(self, document: Document, lineno: int) -&gt;tuple[</span>
<span class="gd">-        int, int]:</span>
<span class="gi">+    def get_sync_start_position(</span>
<span class="gi">+        self, document: Document, lineno: int</span>
<span class="gi">+    ) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Scan backwards, and find a possible position to start.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pattern = self._compiled_pattern</span>
<span class="gi">+        lines = document.lines</span>
<span class="gi">+</span>
<span class="gi">+        # Scan upwards, until we find a point where we can start the syntax</span>
<span class="gi">+        # synchronization.</span>
<span class="gi">+        for i in range(lineno, max(-1, lineno - self.MAX_BACKWARDS), -1):</span>
<span class="gi">+            match = pattern.match(lines[i])</span>
<span class="gi">+            if match:</span>
<span class="gi">+                return i, match.start()</span>
<span class="gi">+</span>
<span class="gi">+        # No synchronization point found. If we aren&#39;t that far from the</span>
<span class="gi">+        # beginning, start at the very beginning, otherwise, just try to start</span>
<span class="gi">+        # at the current line.</span>
<span class="gi">+        if lineno &lt; self.FROM_START_IF_NO_SYNC_POS_FOUND:</span>
<span class="gi">+            return 0, 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            return lineno, 0</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_pygments_lexer_cls(cls, lexer_cls: PygmentsLexerCls) -&gt;RegexSync:</span>
<span class="gi">+    def from_pygments_lexer_cls(cls, lexer_cls: PygmentsLexerCls) -&gt; RegexSync:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a :class:`.RegexSync` instance for this Pygments lexer class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        patterns = {</span>
<span class="gi">+            # For Python, start highlighting at any class/def block.</span>
<span class="gi">+            &quot;Python&quot;: r&quot;^\s*(class|def)\s+&quot;,</span>
<span class="gi">+            &quot;Python 3&quot;: r&quot;^\s*(class|def)\s+&quot;,</span>
<span class="gi">+            # For HTML, start at any open/close tag definition.</span>
<span class="gi">+            &quot;HTML&quot;: r&quot;&lt;[/a-zA-Z]&quot;,</span>
<span class="gi">+            # For javascript, start at a function.</span>
<span class="gi">+            &quot;JavaScript&quot;: r&quot;\bfunction\b&quot;,</span>
<span class="gi">+            # TODO: Add definitions for other languages.</span>
<span class="gi">+            #       By default, we start at every possible line.</span>
<span class="gi">+        }</span>
<span class="gi">+        p = patterns.get(lexer_cls.name, &quot;^&quot;)</span>
<span class="gi">+        return cls(p)</span>


<span class="w"> </span>class _TokenCache(Dict[Tuple[str, ...], str]):
<span class="gu">@@ -80,8 +130,8 @@ class _TokenCache(Dict[Tuple[str, ...], str]):</span>
<span class="w"> </span>    ``class:pygments,pygments.A,pygments.A.B,pygments.A.B.C``
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __missing__(self, key: tuple[str, ...]) -&gt;str:</span>
<span class="gd">-        result = &#39;class:&#39; + pygments_token_to_classname(key)</span>
<span class="gi">+    def __missing__(self, key: tuple[str, ...]) -&gt; str:</span>
<span class="gi">+        result = &quot;class:&quot; + pygments_token_to_classname(key)</span>
<span class="w"> </span>        self[key] = result
<span class="w"> </span>        return result

<span class="gu">@@ -113,31 +163,165 @@ class PygmentsLexer(Lexer):</span>
<span class="w"> </span>        than 1,000 lines.
<span class="w"> </span>    :param syntax_sync: `SyntaxSync` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Minimum amount of lines to go backwards when starting the parser.</span>
<span class="gi">+    # This is important when the lines are retrieved in reverse order, or when</span>
<span class="gi">+    # scrolling upwards. (Due to the complexity of calculating the vertical</span>
<span class="gi">+    # scroll offset in the `Window` class, lines are not always retrieved in</span>
<span class="gi">+    # order.)</span>
<span class="w"> </span>    MIN_LINES_BACKWARDS = 50
<span class="gi">+</span>
<span class="gi">+    # When a parser was started this amount of lines back, read the parser</span>
<span class="gi">+    # until we get the current line. Otherwise, start a new parser.</span>
<span class="gi">+    # (This should probably be bigger than MIN_LINES_BACKWARDS.)</span>
<span class="w"> </span>    REUSE_GENERATOR_MAX_DISTANCE = 100

<span class="gd">-    def __init__(self, pygments_lexer_cls: type[PygmentsLexerCls],</span>
<span class="gd">-        sync_from_start: FilterOrBool=True, syntax_sync: (SyntaxSync | None</span>
<span class="gd">-        )=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pygments_lexer_cls: type[PygmentsLexerCls],</span>
<span class="gi">+        sync_from_start: FilterOrBool = True,</span>
<span class="gi">+        syntax_sync: SyntaxSync | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.pygments_lexer_cls = pygments_lexer_cls
<span class="w"> </span>        self.sync_from_start = to_filter(sync_from_start)
<span class="gd">-        self.pygments_lexer = pygments_lexer_cls(stripnl=False, stripall=</span>
<span class="gd">-            False, ensurenl=False)</span>
<span class="gi">+</span>
<span class="gi">+        # Instantiate the Pygments lexer.</span>
<span class="gi">+        self.pygments_lexer = pygments_lexer_cls(</span>
<span class="gi">+            stripnl=False, stripall=False, ensurenl=False</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Create syntax sync instance.</span>
<span class="w"> </span>        self.syntax_sync = syntax_sync or RegexSync.from_pygments_lexer_cls(
<span class="gd">-            pygments_lexer_cls)</span>
<span class="gi">+            pygments_lexer_cls</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_filename(cls, filename: str, sync_from_start: FilterOrBool=True</span>
<span class="gd">-        ) -&gt;Lexer:</span>
<span class="gi">+    def from_filename(</span>
<span class="gi">+        cls, filename: str, sync_from_start: FilterOrBool = True</span>
<span class="gi">+    ) -&gt; Lexer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a `Lexer` from a filename.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Inline imports: the Pygments dependency is optional!</span>
<span class="gi">+        from pygments.lexers import get_lexer_for_filename</span>
<span class="gi">+        from pygments.util import ClassNotFound</span>

<span class="gd">-    def lex_document(self, document: Document) -&gt;Callable[[int],</span>
<span class="gd">-        StyleAndTextTuples]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            pygments_lexer = get_lexer_for_filename(filename)</span>
<span class="gi">+        except ClassNotFound:</span>
<span class="gi">+            return SimpleLexer()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return cls(pygments_lexer.__class__, sync_from_start=sync_from_start)</span>
<span class="gi">+</span>
<span class="gi">+    def lex_document(self, document: Document) -&gt; Callable[[int], StyleAndTextTuples]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a lexer function that takes a line number and returns the list
<span class="w"> </span>        of (style_str, text) tuples as the Pygments lexer returns for that line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        LineGenerator = Generator[Tuple[int, StyleAndTextTuples], None, None]</span>
<span class="gi">+</span>
<span class="gi">+        # Cache of already lexed lines.</span>
<span class="gi">+        cache: dict[int, StyleAndTextTuples] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Pygments generators that are currently lexing.</span>
<span class="gi">+        # Map lexer generator to the line number.</span>
<span class="gi">+        line_generators: dict[LineGenerator, int] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def get_syntax_sync() -&gt; SyntaxSync:</span>
<span class="gi">+            &quot;The Syntax synchronization object that we currently use.&quot;</span>
<span class="gi">+            if self.sync_from_start():</span>
<span class="gi">+                return SyncFromStart()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.syntax_sync</span>
<span class="gi">+</span>
<span class="gi">+        def find_closest_generator(i: int) -&gt; LineGenerator | None:</span>
<span class="gi">+            &quot;Return a generator close to line &#39;i&#39;, or None if none was found.&quot;</span>
<span class="gi">+            for generator, lineno in line_generators.items():</span>
<span class="gi">+                if lineno &lt; i and i - lineno &lt; self.REUSE_GENERATOR_MAX_DISTANCE:</span>
<span class="gi">+                    return generator</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        def create_line_generator(start_lineno: int, column: int = 0) -&gt; LineGenerator:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Create a generator that yields the lexed lines.</span>
<span class="gi">+            Each iteration it yields a (line_number, [(style_str, text), ...]) tuple.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+            def get_text_fragments() -&gt; Iterable[tuple[str, str]]:</span>
<span class="gi">+                text = &quot;\n&quot;.join(document.lines[start_lineno:])[column:]</span>
<span class="gi">+</span>
<span class="gi">+                # We call `get_text_fragments_unprocessed`, because `get_tokens` will</span>
<span class="gi">+                # still replace \r\n and \r by \n.  (We don&#39;t want that,</span>
<span class="gi">+                # Pygments should return exactly the same amount of text, as we</span>
<span class="gi">+                # have given as input.)</span>
<span class="gi">+                for _, t, v in self.pygments_lexer.get_tokens_unprocessed(text):</span>
<span class="gi">+                    # Turn Pygments `Token` object into prompt_toolkit style</span>
<span class="gi">+                    # strings.</span>
<span class="gi">+                    yield _token_cache[t], v</span>
<span class="gi">+</span>
<span class="gi">+            yield from enumerate(split_lines(list(get_text_fragments())), start_lineno)</span>
<span class="gi">+</span>
<span class="gi">+        def get_generator(i: int) -&gt; LineGenerator:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Find an already started generator that is close, or create a new one.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            # Find closest line generator.</span>
<span class="gi">+            generator = find_closest_generator(i)</span>
<span class="gi">+            if generator:</span>
<span class="gi">+                return generator</span>
<span class="gi">+</span>
<span class="gi">+            # No generator found. Determine starting point for the syntax</span>
<span class="gi">+            # synchronization first.</span>
<span class="gi">+</span>
<span class="gi">+            # Go at least x lines back. (Make scrolling upwards more</span>
<span class="gi">+            # efficient.)</span>
<span class="gi">+            i = max(0, i - self.MIN_LINES_BACKWARDS)</span>
<span class="gi">+</span>
<span class="gi">+            if i == 0:</span>
<span class="gi">+                row = 0</span>
<span class="gi">+                column = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                row, column = get_syntax_sync().get_sync_start_position(document, i)</span>
<span class="gi">+</span>
<span class="gi">+            # Find generator close to this point, or otherwise create a new one.</span>
<span class="gi">+            generator = find_closest_generator(i)</span>
<span class="gi">+            if generator:</span>
<span class="gi">+                return generator</span>
<span class="gi">+            else:</span>
<span class="gi">+                generator = create_line_generator(row, column)</span>
<span class="gi">+</span>
<span class="gi">+            # If the column is not 0, ignore the first line. (Which is</span>
<span class="gi">+            # incomplete. This happens when the synchronization algorithm tells</span>
<span class="gi">+            # us to start parsing in the middle of a line.)</span>
<span class="gi">+            if column:</span>
<span class="gi">+                next(generator)</span>
<span class="gi">+                row += 1</span>
<span class="gi">+</span>
<span class="gi">+            line_generators[generator] = row</span>
<span class="gi">+            return generator</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            &quot;Return the tokens for a given line number.&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cache[i]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                generator = get_generator(i)</span>
<span class="gi">+</span>
<span class="gi">+                # Exhaust the generator, until we find the requested line.</span>
<span class="gi">+                for num, line in generator:</span>
<span class="gi">+                    cache[num] = line</span>
<span class="gi">+                    if num == i:</span>
<span class="gi">+                        line_generators[generator] = i</span>
<span class="gi">+</span>
<span class="gi">+                        # Remove the next item from the cache.</span>
<span class="gi">+                        # (It could happen that it&#39;s already there, because of</span>
<span class="gi">+                        # another generator that started filling these lines,</span>
<span class="gi">+                        # but we want to synchronize these lines with the</span>
<span class="gi">+                        # current lexer&#39;s state.)</span>
<span class="gi">+                        if num + 1 in cache:</span>
<span class="gi">+                            del cache[num + 1]</span>
<span class="gi">+</span>
<span class="gi">+                        return cache[num]</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        return get_line</span>
<span class="gh">diff --git a/src/prompt_toolkit/log.py b/src/prompt_toolkit/log.py</span>
<span class="gh">index 6ac74254..adb5172a 100644</span>
<span class="gd">--- a/src/prompt_toolkit/log.py</span>
<span class="gi">+++ b/src/prompt_toolkit/log.py</span>
<span class="gu">@@ -2,6 +2,11 @@</span>
<span class="w"> </span>Logging configuration.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="gd">-__all__ = [&#39;logger&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;logger&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__package__)
<span class="gh">diff --git a/src/prompt_toolkit/mouse_events.py b/src/prompt_toolkit/mouse_events.py</span>
<span class="gh">index 304c3a19..743773b5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/mouse_events.py</span>
<span class="gi">+++ b/src/prompt_toolkit/mouse_events.py</span>
<span class="gu">@@ -16,31 +16,48 @@ coordinates to coordinates relative to the user control, and there</span>
<span class="w"> </span>`UIControl.mouse_handler` is called.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from enum import Enum
<span class="gi">+</span>
<span class="w"> </span>from .data_structures import Point
<span class="gd">-__all__ = [&#39;MouseEventType&#39;, &#39;MouseButton&#39;, &#39;MouseModifier&#39;, &#39;MouseEvent&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;MouseEventType&quot;, &quot;MouseButton&quot;, &quot;MouseModifier&quot;, &quot;MouseEvent&quot;]</span>


<span class="w"> </span>class MouseEventType(Enum):
<span class="gd">-    MOUSE_UP = &#39;MOUSE_UP&#39;</span>
<span class="gd">-    MOUSE_DOWN = &#39;MOUSE_DOWN&#39;</span>
<span class="gd">-    SCROLL_UP = &#39;SCROLL_UP&#39;</span>
<span class="gd">-    SCROLL_DOWN = &#39;SCROLL_DOWN&#39;</span>
<span class="gd">-    MOUSE_MOVE = &#39;MOUSE_MOVE&#39;</span>
<span class="gi">+    # Mouse up: This same event type is fired for all three events: left mouse</span>
<span class="gi">+    # up, right mouse up, or middle mouse up</span>
<span class="gi">+    MOUSE_UP = &quot;MOUSE_UP&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Mouse down: This implicitly refers to the left mouse down (this event is</span>
<span class="gi">+    # not fired upon pressing the middle or right mouse buttons).</span>
<span class="gi">+    MOUSE_DOWN = &quot;MOUSE_DOWN&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SCROLL_UP = &quot;SCROLL_UP&quot;</span>
<span class="gi">+    SCROLL_DOWN = &quot;SCROLL_DOWN&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Triggered when the left mouse button is held down, and the mouse moves</span>
<span class="gi">+    MOUSE_MOVE = &quot;MOUSE_MOVE&quot;</span>


<span class="w"> </span>class MouseButton(Enum):
<span class="gd">-    LEFT = &#39;LEFT&#39;</span>
<span class="gd">-    MIDDLE = &#39;MIDDLE&#39;</span>
<span class="gd">-    RIGHT = &#39;RIGHT&#39;</span>
<span class="gd">-    NONE = &#39;NONE&#39;</span>
<span class="gd">-    UNKNOWN = &#39;UNKNOWN&#39;</span>
<span class="gi">+    LEFT = &quot;LEFT&quot;</span>
<span class="gi">+    MIDDLE = &quot;MIDDLE&quot;</span>
<span class="gi">+    RIGHT = &quot;RIGHT&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # When we&#39;re scrolling, or just moving the mouse and not pressing a button.</span>
<span class="gi">+    NONE = &quot;NONE&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # This is for when we don&#39;t know which mouse button was pressed, but we do</span>
<span class="gi">+    # know that one has been pressed during this mouse event (as opposed to</span>
<span class="gi">+    # scrolling, for example)</span>
<span class="gi">+    UNKNOWN = &quot;UNKNOWN&quot;</span>


<span class="w"> </span>class MouseModifier(Enum):
<span class="gd">-    SHIFT = &#39;SHIFT&#39;</span>
<span class="gd">-    ALT = &#39;ALT&#39;</span>
<span class="gd">-    CONTROL = &#39;CONTROL&#39;</span>
<span class="gi">+    SHIFT = &quot;SHIFT&quot;</span>
<span class="gi">+    ALT = &quot;ALT&quot;</span>
<span class="gi">+    CONTROL = &quot;CONTROL&quot;</span>


<span class="w"> </span>class MouseEvent:
<span class="gu">@@ -51,13 +68,22 @@ class MouseEvent:</span>
<span class="w"> </span>    :param event_type: `MouseEventType`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, position: Point, event_type: MouseEventType, button:</span>
<span class="gd">-        MouseButton, modifiers: frozenset[MouseModifier]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        position: Point,</span>
<span class="gi">+        event_type: MouseEventType,</span>
<span class="gi">+        button: MouseButton,</span>
<span class="gi">+        modifiers: frozenset[MouseModifier],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.position = position
<span class="w"> </span>        self.event_type = event_type
<span class="w"> </span>        self.button = button
<span class="w"> </span>        self.modifiers = modifiers

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;MouseEvent({!r},{!r},{!r},{!r})&#39;.format(self.position, self</span>
<span class="gd">-            .event_type, self.button, self.modifiers)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;MouseEvent({!r},{!r},{!r},{!r})&quot;.format(</span>
<span class="gi">+            self.position,</span>
<span class="gi">+            self.event_type,</span>
<span class="gi">+            self.button,</span>
<span class="gi">+            self.modifiers,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/base.py b/src/prompt_toolkit/output/base.py</span>
<span class="gh">index 8c4343ff..3c38cec8 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/base.py</span>
<span class="gu">@@ -2,13 +2,20 @@</span>
<span class="w"> </span>Interface for an output.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TextIO
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cursor_shapes import CursorShape
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.styles import Attrs
<span class="gi">+</span>
<span class="w"> </span>from .color_depth import ColorDepth
<span class="gd">-__all__ = [&#39;Output&#39;, &#39;DummyOutput&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Output&quot;,</span>
<span class="gi">+    &quot;DummyOutput&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Output(metaclass=ABCMeta):
<span class="gu">@@ -20,165 +27,138 @@ class Output(metaclass=ABCMeta):</span>
<span class="w"> </span>    :class:`~prompt_toolkit.output.vt100.Vt100_Output` and
<span class="w"> </span>    :class:`~prompt_toolkit.output.win32.Win32Output`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    stdout: TextIO | None = None

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;Return the file descriptor to which we can write for the output.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        &quot;Return the file descriptor to which we can write for the output.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def encoding(self) -&gt;str:</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the encoding for this output, e.g. &#39;utf-8&#39;.
<span class="w"> </span>        (This is used mainly to know which characters are supported by the
<span class="w"> </span>        output the data, so that the UI can provide alternatives, when
<span class="w"> </span>        required.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def write(self, data: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Write text (Terminal escape sequences will be removed/escaped.)&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        &quot;Write text (Terminal escape sequences will be removed/escaped.)&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def write_raw(self, data: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Write text.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def write_raw(self, data: str) -&gt; None:</span>
<span class="gi">+        &quot;Write text.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def set_title(self, title: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Set terminal title.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def set_title(self, title: str) -&gt; None:</span>
<span class="gi">+        &quot;Set terminal title.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def clear_title(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Clear title again. (or restore previous title.)&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def clear_title(self) -&gt; None:</span>
<span class="gi">+        &quot;Clear title again. (or restore previous title.)&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Write to output stream and flush.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        &quot;Write to output stream and flush.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def erase_screen(self) -&gt;None:</span>
<span class="gi">+    def erase_screen(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erases the screen with the background color and moves the cursor to
<span class="w"> </span>        home.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def enter_alternate_screen(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Go to the alternate screen buffer. (For full screen applications).&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def enter_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        &quot;Go to the alternate screen buffer. (For full screen applications).&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def quit_alternate_screen(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Leave the alternate screen buffer.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def quit_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        &quot;Leave the alternate screen buffer.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def enable_mouse_support(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Enable mouse.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def enable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        &quot;Enable mouse.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def disable_mouse_support(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Disable mouse.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def disable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        &quot;Disable mouse.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def erase_end_of_line(self) -&gt;None:</span>
<span class="gi">+    def erase_end_of_line(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erases from the current cursor position to the end of the current line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def erase_down(self) -&gt;None:</span>
<span class="gi">+    def erase_down(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erases the screen from the current line down to the bottom of the
<span class="w"> </span>        screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def reset_attributes(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Reset color and styling attributes.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def reset_attributes(self) -&gt; None:</span>
<span class="gi">+        &quot;Reset color and styling attributes.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Set new color and styling attributes.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt; None:</span>
<span class="gi">+        &quot;Set new color and styling attributes.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def disable_autowrap(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Disable auto line wrapping.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def disable_autowrap(self) -&gt; None:</span>
<span class="gi">+        &quot;Disable auto line wrapping.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def enable_autowrap(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Enable auto line wrapping.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def enable_autowrap(self) -&gt; None:</span>
<span class="gi">+        &quot;Enable auto line wrapping.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def cursor_goto(self, row: int=0, column: int=0) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Move cursor position.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_goto(self, row: int = 0, column: int = 0) -&gt; None:</span>
<span class="gi">+        &quot;Move cursor position.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def cursor_up(self, amount: int) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Move cursor `amount` place up.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_up(self, amount: int) -&gt; None:</span>
<span class="gi">+        &quot;Move cursor `amount` place up.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def cursor_down(self, amount: int) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Move cursor `amount` place down.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_down(self, amount: int) -&gt; None:</span>
<span class="gi">+        &quot;Move cursor `amount` place down.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def cursor_forward(self, amount: int) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Move cursor `amount` place forward.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_forward(self, amount: int) -&gt; None:</span>
<span class="gi">+        &quot;Move cursor `amount` place forward.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def cursor_backward(self, amount: int) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Move cursor `amount` place backward.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_backward(self, amount: int) -&gt; None:</span>
<span class="gi">+        &quot;Move cursor `amount` place backward.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def hide_cursor(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Hide cursor.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def hide_cursor(self) -&gt; None:</span>
<span class="gi">+        &quot;Hide cursor.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def show_cursor(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Show cursor.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def show_cursor(self) -&gt; None:</span>
<span class="gi">+        &quot;Show cursor.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def set_cursor_shape(self, cursor_shape: CursorShape) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Set cursor shape to block, beam or underline.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def set_cursor_shape(self, cursor_shape: CursorShape) -&gt; None:</span>
<span class="gi">+        &quot;Set cursor shape to block, beam or underline.&quot;</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def reset_cursor_shape(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Reset cursor shape.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def reset_cursor_shape(self) -&gt; None:</span>
<span class="gi">+        &quot;Reset cursor shape.&quot;</span>

<span class="gd">-    def ask_for_cpr(self) -&gt;None:</span>
<span class="gi">+    def ask_for_cpr(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asks for a cursor position report (CPR).
<span class="w"> </span>        (VT100 only.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @property
<span class="gd">-    def responds_to_cpr(self) -&gt;bool:</span>
<span class="gi">+    def responds_to_cpr(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        `True` if the `Application` can expect to receive a CPR response after
<span class="w"> </span>        calling `ask_for_cpr` (this will come back through the corresponding
<span class="gu">@@ -191,44 +171,38 @@ class Output(metaclass=ABCMeta):</span>
<span class="w"> </span>        On Windows, we don&#39;t need this, there we have
<span class="w"> </span>        `get_rows_below_cursor_position`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_size(self) -&gt;Size:</span>
<span class="gd">-        &quot;&quot;&quot;Return the size of the output window.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_size(self) -&gt; Size:</span>
<span class="gi">+        &quot;Return the size of the output window.&quot;</span>

<span class="gd">-    def bell(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Sound bell.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def bell(self) -&gt; None:</span>
<span class="gi">+        &quot;Sound bell.&quot;</span>

<span class="gd">-    def enable_bracketed_paste(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;For vt100 only.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def enable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        &quot;For vt100 only.&quot;</span>

<span class="gd">-    def disable_bracketed_paste(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;For vt100 only.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def disable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        &quot;For vt100 only.&quot;</span>

<span class="gd">-    def reset_cursor_key_mode(self) -&gt;None:</span>
<span class="gi">+    def reset_cursor_key_mode(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For vt100 only.
<span class="w"> </span>        Put the terminal in normal cursor mode (instead of application mode).

<span class="w"> </span>        See: https://vt100.net/docs/vt100-ug/chapter3.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def scroll_buffer_to_prompt(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;For Win32 only.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def scroll_buffer_to_prompt(self) -&gt; None:</span>
<span class="gi">+        &quot;For Win32 only.&quot;</span>

<span class="gd">-    def get_rows_below_cursor_position(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;For Windows only.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_rows_below_cursor_position(self) -&gt; int:</span>
<span class="gi">+        &quot;For Windows only.&quot;</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_default_color_depth(self) -&gt;ColorDepth:</span>
<span class="gi">+    def get_default_color_depth(self) -&gt; ColorDepth:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get default color depth for this output.

<span class="gu">@@ -243,7 +217,6 @@ class Output(metaclass=ABCMeta):</span>
<span class="w"> </span>            here. (This is not used when the output corresponds to a
<span class="w"> </span>            prompt_toolkit SSH/Telnet session.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class DummyOutput(Output):
<span class="gu">@@ -251,6 +224,108 @@ class DummyOutput(Output):</span>
<span class="w"> </span>    For testing. An output class that doesn&#39;t render anything.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;There is no sensible default for fileno().&quot;&quot;&quot;</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        &quot;There is no sensible default for fileno().&quot;</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="gi">+        return &quot;utf-8&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def write_raw(self, data: str) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_title(self, title: str) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def clear_title(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def erase_screen(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enter_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def quit_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def disable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def erase_end_of_line(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def erase_down(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def reset_attributes(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def disable_autowrap(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enable_autowrap(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_goto(self, row: int = 0, column: int = 0) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_up(self, amount: int) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_down(self, amount: int) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_forward(self, amount: int) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_backward(self, amount: int) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def hide_cursor(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def show_cursor(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_cursor_shape(self, cursor_shape: CursorShape) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def reset_cursor_shape(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def ask_for_cpr(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def bell(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def disable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_buffer_to_prompt(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_size(self) -&gt; Size:</span>
<span class="gi">+        return Size(rows=40, columns=80)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rows_below_cursor_position(self) -&gt; int:</span>
<span class="gi">+        return 40</span>
<span class="gi">+</span>
<span class="gi">+    def get_default_color_depth(self) -&gt; ColorDepth:</span>
<span class="gi">+        return ColorDepth.DEPTH_1_BIT</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/color_depth.py b/src/prompt_toolkit/output/color_depth.py</span>
<span class="gh">index 079d6e36..f66d2bea 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/color_depth.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/color_depth.py</span>
<span class="gu">@@ -1,25 +1,40 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from enum import Enum
<span class="gd">-__all__ = [&#39;ColorDepth&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ColorDepth&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ColorDepth(str, Enum):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Possible color depth values for the output.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    value: str
<span class="gd">-    DEPTH_1_BIT = &#39;DEPTH_1_BIT&#39;</span>
<span class="gd">-    DEPTH_4_BIT = &#39;DEPTH_4_BIT&#39;</span>
<span class="gd">-    DEPTH_8_BIT = &#39;DEPTH_8_BIT&#39;</span>
<span class="gd">-    DEPTH_24_BIT = &#39;DEPTH_24_BIT&#39;</span>
<span class="gi">+</span>
<span class="gi">+    #: One color only.</span>
<span class="gi">+    DEPTH_1_BIT = &quot;DEPTH_1_BIT&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: ANSI Colors.</span>
<span class="gi">+    DEPTH_4_BIT = &quot;DEPTH_4_BIT&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: The default.</span>
<span class="gi">+    DEPTH_8_BIT = &quot;DEPTH_8_BIT&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: 24 bit True color.</span>
<span class="gi">+    DEPTH_24_BIT = &quot;DEPTH_24_BIT&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Aliases.</span>
<span class="w"> </span>    MONOCHROME = DEPTH_1_BIT
<span class="w"> </span>    ANSI_COLORS_ONLY = DEPTH_4_BIT
<span class="w"> </span>    DEFAULT = DEPTH_8_BIT
<span class="w"> </span>    TRUE_COLOR = DEPTH_24_BIT

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_env(cls) -&gt;(ColorDepth | None):</span>
<span class="gi">+    def from_env(cls) -&gt; ColorDepth | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the color depth if the $PROMPT_TOOLKIT_COLOR_DEPTH environment
<span class="w"> </span>        variable has been set.
<span class="gu">@@ -27,11 +42,23 @@ class ColorDepth(str, Enum):</span>
<span class="w"> </span>        This is a way to enforce a certain color depth in all prompt_toolkit
<span class="w"> </span>        applications.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Disable color if a `NO_COLOR` environment variable is set.</span>
<span class="gi">+        # See: https://no-color.org/</span>
<span class="gi">+        if os.environ.get(&quot;NO_COLOR&quot;):</span>
<span class="gi">+            return cls.DEPTH_1_BIT</span>
<span class="gi">+</span>
<span class="gi">+        # Check the `PROMPT_TOOLKIT_COLOR_DEPTH` environment variable.</span>
<span class="gi">+        all_values = [i.value for i in ColorDepth]</span>
<span class="gi">+        if os.environ.get(&quot;PROMPT_TOOLKIT_COLOR_DEPTH&quot;) in all_values:</span>
<span class="gi">+            return cls(os.environ[&quot;PROMPT_TOOLKIT_COLOR_DEPTH&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def default(cls) -&gt;ColorDepth:</span>
<span class="gi">+    def default(cls) -&gt; ColorDepth:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the default color depth for the default output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .defaults import create_output</span>
<span class="gi">+</span>
<span class="gi">+        return create_output().get_default_color_depth()</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/conemu.py b/src/prompt_toolkit/output/conemu.py</span>
<span class="gh">index 120f4767..63699449 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/conemu.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/conemu.py</span>
<span class="gu">@@ -1,13 +1,21 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="gi">+</span>
<span class="w"> </span>from .base import Output
<span class="w"> </span>from .color_depth import ColorDepth
<span class="w"> </span>from .vt100 import Vt100_Output
<span class="w"> </span>from .win32 import Win32Output
<span class="gd">-__all__ = [&#39;ConEmuOutput&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ConEmuOutput&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ConEmuOutput:
<span class="gu">@@ -26,18 +34,29 @@ class ConEmuOutput:</span>
<span class="w"> </span>    http://gooseberrycreative.com/cmder/
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stdout: TextIO, default_color_depth: (ColorDepth |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gd">-        self.win32_output = Win32Output(stdout, default_color_depth=</span>
<span class="gd">-            default_color_depth)</span>
<span class="gd">-        self.vt100_output = Vt100_Output(stdout, lambda : Size(0, 0),</span>
<span class="gd">-            default_color_depth=default_color_depth)</span>
<span class="gd">-</span>
<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gd">-        if name in (&#39;get_size&#39;, &#39;get_rows_below_cursor_position&#39;,</span>
<span class="gd">-            &#39;enable_mouse_support&#39;, &#39;disable_mouse_support&#39;,</span>
<span class="gd">-            &#39;scroll_buffer_to_prompt&#39;, &#39;get_win32_screen_buffer_info&#39;,</span>
<span class="gd">-            &#39;enable_bracketed_paste&#39;, &#39;disable_bracketed_paste&#39;):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, stdout: TextIO, default_color_depth: ColorDepth | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.win32_output = Win32Output(stdout, default_color_depth=default_color_depth)</span>
<span class="gi">+        self.vt100_output = Vt100_Output(</span>
<span class="gi">+            stdout, lambda: Size(0, 0), default_color_depth=default_color_depth</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def responds_to_cpr(self) -&gt; bool:</span>
<span class="gi">+        return False  # We don&#39;t need this on Windows.</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="gi">+        if name in (</span>
<span class="gi">+            &quot;get_size&quot;,</span>
<span class="gi">+            &quot;get_rows_below_cursor_position&quot;,</span>
<span class="gi">+            &quot;enable_mouse_support&quot;,</span>
<span class="gi">+            &quot;disable_mouse_support&quot;,</span>
<span class="gi">+            &quot;scroll_buffer_to_prompt&quot;,</span>
<span class="gi">+            &quot;get_win32_screen_buffer_info&quot;,</span>
<span class="gi">+            &quot;enable_bracketed_paste&quot;,</span>
<span class="gi">+            &quot;disable_bracketed_paste&quot;,</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return getattr(self.win32_output, name)
<span class="w"> </span>        else:
<span class="w"> </span>            return getattr(self.vt100_output, name)
<span class="gh">diff --git a/src/prompt_toolkit/output/defaults.py b/src/prompt_toolkit/output/defaults.py</span>
<span class="gh">index 396c16f3..ed114e32 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/defaults.py</span>
<span class="gu">@@ -1,15 +1,26 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TextIO, cast
<span class="gd">-from prompt_toolkit.utils import get_bell_environment_variable, get_term_environment_variable, is_conemu_ansi</span>
<span class="gi">+</span>
<span class="gi">+from prompt_toolkit.utils import (</span>
<span class="gi">+    get_bell_environment_variable,</span>
<span class="gi">+    get_term_environment_variable,</span>
<span class="gi">+    is_conemu_ansi,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .base import DummyOutput, Output
<span class="w"> </span>from .color_depth import ColorDepth
<span class="w"> </span>from .plain_text import PlainTextOutput
<span class="gd">-__all__ = [&#39;create_output&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;create_output&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def create_output(stdout: (TextIO | None)=None, always_prefer_tty: bool=False</span>
<span class="gd">-    ) -&gt;Output:</span>
<span class="gi">+def create_output(</span>
<span class="gi">+    stdout: TextIO | None = None, always_prefer_tty: bool = False</span>
<span class="gi">+) -&gt; Output:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return an :class:`~prompt_toolkit.output.Output` instance for the command
<span class="w"> </span>    line.
<span class="gu">@@ -24,4 +35,68 @@ def create_output(stdout: (TextIO | None)=None, always_prefer_tty: bool=False</span>
<span class="w"> </span>        That way, tools like `print_formatted_text` will write plain text into
<span class="w"> </span>        that file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Consider TERM, PROMPT_TOOLKIT_BELL, and PROMPT_TOOLKIT_COLOR_DEPTH</span>
<span class="gi">+    # environment variables. Notice that PROMPT_TOOLKIT_COLOR_DEPTH value is</span>
<span class="gi">+    # the default that&#39;s used if the Application doesn&#39;t override it.</span>
<span class="gi">+    term_from_env = get_term_environment_variable()</span>
<span class="gi">+    bell_from_env = get_bell_environment_variable()</span>
<span class="gi">+    color_depth_from_env = ColorDepth.from_env()</span>
<span class="gi">+</span>
<span class="gi">+    if stdout is None:</span>
<span class="gi">+        # By default, render to stdout. If the output is piped somewhere else,</span>
<span class="gi">+        # render to stderr.</span>
<span class="gi">+        stdout = sys.stdout</span>
<span class="gi">+</span>
<span class="gi">+        if always_prefer_tty:</span>
<span class="gi">+            for io in [sys.stdout, sys.stderr]:</span>
<span class="gi">+                if io is not None and io.isatty():</span>
<span class="gi">+                    # (This is `None` when using `pythonw.exe` on Windows.)</span>
<span class="gi">+                    stdout = io</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+    # If the output is still `None`, use a DummyOutput.</span>
<span class="gi">+    # This happens for instance on Windows, when running the application under</span>
<span class="gi">+    # `pythonw.exe`. In that case, there won&#39;t be a terminal Window, and</span>
<span class="gi">+    # stdin/stdout/stderr are `None`.</span>
<span class="gi">+    if stdout is None:</span>
<span class="gi">+        return DummyOutput()</span>
<span class="gi">+</span>
<span class="gi">+    # If the patch_stdout context manager has been used, then sys.stdout is</span>
<span class="gi">+    # replaced by this proxy. For prompt_toolkit applications, we want to use</span>
<span class="gi">+    # the real stdout.</span>
<span class="gi">+    from prompt_toolkit.patch_stdout import StdoutProxy</span>
<span class="gi">+</span>
<span class="gi">+    while isinstance(stdout, StdoutProxy):</span>
<span class="gi">+        stdout = stdout.original_stdout</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        from .conemu import ConEmuOutput</span>
<span class="gi">+        from .win32 import Win32Output</span>
<span class="gi">+        from .windows10 import Windows10_Output, is_win_vt100_enabled</span>
<span class="gi">+</span>
<span class="gi">+        if is_win_vt100_enabled():</span>
<span class="gi">+            return cast(</span>
<span class="gi">+                Output,</span>
<span class="gi">+                Windows10_Output(stdout, default_color_depth=color_depth_from_env),</span>
<span class="gi">+            )</span>
<span class="gi">+        if is_conemu_ansi():</span>
<span class="gi">+            return cast(</span>
<span class="gi">+                Output, ConEmuOutput(stdout, default_color_depth=color_depth_from_env)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Win32Output(stdout, default_color_depth=color_depth_from_env)</span>
<span class="gi">+    else:</span>
<span class="gi">+        from .vt100 import Vt100_Output</span>
<span class="gi">+</span>
<span class="gi">+        # Stdout is not a TTY? Render as plain text.</span>
<span class="gi">+        # This is mostly useful if stdout is redirected to a file, and</span>
<span class="gi">+        # `print_formatted_text` is used.</span>
<span class="gi">+        if not stdout.isatty():</span>
<span class="gi">+            return PlainTextOutput(stdout)</span>
<span class="gi">+</span>
<span class="gi">+        return Vt100_Output.from_pty(</span>
<span class="gi">+            stdout,</span>
<span class="gi">+            term=term_from_env,</span>
<span class="gi">+            default_color_depth=color_depth_from_env,</span>
<span class="gi">+            enable_bell=bell_from_env,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/flush_stdout.py b/src/prompt_toolkit/output/flush_stdout.py</span>
<span class="gh">index 5a1f98e9..daf58efe 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/flush_stdout.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/flush_stdout.py</span>
<span class="gu">@@ -1,15 +1,87 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import errno
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from typing import IO, Iterator, TextIO
<span class="gd">-__all__ = [&#39;flush_stdout&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;flush_stdout&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def flush_stdout(stdout: TextIO, data: str) -&gt; None:</span>
<span class="gi">+    # If the IO object has an `encoding` and `buffer` attribute, it means that</span>
<span class="gi">+    # we can access the underlying BinaryIO object and write into it in binary</span>
<span class="gi">+    # mode. This is preferred if possible.</span>
<span class="gi">+    # NOTE: When used in a Jupyter notebook, don&#39;t write binary.</span>
<span class="gi">+    #       `ipykernel.iostream.OutStream` has an `encoding` attribute, but not</span>
<span class="gi">+    #       a `buffer` attribute, so we can&#39;t write binary in it.</span>
<span class="gi">+    has_binary_io = hasattr(stdout, &quot;encoding&quot;) and hasattr(stdout, &quot;buffer&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Ensure that `stdout` is made blocking when writing into it.</span>
<span class="gi">+        # Otherwise, when uvloop is activated (which makes stdout</span>
<span class="gi">+        # non-blocking), and we write big amounts of text, then we get a</span>
<span class="gi">+        # `BlockingIOError` here.</span>
<span class="gi">+        with _blocking_io(stdout):</span>
<span class="gi">+            # (We try to encode ourself, because that way we can replace</span>
<span class="gi">+            # characters that don&#39;t exist in the character set, avoiding</span>
<span class="gi">+            # UnicodeEncodeError crashes. E.g. u&#39;\xb7&#39; does not appear in &#39;ascii&#39;.)</span>
<span class="gi">+            # My Arch Linux installation of july 2015 reported &#39;ANSI_X3.4-1968&#39;</span>
<span class="gi">+            # for sys.stdout.encoding in xterm.</span>
<span class="gi">+            if has_binary_io:</span>
<span class="gi">+                stdout.buffer.write(data.encode(stdout.encoding or &quot;utf-8&quot;, &quot;replace&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                stdout.write(data)</span>
<span class="gi">+</span>
<span class="gi">+            stdout.flush()</span>
<span class="gi">+    except OSError as e:</span>
<span class="gi">+        if e.args and e.args[0] == errno.EINTR:</span>
<span class="gi">+            # Interrupted system call. Can happen in case of a window</span>
<span class="gi">+            # resize signal. (Just ignore. The resize handler will render</span>
<span class="gi">+            # again anyway.)</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif e.args and e.args[0] == 0:</span>
<span class="gi">+            # This can happen when there is a lot of output and the user</span>
<span class="gi">+            # sends a KeyboardInterrupt by pressing Control-C. E.g. in</span>
<span class="gi">+            # a Python REPL when we execute &quot;while True: print(&#39;test&#39;)&quot;.</span>
<span class="gi">+            # (The `ptpython` REPL uses this `Output` class instead of</span>
<span class="gi">+            # `stdout` directly -- in order to be network transparent.)</span>
<span class="gi">+            # So, just ignore.</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def _blocking_io(io: IO[str]) -&gt;Iterator[None]:</span>
<span class="gi">+def _blocking_io(io: IO[str]) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Ensure that the FD for `io` is set to blocking in here.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        # On Windows, the `os` module doesn&#39;t have a `get/set_blocking`</span>
<span class="gi">+        # function.</span>
<span class="gi">+        yield</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        fd = io.fileno()</span>
<span class="gi">+        blocking = os.get_blocking(fd)</span>
<span class="gi">+    except:  # noqa</span>
<span class="gi">+        # Failed somewhere.</span>
<span class="gi">+        # `get_blocking` can raise `OSError`.</span>
<span class="gi">+        # The io object can raise `AttributeError` when no `fileno()` method is</span>
<span class="gi">+        # present if we&#39;re not a real file object.</span>
<span class="gi">+        blocking = True  # Assume we&#39;re good, and don&#39;t do anything.</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Make blocking if we weren&#39;t blocking yet.</span>
<span class="gi">+        if not blocking:</span>
<span class="gi">+            os.set_blocking(fd, True)</span>
<span class="gi">+</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Restore original blocking mode.</span>
<span class="gi">+        if not blocking:</span>
<span class="gi">+            os.set_blocking(fd, blocking)</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/plain_text.py b/src/prompt_toolkit/output/plain_text.py</span>
<span class="gh">index 59ecf92e..4b24ad96 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/plain_text.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/plain_text.py</span>
<span class="gu">@@ -1,12 +1,16 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TextIO
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cursor_shapes import CursorShape
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.styles import Attrs
<span class="gi">+</span>
<span class="w"> </span>from .base import Output
<span class="w"> </span>from .color_depth import ColorDepth
<span class="w"> </span>from .flush_stdout import flush_stdout
<span class="gd">-__all__ = [&#39;PlainTextOutput&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;PlainTextOutput&quot;]</span>


<span class="w"> </span>class PlainTextOutput(Output):
<span class="gu">@@ -21,11 +25,119 @@ class PlainTextOutput(Output):</span>
<span class="w"> </span>    formatting.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stdout: TextIO) -&gt;None:</span>
<span class="gd">-        assert all(hasattr(stdout, a) for a in (&#39;write&#39;, &#39;flush&#39;))</span>
<span class="gi">+    def __init__(self, stdout: TextIO) -&gt; None:</span>
<span class="gi">+        assert all(hasattr(stdout, a) for a in (&quot;write&quot;, &quot;flush&quot;))</span>
<span class="gi">+</span>
<span class="w"> </span>        self.stdout: TextIO = stdout
<span class="w"> </span>        self._buffer: list[str] = []

<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;There is no sensible default for fileno().&quot;&quot;&quot;</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        &quot;There is no sensible default for fileno().&quot;</span>
<span class="gi">+        return self.stdout.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="gi">+        return &quot;utf-8&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        self._buffer.append(data)</span>
<span class="gi">+</span>
<span class="gi">+    def write_raw(self, data: str) -&gt; None:</span>
<span class="gi">+        self._buffer.append(data)</span>
<span class="gi">+</span>
<span class="gi">+    def set_title(self, title: str) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def clear_title(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        if not self._buffer:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        data = &quot;&quot;.join(self._buffer)</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        flush_stdout(self.stdout, data)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_screen(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enter_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def quit_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def disable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def erase_end_of_line(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def erase_down(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def reset_attributes(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def disable_autowrap(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enable_autowrap(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_goto(self, row: int = 0, column: int = 0) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_up(self, amount: int) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_down(self, amount: int) -&gt; None:</span>
<span class="gi">+        self._buffer.append(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_forward(self, amount: int) -&gt; None:</span>
<span class="gi">+        self._buffer.append(&quot; &quot; * amount)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_backward(self, amount: int) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def hide_cursor(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def show_cursor(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_cursor_shape(self, cursor_shape: CursorShape) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def reset_cursor_shape(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def ask_for_cpr(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def bell(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def enable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def disable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_buffer_to_prompt(self) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def get_size(self) -&gt; Size:</span>
<span class="gi">+        return Size(rows=40, columns=80)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rows_below_cursor_position(self) -&gt; int:</span>
<span class="gi">+        return 8</span>
<span class="gi">+</span>
<span class="gi">+    def get_default_color_depth(self) -&gt; ColorDepth:</span>
<span class="gi">+        return ColorDepth.DEPTH_1_BIT</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/vt100.py b/src/prompt_toolkit/output/vt100.py</span>
<span class="gh">index d371a044..142deab0 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/vt100.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/vt100.py</span>
<span class="gu">@@ -7,43 +7,104 @@ everything has been highly optimized.)</span>
<span class="w"> </span>http://pygments.org/
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import io
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from typing import Callable, Dict, Hashable, Iterable, Sequence, TextIO, Tuple
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cursor_shapes import CursorShape
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.output import Output
<span class="w"> </span>from prompt_toolkit.styles import ANSI_COLOR_NAMES, Attrs
<span class="w"> </span>from prompt_toolkit.utils import is_dumb_terminal
<span class="gi">+</span>
<span class="w"> </span>from .color_depth import ColorDepth
<span class="w"> </span>from .flush_stdout import flush_stdout
<span class="gd">-__all__ = [&#39;Vt100_Output&#39;]</span>
<span class="gd">-FG_ANSI_COLORS = {&#39;ansidefault&#39;: 39, &#39;ansiblack&#39;: 30, &#39;ansired&#39;: 31,</span>
<span class="gd">-    &#39;ansigreen&#39;: 32, &#39;ansiyellow&#39;: 33, &#39;ansiblue&#39;: 34, &#39;ansimagenta&#39;: 35,</span>
<span class="gd">-    &#39;ansicyan&#39;: 36, &#39;ansigray&#39;: 37, &#39;ansibrightblack&#39;: 90, &#39;ansibrightred&#39;:</span>
<span class="gd">-    91, &#39;ansibrightgreen&#39;: 92, &#39;ansibrightyellow&#39;: 93, &#39;ansibrightblue&#39;: 94,</span>
<span class="gd">-    &#39;ansibrightmagenta&#39;: 95, &#39;ansibrightcyan&#39;: 96, &#39;ansiwhite&#39;: 97}</span>
<span class="gd">-BG_ANSI_COLORS = {&#39;ansidefault&#39;: 49, &#39;ansiblack&#39;: 40, &#39;ansired&#39;: 41,</span>
<span class="gd">-    &#39;ansigreen&#39;: 42, &#39;ansiyellow&#39;: 43, &#39;ansiblue&#39;: 44, &#39;ansimagenta&#39;: 45,</span>
<span class="gd">-    &#39;ansicyan&#39;: 46, &#39;ansigray&#39;: 47, &#39;ansibrightblack&#39;: 100, &#39;ansibrightred&#39;:</span>
<span class="gd">-    101, &#39;ansibrightgreen&#39;: 102, &#39;ansibrightyellow&#39;: 103, &#39;ansibrightblue&#39;:</span>
<span class="gd">-    104, &#39;ansibrightmagenta&#39;: 105, &#39;ansibrightcyan&#39;: 106, &#39;ansiwhite&#39;: 107}</span>
<span class="gd">-ANSI_COLORS_TO_RGB = {&#39;ansidefault&#39;: (0, 0, 0), &#39;ansiblack&#39;: (0, 0, 0),</span>
<span class="gd">-    &#39;ansigray&#39;: (229, 229, 229), &#39;ansibrightblack&#39;: (127, 127, 127),</span>
<span class="gd">-    &#39;ansiwhite&#39;: (255, 255, 255), &#39;ansired&#39;: (205, 0, 0), &#39;ansigreen&#39;: (0, </span>
<span class="gd">-    205, 0), &#39;ansiyellow&#39;: (205, 205, 0), &#39;ansiblue&#39;: (0, 0, 205),</span>
<span class="gd">-    &#39;ansimagenta&#39;: (205, 0, 205), &#39;ansicyan&#39;: (0, 205, 205),</span>
<span class="gd">-    &#39;ansibrightred&#39;: (255, 0, 0), &#39;ansibrightgreen&#39;: (0, 255, 0),</span>
<span class="gd">-    &#39;ansibrightyellow&#39;: (255, 255, 0), &#39;ansibrightblue&#39;: (0, 0, 255),</span>
<span class="gd">-    &#39;ansibrightmagenta&#39;: (255, 0, 255), &#39;ansibrightcyan&#39;: (0, 255, 255)}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Vt100_Output&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+FG_ANSI_COLORS = {</span>
<span class="gi">+    &quot;ansidefault&quot;: 39,</span>
<span class="gi">+    # Low intensity.</span>
<span class="gi">+    &quot;ansiblack&quot;: 30,</span>
<span class="gi">+    &quot;ansired&quot;: 31,</span>
<span class="gi">+    &quot;ansigreen&quot;: 32,</span>
<span class="gi">+    &quot;ansiyellow&quot;: 33,</span>
<span class="gi">+    &quot;ansiblue&quot;: 34,</span>
<span class="gi">+    &quot;ansimagenta&quot;: 35,</span>
<span class="gi">+    &quot;ansicyan&quot;: 36,</span>
<span class="gi">+    &quot;ansigray&quot;: 37,</span>
<span class="gi">+    # High intensity.</span>
<span class="gi">+    &quot;ansibrightblack&quot;: 90,</span>
<span class="gi">+    &quot;ansibrightred&quot;: 91,</span>
<span class="gi">+    &quot;ansibrightgreen&quot;: 92,</span>
<span class="gi">+    &quot;ansibrightyellow&quot;: 93,</span>
<span class="gi">+    &quot;ansibrightblue&quot;: 94,</span>
<span class="gi">+    &quot;ansibrightmagenta&quot;: 95,</span>
<span class="gi">+    &quot;ansibrightcyan&quot;: 96,</span>
<span class="gi">+    &quot;ansiwhite&quot;: 97,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+BG_ANSI_COLORS = {</span>
<span class="gi">+    &quot;ansidefault&quot;: 49,</span>
<span class="gi">+    # Low intensity.</span>
<span class="gi">+    &quot;ansiblack&quot;: 40,</span>
<span class="gi">+    &quot;ansired&quot;: 41,</span>
<span class="gi">+    &quot;ansigreen&quot;: 42,</span>
<span class="gi">+    &quot;ansiyellow&quot;: 43,</span>
<span class="gi">+    &quot;ansiblue&quot;: 44,</span>
<span class="gi">+    &quot;ansimagenta&quot;: 45,</span>
<span class="gi">+    &quot;ansicyan&quot;: 46,</span>
<span class="gi">+    &quot;ansigray&quot;: 47,</span>
<span class="gi">+    # High intensity.</span>
<span class="gi">+    &quot;ansibrightblack&quot;: 100,</span>
<span class="gi">+    &quot;ansibrightred&quot;: 101,</span>
<span class="gi">+    &quot;ansibrightgreen&quot;: 102,</span>
<span class="gi">+    &quot;ansibrightyellow&quot;: 103,</span>
<span class="gi">+    &quot;ansibrightblue&quot;: 104,</span>
<span class="gi">+    &quot;ansibrightmagenta&quot;: 105,</span>
<span class="gi">+    &quot;ansibrightcyan&quot;: 106,</span>
<span class="gi">+    &quot;ansiwhite&quot;: 107,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ANSI_COLORS_TO_RGB = {</span>
<span class="gi">+    &quot;ansidefault&quot;: (</span>
<span class="gi">+        0x00,</span>
<span class="gi">+        0x00,</span>
<span class="gi">+        0x00,</span>
<span class="gi">+    ),  # Don&#39;t use, &#39;default&#39; doesn&#39;t really have a value.</span>
<span class="gi">+    &quot;ansiblack&quot;: (0x00, 0x00, 0x00),</span>
<span class="gi">+    &quot;ansigray&quot;: (0xE5, 0xE5, 0xE5),</span>
<span class="gi">+    &quot;ansibrightblack&quot;: (0x7F, 0x7F, 0x7F),</span>
<span class="gi">+    &quot;ansiwhite&quot;: (0xFF, 0xFF, 0xFF),</span>
<span class="gi">+    # Low intensity.</span>
<span class="gi">+    &quot;ansired&quot;: (0xCD, 0x00, 0x00),</span>
<span class="gi">+    &quot;ansigreen&quot;: (0x00, 0xCD, 0x00),</span>
<span class="gi">+    &quot;ansiyellow&quot;: (0xCD, 0xCD, 0x00),</span>
<span class="gi">+    &quot;ansiblue&quot;: (0x00, 0x00, 0xCD),</span>
<span class="gi">+    &quot;ansimagenta&quot;: (0xCD, 0x00, 0xCD),</span>
<span class="gi">+    &quot;ansicyan&quot;: (0x00, 0xCD, 0xCD),</span>
<span class="gi">+    # High intensity.</span>
<span class="gi">+    &quot;ansibrightred&quot;: (0xFF, 0x00, 0x00),</span>
<span class="gi">+    &quot;ansibrightgreen&quot;: (0x00, 0xFF, 0x00),</span>
<span class="gi">+    &quot;ansibrightyellow&quot;: (0xFF, 0xFF, 0x00),</span>
<span class="gi">+    &quot;ansibrightblue&quot;: (0x00, 0x00, 0xFF),</span>
<span class="gi">+    &quot;ansibrightmagenta&quot;: (0xFF, 0x00, 0xFF),</span>
<span class="gi">+    &quot;ansibrightcyan&quot;: (0x00, 0xFF, 0xFF),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>assert set(FG_ANSI_COLORS) == set(ANSI_COLOR_NAMES)
<span class="w"> </span>assert set(BG_ANSI_COLORS) == set(ANSI_COLOR_NAMES)
<span class="w"> </span>assert set(ANSI_COLORS_TO_RGB) == set(ANSI_COLOR_NAMES)


<span class="gd">-def _get_closest_ansi_color(r: int, g: int, b: int, exclude: Sequence[str]=()</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def _get_closest_ansi_color(r: int, g: int, b: int, exclude: Sequence[str] = ()) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find closest ANSI color. Return it by name.

<span class="gu">@@ -52,7 +113,29 @@ def _get_closest_ansi_color(r: int, g: int, b: int, exclude: Sequence[str]=()</span>
<span class="w"> </span>    :param b: Blue (Between 0 and 255.)
<span class="w"> </span>    :param exclude: A tuple of color names to exclude. (E.g. ``(&#39;ansired&#39;, )``.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exclude = list(exclude)</span>
<span class="gi">+</span>
<span class="gi">+    # When we have a bit of saturation, avoid the gray-like colors, otherwise,</span>
<span class="gi">+    # too often the distance to the gray color is less.</span>
<span class="gi">+    saturation = abs(r - g) + abs(g - b) + abs(b - r)  # Between 0..510</span>
<span class="gi">+</span>
<span class="gi">+    if saturation &gt; 30:</span>
<span class="gi">+        exclude.extend([&quot;ansilightgray&quot;, &quot;ansidarkgray&quot;, &quot;ansiwhite&quot;, &quot;ansiblack&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    # Take the closest color.</span>
<span class="gi">+    # (Thanks to Pygments for this part.)</span>
<span class="gi">+    distance = 257 * 257 * 3  # &quot;infinity&quot; (&gt;distance from #000000 to #ffffff)</span>
<span class="gi">+    match = &quot;ansidefault&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for name, (r2, g2, b2) in ANSI_COLORS_TO_RGB.items():</span>
<span class="gi">+        if name != &quot;ansidefault&quot; and name not in exclude:</span>
<span class="gi">+            d = (r - r2) ** 2 + (g - g2) ** 2 + (b - b2) ** 2</span>
<span class="gi">+</span>
<span class="gi">+            if d &lt; distance:</span>
<span class="gi">+                match = name</span>
<span class="gi">+                distance = d</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>


<span class="w"> </span>_ColorCodeAndName = Tuple[int, str]
<span class="gu">@@ -65,17 +148,38 @@ class _16ColorCache:</span>
<span class="w"> </span>    :param bg: Cache for background colors, instead of foreground.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, bg: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, bg: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.bg = bg
<span class="w"> </span>        self._cache: dict[Hashable, _ColorCodeAndName] = {}

<span class="gd">-    def get_code(self, value: tuple[int, int, int], exclude: Sequence[str]=()</span>
<span class="gd">-        ) -&gt;_ColorCodeAndName:</span>
<span class="gi">+    def get_code(</span>
<span class="gi">+        self, value: tuple[int, int, int], exclude: Sequence[str] = ()</span>
<span class="gi">+    ) -&gt; _ColorCodeAndName:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (ansi_code, ansi_name) tuple. (E.g. ``(44, &#39;ansiblue&#39;)``.) for
<span class="w"> </span>        a given (r,g,b) value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key: Hashable = (value, tuple(exclude))</span>
<span class="gi">+        cache = self._cache</span>
<span class="gi">+</span>
<span class="gi">+        if key not in cache:</span>
<span class="gi">+            cache[key] = self._get(value, exclude)</span>
<span class="gi">+</span>
<span class="gi">+        return cache[key]</span>
<span class="gi">+</span>
<span class="gi">+    def _get(</span>
<span class="gi">+        self, value: tuple[int, int, int], exclude: Sequence[str] = ()</span>
<span class="gi">+    ) -&gt; _ColorCodeAndName:</span>
<span class="gi">+        r, g, b = value</span>
<span class="gi">+        match = _get_closest_ansi_color(r, g, b, exclude=exclude)</span>
<span class="gi">+</span>
<span class="gi">+        # Turn color name into code.</span>
<span class="gi">+        if self.bg:</span>
<span class="gi">+            code = BG_ANSI_COLORS[match]</span>
<span class="gi">+        else:</span>
<span class="gi">+            code = FG_ANSI_COLORS[match]</span>
<span class="gi">+</span>
<span class="gi">+        return code, match</span>


<span class="w"> </span>class _256ColorCache(Dict[Tuple[int, int, int], int]):
<span class="gu">@@ -83,45 +187,63 @@ class _256ColorCache(Dict[Tuple[int, int, int], int]):</span>
<span class="w"> </span>    Cache which maps (r, g, b) tuples to 256 colors.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # Build color table.</span>
<span class="w"> </span>        colors: list[tuple[int, int, int]] = []
<span class="gd">-        colors.append((0, 0, 0))</span>
<span class="gd">-        colors.append((205, 0, 0))</span>
<span class="gd">-        colors.append((0, 205, 0))</span>
<span class="gd">-        colors.append((205, 205, 0))</span>
<span class="gd">-        colors.append((0, 0, 238))</span>
<span class="gd">-        colors.append((205, 0, 205))</span>
<span class="gd">-        colors.append((0, 205, 205))</span>
<span class="gd">-        colors.append((229, 229, 229))</span>
<span class="gd">-        colors.append((127, 127, 127))</span>
<span class="gd">-        colors.append((255, 0, 0))</span>
<span class="gd">-        colors.append((0, 255, 0))</span>
<span class="gd">-        colors.append((255, 255, 0))</span>
<span class="gd">-        colors.append((92, 92, 255))</span>
<span class="gd">-        colors.append((255, 0, 255))</span>
<span class="gd">-        colors.append((0, 255, 255))</span>
<span class="gd">-        colors.append((255, 255, 255))</span>
<span class="gd">-        valuerange = 0, 95, 135, 175, 215, 255</span>
<span class="gi">+</span>
<span class="gi">+        # colors 0..15: 16 basic colors</span>
<span class="gi">+        colors.append((0x00, 0x00, 0x00))  # 0</span>
<span class="gi">+        colors.append((0xCD, 0x00, 0x00))  # 1</span>
<span class="gi">+        colors.append((0x00, 0xCD, 0x00))  # 2</span>
<span class="gi">+        colors.append((0xCD, 0xCD, 0x00))  # 3</span>
<span class="gi">+        colors.append((0x00, 0x00, 0xEE))  # 4</span>
<span class="gi">+        colors.append((0xCD, 0x00, 0xCD))  # 5</span>
<span class="gi">+        colors.append((0x00, 0xCD, 0xCD))  # 6</span>
<span class="gi">+        colors.append((0xE5, 0xE5, 0xE5))  # 7</span>
<span class="gi">+        colors.append((0x7F, 0x7F, 0x7F))  # 8</span>
<span class="gi">+        colors.append((0xFF, 0x00, 0x00))  # 9</span>
<span class="gi">+        colors.append((0x00, 0xFF, 0x00))  # 10</span>
<span class="gi">+        colors.append((0xFF, 0xFF, 0x00))  # 11</span>
<span class="gi">+        colors.append((0x5C, 0x5C, 0xFF))  # 12</span>
<span class="gi">+        colors.append((0xFF, 0x00, 0xFF))  # 13</span>
<span class="gi">+        colors.append((0x00, 0xFF, 0xFF))  # 14</span>
<span class="gi">+        colors.append((0xFF, 0xFF, 0xFF))  # 15</span>
<span class="gi">+</span>
<span class="gi">+        # colors 16..232: the 6x6x6 color cube</span>
<span class="gi">+        valuerange = (0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF)</span>
<span class="gi">+</span>
<span class="w"> </span>        for i in range(217):
<span class="gd">-            r = valuerange[i // 36 % 6]</span>
<span class="gd">-            g = valuerange[i // 6 % 6]</span>
<span class="gi">+            r = valuerange[(i // 36) % 6]</span>
<span class="gi">+            g = valuerange[(i // 6) % 6]</span>
<span class="w"> </span>            b = valuerange[i % 6]
<span class="w"> </span>            colors.append((r, g, b))
<span class="gi">+</span>
<span class="gi">+        # colors 233..253: grayscale</span>
<span class="w"> </span>        for i in range(1, 22):
<span class="w"> </span>            v = 8 + i * 10
<span class="w"> </span>            colors.append((v, v, v))
<span class="gi">+</span>
<span class="w"> </span>        self.colors = colors

<span class="gd">-    def __missing__(self, value: tuple[int, int, int]) -&gt;int:</span>
<span class="gi">+    def __missing__(self, value: tuple[int, int, int]) -&gt; int:</span>
<span class="w"> </span>        r, g, b = value
<span class="gd">-        distance = 257 * 257 * 3</span>
<span class="gi">+</span>
<span class="gi">+        # Find closest color.</span>
<span class="gi">+        # (Thanks to Pygments for this!)</span>
<span class="gi">+        distance = 257 * 257 * 3  # &quot;infinity&quot; (&gt;distance from #000000 to #ffffff)</span>
<span class="w"> </span>        match = 0
<span class="gi">+</span>
<span class="w"> </span>        for i, (r2, g2, b2) in enumerate(self.colors):
<span class="gd">-            if i &gt;= 16:</span>
<span class="gi">+            if i &gt;= 16:  # XXX: We ignore the 16 ANSI colors when mapping RGB</span>
<span class="gi">+                # to the 256 colors, because these highly depend on</span>
<span class="gi">+                # the color scheme of the terminal.</span>
<span class="w"> </span>                d = (r - r2) ** 2 + (g - g2) ** 2 + (b - b2) ** 2
<span class="gi">+</span>
<span class="w"> </span>                if d &lt; distance:
<span class="w"> </span>                    match = i
<span class="w"> </span>                    distance = d
<span class="gi">+</span>
<span class="gi">+        # Turn color name into code.</span>
<span class="w"> </span>        self[value] = match
<span class="w"> </span>        return match

<span class="gu">@@ -140,54 +262,127 @@ class _EscapeCodeCache(Dict[Attrs, str]):</span>
<span class="w"> </span>    :param true_color: When True, use 24bit colors instead of 256 colors.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, color_depth: ColorDepth) -&gt;None:</span>
<span class="gi">+    def __init__(self, color_depth: ColorDepth) -&gt; None:</span>
<span class="w"> </span>        self.color_depth = color_depth

<span class="gd">-    def __missing__(self, attrs: Attrs) -&gt;str:</span>
<span class="gd">-        (fgcolor, bgcolor, bold, underline, strike, italic, blink, reverse,</span>
<span class="gd">-            hidden) = attrs</span>
<span class="gi">+    def __missing__(self, attrs: Attrs) -&gt; str:</span>
<span class="gi">+        (</span>
<span class="gi">+            fgcolor,</span>
<span class="gi">+            bgcolor,</span>
<span class="gi">+            bold,</span>
<span class="gi">+            underline,</span>
<span class="gi">+            strike,</span>
<span class="gi">+            italic,</span>
<span class="gi">+            blink,</span>
<span class="gi">+            reverse,</span>
<span class="gi">+            hidden,</span>
<span class="gi">+        ) = attrs</span>
<span class="w"> </span>        parts: list[str] = []
<span class="gd">-        parts.extend(self._colors_to_code(fgcolor or &#39;&#39;, bgcolor or &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        parts.extend(self._colors_to_code(fgcolor or &quot;&quot;, bgcolor or &quot;&quot;))</span>
<span class="gi">+</span>
<span class="w"> </span>        if bold:
<span class="gd">-            parts.append(&#39;1&#39;)</span>
<span class="gi">+            parts.append(&quot;1&quot;)</span>
<span class="w"> </span>        if italic:
<span class="gd">-            parts.append(&#39;3&#39;)</span>
<span class="gi">+            parts.append(&quot;3&quot;)</span>
<span class="w"> </span>        if blink:
<span class="gd">-            parts.append(&#39;5&#39;)</span>
<span class="gi">+            parts.append(&quot;5&quot;)</span>
<span class="w"> </span>        if underline:
<span class="gd">-            parts.append(&#39;4&#39;)</span>
<span class="gi">+            parts.append(&quot;4&quot;)</span>
<span class="w"> </span>        if reverse:
<span class="gd">-            parts.append(&#39;7&#39;)</span>
<span class="gi">+            parts.append(&quot;7&quot;)</span>
<span class="w"> </span>        if hidden:
<span class="gd">-            parts.append(&#39;8&#39;)</span>
<span class="gi">+            parts.append(&quot;8&quot;)</span>
<span class="w"> </span>        if strike:
<span class="gd">-            parts.append(&#39;9&#39;)</span>
<span class="gi">+            parts.append(&quot;9&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if parts:
<span class="gd">-            result = &#39;\x1b[0;&#39; + &#39;;&#39;.join(parts) + &#39;m&#39;</span>
<span class="gi">+            result = &quot;\x1b[0;&quot; + &quot;;&quot;.join(parts) + &quot;m&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            result = &#39;\x1b[0m&#39;</span>
<span class="gi">+            result = &quot;\x1b[0m&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self[attrs] = result
<span class="w"> </span>        return result

<span class="gd">-    def _color_name_to_rgb(self, color: str) -&gt;tuple[int, int, int]:</span>
<span class="gd">-        &quot;&quot;&quot;Turn &#39;ffffff&#39;, into (0xff, 0xff, 0xff).&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _color_name_to_rgb(self, color: str) -&gt; tuple[int, int, int]:</span>
<span class="gi">+        &quot;Turn &#39;ffffff&#39;, into (0xff, 0xff, 0xff).&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            rgb = int(color, 16)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            r = (rgb &gt;&gt; 16) &amp; 0xFF</span>
<span class="gi">+            g = (rgb &gt;&gt; 8) &amp; 0xFF</span>
<span class="gi">+            b = rgb &amp; 0xFF</span>
<span class="gi">+            return r, g, b</span>

<span class="gd">-    def _colors_to_code(self, fg_color: str, bg_color: str) -&gt;Iterable[str]:</span>
<span class="gi">+    def _colors_to_code(self, fg_color: str, bg_color: str) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a tuple with the vt100 values  that represent this color.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_size(fileno: int) -&gt;tuple[int, int]:</span>
<span class="gi">+        # When requesting ANSI colors only, and both fg/bg color were converted</span>
<span class="gi">+        # to ANSI, ensure that the foreground and background color are not the</span>
<span class="gi">+        # same. (Unless they were explicitly defined to be the same color.)</span>
<span class="gi">+        fg_ansi = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def get(color: str, bg: bool) -&gt; list[int]:</span>
<span class="gi">+            nonlocal fg_ansi</span>
<span class="gi">+</span>
<span class="gi">+            table = BG_ANSI_COLORS if bg else FG_ANSI_COLORS</span>
<span class="gi">+</span>
<span class="gi">+            if not color or self.color_depth == ColorDepth.DEPTH_1_BIT:</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+            # 16 ANSI colors. (Given by name.)</span>
<span class="gi">+            elif color in table:</span>
<span class="gi">+                return [table[color]]</span>
<span class="gi">+</span>
<span class="gi">+            # RGB colors. (Defined as &#39;ffffff&#39;.)</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    rgb = self._color_name_to_rgb(color)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    return []</span>
<span class="gi">+</span>
<span class="gi">+                # When only 16 colors are supported, use that.</span>
<span class="gi">+                if self.color_depth == ColorDepth.DEPTH_4_BIT:</span>
<span class="gi">+                    if bg:  # Background.</span>
<span class="gi">+                        if fg_color != bg_color:</span>
<span class="gi">+                            exclude = [fg_ansi]</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            exclude = []</span>
<span class="gi">+                        code, name = _16_bg_colors.get_code(rgb, exclude=exclude)</span>
<span class="gi">+                        return [code]</span>
<span class="gi">+                    else:  # Foreground.</span>
<span class="gi">+                        code, name = _16_fg_colors.get_code(rgb)</span>
<span class="gi">+                        fg_ansi = name</span>
<span class="gi">+                        return [code]</span>
<span class="gi">+</span>
<span class="gi">+                # True colors. (Only when this feature is enabled.)</span>
<span class="gi">+                elif self.color_depth == ColorDepth.DEPTH_24_BIT:</span>
<span class="gi">+                    r, g, b = rgb</span>
<span class="gi">+                    return [(48 if bg else 38), 2, r, g, b]</span>
<span class="gi">+</span>
<span class="gi">+                # 256 RGB colors.</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return [(48 if bg else 38), 5, _256_colors[rgb]]</span>
<span class="gi">+</span>
<span class="gi">+        result: list[int] = []</span>
<span class="gi">+        result.extend(get(fg_color, False))</span>
<span class="gi">+        result.extend(get(bg_color, True))</span>
<span class="gi">+</span>
<span class="gi">+        return map(str, result)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_size(fileno: int) -&gt; tuple[int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the size of this pseudo terminal.

<span class="w"> </span>    :param fileno: stdout.fileno()
<span class="w"> </span>    :returns: A (rows, cols) tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    size = os.get_terminal_size(fileno)</span>
<span class="gi">+    return size.lines, size.columns</span>


<span class="w"> </span>class Vt100_Output(Output):
<span class="gu">@@ -203,12 +398,22 @@ class Vt100_Output(Output):</span>
<span class="w"> </span>        does respond to CPR escapes. When `False`, never attempt to send CPR
<span class="w"> </span>        requests.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # For the error messages. Only display &quot;Output is not a terminal&quot; once per</span>
<span class="gi">+    # file descriptor.</span>
<span class="w"> </span>    _fds_not_a_terminal: set[int] = set()

<span class="gd">-    def __init__(self, stdout: TextIO, get_size: Callable[[], Size], term:</span>
<span class="gd">-        (str | None)=None, default_color_depth: (ColorDepth | None)=None,</span>
<span class="gd">-        enable_bell: bool=True, enable_cpr: bool=True) -&gt;None:</span>
<span class="gd">-        assert all(hasattr(stdout, a) for a in (&#39;write&#39;, &#39;flush&#39;))</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stdout: TextIO,</span>
<span class="gi">+        get_size: Callable[[], Size],</span>
<span class="gi">+        term: str | None = None,</span>
<span class="gi">+        default_color_depth: ColorDepth | None = None,</span>
<span class="gi">+        enable_bell: bool = True,</span>
<span class="gi">+        enable_cpr: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert all(hasattr(stdout, a) for a in (&quot;write&quot;, &quot;flush&quot;))</span>
<span class="gi">+</span>
<span class="w"> </span>        self._buffer: list[str] = []
<span class="w"> </span>        self.stdout: TextIO = stdout
<span class="w"> </span>        self.default_color_depth = default_color_depth
<span class="gu">@@ -216,114 +421,308 @@ class Vt100_Output(Output):</span>
<span class="w"> </span>        self.term = term
<span class="w"> </span>        self.enable_bell = enable_bell
<span class="w"> </span>        self.enable_cpr = enable_cpr
<span class="gi">+</span>
<span class="gi">+        # Cache for escape codes.</span>
<span class="w"> </span>        self._escape_code_caches: dict[ColorDepth, _EscapeCodeCache] = {
<span class="gd">-            ColorDepth.DEPTH_1_BIT: _EscapeCodeCache(ColorDepth.DEPTH_1_BIT</span>
<span class="gd">-            ), ColorDepth.DEPTH_4_BIT: _EscapeCodeCache(ColorDepth.</span>
<span class="gd">-            DEPTH_4_BIT), ColorDepth.DEPTH_8_BIT: _EscapeCodeCache(</span>
<span class="gd">-            ColorDepth.DEPTH_8_BIT), ColorDepth.DEPTH_24_BIT:</span>
<span class="gd">-            _EscapeCodeCache(ColorDepth.DEPTH_24_BIT)}</span>
<span class="gi">+            ColorDepth.DEPTH_1_BIT: _EscapeCodeCache(ColorDepth.DEPTH_1_BIT),</span>
<span class="gi">+            ColorDepth.DEPTH_4_BIT: _EscapeCodeCache(ColorDepth.DEPTH_4_BIT),</span>
<span class="gi">+            ColorDepth.DEPTH_8_BIT: _EscapeCodeCache(ColorDepth.DEPTH_8_BIT),</span>
<span class="gi">+            ColorDepth.DEPTH_24_BIT: _EscapeCodeCache(ColorDepth.DEPTH_24_BIT),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # Keep track of whether the cursor shape was ever changed.</span>
<span class="gi">+        # (We don&#39;t restore the cursor shape if it was never changed - by</span>
<span class="gi">+        # default, we don&#39;t change them.)</span>
<span class="w"> </span>        self._cursor_shape_changed = False

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_pty(cls, stdout: TextIO, term: (str | None)=None,</span>
<span class="gd">-        default_color_depth: (ColorDepth | None)=None, enable_bell: bool=True</span>
<span class="gd">-        ) -&gt;Vt100_Output:</span>
<span class="gi">+    def from_pty(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        stdout: TextIO,</span>
<span class="gi">+        term: str | None = None,</span>
<span class="gi">+        default_color_depth: ColorDepth | None = None,</span>
<span class="gi">+        enable_bell: bool = True,</span>
<span class="gi">+    ) -&gt; Vt100_Output:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create an Output class from a pseudo terminal.
<span class="w"> </span>        (This will take the dimensions by reading the pseudo
<span class="w"> </span>        terminal attributes.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;Return file descriptor.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def encoding(self) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Return encoding used for stdout.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_raw(self, data: str) -&gt;None:</span>
<span class="gi">+        fd: int | None</span>
<span class="gi">+        # Normally, this requires a real TTY device, but people instantiate</span>
<span class="gi">+        # this class often during unit tests as well. For convenience, we print</span>
<span class="gi">+        # an error message, use standard dimensions, and go on.</span>
<span class="gi">+        try:</span>
<span class="gi">+            fd = stdout.fileno()</span>
<span class="gi">+        except io.UnsupportedOperation:</span>
<span class="gi">+            fd = None</span>
<span class="gi">+</span>
<span class="gi">+        if not stdout.isatty() and (fd is None or fd not in cls._fds_not_a_terminal):</span>
<span class="gi">+            msg = &quot;Warning: Output is not a terminal (fd=%r).\n&quot;</span>
<span class="gi">+            sys.stderr.write(msg % fd)</span>
<span class="gi">+            sys.stderr.flush()</span>
<span class="gi">+            if fd is not None:</span>
<span class="gi">+                cls._fds_not_a_terminal.add(fd)</span>
<span class="gi">+</span>
<span class="gi">+        def get_size() -&gt; Size:</span>
<span class="gi">+            # If terminal (incorrectly) reports its size as 0, pick a</span>
<span class="gi">+            # reasonable default.  See</span>
<span class="gi">+            # https://github.com/ipython/ipython/issues/10071</span>
<span class="gi">+            rows, columns = (None, None)</span>
<span class="gi">+</span>
<span class="gi">+            # It is possible that `stdout` is no longer a TTY device at this</span>
<span class="gi">+            # point. In that case we get an `OSError` in the ioctl call in</span>
<span class="gi">+            # `get_size`. See:</span>
<span class="gi">+            # https://github.com/prompt-toolkit/python-prompt-toolkit/pull/1021</span>
<span class="gi">+            try:</span>
<span class="gi">+                rows, columns = _get_size(stdout.fileno())</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            return Size(rows=rows or 24, columns=columns or 80)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            stdout,</span>
<span class="gi">+            get_size,</span>
<span class="gi">+            term=term,</span>
<span class="gi">+            default_color_depth=default_color_depth,</span>
<span class="gi">+            enable_bell=enable_bell,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_size(self) -&gt; Size:</span>
<span class="gi">+        return self._get_size()</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        &quot;Return file descriptor.&quot;</span>
<span class="gi">+        return self.stdout.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="gi">+        &quot;Return encoding used for stdout.&quot;</span>
<span class="gi">+        return self.stdout.encoding</span>
<span class="gi">+</span>
<span class="gi">+    def write_raw(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write raw data to output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._buffer.append(data)</span>

<span class="gd">-    def write(self, data: str) -&gt;None:</span>
<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write text to output.
<span class="w"> </span>        (Removes vt100 escape codes. -- used for safely writing text.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._buffer.append(data.replace(&quot;\x1b&quot;, &quot;?&quot;))</span>

<span class="gd">-    def set_title(self, title: str) -&gt;None:</span>
<span class="gi">+    def set_title(self, title: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set terminal title.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def erase_screen(self) -&gt;None:</span>
<span class="gi">+        if self.term not in (</span>
<span class="gi">+            &quot;linux&quot;,</span>
<span class="gi">+            &quot;eterm-color&quot;,</span>
<span class="gi">+        ):  # Not supported by the Linux console.</span>
<span class="gi">+            self.write_raw(</span>
<span class="gi">+                &quot;\x1b]2;%s\x07&quot; % title.replace(&quot;\x1b&quot;, &quot;&quot;).replace(&quot;\x07&quot;, &quot;&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def clear_title(self) -&gt; None:</span>
<span class="gi">+        self.set_title(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_screen(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erases the screen with the background color and moves the cursor to
<span class="w"> </span>        home.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_raw(&quot;\x1b[2J&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def enter_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1049h\x1b[H&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def quit_alternate_screen(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1049l&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def enable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1000h&quot;)</span>

<span class="gd">-    def erase_end_of_line(self) -&gt;None:</span>
<span class="gi">+        # Enable mouse-drag support.</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1003h&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Enable urxvt Mouse mode. (For terminals that understand this.)</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1015h&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Also enable Xterm SGR mouse mode. (For terminals that understand this.)</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1006h&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Note: E.g. lxterminal understands 1000h, but not the urxvt or sgr</span>
<span class="gi">+        #       extensions.</span>
<span class="gi">+</span>
<span class="gi">+    def disable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1000l&quot;)</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1015l&quot;)</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1006l&quot;)</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1003l&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_end_of_line(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erases from the current cursor position to the end of the current line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_raw(&quot;\x1b[K&quot;)</span>

<span class="gd">-    def erase_down(self) -&gt;None:</span>
<span class="gi">+    def erase_down(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erases the screen from the current line down to the bottom of the
<span class="w"> </span>        screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_raw(&quot;\x1b[J&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def reset_attributes(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[0m&quot;)</span>

<span class="gd">-    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt;None:</span>
<span class="gi">+    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create new style and output.

<span class="w"> </span>        :param attrs: `Attrs` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get current depth.</span>
<span class="gi">+        escape_code_cache = self._escape_code_caches[color_depth]</span>
<span class="gi">+</span>
<span class="gi">+        # Write escape character.</span>
<span class="gi">+        self.write_raw(escape_code_cache[attrs])</span>
<span class="gi">+</span>
<span class="gi">+    def disable_autowrap(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?7l&quot;)</span>

<span class="gd">-    def reset_cursor_key_mode(self) -&gt;None:</span>
<span class="gi">+    def enable_autowrap(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?7h&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def enable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?2004h&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def disable_bracketed_paste(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?2004l&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def reset_cursor_key_mode(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For vt100 only.
<span class="w"> </span>        Put the terminal in cursor mode (instead of application mode).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Put the terminal in cursor mode. (Instead of application mode.)</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?1l&quot;)</span>

<span class="gd">-    def cursor_goto(self, row: int=0, column: int=0) -&gt;None:</span>
<span class="gi">+    def cursor_goto(self, row: int = 0, column: int = 0) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Move cursor position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_raw(&quot;\x1b[%i;%iH&quot; % (row, column))</span>

<span class="gd">-    def reset_cursor_shape(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Reset cursor shape.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_up(self, amount: int) -&gt; None:</span>
<span class="gi">+        if amount == 0:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif amount == 1:</span>
<span class="gi">+            self.write_raw(&quot;\x1b[A&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write_raw(&quot;\x1b[%iA&quot; % amount)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_down(self, amount: int) -&gt; None:</span>
<span class="gi">+        if amount == 0:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif amount == 1:</span>
<span class="gi">+            # Note: Not the same as &#39;\n&#39;, &#39;\n&#39; can cause the window content to</span>
<span class="gi">+            #       scroll.</span>
<span class="gi">+            self.write_raw(&quot;\x1b[B&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write_raw(&quot;\x1b[%iB&quot; % amount)</span>

<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gi">+    def cursor_forward(self, amount: int) -&gt; None:</span>
<span class="gi">+        if amount == 0:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif amount == 1:</span>
<span class="gi">+            self.write_raw(&quot;\x1b[C&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write_raw(&quot;\x1b[%iC&quot; % amount)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_backward(self, amount: int) -&gt; None:</span>
<span class="gi">+        if amount == 0:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif amount == 1:</span>
<span class="gi">+            self.write_raw(&quot;\b&quot;)  # &#39;\x1b[D&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write_raw(&quot;\x1b[%iD&quot; % amount)</span>
<span class="gi">+</span>
<span class="gi">+    def hide_cursor(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?25l&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def show_cursor(self) -&gt; None:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[?12l\x1b[?25h&quot;)  # Stop blinking cursor and show.</span>
<span class="gi">+</span>
<span class="gi">+    def set_cursor_shape(self, cursor_shape: CursorShape) -&gt; None:</span>
<span class="gi">+        if cursor_shape == CursorShape._NEVER_CHANGE:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._cursor_shape_changed = True</span>
<span class="gi">+        self.write_raw(</span>
<span class="gi">+            {</span>
<span class="gi">+                CursorShape.BLOCK: &quot;\x1b[2 q&quot;,</span>
<span class="gi">+                CursorShape.BEAM: &quot;\x1b[6 q&quot;,</span>
<span class="gi">+                CursorShape.UNDERLINE: &quot;\x1b[4 q&quot;,</span>
<span class="gi">+                CursorShape.BLINKING_BLOCK: &quot;\x1b[1 q&quot;,</span>
<span class="gi">+                CursorShape.BLINKING_BEAM: &quot;\x1b[5 q&quot;,</span>
<span class="gi">+                CursorShape.BLINKING_UNDERLINE: &quot;\x1b[3 q&quot;,</span>
<span class="gi">+            }.get(cursor_shape, &quot;&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def reset_cursor_shape(self) -&gt; None:</span>
<span class="gi">+        &quot;Reset cursor shape.&quot;</span>
<span class="gi">+        # (Only reset cursor shape, if we ever changed it.)</span>
<span class="gi">+        if self._cursor_shape_changed:</span>
<span class="gi">+            self._cursor_shape_changed = False</span>
<span class="gi">+</span>
<span class="gi">+            # Reset cursor shape.</span>
<span class="gi">+            self.write_raw(&quot;\x1b[0 q&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write to output stream and flush.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._buffer:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        data = &quot;&quot;.join(self._buffer)</span>
<span class="gi">+        self._buffer = []</span>

<span class="gd">-    def ask_for_cpr(self) -&gt;None:</span>
<span class="gi">+        flush_stdout(self.stdout, data)</span>
<span class="gi">+</span>
<span class="gi">+    def ask_for_cpr(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asks for a cursor position report (CPR).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def bell(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Sound bell.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_default_color_depth(self) -&gt;ColorDepth:</span>
<span class="gi">+        self.write_raw(&quot;\x1b[6n&quot;)</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def responds_to_cpr(self) -&gt; bool:</span>
<span class="gi">+        if not self.enable_cpr:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # When the input is a tty, we assume that CPR is supported.</span>
<span class="gi">+        # It&#39;s not when the input is piped from Pexpect.</span>
<span class="gi">+        if os.environ.get(&quot;PROMPT_TOOLKIT_NO_CPR&quot;, &quot;&quot;) == &quot;1&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if is_dumb_terminal(self.term):</span>
<span class="gi">+            return False</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.stdout.isatty()</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False  # ValueError: I/O operation on closed file</span>
<span class="gi">+</span>
<span class="gi">+    def bell(self) -&gt; None:</span>
<span class="gi">+        &quot;Sound bell.&quot;</span>
<span class="gi">+        if self.enable_bell:</span>
<span class="gi">+            self.write_raw(&quot;\a&quot;)</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def get_default_color_depth(self) -&gt; ColorDepth:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the default color depth for a vt100 terminal, according to the
<span class="w"> </span>        our term value.
<span class="gu">@@ -331,4 +730,18 @@ class Vt100_Output(Output):</span>
<span class="w"> </span>        We prefer 256 colors almost always, because this is what most terminals
<span class="w"> </span>        support these days, and is a good default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_color_depth is not None:</span>
<span class="gi">+            return self.default_color_depth</span>
<span class="gi">+</span>
<span class="gi">+        term = self.term</span>
<span class="gi">+</span>
<span class="gi">+        if term is None:</span>
<span class="gi">+            return ColorDepth.DEFAULT</span>
<span class="gi">+</span>
<span class="gi">+        if is_dumb_terminal(term):</span>
<span class="gi">+            return ColorDepth.DEPTH_1_BIT</span>
<span class="gi">+</span>
<span class="gi">+        if term in (&quot;linux&quot;, &quot;eterm-color&quot;):</span>
<span class="gi">+            return ColorDepth.DEPTH_4_BIT</span>
<span class="gi">+</span>
<span class="gi">+        return ColorDepth.DEFAULT</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/win32.py b/src/prompt_toolkit/output/win32.py</span>
<span class="gh">index 15c3a7b8..edeca096 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/win32.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/win32.py</span>
<span class="gu">@@ -1,24 +1,42 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from ctypes import ArgumentError, byref, c_char, c_long, c_uint, c_ulong, pointer
<span class="w"> </span>from ctypes.wintypes import DWORD, HANDLE
<span class="w"> </span>from typing import Callable, TextIO, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cursor_shapes import CursorShape
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.styles import ANSI_COLOR_NAMES, Attrs
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gd">-from prompt_toolkit.win32_types import CONSOLE_SCREEN_BUFFER_INFO, COORD, SMALL_RECT, STD_INPUT_HANDLE, STD_OUTPUT_HANDLE</span>
<span class="gi">+from prompt_toolkit.win32_types import (</span>
<span class="gi">+    CONSOLE_SCREEN_BUFFER_INFO,</span>
<span class="gi">+    COORD,</span>
<span class="gi">+    SMALL_RECT,</span>
<span class="gi">+    STD_INPUT_HANDLE,</span>
<span class="gi">+    STD_OUTPUT_HANDLE,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from ..utils import SPHINX_AUTODOC_RUNNING
<span class="w"> </span>from .base import Output
<span class="w"> </span>from .color_depth import ColorDepth
<span class="gi">+</span>
<span class="gi">+# Do not import win32-specific stuff when generating documentation.</span>
<span class="gi">+# Otherwise RTD would be unable to generate docs for this module.</span>
<span class="w"> </span>if not SPHINX_AUTODOC_RUNNING:
<span class="w"> </span>    from ctypes import windll
<span class="gd">-__all__ = [&#39;Win32Output&#39;]</span>


<span class="gd">-def _coord_byval(coord: COORD) -&gt;c_long:</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Win32Output&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _coord_byval(coord: COORD) -&gt; c_long:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turns a COORD object into a c_long.
<span class="w"> </span>    This will cause it to be passed by value instead of by reference. (That is what I think at least.)
<span class="gu">@@ -33,11 +51,14 @@ def _coord_byval(coord: COORD) -&gt;c_long:</span>

<span class="w"> </span>    More info: http://msdn.microsoft.com/en-us/library/windows/desktop/ms686025(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return c_long(coord.Y * 0x10000 | coord.X &amp; 0xFFFF)</span>


<span class="gi">+#: If True: write the output of the renderer also to the following file. This</span>
<span class="gi">+#: is very useful for debugging. (e.g.: to see that we don&#39;t write more bytes</span>
<span class="gi">+#: than required.)</span>
<span class="w"> </span>_DEBUG_RENDER_OUTPUT = False
<span class="gd">-_DEBUG_RENDER_OUTPUT_FILENAME = &#39;prompt-toolkit-windows-output.log&#39;</span>
<span class="gi">+_DEBUG_RENDER_OUTPUT_FILENAME = r&quot;prompt-toolkit-windows-output.log&quot;</span>


<span class="w"> </span>class NoConsoleScreenBufferError(Exception):
<span class="gu">@@ -46,18 +67,24 @@ class NoConsoleScreenBufferError(Exception):</span>
<span class="w"> </span>    the user tries to instantiate Win32Output.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        xterm = &#39;xterm&#39; in os.environ.get(&#39;TERM&#39;, &#39;&#39;)</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        # Are we running in &#39;xterm&#39; on Windows, like git-bash for instance?</span>
<span class="gi">+        xterm = &quot;xterm&quot; in os.environ.get(&quot;TERM&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if xterm:
<span class="w"> </span>            message = (
<span class="gd">-                &#39;Found %s, while expecting a Windows console. Maybe try to run this program using &quot;winpty&quot; or run it in cmd.exe instead. Or otherwise, in case of Cygwin, use the Python executable that is compiled for Cygwin.&#39;</span>
<span class="gd">-                 % os.environ[&#39;TERM&#39;])</span>
<span class="gi">+                &quot;Found %s, while expecting a Windows console. &quot;</span>
<span class="gi">+                &#39;Maybe try to run this program using &quot;winpty&quot; &#39;</span>
<span class="gi">+                &quot;or run it in cmd.exe instead. Or otherwise, &quot;</span>
<span class="gi">+                &quot;in case of Cygwin, use the Python executable &quot;</span>
<span class="gi">+                &quot;that is compiled for Cygwin.&quot; % os.environ[&quot;TERM&quot;]</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            message = &#39;No Windows console found. Are you running cmd.exe?&#39;</span>
<span class="gi">+            message = &quot;No Windows console found. Are you running cmd.exe?&quot;</span>
<span class="w"> </span>        super().__init__(message)


<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class Win32Output(Output):
<span class="gu">@@ -66,86 +93,414 @@ class Win32Output(Output):</span>
<span class="w"> </span>    (cmd.exe and similar.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stdout: TextIO, use_complete_width: bool=False,</span>
<span class="gd">-        default_color_depth: (ColorDepth | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stdout: TextIO,</span>
<span class="gi">+        use_complete_width: bool = False,</span>
<span class="gi">+        default_color_depth: ColorDepth | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.use_complete_width = use_complete_width
<span class="w"> </span>        self.default_color_depth = default_color_depth
<span class="gi">+</span>
<span class="w"> </span>        self._buffer: list[str] = []
<span class="w"> </span>        self.stdout: TextIO = stdout
<span class="w"> </span>        self.hconsole = HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE))
<span class="gi">+</span>
<span class="w"> </span>        self._in_alternate_screen = False
<span class="w"> </span>        self._hidden = False
<span class="gi">+</span>
<span class="w"> </span>        self.color_lookup_table = ColorLookupTable()
<span class="gi">+</span>
<span class="gi">+        # Remember the default console colors.</span>
<span class="w"> </span>        info = self.get_win32_screen_buffer_info()
<span class="w"> </span>        self.default_attrs = info.wAttributes if info else 15
<span class="gi">+</span>
<span class="w"> </span>        if _DEBUG_RENDER_OUTPUT:
<span class="gd">-            self.LOG = open(_DEBUG_RENDER_OUTPUT_FILENAME, &#39;ab&#39;)</span>
<span class="gi">+            self.LOG = open(_DEBUG_RENDER_OUTPUT_FILENAME, &quot;ab&quot;)</span>

<span class="gd">-    def fileno(self) -&gt;int:</span>
<span class="gd">-        &quot;&quot;&quot;Return file descriptor.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        &quot;Return file descriptor.&quot;</span>
<span class="gi">+        return self.stdout.fileno()</span>

<span class="gd">-    def encoding(self) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Return encoding used for stdout.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="gi">+        &quot;Return encoding used for stdout.&quot;</span>
<span class="gi">+        return self.stdout.encoding</span>

<span class="gd">-    def write_raw(self, data: str) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;For win32, there is no difference between write and write_raw.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        if self._hidden:</span>
<span class="gi">+            data = &quot; &quot; * get_cwidth(data)</span>
<span class="gi">+</span>
<span class="gi">+        self._buffer.append(data)</span>
<span class="gi">+</span>
<span class="gi">+    def write_raw(self, data: str) -&gt; None:</span>
<span class="gi">+        &quot;For win32, there is no difference between write and write_raw.&quot;</span>
<span class="gi">+        self.write(data)</span>
<span class="gi">+</span>
<span class="gi">+    def get_size(self) -&gt; Size:</span>
<span class="gi">+        info = self.get_win32_screen_buffer_info()</span>

<span class="gd">-    def _winapi(self, func: Callable[..., _T], *a: object, **kw: object) -&gt;_T:</span>
<span class="gi">+        # We take the width of the *visible* region as the size. Not the width</span>
<span class="gi">+        # of the complete screen buffer. (Unless use_complete_width has been</span>
<span class="gi">+        # set.)</span>
<span class="gi">+        if self.use_complete_width:</span>
<span class="gi">+            width = info.dwSize.X</span>
<span class="gi">+        else:</span>
<span class="gi">+            width = info.srWindow.Right - info.srWindow.Left</span>
<span class="gi">+</span>
<span class="gi">+        height = info.srWindow.Bottom - info.srWindow.Top + 1</span>
<span class="gi">+</span>
<span class="gi">+        # We avoid the right margin, windows will wrap otherwise.</span>
<span class="gi">+        maxwidth = info.dwSize.X - 1</span>
<span class="gi">+        width = min(maxwidth, width)</span>
<span class="gi">+</span>
<span class="gi">+        # Create `Size` object.</span>
<span class="gi">+        return Size(rows=height, columns=width)</span>
<span class="gi">+</span>
<span class="gi">+    def _winapi(self, func: Callable[..., _T], *a: object, **kw: object) -&gt; _T:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush and call win API function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>

<span class="gd">-    def get_win32_screen_buffer_info(self) -&gt;CONSOLE_SCREEN_BUFFER_INFO:</span>
<span class="gi">+        if _DEBUG_RENDER_OUTPUT:</span>
<span class="gi">+            self.LOG.write((&quot;%r&quot; % func.__name__).encode(&quot;utf-8&quot;) + b&quot;\n&quot;)</span>
<span class="gi">+            self.LOG.write(</span>
<span class="gi">+                b&quot;     &quot; + &quot;, &quot;.join([&quot;%r&quot; % i for i in a]).encode(&quot;utf-8&quot;) + b&quot;\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.LOG.write(</span>
<span class="gi">+                b&quot;     &quot;</span>
<span class="gi">+                + &quot;, &quot;.join([&quot;%r&quot; % type(i) for i in a]).encode(&quot;utf-8&quot;)</span>
<span class="gi">+                + b&quot;\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.LOG.flush()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*a, **kw)</span>
<span class="gi">+        except ArgumentError as e:</span>
<span class="gi">+            if _DEBUG_RENDER_OUTPUT:</span>
<span class="gi">+                self.LOG.write((f&quot;    Error in {func.__name__!r} {e!r} {e}\n&quot;).encode())</span>
<span class="gi">+</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def get_win32_screen_buffer_info(self) -&gt; CONSOLE_SCREEN_BUFFER_INFO:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return Screen buffer info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # NOTE: We don&#39;t call the `GetConsoleScreenBufferInfo` API through</span>
<span class="gi">+        #     `self._winapi`. Doing so causes Python to crash on certain 64bit</span>
<span class="gi">+        #     Python versions. (Reproduced with 64bit Python 2.7.6, on Windows</span>
<span class="gi">+        #     10). It is not clear why. Possibly, it has to do with passing</span>
<span class="gi">+        #     these objects as an argument, or through *args.</span>
<span class="gi">+</span>
<span class="gi">+        # The Python documentation contains the following - possibly related - warning:</span>
<span class="gi">+        #     ctypes does not support passing unions or structures with</span>
<span class="gi">+        #     bit-fields to functions by value. While this may work on 32-bit</span>
<span class="gi">+        #     x86, it&#39;s not guaranteed by the library to work in the general</span>
<span class="gi">+        #     case. Unions and structures with bit-fields should always be</span>
<span class="gi">+        #     passed to functions by pointer.</span>
<span class="gi">+</span>
<span class="gi">+        # Also see:</span>
<span class="gi">+        #    - https://github.com/ipython/ipython/issues/10070</span>
<span class="gi">+        #    - https://github.com/jonathanslenders/python-prompt-toolkit/issues/406</span>
<span class="gi">+        #    - https://github.com/jonathanslenders/python-prompt-toolkit/issues/86</span>
<span class="gi">+</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        sbinfo = CONSOLE_SCREEN_BUFFER_INFO()</span>
<span class="gi">+        success = windll.kernel32.GetConsoleScreenBufferInfo(</span>
<span class="gi">+            self.hconsole, byref(sbinfo)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # success = self._winapi(windll.kernel32.GetConsoleScreenBufferInfo,</span>
<span class="gi">+        #                        self.hconsole, byref(sbinfo))</span>
<span class="gi">+</span>
<span class="gi">+        if success:</span>
<span class="gi">+            return sbinfo</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NoConsoleScreenBufferError</span>

<span class="gd">-    def set_title(self, title: str) -&gt;None:</span>
<span class="gi">+    def set_title(self, title: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set terminal title.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._winapi(windll.kernel32.SetConsoleTitleW, title)</span>
<span class="gi">+</span>
<span class="gi">+    def clear_title(self) -&gt; None:</span>
<span class="gi">+        self._winapi(windll.kernel32.SetConsoleTitleW, &quot;&quot;)</span>

<span class="gd">-    def erase_end_of_line(self) -&gt;None:</span>
<span class="gi">+    def erase_screen(self) -&gt; None:</span>
<span class="gi">+        start = COORD(0, 0)</span>
<span class="gi">+        sbinfo = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        length = sbinfo.dwSize.X * sbinfo.dwSize.Y</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_goto(row=0, column=0)</span>
<span class="gi">+        self._erase(start, length)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_down(self) -&gt; None:</span>
<span class="gi">+        sbinfo = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        size = sbinfo.dwSize</span>
<span class="gi">+</span>
<span class="gi">+        start = sbinfo.dwCursorPosition</span>
<span class="gi">+        length = (size.X - size.X) + size.X * (size.Y - sbinfo.dwCursorPosition.Y)</span>
<span class="gi">+</span>
<span class="gi">+        self._erase(start, length)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_end_of_line(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;&quot;&quot;&quot;
<span class="gi">+        sbinfo = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        start = sbinfo.dwCursorPosition</span>
<span class="gi">+        length = sbinfo.dwSize.X - sbinfo.dwCursorPosition.X</span>
<span class="gi">+</span>
<span class="gi">+        self._erase(start, length)</span>
<span class="gi">+</span>
<span class="gi">+    def _erase(self, start: COORD, length: int) -&gt; None:</span>
<span class="gi">+        chars_written = c_ulong()</span>
<span class="gi">+</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.FillConsoleOutputCharacterA,</span>
<span class="gi">+            self.hconsole,</span>
<span class="gi">+            c_char(b&quot; &quot;),</span>
<span class="gi">+            DWORD(length),</span>
<span class="gi">+            _coord_byval(start),</span>
<span class="gi">+            byref(chars_written),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Reset attributes.</span>
<span class="gi">+        sbinfo = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.FillConsoleOutputAttribute,</span>
<span class="gi">+            self.hconsole,</span>
<span class="gi">+            sbinfo.wAttributes,</span>
<span class="gi">+            length,</span>
<span class="gi">+            _coord_byval(start),</span>
<span class="gi">+            byref(chars_written),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def reset_attributes(self) -&gt; None:</span>
<span class="gi">+        &quot;Reset the console foreground/background color.&quot;</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleTextAttribute, self.hconsole, self.default_attrs</span>
<span class="gi">+        )</span>
<span class="gi">+        self._hidden = False</span>
<span class="gi">+</span>
<span class="gi">+    def set_attributes(self, attrs: Attrs, color_depth: ColorDepth) -&gt; None:</span>
<span class="gi">+        (</span>
<span class="gi">+            fgcolor,</span>
<span class="gi">+            bgcolor,</span>
<span class="gi">+            bold,</span>
<span class="gi">+            underline,</span>
<span class="gi">+            strike,</span>
<span class="gi">+            italic,</span>
<span class="gi">+            blink,</span>
<span class="gi">+            reverse,</span>
<span class="gi">+            hidden,</span>
<span class="gi">+        ) = attrs</span>
<span class="gi">+        self._hidden = bool(hidden)</span>
<span class="gi">+</span>
<span class="gi">+        # Start from the default attributes.</span>
<span class="gi">+        win_attrs: int = self.default_attrs</span>
<span class="gi">+</span>
<span class="gi">+        if color_depth != ColorDepth.DEPTH_1_BIT:</span>
<span class="gi">+            # Override the last four bits: foreground color.</span>
<span class="gi">+            if fgcolor:</span>
<span class="gi">+                win_attrs = win_attrs &amp; ~0xF</span>
<span class="gi">+                win_attrs |= self.color_lookup_table.lookup_fg_color(fgcolor)</span>
<span class="gi">+</span>
<span class="gi">+            # Override the next four bits: background color.</span>
<span class="gi">+            if bgcolor:</span>
<span class="gi">+                win_attrs = win_attrs &amp; ~0xF0</span>
<span class="gi">+                win_attrs |= self.color_lookup_table.lookup_bg_color(bgcolor)</span>
<span class="gi">+</span>
<span class="gi">+        # Reverse: swap these four bits groups.</span>
<span class="gi">+        if reverse:</span>
<span class="gi">+            win_attrs = (</span>
<span class="gi">+                (win_attrs &amp; ~0xFF)</span>
<span class="gi">+                | ((win_attrs &amp; 0xF) &lt;&lt; 4)</span>
<span class="gi">+                | ((win_attrs &amp; 0xF0) &gt;&gt; 4)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self._winapi(windll.kernel32.SetConsoleTextAttribute, self.hconsole, win_attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def disable_autowrap(self) -&gt; None:</span>
<span class="gi">+        # Not supported by Windows.</span>
<span class="w"> </span>        pass

<span class="gd">-    def reset_attributes(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Reset the console foreground/background color.&quot;&quot;&quot;</span>
<span class="gi">+    def enable_autowrap(self) -&gt; None:</span>
<span class="gi">+        # Not supported by Windows.</span>
<span class="w"> </span>        pass

<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gi">+    def cursor_goto(self, row: int = 0, column: int = 0) -&gt; None:</span>
<span class="gi">+        pos = COORD(X=column, Y=row)</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleCursorPosition, self.hconsole, _coord_byval(pos)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_up(self, amount: int) -&gt; None:</span>
<span class="gi">+        sr = self.get_win32_screen_buffer_info().dwCursorPosition</span>
<span class="gi">+        pos = COORD(X=sr.X, Y=sr.Y - amount)</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleCursorPosition, self.hconsole, _coord_byval(pos)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_down(self, amount: int) -&gt; None:</span>
<span class="gi">+        self.cursor_up(-amount)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_forward(self, amount: int) -&gt; None:</span>
<span class="gi">+        sr = self.get_win32_screen_buffer_info().dwCursorPosition</span>
<span class="gi">+        #        assert sr.X + amount &gt;= 0, &#39;Negative cursor position: x=%r amount=%r&#39; % (sr.X, amount)</span>
<span class="gi">+</span>
<span class="gi">+        pos = COORD(X=max(0, sr.X + amount), Y=sr.Y)</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleCursorPosition, self.hconsole, _coord_byval(pos)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_backward(self, amount: int) -&gt; None:</span>
<span class="gi">+        self.cursor_forward(-amount)</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write to output stream and flush.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._buffer:</span>
<span class="gi">+            # Only flush stdout buffer. (It could be that Python still has</span>
<span class="gi">+            # something in its buffer. -- We want to be sure to print that in</span>
<span class="gi">+            # the correct color.)</span>
<span class="gi">+            self.stdout.flush()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        data = &quot;&quot;.join(self._buffer)</span>

<span class="gd">-    def scroll_buffer_to_prompt(self) -&gt;None:</span>
<span class="gi">+        if _DEBUG_RENDER_OUTPUT:</span>
<span class="gi">+            self.LOG.write((&quot;%r&quot; % data).encode(&quot;utf-8&quot;) + b&quot;\n&quot;)</span>
<span class="gi">+            self.LOG.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Print characters one by one. This appears to be the best solution</span>
<span class="gi">+        # in order to avoid traces of vertical lines when the completion</span>
<span class="gi">+        # menu disappears.</span>
<span class="gi">+        for b in data:</span>
<span class="gi">+            written = DWORD()</span>
<span class="gi">+</span>
<span class="gi">+            retval = windll.kernel32.WriteConsoleW(</span>
<span class="gi">+                self.hconsole, b, 1, byref(written), None</span>
<span class="gi">+            )</span>
<span class="gi">+            assert retval != 0</span>
<span class="gi">+</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+</span>
<span class="gi">+    def get_rows_below_cursor_position(self) -&gt; int:</span>
<span class="gi">+        info = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        return info.srWindow.Bottom - info.dwCursorPosition.Y + 1</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_buffer_to_prompt(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        To be called before drawing the prompt. This should scroll the console
<span class="w"> </span>        to left, with the cursor at the bottom (if possible).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get current window size</span>
<span class="gi">+        info = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        sr = info.srWindow</span>
<span class="gi">+        cursor_pos = info.dwCursorPosition</span>
<span class="gi">+</span>
<span class="gi">+        result = SMALL_RECT()</span>
<span class="gi">+</span>
<span class="gi">+        # Scroll to the left.</span>
<span class="gi">+        result.Left = 0</span>
<span class="gi">+        result.Right = sr.Right - sr.Left</span>

<span class="gd">-    def enter_alternate_screen(self) -&gt;None:</span>
<span class="gi">+        # Scroll vertical</span>
<span class="gi">+        win_height = sr.Bottom - sr.Top</span>
<span class="gi">+        if 0 &lt; sr.Bottom - cursor_pos.Y &lt; win_height - 1:</span>
<span class="gi">+            # no vertical scroll if cursor already on the screen</span>
<span class="gi">+            result.Bottom = sr.Bottom</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.Bottom = max(win_height, cursor_pos.Y)</span>
<span class="gi">+        result.Top = result.Bottom - win_height</span>
<span class="gi">+</span>
<span class="gi">+        # Scroll API</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleWindowInfo, self.hconsole, True, byref(result)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def enter_alternate_screen(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Go to alternate screen buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def quit_alternate_screen(self) -&gt;None:</span>
<span class="gi">+        if not self._in_alternate_screen:</span>
<span class="gi">+            GENERIC_READ = 0x80000000</span>
<span class="gi">+            GENERIC_WRITE = 0x40000000</span>
<span class="gi">+</span>
<span class="gi">+            # Create a new console buffer and activate that one.</span>
<span class="gi">+            handle = HANDLE(</span>
<span class="gi">+                self._winapi(</span>
<span class="gi">+                    windll.kernel32.CreateConsoleScreenBuffer,</span>
<span class="gi">+                    GENERIC_READ | GENERIC_WRITE,</span>
<span class="gi">+                    DWORD(0),</span>
<span class="gi">+                    None,</span>
<span class="gi">+                    DWORD(1),</span>
<span class="gi">+                    None,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            self._winapi(windll.kernel32.SetConsoleActiveScreenBuffer, handle)</span>
<span class="gi">+            self.hconsole = handle</span>
<span class="gi">+            self._in_alternate_screen = True</span>
<span class="gi">+</span>
<span class="gi">+    def quit_alternate_screen(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Make stdout again the active buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        if self._in_alternate_screen:</span>
<span class="gi">+            stdout = HANDLE(</span>
<span class="gi">+                self._winapi(windll.kernel32.GetStdHandle, STD_OUTPUT_HANDLE)</span>
<span class="gi">+            )</span>
<span class="gi">+            self._winapi(windll.kernel32.SetConsoleActiveScreenBuffer, stdout)</span>
<span class="gi">+            self._winapi(windll.kernel32.CloseHandle, self.hconsole)</span>
<span class="gi">+            self.hconsole = stdout</span>
<span class="gi">+            self._in_alternate_screen = False</span>
<span class="gi">+</span>
<span class="gi">+    def enable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        ENABLE_MOUSE_INPUT = 0x10</span>
<span class="gi">+</span>
<span class="gi">+        # This `ENABLE_QUICK_EDIT_MODE` flag needs to be cleared for mouse</span>
<span class="gi">+        # support to work, but it&#39;s possible that it was already cleared</span>
<span class="gi">+        # before.</span>
<span class="gi">+        ENABLE_QUICK_EDIT_MODE = 0x0040</span>
<span class="gi">+</span>
<span class="gi">+        handle = HANDLE(windll.kernel32.GetStdHandle(STD_INPUT_HANDLE))</span>
<span class="gi">+</span>
<span class="gi">+        original_mode = DWORD()</span>
<span class="gi">+        self._winapi(windll.kernel32.GetConsoleMode, handle, pointer(original_mode))</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleMode,</span>
<span class="gi">+            handle,</span>
<span class="gi">+            (original_mode.value | ENABLE_MOUSE_INPUT) &amp; ~ENABLE_QUICK_EDIT_MODE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def disable_mouse_support(self) -&gt; None:</span>
<span class="gi">+        ENABLE_MOUSE_INPUT = 0x10</span>
<span class="gi">+        handle = HANDLE(windll.kernel32.GetStdHandle(STD_INPUT_HANDLE))</span>
<span class="gi">+</span>
<span class="gi">+        original_mode = DWORD()</span>
<span class="gi">+        self._winapi(windll.kernel32.GetConsoleMode, handle, pointer(original_mode))</span>
<span class="gi">+        self._winapi(</span>
<span class="gi">+            windll.kernel32.SetConsoleMode,</span>
<span class="gi">+            handle,</span>
<span class="gi">+            original_mode.value &amp; ~ENABLE_MOUSE_INPUT,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def hide_cursor(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def show_cursor(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def set_cursor_shape(self, cursor_shape: CursorShape) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def reset_cursor_shape(self) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="w"> </span>    @classmethod
<span class="gd">-    def win32_refresh_window(cls) -&gt;None:</span>
<span class="gi">+    def win32_refresh_window(cls) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Call win32 API to refresh the whole Window.

<span class="gu">@@ -153,50 +508,79 @@ class Win32Output(Output):</span>
<span class="w"> </span>        for completion menus. When the menu disappears, it leaves traces due
<span class="w"> </span>        to a bug in the Windows Console. Sending a repaint request solves it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get console handle</span>
<span class="gi">+        handle = HANDLE(windll.kernel32.GetConsoleWindow())</span>
<span class="gi">+</span>
<span class="gi">+        RDW_INVALIDATE = 0x0001</span>
<span class="gi">+        windll.user32.RedrawWindow(handle, None, None, c_uint(RDW_INVALIDATE))</span>

<span class="gd">-    def get_default_color_depth(self) -&gt;ColorDepth:</span>
<span class="gi">+    def get_default_color_depth(self) -&gt; ColorDepth:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the default color depth for a windows terminal.

<span class="w"> </span>        Contrary to the Vt100 implementation, this doesn&#39;t depend on a $TERM
<span class="w"> </span>        variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_color_depth is not None:</span>
<span class="gi">+            return self.default_color_depth</span>
<span class="gi">+</span>
<span class="gi">+        return ColorDepth.DEPTH_4_BIT</span>


<span class="w"> </span>class FOREGROUND_COLOR:
<span class="gd">-    BLACK = 0</span>
<span class="gd">-    BLUE = 1</span>
<span class="gd">-    GREEN = 2</span>
<span class="gd">-    CYAN = 3</span>
<span class="gd">-    RED = 4</span>
<span class="gd">-    MAGENTA = 5</span>
<span class="gd">-    YELLOW = 6</span>
<span class="gd">-    GRAY = 7</span>
<span class="gd">-    INTENSITY = 8</span>
<span class="gi">+    BLACK = 0x0000</span>
<span class="gi">+    BLUE = 0x0001</span>
<span class="gi">+    GREEN = 0x0002</span>
<span class="gi">+    CYAN = 0x0003</span>
<span class="gi">+    RED = 0x0004</span>
<span class="gi">+    MAGENTA = 0x0005</span>
<span class="gi">+    YELLOW = 0x0006</span>
<span class="gi">+    GRAY = 0x0007</span>
<span class="gi">+    INTENSITY = 0x0008  # Foreground color is intensified.</span>


<span class="w"> </span>class BACKGROUND_COLOR:
<span class="gd">-    BLACK = 0</span>
<span class="gd">-    BLUE = 16</span>
<span class="gd">-    GREEN = 32</span>
<span class="gd">-    CYAN = 48</span>
<span class="gd">-    RED = 64</span>
<span class="gd">-    MAGENTA = 80</span>
<span class="gd">-    YELLOW = 96</span>
<span class="gd">-    GRAY = 112</span>
<span class="gd">-    INTENSITY = 128</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _create_ansi_color_dict(color_cls: (type[FOREGROUND_COLOR] | type[</span>
<span class="gd">-    BACKGROUND_COLOR])) -&gt;dict[str, int]:</span>
<span class="gd">-    &quot;&quot;&quot;Create a table that maps the 16 named ansi colors to their Windows code.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    BLACK = 0x0000</span>
<span class="gi">+    BLUE = 0x0010</span>
<span class="gi">+    GREEN = 0x0020</span>
<span class="gi">+    CYAN = 0x0030</span>
<span class="gi">+    RED = 0x0040</span>
<span class="gi">+    MAGENTA = 0x0050</span>
<span class="gi">+    YELLOW = 0x0060</span>
<span class="gi">+    GRAY = 0x0070</span>
<span class="gi">+    INTENSITY = 0x0080  # Background color is intensified.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_ansi_color_dict(</span>
<span class="gi">+    color_cls: type[FOREGROUND_COLOR] | type[BACKGROUND_COLOR],</span>
<span class="gi">+) -&gt; dict[str, int]:</span>
<span class="gi">+    &quot;Create a table that maps the 16 named ansi colors to their Windows code.&quot;</span>
<span class="gi">+    return {</span>
<span class="gi">+        &quot;ansidefault&quot;: color_cls.BLACK,</span>
<span class="gi">+        &quot;ansiblack&quot;: color_cls.BLACK,</span>
<span class="gi">+        &quot;ansigray&quot;: color_cls.GRAY,</span>
<span class="gi">+        &quot;ansibrightblack&quot;: color_cls.BLACK | color_cls.INTENSITY,</span>
<span class="gi">+        &quot;ansiwhite&quot;: color_cls.GRAY | color_cls.INTENSITY,</span>
<span class="gi">+        # Low intensity.</span>
<span class="gi">+        &quot;ansired&quot;: color_cls.RED,</span>
<span class="gi">+        &quot;ansigreen&quot;: color_cls.GREEN,</span>
<span class="gi">+        &quot;ansiyellow&quot;: color_cls.YELLOW,</span>
<span class="gi">+        &quot;ansiblue&quot;: color_cls.BLUE,</span>
<span class="gi">+        &quot;ansimagenta&quot;: color_cls.MAGENTA,</span>
<span class="gi">+        &quot;ansicyan&quot;: color_cls.CYAN,</span>
<span class="gi">+        # High intensity.</span>
<span class="gi">+        &quot;ansibrightred&quot;: color_cls.RED | color_cls.INTENSITY,</span>
<span class="gi">+        &quot;ansibrightgreen&quot;: color_cls.GREEN | color_cls.INTENSITY,</span>
<span class="gi">+        &quot;ansibrightyellow&quot;: color_cls.YELLOW | color_cls.INTENSITY,</span>
<span class="gi">+        &quot;ansibrightblue&quot;: color_cls.BLUE | color_cls.INTENSITY,</span>
<span class="gi">+        &quot;ansibrightmagenta&quot;: color_cls.MAGENTA | color_cls.INTENSITY,</span>
<span class="gi">+        &quot;ansibrightcyan&quot;: color_cls.CYAN | color_cls.INTENSITY,</span>
<span class="gi">+    }</span>


<span class="w"> </span>FG_ANSI_COLORS = _create_ansi_color_dict(FOREGROUND_COLOR)
<span class="w"> </span>BG_ANSI_COLORS = _create_ansi_color_dict(BACKGROUND_COLOR)
<span class="gi">+</span>
<span class="w"> </span>assert set(FG_ANSI_COLORS) == set(ANSI_COLOR_NAMES)
<span class="w"> </span>assert set(BG_ANSI_COLORS) == set(ANSI_COLOR_NAMES)

<span class="gu">@@ -206,31 +590,94 @@ class ColorLookupTable:</span>
<span class="w"> </span>    Inspired by pygments/formatters/terminal256.py
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._win32_colors = self._build_color_table()
<span class="gi">+</span>
<span class="gi">+        # Cache (map color string to foreground and background code).</span>
<span class="w"> </span>        self.best_match: dict[str, tuple[int, int]] = {}

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _build_color_table() -&gt;list[tuple[int, int, int, int, int]]:</span>
<span class="gi">+    def _build_color_table() -&gt; list[tuple[int, int, int, int, int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Build an RGB-to-256 color conversion table
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def lookup_fg_color(self, fg_color: str) -&gt;int:</span>
<span class="gi">+        FG = FOREGROUND_COLOR</span>
<span class="gi">+        BG = BACKGROUND_COLOR</span>
<span class="gi">+</span>
<span class="gi">+        return [</span>
<span class="gi">+            (0x00, 0x00, 0x00, FG.BLACK, BG.BLACK),</span>
<span class="gi">+            (0x00, 0x00, 0xAA, FG.BLUE, BG.BLUE),</span>
<span class="gi">+            (0x00, 0xAA, 0x00, FG.GREEN, BG.GREEN),</span>
<span class="gi">+            (0x00, 0xAA, 0xAA, FG.CYAN, BG.CYAN),</span>
<span class="gi">+            (0xAA, 0x00, 0x00, FG.RED, BG.RED),</span>
<span class="gi">+            (0xAA, 0x00, 0xAA, FG.MAGENTA, BG.MAGENTA),</span>
<span class="gi">+            (0xAA, 0xAA, 0x00, FG.YELLOW, BG.YELLOW),</span>
<span class="gi">+            (0x88, 0x88, 0x88, FG.GRAY, BG.GRAY),</span>
<span class="gi">+            (0x44, 0x44, 0xFF, FG.BLUE | FG.INTENSITY, BG.BLUE | BG.INTENSITY),</span>
<span class="gi">+            (0x44, 0xFF, 0x44, FG.GREEN | FG.INTENSITY, BG.GREEN | BG.INTENSITY),</span>
<span class="gi">+            (0x44, 0xFF, 0xFF, FG.CYAN | FG.INTENSITY, BG.CYAN | BG.INTENSITY),</span>
<span class="gi">+            (0xFF, 0x44, 0x44, FG.RED | FG.INTENSITY, BG.RED | BG.INTENSITY),</span>
<span class="gi">+            (0xFF, 0x44, 0xFF, FG.MAGENTA | FG.INTENSITY, BG.MAGENTA | BG.INTENSITY),</span>
<span class="gi">+            (0xFF, 0xFF, 0x44, FG.YELLOW | FG.INTENSITY, BG.YELLOW | BG.INTENSITY),</span>
<span class="gi">+            (0x44, 0x44, 0x44, FG.BLACK | FG.INTENSITY, BG.BLACK | BG.INTENSITY),</span>
<span class="gi">+            (0xFF, 0xFF, 0xFF, FG.GRAY | FG.INTENSITY, BG.GRAY | BG.INTENSITY),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _closest_color(self, r: int, g: int, b: int) -&gt; tuple[int, int]:</span>
<span class="gi">+        distance = 257 * 257 * 3  # &quot;infinity&quot; (&gt;distance from #000000 to #ffffff)</span>
<span class="gi">+        fg_match = 0</span>
<span class="gi">+        bg_match = 0</span>
<span class="gi">+</span>
<span class="gi">+        for r_, g_, b_, fg_, bg_ in self._win32_colors:</span>
<span class="gi">+            rd = r - r_</span>
<span class="gi">+            gd = g - g_</span>
<span class="gi">+            bd = b - b_</span>
<span class="gi">+</span>
<span class="gi">+            d = rd * rd + gd * gd + bd * bd</span>
<span class="gi">+</span>
<span class="gi">+            if d &lt; distance:</span>
<span class="gi">+                fg_match = fg_</span>
<span class="gi">+                bg_match = bg_</span>
<span class="gi">+                distance = d</span>
<span class="gi">+        return fg_match, bg_match</span>
<span class="gi">+</span>
<span class="gi">+    def _color_indexes(self, color: str) -&gt; tuple[int, int]:</span>
<span class="gi">+        indexes = self.best_match.get(color, None)</span>
<span class="gi">+        if indexes is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                rgb = int(str(color), 16)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                rgb = 0</span>
<span class="gi">+</span>
<span class="gi">+            r = (rgb &gt;&gt; 16) &amp; 0xFF</span>
<span class="gi">+            g = (rgb &gt;&gt; 8) &amp; 0xFF</span>
<span class="gi">+            b = rgb &amp; 0xFF</span>
<span class="gi">+            indexes = self._closest_color(r, g, b)</span>
<span class="gi">+            self.best_match[color] = indexes</span>
<span class="gi">+        return indexes</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_fg_color(self, fg_color: str) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the color for use in the
<span class="w"> </span>        `windll.kernel32.SetConsoleTextAttribute` API call.

<span class="w"> </span>        :param fg_color: Foreground as text. E.g. &#39;ffffff&#39; or &#39;red&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Foreground.</span>
<span class="gi">+        if fg_color in FG_ANSI_COLORS:</span>
<span class="gi">+            return FG_ANSI_COLORS[fg_color]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._color_indexes(fg_color)[0]</span>

<span class="gd">-    def lookup_bg_color(self, bg_color: str) -&gt;int:</span>
<span class="gi">+    def lookup_bg_color(self, bg_color: str) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the color for use in the
<span class="w"> </span>        `windll.kernel32.SetConsoleTextAttribute` API call.

<span class="w"> </span>        :param bg_color: Background as text. E.g. &#39;ffffff&#39; or &#39;red&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Background.</span>
<span class="gi">+        if bg_color in BG_ANSI_COLORS:</span>
<span class="gi">+            return BG_ANSI_COLORS[bg_color]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._color_indexes(bg_color)[1]</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/windows10.py b/src/prompt_toolkit/output/windows10.py</span>
<span class="gh">index 8ed52363..c39f3ecf 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/windows10.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/windows10.py</span>
<span class="gu">@@ -1,18 +1,28 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-assert sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+assert sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>from ctypes import byref, windll
<span class="w"> </span>from ctypes.wintypes import DWORD, HANDLE
<span class="w"> </span>from typing import Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.data_structures import Size
<span class="w"> </span>from prompt_toolkit.win32_types import STD_OUTPUT_HANDLE
<span class="gi">+</span>
<span class="w"> </span>from .base import Output
<span class="w"> </span>from .color_depth import ColorDepth
<span class="w"> </span>from .vt100 import Vt100_Output
<span class="w"> </span>from .win32 import Win32Output
<span class="gd">-__all__ = [&#39;Windows10_Output&#39;]</span>
<span class="gd">-ENABLE_PROCESSED_INPUT = 1</span>
<span class="gd">-ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Windows10_Output&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# See: https://msdn.microsoft.com/pl-pl/library/windows/desktop/ms686033(v=vs.85).aspx</span>
<span class="gi">+ENABLE_PROCESSED_INPUT = 0x0001</span>
<span class="gi">+ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004</span>


<span class="w"> </span>class Windows10_Output:
<span class="gu">@@ -20,47 +30,99 @@ class Windows10_Output:</span>
<span class="w"> </span>    Windows 10 output abstraction. This enables and uses vt100 escape sequences.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stdout: TextIO, default_color_depth: (ColorDepth |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, stdout: TextIO, default_color_depth: ColorDepth | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.default_color_depth = default_color_depth
<span class="gd">-        self.win32_output = Win32Output(stdout, default_color_depth=</span>
<span class="gd">-            default_color_depth)</span>
<span class="gd">-        self.vt100_output = Vt100_Output(stdout, lambda : Size(0, 0),</span>
<span class="gd">-            default_color_depth=default_color_depth)</span>
<span class="gd">-        self._hconsole = HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)</span>
<span class="gd">-            )</span>
<span class="gd">-</span>
<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gi">+        self.win32_output = Win32Output(stdout, default_color_depth=default_color_depth)</span>
<span class="gi">+        self.vt100_output = Vt100_Output(</span>
<span class="gi">+            stdout, lambda: Size(0, 0), default_color_depth=default_color_depth</span>
<span class="gi">+        )</span>
<span class="gi">+        self._hconsole = HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE))</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write to output stream and flush.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_mode = DWORD(0)</span>
<span class="gi">+</span>
<span class="gi">+        # Remember the previous console mode.</span>
<span class="gi">+        windll.kernel32.GetConsoleMode(self._hconsole, byref(original_mode))</span>

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gd">-        if name in (&#39;get_size&#39;, &#39;get_rows_below_cursor_position&#39;,</span>
<span class="gd">-            &#39;enable_mouse_support&#39;, &#39;disable_mouse_support&#39;,</span>
<span class="gd">-            &#39;scroll_buffer_to_prompt&#39;, &#39;get_win32_screen_buffer_info&#39;,</span>
<span class="gd">-            &#39;enable_bracketed_paste&#39;, &#39;disable_bracketed_paste&#39;):</span>
<span class="gi">+        # Enable processing of vt100 sequences.</span>
<span class="gi">+        windll.kernel32.SetConsoleMode(</span>
<span class="gi">+            self._hconsole,</span>
<span class="gi">+            DWORD(ENABLE_PROCESSED_INPUT | ENABLE_VIRTUAL_TERMINAL_PROCESSING),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.vt100_output.flush()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Restore console mode.</span>
<span class="gi">+            windll.kernel32.SetConsoleMode(self._hconsole, original_mode)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def responds_to_cpr(self) -&gt; bool:</span>
<span class="gi">+        return False  # We don&#39;t need this on Windows.</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="gi">+        if name in (</span>
<span class="gi">+            &quot;get_size&quot;,</span>
<span class="gi">+            &quot;get_rows_below_cursor_position&quot;,</span>
<span class="gi">+            &quot;enable_mouse_support&quot;,</span>
<span class="gi">+            &quot;disable_mouse_support&quot;,</span>
<span class="gi">+            &quot;scroll_buffer_to_prompt&quot;,</span>
<span class="gi">+            &quot;get_win32_screen_buffer_info&quot;,</span>
<span class="gi">+            &quot;enable_bracketed_paste&quot;,</span>
<span class="gi">+            &quot;disable_bracketed_paste&quot;,</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return getattr(self.win32_output, name)
<span class="w"> </span>        else:
<span class="w"> </span>            return getattr(self.vt100_output, name)

<span class="gd">-    def get_default_color_depth(self) -&gt;ColorDepth:</span>
<span class="gi">+    def get_default_color_depth(self) -&gt; ColorDepth:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the default color depth for a windows terminal.

<span class="w"> </span>        Contrary to the Vt100 implementation, this doesn&#39;t depend on a $TERM
<span class="w"> </span>        variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_color_depth is not None:</span>
<span class="gi">+            return self.default_color_depth</span>
<span class="gi">+</span>
<span class="gi">+        # Previously, we used `DEPTH_4_BIT`, even on Windows 10. This was</span>
<span class="gi">+        # because true color support was added after &quot;Console Virtual Terminal</span>
<span class="gi">+        # Sequences&quot; support was added, and there was no good way to detect</span>
<span class="gi">+        # what support was given.</span>
<span class="gi">+        # 24bit color support was added in 2016, so let&#39;s assume it&#39;s safe to</span>
<span class="gi">+        # take that as a default:</span>
<span class="gi">+        # https://devblogs.microsoft.com/commandline/24-bit-color-in-the-windows-console/</span>
<span class="gi">+        return ColorDepth.TRUE_COLOR</span>


<span class="w"> </span>Output.register(Windows10_Output)


<span class="gd">-def is_win_vt100_enabled() -&gt;bool:</span>
<span class="gi">+def is_win_vt100_enabled() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns True when we&#39;re running Windows and VT100 escape sequences are
<span class="w"> </span>    supported.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform != &quot;win32&quot;:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    hconsole = HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE))</span>
<span class="gi">+</span>
<span class="gi">+    # Get original console mode.</span>
<span class="gi">+    original_mode = DWORD(0)</span>
<span class="gi">+    windll.kernel32.GetConsoleMode(hconsole, byref(original_mode))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Try to enable VT100 sequences.</span>
<span class="gi">+        result: int = windll.kernel32.SetConsoleMode(</span>
<span class="gi">+            hconsole, DWORD(ENABLE_PROCESSED_INPUT | ENABLE_VIRTUAL_TERMINAL_PROCESSING)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return result == 1</span>
<span class="gi">+    finally:</span>
<span class="gi">+        windll.kernel32.SetConsoleMode(hconsole, original_mode)</span>
<span class="gh">diff --git a/src/prompt_toolkit/patch_stdout.py b/src/prompt_toolkit/patch_stdout.py</span>
<span class="gh">index c07354d2..528bec7f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/patch_stdout.py</span>
<span class="gi">+++ b/src/prompt_toolkit/patch_stdout.py</span>
<span class="gu">@@ -18,6 +18,7 @@ Multiple applications can run in the body of the context manager, one after the</span>
<span class="w"> </span>other.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import queue
<span class="w"> </span>import sys
<span class="gu">@@ -25,13 +26,18 @@ import threading</span>
<span class="w"> </span>import time
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from typing import Generator, TextIO, cast
<span class="gi">+</span>
<span class="w"> </span>from .application import get_app_session, run_in_terminal
<span class="w"> </span>from .output import Output
<span class="gd">-__all__ = [&#39;patch_stdout&#39;, &#39;StdoutProxy&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;patch_stdout&quot;,</span>
<span class="gi">+    &quot;StdoutProxy&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def patch_stdout(raw: bool=False) -&gt;Generator[None, None, None]:</span>
<span class="gi">+def patch_stdout(raw: bool = False) -&gt; Generator[None, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace `sys.stdout` by an :class:`_StdoutProxy` instance.

<span class="gu">@@ -48,11 +54,23 @@ def patch_stdout(raw: bool=False) -&gt;Generator[None, None, None]:</span>
<span class="w"> </span>    :param raw: (`bool`) When True, vt100 terminal escape sequences are not
<span class="w"> </span>                removed/escaped.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with StdoutProxy(raw=raw) as proxy:</span>
<span class="gi">+        original_stdout = sys.stdout</span>
<span class="gi">+        original_stderr = sys.stderr</span>
<span class="gi">+</span>
<span class="gi">+        # Enter.</span>
<span class="gi">+        sys.stdout = cast(TextIO, proxy)</span>
<span class="gi">+        sys.stderr = cast(TextIO, proxy)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            sys.stdout = original_stdout</span>
<span class="gi">+            sys.stderr = original_stderr</span>


<span class="w"> </span>class _Done:
<span class="gd">-    &quot;&quot;&quot;Sentinel value for stopping the stdout proxy.&quot;&quot;&quot;</span>
<span class="gi">+    &quot;Sentinel value for stopping the stdout proxy.&quot;</span>


<span class="w"> </span>class StdoutProxy:
<span class="gu">@@ -73,63 +91,206 @@ class StdoutProxy:</span>
<span class="w"> </span>    between writes in order to bundle many smaller writes in a short timespan.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, sleep_between_writes: float=0.2, raw: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sleep_between_writes: float = 0.2,</span>
<span class="gi">+        raw: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.sleep_between_writes = sleep_between_writes
<span class="w"> </span>        self.raw = raw
<span class="gi">+</span>
<span class="w"> </span>        self._lock = threading.RLock()
<span class="w"> </span>        self._buffer: list[str] = []
<span class="gi">+</span>
<span class="gi">+        # Keep track of the curret app session.</span>
<span class="w"> </span>        self.app_session = get_app_session()
<span class="gi">+</span>
<span class="gi">+        # See what output is active *right now*. We should do it at this point,</span>
<span class="gi">+        # before this `StdoutProxy` instance is possibly assigned to `sys.stdout`.</span>
<span class="gi">+        # Otherwise, if `patch_stdout` is used, and no `Output` instance has</span>
<span class="gi">+        # been created, then the default output creation code will see this</span>
<span class="gi">+        # proxy object as `sys.stdout`, and get in a recursive loop trying to</span>
<span class="gi">+        # access `StdoutProxy.isatty()` which will again retrieve the output.</span>
<span class="w"> </span>        self._output: Output = self.app_session.output
<span class="gi">+</span>
<span class="gi">+        # Flush thread</span>
<span class="w"> </span>        self._flush_queue: queue.Queue[str | _Done] = queue.Queue()
<span class="w"> </span>        self._flush_thread = self._start_write_thread()
<span class="w"> </span>        self.closed = False

<span class="gd">-    def __enter__(self) -&gt;StdoutProxy:</span>
<span class="gi">+    def __enter__(self) -&gt; StdoutProxy:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, *args: object) -&gt;None:</span>
<span class="gi">+    def __exit__(self, *args: object) -&gt; None:</span>
<span class="w"> </span>        self.close()

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Stop `StdoutProxy` proxy.

<span class="w"> </span>        This will terminate the write thread, make sure everything is flushed
<span class="w"> </span>        and wait for the write thread to finish.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.closed:</span>
<span class="gi">+            self._flush_queue.put(_Done())</span>
<span class="gi">+            self._flush_thread.join()</span>
<span class="gi">+            self.closed = True</span>
<span class="gi">+</span>
<span class="gi">+    def _start_write_thread(self) -&gt; threading.Thread:</span>
<span class="gi">+        thread = threading.Thread(</span>
<span class="gi">+            target=self._write_thread,</span>
<span class="gi">+            name=&quot;patch-stdout-flush-thread&quot;,</span>
<span class="gi">+            daemon=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        thread.start()</span>
<span class="gi">+        return thread</span>
<span class="gi">+</span>
<span class="gi">+    def _write_thread(self) -&gt; None:</span>
<span class="gi">+        done = False</span>
<span class="gi">+</span>
<span class="gi">+        while not done:</span>
<span class="gi">+            item = self._flush_queue.get()</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(item, _Done):</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # Don&#39;t bother calling when we got an empty string.</span>
<span class="gi">+            if not item:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            text = []</span>
<span class="gi">+            text.append(item)</span>
<span class="gi">+</span>
<span class="gi">+            # Read the rest of the queue if more data was queued up.</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    item = self._flush_queue.get_nowait()</span>
<span class="gi">+                except queue.Empty:</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if isinstance(item, _Done):</span>
<span class="gi">+                        done = True</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        text.append(item)</span>
<span class="gi">+</span>
<span class="gi">+            app_loop = self._get_app_loop()</span>
<span class="gi">+            self._write_and_flush(app_loop, &quot;&quot;.join(text))</span>
<span class="gi">+</span>
<span class="gi">+            # If an application was running that requires repainting, then wait</span>
<span class="gi">+            # for a very short time, in order to bundle actual writes and avoid</span>
<span class="gi">+            # having to repaint to often.</span>
<span class="gi">+            if app_loop is not None:</span>
<span class="gi">+                time.sleep(self.sleep_between_writes)</span>

<span class="gd">-    def _get_app_loop(self) -&gt;(asyncio.AbstractEventLoop | None):</span>
<span class="gi">+    def _get_app_loop(self) -&gt; asyncio.AbstractEventLoop | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the event loop for the application currently running in our
<span class="w"> </span>        `AppSession`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = self.app_session.app</span>

<span class="gd">-    def _write_and_flush(self, loop: (asyncio.AbstractEventLoop | None),</span>
<span class="gd">-        text: str) -&gt;None:</span>
<span class="gi">+        if app is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return app.loop</span>
<span class="gi">+</span>
<span class="gi">+    def _write_and_flush(</span>
<span class="gi">+        self, loop: asyncio.AbstractEventLoop | None, text: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write the given text to stdout and flush.
<span class="w"> </span>        If an application is running, use `run_in_terminal`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _write(self, data: str) -&gt;None:</span>
<span class="gi">+        def write_and_flush() -&gt; None:</span>
<span class="gi">+            # Ensure that autowrap is enabled before calling `write`.</span>
<span class="gi">+            # XXX: On Windows, the `Windows10_Output` enables/disables VT</span>
<span class="gi">+            #      terminal processing for every flush. It turns out that this</span>
<span class="gi">+            #      causes autowrap to be reset (disabled) after each flush. So,</span>
<span class="gi">+            #      we have to enable it again before writing text.</span>
<span class="gi">+            self._output.enable_autowrap()</span>
<span class="gi">+</span>
<span class="gi">+            if self.raw:</span>
<span class="gi">+                self._output.write_raw(text)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._output.write(text)</span>
<span class="gi">+</span>
<span class="gi">+            self._output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        def write_and_flush_in_loop() -&gt; None:</span>
<span class="gi">+            # If an application is running, use `run_in_terminal`, otherwise</span>
<span class="gi">+            # call it directly.</span>
<span class="gi">+            run_in_terminal(write_and_flush, in_executor=False)</span>
<span class="gi">+</span>
<span class="gi">+        if loop is None:</span>
<span class="gi">+            # No loop, write immediately.</span>
<span class="gi">+            write_and_flush()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Make sure `write_and_flush` is executed *in* the event loop, not</span>
<span class="gi">+            # in another thread.</span>
<span class="gi">+            loop.call_soon_threadsafe(write_and_flush_in_loop)</span>
<span class="gi">+</span>
<span class="gi">+    def _write(self, data: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Note: print()-statements cause to multiple write calls.
<span class="gd">-              (write(&#39;line&#39;) and write(&#39;</span>
<span class="gd">-&#39;)). Of course we don&#39;t want to call</span>
<span class="gi">+              (write(&#39;line&#39;) and write(&#39;\n&#39;)). Of course we don&#39;t want to call</span>
<span class="w"> </span>              `run_in_terminal` for every individual call, because that&#39;s too
<span class="w"> </span>              expensive, and as long as the newline hasn&#39;t been written, the
<span class="w"> </span>              text itself is again overwritten by the rendering of the input
<span class="w"> </span>              command line. Therefor, we have a little buffer which holds the
<span class="w"> </span>              text until a newline is written to stdout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;\n&quot; in data:</span>
<span class="gi">+            # When there is a newline in the data, write everything before the</span>
<span class="gi">+            # newline, including the newline itself.</span>
<span class="gi">+            before, after = data.rsplit(&quot;\n&quot;, 1)</span>
<span class="gi">+            to_write = self._buffer + [before, &quot;\n&quot;]</span>
<span class="gi">+            self._buffer = [after]</span>
<span class="gi">+</span>
<span class="gi">+            text = &quot;&quot;.join(to_write)</span>
<span class="gi">+            self._flush_queue.put(text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, cache in buffer.</span>
<span class="gi">+            self._buffer.append(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _flush(self) -&gt; None:</span>
<span class="gi">+        text = &quot;&quot;.join(self._buffer)</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        self._flush_queue.put(text)</span>

<span class="gd">-    def flush(self) -&gt;None:</span>
<span class="gi">+    def write(self, data: str) -&gt; int:</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._write(data)</span>
<span class="gi">+</span>
<span class="gi">+        return len(data)  # Pretend everything was written.</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush buffered output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._flush()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def original_stdout(self) -&gt; TextIO:</span>
<span class="gi">+        return self._output.stdout or sys.__stdout__</span>
<span class="gi">+</span>
<span class="gi">+    # Attributes for compatibility with sys.__stdout__:</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return self._output.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def isatty(self) -&gt; bool:</span>
<span class="gi">+        stdout = self._output.stdout</span>
<span class="gi">+        if stdout is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return stdout.isatty()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def encoding(self) -&gt; str:</span>
<span class="gi">+        return self._output.encoding()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def errors(self) -&gt; str:</span>
<span class="gi">+        return &quot;strict&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/renderer.py b/src/prompt_toolkit/renderer.py</span>
<span class="gh">index d60c37f7..5ad1dd68 100644</span>
<span class="gd">--- a/src/prompt_toolkit/renderer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/renderer.py</span>
<span class="gu">@@ -3,10 +3,12 @@ Renders the command line on the console.</span>
<span class="w"> </span>(Redraws parts of the input line that were changed.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from asyncio import FIRST_COMPLETED, Future, ensure_future, sleep, wait
<span class="w"> </span>from collections import deque
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, Hashable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.cursor_shapes import CursorShape
<span class="w"> </span>from prompt_toolkit.data_structures import Point, Size
<span class="gu">@@ -15,19 +17,39 @@ from prompt_toolkit.formatted_text import AnyFormattedText, to_formatted_text</span>
<span class="w"> </span>from prompt_toolkit.layout.mouse_handlers import MouseHandlers
<span class="w"> </span>from prompt_toolkit.layout.screen import Char, Screen, WritePosition
<span class="w"> </span>from prompt_toolkit.output import ColorDepth, Output
<span class="gd">-from prompt_toolkit.styles import Attrs, BaseStyle, DummyStyleTransformation, StyleTransformation</span>
<span class="gi">+from prompt_toolkit.styles import (</span>
<span class="gi">+    Attrs,</span>
<span class="gi">+    BaseStyle,</span>
<span class="gi">+    DummyStyleTransformation,</span>
<span class="gi">+    StyleTransformation,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.application import Application
<span class="w"> </span>    from prompt_toolkit.layout.layout import Layout
<span class="gd">-__all__ = [&#39;Renderer&#39;, &#39;print_formatted_text&#39;]</span>


<span class="gd">-def _output_screen_diff(app: Application[Any], output: Output, screen:</span>
<span class="gd">-    Screen, current_pos: Point, color_depth: ColorDepth, previous_screen: (</span>
<span class="gd">-    Screen | None), last_style: (str | None), is_done: bool, full_screen:</span>
<span class="gd">-    bool, attrs_for_style_string: _StyleStringToAttrsCache,</span>
<span class="gd">-    style_string_has_style: _StyleStringHasStyleCache, size: Size,</span>
<span class="gd">-    previous_width: int) -&gt;tuple[Point, str | None]:</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Renderer&quot;,</span>
<span class="gi">+    &quot;print_formatted_text&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _output_screen_diff(</span>
<span class="gi">+    app: Application[Any],</span>
<span class="gi">+    output: Output,</span>
<span class="gi">+    screen: Screen,</span>
<span class="gi">+    current_pos: Point,</span>
<span class="gi">+    color_depth: ColorDepth,</span>
<span class="gi">+    previous_screen: Screen | None,</span>
<span class="gi">+    last_style: str | None,</span>
<span class="gi">+    is_done: bool,  # XXX: drop is_done</span>
<span class="gi">+    full_screen: bool,</span>
<span class="gi">+    attrs_for_style_string: _StyleStringToAttrsCache,</span>
<span class="gi">+    style_string_has_style: _StyleStringHasStyleCache,</span>
<span class="gi">+    size: Size,</span>
<span class="gi">+    previous_width: int,</span>
<span class="gi">+) -&gt; tuple[Point, str | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Render the diff between this screen and the previous screen.

<span class="gu">@@ -47,11 +69,201 @@ def _output_screen_diff(app: Application[Any], output: Output, screen:</span>
<span class="w"> </span>    :param width: The width of the terminal.
<span class="w"> </span>    :param previous_width: The width of the terminal during the last rendering.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    width, height = size.columns, size.rows</span>
<span class="gi">+</span>
<span class="gi">+    #: Variable for capturing the output.</span>
<span class="gi">+    write = output.write</span>
<span class="gi">+    write_raw = output.write_raw</span>
<span class="gi">+</span>
<span class="gi">+    # Create locals for the most used output methods.</span>
<span class="gi">+    # (Save expensive attribute lookups.)</span>
<span class="gi">+    _output_set_attributes = output.set_attributes</span>
<span class="gi">+    _output_reset_attributes = output.reset_attributes</span>
<span class="gi">+    _output_cursor_forward = output.cursor_forward</span>
<span class="gi">+    _output_cursor_up = output.cursor_up</span>
<span class="gi">+    _output_cursor_backward = output.cursor_backward</span>
<span class="gi">+</span>
<span class="gi">+    # Hide cursor before rendering. (Avoid flickering.)</span>
<span class="gi">+    output.hide_cursor()</span>
<span class="gi">+</span>
<span class="gi">+    def reset_attributes() -&gt; None:</span>
<span class="gi">+        &quot;Wrapper around Output.reset_attributes.&quot;</span>
<span class="gi">+        nonlocal last_style</span>
<span class="gi">+        _output_reset_attributes()</span>
<span class="gi">+        last_style = None  # Forget last char after resetting attributes.</span>
<span class="gi">+</span>
<span class="gi">+    def move_cursor(new: Point) -&gt; Point:</span>
<span class="gi">+        &quot;Move cursor to this `new` point. Returns the given Point.&quot;</span>
<span class="gi">+        current_x, current_y = current_pos.x, current_pos.y</span>
<span class="gi">+</span>
<span class="gi">+        if new.y &gt; current_y:</span>
<span class="gi">+            # Use newlines instead of CURSOR_DOWN, because this might add new lines.</span>
<span class="gi">+            # CURSOR_DOWN will never create new lines at the bottom.</span>
<span class="gi">+            # Also reset attributes, otherwise the newline could draw a</span>
<span class="gi">+            # background color.</span>
<span class="gi">+            reset_attributes()</span>
<span class="gi">+            write(&quot;\r\n&quot; * (new.y - current_y))</span>
<span class="gi">+            current_x = 0</span>
<span class="gi">+            _output_cursor_forward(new.x)</span>
<span class="gi">+            return new</span>
<span class="gi">+        elif new.y &lt; current_y:</span>
<span class="gi">+            _output_cursor_up(current_y - new.y)</span>
<span class="gi">+</span>
<span class="gi">+        if current_x &gt;= width - 1:</span>
<span class="gi">+            write(&quot;\r&quot;)</span>
<span class="gi">+            _output_cursor_forward(new.x)</span>
<span class="gi">+        elif new.x &lt; current_x or current_x &gt;= width - 1:</span>
<span class="gi">+            _output_cursor_backward(current_x - new.x)</span>
<span class="gi">+        elif new.x &gt; current_x:</span>
<span class="gi">+            _output_cursor_forward(new.x - current_x)</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def output_char(char: Char) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Write the output of this character.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        nonlocal last_style</span>
<span class="gi">+</span>
<span class="gi">+        # If the last printed character has the same style, don&#39;t output the</span>
<span class="gi">+        # style again.</span>
<span class="gi">+        if last_style == char.style:</span>
<span class="gi">+            write(char.char)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Look up `Attr` for this style string. Only set attributes if different.</span>
<span class="gi">+            # (Two style strings can still have the same formatting.)</span>
<span class="gi">+            # Note that an empty style string can have formatting that needs to</span>
<span class="gi">+            # be applied, because of style transformations.</span>
<span class="gi">+            new_attrs = attrs_for_style_string[char.style]</span>
<span class="gi">+            if not last_style or new_attrs != attrs_for_style_string[last_style]:</span>
<span class="gi">+                _output_set_attributes(new_attrs, color_depth)</span>
<span class="gi">+</span>
<span class="gi">+            write(char.char)</span>
<span class="gi">+            last_style = char.style</span>
<span class="gi">+</span>
<span class="gi">+    def get_max_column_index(row: dict[int, Char]) -&gt; int:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Return max used column index, ignoring whitespace (without style) at</span>
<span class="gi">+        the end of the line. This is important for people that copy/paste</span>
<span class="gi">+        terminal output.</span>
<span class="gi">+</span>
<span class="gi">+        There are two reasons we are sometimes seeing whitespace at the end:</span>
<span class="gi">+        - `BufferControl` adds a trailing space to each line, because it&#39;s a</span>
<span class="gi">+          possible cursor position, so that the line wrapping won&#39;t change if</span>
<span class="gi">+          the cursor position moves around.</span>
<span class="gi">+        - The `Window` adds a style class to the current line for highlighting</span>
<span class="gi">+          (cursor-line).</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        numbers = (</span>
<span class="gi">+            index</span>
<span class="gi">+            for index, cell in row.items()</span>
<span class="gi">+            if cell.char != &quot; &quot; or style_string_has_style[cell.style]</span>
<span class="gi">+        )</span>
<span class="gi">+        return max(numbers, default=0)</span>
<span class="gi">+</span>
<span class="gi">+    # Render for the first time: reset styling.</span>
<span class="gi">+    if not previous_screen:</span>
<span class="gi">+        reset_attributes()</span>
<span class="gi">+</span>
<span class="gi">+    # Disable autowrap. (When entering a the alternate screen, or anytime when</span>
<span class="gi">+    # we have a prompt. - In the case of a REPL, like IPython, people can have</span>
<span class="gi">+    # background threads, and it&#39;s hard for debugging if their output is not</span>
<span class="gi">+    # wrapped.)</span>
<span class="gi">+    if not previous_screen or not full_screen:</span>
<span class="gi">+        output.disable_autowrap()</span>
<span class="gi">+</span>
<span class="gi">+    # When the previous screen has a different size, redraw everything anyway.</span>
<span class="gi">+    # Also when we are done. (We might take up less rows, so clearing is important.)</span>
<span class="gi">+    if (</span>
<span class="gi">+        is_done or not previous_screen or previous_width != width</span>
<span class="gi">+    ):  # XXX: also consider height??</span>
<span class="gi">+        current_pos = move_cursor(Point(x=0, y=0))</span>
<span class="gi">+        reset_attributes()</span>
<span class="gi">+        output.erase_down()</span>
<span class="gi">+</span>
<span class="gi">+        previous_screen = Screen()</span>
<span class="gi">+</span>
<span class="gi">+    # Get height of the screen.</span>
<span class="gi">+    # (height changes as we loop over data_buffer, so remember the current value.)</span>
<span class="gi">+    # (Also make sure to clip the height to the size of the output.)</span>
<span class="gi">+    current_height = min(screen.height, height)</span>
<span class="gi">+</span>
<span class="gi">+    # Loop over the rows.</span>
<span class="gi">+    row_count = min(max(screen.height, previous_screen.height), height)</span>
<span class="gi">+</span>
<span class="gi">+    for y in range(row_count):</span>
<span class="gi">+        new_row = screen.data_buffer[y]</span>
<span class="gi">+        previous_row = previous_screen.data_buffer[y]</span>
<span class="gi">+        zero_width_escapes_row = screen.zero_width_escapes[y]</span>
<span class="gi">+</span>
<span class="gi">+        new_max_line_len = min(width - 1, get_max_column_index(new_row))</span>
<span class="gi">+        previous_max_line_len = min(width - 1, get_max_column_index(previous_row))</span>
<span class="gi">+</span>
<span class="gi">+        # Loop over the columns.</span>
<span class="gi">+        c = 0  # Column counter.</span>
<span class="gi">+        while c &lt;= new_max_line_len:</span>
<span class="gi">+            new_char = new_row[c]</span>
<span class="gi">+            old_char = previous_row[c]</span>
<span class="gi">+            char_width = new_char.width or 1</span>
<span class="gi">+</span>
<span class="gi">+            # When the old and new character at this position are different,</span>
<span class="gi">+            # draw the output. (Because of the performance, we don&#39;t call</span>
<span class="gi">+            # `Char.__ne__`, but inline the same expression.)</span>
<span class="gi">+            if new_char.char != old_char.char or new_char.style != old_char.style:</span>
<span class="gi">+                current_pos = move_cursor(Point(x=c, y=y))</span>
<span class="gi">+</span>
<span class="gi">+                # Send injected escape sequences to output.</span>
<span class="gi">+                if c in zero_width_escapes_row:</span>
<span class="gi">+                    write_raw(zero_width_escapes_row[c])</span>
<span class="gi">+</span>
<span class="gi">+                output_char(new_char)</span>
<span class="gi">+                current_pos = Point(x=current_pos.x + char_width, y=current_pos.y)</span>
<span class="gi">+</span>
<span class="gi">+            c += char_width</span>
<span class="gi">+</span>
<span class="gi">+        # If the new line is shorter, trim it.</span>
<span class="gi">+        if previous_screen and new_max_line_len &lt; previous_max_line_len:</span>
<span class="gi">+            current_pos = move_cursor(Point(x=new_max_line_len + 1, y=y))</span>
<span class="gi">+            reset_attributes()</span>
<span class="gi">+            output.erase_end_of_line()</span>
<span class="gi">+</span>
<span class="gi">+    # Correctly reserve vertical space as required by the layout.</span>
<span class="gi">+    # When this is a new screen (drawn for the first time), or for some reason</span>
<span class="gi">+    # higher than the previous one. Move the cursor once to the bottom of the</span>
<span class="gi">+    # output. That way, we&#39;re sure that the terminal scrolls up, even when the</span>
<span class="gi">+    # lower lines of the canvas just contain whitespace.</span>
<span class="gi">+</span>
<span class="gi">+    # The most obvious reason that we actually want this behavior is the avoid</span>
<span class="gi">+    # the artifact of the input scrolling when the completion menu is shown.</span>
<span class="gi">+    # (If the scrolling is actually wanted, the layout can still be build in a</span>
<span class="gi">+    # way to behave that way by setting a dynamic height.)</span>
<span class="gi">+    if current_height &gt; previous_screen.height:</span>
<span class="gi">+        current_pos = move_cursor(Point(x=0, y=current_height - 1))</span>
<span class="gi">+</span>
<span class="gi">+    # Move cursor:</span>
<span class="gi">+    if is_done:</span>
<span class="gi">+        current_pos = move_cursor(Point(x=0, y=current_height))</span>
<span class="gi">+        output.erase_down()</span>
<span class="gi">+    else:</span>
<span class="gi">+        current_pos = move_cursor(screen.get_cursor_position(app.layout.current_window))</span>
<span class="gi">+</span>
<span class="gi">+    if is_done or not full_screen:</span>
<span class="gi">+        output.enable_autowrap()</span>
<span class="gi">+</span>
<span class="gi">+    # Always reset the color attributes. This is important because a background</span>
<span class="gi">+    # thread could print data to stdout and we want that to be displayed in the</span>
<span class="gi">+    # default colors. (Also, if a background color has been set, many terminals</span>
<span class="gi">+    # give weird artifacts on resize events.)</span>
<span class="gi">+    reset_attributes()</span>
<span class="gi">+</span>
<span class="gi">+    if screen.show_cursor or is_done:</span>
<span class="gi">+        output.show_cursor()</span>
<span class="gi">+</span>
<span class="gi">+    return current_pos, last_style</span>


<span class="w"> </span>class HeightIsUnknownError(Exception):
<span class="gd">-    &quot;&quot;&quot;Information unavailable. Did not yet receive the CPR response.&quot;&quot;&quot;</span>
<span class="gi">+    &quot;Information unavailable. Did not yet receive the CPR response.&quot;</span>


<span class="w"> </span>class _StyleStringToAttrsCache(Dict[str, Attrs]):
<span class="gu">@@ -60,14 +272,18 @@ class _StyleStringToAttrsCache(Dict[str, Attrs]):</span>
<span class="w"> </span>    (This is an important speed up.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_attrs_for_style_str: Callable[[str], Attrs],</span>
<span class="gd">-        style_transformation: StyleTransformation) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_attrs_for_style_str: Callable[[str], Attrs],</span>
<span class="gi">+        style_transformation: StyleTransformation,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.get_attrs_for_style_str = get_attrs_for_style_str
<span class="w"> </span>        self.style_transformation = style_transformation

<span class="gd">-    def __missing__(self, style_str: str) -&gt;Attrs:</span>
<span class="gi">+    def __missing__(self, style_str: str) -&gt; Attrs:</span>
<span class="w"> </span>        attrs = self.get_attrs_for_style_str(style_str)
<span class="w"> </span>        attrs = self.style_transformation.transform_attrs(attrs)
<span class="gi">+</span>
<span class="w"> </span>        self[style_str] = attrs
<span class="w"> </span>        return attrs

<span class="gu">@@ -83,22 +299,30 @@ class _StyleStringHasStyleCache(Dict[str, bool]):</span>
<span class="w"> </span>    output if there&#39;s no text in the cell.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, style_string_to_attrs: dict[str, Attrs]) -&gt;None:</span>
<span class="gi">+    def __init__(self, style_string_to_attrs: dict[str, Attrs]) -&gt; None:</span>
<span class="w"> </span>        self.style_string_to_attrs = style_string_to_attrs

<span class="gd">-    def __missing__(self, style_str: str) -&gt;bool:</span>
<span class="gi">+    def __missing__(self, style_str: str) -&gt; bool:</span>
<span class="w"> </span>        attrs = self.style_string_to_attrs[style_str]
<span class="gd">-        is_default = bool(attrs.color or attrs.bgcolor or attrs.underline or</span>
<span class="gd">-            attrs.strike or attrs.blink or attrs.reverse)</span>
<span class="gi">+        is_default = bool(</span>
<span class="gi">+            attrs.color</span>
<span class="gi">+            or attrs.bgcolor</span>
<span class="gi">+            or attrs.underline</span>
<span class="gi">+            or attrs.strike</span>
<span class="gi">+            or attrs.blink</span>
<span class="gi">+            or attrs.reverse</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self[style_str] = is_default
<span class="w"> </span>        return is_default


<span class="w"> </span>class CPR_Support(Enum):
<span class="gd">-    &quot;&quot;&quot;Enum: whether or not CPR is supported.&quot;&quot;&quot;</span>
<span class="gd">-    SUPPORTED = &#39;SUPPORTED&#39;</span>
<span class="gd">-    NOT_SUPPORTED = &#39;NOT_SUPPORTED&#39;</span>
<span class="gd">-    UNKNOWN = &#39;UNKNOWN&#39;</span>
<span class="gi">+    &quot;Enum: whether or not CPR is supported.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SUPPORTED = &quot;SUPPORTED&quot;</span>
<span class="gi">+    NOT_SUPPORTED = &quot;NOT_SUPPORTED&quot;</span>
<span class="gi">+    UNKNOWN = &quot;UNKNOWN&quot;</span>


<span class="w"> </span>class Renderer:
<span class="gu">@@ -111,56 +335,130 @@ class Renderer:</span>
<span class="w"> </span>        r = Renderer(style, output)
<span class="w"> </span>        r.render(app, layout=...)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    CPR_TIMEOUT = 2</span>

<span class="gd">-    def __init__(self, style: BaseStyle, output: Output, full_screen: bool=</span>
<span class="gd">-        False, mouse_support: FilterOrBool=False,</span>
<span class="gd">-        cpr_not_supported_callback: (Callable[[], None] | None)=None) -&gt;None:</span>
<span class="gi">+    CPR_TIMEOUT = 2  # Time to wait until we consider CPR to be not supported.</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        style: BaseStyle,</span>
<span class="gi">+        output: Output,</span>
<span class="gi">+        full_screen: bool = False,</span>
<span class="gi">+        mouse_support: FilterOrBool = False,</span>
<span class="gi">+        cpr_not_supported_callback: Callable[[], None] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.output = output
<span class="w"> </span>        self.full_screen = full_screen
<span class="w"> </span>        self.mouse_support = to_filter(mouse_support)
<span class="w"> </span>        self.cpr_not_supported_callback = cpr_not_supported_callback
<span class="gi">+</span>
<span class="w"> </span>        self._in_alternate_screen = False
<span class="w"> </span>        self._mouse_support_enabled = False
<span class="w"> </span>        self._bracketed_paste_enabled = False
<span class="w"> </span>        self._cursor_key_mode_reset = False
<span class="gi">+</span>
<span class="gi">+        # Future set when we are waiting for a CPR flag.</span>
<span class="w"> </span>        self._waiting_for_cpr_futures: deque[Future[None]] = deque()
<span class="w"> </span>        self.cpr_support = CPR_Support.UNKNOWN
<span class="gi">+</span>
<span class="w"> </span>        if not output.responds_to_cpr:
<span class="w"> </span>            self.cpr_support = CPR_Support.NOT_SUPPORTED
<span class="gi">+</span>
<span class="gi">+        # Cache for the style.</span>
<span class="w"> </span>        self._attrs_for_style: _StyleStringToAttrsCache | None = None
<span class="w"> </span>        self._style_string_has_style: _StyleStringHasStyleCache | None = None
<span class="w"> </span>        self._last_style_hash: Hashable | None = None
<span class="w"> </span>        self._last_transformation_hash: Hashable | None = None
<span class="w"> </span>        self._last_color_depth: ColorDepth | None = None
<span class="gi">+</span>
<span class="w"> </span>        self.reset(_scroll=True)

<span class="gi">+    def reset(self, _scroll: bool = False, leave_alternate_screen: bool = True) -&gt; None:</span>
<span class="gi">+        # Reset position</span>
<span class="gi">+        self._cursor_pos = Point(x=0, y=0)</span>
<span class="gi">+</span>
<span class="gi">+        # Remember the last screen instance between renderers. This way,</span>
<span class="gi">+        # we can create a `diff` between two screens and only output the</span>
<span class="gi">+        # difference. It&#39;s also to remember the last height. (To show for</span>
<span class="gi">+        # instance a toolbar at the bottom position.)</span>
<span class="gi">+        self._last_screen: Screen | None = None</span>
<span class="gi">+        self._last_size: Size | None = None</span>
<span class="gi">+        self._last_style: str | None = None</span>
<span class="gi">+        self._last_cursor_shape: CursorShape | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # Default MouseHandlers. (Just empty.)</span>
<span class="gi">+        self.mouse_handlers = MouseHandlers()</span>
<span class="gi">+</span>
<span class="gi">+        #: Space from the top of the layout, until the bottom of the terminal.</span>
<span class="gi">+        #: We don&#39;t know this until a `report_absolute_cursor_row` call.</span>
<span class="gi">+        self._min_available_height = 0</span>
<span class="gi">+</span>
<span class="gi">+        # In case of Windows, also make sure to scroll to the current cursor</span>
<span class="gi">+        # position. (Only when rendering the first time.)</span>
<span class="gi">+        # It does nothing for vt100 terminals.</span>
<span class="gi">+        if _scroll:</span>
<span class="gi">+            self.output.scroll_buffer_to_prompt()</span>
<span class="gi">+</span>
<span class="gi">+        # Quit alternate screen.</span>
<span class="gi">+        if self._in_alternate_screen and leave_alternate_screen:</span>
<span class="gi">+            self.output.quit_alternate_screen()</span>
<span class="gi">+            self._in_alternate_screen = False</span>
<span class="gi">+</span>
<span class="gi">+        # Disable mouse support.</span>
<span class="gi">+        if self._mouse_support_enabled:</span>
<span class="gi">+            self.output.disable_mouse_support()</span>
<span class="gi">+            self._mouse_support_enabled = False</span>
<span class="gi">+</span>
<span class="gi">+        # Disable bracketed paste.</span>
<span class="gi">+        if self._bracketed_paste_enabled:</span>
<span class="gi">+            self.output.disable_bracketed_paste()</span>
<span class="gi">+            self._bracketed_paste_enabled = False</span>
<span class="gi">+</span>
<span class="gi">+        self.output.reset_cursor_shape()</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: No need to set/reset cursor key mode here.</span>
<span class="gi">+</span>
<span class="gi">+        # Flush output. `disable_mouse_support` needs to write to stdout.</span>
<span class="gi">+        self.output.flush()</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def last_rendered_screen(self) -&gt;(Screen | None):</span>
<span class="gi">+    def last_rendered_screen(self) -&gt; Screen | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The `Screen` class that was generated during the last rendering.
<span class="w"> </span>        This can be `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._last_screen</span>

<span class="w"> </span>    @property
<span class="gd">-    def height_is_known(self) -&gt;bool:</span>
<span class="gi">+    def height_is_known(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when the height from the cursor until the bottom of the terminal
<span class="w"> </span>        is known. (It&#39;s often nicer to draw bottom toolbars only if the height
<span class="w"> </span>        is known, in order to avoid flickering when the CPR response arrives.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.full_screen or self._min_available_height &gt; 0:</span>
<span class="gi">+            return True</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._min_available_height = self.output.get_rows_below_cursor_position()</span>
<span class="gi">+            return True</span>
<span class="gi">+        except NotImplementedError:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    @property
<span class="gd">-    def rows_above_layout(self) -&gt;int:</span>
<span class="gi">+    def rows_above_layout(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the number of rows visible in the terminal above the layout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def request_absolute_cursor_position(self) -&gt;None:</span>
<span class="gi">+        if self._in_alternate_screen:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        elif self._min_available_height &gt; 0:</span>
<span class="gi">+            total_rows = self.output.get_size().rows</span>
<span class="gi">+            last_screen_height = self._last_screen.height if self._last_screen else 0</span>
<span class="gi">+            return total_rows - max(self._min_available_height, last_screen_height)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise HeightIsUnknownError(&quot;Rows above layout is unknown.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def request_absolute_cursor_position(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get current cursor position.

<span class="gu">@@ -171,40 +469,262 @@ class Renderer:</span>
<span class="w"> </span>        For vt100: Do CPR request. (answer will arrive later.)
<span class="w"> </span>        For win32: Do API call. (Answer comes immediately.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Only do this request when the cursor is at the top row. (after a</span>
<span class="gi">+        # clear or reset). We will rely on that in `report_absolute_cursor_row`.</span>
<span class="gi">+        assert self._cursor_pos.y == 0</span>
<span class="gi">+</span>
<span class="gi">+        # In full-screen mode, always use the total height as min-available-height.</span>
<span class="gi">+        if self.full_screen:</span>
<span class="gi">+            self._min_available_height = self.output.get_size().rows</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # For Win32, we have an API call to get the number of rows below the</span>
<span class="gi">+        # cursor.</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._min_available_height = self.output.get_rows_below_cursor_position()</span>
<span class="gi">+            return</span>
<span class="gi">+        except NotImplementedError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Use CPR.</span>
<span class="gi">+        if self.cpr_support == CPR_Support.NOT_SUPPORTED:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        def do_cpr() -&gt; None:</span>
<span class="gi">+            # Asks for a cursor position report (CPR).</span>
<span class="gi">+            self._waiting_for_cpr_futures.append(Future())</span>
<span class="gi">+            self.output.ask_for_cpr()</span>
<span class="gi">+</span>
<span class="gi">+        if self.cpr_support == CPR_Support.SUPPORTED:</span>
<span class="gi">+            do_cpr()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If we don&#39;t know whether CPR is supported, only do a request if</span>
<span class="gi">+        # none is pending, and test it, using a timer.</span>
<span class="gi">+        if self.waiting_for_cpr:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        do_cpr()</span>
<span class="gi">+</span>
<span class="gi">+        async def timer() -&gt; None:</span>
<span class="gi">+            await sleep(self.CPR_TIMEOUT)</span>
<span class="gi">+</span>
<span class="gi">+            # Not set in the meantime -&gt; not supported.</span>
<span class="gi">+            if self.cpr_support == CPR_Support.UNKNOWN:</span>
<span class="gi">+                self.cpr_support = CPR_Support.NOT_SUPPORTED</span>
<span class="gi">+</span>
<span class="gi">+                if self.cpr_not_supported_callback:</span>
<span class="gi">+                    # Make sure to call this callback in the main thread.</span>
<span class="gi">+                    self.cpr_not_supported_callback()</span>

<span class="gd">-    def report_absolute_cursor_row(self, row: int) -&gt;None:</span>
<span class="gi">+        get_app().create_background_task(timer())</span>
<span class="gi">+</span>
<span class="gi">+    def report_absolute_cursor_row(self, row: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        To be called when we know the absolute cursor position.
<span class="w"> </span>        (As an answer of a &quot;Cursor Position Request&quot; response.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cpr_support = CPR_Support.SUPPORTED</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate the amount of rows from the cursor position until the</span>
<span class="gi">+        # bottom of the terminal.</span>
<span class="gi">+        total_rows = self.output.get_size().rows</span>
<span class="gi">+        rows_below_cursor = total_rows - row + 1</span>
<span class="gi">+</span>
<span class="gi">+        # Set the minimum available height.</span>
<span class="gi">+        self._min_available_height = rows_below_cursor</span>
<span class="gi">+</span>
<span class="gi">+        # Pop and set waiting for CPR future.</span>
<span class="gi">+        try:</span>
<span class="gi">+            f = self._waiting_for_cpr_futures.popleft()</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            pass  # Received CPR response without having a CPR.</span>
<span class="gi">+        else:</span>
<span class="gi">+            f.set_result(None)</span>

<span class="w"> </span>    @property
<span class="gd">-    def waiting_for_cpr(self) -&gt;bool:</span>
<span class="gi">+    def waiting_for_cpr(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Waiting for CPR flag. True when we send the request, but didn&#39;t got a
<span class="w"> </span>        response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self._waiting_for_cpr_futures)</span>

<span class="gd">-    async def wait_for_cpr_responses(self, timeout: int=1) -&gt;None:</span>
<span class="gi">+    async def wait_for_cpr_responses(self, timeout: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wait for a CPR response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def render(self, app: Application[Any], layout: Layout, is_done: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        cpr_futures = list(self._waiting_for_cpr_futures)  # Make copy.</span>
<span class="gi">+</span>
<span class="gi">+        # When there are no CPRs in the queue. Don&#39;t do anything.</span>
<span class="gi">+        if not cpr_futures or self.cpr_support == CPR_Support.NOT_SUPPORTED:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        async def wait_for_responses() -&gt; None:</span>
<span class="gi">+            for response_f in cpr_futures:</span>
<span class="gi">+                await response_f</span>
<span class="gi">+</span>
<span class="gi">+        async def wait_for_timeout() -&gt; None:</span>
<span class="gi">+            await sleep(timeout)</span>
<span class="gi">+</span>
<span class="gi">+            # Got timeout, erase queue.</span>
<span class="gi">+            for response_f in cpr_futures:</span>
<span class="gi">+                response_f.cancel()</span>
<span class="gi">+            self._waiting_for_cpr_futures = deque()</span>
<span class="gi">+</span>
<span class="gi">+        tasks = {</span>
<span class="gi">+            ensure_future(wait_for_responses()),</span>
<span class="gi">+            ensure_future(wait_for_timeout()),</span>
<span class="gi">+        }</span>
<span class="gi">+        _, pending = await wait(tasks, return_when=FIRST_COMPLETED)</span>
<span class="gi">+        for task in pending:</span>
<span class="gi">+            task.cancel()</span>
<span class="gi">+</span>
<span class="gi">+    def render(</span>
<span class="gi">+        self, app: Application[Any], layout: Layout, is_done: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Render the current interface to the output.

<span class="w"> </span>        :param is_done: When True, put the cursor at the end of the interface. We
<span class="w"> </span>                won&#39;t print any changes to this part.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def erase(self, leave_alternate_screen: bool=True) -&gt;None:</span>
<span class="gi">+        output = self.output</span>
<span class="gi">+</span>
<span class="gi">+        # Enter alternate screen.</span>
<span class="gi">+        if self.full_screen and not self._in_alternate_screen:</span>
<span class="gi">+            self._in_alternate_screen = True</span>
<span class="gi">+            output.enter_alternate_screen()</span>
<span class="gi">+</span>
<span class="gi">+        # Enable bracketed paste.</span>
<span class="gi">+        if not self._bracketed_paste_enabled:</span>
<span class="gi">+            self.output.enable_bracketed_paste()</span>
<span class="gi">+            self._bracketed_paste_enabled = True</span>
<span class="gi">+</span>
<span class="gi">+        # Reset cursor key mode.</span>
<span class="gi">+        if not self._cursor_key_mode_reset:</span>
<span class="gi">+            self.output.reset_cursor_key_mode()</span>
<span class="gi">+            self._cursor_key_mode_reset = True</span>
<span class="gi">+</span>
<span class="gi">+        # Enable/disable mouse support.</span>
<span class="gi">+        needs_mouse_support = self.mouse_support()</span>
<span class="gi">+</span>
<span class="gi">+        if needs_mouse_support and not self._mouse_support_enabled:</span>
<span class="gi">+            output.enable_mouse_support()</span>
<span class="gi">+            self._mouse_support_enabled = True</span>
<span class="gi">+</span>
<span class="gi">+        elif not needs_mouse_support and self._mouse_support_enabled:</span>
<span class="gi">+            output.disable_mouse_support()</span>
<span class="gi">+            self._mouse_support_enabled = False</span>
<span class="gi">+</span>
<span class="gi">+        # Create screen and write layout to it.</span>
<span class="gi">+        size = output.get_size()</span>
<span class="gi">+        screen = Screen()</span>
<span class="gi">+        screen.show_cursor = False  # Hide cursor by default, unless one of the</span>
<span class="gi">+        # containers decides to display it.</span>
<span class="gi">+        mouse_handlers = MouseHandlers()</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate height.</span>
<span class="gi">+        if self.full_screen:</span>
<span class="gi">+            height = size.rows</span>
<span class="gi">+        elif is_done:</span>
<span class="gi">+            # When we are done, we don&#39;t necessary want to fill up until the bottom.</span>
<span class="gi">+            height = layout.container.preferred_height(</span>
<span class="gi">+                size.columns, size.rows</span>
<span class="gi">+            ).preferred</span>
<span class="gi">+        else:</span>
<span class="gi">+            last_height = self._last_screen.height if self._last_screen else 0</span>
<span class="gi">+            height = max(</span>
<span class="gi">+                self._min_available_height,</span>
<span class="gi">+                last_height,</span>
<span class="gi">+                layout.container.preferred_height(size.columns, size.rows).preferred,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        height = min(height, size.rows)</span>
<span class="gi">+</span>
<span class="gi">+        # When the size changes, don&#39;t consider the previous screen.</span>
<span class="gi">+        if self._last_size != size:</span>
<span class="gi">+            self._last_screen = None</span>
<span class="gi">+</span>
<span class="gi">+        # When we render using another style or another color depth, do a full</span>
<span class="gi">+        # repaint. (Forget about the previous rendered screen.)</span>
<span class="gi">+        # (But note that we still use _last_screen to calculate the height.)</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.style.invalidation_hash() != self._last_style_hash</span>
<span class="gi">+            or app.style_transformation.invalidation_hash()</span>
<span class="gi">+            != self._last_transformation_hash</span>
<span class="gi">+            or app.color_depth != self._last_color_depth</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._last_screen = None</span>
<span class="gi">+            self._attrs_for_style = None</span>
<span class="gi">+            self._style_string_has_style = None</span>
<span class="gi">+</span>
<span class="gi">+        if self._attrs_for_style is None:</span>
<span class="gi">+            self._attrs_for_style = _StyleStringToAttrsCache(</span>
<span class="gi">+                self.style.get_attrs_for_style_str, app.style_transformation</span>
<span class="gi">+            )</span>
<span class="gi">+        if self._style_string_has_style is None:</span>
<span class="gi">+            self._style_string_has_style = _StyleStringHasStyleCache(</span>
<span class="gi">+                self._attrs_for_style</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self._last_style_hash = self.style.invalidation_hash()</span>
<span class="gi">+        self._last_transformation_hash = app.style_transformation.invalidation_hash()</span>
<span class="gi">+        self._last_color_depth = app.color_depth</span>
<span class="gi">+</span>
<span class="gi">+        layout.container.write_to_screen(</span>
<span class="gi">+            screen,</span>
<span class="gi">+            mouse_handlers,</span>
<span class="gi">+            WritePosition(xpos=0, ypos=0, width=size.columns, height=height),</span>
<span class="gi">+            parent_style=&quot;&quot;,</span>
<span class="gi">+            erase_bg=False,</span>
<span class="gi">+            z_index=None,</span>
<span class="gi">+        )</span>
<span class="gi">+        screen.draw_all_floats()</span>
<span class="gi">+</span>
<span class="gi">+        # When grayed. Replace all styles in the new screen.</span>
<span class="gi">+        if app.exit_style:</span>
<span class="gi">+            screen.append_style_to_content(app.exit_style)</span>
<span class="gi">+</span>
<span class="gi">+        # Process diff and write to output.</span>
<span class="gi">+        self._cursor_pos, self._last_style = _output_screen_diff(</span>
<span class="gi">+            app,</span>
<span class="gi">+            output,</span>
<span class="gi">+            screen,</span>
<span class="gi">+            self._cursor_pos,</span>
<span class="gi">+            app.color_depth,</span>
<span class="gi">+            self._last_screen,</span>
<span class="gi">+            self._last_style,</span>
<span class="gi">+            is_done,</span>
<span class="gi">+            full_screen=self.full_screen,</span>
<span class="gi">+            attrs_for_style_string=self._attrs_for_style,</span>
<span class="gi">+            style_string_has_style=self._style_string_has_style,</span>
<span class="gi">+            size=size,</span>
<span class="gi">+            previous_width=(self._last_size.columns if self._last_size else 0),</span>
<span class="gi">+        )</span>
<span class="gi">+        self._last_screen = screen</span>
<span class="gi">+        self._last_size = size</span>
<span class="gi">+        self.mouse_handlers = mouse_handlers</span>
<span class="gi">+</span>
<span class="gi">+        # Handle cursor shapes.</span>
<span class="gi">+        new_cursor_shape = app.cursor.get_cursor_shape(app)</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._last_cursor_shape is None</span>
<span class="gi">+            or self._last_cursor_shape != new_cursor_shape</span>
<span class="gi">+        ):</span>
<span class="gi">+            output.set_cursor_shape(new_cursor_shape)</span>
<span class="gi">+            self._last_cursor_shape = new_cursor_shape</span>
<span class="gi">+</span>
<span class="gi">+        # Flush buffered output.</span>
<span class="gi">+        output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Set visible windows in layout.</span>
<span class="gi">+        app.layout.visible_windows = screen.visible_windows</span>
<span class="gi">+</span>
<span class="gi">+        if is_done:</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+</span>
<span class="gi">+    def erase(self, leave_alternate_screen: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Hide all output and put the cursor back at the first line. This is for
<span class="w"> </span>        instance used for running a system command (while hiding the CLI) and
<span class="gu">@@ -213,19 +733,81 @@ class Renderer:</span>
<span class="w"> </span>        :param leave_alternate_screen: When True, and when inside an alternate
<span class="w"> </span>            screen buffer, quit the alternate screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        output = self.output</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+        output.cursor_backward(self._cursor_pos.x)</span>
<span class="gi">+        output.cursor_up(self._cursor_pos.y)</span>
<span class="gi">+        output.erase_down()</span>
<span class="gi">+        output.reset_attributes()</span>
<span class="gi">+        output.enable_autowrap()</span>
<span class="gi">+</span>
<span class="gi">+        output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        self.reset(leave_alternate_screen=leave_alternate_screen)</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clear screen and go to 0,0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Erase current output first.</span>
<span class="gi">+        self.erase()</span>
<span class="gi">+</span>
<span class="gi">+        # Send &quot;Erase Screen&quot; command and go to (0, 0).</span>
<span class="gi">+        output = self.output</span>
<span class="gi">+</span>
<span class="gi">+        output.erase_screen()</span>
<span class="gi">+        output.cursor_goto(0, 0)</span>
<span class="gi">+        output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        self.request_absolute_cursor_position()</span>


<span class="gd">-def print_formatted_text(output: Output, formatted_text: AnyFormattedText,</span>
<span class="gd">-    style: BaseStyle, style_transformation: (StyleTransformation | None)=</span>
<span class="gd">-    None, color_depth: (ColorDepth | None)=None) -&gt;None:</span>
<span class="gi">+def print_formatted_text(</span>
<span class="gi">+    output: Output,</span>
<span class="gi">+    formatted_text: AnyFormattedText,</span>
<span class="gi">+    style: BaseStyle,</span>
<span class="gi">+    style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+    color_depth: ColorDepth | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Print a list of (style_str, text) tuples in the given style to the output.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fragments = to_formatted_text(formatted_text)</span>
<span class="gi">+    style_transformation = style_transformation or DummyStyleTransformation()</span>
<span class="gi">+    color_depth = color_depth or output.get_default_color_depth()</span>
<span class="gi">+</span>
<span class="gi">+    # Reset first.</span>
<span class="gi">+    output.reset_attributes()</span>
<span class="gi">+    output.enable_autowrap()</span>
<span class="gi">+    last_attrs: Attrs | None = None</span>
<span class="gi">+</span>
<span class="gi">+    # Print all (style_str, text) tuples.</span>
<span class="gi">+    attrs_for_style_string = _StyleStringToAttrsCache(</span>
<span class="gi">+        style.get_attrs_for_style_str, style_transformation</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    for style_str, text, *_ in fragments:</span>
<span class="gi">+        attrs = attrs_for_style_string[style_str]</span>
<span class="gi">+</span>
<span class="gi">+        # Set style attributes if something changed.</span>
<span class="gi">+        if attrs != last_attrs:</span>
<span class="gi">+            if attrs:</span>
<span class="gi">+                output.set_attributes(attrs, color_depth)</span>
<span class="gi">+            else:</span>
<span class="gi">+                output.reset_attributes()</span>
<span class="gi">+        last_attrs = attrs</span>
<span class="gi">+</span>
<span class="gi">+        # Print escape sequences as raw output</span>
<span class="gi">+        if &quot;[ZeroWidthEscape]&quot; in style_str:</span>
<span class="gi">+            output.write_raw(text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Eliminate carriage returns</span>
<span class="gi">+            text = text.replace(&quot;\r&quot;, &quot;&quot;)</span>
<span class="gi">+            # Insert a carriage return before every newline (important when the</span>
<span class="gi">+            # front-end is a telnet client).</span>
<span class="gi">+            text = text.replace(&quot;\n&quot;, &quot;\r\n&quot;)</span>
<span class="gi">+            output.write(text)</span>
<span class="gi">+</span>
<span class="gi">+    # Reset again.</span>
<span class="gi">+    output.reset_attributes()</span>
<span class="gi">+    output.flush()</span>
<span class="gh">diff --git a/src/prompt_toolkit/search.py b/src/prompt_toolkit/search.py</span>
<span class="gh">index 60c9f64a..fd90a04e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/search.py</span>
<span class="gi">+++ b/src/prompt_toolkit/search.py</span>
<span class="gu">@@ -6,20 +6,28 @@ For the key bindings implementation with attached filters, check</span>
<span class="w"> </span>instead of calling these function directly.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from .application.current import get_app
<span class="w"> </span>from .filters import FilterOrBool, is_searching, to_filter
<span class="w"> </span>from .key_binding.vi_state import InputMode
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.layout.controls import BufferControl, SearchBufferControl
<span class="w"> </span>    from prompt_toolkit.layout.layout import Layout
<span class="gd">-__all__ = [&#39;SearchDirection&#39;, &#39;start_search&#39;, &#39;stop_search&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;SearchDirection&quot;,</span>
<span class="gi">+    &quot;start_search&quot;,</span>
<span class="gi">+    &quot;stop_search&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class SearchDirection(Enum):
<span class="gd">-    FORWARD = &#39;FORWARD&#39;</span>
<span class="gd">-    BACKWARD = &#39;BACKWARD&#39;</span>
<span class="gi">+    FORWARD = &quot;FORWARD&quot;</span>
<span class="gi">+    BACKWARD = &quot;BACKWARD&quot;</span>


<span class="w"> </span>class SearchState:
<span class="gu">@@ -37,19 +45,28 @@ class SearchState:</span>
<span class="w"> </span>    they can have a different `SearchState` each (if they have a different
<span class="w"> </span>    search control).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;text&#39;, &#39;direction&#39;, &#39;ignore_case&#39;</span>

<span class="gd">-    def __init__(self, text: str=&#39;&#39;, direction: SearchDirection=</span>
<span class="gd">-        SearchDirection.FORWARD, ignore_case: FilterOrBool=False) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;text&quot;, &quot;direction&quot;, &quot;ignore_case&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: str = &quot;&quot;,</span>
<span class="gi">+        direction: SearchDirection = SearchDirection.FORWARD,</span>
<span class="gi">+        ignore_case: FilterOrBool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.direction = direction
<span class="w"> </span>        self.ignore_case = to_filter(ignore_case)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}({!r}, direction={!r}, ignore_case={!r})&#39;.format(self.</span>
<span class="gd">-            __class__.__name__, self.text, self.direction, self.ignore_case)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}({!r}, direction={!r}, ignore_case={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.text,</span>
<span class="gi">+            self.direction,</span>
<span class="gi">+            self.ignore_case,</span>
<span class="gi">+        )</span>

<span class="gd">-    def __invert__(self) -&gt;SearchState:</span>
<span class="gi">+    def __invert__(self) -&gt; SearchState:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new SearchState where backwards becomes forwards and the other
<span class="w"> </span>        way around.
<span class="gu">@@ -58,12 +75,16 @@ class SearchState:</span>
<span class="w"> </span>            direction = SearchDirection.FORWARD
<span class="w"> </span>        else:
<span class="w"> </span>            direction = SearchDirection.BACKWARD
<span class="gd">-        return SearchState(text=self.text, direction=direction, ignore_case</span>
<span class="gd">-            =self.ignore_case)</span>

<span class="gi">+        return SearchState(</span>
<span class="gi">+            text=self.text, direction=direction, ignore_case=self.ignore_case</span>
<span class="gi">+        )</span>

<span class="gd">-def start_search(buffer_control: (BufferControl | None)=None, direction:</span>
<span class="gd">-    SearchDirection=SearchDirection.FORWARD) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def start_search(</span>
<span class="gi">+    buffer_control: BufferControl | None = None,</span>
<span class="gi">+    direction: SearchDirection = SearchDirection.FORWARD,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Start search through the given `buffer_control` using the
<span class="w"> </span>    `search_buffer_control`.
<span class="gu">@@ -71,33 +92,139 @@ def start_search(buffer_control: (BufferControl | None)=None, direction:</span>
<span class="w"> </span>    :param buffer_control: Start search for this `BufferControl`. If not given,
<span class="w"> </span>        search through the current control.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+</span>
<span class="gi">+    assert buffer_control is None or isinstance(buffer_control, BufferControl)</span>
<span class="gi">+</span>
<span class="gi">+    layout = get_app().layout</span>
<span class="gi">+</span>
<span class="gi">+    # When no control is given, use the current control if that&#39;s a BufferControl.</span>
<span class="gi">+    if buffer_control is None:</span>
<span class="gi">+        if not isinstance(layout.current_control, BufferControl):</span>
<span class="gi">+            return</span>
<span class="gi">+        buffer_control = layout.current_control</span>

<span class="gi">+    # Only if this control is searchable.</span>
<span class="gi">+    search_buffer_control = buffer_control.search_buffer_control</span>

<span class="gd">-def stop_search(buffer_control: (BufferControl | None)=None) -&gt;None:</span>
<span class="gi">+    if search_buffer_control:</span>
<span class="gi">+        buffer_control.search_state.direction = direction</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure to focus the search BufferControl</span>
<span class="gi">+        layout.focus(search_buffer_control)</span>
<span class="gi">+</span>
<span class="gi">+        # Remember search link.</span>
<span class="gi">+        layout.search_links[search_buffer_control] = buffer_control</span>
<span class="gi">+</span>
<span class="gi">+        # If we&#39;re in Vi mode, make sure to go into insert mode.</span>
<span class="gi">+        get_app().vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def stop_search(buffer_control: BufferControl | None = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Stop search through the given `buffer_control`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    layout = get_app().layout</span>
<span class="gi">+</span>
<span class="gi">+    if buffer_control is None:</span>
<span class="gi">+        buffer_control = layout.search_target_buffer_control</span>
<span class="gi">+        if buffer_control is None:</span>
<span class="gi">+            # (Should not happen, but possible when `stop_search` is called</span>
<span class="gi">+            # when we&#39;re not searching.)</span>
<span class="gi">+            return</span>
<span class="gi">+        search_buffer_control = buffer_control.search_buffer_control</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert buffer_control in layout.search_links.values()</span>
<span class="gi">+        search_buffer_control = _get_reverse_search_links(layout)[buffer_control]</span>
<span class="gi">+</span>
<span class="gi">+    # Focus the original buffer again.</span>
<span class="gi">+    layout.focus(buffer_control)</span>
<span class="gi">+</span>
<span class="gi">+    if search_buffer_control is not None:</span>
<span class="gi">+        # Remove the search link.</span>
<span class="gi">+        del layout.search_links[search_buffer_control]</span>

<span class="gi">+        # Reset content of search control.</span>
<span class="gi">+        search_buffer_control.buffer.reset()</span>

<span class="gd">-def do_incremental_search(direction: SearchDirection, count: int=1) -&gt;None:</span>
<span class="gi">+    # If we&#39;re in Vi mode, go back to navigation mode.</span>
<span class="gi">+    get_app().vi_state.input_mode = InputMode.NAVIGATION</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_incremental_search(direction: SearchDirection, count: int = 1) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply search, but keep search buffer focused.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert is_searching()</span>
<span class="gi">+</span>
<span class="gi">+    layout = get_app().layout</span>
<span class="gi">+</span>
<span class="gi">+    # Only search if the current control is a `BufferControl`.</span>
<span class="gi">+    from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+</span>
<span class="gi">+    search_control = layout.current_control</span>
<span class="gi">+    if not isinstance(search_control, BufferControl):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    prev_control = layout.search_target_buffer_control</span>
<span class="gi">+    if prev_control is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    search_state = prev_control.search_state</span>
<span class="gi">+</span>
<span class="gi">+    # Update search_state.</span>
<span class="gi">+    direction_changed = search_state.direction != direction</span>
<span class="gi">+</span>
<span class="gi">+    search_state.text = search_control.buffer.text</span>
<span class="gi">+    search_state.direction = direction</span>
<span class="gi">+</span>
<span class="gi">+    # Apply search to current buffer.</span>
<span class="gi">+    if not direction_changed:</span>
<span class="gi">+        prev_control.buffer.apply_search(</span>
<span class="gi">+            search_state, include_current_position=False, count=count</span>
<span class="gi">+        )</span>


<span class="gd">-def accept_search() -&gt;None:</span>
<span class="gi">+def accept_search() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept current search query. Focus original `BufferControl` again.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    layout = get_app().layout</span>
<span class="gi">+</span>
<span class="gi">+    search_control = layout.current_control</span>
<span class="gi">+    target_buffer_control = layout.search_target_buffer_control</span>
<span class="gi">+</span>
<span class="gi">+    from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(search_control, BufferControl):</span>
<span class="gi">+        return</span>
<span class="gi">+    if target_buffer_control is None:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    search_state = target_buffer_control.search_state</span>
<span class="gi">+</span>
<span class="gi">+    # Update search state.</span>
<span class="gi">+    if search_control.buffer.text:</span>
<span class="gi">+        search_state.text = search_control.buffer.text</span>
<span class="gi">+</span>
<span class="gi">+    # Apply search.</span>
<span class="gi">+    target_buffer_control.buffer.apply_search(</span>
<span class="gi">+        search_state, include_current_position=True</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Add query to history of search line.</span>
<span class="gi">+    search_control.buffer.append_to_history()</span>
<span class="gi">+</span>
<span class="gi">+    # Stop search and focus previous control again.</span>
<span class="gi">+    stop_search(target_buffer_control)</span>


<span class="gd">-def _get_reverse_search_links(layout: Layout) -&gt;dict[BufferControl,</span>
<span class="gd">-    SearchBufferControl]:</span>
<span class="gi">+def _get_reverse_search_links(</span>
<span class="gi">+    layout: Layout,</span>
<span class="gi">+) -&gt; dict[BufferControl, SearchBufferControl]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return mapping from BufferControl to SearchBufferControl.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {</span>
<span class="gi">+        buffer_control: search_buffer_control</span>
<span class="gi">+        for search_buffer_control, buffer_control in layout.search_links.items()</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/src/prompt_toolkit/selection.py b/src/prompt_toolkit/selection.py</span>
<span class="gh">index 3beccb22..2158fa92 100644</span>
<span class="gd">--- a/src/prompt_toolkit/selection.py</span>
<span class="gi">+++ b/src/prompt_toolkit/selection.py</span>
<span class="gu">@@ -2,23 +2,35 @@</span>
<span class="w"> </span>Data structures for the selection.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from enum import Enum
<span class="gd">-__all__ = [&#39;SelectionType&#39;, &#39;PasteMode&#39;, &#39;SelectionState&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;SelectionType&quot;,</span>
<span class="gi">+    &quot;PasteMode&quot;,</span>
<span class="gi">+    &quot;SelectionState&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class SelectionType(Enum):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Type of selection.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    CHARACTERS = &#39;CHARACTERS&#39;</span>
<span class="gd">-    LINES = &#39;LINES&#39;</span>
<span class="gd">-    BLOCK = &#39;BLOCK&#39;</span>
<span class="gi">+</span>
<span class="gi">+    #: Characters. (Visual in Vi.)</span>
<span class="gi">+    CHARACTERS = &quot;CHARACTERS&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: Whole lines. (Visual-Line in Vi.)</span>
<span class="gi">+    LINES = &quot;LINES&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: A block selection. (Visual-Block in Vi.)</span>
<span class="gi">+    BLOCK = &quot;BLOCK&quot;</span>


<span class="w"> </span>class PasteMode(Enum):
<span class="gd">-    EMACS = &#39;EMACS&#39;</span>
<span class="gd">-    VI_AFTER = &#39;VI_AFTER&#39;</span>
<span class="gd">-    VI_BEFORE = &#39;VI_BEFORE&#39;</span>
<span class="gi">+    EMACS = &quot;EMACS&quot;  # Yank like emacs.</span>
<span class="gi">+    VI_AFTER = &quot;VI_AFTER&quot;  # When pressing &#39;p&#39; in Vi.</span>
<span class="gi">+    VI_BEFORE = &quot;VI_BEFORE&quot;  # When pressing &#39;P&#39; in Vi.</span>


<span class="w"> </span>class SelectionState:
<span class="gu">@@ -29,12 +41,21 @@ class SelectionState:</span>
<span class="w"> </span>    :param type: :class:`~.SelectionType`
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, original_cursor_position: int=0, type: SelectionType</span>
<span class="gd">-        =SelectionType.CHARACTERS) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        original_cursor_position: int = 0,</span>
<span class="gi">+        type: SelectionType = SelectionType.CHARACTERS,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.original_cursor_position = original_cursor_position
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.shift_mode = False

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(original_cursor_position={!r}, type={!r})&#39;.format(self.</span>
<span class="gd">-            __class__.__name__, self.original_cursor_position, self.type)</span>
<span class="gi">+    def enter_shift_mode(self) -&gt; None:</span>
<span class="gi">+        self.shift_mode = True</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(original_cursor_position={!r}, type={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.original_cursor_position,</span>
<span class="gi">+            self.type,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/dialogs.py b/src/prompt_toolkit/shortcuts/dialogs.py</span>
<span class="gh">index 1ae0d91d..d78e7dbd 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/dialogs.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/dialogs.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from typing import Any, Callable, Sequence, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application import Application
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.buffer import Buffer
<span class="gu">@@ -17,90 +19,312 @@ from prompt_toolkit.layout.containers import AnyContainer, HSplit</span>
<span class="w"> </span>from prompt_toolkit.layout.dimension import Dimension as D
<span class="w"> </span>from prompt_toolkit.styles import BaseStyle
<span class="w"> </span>from prompt_toolkit.validation import Validator
<span class="gd">-from prompt_toolkit.widgets import Box, Button, CheckboxList, Dialog, Label, ProgressBar, RadioList, TextArea, ValidationToolbar</span>
<span class="gd">-__all__ = [&#39;yes_no_dialog&#39;, &#39;button_dialog&#39;, &#39;input_dialog&#39;,</span>
<span class="gd">-    &#39;message_dialog&#39;, &#39;radiolist_dialog&#39;, &#39;checkboxlist_dialog&#39;,</span>
<span class="gd">-    &#39;progress_dialog&#39;]</span>
<span class="gi">+from prompt_toolkit.widgets import (</span>
<span class="gi">+    Box,</span>
<span class="gi">+    Button,</span>
<span class="gi">+    CheckboxList,</span>
<span class="gi">+    Dialog,</span>
<span class="gi">+    Label,</span>
<span class="gi">+    ProgressBar,</span>
<span class="gi">+    RadioList,</span>
<span class="gi">+    TextArea,</span>
<span class="gi">+    ValidationToolbar,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;yes_no_dialog&quot;,</span>
<span class="gi">+    &quot;button_dialog&quot;,</span>
<span class="gi">+    &quot;input_dialog&quot;,</span>
<span class="gi">+    &quot;message_dialog&quot;,</span>
<span class="gi">+    &quot;radiolist_dialog&quot;,</span>
<span class="gi">+    &quot;checkboxlist_dialog&quot;,</span>
<span class="gi">+    &quot;progress_dialog&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def yes_no_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-    yes_text: str=&#39;Yes&#39;, no_text: str=&#39;No&#39;, style: (BaseStyle | None)=None</span>
<span class="gd">-    ) -&gt;Application[bool]:</span>
<span class="gi">+def yes_no_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    yes_text: str = &quot;Yes&quot;,</span>
<span class="gi">+    no_text: str = &quot;No&quot;,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+) -&gt; Application[bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a Yes/No dialog.
<span class="w"> </span>    Return a boolean.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def yes_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=True)</span>
<span class="gi">+</span>
<span class="gi">+    def no_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=False)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=Label(text=text, dont_extend_height=True),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=yes_text, handler=yes_handler),</span>
<span class="gi">+            Button(text=no_text, handler=no_handler),</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>

<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+    return _create_app(dialog, style)</span>


<span class="gd">-def button_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-    buttons: list[tuple[str, _T]]=[], style: (BaseStyle | None)=None</span>
<span class="gd">-    ) -&gt;Application[_T]:</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def button_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    buttons: list[tuple[str, _T]] = [],</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+) -&gt; Application[_T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a dialog with button choices (given as a list of tuples).
<span class="w"> </span>    Return the value associated with button.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def button_handler(v: _T) -&gt; None:</span>
<span class="gi">+        get_app().exit(result=v)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=Label(text=text, dont_extend_height=True),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=t, handler=functools.partial(button_handler, v))</span>
<span class="gi">+            for t, v in buttons</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return _create_app(dialog, style)</span>

<span class="gd">-def input_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-    ok_text: str=&#39;OK&#39;, cancel_text: str=&#39;Cancel&#39;, completer: (Completer |</span>
<span class="gd">-    None)=None, validator: (Validator | None)=None, password: FilterOrBool=</span>
<span class="gd">-    False, style: (BaseStyle | None)=None, default: str=&#39;&#39;) -&gt;Application[str]:</span>
<span class="gi">+</span>
<span class="gi">+def input_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    ok_text: str = &quot;OK&quot;,</span>
<span class="gi">+    cancel_text: str = &quot;Cancel&quot;,</span>
<span class="gi">+    completer: Completer | None = None,</span>
<span class="gi">+    validator: Validator | None = None,</span>
<span class="gi">+    password: FilterOrBool = False,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+    default: str = &quot;&quot;,</span>
<span class="gi">+) -&gt; Application[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a text input box.
<span class="w"> </span>    Return the given text, or None when cancelled.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def accept(buf: Buffer) -&gt; bool:</span>
<span class="gi">+        get_app().layout.focus(ok_button)</span>
<span class="gi">+        return True  # Keep text.</span>
<span class="gi">+</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=textfield.text)</span>
<span class="gi">+</span>
<span class="gi">+    ok_button = Button(text=ok_text, handler=ok_handler)</span>
<span class="gi">+    cancel_button = Button(text=cancel_text, handler=_return_none)</span>
<span class="gi">+</span>
<span class="gi">+    textfield = TextArea(</span>
<span class="gi">+        text=default,</span>
<span class="gi">+        multiline=False,</span>
<span class="gi">+        password=password,</span>
<span class="gi">+        completer=completer,</span>
<span class="gi">+        validator=validator,</span>
<span class="gi">+        accept_handler=accept,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                Label(text=text, dont_extend_height=True),</span>
<span class="gi">+                textfield,</span>
<span class="gi">+                ValidationToolbar(),</span>
<span class="gi">+            ],</span>
<span class="gi">+            padding=D(preferred=1, max=1),</span>
<span class="gi">+        ),</span>
<span class="gi">+        buttons=[ok_button, cancel_button],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>

<span class="gd">-def message_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-    ok_text: str=&#39;Ok&#39;, style: (BaseStyle | None)=None) -&gt;Application[None]:</span>
<span class="gi">+    return _create_app(dialog, style)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def message_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    ok_text: str = &quot;Ok&quot;,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+) -&gt; Application[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a simple message box and wait until the user presses enter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=Label(text=text, dont_extend_height=True),</span>
<span class="gi">+        buttons=[Button(text=ok_text, handler=_return_none)],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>

<span class="gi">+    return _create_app(dialog, style)</span>

<span class="gd">-def radiolist_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-    ok_text: str=&#39;Ok&#39;, cancel_text: str=&#39;Cancel&#39;, values: (Sequence[tuple[</span>
<span class="gd">-    _T, AnyFormattedText]] | None)=None, default: (_T | None)=None, style:</span>
<span class="gd">-    (BaseStyle | None)=None) -&gt;Application[_T]:</span>
<span class="gi">+</span>
<span class="gi">+def radiolist_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    ok_text: str = &quot;Ok&quot;,</span>
<span class="gi">+    cancel_text: str = &quot;Cancel&quot;,</span>
<span class="gi">+    values: Sequence[tuple[_T, AnyFormattedText]] | None = None,</span>
<span class="gi">+    default: _T | None = None,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+) -&gt; Application[_T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a simple list of element the user can choose amongst.

<span class="w"> </span>    Only one element can be selected at a time using Arrow keys and Enter.
<span class="w"> </span>    The focus can be moved between the list and the Ok/Cancel button with tab.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if values is None:</span>
<span class="gi">+        values = []</span>
<span class="gi">+</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=radio_list.current_value)</span>

<span class="gi">+    radio_list = RadioList(values=values, default=default)</span>

<span class="gd">-def checkboxlist_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=</span>
<span class="gd">-    &#39;&#39;, ok_text: str=&#39;Ok&#39;, cancel_text: str=&#39;Cancel&#39;, values: (Sequence[</span>
<span class="gd">-    tuple[_T, AnyFormattedText]] | None)=None, default_values: (Sequence[_T</span>
<span class="gd">-    ] | None)=None, style: (BaseStyle | None)=None) -&gt;Application[list[_T]]:</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit(</span>
<span class="gi">+            [Label(text=text, dont_extend_height=True), radio_list],</span>
<span class="gi">+            padding=1,</span>
<span class="gi">+        ),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=ok_text, handler=ok_handler),</span>
<span class="gi">+            Button(text=cancel_text, handler=_return_none),</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return _create_app(dialog, style)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def checkboxlist_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    ok_text: str = &quot;Ok&quot;,</span>
<span class="gi">+    cancel_text: str = &quot;Cancel&quot;,</span>
<span class="gi">+    values: Sequence[tuple[_T, AnyFormattedText]] | None = None,</span>
<span class="gi">+    default_values: Sequence[_T] | None = None,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+) -&gt; Application[list[_T]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a simple list of element the user can choose multiple values amongst.

<span class="w"> </span>    Several elements can be selected at a time using Arrow keys and Enter.
<span class="w"> </span>    The focus can be moved between the list and the Ok/Cancel button with tab.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if values is None:</span>
<span class="gi">+        values = []</span>
<span class="gi">+</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=cb_list.current_values)</span>
<span class="gi">+</span>
<span class="gi">+    cb_list = CheckboxList(values=values, default_values=default_values)</span>

<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit(</span>
<span class="gi">+            [Label(text=text, dont_extend_height=True), cb_list],</span>
<span class="gi">+            padding=1,</span>
<span class="gi">+        ),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=ok_text, handler=ok_handler),</span>
<span class="gi">+            Button(text=cancel_text, handler=_return_none),</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>

<span class="gd">-def progress_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-    run_callback: Callable[[Callable[[int], None], Callable[[str], None]],</span>
<span class="gd">-    None]=lambda *a: None, style: (BaseStyle | None)=None) -&gt;Application[None]:</span>
<span class="gi">+    return _create_app(dialog, style)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def progress_dialog(</span>
<span class="gi">+    title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    text: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+    run_callback: Callable[[Callable[[int], None], Callable[[str], None]], None] = (</span>
<span class="gi">+        lambda *a: None</span>
<span class="gi">+    ),</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+) -&gt; Application[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :param run_callback: A function that receives as input a `set_percentage`
<span class="w"> </span>        function and it does the work.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+    progressbar = ProgressBar()</span>
<span class="gi">+    text_area = TextArea(</span>
<span class="gi">+        focusable=False,</span>
<span class="gi">+        # Prefer this text area as big as possible, to avoid having a window</span>
<span class="gi">+        # that keeps resizing when we add text to it.</span>
<span class="gi">+        height=D(preferred=10**10),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        body=HSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                Box(Label(text=text)),</span>
<span class="gi">+                Box(text_area, padding=D.exact(1)),</span>
<span class="gi">+                progressbar,</span>
<span class="gi">+            ]</span>
<span class="gi">+        ),</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+    app = _create_app(dialog, style)</span>
<span class="gi">+</span>
<span class="gi">+    def set_percentage(value: int) -&gt; None:</span>
<span class="gi">+        progressbar.percentage = int(value)</span>
<span class="gi">+        app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+    def log_text(text: str) -&gt; None:</span>
<span class="gi">+        loop.call_soon_threadsafe(text_area.buffer.insert_text, text)</span>
<span class="gi">+        app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+    # Run the callback in the executor. When done, set a return value for the</span>
<span class="gi">+    # UI, so that it quits.</span>
<span class="gi">+    def start() -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            run_callback(set_percentage, log_text)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            app.exit()</span>
<span class="gi">+</span>
<span class="gi">+    def pre_run() -&gt; None:</span>
<span class="gi">+        run_in_executor_with_context(start)</span>
<span class="gi">+</span>
<span class="gi">+    app.pre_run_callables.append(pre_run)</span>
<span class="gi">+</span>
<span class="gi">+    return app</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_app(dialog: AnyContainer, style: BaseStyle | None) -&gt; Application[Any]:</span>
<span class="gi">+    # Key bindings.</span>
<span class="gi">+    bindings = KeyBindings()</span>
<span class="gi">+    bindings.add(&quot;tab&quot;)(focus_next)</span>
<span class="gi">+    bindings.add(&quot;s-tab&quot;)(focus_previous)</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([load_key_bindings(), bindings]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="gd">-def _return_none() -&gt;None:</span>
<span class="gd">-    &quot;&quot;&quot;Button handler that returns None.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def _return_none() -&gt; None:</span>
<span class="gi">+    &quot;Button handler that returns None.&quot;</span>
<span class="gi">+    get_app().exit()</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/progress_bar/base.py b/src/prompt_toolkit/shortcuts/progress_bar/base.py</span>
<span class="gh">index 3cc8cbce..21aa1bec 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/progress_bar/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/progress_bar/base.py</span>
<span class="gu">@@ -8,6 +8,7 @@ Progress bar implementation on top of prompt_toolkit.</span>
<span class="w"> </span>            ...
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextvars
<span class="w"> </span>import datetime
<span class="w"> </span>import functools
<span class="gu">@@ -15,36 +16,75 @@ import os</span>
<span class="w"> </span>import signal
<span class="w"> </span>import threading
<span class="w"> </span>import traceback
<span class="gd">-from typing import Callable, Generic, Iterable, Iterator, Sequence, Sized, TextIO, TypeVar, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Sized,</span>
<span class="gi">+    TextIO,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application import Application
<span class="w"> </span>from prompt_toolkit.application.current import get_app_session
<span class="w"> </span>from prompt_toolkit.filters import Condition, is_done, renderer_height_is_known
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.input import Input
<span class="w"> </span>from prompt_toolkit.key_binding import KeyBindings
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="gd">-from prompt_toolkit.layout import ConditionalContainer, FormattedTextControl, HSplit, Layout, VSplit, Window</span>
<span class="gi">+from prompt_toolkit.layout import (</span>
<span class="gi">+    ConditionalContainer,</span>
<span class="gi">+    FormattedTextControl,</span>
<span class="gi">+    HSplit,</span>
<span class="gi">+    Layout,</span>
<span class="gi">+    VSplit,</span>
<span class="gi">+    Window,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.controls import UIContent, UIControl
<span class="w"> </span>from prompt_toolkit.layout.dimension import AnyDimension, D
<span class="w"> </span>from prompt_toolkit.output import ColorDepth, Output
<span class="w"> </span>from prompt_toolkit.styles import BaseStyle
<span class="w"> </span>from prompt_toolkit.utils import in_main_thread
<span class="gi">+</span>
<span class="w"> </span>from .formatters import Formatter, create_default_formatters
<span class="gd">-__all__ = [&#39;ProgressBar&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;ProgressBar&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent
<span class="gd">-_SIGWINCH = getattr(signal, &#39;SIGWINCH&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+_SIGWINCH = getattr(signal, &quot;SIGWINCH&quot;, None)</span>


<span class="gd">-def create_key_bindings(cancel_callback: (Callable[[], None] | None)</span>
<span class="gd">-    ) -&gt;KeyBindings:</span>
<span class="gi">+def create_key_bindings(cancel_callback: Callable[[], None] | None) -&gt; KeyBindings:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Key bindings handled by the progress bar.
<span class="w"> </span>    (The main thread is not supposed to handle any key bindings.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>

<span class="gi">+    @kb.add(&quot;c-l&quot;)</span>
<span class="gi">+    def _clear(event: E) -&gt; None:</span>
<span class="gi">+        event.app.renderer.clear()</span>

<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+    if cancel_callback is not None:</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot;c-c&quot;)</span>
<span class="gi">+        def _interrupt(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Kill the &#39;body&#39; of the progress bar, but only if we run from the main thread.&quot;</span>
<span class="gi">+            assert cancel_callback is not None</span>
<span class="gi">+            cancel_callback()</span>
<span class="gi">+</span>
<span class="gi">+    return kb</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class ProgressBar:
<span class="gu">@@ -74,12 +114,19 @@ class ProgressBar:</span>
<span class="w"> </span>    :param input: :class:`~prompt_toolkit.input.Input` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, title: AnyFormattedText=None, formatters: (Sequence[</span>
<span class="gd">-        Formatter] | None)=None, bottom_toolbar: AnyFormattedText=None,</span>
<span class="gd">-        style: (BaseStyle | None)=None, key_bindings: (KeyBindings | None)=</span>
<span class="gd">-        None, cancel_callback: (Callable[[], None] | None)=None, file: (</span>
<span class="gd">-        TextIO | None)=None, color_depth: (ColorDepth | None)=None, output:</span>
<span class="gd">-        (Output | None)=None, input: (Input | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        title: AnyFormattedText = None,</span>
<span class="gi">+        formatters: Sequence[Formatter] | None = None,</span>
<span class="gi">+        bottom_toolbar: AnyFormattedText = None,</span>
<span class="gi">+        style: BaseStyle | None = None,</span>
<span class="gi">+        key_bindings: KeyBindings | None = None,</span>
<span class="gi">+        cancel_callback: Callable[[], None] | None = None,</span>
<span class="gi">+        file: TextIO | None = None,</span>
<span class="gi">+        color_depth: ColorDepth | None = None,</span>
<span class="gi">+        output: Output | None = None,</span>
<span class="gi">+        input: Input | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.title = title
<span class="w"> </span>        self.formatters = formatters or create_default_formatters()
<span class="w"> </span>        self.bottom_toolbar = bottom_toolbar
<span class="gu">@@ -87,61 +134,125 @@ class ProgressBar:</span>
<span class="w"> </span>        self.style = style
<span class="w"> </span>        self.key_bindings = key_bindings
<span class="w"> </span>        self.cancel_callback = cancel_callback
<span class="gi">+</span>
<span class="gi">+        # If no `cancel_callback` was given, and we&#39;re creating the progress</span>
<span class="gi">+        # bar from the main thread. Cancel by sending a `KeyboardInterrupt` to</span>
<span class="gi">+        # the main thread.</span>
<span class="w"> </span>        if self.cancel_callback is None and in_main_thread():

<span class="gd">-            def keyboard_interrupt_to_main_thread() -&gt;None:</span>
<span class="gi">+            def keyboard_interrupt_to_main_thread() -&gt; None:</span>
<span class="w"> </span>                os.kill(os.getpid(), signal.SIGINT)
<span class="gi">+</span>
<span class="w"> </span>            self.cancel_callback = keyboard_interrupt_to_main_thread
<span class="gi">+</span>
<span class="gi">+        # Note that we use __stderr__ as default error output, because that</span>
<span class="gi">+        # works best with `patch_stdout`.</span>
<span class="w"> </span>        self.color_depth = color_depth
<span class="w"> </span>        self.output = output or get_app_session().output
<span class="w"> </span>        self.input = input or get_app_session().input
<span class="gi">+</span>
<span class="w"> </span>        self._thread: threading.Thread | None = None
<span class="gi">+</span>
<span class="w"> </span>        self._has_sigwinch = False
<span class="w"> </span>        self._app_started = threading.Event()

<span class="gd">-    def __enter__(self) -&gt;ProgressBar:</span>
<span class="gd">-        title_toolbar = ConditionalContainer(Window(FormattedTextControl(lambda</span>
<span class="gd">-            : self.title), height=1, style=&#39;class:progressbar,title&#39;),</span>
<span class="gd">-            filter=Condition(lambda : self.title is not None))</span>
<span class="gd">-        bottom_toolbar = ConditionalContainer(Window(FormattedTextControl(</span>
<span class="gd">-            lambda : self.bottom_toolbar, style=&#39;class:bottom-toolbar.text&#39;</span>
<span class="gd">-            ), style=&#39;class:bottom-toolbar&#39;, height=1), filter=~is_done &amp;</span>
<span class="gd">-            renderer_height_is_known &amp; Condition(lambda : self.</span>
<span class="gd">-            bottom_toolbar is not None))</span>
<span class="gd">-</span>
<span class="gd">-        def width_for_formatter(formatter: Formatter) -&gt;AnyDimension:</span>
<span class="gi">+    def __enter__(self) -&gt; ProgressBar:</span>
<span class="gi">+        # Create UI Application.</span>
<span class="gi">+        title_toolbar = ConditionalContainer(</span>
<span class="gi">+            Window(</span>
<span class="gi">+                FormattedTextControl(lambda: self.title),</span>
<span class="gi">+                height=1,</span>
<span class="gi">+                style=&quot;class:progressbar,title&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=Condition(lambda: self.title is not None),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        bottom_toolbar = ConditionalContainer(</span>
<span class="gi">+            Window(</span>
<span class="gi">+                FormattedTextControl(</span>
<span class="gi">+                    lambda: self.bottom_toolbar, style=&quot;class:bottom-toolbar.text&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+                style=&quot;class:bottom-toolbar&quot;,</span>
<span class="gi">+                height=1,</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=~is_done</span>
<span class="gi">+            &amp; renderer_height_is_known</span>
<span class="gi">+            &amp; Condition(lambda: self.bottom_toolbar is not None),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def width_for_formatter(formatter: Formatter) -&gt; AnyDimension:</span>
<span class="gi">+            # Needs to be passed as callable (partial) to the &#39;width&#39;</span>
<span class="gi">+            # parameter, because we want to call it on every resize.</span>
<span class="w"> </span>            return formatter.get_width(progress_bar=self)
<span class="gd">-        progress_controls = [Window(content=_ProgressControl(self, f, self.</span>
<span class="gd">-            cancel_callback), width=functools.partial(width_for_formatter,</span>
<span class="gd">-            f)) for f in self.formatters]</span>
<span class="gd">-        self.app: Application[None] = Application(min_redraw_interval=0.05,</span>
<span class="gd">-            layout=Layout(HSplit([title_toolbar, VSplit(progress_controls,</span>
<span class="gd">-            height=lambda : D(preferred=len(self.counters), max=len(self.</span>
<span class="gd">-            counters))), Window(), bottom_toolbar])), style=self.style,</span>
<span class="gd">-            key_bindings=self.key_bindings, refresh_interval=0.3,</span>
<span class="gd">-            color_depth=self.color_depth, output=self.output, input=self.input)</span>
<span class="gd">-</span>
<span class="gd">-        def run() -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+        progress_controls = [</span>
<span class="gi">+            Window(</span>
<span class="gi">+                content=_ProgressControl(self, f, self.cancel_callback),</span>
<span class="gi">+                width=functools.partial(width_for_formatter, f),</span>
<span class="gi">+            )</span>
<span class="gi">+            for f in self.formatters</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        self.app: Application[None] = Application(</span>
<span class="gi">+            min_redraw_interval=0.05,</span>
<span class="gi">+            layout=Layout(</span>
<span class="gi">+                HSplit(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        title_toolbar,</span>
<span class="gi">+                        VSplit(</span>
<span class="gi">+                            progress_controls,</span>
<span class="gi">+                            height=lambda: D(</span>
<span class="gi">+                                preferred=len(self.counters), max=len(self.counters)</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        Window(),</span>
<span class="gi">+                        bottom_toolbar,</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+            ),</span>
<span class="gi">+            style=self.style,</span>
<span class="gi">+            key_bindings=self.key_bindings,</span>
<span class="gi">+            refresh_interval=0.3,</span>
<span class="gi">+            color_depth=self.color_depth,</span>
<span class="gi">+            output=self.output,</span>
<span class="gi">+            input=self.input,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Run application in different thread.</span>
<span class="gi">+        def run() -&gt; None:</span>
<span class="w"> </span>            try:
<span class="w"> </span>                self.app.run(pre_run=self._app_started.set)
<span class="w"> </span>            except BaseException as e:
<span class="w"> </span>                traceback.print_exc()
<span class="w"> </span>                print(e)
<span class="gi">+</span>
<span class="w"> </span>        ctx: contextvars.Context = contextvars.copy_context()
<span class="gi">+</span>
<span class="w"> </span>        self._thread = threading.Thread(target=ctx.run, args=(run,))
<span class="w"> </span>        self._thread.start()
<span class="gi">+</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, *a: object) -&gt;None:</span>
<span class="gi">+    def __exit__(self, *a: object) -&gt; None:</span>
<span class="gi">+        # Wait for the app to be started. Make sure we don&#39;t quit earlier,</span>
<span class="gi">+        # otherwise `self.app.exit` won&#39;t terminate the app because</span>
<span class="gi">+        # `self.app.future` has not yet been set.</span>
<span class="w"> </span>        self._app_started.wait()
<span class="gi">+</span>
<span class="gi">+        # Quit UI application.</span>
<span class="w"> </span>        if self.app.is_running and self.app.loop is not None:
<span class="w"> </span>            self.app.loop.call_soon_threadsafe(self.app.exit)
<span class="gi">+</span>
<span class="w"> </span>        if self._thread is not None:
<span class="w"> </span>            self._thread.join()

<span class="gd">-    def __call__(self, data: (Iterable[_T] | None)=None, label:</span>
<span class="gd">-        AnyFormattedText=&#39;&#39;, remove_when_done: bool=False, total: (int |</span>
<span class="gd">-        None)=None) -&gt;ProgressBarCounter[_T]:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: Iterable[_T] | None = None,</span>
<span class="gi">+        label: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        remove_when_done: bool = False,</span>
<span class="gi">+        total: int | None = None,</span>
<span class="gi">+    ) -&gt; ProgressBarCounter[_T]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start a new counter.

<span class="gu">@@ -151,25 +262,56 @@ class ProgressBar:</span>
<span class="w"> </span>        :param total: Specify the maximum value if it can&#39;t be calculated by
<span class="w"> </span>            calling ``len``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        counter = ProgressBarCounter(self, data, label=label,</span>
<span class="gd">-            remove_when_done=remove_when_done, total=total)</span>
<span class="gi">+        counter = ProgressBarCounter(</span>
<span class="gi">+            self, data, label=label, remove_when_done=remove_when_done, total=total</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.counters.append(counter)
<span class="w"> </span>        return counter

<span class="gi">+    def invalidate(self) -&gt; None:</span>
<span class="gi">+        self.app.invalidate()</span>
<span class="gi">+</span>

<span class="w"> </span>class _ProgressControl(UIControl):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    User control for the progress bar.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, progress_bar: ProgressBar, formatter: Formatter,</span>
<span class="gd">-        cancel_callback: (Callable[[], None] | None)) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        formatter: Formatter,</span>
<span class="gi">+        cancel_callback: Callable[[], None] | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.progress_bar = progress_bar
<span class="w"> </span>        self.formatter = formatter
<span class="w"> </span>        self._key_bindings = create_key_bindings(cancel_callback)

<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="gi">+        items: list[StyleAndTextTuples] = []</span>
<span class="gi">+</span>
<span class="gi">+        for pr in self.progress_bar.counters:</span>
<span class="gi">+            try:</span>
<span class="gi">+                text = self.formatter.format(self.progress_bar, pr, width)</span>
<span class="gi">+            except BaseException:</span>
<span class="gi">+                traceback.print_exc()</span>
<span class="gi">+                text = &quot;ERROR&quot;</span>
<span class="gi">+</span>
<span class="gi">+            items.append(to_formatted_text(text))</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            return items[i]</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent(get_line=get_line, line_count=len(items), show_cursor=False)</span>
<span class="gi">+</span>
<span class="gi">+    def is_focusable(self) -&gt; bool:</span>
<span class="gi">+        return True  # Make sure that the key bindings work.</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_bindings(self) -&gt; KeyBindings:</span>
<span class="gi">+        return self._key_bindings</span>
<span class="gi">+</span>

<span class="gd">-_CounterItem = TypeVar(&#39;_CounterItem&#39;, covariant=True)</span>
<span class="gi">+_CounterItem = TypeVar(&quot;_CounterItem&quot;, covariant=True)</span>


<span class="w"> </span>class ProgressBarCounter(Generic[_CounterItem]):
<span class="gu">@@ -177,9 +319,14 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>
<span class="w"> </span>    An individual counter (A progress bar can have multiple counters).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, progress_bar: ProgressBar, data: (Iterable[</span>
<span class="gd">-        _CounterItem] | None)=None, label: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-        remove_when_done: bool=False, total: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        data: Iterable[_CounterItem] | None = None,</span>
<span class="gi">+        label: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        remove_when_done: bool = False,</span>
<span class="gi">+        total: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.start_time = datetime.datetime.now()
<span class="w"> </span>        self.stop_time: datetime.datetime | None = None
<span class="w"> </span>        self.progress_bar = progress_bar
<span class="gu">@@ -189,36 +336,42 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>
<span class="w"> </span>        self.remove_when_done = remove_when_done
<span class="w"> </span>        self._done = False
<span class="w"> </span>        self.total: int | None
<span class="gi">+</span>
<span class="w"> </span>        if total is None:
<span class="w"> </span>            try:
<span class="w"> </span>                self.total = len(cast(Sized, data))
<span class="w"> </span>            except TypeError:
<span class="gd">-                self.total = None</span>
<span class="gi">+                self.total = None  # We don&#39;t know the total length.</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.total = total

<span class="gd">-    def __iter__(self) -&gt;Iterator[_CounterItem]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[_CounterItem]:</span>
<span class="w"> </span>        if self.data is not None:
<span class="w"> </span>            try:
<span class="w"> </span>                for item in self.data:
<span class="w"> </span>                    yield item
<span class="w"> </span>                    self.item_completed()
<span class="gi">+</span>
<span class="gi">+                # Only done if we iterate to the very end.</span>
<span class="w"> </span>                self.done = True
<span class="w"> </span>            finally:
<span class="gi">+                # Ensure counter has stopped even if we did not iterate to the</span>
<span class="gi">+                # end (e.g. break or exceptions).</span>
<span class="w"> </span>                self.stopped = True
<span class="w"> </span>        else:
<span class="gd">-            raise NotImplementedError(&#39;No data defined to iterate over.&#39;)</span>
<span class="gi">+            raise NotImplementedError(&quot;No data defined to iterate over.&quot;)</span>

<span class="gd">-    def item_completed(self) -&gt;None:</span>
<span class="gi">+    def item_completed(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start handling the next item.

<span class="w"> </span>        (Can be called manually in case we don&#39;t have a collection to loop through.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items_completed += 1</span>
<span class="gi">+        self.progress_bar.invalidate()</span>

<span class="w"> </span>    @property
<span class="gd">-    def done(self) -&gt;bool:</span>
<span class="gi">+    def done(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether a counter has been completed.

<span class="w"> </span>        Done counter have been stopped (see stopped) and removed depending on
<span class="gu">@@ -227,10 +380,18 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>
<span class="w"> </span>        Contrast this with stopped. A stopped counter may be terminated before
<span class="w"> </span>        100% completion. A done counter has reached its 100% completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._done</span>
<span class="gi">+</span>
<span class="gi">+    @done.setter</span>
<span class="gi">+    def done(self, value: bool) -&gt; None:</span>
<span class="gi">+        self._done = value</span>
<span class="gi">+        self.stopped = value</span>
<span class="gi">+</span>
<span class="gi">+        if value and self.remove_when_done:</span>
<span class="gi">+            self.progress_bar.counters.remove(self)</span>

<span class="w"> </span>    @property
<span class="gd">-    def stopped(self) -&gt;bool:</span>
<span class="gi">+    def stopped(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether a counter has been stopped.

<span class="w"> </span>        Stopped counters no longer have increasing time_elapsed. This distinction is
<span class="gu">@@ -245,18 +406,43 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>
<span class="w"> </span>        Contrast this with done. A done counter has reached its 100% completion.
<span class="w"> </span>        A stopped counter may be terminated before 100% completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stop_time is not None</span>
<span class="gi">+</span>
<span class="gi">+    @stopped.setter</span>
<span class="gi">+    def stopped(self, value: bool) -&gt; None:</span>
<span class="gi">+        if value:</span>
<span class="gi">+            # This counter has not already been stopped.</span>
<span class="gi">+            if not self.stop_time:</span>
<span class="gi">+                self.stop_time = datetime.datetime.now()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Clearing any previously set stop_time.</span>
<span class="gi">+            self.stop_time = None</span>

<span class="w"> </span>    @property
<span class="gd">-    def time_elapsed(self) -&gt;datetime.timedelta:</span>
<span class="gi">+    def percentage(self) -&gt; float:</span>
<span class="gi">+        if self.total is None:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.items_completed * 100 / max(self.total, 1)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def time_elapsed(self) -&gt; datetime.timedelta:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return how much time has been elapsed since the start.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stop_time is None:</span>
<span class="gi">+            return datetime.datetime.now() - self.start_time</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.stop_time - self.start_time</span>

<span class="w"> </span>    @property
<span class="gd">-    def time_left(self) -&gt;(datetime.timedelta | None):</span>
<span class="gi">+    def time_left(self) -&gt; datetime.timedelta | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Timedelta representing the time left.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.total is None or not self.percentage:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif self.done or self.stopped:</span>
<span class="gi">+            return datetime.timedelta(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.time_elapsed * (100 - self.percentage) / self.percentage</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/progress_bar/formatters.py b/src/prompt_toolkit/shortcuts/progress_bar/formatters.py</span>
<span class="gh">index 8ff11a85..dd0339c3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/progress_bar/formatters.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/progress_bar/formatters.py</span>
<span class="gu">@@ -3,20 +3,40 @@ Formatter classes for the progress bar.</span>
<span class="w"> </span>Each progress bar consists of a list of these formatters.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import time
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gd">-from prompt_toolkit.formatted_text import HTML, AnyFormattedText, StyleAndTextTuples, to_formatted_text</span>
<span class="gi">+</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    HTML,</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.formatted_text.utils import fragment_list_width
<span class="w"> </span>from prompt_toolkit.layout.dimension import AnyDimension, D
<span class="w"> </span>from prompt_toolkit.layout.utils import explode_text_fragments
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .base import ProgressBar, ProgressBarCounter
<span class="gd">-__all__ = [&#39;Formatter&#39;, &#39;Text&#39;, &#39;Label&#39;, &#39;Percentage&#39;, &#39;Bar&#39;, &#39;Progress&#39;,</span>
<span class="gd">-    &#39;TimeElapsed&#39;, &#39;TimeLeft&#39;, &#39;IterationsPerSecond&#39;, &#39;SpinningWheel&#39;,</span>
<span class="gd">-    &#39;Rainbow&#39;, &#39;create_default_formatters&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Formatter&quot;,</span>
<span class="gi">+    &quot;Text&quot;,</span>
<span class="gi">+    &quot;Label&quot;,</span>
<span class="gi">+    &quot;Percentage&quot;,</span>
<span class="gi">+    &quot;Bar&quot;,</span>
<span class="gi">+    &quot;Progress&quot;,</span>
<span class="gi">+    &quot;TimeElapsed&quot;,</span>
<span class="gi">+    &quot;TimeLeft&quot;,</span>
<span class="gi">+    &quot;IterationsPerSecond&quot;,</span>
<span class="gi">+    &quot;SpinningWheel&quot;,</span>
<span class="gi">+    &quot;Rainbow&quot;,</span>
<span class="gi">+    &quot;create_default_formatters&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Formatter(metaclass=ABCMeta):
<span class="gu">@@ -24,15 +44,38 @@ class Formatter(metaclass=ABCMeta):</span>
<span class="w"> </span>    Base class for any formatter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        return D()</span>
<span class="gi">+</span>

<span class="w"> </span>class Text(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display plain text.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: AnyFormattedText, style: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, text: AnyFormattedText, style: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        self.text = to_formatted_text(text, style=style)

<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        return self.text</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        return fragment_list_width(self.text)</span>
<span class="gi">+</span>

<span class="w"> </span>class Label(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -44,30 +87,82 @@ class Label(Formatter):</span>
<span class="w"> </span>        If no task name was given, no suffix will be added.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, width: AnyDimension=None, suffix: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, width: AnyDimension = None, suffix: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.suffix = suffix

<span class="gi">+    def _add_suffix(self, label: AnyFormattedText) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        label = to_formatted_text(label, style=&quot;class:label&quot;)</span>
<span class="gi">+        return label + [(&quot;&quot;, self.suffix)]</span>
<span class="gi">+</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        label = self._add_suffix(progress.label)</span>
<span class="gi">+        cwidth = fragment_list_width(label)</span>
<span class="gi">+</span>
<span class="gi">+        if cwidth &gt; width:</span>
<span class="gi">+            # It doesn&#39;t fit -&gt; scroll task name.</span>
<span class="gi">+            label = explode_text_fragments(label)</span>
<span class="gi">+            max_scroll = cwidth - width</span>
<span class="gi">+            current_scroll = int(time.time() * 3 % max_scroll)</span>
<span class="gi">+            label = label[current_scroll:]</span>
<span class="gi">+</span>
<span class="gi">+        return label</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        if self.width:</span>
<span class="gi">+            return self.width</span>
<span class="gi">+</span>
<span class="gi">+        all_labels = [self._add_suffix(c.label) for c in progress_bar.counters]</span>
<span class="gi">+        if all_labels:</span>
<span class="gi">+            max_widths = max(fragment_list_width(l) for l in all_labels)</span>
<span class="gi">+            return D(preferred=max_widths, max=max_widths)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return D()</span>
<span class="gi">+</span>

<span class="w"> </span>class Percentage(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display the progress as a percentage.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    template = &#39;&lt;percentage&gt;{percentage:&gt;5}%&lt;/percentage&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    template = &quot;&lt;percentage&gt;{percentage:&gt;5}%&lt;/percentage&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        return HTML(self.template).format(percentage=round(progress.percentage, 1))</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        return D.exact(6)</span>


<span class="w"> </span>class Bar(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display the progress bar itself.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    template = (</span>
<span class="gd">-        &#39;&lt;bar&gt;{start}&lt;bar-a&gt;{bar_a}&lt;/bar-a&gt;&lt;bar-b&gt;{bar_b}&lt;/bar-b&gt;&lt;bar-c&gt;{bar_c}&lt;/bar-c&gt;{end}&lt;/bar&gt;&#39;</span>
<span class="gd">-        )</span>

<span class="gd">-    def __init__(self, start: str=&#39;[&#39;, end: str=&#39;]&#39;, sym_a: str=&#39;=&#39;, sym_b:</span>
<span class="gd">-        str=&#39;&gt;&#39;, sym_c: str=&#39; &#39;, unknown: str=&#39;#&#39;) -&gt;None:</span>
<span class="gi">+    template = &quot;&lt;bar&gt;{start}&lt;bar-a&gt;{bar_a}&lt;/bar-a&gt;&lt;bar-b&gt;{bar_b}&lt;/bar-b&gt;&lt;bar-c&gt;{bar_c}&lt;/bar-c&gt;{end}&lt;/bar&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start: str = &quot;[&quot;,</span>
<span class="gi">+        end: str = &quot;]&quot;,</span>
<span class="gi">+        sym_a: str = &quot;=&quot;,</span>
<span class="gi">+        sym_b: str = &quot;&gt;&quot;,</span>
<span class="gi">+        sym_c: str = &quot; &quot;,</span>
<span class="gi">+        unknown: str = &quot;#&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert len(sym_a) == 1 and get_cwidth(sym_a) == 1
<span class="w"> </span>        assert len(sym_c) == 1 and get_cwidth(sym_c) == 1
<span class="gi">+</span>
<span class="w"> </span>        self.start = start
<span class="w"> </span>        self.end = end
<span class="w"> </span>        self.sym_a = sym_a
<span class="gu">@@ -75,19 +170,79 @@ class Bar(Formatter):</span>
<span class="w"> </span>        self.sym_c = sym_c
<span class="w"> </span>        self.unknown = unknown

<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        if progress.done or progress.total or progress.stopped:</span>
<span class="gi">+            sym_a, sym_b, sym_c = self.sym_a, self.sym_b, self.sym_c</span>
<span class="gi">+</span>
<span class="gi">+            # Compute pb_a based on done, total, or stopped states.</span>
<span class="gi">+            if progress.done:</span>
<span class="gi">+                # 100% completed irrelevant of how much was actually marked as completed.</span>
<span class="gi">+                percent = 1.0</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Show percentage completed.</span>
<span class="gi">+                percent = progress.percentage / 100</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Total is unknown and bar is still running.</span>
<span class="gi">+            sym_a, sym_b, sym_c = self.sym_c, self.unknown, self.sym_c</span>
<span class="gi">+</span>
<span class="gi">+            # Compute percent based on the time.</span>
<span class="gi">+            percent = time.time() * 20 % 100 / 100</span>
<span class="gi">+</span>
<span class="gi">+        # Subtract left, sym_b, and right.</span>
<span class="gi">+        width -= get_cwidth(self.start + sym_b + self.end)</span>
<span class="gi">+</span>
<span class="gi">+        # Scale percent by width</span>
<span class="gi">+        pb_a = int(percent * width)</span>
<span class="gi">+        bar_a = sym_a * pb_a</span>
<span class="gi">+        bar_b = sym_b</span>
<span class="gi">+        bar_c = sym_c * (width - pb_a)</span>
<span class="gi">+</span>
<span class="gi">+        return HTML(self.template).format(</span>
<span class="gi">+            start=self.start, end=self.end, bar_a=bar_a, bar_b=bar_b, bar_c=bar_c</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        return D(min=9)</span>
<span class="gi">+</span>

<span class="w"> </span>class Progress(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display the progress as text.  E.g. &quot;8/20&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    template = &#39;&lt;current&gt;{current:&gt;3}&lt;/current&gt;/&lt;total&gt;{total:&gt;3}&lt;/total&gt;&#39;</span>

<span class="gi">+    template = &quot;&lt;current&gt;{current:&gt;3}&lt;/current&gt;/&lt;total&gt;{total:&gt;3}&lt;/total&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        return HTML(self.template).format(</span>
<span class="gi">+            current=progress.items_completed, total=progress.total or &quot;?&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-def _format_timedelta(timedelta: datetime.timedelta) -&gt;str:</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        all_lengths = [</span>
<span class="gi">+            len(&quot;{:&gt;3}&quot;.format(c.total or &quot;?&quot;)) for c in progress_bar.counters</span>
<span class="gi">+        ]</span>
<span class="gi">+        all_lengths.append(1)</span>
<span class="gi">+        return D.exact(max(all_lengths) * 2 + 1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_timedelta(timedelta: datetime.timedelta) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return hh:mm:ss, or mm:ss if the amount of hours is zero.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = f&quot;{timedelta}&quot;.split(&quot;.&quot;)[0]</span>
<span class="gi">+    if result.startswith(&quot;0:&quot;):</span>
<span class="gi">+        result = result[2:]</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class TimeElapsed(Formatter):
<span class="gu">@@ -95,51 +250,180 @@ class TimeElapsed(Formatter):</span>
<span class="w"> </span>    Display the elapsed time.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        text = _format_timedelta(progress.time_elapsed).rjust(width)</span>
<span class="gi">+        return HTML(&quot;&lt;time-elapsed&gt;{time_elapsed}&lt;/time-elapsed&gt;&quot;).format(</span>
<span class="gi">+            time_elapsed=text</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        all_values = [</span>
<span class="gi">+            len(_format_timedelta(c.time_elapsed)) for c in progress_bar.counters</span>
<span class="gi">+        ]</span>
<span class="gi">+        if all_values:</span>
<span class="gi">+            return max(all_values)</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>

<span class="w"> </span>class TimeLeft(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display the time left.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    template = &#39;&lt;time-left&gt;{time_left}&lt;/time-left&gt;&#39;</span>
<span class="gd">-    unknown = &#39;?:??:??&#39;</span>
<span class="gi">+</span>
<span class="gi">+    template = &quot;&lt;time-left&gt;{time_left}&lt;/time-left&gt;&quot;</span>
<span class="gi">+    unknown = &quot;?:??:??&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        time_left = progress.time_left</span>
<span class="gi">+        if time_left is not None:</span>
<span class="gi">+            formatted_time_left = _format_timedelta(time_left)</span>
<span class="gi">+        else:</span>
<span class="gi">+            formatted_time_left = self.unknown</span>
<span class="gi">+</span>
<span class="gi">+        return HTML(self.template).format(time_left=formatted_time_left.rjust(width))</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        all_values = [</span>
<span class="gi">+            len(_format_timedelta(c.time_left)) if c.time_left is not None else 7</span>
<span class="gi">+            for c in progress_bar.counters</span>
<span class="gi">+        ]</span>
<span class="gi">+        if all_values:</span>
<span class="gi">+            return max(all_values)</span>
<span class="gi">+        return 0</span>


<span class="w"> </span>class IterationsPerSecond(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display the iterations per second.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    template = (
<span class="gd">-        &#39;&lt;iterations-per-second&gt;{iterations_per_second:.2f}&lt;/iterations-per-second&gt;&#39;</span>
<span class="gd">-        )</span>
<span class="gi">+        &quot;&lt;iterations-per-second&gt;{iterations_per_second:.2f}&lt;/iterations-per-second&gt;&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        value = progress.items_completed / progress.time_elapsed.total_seconds()</span>
<span class="gi">+        return HTML(self.template.format(iterations_per_second=value))</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        all_values = [</span>
<span class="gi">+            len(f&quot;{c.items_completed / c.time_elapsed.total_seconds():.2f}&quot;)</span>
<span class="gi">+            for c in progress_bar.counters</span>
<span class="gi">+        ]</span>
<span class="gi">+        if all_values:</span>
<span class="gi">+            return max(all_values)</span>
<span class="gi">+        return 0</span>


<span class="w"> </span>class SpinningWheel(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a spinning wheel.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    characters = &#39;/-\\|&#39;</span>
<span class="gi">+</span>
<span class="gi">+    characters = r&quot;/-\|&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        index = int(time.time() * 3) % len(self.characters)</span>
<span class="gi">+        return HTML(&quot;&lt;spinning-wheel&gt;{0}&lt;/spinning-wheel&gt;&quot;).format(</span>
<span class="gi">+            self.characters[index]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        return D.exact(1)</span>


<span class="gd">-def _hue_to_rgb(hue: float) -&gt;tuple[int, int, int]:</span>
<span class="gi">+def _hue_to_rgb(hue: float) -&gt; tuple[int, int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take hue between 0 and 1, return (r, g, b).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i = int(hue * 6.0)</span>
<span class="gi">+    f = (hue * 6.0) - i</span>
<span class="gi">+</span>
<span class="gi">+    q = int(255 * (1.0 - f))</span>
<span class="gi">+    t = int(255 * (1.0 - (1.0 - f)))</span>
<span class="gi">+</span>
<span class="gi">+    i %= 6</span>
<span class="gi">+</span>
<span class="gi">+    return [</span>
<span class="gi">+        (255, t, 0),</span>
<span class="gi">+        (q, 255, 0),</span>
<span class="gi">+        (0, 255, t),</span>
<span class="gi">+        (0, q, 255),</span>
<span class="gi">+        (t, 0, 255),</span>
<span class="gi">+        (255, 0, q),</span>
<span class="gi">+    ][i]</span>


<span class="w"> </span>class Rainbow(Formatter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    For the fun. Add rainbow colors to any of the other formatters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    colors = [(&#39;#%.2x%.2x%.2x&#39; % _hue_to_rgb(h / 100.0)) for h in range(0, 100)</span>
<span class="gd">-        ]</span>

<span class="gd">-    def __init__(self, formatter: Formatter) -&gt;None:</span>
<span class="gi">+    colors = [&quot;#%.2x%.2x%.2x&quot; % _hue_to_rgb(h / 100.0) for h in range(0, 100)]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, formatter: Formatter) -&gt; None:</span>
<span class="w"> </span>        self.formatter = formatter

<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress_bar: ProgressBar,</span>
<span class="gi">+        progress: ProgressBarCounter[object],</span>
<span class="gi">+        width: int,</span>
<span class="gi">+    ) -&gt; AnyFormattedText:</span>
<span class="gi">+        # Get formatted text from nested formatter, and explode it in</span>
<span class="gi">+        # text/style tuples.</span>
<span class="gi">+        result = self.formatter.format(progress_bar, progress, width)</span>
<span class="gi">+        result = explode_text_fragments(to_formatted_text(result))</span>
<span class="gi">+</span>
<span class="gi">+        # Insert colors.</span>
<span class="gi">+        result2: StyleAndTextTuples = []</span>
<span class="gi">+        shift = int(time.time() * 3) % len(self.colors)</span>
<span class="gi">+</span>
<span class="gi">+        for i, (style, text, *_) in enumerate(result):</span>
<span class="gi">+            result2.append(</span>
<span class="gi">+                (style + &quot; &quot; + self.colors[(i + shift) % len(self.colors)], text)</span>
<span class="gi">+            )</span>
<span class="gi">+        return result2</span>
<span class="gi">+</span>
<span class="gi">+    def get_width(self, progress_bar: ProgressBar) -&gt; AnyDimension:</span>
<span class="gi">+        return self.formatter.get_width(progress_bar)</span>
<span class="gi">+</span>

<span class="gd">-def create_default_formatters() -&gt;list[Formatter]:</span>
<span class="gi">+def create_default_formatters() -&gt; list[Formatter]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the list of default formatters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        Label(),</span>
<span class="gi">+        Text(&quot; &quot;),</span>
<span class="gi">+        Percentage(),</span>
<span class="gi">+        Text(&quot; &quot;),</span>
<span class="gi">+        Bar(),</span>
<span class="gi">+        Text(&quot; &quot;),</span>
<span class="gi">+        Progress(),</span>
<span class="gi">+        Text(&quot; &quot;),</span>
<span class="gi">+        Text(&quot;eta [&quot;, style=&quot;class:time-left&quot;),</span>
<span class="gi">+        TimeLeft(),</span>
<span class="gi">+        Text(&quot;]&quot;, style=&quot;class:time-left&quot;),</span>
<span class="gi">+        Text(&quot; &quot;),</span>
<span class="gi">+    ]</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/prompt.py b/src/prompt_toolkit/shortcuts/prompt.py</span>
<span class="gh">index 452ef1a4..7274b5f0 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/prompt.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/prompt.py</span>
<span class="gu">@@ -25,63 +25,163 @@ Example::</span>
<span class="w"> </span>        result = s.prompt(&#39;Say something: &#39;)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from asyncio import get_running_loop
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import TYPE_CHECKING, Callable, Generic, Iterator, TypeVar, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application import Application
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.auto_suggest import AutoSuggest, DynamicAutoSuggest
<span class="w"> </span>from prompt_toolkit.buffer import Buffer
<span class="w"> </span>from prompt_toolkit.clipboard import Clipboard, DynamicClipboard, InMemoryClipboard
<span class="w"> </span>from prompt_toolkit.completion import Completer, DynamicCompleter, ThreadedCompleter
<span class="gd">-from prompt_toolkit.cursor_shapes import AnyCursorShapeConfig, CursorShapeConfig, DynamicCursorShapeConfig</span>
<span class="gi">+from prompt_toolkit.cursor_shapes import (</span>
<span class="gi">+    AnyCursorShapeConfig,</span>
<span class="gi">+    CursorShapeConfig,</span>
<span class="gi">+    DynamicCursorShapeConfig,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="w"> </span>from prompt_toolkit.enums import DEFAULT_BUFFER, SEARCH_BUFFER, EditingMode
<span class="w"> </span>from prompt_toolkit.eventloop import InputHook
<span class="gd">-from prompt_toolkit.filters import Condition, FilterOrBool, has_arg, has_focus, is_done, is_true, renderer_height_is_known, to_filter</span>
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, fragment_list_to_text, merge_formatted_text, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    FilterOrBool,</span>
<span class="gi">+    has_arg,</span>
<span class="gi">+    has_focus,</span>
<span class="gi">+    is_done,</span>
<span class="gi">+    is_true,</span>
<span class="gi">+    renderer_height_is_known,</span>
<span class="gi">+    to_filter,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    fragment_list_to_text,</span>
<span class="gi">+    merge_formatted_text,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.history import History, InMemoryHistory
<span class="w"> </span>from prompt_toolkit.input.base import Input
<span class="w"> </span>from prompt_toolkit.key_binding.bindings.auto_suggest import load_auto_suggest_bindings
<span class="gd">-from prompt_toolkit.key_binding.bindings.completion import display_completions_like_readline</span>
<span class="gd">-from prompt_toolkit.key_binding.bindings.open_in_editor import load_open_in_editor_bindings</span>
<span class="gd">-from prompt_toolkit.key_binding.key_bindings import ConditionalKeyBindings, DynamicKeyBindings, KeyBindings, KeyBindingsBase, merge_key_bindings</span>
<span class="gi">+from prompt_toolkit.key_binding.bindings.completion import (</span>
<span class="gi">+    display_completions_like_readline,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.key_binding.bindings.open_in_editor import (</span>
<span class="gi">+    load_open_in_editor_bindings,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+    ConditionalKeyBindings,</span>
<span class="gi">+    DynamicKeyBindings,</span>
<span class="gi">+    KeyBindings,</span>
<span class="gi">+    KeyBindingsBase,</span>
<span class="gi">+    merge_key_bindings,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.layout import Float, FloatContainer, HSplit, Window
<span class="w"> </span>from prompt_toolkit.layout.containers import ConditionalContainer, WindowAlign
<span class="gd">-from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl, SearchBufferControl</span>
<span class="gi">+from prompt_toolkit.layout.controls import (</span>
<span class="gi">+    BufferControl,</span>
<span class="gi">+    FormattedTextControl,</span>
<span class="gi">+    SearchBufferControl,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.dimension import Dimension
<span class="w"> </span>from prompt_toolkit.layout.layout import Layout
<span class="w"> </span>from prompt_toolkit.layout.menus import CompletionsMenu, MultiColumnCompletionsMenu
<span class="gd">-from prompt_toolkit.layout.processors import AfterInput, AppendAutoSuggestion, ConditionalProcessor, DisplayMultipleCursors, DynamicProcessor, HighlightIncrementalSearchProcessor, HighlightSelectionProcessor, PasswordProcessor, Processor, ReverseSearchProcessor, merge_processors</span>
<span class="gi">+from prompt_toolkit.layout.processors import (</span>
<span class="gi">+    AfterInput,</span>
<span class="gi">+    AppendAutoSuggestion,</span>
<span class="gi">+    ConditionalProcessor,</span>
<span class="gi">+    DisplayMultipleCursors,</span>
<span class="gi">+    DynamicProcessor,</span>
<span class="gi">+    HighlightIncrementalSearchProcessor,</span>
<span class="gi">+    HighlightSelectionProcessor,</span>
<span class="gi">+    PasswordProcessor,</span>
<span class="gi">+    Processor,</span>
<span class="gi">+    ReverseSearchProcessor,</span>
<span class="gi">+    merge_processors,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.utils import explode_text_fragments
<span class="w"> </span>from prompt_toolkit.lexers import DynamicLexer, Lexer
<span class="w"> </span>from prompt_toolkit.output import ColorDepth, DummyOutput, Output
<span class="gd">-from prompt_toolkit.styles import BaseStyle, ConditionalStyleTransformation, DynamicStyle, DynamicStyleTransformation, StyleTransformation, SwapLightAndDarkStyleTransformation, merge_style_transformations</span>
<span class="gd">-from prompt_toolkit.utils import get_cwidth, is_dumb_terminal, suspend_to_background_supported, to_str</span>
<span class="gi">+from prompt_toolkit.styles import (</span>
<span class="gi">+    BaseStyle,</span>
<span class="gi">+    ConditionalStyleTransformation,</span>
<span class="gi">+    DynamicStyle,</span>
<span class="gi">+    DynamicStyleTransformation,</span>
<span class="gi">+    StyleTransformation,</span>
<span class="gi">+    SwapLightAndDarkStyleTransformation,</span>
<span class="gi">+    merge_style_transformations,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.utils import (</span>
<span class="gi">+    get_cwidth,</span>
<span class="gi">+    is_dumb_terminal,</span>
<span class="gi">+    suspend_to_background_supported,</span>
<span class="gi">+    to_str,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.validation import DynamicValidator, Validator
<span class="gd">-from prompt_toolkit.widgets.toolbars import SearchToolbar, SystemToolbar, ValidationToolbar</span>
<span class="gi">+from prompt_toolkit.widgets.toolbars import (</span>
<span class="gi">+    SearchToolbar,</span>
<span class="gi">+    SystemToolbar,</span>
<span class="gi">+    ValidationToolbar,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.formatted_text.base import MagicFormattedText
<span class="gd">-__all__ = [&#39;PromptSession&#39;, &#39;prompt&#39;, &#39;confirm&#39;, &#39;create_confirm_session&#39;,</span>
<span class="gd">-    &#39;CompleteStyle&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;PromptSession&quot;,</span>
<span class="gi">+    &quot;prompt&quot;,</span>
<span class="gi">+    &quot;confirm&quot;,</span>
<span class="gi">+    &quot;create_confirm_session&quot;,  # Used by &#39;_display_completions_like_readline&#39;.</span>
<span class="gi">+    &quot;CompleteStyle&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>_StyleAndTextTuplesCallable = Callable[[], StyleAndTextTuples]
<span class="w"> </span>E = KeyPressEvent


<span class="gd">-def _split_multiline_prompt(get_prompt_text: _StyleAndTextTuplesCallable</span>
<span class="gd">-    ) -&gt;tuple[Callable[[], bool], _StyleAndTextTuplesCallable,</span>
<span class="gd">-    _StyleAndTextTuplesCallable]:</span>
<span class="gi">+def _split_multiline_prompt(</span>
<span class="gi">+    get_prompt_text: _StyleAndTextTuplesCallable,</span>
<span class="gi">+) -&gt; tuple[</span>
<span class="gi">+    Callable[[], bool], _StyleAndTextTuplesCallable, _StyleAndTextTuplesCallable</span>
<span class="gi">+]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a `get_prompt_text` function and return three new functions instead.
<span class="w"> </span>    One that tells whether this prompt consists of multiple lines; one that
<span class="w"> </span>    returns the fragments to be shown on the lines above the input; and another
<span class="w"> </span>    one with the fragments to be shown at the first line of the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def has_before_fragments() -&gt; bool:</span>
<span class="gi">+        for fragment, char, *_ in get_prompt_text():</span>
<span class="gi">+            if &quot;\n&quot; in char:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def before() -&gt; StyleAndTextTuples:</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+        found_nl = False</span>
<span class="gi">+        for fragment, char, *_ in reversed(explode_text_fragments(get_prompt_text())):</span>
<span class="gi">+            if found_nl:</span>
<span class="gi">+                result.insert(0, (fragment, char))</span>
<span class="gi">+            elif char == &quot;\n&quot;:</span>
<span class="gi">+                found_nl = True</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def first_input_line() -&gt; StyleAndTextTuples:</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+        for fragment, char, *_ in reversed(explode_text_fragments(get_prompt_text())):</span>
<span class="gi">+            if char == &quot;\n&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.insert(0, (fragment, char))</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    return has_before_fragments, before, first_input_line</span>


<span class="w"> </span>class _RPrompt(Window):
<span class="gu">@@ -89,24 +189,37 @@ class _RPrompt(Window):</span>
<span class="w"> </span>    The prompt that is displayed on the right side of the Window.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: AnyFormattedText) -&gt;None:</span>
<span class="gd">-        super().__init__(FormattedTextControl(text=text), align=WindowAlign</span>
<span class="gd">-            .RIGHT, style=&#39;class:rprompt&#39;)</span>
<span class="gi">+    def __init__(self, text: AnyFormattedText) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            FormattedTextControl(text=text),</span>
<span class="gi">+            align=WindowAlign.RIGHT,</span>
<span class="gi">+            style=&quot;class:rprompt&quot;,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class CompleteStyle(str, Enum):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    How to display autocompletions for the prompt.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    value: str
<span class="gd">-    COLUMN = &#39;COLUMN&#39;</span>
<span class="gd">-    MULTI_COLUMN = &#39;MULTI_COLUMN&#39;</span>
<span class="gd">-    READLINE_LIKE = &#39;READLINE_LIKE&#39;</span>
<span class="gi">+</span>
<span class="gi">+    COLUMN = &quot;COLUMN&quot;</span>
<span class="gi">+    MULTI_COLUMN = &quot;MULTI_COLUMN&quot;</span>
<span class="gi">+    READLINE_LIKE = &quot;READLINE_LIKE&quot;</span>


<span class="gd">-PromptContinuationText = Union[str, &#39;MagicFormattedText&#39;,</span>
<span class="gd">-    StyleAndTextTuples, Callable[[int, int, int], AnyFormattedText]]</span>
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+# Formatted text for the continuation prompt. It&#39;s the same like other</span>
<span class="gi">+# formatted text, except that if it&#39;s a callable, it takes three arguments.</span>
<span class="gi">+PromptContinuationText = Union[</span>
<span class="gi">+    str,</span>
<span class="gi">+    &quot;MagicFormattedText&quot;,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    # (prompt_width, line_number, wrap_count) -&gt; AnyFormattedText.</span>
<span class="gi">+    Callable[[int, int, int], AnyFormattedText],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class PromptSession(Generic[_T]):
<span class="gu">@@ -211,51 +324,105 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        input/output is by creating an `AppSession`.)
<span class="w"> </span>    :param output: `Output` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _fields = (&#39;message&#39;, &#39;lexer&#39;, &#39;completer&#39;, &#39;complete_in_thread&#39;,</span>
<span class="gd">-        &#39;is_password&#39;, &#39;editing_mode&#39;, &#39;key_bindings&#39;, &#39;is_password&#39;,</span>
<span class="gd">-        &#39;bottom_toolbar&#39;, &#39;style&#39;, &#39;style_transformation&#39;,</span>
<span class="gd">-        &#39;swap_light_and_dark_colors&#39;, &#39;color_depth&#39;, &#39;cursor&#39;,</span>
<span class="gd">-        &#39;include_default_pygments_style&#39;, &#39;rprompt&#39;, &#39;multiline&#39;,</span>
<span class="gd">-        &#39;prompt_continuation&#39;, &#39;wrap_lines&#39;, &#39;enable_history_search&#39;,</span>
<span class="gd">-        &#39;search_ignore_case&#39;, &#39;complete_while_typing&#39;,</span>
<span class="gd">-        &#39;validate_while_typing&#39;, &#39;complete_style&#39;, &#39;mouse_support&#39;,</span>
<span class="gd">-        &#39;auto_suggest&#39;, &#39;clipboard&#39;, &#39;validator&#39;, &#39;refresh_interval&#39;,</span>
<span class="gd">-        &#39;input_processors&#39;, &#39;placeholder&#39;, &#39;enable_system_prompt&#39;,</span>
<span class="gd">-        &#39;enable_suspend&#39;, &#39;enable_open_in_editor&#39;, &#39;reserve_space_for_menu&#39;,</span>
<span class="gd">-        &#39;tempfile_suffix&#39;, &#39;tempfile&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, message: AnyFormattedText=&#39;&#39;, *, multiline:</span>
<span class="gd">-        FilterOrBool=False, wrap_lines: FilterOrBool=True, is_password:</span>
<span class="gd">-        FilterOrBool=False, vi_mode: bool=False, editing_mode: EditingMode=</span>
<span class="gd">-        EditingMode.EMACS, complete_while_typing: FilterOrBool=True,</span>
<span class="gd">-        validate_while_typing: FilterOrBool=True, enable_history_search:</span>
<span class="gd">-        FilterOrBool=False, search_ignore_case: FilterOrBool=False, lexer:</span>
<span class="gd">-        (Lexer | None)=None, enable_system_prompt: FilterOrBool=False,</span>
<span class="gd">-        enable_suspend: FilterOrBool=False, enable_open_in_editor:</span>
<span class="gd">-        FilterOrBool=False, validator: (Validator | None)=None, completer:</span>
<span class="gd">-        (Completer | None)=None, complete_in_thread: bool=False,</span>
<span class="gd">-        reserve_space_for_menu: int=8, complete_style: CompleteStyle=</span>
<span class="gd">-        CompleteStyle.COLUMN, auto_suggest: (AutoSuggest | None)=None,</span>
<span class="gd">-        style: (BaseStyle | None)=None, style_transformation: (</span>
<span class="gd">-        StyleTransformation | None)=None, swap_light_and_dark_colors:</span>
<span class="gd">-        FilterOrBool=False, color_depth: (ColorDepth | None)=None, cursor:</span>
<span class="gd">-        AnyCursorShapeConfig=None, include_default_pygments_style:</span>
<span class="gd">-        FilterOrBool=True, history: (History | None)=None, clipboard: (</span>
<span class="gd">-        Clipboard | None)=None, prompt_continuation: (</span>
<span class="gd">-        PromptContinuationText | None)=None, rprompt: AnyFormattedText=None,</span>
<span class="gd">-        bottom_toolbar: AnyFormattedText=None, mouse_support: FilterOrBool=</span>
<span class="gd">-        False, input_processors: (list[Processor] | None)=None, placeholder:</span>
<span class="gd">-        (AnyFormattedText | None)=None, key_bindings: (KeyBindingsBase |</span>
<span class="gd">-        None)=None, erase_when_done: bool=False, tempfile_suffix: (str |</span>
<span class="gd">-        Callable[[], str] | None)=&#39;.txt&#39;, tempfile: (str | Callable[[], str</span>
<span class="gd">-        ] | None)=None, refresh_interval: float=0, input: (Input | None)=</span>
<span class="gd">-        None, output: (Output | None)=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    _fields = (</span>
<span class="gi">+        &quot;message&quot;,</span>
<span class="gi">+        &quot;lexer&quot;,</span>
<span class="gi">+        &quot;completer&quot;,</span>
<span class="gi">+        &quot;complete_in_thread&quot;,</span>
<span class="gi">+        &quot;is_password&quot;,</span>
<span class="gi">+        &quot;editing_mode&quot;,</span>
<span class="gi">+        &quot;key_bindings&quot;,</span>
<span class="gi">+        &quot;is_password&quot;,</span>
<span class="gi">+        &quot;bottom_toolbar&quot;,</span>
<span class="gi">+        &quot;style&quot;,</span>
<span class="gi">+        &quot;style_transformation&quot;,</span>
<span class="gi">+        &quot;swap_light_and_dark_colors&quot;,</span>
<span class="gi">+        &quot;color_depth&quot;,</span>
<span class="gi">+        &quot;cursor&quot;,</span>
<span class="gi">+        &quot;include_default_pygments_style&quot;,</span>
<span class="gi">+        &quot;rprompt&quot;,</span>
<span class="gi">+        &quot;multiline&quot;,</span>
<span class="gi">+        &quot;prompt_continuation&quot;,</span>
<span class="gi">+        &quot;wrap_lines&quot;,</span>
<span class="gi">+        &quot;enable_history_search&quot;,</span>
<span class="gi">+        &quot;search_ignore_case&quot;,</span>
<span class="gi">+        &quot;complete_while_typing&quot;,</span>
<span class="gi">+        &quot;validate_while_typing&quot;,</span>
<span class="gi">+        &quot;complete_style&quot;,</span>
<span class="gi">+        &quot;mouse_support&quot;,</span>
<span class="gi">+        &quot;auto_suggest&quot;,</span>
<span class="gi">+        &quot;clipboard&quot;,</span>
<span class="gi">+        &quot;validator&quot;,</span>
<span class="gi">+        &quot;refresh_interval&quot;,</span>
<span class="gi">+        &quot;input_processors&quot;,</span>
<span class="gi">+        &quot;placeholder&quot;,</span>
<span class="gi">+        &quot;enable_system_prompt&quot;,</span>
<span class="gi">+        &quot;enable_suspend&quot;,</span>
<span class="gi">+        &quot;enable_open_in_editor&quot;,</span>
<span class="gi">+        &quot;reserve_space_for_menu&quot;,</span>
<span class="gi">+        &quot;tempfile_suffix&quot;,</span>
<span class="gi">+        &quot;tempfile&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        *,</span>
<span class="gi">+        multiline: FilterOrBool = False,</span>
<span class="gi">+        wrap_lines: FilterOrBool = True,</span>
<span class="gi">+        is_password: FilterOrBool = False,</span>
<span class="gi">+        vi_mode: bool = False,</span>
<span class="gi">+        editing_mode: EditingMode = EditingMode.EMACS,</span>
<span class="gi">+        complete_while_typing: FilterOrBool = True,</span>
<span class="gi">+        validate_while_typing: FilterOrBool = True,</span>
<span class="gi">+        enable_history_search: FilterOrBool = False,</span>
<span class="gi">+        search_ignore_case: FilterOrBool = False,</span>
<span class="gi">+        lexer: Lexer | None = None,</span>
<span class="gi">+        enable_system_prompt: FilterOrBool = False,</span>
<span class="gi">+        enable_suspend: FilterOrBool = False,</span>
<span class="gi">+        enable_open_in_editor: FilterOrBool = False,</span>
<span class="gi">+        validator: Validator | None = None,</span>
<span class="gi">+        completer: Completer | None = None,</span>
<span class="gi">+        complete_in_thread: bool = False,</span>
<span class="gi">+        reserve_space_for_menu: int = 8,</span>
<span class="gi">+        complete_style: CompleteStyle = CompleteStyle.COLUMN,</span>
<span class="gi">+        auto_suggest: AutoSuggest | None = None,</span>
<span class="gi">+        style: BaseStyle | None = None,</span>
<span class="gi">+        style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+        swap_light_and_dark_colors: FilterOrBool = False,</span>
<span class="gi">+        color_depth: ColorDepth | None = None,</span>
<span class="gi">+        cursor: AnyCursorShapeConfig = None,</span>
<span class="gi">+        include_default_pygments_style: FilterOrBool = True,</span>
<span class="gi">+        history: History | None = None,</span>
<span class="gi">+        clipboard: Clipboard | None = None,</span>
<span class="gi">+        prompt_continuation: PromptContinuationText | None = None,</span>
<span class="gi">+        rprompt: AnyFormattedText = None,</span>
<span class="gi">+        bottom_toolbar: AnyFormattedText = None,</span>
<span class="gi">+        mouse_support: FilterOrBool = False,</span>
<span class="gi">+        input_processors: list[Processor] | None = None,</span>
<span class="gi">+        placeholder: AnyFormattedText | None = None,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        erase_when_done: bool = False,</span>
<span class="gi">+        tempfile_suffix: str | Callable[[], str] | None = &quot;.txt&quot;,</span>
<span class="gi">+        tempfile: str | Callable[[], str] | None = None,</span>
<span class="gi">+        refresh_interval: float = 0,</span>
<span class="gi">+        input: Input | None = None,</span>
<span class="gi">+        output: Output | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        history = history or InMemoryHistory()
<span class="w"> </span>        clipboard = clipboard or InMemoryClipboard()
<span class="gi">+</span>
<span class="gi">+        # Ensure backwards-compatibility, when `vi_mode` is passed.</span>
<span class="w"> </span>        if vi_mode:
<span class="w"> </span>            editing_mode = EditingMode.VI
<span class="gi">+</span>
<span class="gi">+        # Store all settings in this class.</span>
<span class="w"> </span>        self._input = input
<span class="w"> </span>        self._output = output
<span class="gi">+</span>
<span class="gi">+        # Store attributes.</span>
<span class="gi">+        # (All except &#39;editing_mode&#39;.)</span>
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.lexer = lexer
<span class="w"> </span>        self.completer = completer
<span class="gu">@@ -291,13 +458,15 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        self.reserve_space_for_menu = reserve_space_for_menu
<span class="w"> </span>        self.tempfile_suffix = tempfile_suffix
<span class="w"> </span>        self.tempfile = tempfile
<span class="gi">+</span>
<span class="gi">+        # Create buffers, layout and Application.</span>
<span class="w"> </span>        self.history = history
<span class="w"> </span>        self.default_buffer = self._create_default_buffer()
<span class="w"> </span>        self.search_buffer = self._create_search_buffer()
<span class="w"> </span>        self.layout = self._create_layout()
<span class="w"> </span>        self.app = self._create_application(editing_mode, erase_when_done)

<span class="gd">-    def _dyncond(self, attr_name: str) -&gt;Condition:</span>
<span class="gi">+    def _dyncond(self, attr_name: str) -&gt; Condition:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Dynamically take this setting from this &#39;PromptSession&#39; class.
<span class="w"> </span>        `attr_name` represents an attribute name of this class. Its value
<span class="gu">@@ -306,63 +475,426 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        This returns something that can be used as either a `Filter`
<span class="w"> </span>        or `Filter`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _create_default_buffer(self) -&gt;Buffer:</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def dynamic() -&gt; bool:</span>
<span class="gi">+            value = cast(FilterOrBool, getattr(self, attr_name))</span>
<span class="gi">+            return to_filter(value)()</span>
<span class="gi">+</span>
<span class="gi">+        return dynamic</span>
<span class="gi">+</span>
<span class="gi">+    def _create_default_buffer(self) -&gt; Buffer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create and return the default input buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dyncond = self._dyncond</span>
<span class="gi">+</span>
<span class="gi">+        # Create buffers list.</span>
<span class="gi">+        def accept(buff: Buffer) -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot;Accept the content of the default buffer. This is called when</span>
<span class="gi">+            the validation succeeds.&quot;&quot;&quot;</span>
<span class="gi">+            cast(Application[str], get_app()).exit(result=buff.document.text)</span>
<span class="gi">+            return True  # Keep text, we call &#39;reset&#39; later on.</span>
<span class="gi">+</span>
<span class="gi">+        return Buffer(</span>
<span class="gi">+            name=DEFAULT_BUFFER,</span>
<span class="gi">+            # Make sure that complete_while_typing is disabled when</span>
<span class="gi">+            # enable_history_search is enabled. (First convert to Filter,</span>
<span class="gi">+            # to avoid doing bitwise operations on bool objects.)</span>
<span class="gi">+            complete_while_typing=Condition(</span>
<span class="gi">+                lambda: is_true(self.complete_while_typing)</span>
<span class="gi">+                and not is_true(self.enable_history_search)</span>
<span class="gi">+                and not self.complete_style == CompleteStyle.READLINE_LIKE</span>
<span class="gi">+            ),</span>
<span class="gi">+            validate_while_typing=dyncond(&quot;validate_while_typing&quot;),</span>
<span class="gi">+            enable_history_search=dyncond(&quot;enable_history_search&quot;),</span>
<span class="gi">+            validator=DynamicValidator(lambda: self.validator),</span>
<span class="gi">+            completer=DynamicCompleter(</span>
<span class="gi">+                lambda: ThreadedCompleter(self.completer)</span>
<span class="gi">+                if self.complete_in_thread and self.completer</span>
<span class="gi">+                else self.completer</span>
<span class="gi">+            ),</span>
<span class="gi">+            history=self.history,</span>
<span class="gi">+            auto_suggest=DynamicAutoSuggest(lambda: self.auto_suggest),</span>
<span class="gi">+            accept_handler=accept,</span>
<span class="gi">+            tempfile_suffix=lambda: to_str(self.tempfile_suffix or &quot;&quot;),</span>
<span class="gi">+            tempfile=lambda: to_str(self.tempfile or &quot;&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _create_search_buffer(self) -&gt; Buffer:</span>
<span class="gi">+        return Buffer(name=SEARCH_BUFFER)</span>

<span class="gd">-    def _create_layout(self) -&gt;Layout:</span>
<span class="gi">+    def _create_layout(self) -&gt; Layout:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create `Layout` for this prompt.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dyncond = self._dyncond</span>
<span class="gi">+</span>
<span class="gi">+        # Create functions that will dynamically split the prompt. (If we have</span>
<span class="gi">+        # a multiline prompt.)</span>
<span class="gi">+        (</span>
<span class="gi">+            has_before_fragments,</span>
<span class="gi">+            get_prompt_text_1,</span>
<span class="gi">+            get_prompt_text_2,</span>
<span class="gi">+        ) = _split_multiline_prompt(self._get_prompt)</span>
<span class="gi">+</span>
<span class="gi">+        default_buffer = self.default_buffer</span>
<span class="gi">+        search_buffer = self.search_buffer</span>

<span class="gd">-    def _create_application(self, editing_mode: EditingMode,</span>
<span class="gd">-        erase_when_done: bool) -&gt;Application[_T]:</span>
<span class="gi">+        # Create processors list.</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def display_placeholder() -&gt; bool:</span>
<span class="gi">+            return self.placeholder is not None and self.default_buffer.text == &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        all_input_processors = [</span>
<span class="gi">+            HighlightIncrementalSearchProcessor(),</span>
<span class="gi">+            HighlightSelectionProcessor(),</span>
<span class="gi">+            ConditionalProcessor(</span>
<span class="gi">+                AppendAutoSuggestion(), has_focus(default_buffer) &amp; ~is_done</span>
<span class="gi">+            ),</span>
<span class="gi">+            ConditionalProcessor(PasswordProcessor(), dyncond(&quot;is_password&quot;)),</span>
<span class="gi">+            DisplayMultipleCursors(),</span>
<span class="gi">+            # Users can insert processors here.</span>
<span class="gi">+            DynamicProcessor(lambda: merge_processors(self.input_processors or [])),</span>
<span class="gi">+            ConditionalProcessor(</span>
<span class="gi">+                AfterInput(lambda: self.placeholder),</span>
<span class="gi">+                filter=display_placeholder,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Create bottom toolbars.</span>
<span class="gi">+        bottom_toolbar = ConditionalContainer(</span>
<span class="gi">+            Window(</span>
<span class="gi">+                FormattedTextControl(</span>
<span class="gi">+                    lambda: self.bottom_toolbar, style=&quot;class:bottom-toolbar.text&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+                style=&quot;class:bottom-toolbar&quot;,</span>
<span class="gi">+                dont_extend_height=True,</span>
<span class="gi">+                height=Dimension(min=1),</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=Condition(lambda: self.bottom_toolbar is not None)</span>
<span class="gi">+            &amp; ~is_done</span>
<span class="gi">+            &amp; renderer_height_is_known,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        search_toolbar = SearchToolbar(</span>
<span class="gi">+            search_buffer, ignore_case=dyncond(&quot;search_ignore_case&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        search_buffer_control = SearchBufferControl(</span>
<span class="gi">+            buffer=search_buffer,</span>
<span class="gi">+            input_processors=[ReverseSearchProcessor()],</span>
<span class="gi">+            ignore_case=dyncond(&quot;search_ignore_case&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        system_toolbar = SystemToolbar(</span>
<span class="gi">+            enable_global_bindings=dyncond(&quot;enable_system_prompt&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def get_search_buffer_control() -&gt; SearchBufferControl:</span>
<span class="gi">+            &quot;Return the UIControl to be focused when searching start.&quot;</span>
<span class="gi">+            if is_true(self.multiline):</span>
<span class="gi">+                return search_toolbar.control</span>
<span class="gi">+            else:</span>
<span class="gi">+                return search_buffer_control</span>
<span class="gi">+</span>
<span class="gi">+        default_buffer_control = BufferControl(</span>
<span class="gi">+            buffer=default_buffer,</span>
<span class="gi">+            search_buffer_control=get_search_buffer_control,</span>
<span class="gi">+            input_processors=all_input_processors,</span>
<span class="gi">+            include_default_input_processors=False,</span>
<span class="gi">+            lexer=DynamicLexer(lambda: self.lexer),</span>
<span class="gi">+            preview_search=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        default_buffer_window = Window(</span>
<span class="gi">+            default_buffer_control,</span>
<span class="gi">+            height=self._get_default_buffer_control_height,</span>
<span class="gi">+            get_line_prefix=partial(</span>
<span class="gi">+                self._get_line_prefix, get_prompt_text_2=get_prompt_text_2</span>
<span class="gi">+            ),</span>
<span class="gi">+            wrap_lines=dyncond(&quot;wrap_lines&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def multi_column_complete_style() -&gt; bool:</span>
<span class="gi">+            return self.complete_style == CompleteStyle.MULTI_COLUMN</span>
<span class="gi">+</span>
<span class="gi">+        # Build the layout.</span>
<span class="gi">+        layout = HSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                # The main input, with completion menus floating on top of it.</span>
<span class="gi">+                FloatContainer(</span>
<span class="gi">+                    HSplit(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            ConditionalContainer(</span>
<span class="gi">+                                Window(</span>
<span class="gi">+                                    FormattedTextControl(get_prompt_text_1),</span>
<span class="gi">+                                    dont_extend_height=True,</span>
<span class="gi">+                                ),</span>
<span class="gi">+                                Condition(has_before_fragments),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            ConditionalContainer(</span>
<span class="gi">+                                default_buffer_window,</span>
<span class="gi">+                                Condition(</span>
<span class="gi">+                                    lambda: get_app().layout.current_control</span>
<span class="gi">+                                    != search_buffer_control</span>
<span class="gi">+                                ),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            ConditionalContainer(</span>
<span class="gi">+                                Window(search_buffer_control),</span>
<span class="gi">+                                Condition(</span>
<span class="gi">+                                    lambda: get_app().layout.current_control</span>
<span class="gi">+                                    == search_buffer_control</span>
<span class="gi">+                                ),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    [</span>
<span class="gi">+                        # Completion menus.</span>
<span class="gi">+                        # NOTE: Especially the multi-column menu needs to be</span>
<span class="gi">+                        #       transparent, because the shape is not always</span>
<span class="gi">+                        #       rectangular due to the meta-text below the menu.</span>
<span class="gi">+                        Float(</span>
<span class="gi">+                            xcursor=True,</span>
<span class="gi">+                            ycursor=True,</span>
<span class="gi">+                            transparent=True,</span>
<span class="gi">+                            content=CompletionsMenu(</span>
<span class="gi">+                                max_height=16,</span>
<span class="gi">+                                scroll_offset=1,</span>
<span class="gi">+                                extra_filter=has_focus(default_buffer)</span>
<span class="gi">+                                &amp; ~multi_column_complete_style,</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        Float(</span>
<span class="gi">+                            xcursor=True,</span>
<span class="gi">+                            ycursor=True,</span>
<span class="gi">+                            transparent=True,</span>
<span class="gi">+                            content=MultiColumnCompletionsMenu(</span>
<span class="gi">+                                show_meta=True,</span>
<span class="gi">+                                extra_filter=has_focus(default_buffer)</span>
<span class="gi">+                                &amp; multi_column_complete_style,</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        # The right prompt.</span>
<span class="gi">+                        Float(</span>
<span class="gi">+                            right=0,</span>
<span class="gi">+                            top=0,</span>
<span class="gi">+                            hide_when_covering_content=True,</span>
<span class="gi">+                            content=_RPrompt(lambda: self.rprompt),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    ],</span>
<span class="gi">+                ),</span>
<span class="gi">+                ConditionalContainer(ValidationToolbar(), filter=~is_done),</span>
<span class="gi">+                ConditionalContainer(</span>
<span class="gi">+                    system_toolbar, dyncond(&quot;enable_system_prompt&quot;) &amp; ~is_done</span>
<span class="gi">+                ),</span>
<span class="gi">+                # In multiline mode, we use two toolbars for &#39;arg&#39; and &#39;search&#39;.</span>
<span class="gi">+                ConditionalContainer(</span>
<span class="gi">+                    Window(FormattedTextControl(self._get_arg_text), height=1),</span>
<span class="gi">+                    dyncond(&quot;multiline&quot;) &amp; has_arg,</span>
<span class="gi">+                ),</span>
<span class="gi">+                ConditionalContainer(search_toolbar, dyncond(&quot;multiline&quot;) &amp; ~is_done),</span>
<span class="gi">+                bottom_toolbar,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return Layout(layout, default_buffer_window)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_application(</span>
<span class="gi">+        self, editing_mode: EditingMode, erase_when_done: bool</span>
<span class="gi">+    ) -&gt; Application[_T]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create the `Application` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dyncond = self._dyncond</span>
<span class="gi">+</span>
<span class="gi">+        # Default key bindings.</span>
<span class="gi">+        auto_suggest_bindings = load_auto_suggest_bindings()</span>
<span class="gi">+        open_in_editor_bindings = load_open_in_editor_bindings()</span>
<span class="gi">+        prompt_bindings = self._create_prompt_bindings()</span>

<span class="gd">-    def _create_prompt_bindings(self) -&gt;KeyBindings:</span>
<span class="gi">+        # Create application</span>
<span class="gi">+        application: Application[_T] = Application(</span>
<span class="gi">+            layout=self.layout,</span>
<span class="gi">+            style=DynamicStyle(lambda: self.style),</span>
<span class="gi">+            style_transformation=merge_style_transformations(</span>
<span class="gi">+                [</span>
<span class="gi">+                    DynamicStyleTransformation(lambda: self.style_transformation),</span>
<span class="gi">+                    ConditionalStyleTransformation(</span>
<span class="gi">+                        SwapLightAndDarkStyleTransformation(),</span>
<span class="gi">+                        dyncond(&quot;swap_light_and_dark_colors&quot;),</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ]</span>
<span class="gi">+            ),</span>
<span class="gi">+            include_default_pygments_style=dyncond(&quot;include_default_pygments_style&quot;),</span>
<span class="gi">+            clipboard=DynamicClipboard(lambda: self.clipboard),</span>
<span class="gi">+            key_bindings=merge_key_bindings(</span>
<span class="gi">+                [</span>
<span class="gi">+                    merge_key_bindings(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            auto_suggest_bindings,</span>
<span class="gi">+                            ConditionalKeyBindings(</span>
<span class="gi">+                                open_in_editor_bindings,</span>
<span class="gi">+                                dyncond(&quot;enable_open_in_editor&quot;)</span>
<span class="gi">+                                &amp; has_focus(DEFAULT_BUFFER),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            prompt_bindings,</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    DynamicKeyBindings(lambda: self.key_bindings),</span>
<span class="gi">+                ]</span>
<span class="gi">+            ),</span>
<span class="gi">+            mouse_support=dyncond(&quot;mouse_support&quot;),</span>
<span class="gi">+            editing_mode=editing_mode,</span>
<span class="gi">+            erase_when_done=erase_when_done,</span>
<span class="gi">+            reverse_vi_search_direction=True,</span>
<span class="gi">+            color_depth=lambda: self.color_depth,</span>
<span class="gi">+            cursor=DynamicCursorShapeConfig(lambda: self.cursor),</span>
<span class="gi">+            refresh_interval=self.refresh_interval,</span>
<span class="gi">+            input=self._input,</span>
<span class="gi">+            output=self._output,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # During render time, make sure that we focus the right search control</span>
<span class="gi">+        # (if we are searching). - This could be useful if people make the</span>
<span class="gi">+        # &#39;multiline&#39; property dynamic.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        def on_render(app):</span>
<span class="gi">+            multiline = is_true(self.multiline)</span>
<span class="gi">+            current_control = app.layout.current_control</span>
<span class="gi">+</span>
<span class="gi">+            if multiline:</span>
<span class="gi">+                if current_control == search_buffer_control:</span>
<span class="gi">+                    app.layout.current_control = search_toolbar.control</span>
<span class="gi">+                    app.invalidate()</span>
<span class="gi">+            else:</span>
<span class="gi">+                if current_control == search_toolbar.control:</span>
<span class="gi">+                    app.layout.current_control = search_buffer_control</span>
<span class="gi">+                    app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+        app.on_render += on_render</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return application</span>
<span class="gi">+</span>
<span class="gi">+    def _create_prompt_bindings(self) -&gt; KeyBindings:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create the KeyBindings for a prompt application.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kb = KeyBindings()</span>
<span class="gi">+        handle = kb.add</span>
<span class="gi">+        default_focused = has_focus(DEFAULT_BUFFER)</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def do_accept() -&gt; bool:</span>
<span class="gi">+            return not is_true(self.multiline) and self.app.layout.has_focus(</span>
<span class="gi">+                DEFAULT_BUFFER</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;enter&quot;, filter=do_accept &amp; default_focused)</span>
<span class="gi">+        def _accept_input(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Accept input when enter has been pressed.&quot;</span>
<span class="gi">+            self.default_buffer.validate_and_handle()</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def readline_complete_style() -&gt; bool:</span>
<span class="gi">+            return self.complete_style == CompleteStyle.READLINE_LIKE</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;tab&quot;, filter=readline_complete_style &amp; default_focused)</span>
<span class="gi">+        def _complete_like_readline(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Display completions (like Readline).&quot;</span>
<span class="gi">+            display_completions_like_readline(event)</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-c&quot;, filter=default_focused)</span>
<span class="gi">+        @handle(&quot;&lt;sigint&gt;&quot;)</span>
<span class="gi">+        def _keyboard_interrupt(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Abort when Control-C has been pressed.&quot;</span>
<span class="gi">+            event.app.exit(exception=KeyboardInterrupt, style=&quot;class:aborting&quot;)</span>

<span class="gd">-    def prompt(self, message: (AnyFormattedText | None)=None, *,</span>
<span class="gd">-        editing_mode: (EditingMode | None)=None, refresh_interval: (float |</span>
<span class="gd">-        None)=None, vi_mode: (bool | None)=None, lexer: (Lexer | None)=None,</span>
<span class="gd">-        completer: (Completer | None)=None, complete_in_thread: (bool |</span>
<span class="gd">-        None)=None, is_password: (bool | None)=None, key_bindings: (</span>
<span class="gd">-        KeyBindingsBase | None)=None, bottom_toolbar: (AnyFormattedText |</span>
<span class="gd">-        None)=None, style: (BaseStyle | None)=None, color_depth: (</span>
<span class="gd">-        ColorDepth | None)=None, cursor: (AnyCursorShapeConfig | None)=None,</span>
<span class="gd">-        include_default_pygments_style: (FilterOrBool | None)=None,</span>
<span class="gd">-        style_transformation: (StyleTransformation | None)=None,</span>
<span class="gd">-        swap_light_and_dark_colors: (FilterOrBool | None)=None, rprompt: (</span>
<span class="gd">-        AnyFormattedText | None)=None, multiline: (FilterOrBool | None)=</span>
<span class="gd">-        None, prompt_continuation: (PromptContinuationText | None)=None,</span>
<span class="gd">-        wrap_lines: (FilterOrBool | None)=None, enable_history_search: (</span>
<span class="gd">-        FilterOrBool | None)=None, search_ignore_case: (FilterOrBool | None</span>
<span class="gd">-        )=None, complete_while_typing: (FilterOrBool | None)=None,</span>
<span class="gd">-        validate_while_typing: (FilterOrBool | None)=None, complete_style:</span>
<span class="gd">-        (CompleteStyle | None)=None, auto_suggest: (AutoSuggest | None)=</span>
<span class="gd">-        None, validator: (Validator | None)=None, clipboard: (Clipboard |</span>
<span class="gd">-        None)=None, mouse_support: (FilterOrBool | None)=None,</span>
<span class="gd">-        input_processors: (list[Processor] | None)=None, placeholder: (</span>
<span class="gd">-        AnyFormattedText | None)=None, reserve_space_for_menu: (int | None)</span>
<span class="gd">-        =None, enable_system_prompt: (FilterOrBool | None)=None,</span>
<span class="gd">-        enable_suspend: (FilterOrBool | None)=None, enable_open_in_editor:</span>
<span class="gd">-        (FilterOrBool | None)=None, tempfile_suffix: (str | Callable[[],</span>
<span class="gd">-        str] | None)=None, tempfile: (str | Callable[[], str] | None)=None,</span>
<span class="gd">-        default: (str | Document)=&#39;&#39;, accept_default: bool=False, pre_run:</span>
<span class="gd">-        (Callable[[], None] | None)=None, set_exception_handler: bool=True,</span>
<span class="gd">-        handle_sigint: bool=True, in_thread: bool=False, inputhook: (</span>
<span class="gd">-        InputHook | None)=None) -&gt;_T:</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def ctrl_d_condition() -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot;Ctrl-D binding is only active when the default buffer is selected</span>
<span class="gi">+            and empty.&quot;&quot;&quot;</span>
<span class="gi">+            app = get_app()</span>
<span class="gi">+            return (</span>
<span class="gi">+                app.current_buffer.name == DEFAULT_BUFFER</span>
<span class="gi">+                and not app.current_buffer.text</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-d&quot;, filter=ctrl_d_condition &amp; default_focused)</span>
<span class="gi">+        def _eof(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Exit when Control-D has been pressed.&quot;</span>
<span class="gi">+            event.app.exit(exception=EOFError, style=&quot;class:exiting&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        suspend_supported = Condition(suspend_to_background_supported)</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def enable_suspend() -&gt; bool:</span>
<span class="gi">+            return to_filter(self.enable_suspend)()</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-z&quot;, filter=suspend_supported &amp; enable_suspend)</span>
<span class="gi">+        def _suspend(event: E) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Suspend process to background.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            event.app.suspend_to_background()</span>
<span class="gi">+</span>
<span class="gi">+        return kb</span>
<span class="gi">+</span>
<span class="gi">+    def prompt(</span>
<span class="gi">+        self,</span>
<span class="gi">+        # When any of these arguments are passed, this value is overwritten</span>
<span class="gi">+        # in this PromptSession.</span>
<span class="gi">+        message: AnyFormattedText | None = None,</span>
<span class="gi">+        # `message` should go first, because people call it as</span>
<span class="gi">+        # positional argument.</span>
<span class="gi">+        *,</span>
<span class="gi">+        editing_mode: EditingMode | None = None,</span>
<span class="gi">+        refresh_interval: float | None = None,</span>
<span class="gi">+        vi_mode: bool | None = None,</span>
<span class="gi">+        lexer: Lexer | None = None,</span>
<span class="gi">+        completer: Completer | None = None,</span>
<span class="gi">+        complete_in_thread: bool | None = None,</span>
<span class="gi">+        is_password: bool | None = None,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        bottom_toolbar: AnyFormattedText | None = None,</span>
<span class="gi">+        style: BaseStyle | None = None,</span>
<span class="gi">+        color_depth: ColorDepth | None = None,</span>
<span class="gi">+        cursor: AnyCursorShapeConfig | None = None,</span>
<span class="gi">+        include_default_pygments_style: FilterOrBool | None = None,</span>
<span class="gi">+        style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+        swap_light_and_dark_colors: FilterOrBool | None = None,</span>
<span class="gi">+        rprompt: AnyFormattedText | None = None,</span>
<span class="gi">+        multiline: FilterOrBool | None = None,</span>
<span class="gi">+        prompt_continuation: PromptContinuationText | None = None,</span>
<span class="gi">+        wrap_lines: FilterOrBool | None = None,</span>
<span class="gi">+        enable_history_search: FilterOrBool | None = None,</span>
<span class="gi">+        search_ignore_case: FilterOrBool | None = None,</span>
<span class="gi">+        complete_while_typing: FilterOrBool | None = None,</span>
<span class="gi">+        validate_while_typing: FilterOrBool | None = None,</span>
<span class="gi">+        complete_style: CompleteStyle | None = None,</span>
<span class="gi">+        auto_suggest: AutoSuggest | None = None,</span>
<span class="gi">+        validator: Validator | None = None,</span>
<span class="gi">+        clipboard: Clipboard | None = None,</span>
<span class="gi">+        mouse_support: FilterOrBool | None = None,</span>
<span class="gi">+        input_processors: list[Processor] | None = None,</span>
<span class="gi">+        placeholder: AnyFormattedText | None = None,</span>
<span class="gi">+        reserve_space_for_menu: int | None = None,</span>
<span class="gi">+        enable_system_prompt: FilterOrBool | None = None,</span>
<span class="gi">+        enable_suspend: FilterOrBool | None = None,</span>
<span class="gi">+        enable_open_in_editor: FilterOrBool | None = None,</span>
<span class="gi">+        tempfile_suffix: str | Callable[[], str] | None = None,</span>
<span class="gi">+        tempfile: str | Callable[[], str] | None = None,</span>
<span class="gi">+        # Following arguments are specific to the current `prompt()` call.</span>
<span class="gi">+        default: str | Document = &quot;&quot;,</span>
<span class="gi">+        accept_default: bool = False,</span>
<span class="gi">+        pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+        set_exception_handler: bool = True,</span>
<span class="gi">+        handle_sigint: bool = True,</span>
<span class="gi">+        in_thread: bool = False,</span>
<span class="gi">+        inputhook: InputHook | None = None,</span>
<span class="gi">+    ) -&gt; _T:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Display the prompt.

<span class="gu">@@ -392,11 +924,114 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        pressed (for abort) and ``EOFError`` when control-d has been pressed
<span class="w"> </span>        (for exit).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # NOTE: We used to create a backup of the PromptSession attributes and</span>
<span class="gi">+        #       restore them after exiting the prompt. This code has been</span>
<span class="gi">+        #       removed, because it was confusing and didn&#39;t really serve a use</span>
<span class="gi">+        #       case. (People were changing `Application.editing_mode`</span>
<span class="gi">+        #       dynamically and surprised that it was reset after every call.)</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE 2: YES, this is a lot of repeation below...</span>
<span class="gi">+        #         However, it is a very convenient for a user to accept all</span>
<span class="gi">+        #         these parameters in this `prompt` method as well. We could</span>
<span class="gi">+        #         use `locals()` and `setattr` to avoid the repetition, but</span>
<span class="gi">+        #         then we loose the advantage of mypy and pyflakes to be able</span>
<span class="gi">+        #         to verify the code.</span>
<span class="gi">+        if message is not None:</span>
<span class="gi">+            self.message = message</span>
<span class="gi">+        if editing_mode is not None:</span>
<span class="gi">+            self.editing_mode = editing_mode</span>
<span class="gi">+        if refresh_interval is not None:</span>
<span class="gi">+            self.refresh_interval = refresh_interval</span>
<span class="gi">+        if vi_mode:</span>
<span class="gi">+            self.editing_mode = EditingMode.VI</span>
<span class="gi">+        if lexer is not None:</span>
<span class="gi">+            self.lexer = lexer</span>
<span class="gi">+        if completer is not None:</span>
<span class="gi">+            self.completer = completer</span>
<span class="gi">+        if complete_in_thread is not None:</span>
<span class="gi">+            self.complete_in_thread = complete_in_thread</span>
<span class="gi">+        if is_password is not None:</span>
<span class="gi">+            self.is_password = is_password</span>
<span class="gi">+        if key_bindings is not None:</span>
<span class="gi">+            self.key_bindings = key_bindings</span>
<span class="gi">+        if bottom_toolbar is not None:</span>
<span class="gi">+            self.bottom_toolbar = bottom_toolbar</span>
<span class="gi">+        if style is not None:</span>
<span class="gi">+            self.style = style</span>
<span class="gi">+        if color_depth is not None:</span>
<span class="gi">+            self.color_depth = color_depth</span>
<span class="gi">+        if cursor is not None:</span>
<span class="gi">+            self.cursor = cursor</span>
<span class="gi">+        if include_default_pygments_style is not None:</span>
<span class="gi">+            self.include_default_pygments_style = include_default_pygments_style</span>
<span class="gi">+        if style_transformation is not None:</span>
<span class="gi">+            self.style_transformation = style_transformation</span>
<span class="gi">+        if swap_light_and_dark_colors is not None:</span>
<span class="gi">+            self.swap_light_and_dark_colors = swap_light_and_dark_colors</span>
<span class="gi">+        if rprompt is not None:</span>
<span class="gi">+            self.rprompt = rprompt</span>
<span class="gi">+        if multiline is not None:</span>
<span class="gi">+            self.multiline = multiline</span>
<span class="gi">+        if prompt_continuation is not None:</span>
<span class="gi">+            self.prompt_continuation = prompt_continuation</span>
<span class="gi">+        if wrap_lines is not None:</span>
<span class="gi">+            self.wrap_lines = wrap_lines</span>
<span class="gi">+        if enable_history_search is not None:</span>
<span class="gi">+            self.enable_history_search = enable_history_search</span>
<span class="gi">+        if search_ignore_case is not None:</span>
<span class="gi">+            self.search_ignore_case = search_ignore_case</span>
<span class="gi">+        if complete_while_typing is not None:</span>
<span class="gi">+            self.complete_while_typing = complete_while_typing</span>
<span class="gi">+        if validate_while_typing is not None:</span>
<span class="gi">+            self.validate_while_typing = validate_while_typing</span>
<span class="gi">+        if complete_style is not None:</span>
<span class="gi">+            self.complete_style = complete_style</span>
<span class="gi">+        if auto_suggest is not None:</span>
<span class="gi">+            self.auto_suggest = auto_suggest</span>
<span class="gi">+        if validator is not None:</span>
<span class="gi">+            self.validator = validator</span>
<span class="gi">+        if clipboard is not None:</span>
<span class="gi">+            self.clipboard = clipboard</span>
<span class="gi">+        if mouse_support is not None:</span>
<span class="gi">+            self.mouse_support = mouse_support</span>
<span class="gi">+        if input_processors is not None:</span>
<span class="gi">+            self.input_processors = input_processors</span>
<span class="gi">+        if placeholder is not None:</span>
<span class="gi">+            self.placeholder = placeholder</span>
<span class="gi">+        if reserve_space_for_menu is not None:</span>
<span class="gi">+            self.reserve_space_for_menu = reserve_space_for_menu</span>
<span class="gi">+        if enable_system_prompt is not None:</span>
<span class="gi">+            self.enable_system_prompt = enable_system_prompt</span>
<span class="gi">+        if enable_suspend is not None:</span>
<span class="gi">+            self.enable_suspend = enable_suspend</span>
<span class="gi">+        if enable_open_in_editor is not None:</span>
<span class="gi">+            self.enable_open_in_editor = enable_open_in_editor</span>
<span class="gi">+        if tempfile_suffix is not None:</span>
<span class="gi">+            self.tempfile_suffix = tempfile_suffix</span>
<span class="gi">+        if tempfile is not None:</span>
<span class="gi">+            self.tempfile = tempfile</span>
<span class="gi">+</span>
<span class="gi">+        self._add_pre_run_callables(pre_run, accept_default)</span>
<span class="gi">+        self.default_buffer.reset(</span>
<span class="gi">+            default if isinstance(default, Document) else Document(default)</span>
<span class="gi">+        )</span>
<span class="gi">+        self.app.refresh_interval = self.refresh_interval  # This is not reactive.</span>
<span class="gi">+</span>
<span class="gi">+        # If we are using the default output, and have a dumb terminal. Use the</span>
<span class="gi">+        # dumb prompt.</span>
<span class="gi">+        if self._output is None and is_dumb_terminal():</span>
<span class="gi">+            with self._dumb_prompt(self.message) as dump_app:</span>
<span class="gi">+                return dump_app.run(in_thread=in_thread, handle_sigint=handle_sigint)</span>
<span class="gi">+</span>
<span class="gi">+        return self.app.run(</span>
<span class="gi">+            set_exception_handler=set_exception_handler,</span>
<span class="gi">+            in_thread=in_thread,</span>
<span class="gi">+            handle_sigint=handle_sigint,</span>
<span class="gi">+            inputhook=inputhook,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @contextmanager
<span class="gd">-    def _dumb_prompt(self, message: AnyFormattedText=&#39;&#39;) -&gt;Iterator[Application</span>
<span class="gd">-        [_T]]:</span>
<span class="gi">+    def _dumb_prompt(self, message: AnyFormattedText = &quot;&quot;) -&gt; Iterator[Application[_T]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create prompt `Application` for prompt function for dumb terminals.

<span class="gu">@@ -409,10 +1044,235 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        cursor movements. Instead we only print the typed character that&#39;s
<span class="w"> </span>        right before the cursor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Send prompt to output.</span>
<span class="gi">+        self.output.write(fragment_list_to_text(to_formatted_text(self.message)))</span>
<span class="gi">+        self.output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Key bindings for the dumb prompt: mostly the same as the full prompt.</span>
<span class="gi">+        key_bindings: KeyBindingsBase = self._create_prompt_bindings()</span>
<span class="gi">+        if self.key_bindings:</span>
<span class="gi">+            key_bindings = merge_key_bindings([self.key_bindings, key_bindings])</span>
<span class="gi">+</span>
<span class="gi">+        # Create and run application.</span>
<span class="gi">+        application = cast(</span>
<span class="gi">+            Application[_T],</span>
<span class="gi">+            Application(</span>
<span class="gi">+                input=self.input,</span>
<span class="gi">+                output=DummyOutput(),</span>
<span class="gi">+                layout=self.layout,</span>
<span class="gi">+                key_bindings=key_bindings,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def on_text_changed(_: object) -&gt; None:</span>
<span class="gi">+            self.output.write(self.default_buffer.document.text_before_cursor[-1:])</span>
<span class="gi">+            self.output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        self.default_buffer.on_text_changed += on_text_changed</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield application</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Render line ending.</span>
<span class="gi">+            self.output.write(&quot;\r\n&quot;)</span>
<span class="gi">+            self.output.flush()</span>
<span class="gi">+</span>
<span class="gi">+            self.default_buffer.on_text_changed -= on_text_changed</span>
<span class="gi">+</span>
<span class="gi">+    async def prompt_async(</span>
<span class="gi">+        self,</span>
<span class="gi">+        # When any of these arguments are passed, this value is overwritten</span>
<span class="gi">+        # in this PromptSession.</span>
<span class="gi">+        message: AnyFormattedText | None = None,</span>
<span class="gi">+        # `message` should go first, because people call it as</span>
<span class="gi">+        # positional argument.</span>
<span class="gi">+        *,</span>
<span class="gi">+        editing_mode: EditingMode | None = None,</span>
<span class="gi">+        refresh_interval: float | None = None,</span>
<span class="gi">+        vi_mode: bool | None = None,</span>
<span class="gi">+        lexer: Lexer | None = None,</span>
<span class="gi">+        completer: Completer | None = None,</span>
<span class="gi">+        complete_in_thread: bool | None = None,</span>
<span class="gi">+        is_password: bool | None = None,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+        bottom_toolbar: AnyFormattedText | None = None,</span>
<span class="gi">+        style: BaseStyle | None = None,</span>
<span class="gi">+        color_depth: ColorDepth | None = None,</span>
<span class="gi">+        cursor: CursorShapeConfig | None = None,</span>
<span class="gi">+        include_default_pygments_style: FilterOrBool | None = None,</span>
<span class="gi">+        style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+        swap_light_and_dark_colors: FilterOrBool | None = None,</span>
<span class="gi">+        rprompt: AnyFormattedText | None = None,</span>
<span class="gi">+        multiline: FilterOrBool | None = None,</span>
<span class="gi">+        prompt_continuation: PromptContinuationText | None = None,</span>
<span class="gi">+        wrap_lines: FilterOrBool | None = None,</span>
<span class="gi">+        enable_history_search: FilterOrBool | None = None,</span>
<span class="gi">+        search_ignore_case: FilterOrBool | None = None,</span>
<span class="gi">+        complete_while_typing: FilterOrBool | None = None,</span>
<span class="gi">+        validate_while_typing: FilterOrBool | None = None,</span>
<span class="gi">+        complete_style: CompleteStyle | None = None,</span>
<span class="gi">+        auto_suggest: AutoSuggest | None = None,</span>
<span class="gi">+        validator: Validator | None = None,</span>
<span class="gi">+        clipboard: Clipboard | None = None,</span>
<span class="gi">+        mouse_support: FilterOrBool | None = None,</span>
<span class="gi">+        input_processors: list[Processor] | None = None,</span>
<span class="gi">+        placeholder: AnyFormattedText | None = None,</span>
<span class="gi">+        reserve_space_for_menu: int | None = None,</span>
<span class="gi">+        enable_system_prompt: FilterOrBool | None = None,</span>
<span class="gi">+        enable_suspend: FilterOrBool | None = None,</span>
<span class="gi">+        enable_open_in_editor: FilterOrBool | None = None,</span>
<span class="gi">+        tempfile_suffix: str | Callable[[], str] | None = None,</span>
<span class="gi">+        tempfile: str | Callable[[], str] | None = None,</span>
<span class="gi">+        # Following arguments are specific to the current `prompt()` call.</span>
<span class="gi">+        default: str | Document = &quot;&quot;,</span>
<span class="gi">+        accept_default: bool = False,</span>
<span class="gi">+        pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+        set_exception_handler: bool = True,</span>
<span class="gi">+        handle_sigint: bool = True,</span>
<span class="gi">+    ) -&gt; _T:</span>
<span class="gi">+        if message is not None:</span>
<span class="gi">+            self.message = message</span>
<span class="gi">+        if editing_mode is not None:</span>
<span class="gi">+            self.editing_mode = editing_mode</span>
<span class="gi">+        if refresh_interval is not None:</span>
<span class="gi">+            self.refresh_interval = refresh_interval</span>
<span class="gi">+        if vi_mode:</span>
<span class="gi">+            self.editing_mode = EditingMode.VI</span>
<span class="gi">+        if lexer is not None:</span>
<span class="gi">+            self.lexer = lexer</span>
<span class="gi">+        if completer is not None:</span>
<span class="gi">+            self.completer = completer</span>
<span class="gi">+        if complete_in_thread is not None:</span>
<span class="gi">+            self.complete_in_thread = complete_in_thread</span>
<span class="gi">+        if is_password is not None:</span>
<span class="gi">+            self.is_password = is_password</span>
<span class="gi">+        if key_bindings is not None:</span>
<span class="gi">+            self.key_bindings = key_bindings</span>
<span class="gi">+        if bottom_toolbar is not None:</span>
<span class="gi">+            self.bottom_toolbar = bottom_toolbar</span>
<span class="gi">+        if style is not None:</span>
<span class="gi">+            self.style = style</span>
<span class="gi">+        if color_depth is not None:</span>
<span class="gi">+            self.color_depth = color_depth</span>
<span class="gi">+        if cursor is not None:</span>
<span class="gi">+            self.cursor = cursor</span>
<span class="gi">+        if include_default_pygments_style is not None:</span>
<span class="gi">+            self.include_default_pygments_style = include_default_pygments_style</span>
<span class="gi">+        if style_transformation is not None:</span>
<span class="gi">+            self.style_transformation = style_transformation</span>
<span class="gi">+        if swap_light_and_dark_colors is not None:</span>
<span class="gi">+            self.swap_light_and_dark_colors = swap_light_and_dark_colors</span>
<span class="gi">+        if rprompt is not None:</span>
<span class="gi">+            self.rprompt = rprompt</span>
<span class="gi">+        if multiline is not None:</span>
<span class="gi">+            self.multiline = multiline</span>
<span class="gi">+        if prompt_continuation is not None:</span>
<span class="gi">+            self.prompt_continuation = prompt_continuation</span>
<span class="gi">+        if wrap_lines is not None:</span>
<span class="gi">+            self.wrap_lines = wrap_lines</span>
<span class="gi">+        if enable_history_search is not None:</span>
<span class="gi">+            self.enable_history_search = enable_history_search</span>
<span class="gi">+        if search_ignore_case is not None:</span>
<span class="gi">+            self.search_ignore_case = search_ignore_case</span>
<span class="gi">+        if complete_while_typing is not None:</span>
<span class="gi">+            self.complete_while_typing = complete_while_typing</span>
<span class="gi">+        if validate_while_typing is not None:</span>
<span class="gi">+            self.validate_while_typing = validate_while_typing</span>
<span class="gi">+        if complete_style is not None:</span>
<span class="gi">+            self.complete_style = complete_style</span>
<span class="gi">+        if auto_suggest is not None:</span>
<span class="gi">+            self.auto_suggest = auto_suggest</span>
<span class="gi">+        if validator is not None:</span>
<span class="gi">+            self.validator = validator</span>
<span class="gi">+        if clipboard is not None:</span>
<span class="gi">+            self.clipboard = clipboard</span>
<span class="gi">+        if mouse_support is not None:</span>
<span class="gi">+            self.mouse_support = mouse_support</span>
<span class="gi">+        if input_processors is not None:</span>
<span class="gi">+            self.input_processors = input_processors</span>
<span class="gi">+        if placeholder is not None:</span>
<span class="gi">+            self.placeholder = placeholder</span>
<span class="gi">+        if reserve_space_for_menu is not None:</span>
<span class="gi">+            self.reserve_space_for_menu = reserve_space_for_menu</span>
<span class="gi">+        if enable_system_prompt is not None:</span>
<span class="gi">+            self.enable_system_prompt = enable_system_prompt</span>
<span class="gi">+        if enable_suspend is not None:</span>
<span class="gi">+            self.enable_suspend = enable_suspend</span>
<span class="gi">+        if enable_open_in_editor is not None:</span>
<span class="gi">+            self.enable_open_in_editor = enable_open_in_editor</span>
<span class="gi">+        if tempfile_suffix is not None:</span>
<span class="gi">+            self.tempfile_suffix = tempfile_suffix</span>
<span class="gi">+        if tempfile is not None:</span>
<span class="gi">+            self.tempfile = tempfile</span>
<span class="gi">+</span>
<span class="gi">+        self._add_pre_run_callables(pre_run, accept_default)</span>
<span class="gi">+        self.default_buffer.reset(</span>
<span class="gi">+            default if isinstance(default, Document) else Document(default)</span>
<span class="gi">+        )</span>
<span class="gi">+        self.app.refresh_interval = self.refresh_interval  # This is not reactive.</span>
<span class="gi">+</span>
<span class="gi">+        # If we are using the default output, and have a dumb terminal. Use the</span>
<span class="gi">+        # dumb prompt.</span>
<span class="gi">+        if self._output is None and is_dumb_terminal():</span>
<span class="gi">+            with self._dumb_prompt(self.message) as dump_app:</span>
<span class="gi">+                return await dump_app.run_async(handle_sigint=handle_sigint)</span>
<span class="gi">+</span>
<span class="gi">+        return await self.app.run_async(</span>
<span class="gi">+            set_exception_handler=set_exception_handler, handle_sigint=handle_sigint</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _add_pre_run_callables(</span>
<span class="gi">+        self, pre_run: Callable[[], None] | None, accept_default: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        def pre_run2() -&gt; None:</span>
<span class="gi">+            if pre_run:</span>
<span class="gi">+                pre_run()</span>
<span class="gi">+</span>
<span class="gi">+            if accept_default:</span>
<span class="gi">+                # Validate and handle input. We use `call_from_executor` in</span>
<span class="gi">+                # order to run it &quot;soon&quot; (during the next iteration of the</span>
<span class="gi">+                # event loop), instead of right now. Otherwise, it won&#39;t</span>
<span class="gi">+                # display the default value.</span>
<span class="gi">+                get_running_loop().call_soon(self.default_buffer.validate_and_handle)</span>
<span class="gi">+</span>
<span class="gi">+        self.app.pre_run_callables.append(pre_run2)</span>

<span class="gd">-    def _get_continuation(self, width: int, line_number: int, wrap_count: int</span>
<span class="gd">-        ) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def editing_mode(self) -&gt; EditingMode:</span>
<span class="gi">+        return self.app.editing_mode</span>
<span class="gi">+</span>
<span class="gi">+    @editing_mode.setter</span>
<span class="gi">+    def editing_mode(self, value: EditingMode) -&gt; None:</span>
<span class="gi">+        self.app.editing_mode = value</span>
<span class="gi">+</span>
<span class="gi">+    def _get_default_buffer_control_height(self) -&gt; Dimension:</span>
<span class="gi">+        # If there is an autocompletion menu to be shown, make sure that our</span>
<span class="gi">+        # layout has at least a minimal height in order to display it.</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.completer is not None</span>
<span class="gi">+            and self.complete_style != CompleteStyle.READLINE_LIKE</span>
<span class="gi">+        ):</span>
<span class="gi">+            space = self.reserve_space_for_menu</span>
<span class="gi">+        else:</span>
<span class="gi">+            space = 0</span>
<span class="gi">+</span>
<span class="gi">+        if space and not get_app().is_done:</span>
<span class="gi">+            buff = self.default_buffer</span>
<span class="gi">+</span>
<span class="gi">+            # Reserve the space, either when there are completions, or when</span>
<span class="gi">+            # `complete_while_typing` is true and we expect completions very</span>
<span class="gi">+            # soon.</span>
<span class="gi">+            if buff.complete_while_typing() or buff.complete_state is not None:</span>
<span class="gi">+                return Dimension(min=space)</span>
<span class="gi">+</span>
<span class="gi">+        return Dimension()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_prompt(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        return to_formatted_text(self.message, style=&quot;class:prompt&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_continuation(</span>
<span class="gi">+        self, width: int, line_number: int, wrap_count: int</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert the prompt continuation.

<span class="gu">@@ -421,74 +1281,224 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        :param line_number:
<span class="w"> </span>        :param wrap_count: Amount of times that the line has been wrapped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prompt_continuation = self.prompt_continuation</span>
<span class="gi">+</span>
<span class="gi">+        if callable(prompt_continuation):</span>
<span class="gi">+            continuation: AnyFormattedText = prompt_continuation(</span>
<span class="gi">+                width, line_number, wrap_count</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            continuation = prompt_continuation</span>
<span class="gi">+</span>
<span class="gi">+        # When the continuation prompt is not given, choose the same width as</span>
<span class="gi">+        # the actual prompt.</span>
<span class="gi">+        if continuation is None and is_true(self.multiline):</span>
<span class="gi">+            continuation = &quot; &quot; * width</span>
<span class="gi">+</span>
<span class="gi">+        return to_formatted_text(continuation, style=&quot;class:prompt-continuation&quot;)</span>

<span class="gd">-    def _get_line_prefix(self, line_number: int, wrap_count: int,</span>
<span class="gd">-        get_prompt_text_2: _StyleAndTextTuplesCallable) -&gt;StyleAndTextTuples:</span>
<span class="gi">+    def _get_line_prefix(</span>
<span class="gi">+        self,</span>
<span class="gi">+        line_number: int,</span>
<span class="gi">+        wrap_count: int,</span>
<span class="gi">+        get_prompt_text_2: _StyleAndTextTuplesCallable,</span>
<span class="gi">+    ) -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return whatever needs to be inserted before every line.
<span class="w"> </span>        (the prompt, or a line continuation.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First line: display the &quot;arg&quot; or the prompt.</span>
<span class="gi">+        if line_number == 0 and wrap_count == 0:</span>
<span class="gi">+            if not is_true(self.multiline) and get_app().key_processor.arg is not None:</span>
<span class="gi">+                return self._inline_arg()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return get_prompt_text_2()</span>

<span class="gd">-    def _get_arg_text(self) -&gt;StyleAndTextTuples:</span>
<span class="gd">-        &quot;&quot;&quot;&#39;arg&#39; toolbar, for in multiline mode.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        # For the next lines, display the appropriate continuation.</span>
<span class="gi">+        prompt_width = get_cwidth(fragment_list_to_text(get_prompt_text_2()))</span>
<span class="gi">+        return self._get_continuation(prompt_width, line_number, wrap_count)</span>

<span class="gd">-    def _inline_arg(self) -&gt;StyleAndTextTuples:</span>
<span class="gd">-        &quot;&quot;&quot;&#39;arg&#39; prefix, for in single line mode.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _get_arg_text(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        &quot;&#39;arg&#39; toolbar, for in multiline mode.&quot;</span>
<span class="gi">+        arg = self.app.key_processor.arg</span>
<span class="gi">+        if arg is None:</span>
<span class="gi">+            # Should not happen because of the `has_arg` filter in the layout.</span>
<span class="gi">+            return []</span>

<span class="gi">+        if arg == &quot;-&quot;:</span>
<span class="gi">+            arg = &quot;-1&quot;</span>

<span class="gd">-def prompt(message: (AnyFormattedText | None)=None, *, history: (History |</span>
<span class="gd">-    None)=None, editing_mode: (EditingMode | None)=None, refresh_interval:</span>
<span class="gd">-    (float | None)=None, vi_mode: (bool | None)=None, lexer: (Lexer | None)</span>
<span class="gd">-    =None, completer: (Completer | None)=None, complete_in_thread: (bool |</span>
<span class="gd">-    None)=None, is_password: (bool | None)=None, key_bindings: (</span>
<span class="gd">-    KeyBindingsBase | None)=None, bottom_toolbar: (AnyFormattedText | None)</span>
<span class="gd">-    =None, style: (BaseStyle | None)=None, color_depth: (ColorDepth | None)</span>
<span class="gd">-    =None, cursor: AnyCursorShapeConfig=None,</span>
<span class="gd">-    include_default_pygments_style: (FilterOrBool | None)=None,</span>
<span class="gd">-    style_transformation: (StyleTransformation | None)=None,</span>
<span class="gd">-    swap_light_and_dark_colors: (FilterOrBool | None)=None, rprompt: (</span>
<span class="gd">-    AnyFormattedText | None)=None, multiline: (FilterOrBool | None)=None,</span>
<span class="gd">-    prompt_continuation: (PromptContinuationText | None)=None, wrap_lines:</span>
<span class="gd">-    (FilterOrBool | None)=None, enable_history_search: (FilterOrBool | None</span>
<span class="gd">-    )=None, search_ignore_case: (FilterOrBool | None)=None,</span>
<span class="gd">-    complete_while_typing: (FilterOrBool | None)=None,</span>
<span class="gd">-    validate_while_typing: (FilterOrBool | None)=None, complete_style: (</span>
<span class="gd">-    CompleteStyle | None)=None, auto_suggest: (AutoSuggest | None)=None,</span>
<span class="gd">-    validator: (Validator | None)=None, clipboard: (Clipboard | None)=None,</span>
<span class="gd">-    mouse_support: (FilterOrBool | None)=None, input_processors: (list[</span>
<span class="gd">-    Processor] | None)=None, placeholder: (AnyFormattedText | None)=None,</span>
<span class="gd">-    reserve_space_for_menu: (int | None)=None, enable_system_prompt: (</span>
<span class="gd">-    FilterOrBool | None)=None, enable_suspend: (FilterOrBool | None)=None,</span>
<span class="gd">-    enable_open_in_editor: (FilterOrBool | None)=None, tempfile_suffix: (</span>
<span class="gd">-    str | Callable[[], str] | None)=None, tempfile: (str | Callable[[], str</span>
<span class="gd">-    ] | None)=None, default: str=&#39;&#39;, accept_default: bool=False, pre_run: (</span>
<span class="gd">-    Callable[[], None] | None)=None, set_exception_handler: bool=True,</span>
<span class="gd">-    handle_sigint: bool=True, in_thread: bool=False, inputhook: (InputHook |</span>
<span class="gd">-    None)=None) -&gt;str:</span>
<span class="gi">+        return [(&quot;class:arg-toolbar&quot;, &quot;Repeat: &quot;), (&quot;class:arg-toolbar.text&quot;, arg)]</span>
<span class="gi">+</span>
<span class="gi">+    def _inline_arg(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        &quot;&#39;arg&#39; prefix, for in single line mode.&quot;</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        if app.key_processor.arg is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            arg = app.key_processor.arg</span>
<span class="gi">+</span>
<span class="gi">+            return [</span>
<span class="gi">+                (&quot;class:prompt.arg&quot;, &quot;(arg: &quot;),</span>
<span class="gi">+                (&quot;class:prompt.arg.text&quot;, str(arg)),</span>
<span class="gi">+                (&quot;class:prompt.arg&quot;, &quot;) &quot;),</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+    # Expose the Input and Output objects as attributes, mainly for</span>
<span class="gi">+    # backward-compatibility.</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def input(self) -&gt; Input:</span>
<span class="gi">+        return self.app.input</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def output(self) -&gt; Output:</span>
<span class="gi">+        return self.app.output</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prompt(</span>
<span class="gi">+    message: AnyFormattedText | None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    history: History | None = None,</span>
<span class="gi">+    editing_mode: EditingMode | None = None,</span>
<span class="gi">+    refresh_interval: float | None = None,</span>
<span class="gi">+    vi_mode: bool | None = None,</span>
<span class="gi">+    lexer: Lexer | None = None,</span>
<span class="gi">+    completer: Completer | None = None,</span>
<span class="gi">+    complete_in_thread: bool | None = None,</span>
<span class="gi">+    is_password: bool | None = None,</span>
<span class="gi">+    key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+    bottom_toolbar: AnyFormattedText | None = None,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+    color_depth: ColorDepth | None = None,</span>
<span class="gi">+    cursor: AnyCursorShapeConfig = None,</span>
<span class="gi">+    include_default_pygments_style: FilterOrBool | None = None,</span>
<span class="gi">+    style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+    swap_light_and_dark_colors: FilterOrBool | None = None,</span>
<span class="gi">+    rprompt: AnyFormattedText | None = None,</span>
<span class="gi">+    multiline: FilterOrBool | None = None,</span>
<span class="gi">+    prompt_continuation: PromptContinuationText | None = None,</span>
<span class="gi">+    wrap_lines: FilterOrBool | None = None,</span>
<span class="gi">+    enable_history_search: FilterOrBool | None = None,</span>
<span class="gi">+    search_ignore_case: FilterOrBool | None = None,</span>
<span class="gi">+    complete_while_typing: FilterOrBool | None = None,</span>
<span class="gi">+    validate_while_typing: FilterOrBool | None = None,</span>
<span class="gi">+    complete_style: CompleteStyle | None = None,</span>
<span class="gi">+    auto_suggest: AutoSuggest | None = None,</span>
<span class="gi">+    validator: Validator | None = None,</span>
<span class="gi">+    clipboard: Clipboard | None = None,</span>
<span class="gi">+    mouse_support: FilterOrBool | None = None,</span>
<span class="gi">+    input_processors: list[Processor] | None = None,</span>
<span class="gi">+    placeholder: AnyFormattedText | None = None,</span>
<span class="gi">+    reserve_space_for_menu: int | None = None,</span>
<span class="gi">+    enable_system_prompt: FilterOrBool | None = None,</span>
<span class="gi">+    enable_suspend: FilterOrBool | None = None,</span>
<span class="gi">+    enable_open_in_editor: FilterOrBool | None = None,</span>
<span class="gi">+    tempfile_suffix: str | Callable[[], str] | None = None,</span>
<span class="gi">+    tempfile: str | Callable[[], str] | None = None,</span>
<span class="gi">+    # Following arguments are specific to the current `prompt()` call.</span>
<span class="gi">+    default: str = &quot;&quot;,</span>
<span class="gi">+    accept_default: bool = False,</span>
<span class="gi">+    pre_run: Callable[[], None] | None = None,</span>
<span class="gi">+    set_exception_handler: bool = True,</span>
<span class="gi">+    handle_sigint: bool = True,</span>
<span class="gi">+    in_thread: bool = False,</span>
<span class="gi">+    inputhook: InputHook | None = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The global `prompt` function. This will create a new `PromptSession`
<span class="w"> </span>    instance for every call.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The history is the only attribute that has to be passed to the</span>
<span class="gi">+    # `PromptSession`, it can&#39;t be passed into the `prompt()` method.</span>
<span class="gi">+    session: PromptSession[str] = PromptSession(history=history)</span>
<span class="gi">+</span>
<span class="gi">+    return session.prompt(</span>
<span class="gi">+        message,</span>
<span class="gi">+        editing_mode=editing_mode,</span>
<span class="gi">+        refresh_interval=refresh_interval,</span>
<span class="gi">+        vi_mode=vi_mode,</span>
<span class="gi">+        lexer=lexer,</span>
<span class="gi">+        completer=completer,</span>
<span class="gi">+        complete_in_thread=complete_in_thread,</span>
<span class="gi">+        is_password=is_password,</span>
<span class="gi">+        key_bindings=key_bindings,</span>
<span class="gi">+        bottom_toolbar=bottom_toolbar,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        color_depth=color_depth,</span>
<span class="gi">+        cursor=cursor,</span>
<span class="gi">+        include_default_pygments_style=include_default_pygments_style,</span>
<span class="gi">+        style_transformation=style_transformation,</span>
<span class="gi">+        swap_light_and_dark_colors=swap_light_and_dark_colors,</span>
<span class="gi">+        rprompt=rprompt,</span>
<span class="gi">+        multiline=multiline,</span>
<span class="gi">+        prompt_continuation=prompt_continuation,</span>
<span class="gi">+        wrap_lines=wrap_lines,</span>
<span class="gi">+        enable_history_search=enable_history_search,</span>
<span class="gi">+        search_ignore_case=search_ignore_case,</span>
<span class="gi">+        complete_while_typing=complete_while_typing,</span>
<span class="gi">+        validate_while_typing=validate_while_typing,</span>
<span class="gi">+        complete_style=complete_style,</span>
<span class="gi">+        auto_suggest=auto_suggest,</span>
<span class="gi">+        validator=validator,</span>
<span class="gi">+        clipboard=clipboard,</span>
<span class="gi">+        mouse_support=mouse_support,</span>
<span class="gi">+        input_processors=input_processors,</span>
<span class="gi">+        placeholder=placeholder,</span>
<span class="gi">+        reserve_space_for_menu=reserve_space_for_menu,</span>
<span class="gi">+        enable_system_prompt=enable_system_prompt,</span>
<span class="gi">+        enable_suspend=enable_suspend,</span>
<span class="gi">+        enable_open_in_editor=enable_open_in_editor,</span>
<span class="gi">+        tempfile_suffix=tempfile_suffix,</span>
<span class="gi">+        tempfile=tempfile,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+        accept_default=accept_default,</span>
<span class="gi">+        pre_run=pre_run,</span>
<span class="gi">+        set_exception_handler=set_exception_handler,</span>
<span class="gi">+        handle_sigint=handle_sigint,</span>
<span class="gi">+        in_thread=in_thread,</span>
<span class="gi">+        inputhook=inputhook,</span>
<span class="gi">+    )</span>


<span class="w"> </span>prompt.__doc__ = PromptSession.prompt.__doc__


<span class="gd">-def create_confirm_session(message: str, suffix: str=&#39; (y/n) &#39;</span>
<span class="gd">-    ) -&gt;PromptSession[bool]:</span>
<span class="gi">+def create_confirm_session(</span>
<span class="gi">+    message: str, suffix: str = &quot; (y/n) &quot;</span>
<span class="gi">+) -&gt; PromptSession[bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `PromptSession` object for the &#39;confirm&#39; function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(&quot;y&quot;)</span>
<span class="gi">+    @bindings.add(&quot;Y&quot;)</span>
<span class="gi">+    def yes(event: E) -&gt; None:</span>
<span class="gi">+        session.default_buffer.text = &quot;y&quot;</span>
<span class="gi">+        event.app.exit(result=True)</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(&quot;n&quot;)</span>
<span class="gi">+    @bindings.add(&quot;N&quot;)</span>
<span class="gi">+    def no(event: E) -&gt; None:</span>
<span class="gi">+        session.default_buffer.text = &quot;n&quot;</span>
<span class="gi">+        event.app.exit(result=False)</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(Keys.Any)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;Disallow inserting other text.&quot;</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    complete_message = merge_formatted_text([message, suffix])</span>
<span class="gi">+    session: PromptSession[bool] = PromptSession(</span>
<span class="gi">+        complete_message, key_bindings=bindings</span>
<span class="gi">+    )</span>
<span class="gi">+    return session</span>


<span class="gd">-def confirm(message: str=&#39;Confirm?&#39;, suffix: str=&#39; (y/n) &#39;) -&gt;bool:</span>
<span class="gi">+def confirm(message: str = &quot;Confirm?&quot;, suffix: str = &quot; (y/n) &quot;) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a confirmation prompt that returns True/False.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    session = create_confirm_session(message, suffix)</span>
<span class="gi">+    return session.prompt()</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/utils.py b/src/prompt_toolkit/shortcuts/utils.py</span>
<span class="gh">index 44028b38..abf4fd2a 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/utils.py</span>
<span class="gu">@@ -1,27 +1,55 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from asyncio.events import AbstractEventLoop
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application import Application
<span class="w"> </span>from prompt_toolkit.application.current import get_app_or_none, get_app_session
<span class="w"> </span>from prompt_toolkit.application.run_in_terminal import run_in_terminal
<span class="gd">-from prompt_toolkit.formatted_text import FormattedText, StyleAndTextTuples, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    FormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.input import DummyInput
<span class="w"> </span>from prompt_toolkit.layout import Layout
<span class="w"> </span>from prompt_toolkit.output import ColorDepth, Output
<span class="w"> </span>from prompt_toolkit.output.defaults import create_output
<span class="gd">-from prompt_toolkit.renderer import print_formatted_text as renderer_print_formatted_text</span>
<span class="gd">-from prompt_toolkit.styles import BaseStyle, StyleTransformation, default_pygments_style, default_ui_style, merge_styles</span>
<span class="gi">+from prompt_toolkit.renderer import (</span>
<span class="gi">+    print_formatted_text as renderer_print_formatted_text,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.styles import (</span>
<span class="gi">+    BaseStyle,</span>
<span class="gi">+    StyleTransformation,</span>
<span class="gi">+    default_pygments_style,</span>
<span class="gi">+    default_ui_style,</span>
<span class="gi">+    merge_styles,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from prompt_toolkit.layout.containers import AnyContainer
<span class="gd">-__all__ = [&#39;print_formatted_text&#39;, &#39;print_container&#39;, &#39;clear&#39;, &#39;set_title&#39;,</span>
<span class="gd">-    &#39;clear_title&#39;]</span>

<span class="gd">-</span>
<span class="gd">-def print_formatted_text(*values: Any, sep: str=&#39; &#39;, end: str=&#39;\n&#39;, file: (</span>
<span class="gd">-    TextIO | None)=None, flush: bool=False, style: (BaseStyle | None)=None,</span>
<span class="gd">-    output: (Output | None)=None, color_depth: (ColorDepth | None)=None,</span>
<span class="gd">-    style_transformation: (StyleTransformation | None)=None,</span>
<span class="gd">-    include_default_pygments_style: bool=True) -&gt;None:</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;print_formatted_text&quot;,</span>
<span class="gi">+    &quot;print_container&quot;,</span>
<span class="gi">+    &quot;clear&quot;,</span>
<span class="gi">+    &quot;set_title&quot;,</span>
<span class="gi">+    &quot;clear_title&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def print_formatted_text(</span>
<span class="gi">+    *values: Any,</span>
<span class="gi">+    sep: str = &quot; &quot;,</span>
<span class="gi">+    end: str = &quot;\n&quot;,</span>
<span class="gi">+    file: TextIO | None = None,</span>
<span class="gi">+    flush: bool = False,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+    output: Output | None = None,</span>
<span class="gi">+    color_depth: ColorDepth | None = None,</span>
<span class="gi">+    style_transformation: StyleTransformation | None = None,</span>
<span class="gi">+    include_default_pygments_style: bool = True,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    ::

<span class="gu">@@ -73,12 +101,75 @@ def print_formatted_text(*values: Any, sep: str=&#39; &#39;, end: str=&#39;\n&#39;, file: (</span>
<span class="w"> </span>    :param include_default_pygments_style: `bool`. Include the default Pygments
<span class="w"> </span>        style when set to `True` (the default).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def print_container(container: AnyContainer, file: (TextIO | None)=None,</span>
<span class="gd">-    style: (BaseStyle | None)=None, include_default_pygments_style: bool=True</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+    assert not (output and file)</span>
<span class="gi">+</span>
<span class="gi">+    # Create Output object.</span>
<span class="gi">+    if output is None:</span>
<span class="gi">+        if file:</span>
<span class="gi">+            output = create_output(stdout=file)</span>
<span class="gi">+        else:</span>
<span class="gi">+            output = get_app_session().output</span>
<span class="gi">+</span>
<span class="gi">+    assert isinstance(output, Output)</span>
<span class="gi">+</span>
<span class="gi">+    # Get color depth.</span>
<span class="gi">+    color_depth = color_depth or output.get_default_color_depth()</span>
<span class="gi">+</span>
<span class="gi">+    # Merges values.</span>
<span class="gi">+    def to_text(val: Any) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        # Normal lists which are not instances of `FormattedText` are</span>
<span class="gi">+        # considered plain text.</span>
<span class="gi">+        if isinstance(val, list) and not isinstance(val, FormattedText):</span>
<span class="gi">+            return to_formatted_text(f&quot;{val}&quot;)</span>
<span class="gi">+        return to_formatted_text(val, auto_convert=True)</span>
<span class="gi">+</span>
<span class="gi">+    fragments = []</span>
<span class="gi">+    for i, value in enumerate(values):</span>
<span class="gi">+        fragments.extend(to_text(value))</span>
<span class="gi">+</span>
<span class="gi">+        if sep and i != len(values) - 1:</span>
<span class="gi">+            fragments.extend(to_text(sep))</span>
<span class="gi">+</span>
<span class="gi">+    fragments.extend(to_text(end))</span>
<span class="gi">+</span>
<span class="gi">+    # Print output.</span>
<span class="gi">+    def render() -&gt; None:</span>
<span class="gi">+        assert isinstance(output, Output)</span>
<span class="gi">+</span>
<span class="gi">+        renderer_print_formatted_text(</span>
<span class="gi">+            output,</span>
<span class="gi">+            fragments,</span>
<span class="gi">+            _create_merged_style(</span>
<span class="gi">+                style, include_default_pygments_style=include_default_pygments_style</span>
<span class="gi">+            ),</span>
<span class="gi">+            color_depth=color_depth,</span>
<span class="gi">+            style_transformation=style_transformation,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Flush the output stream.</span>
<span class="gi">+        if flush:</span>
<span class="gi">+            output.flush()</span>
<span class="gi">+</span>
<span class="gi">+    # If an application is running, print above the app. This does not require</span>
<span class="gi">+    # `patch_stdout`.</span>
<span class="gi">+    loop: AbstractEventLoop | None = None</span>
<span class="gi">+</span>
<span class="gi">+    app = get_app_or_none()</span>
<span class="gi">+    if app is not None:</span>
<span class="gi">+        loop = app.loop</span>
<span class="gi">+</span>
<span class="gi">+    if loop is not None:</span>
<span class="gi">+        loop.call_soon_threadsafe(lambda: run_in_terminal(render))</span>
<span class="gi">+    else:</span>
<span class="gi">+        render()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def print_container(</span>
<span class="gi">+    container: AnyContainer,</span>
<span class="gi">+    file: TextIO | None = None,</span>
<span class="gi">+    style: BaseStyle | None = None,</span>
<span class="gi">+    include_default_pygments_style: bool = True,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Print any layout to the output in a non-interactive way.

<span class="gu">@@ -88,33 +179,61 @@ def print_container(container: AnyContainer, file: (TextIO | None)=None,</span>
<span class="w"> </span>        print_container(
<span class="w"> </span>            Frame(TextArea(text=&#39;Hello world!&#39;)))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _create_merged_style(style: (BaseStyle | None),</span>
<span class="gd">-    include_default_pygments_style: bool) -&gt;BaseStyle:</span>
<span class="gi">+    if file:</span>
<span class="gi">+        output = create_output(stdout=file)</span>
<span class="gi">+    else:</span>
<span class="gi">+        output = get_app_session().output</span>
<span class="gi">+</span>
<span class="gi">+    app: Application[None] = Application(</span>
<span class="gi">+        layout=Layout(container=container),</span>
<span class="gi">+        output=output,</span>
<span class="gi">+        # `DummyInput` will cause the application to terminate immediately.</span>
<span class="gi">+        input=DummyInput(),</span>
<span class="gi">+        style=_create_merged_style(</span>
<span class="gi">+            style, include_default_pygments_style=include_default_pygments_style</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    try:</span>
<span class="gi">+        app.run(in_thread=True)</span>
<span class="gi">+    except EOFError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_merged_style(</span>
<span class="gi">+    style: BaseStyle | None, include_default_pygments_style: bool</span>
<span class="gi">+) -&gt; BaseStyle:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge user defined style with built-in style.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    styles = [default_ui_style()]</span>
<span class="gi">+    if include_default_pygments_style:</span>
<span class="gi">+        styles.append(default_pygments_style())</span>
<span class="gi">+    if style:</span>
<span class="gi">+        styles.append(style)</span>
<span class="gi">+</span>
<span class="gi">+    return merge_styles(styles)</span>


<span class="gd">-def clear() -&gt;None:</span>
<span class="gi">+def clear() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clear the screen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = get_app_session().output</span>
<span class="gi">+    output.erase_screen()</span>
<span class="gi">+    output.cursor_goto(0, 0)</span>
<span class="gi">+    output.flush()</span>


<span class="gd">-def set_title(text: str) -&gt;None:</span>
<span class="gi">+def set_title(text: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Set the terminal title.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = get_app_session().output</span>
<span class="gi">+    output.set_title(text)</span>


<span class="gd">-def clear_title() -&gt;None:</span>
<span class="gi">+def clear_title() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Erase the current title.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    set_title(&quot;&quot;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/base.py b/src/prompt_toolkit/styles/base.py</span>
<span class="gh">index a78d7080..b50f3b0e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/base.py</span>
<span class="gu">@@ -2,12 +2,22 @@</span>
<span class="w"> </span>The base classes for the styling.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod, abstractproperty
<span class="w"> </span>from typing import Callable, Hashable, NamedTuple
<span class="gd">-__all__ = [&#39;Attrs&#39;, &#39;DEFAULT_ATTRS&#39;, &#39;ANSI_COLOR_NAMES&#39;,</span>
<span class="gd">-    &#39;ANSI_COLOR_NAMES_ALIASES&#39;, &#39;BaseStyle&#39;, &#39;DummyStyle&#39;, &#39;DynamicStyle&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Attrs&quot;,</span>
<span class="gi">+    &quot;DEFAULT_ATTRS&quot;,</span>
<span class="gi">+    &quot;ANSI_COLOR_NAMES&quot;,</span>
<span class="gi">+    &quot;ANSI_COLOR_NAMES_ALIASES&quot;,</span>
<span class="gi">+    &quot;BaseStyle&quot;,</span>
<span class="gi">+    &quot;DummyStyle&quot;,</span>
<span class="gi">+    &quot;DynamicStyle&quot;,</span>
<span class="gi">+]</span>


<span class="gi">+#: Style attributes.</span>
<span class="w"> </span>class Attrs(NamedTuple):
<span class="w"> </span>    color: str | None
<span class="w"> </span>    bgcolor: str | None
<span class="gu">@@ -31,21 +41,68 @@ class Attrs(NamedTuple):</span>
<span class="w"> </span>:param reverse: Boolean
<span class="w"> </span>:param hidden: Boolean
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-DEFAULT_ATTRS = Attrs(color=&#39;&#39;, bgcolor=&#39;&#39;, bold=False, underline=False,</span>
<span class="gd">-    strike=False, italic=False, blink=False, reverse=False, hidden=False)</span>
<span class="gd">-ANSI_COLOR_NAMES = [&#39;ansidefault&#39;, &#39;ansiblack&#39;, &#39;ansired&#39;, &#39;ansigreen&#39;,</span>
<span class="gd">-    &#39;ansiyellow&#39;, &#39;ansiblue&#39;, &#39;ansimagenta&#39;, &#39;ansicyan&#39;, &#39;ansigray&#39;,</span>
<span class="gd">-    &#39;ansibrightblack&#39;, &#39;ansibrightred&#39;, &#39;ansibrightgreen&#39;,</span>
<span class="gd">-    &#39;ansibrightyellow&#39;, &#39;ansibrightblue&#39;, &#39;ansibrightmagenta&#39;,</span>
<span class="gd">-    &#39;ansibrightcyan&#39;, &#39;ansiwhite&#39;]</span>
<span class="gd">-ANSI_COLOR_NAMES_ALIASES: dict[str, str] = {&#39;ansidarkgray&#39;:</span>
<span class="gd">-    &#39;ansibrightblack&#39;, &#39;ansiteal&#39;: &#39;ansicyan&#39;, &#39;ansiturquoise&#39;:</span>
<span class="gd">-    &#39;ansibrightcyan&#39;, &#39;ansibrown&#39;: &#39;ansiyellow&#39;, &#39;ansipurple&#39;:</span>
<span class="gd">-    &#39;ansimagenta&#39;, &#39;ansifuchsia&#39;: &#39;ansibrightmagenta&#39;, &#39;ansilightgray&#39;:</span>
<span class="gd">-    &#39;ansigray&#39;, &#39;ansidarkred&#39;: &#39;ansired&#39;, &#39;ansidarkgreen&#39;: &#39;ansigreen&#39;,</span>
<span class="gd">-    &#39;ansidarkblue&#39;: &#39;ansiblue&#39;}</span>
<span class="gi">+</span>
<span class="gi">+#: The default `Attrs`.</span>
<span class="gi">+DEFAULT_ATTRS = Attrs(</span>
<span class="gi">+    color=&quot;&quot;,</span>
<span class="gi">+    bgcolor=&quot;&quot;,</span>
<span class="gi">+    bold=False,</span>
<span class="gi">+    underline=False,</span>
<span class="gi">+    strike=False,</span>
<span class="gi">+    italic=False,</span>
<span class="gi">+    blink=False,</span>
<span class="gi">+    reverse=False,</span>
<span class="gi">+    hidden=False,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: ``Attrs.bgcolor/fgcolor`` can be in either &#39;ffffff&#39; format, or can be any of</span>
<span class="gi">+#: the following in case we want to take colors from the 8/16 color palette.</span>
<span class="gi">+#: Usually, in that case, the terminal application allows to configure the RGB</span>
<span class="gi">+#: values for these names.</span>
<span class="gi">+#: ISO 6429 colors</span>
<span class="gi">+ANSI_COLOR_NAMES = [</span>
<span class="gi">+    &quot;ansidefault&quot;,</span>
<span class="gi">+    # Low intensity, dark.  (One or two components 0x80, the other 0x00.)</span>
<span class="gi">+    &quot;ansiblack&quot;,</span>
<span class="gi">+    &quot;ansired&quot;,</span>
<span class="gi">+    &quot;ansigreen&quot;,</span>
<span class="gi">+    &quot;ansiyellow&quot;,</span>
<span class="gi">+    &quot;ansiblue&quot;,</span>
<span class="gi">+    &quot;ansimagenta&quot;,</span>
<span class="gi">+    &quot;ansicyan&quot;,</span>
<span class="gi">+    &quot;ansigray&quot;,</span>
<span class="gi">+    # High intensity, bright. (One or two components 0xff, the other 0x00. Not supported everywhere.)</span>
<span class="gi">+    &quot;ansibrightblack&quot;,</span>
<span class="gi">+    &quot;ansibrightred&quot;,</span>
<span class="gi">+    &quot;ansibrightgreen&quot;,</span>
<span class="gi">+    &quot;ansibrightyellow&quot;,</span>
<span class="gi">+    &quot;ansibrightblue&quot;,</span>
<span class="gi">+    &quot;ansibrightmagenta&quot;,</span>
<span class="gi">+    &quot;ansibrightcyan&quot;,</span>
<span class="gi">+    &quot;ansiwhite&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# People don&#39;t use the same ANSI color names everywhere. In prompt_toolkit 1.0</span>
<span class="gi">+# we used some unconventional names (which were contributed like that to</span>
<span class="gi">+# Pygments). This is fixed now, but we still support the old names.</span>
<span class="gi">+</span>
<span class="gi">+# The table below maps the old aliases to the current names.</span>
<span class="gi">+ANSI_COLOR_NAMES_ALIASES: dict[str, str] = {</span>
<span class="gi">+    &quot;ansidarkgray&quot;: &quot;ansibrightblack&quot;,</span>
<span class="gi">+    &quot;ansiteal&quot;: &quot;ansicyan&quot;,</span>
<span class="gi">+    &quot;ansiturquoise&quot;: &quot;ansibrightcyan&quot;,</span>
<span class="gi">+    &quot;ansibrown&quot;: &quot;ansiyellow&quot;,</span>
<span class="gi">+    &quot;ansipurple&quot;: &quot;ansimagenta&quot;,</span>
<span class="gi">+    &quot;ansifuchsia&quot;: &quot;ansibrightmagenta&quot;,</span>
<span class="gi">+    &quot;ansilightgray&quot;: &quot;ansigray&quot;,</span>
<span class="gi">+    &quot;ansidarkred&quot;: &quot;ansired&quot;,</span>
<span class="gi">+    &quot;ansidarkgreen&quot;: &quot;ansigreen&quot;,</span>
<span class="gi">+    &quot;ansidarkblue&quot;: &quot;ansiblue&quot;,</span>
<span class="gi">+}</span>
<span class="w"> </span>assert set(ANSI_COLOR_NAMES_ALIASES.values()).issubset(set(ANSI_COLOR_NAMES))
<span class="gd">-assert not set(ANSI_COLOR_NAMES_ALIASES.keys()) &amp; set(ANSI_COLOR_NAMES)</span>
<span class="gi">+assert not (set(ANSI_COLOR_NAMES_ALIASES.keys()) &amp; set(ANSI_COLOR_NAMES))</span>


<span class="w"> </span>class BaseStyle(metaclass=ABCMeta):
<span class="gu">@@ -54,8 +111,9 @@ class BaseStyle(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def get_attrs_for_style_str(self, style_str: str, default: Attrs=</span>
<span class="gd">-        DEFAULT_ATTRS) -&gt;Attrs:</span>
<span class="gi">+    def get_attrs_for_style_str(</span>
<span class="gi">+        self, style_str: str, default: Attrs = DEFAULT_ATTRS</span>
<span class="gi">+    ) -&gt; Attrs:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return :class:`.Attrs` for the given style string.

<span class="gu">@@ -63,24 +121,22 @@ class BaseStyle(metaclass=ABCMeta):</span>
<span class="w"> </span>            well as classnames (e.g. &quot;class:title&quot;).
<span class="w"> </span>        :param default: `Attrs` to be used if no styling was defined.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractproperty
<span class="gd">-    def style_rules(self) -&gt;list[tuple[str, str]]:</span>
<span class="gi">+    def style_rules(self) -&gt; list[tuple[str, str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The list of style rules, used to create this style.
<span class="w"> </span>        (Required for `DynamicStyle` and `_MergedStyle` to work.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Invalidation hash for the style. When this changes over time, the
<span class="w"> </span>        renderer knows that something in the style changed, and that everything
<span class="w"> </span>        has to be redrawn.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class DummyStyle(BaseStyle):
<span class="gu">@@ -88,6 +144,18 @@ class DummyStyle(BaseStyle):</span>
<span class="w"> </span>    A style that doesn&#39;t style anything.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_attrs_for_style_str(</span>
<span class="gi">+        self, style_str: str, default: Attrs = DEFAULT_ATTRS</span>
<span class="gi">+    ) -&gt; Attrs:</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return 1  # Always the same value.</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def style_rules(self) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicStyle(BaseStyle):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -99,3 +167,17 @@ class DynamicStyle(BaseStyle):</span>
<span class="w"> </span>    def __init__(self, get_style: Callable[[], BaseStyle | None]):
<span class="w"> </span>        self.get_style = get_style
<span class="w"> </span>        self._dummy = DummyStyle()
<span class="gi">+</span>
<span class="gi">+    def get_attrs_for_style_str(</span>
<span class="gi">+        self, style_str: str, default: Attrs = DEFAULT_ATTRS</span>
<span class="gi">+    ) -&gt; Attrs:</span>
<span class="gi">+        style = self.get_style() or self._dummy</span>
<span class="gi">+</span>
<span class="gi">+        return style.get_attrs_for_style_str(style_str, default)</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return (self.get_style() or self._dummy).invalidation_hash()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def style_rules(self) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+        return (self.get_style() or self._dummy).style_rules</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/defaults.py b/src/prompt_toolkit/styles/defaults.py</span>
<span class="gh">index 21bda00d..75b8dd21 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/defaults.py</span>
<span class="gu">@@ -2,112 +2,234 @@</span>
<span class="w"> </span>The default styling.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cache import memoized
<span class="gi">+</span>
<span class="w"> </span>from .base import ANSI_COLOR_NAMES, BaseStyle
<span class="w"> </span>from .named_colors import NAMED_COLORS
<span class="w"> </span>from .style import Style, merge_styles
<span class="gd">-__all__ = [&#39;default_ui_style&#39;, &#39;default_pygments_style&#39;]</span>
<span class="gd">-PROMPT_TOOLKIT_STYLE = [(&#39;search&#39;, &#39;bg:ansibrightyellow ansiblack&#39;), (</span>
<span class="gd">-    &#39;search.current&#39;, &#39;&#39;), (&#39;incsearch&#39;, &#39;&#39;), (&#39;incsearch.current&#39;,</span>
<span class="gd">-    &#39;reverse&#39;), (&#39;selected&#39;, &#39;reverse&#39;), (&#39;cursor-column&#39;, &#39;bg:#dddddd&#39;), (</span>
<span class="gd">-    &#39;cursor-line&#39;, &#39;underline&#39;), (&#39;color-column&#39;, &#39;bg:#ccaacc&#39;), (</span>
<span class="gd">-    &#39;matching-bracket&#39;, &#39;&#39;), (&#39;matching-bracket.other&#39;,</span>
<span class="gd">-    &#39;#000000 bg:#aacccc&#39;), (&#39;matching-bracket.cursor&#39;, &#39;#ff8888 bg:#880000&#39;</span>
<span class="gd">-    ), (&#39;multiple-cursors&#39;, &#39;#000000 bg:#ccccaa&#39;), (&#39;line-number&#39;,</span>
<span class="gd">-    &#39;#888888&#39;), (&#39;line-number.current&#39;, &#39;bold&#39;), (&#39;tilde&#39;, &#39;#8888ff&#39;), (</span>
<span class="gd">-    &#39;prompt&#39;, &#39;&#39;), (&#39;prompt.arg&#39;, &#39;noinherit&#39;), (&#39;prompt.arg.text&#39;, &#39;&#39;), (</span>
<span class="gd">-    &#39;prompt.search&#39;, &#39;noinherit&#39;), (&#39;prompt.search.text&#39;, &#39;&#39;), (</span>
<span class="gd">-    &#39;search-toolbar&#39;, &#39;bold&#39;), (&#39;search-toolbar.text&#39;, &#39;nobold&#39;), (</span>
<span class="gd">-    &#39;system-toolbar&#39;, &#39;bold&#39;), (&#39;system-toolbar.text&#39;, &#39;nobold&#39;), (</span>
<span class="gd">-    &#39;arg-toolbar&#39;, &#39;bold&#39;), (&#39;arg-toolbar.text&#39;, &#39;nobold&#39;), (</span>
<span class="gd">-    &#39;validation-toolbar&#39;, &#39;bg:#550000 #ffffff&#39;), (&#39;window-too-small&#39;,</span>
<span class="gd">-    &#39;bg:#550000 #ffffff&#39;), (&#39;completion-toolbar&#39;, &#39;bg:#bbbbbb #000000&#39;), (</span>
<span class="gd">-    &#39;completion-toolbar.arrow&#39;, &#39;bg:#bbbbbb #000000 bold&#39;), (</span>
<span class="gd">-    &#39;completion-toolbar.completion&#39;, &#39;bg:#bbbbbb #000000&#39;), (</span>
<span class="gd">-    &#39;completion-toolbar.completion.current&#39;, &#39;bg:#444444 #ffffff&#39;), (</span>
<span class="gd">-    &#39;completion-menu&#39;, &#39;bg:#bbbbbb #000000&#39;), (&#39;completion-menu.completion&#39;,</span>
<span class="gd">-    &#39;&#39;), (&#39;completion-menu.completion.current&#39;,</span>
<span class="gd">-    &#39;fg:#888888 bg:#ffffff reverse&#39;), (&#39;completion-menu.meta.completion&#39;,</span>
<span class="gd">-    &#39;bg:#999999 #000000&#39;), (&#39;completion-menu.meta.completion.current&#39;,</span>
<span class="gd">-    &#39;bg:#aaaaaa #000000&#39;), (&#39;completion-menu.multi-column-meta&#39;,</span>
<span class="gd">-    &#39;bg:#aaaaaa #000000&#39;), (&#39;completion-menu.completion fuzzymatch.outside&#39;,</span>
<span class="gd">-    &#39;fg:#444444&#39;), (&#39;completion-menu.completion fuzzymatch.inside&#39;, &#39;bold&#39;),</span>
<span class="gd">-    (&#39;completion-menu.completion fuzzymatch.inside.character&#39;, &#39;underline&#39;),</span>
<span class="gd">-    (&#39;completion-menu.completion.current fuzzymatch.outside&#39;, &#39;fg:default&#39;),</span>
<span class="gd">-    (&#39;completion-menu.completion.current fuzzymatch.inside&#39;, &#39;nobold&#39;), (</span>
<span class="gd">-    &#39;readline-like-completions&#39;, &#39;&#39;), (</span>
<span class="gd">-    &#39;readline-like-completions.completion&#39;, &#39;&#39;), (</span>
<span class="gd">-    &#39;readline-like-completions.completion fuzzymatch.outside&#39;, &#39;#888888&#39;),</span>
<span class="gd">-    (&#39;readline-like-completions.completion fuzzymatch.inside&#39;, &#39;&#39;), (</span>
<span class="gd">-    &#39;readline-like-completions.completion fuzzymatch.inside.character&#39;,</span>
<span class="gd">-    &#39;underline&#39;), (&#39;scrollbar.background&#39;, &#39;bg:#aaaaaa&#39;), (</span>
<span class="gd">-    &#39;scrollbar.button&#39;, &#39;bg:#444444&#39;), (&#39;scrollbar.arrow&#39;, &#39;noinherit bold&#39;</span>
<span class="gd">-    ), (&#39;auto-suggestion&#39;, &#39;#666666&#39;), (&#39;trailing-whitespace&#39;, &#39;#999999&#39;),</span>
<span class="gd">-    (&#39;tab&#39;, &#39;#999999&#39;), (&#39;aborting&#39;,</span>
<span class="gd">-    &#39;#888888 bg:default noreverse noitalic nounderline noblink&#39;), (</span>
<span class="gd">-    &#39;exiting&#39;, &#39;#888888 bg:default noreverse noitalic nounderline noblink&#39;),</span>
<span class="gd">-    (&#39;digraph&#39;, &#39;#4444ff&#39;), (&#39;control-character&#39;, &#39;ansiblue&#39;), (&#39;nbsp&#39;,</span>
<span class="gd">-    &#39;underline ansiyellow&#39;), (&#39;i&#39;, &#39;italic&#39;), (&#39;u&#39;, &#39;underline&#39;), (&#39;s&#39;,</span>
<span class="gd">-    &#39;strike&#39;), (&#39;b&#39;, &#39;bold&#39;), (&#39;em&#39;, &#39;italic&#39;), (&#39;strong&#39;, &#39;bold&#39;), (&#39;del&#39;,</span>
<span class="gd">-    &#39;strike&#39;), (&#39;hidden&#39;, &#39;hidden&#39;), (&#39;italic&#39;, &#39;italic&#39;), (&#39;underline&#39;,</span>
<span class="gd">-    &#39;underline&#39;), (&#39;strike&#39;, &#39;strike&#39;), (&#39;bold&#39;, &#39;bold&#39;), (&#39;reverse&#39;,</span>
<span class="gd">-    &#39;reverse&#39;), (&#39;noitalic&#39;, &#39;noitalic&#39;), (&#39;nounderline&#39;, &#39;nounderline&#39;), (</span>
<span class="gd">-    &#39;nostrike&#39;, &#39;nostrike&#39;), (&#39;nobold&#39;, &#39;nobold&#39;), (&#39;noreverse&#39;,</span>
<span class="gd">-    &#39;noreverse&#39;), (&#39;bottom-toolbar&#39;, &#39;reverse&#39;)]</span>
<span class="gd">-COLORS_STYLE = [(name, &#39;fg:&#39; + name) for name in ANSI_COLOR_NAMES] + [(name</span>
<span class="gd">-    .lower(), &#39;fg:&#39; + name) for name in NAMED_COLORS]</span>
<span class="gd">-WIDGETS_STYLE = [(&#39;dialog&#39;, &#39;bg:#4444ff&#39;), (&#39;dialog.body&#39;,</span>
<span class="gd">-    &#39;bg:#ffffff #000000&#39;), (&#39;dialog.body text-area&#39;, &#39;bg:#cccccc&#39;), (</span>
<span class="gd">-    &#39;dialog.body text-area last-line&#39;, &#39;underline&#39;), (&#39;dialog frame.label&#39;,</span>
<span class="gd">-    &#39;#ff0000 bold&#39;), (&#39;dialog.body scrollbar.background&#39;, &#39;&#39;), (</span>
<span class="gd">-    &#39;dialog.body scrollbar.button&#39;, &#39;bg:#000000&#39;), (</span>
<span class="gd">-    &#39;dialog.body scrollbar.arrow&#39;, &#39;&#39;), (&#39;dialog.body scrollbar.start&#39;,</span>
<span class="gd">-    &#39;nounderline&#39;), (&#39;dialog.body scrollbar.end&#39;, &#39;nounderline&#39;), (&#39;button&#39;,</span>
<span class="gd">-    &#39;&#39;), (&#39;button.arrow&#39;, &#39;bold&#39;), (&#39;button.focused&#39;, &#39;bg:#aa0000 #ffffff&#39;),</span>
<span class="gd">-    (&#39;menu-bar&#39;, &#39;bg:#aaaaaa #000000&#39;), (&#39;menu-bar.selected-item&#39;,</span>
<span class="gd">-    &#39;bg:#ffffff #000000&#39;), (&#39;menu&#39;, &#39;bg:#888888 #ffffff&#39;), (&#39;menu.border&#39;,</span>
<span class="gd">-    &#39;#aaaaaa&#39;), (&#39;menu.border shadow&#39;, &#39;#444444&#39;), (&#39;dialog shadow&#39;,</span>
<span class="gd">-    &#39;bg:#000088&#39;), (&#39;dialog.body shadow&#39;, &#39;bg:#aaaaaa&#39;), (&#39;progress-bar&#39;,</span>
<span class="gd">-    &#39;bg:#000088&#39;), (&#39;progress-bar.used&#39;, &#39;bg:#ff0000&#39;)]</span>
<span class="gd">-PYGMENTS_DEFAULT_STYLE = {&#39;pygments.whitespace&#39;: &#39;#bbbbbb&#39;,</span>
<span class="gd">-    &#39;pygments.comment&#39;: &#39;italic #408080&#39;, &#39;pygments.comment.preproc&#39;:</span>
<span class="gd">-    &#39;noitalic #bc7a00&#39;, &#39;pygments.keyword&#39;: &#39;bold #008000&#39;,</span>
<span class="gd">-    &#39;pygments.keyword.pseudo&#39;: &#39;nobold&#39;, &#39;pygments.keyword.type&#39;:</span>
<span class="gd">-    &#39;nobold #b00040&#39;, &#39;pygments.operator&#39;: &#39;#666666&#39;,</span>
<span class="gd">-    &#39;pygments.operator.word&#39;: &#39;bold #aa22ff&#39;, &#39;pygments.name.builtin&#39;:</span>
<span class="gd">-    &#39;#008000&#39;, &#39;pygments.name.function&#39;: &#39;#0000ff&#39;, &#39;pygments.name.class&#39;:</span>
<span class="gd">-    &#39;bold #0000ff&#39;, &#39;pygments.name.namespace&#39;: &#39;bold #0000ff&#39;,</span>
<span class="gd">-    &#39;pygments.name.exception&#39;: &#39;bold #d2413a&#39;, &#39;pygments.name.variable&#39;:</span>
<span class="gd">-    &#39;#19177c&#39;, &#39;pygments.name.constant&#39;: &#39;#880000&#39;, &#39;pygments.name.label&#39;:</span>
<span class="gd">-    &#39;#a0a000&#39;, &#39;pygments.name.entity&#39;: &#39;bold #999999&#39;,</span>
<span class="gd">-    &#39;pygments.name.attribute&#39;: &#39;#7d9029&#39;, &#39;pygments.name.tag&#39;:</span>
<span class="gd">-    &#39;bold #008000&#39;, &#39;pygments.name.decorator&#39;: &#39;#aa22ff&#39;,</span>
<span class="gd">-    &#39;pygments.literal.string&#39;: &#39;#ba2121&#39;, &#39;pygments.literal.string.doc&#39;:</span>
<span class="gd">-    &#39;italic&#39;, &#39;pygments.literal.string.interpol&#39;: &#39;bold #bb6688&#39;,</span>
<span class="gd">-    &#39;pygments.literal.string.escape&#39;: &#39;bold #bb6622&#39;,</span>
<span class="gd">-    &#39;pygments.literal.string.regex&#39;: &#39;#bb6688&#39;,</span>
<span class="gd">-    &#39;pygments.literal.string.symbol&#39;: &#39;#19177c&#39;,</span>
<span class="gd">-    &#39;pygments.literal.string.other&#39;: &#39;#008000&#39;, &#39;pygments.literal.number&#39;:</span>
<span class="gd">-    &#39;#666666&#39;, &#39;pygments.generic.heading&#39;: &#39;bold #000080&#39;,</span>
<span class="gd">-    &#39;pygments.generic.subheading&#39;: &#39;bold #800080&#39;,</span>
<span class="gd">-    &#39;pygments.generic.deleted&#39;: &#39;#a00000&#39;, &#39;pygments.generic.inserted&#39;:</span>
<span class="gd">-    &#39;#00a000&#39;, &#39;pygments.generic.error&#39;: &#39;#ff0000&#39;, &#39;pygments.generic.emph&#39;:</span>
<span class="gd">-    &#39;italic&#39;, &#39;pygments.generic.strong&#39;: &#39;bold&#39;, &#39;pygments.generic.prompt&#39;:</span>
<span class="gd">-    &#39;bold #000080&#39;, &#39;pygments.generic.output&#39;: &#39;#888&#39;,</span>
<span class="gd">-    &#39;pygments.generic.traceback&#39;: &#39;#04d&#39;, &#39;pygments.error&#39;: &#39;border:#ff0000&#39;}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;default_ui_style&quot;,</span>
<span class="gi">+    &quot;default_pygments_style&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+#: Default styling. Mapping from classnames to their style definition.</span>
<span class="gi">+PROMPT_TOOLKIT_STYLE = [</span>
<span class="gi">+    # Highlighting of search matches in document.</span>
<span class="gi">+    (&quot;search&quot;, &quot;bg:ansibrightyellow ansiblack&quot;),</span>
<span class="gi">+    (&quot;search.current&quot;, &quot;&quot;),</span>
<span class="gi">+    # Incremental search.</span>
<span class="gi">+    (&quot;incsearch&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;incsearch.current&quot;, &quot;reverse&quot;),</span>
<span class="gi">+    # Highlighting of select text in document.</span>
<span class="gi">+    (&quot;selected&quot;, &quot;reverse&quot;),</span>
<span class="gi">+    (&quot;cursor-column&quot;, &quot;bg:#dddddd&quot;),</span>
<span class="gi">+    (&quot;cursor-line&quot;, &quot;underline&quot;),</span>
<span class="gi">+    (&quot;color-column&quot;, &quot;bg:#ccaacc&quot;),</span>
<span class="gi">+    # Highlighting of matching brackets.</span>
<span class="gi">+    (&quot;matching-bracket&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;matching-bracket.other&quot;, &quot;#000000 bg:#aacccc&quot;),</span>
<span class="gi">+    (&quot;matching-bracket.cursor&quot;, &quot;#ff8888 bg:#880000&quot;),</span>
<span class="gi">+    # Styling of other cursors, in case of block editing.</span>
<span class="gi">+    (&quot;multiple-cursors&quot;, &quot;#000000 bg:#ccccaa&quot;),</span>
<span class="gi">+    # Line numbers.</span>
<span class="gi">+    (&quot;line-number&quot;, &quot;#888888&quot;),</span>
<span class="gi">+    (&quot;line-number.current&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;tilde&quot;, &quot;#8888ff&quot;),</span>
<span class="gi">+    # Default prompt.</span>
<span class="gi">+    (&quot;prompt&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;prompt.arg&quot;, &quot;noinherit&quot;),</span>
<span class="gi">+    (&quot;prompt.arg.text&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;prompt.search&quot;, &quot;noinherit&quot;),</span>
<span class="gi">+    (&quot;prompt.search.text&quot;, &quot;&quot;),</span>
<span class="gi">+    # Search toolbar.</span>
<span class="gi">+    (&quot;search-toolbar&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;search-toolbar.text&quot;, &quot;nobold&quot;),</span>
<span class="gi">+    # System toolbar</span>
<span class="gi">+    (&quot;system-toolbar&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;system-toolbar.text&quot;, &quot;nobold&quot;),</span>
<span class="gi">+    # &quot;arg&quot; toolbar.</span>
<span class="gi">+    (&quot;arg-toolbar&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;arg-toolbar.text&quot;, &quot;nobold&quot;),</span>
<span class="gi">+    # Validation toolbar.</span>
<span class="gi">+    (&quot;validation-toolbar&quot;, &quot;bg:#550000 #ffffff&quot;),</span>
<span class="gi">+    (&quot;window-too-small&quot;, &quot;bg:#550000 #ffffff&quot;),</span>
<span class="gi">+    # Completions toolbar.</span>
<span class="gi">+    (&quot;completion-toolbar&quot;, &quot;bg:#bbbbbb #000000&quot;),</span>
<span class="gi">+    (&quot;completion-toolbar.arrow&quot;, &quot;bg:#bbbbbb #000000 bold&quot;),</span>
<span class="gi">+    (&quot;completion-toolbar.completion&quot;, &quot;bg:#bbbbbb #000000&quot;),</span>
<span class="gi">+    (&quot;completion-toolbar.completion.current&quot;, &quot;bg:#444444 #ffffff&quot;),</span>
<span class="gi">+    # Completions menu.</span>
<span class="gi">+    (&quot;completion-menu&quot;, &quot;bg:#bbbbbb #000000&quot;),</span>
<span class="gi">+    (&quot;completion-menu.completion&quot;, &quot;&quot;),</span>
<span class="gi">+    # (Note: for the current completion, we use &#39;reverse&#39; on top of fg/bg</span>
<span class="gi">+    # colors. This is to have proper rendering with NO_COLOR=1).</span>
<span class="gi">+    (&quot;completion-menu.completion.current&quot;, &quot;fg:#888888 bg:#ffffff reverse&quot;),</span>
<span class="gi">+    (&quot;completion-menu.meta.completion&quot;, &quot;bg:#999999 #000000&quot;),</span>
<span class="gi">+    (&quot;completion-menu.meta.completion.current&quot;, &quot;bg:#aaaaaa #000000&quot;),</span>
<span class="gi">+    (&quot;completion-menu.multi-column-meta&quot;, &quot;bg:#aaaaaa #000000&quot;),</span>
<span class="gi">+    # Fuzzy matches in completion menu (for FuzzyCompleter).</span>
<span class="gi">+    (&quot;completion-menu.completion fuzzymatch.outside&quot;, &quot;fg:#444444&quot;),</span>
<span class="gi">+    (&quot;completion-menu.completion fuzzymatch.inside&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;completion-menu.completion fuzzymatch.inside.character&quot;, &quot;underline&quot;),</span>
<span class="gi">+    (&quot;completion-menu.completion.current fuzzymatch.outside&quot;, &quot;fg:default&quot;),</span>
<span class="gi">+    (&quot;completion-menu.completion.current fuzzymatch.inside&quot;, &quot;nobold&quot;),</span>
<span class="gi">+    # Styling of readline-like completions.</span>
<span class="gi">+    (&quot;readline-like-completions&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;readline-like-completions.completion&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;readline-like-completions.completion fuzzymatch.outside&quot;, &quot;#888888&quot;),</span>
<span class="gi">+    (&quot;readline-like-completions.completion fuzzymatch.inside&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;readline-like-completions.completion fuzzymatch.inside.character&quot;, &quot;underline&quot;),</span>
<span class="gi">+    # Scrollbars.</span>
<span class="gi">+    (&quot;scrollbar.background&quot;, &quot;bg:#aaaaaa&quot;),</span>
<span class="gi">+    (&quot;scrollbar.button&quot;, &quot;bg:#444444&quot;),</span>
<span class="gi">+    (&quot;scrollbar.arrow&quot;, &quot;noinherit bold&quot;),</span>
<span class="gi">+    # Start/end of scrollbars. Adding &#39;underline&#39; here provides a nice little</span>
<span class="gi">+    # detail to the progress bar, but it doesn&#39;t look good on all terminals.</span>
<span class="gi">+    # (&#39;scrollbar.start&#39;,                          &#39;underline #ffffff&#39;),</span>
<span class="gi">+    # (&#39;scrollbar.end&#39;,                            &#39;underline #000000&#39;),</span>
<span class="gi">+    # Auto suggestion text.</span>
<span class="gi">+    (&quot;auto-suggestion&quot;, &quot;#666666&quot;),</span>
<span class="gi">+    # Trailing whitespace and tabs.</span>
<span class="gi">+    (&quot;trailing-whitespace&quot;, &quot;#999999&quot;),</span>
<span class="gi">+    (&quot;tab&quot;, &quot;#999999&quot;),</span>
<span class="gi">+    # When Control-C/D has been pressed. Grayed.</span>
<span class="gi">+    (&quot;aborting&quot;, &quot;#888888 bg:default noreverse noitalic nounderline noblink&quot;),</span>
<span class="gi">+    (&quot;exiting&quot;, &quot;#888888 bg:default noreverse noitalic nounderline noblink&quot;),</span>
<span class="gi">+    # Entering a Vi digraph.</span>
<span class="gi">+    (&quot;digraph&quot;, &quot;#4444ff&quot;),</span>
<span class="gi">+    # Control characters, like ^C, ^X.</span>
<span class="gi">+    (&quot;control-character&quot;, &quot;ansiblue&quot;),</span>
<span class="gi">+    # Non-breaking space.</span>
<span class="gi">+    (&quot;nbsp&quot;, &quot;underline ansiyellow&quot;),</span>
<span class="gi">+    # Default styling of HTML elements.</span>
<span class="gi">+    (&quot;i&quot;, &quot;italic&quot;),</span>
<span class="gi">+    (&quot;u&quot;, &quot;underline&quot;),</span>
<span class="gi">+    (&quot;s&quot;, &quot;strike&quot;),</span>
<span class="gi">+    (&quot;b&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;em&quot;, &quot;italic&quot;),</span>
<span class="gi">+    (&quot;strong&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;del&quot;, &quot;strike&quot;),</span>
<span class="gi">+    (&quot;hidden&quot;, &quot;hidden&quot;),</span>
<span class="gi">+    # It should be possible to use the style names in HTML.</span>
<span class="gi">+    # &lt;reverse&gt;...&lt;/reverse&gt;  or &lt;noreverse&gt;...&lt;/noreverse&gt;.</span>
<span class="gi">+    (&quot;italic&quot;, &quot;italic&quot;),</span>
<span class="gi">+    (&quot;underline&quot;, &quot;underline&quot;),</span>
<span class="gi">+    (&quot;strike&quot;, &quot;strike&quot;),</span>
<span class="gi">+    (&quot;bold&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;reverse&quot;, &quot;reverse&quot;),</span>
<span class="gi">+    (&quot;noitalic&quot;, &quot;noitalic&quot;),</span>
<span class="gi">+    (&quot;nounderline&quot;, &quot;nounderline&quot;),</span>
<span class="gi">+    (&quot;nostrike&quot;, &quot;nostrike&quot;),</span>
<span class="gi">+    (&quot;nobold&quot;, &quot;nobold&quot;),</span>
<span class="gi">+    (&quot;noreverse&quot;, &quot;noreverse&quot;),</span>
<span class="gi">+    # Prompt bottom toolbar</span>
<span class="gi">+    (&quot;bottom-toolbar&quot;, &quot;reverse&quot;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Style that will turn for instance the class &#39;red&#39; into &#39;red&#39;.</span>
<span class="gi">+COLORS_STYLE = [(name, &quot;fg:&quot; + name) for name in ANSI_COLOR_NAMES] + [</span>
<span class="gi">+    (name.lower(), &quot;fg:&quot; + name) for name in NAMED_COLORS</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+WIDGETS_STYLE = [</span>
<span class="gi">+    # Dialog windows.</span>
<span class="gi">+    (&quot;dialog&quot;, &quot;bg:#4444ff&quot;),</span>
<span class="gi">+    (&quot;dialog.body&quot;, &quot;bg:#ffffff #000000&quot;),</span>
<span class="gi">+    (&quot;dialog.body text-area&quot;, &quot;bg:#cccccc&quot;),</span>
<span class="gi">+    (&quot;dialog.body text-area last-line&quot;, &quot;underline&quot;),</span>
<span class="gi">+    (&quot;dialog frame.label&quot;, &quot;#ff0000 bold&quot;),</span>
<span class="gi">+    # Scrollbars in dialogs.</span>
<span class="gi">+    (&quot;dialog.body scrollbar.background&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;dialog.body scrollbar.button&quot;, &quot;bg:#000000&quot;),</span>
<span class="gi">+    (&quot;dialog.body scrollbar.arrow&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;dialog.body scrollbar.start&quot;, &quot;nounderline&quot;),</span>
<span class="gi">+    (&quot;dialog.body scrollbar.end&quot;, &quot;nounderline&quot;),</span>
<span class="gi">+    # Buttons.</span>
<span class="gi">+    (&quot;button&quot;, &quot;&quot;),</span>
<span class="gi">+    (&quot;button.arrow&quot;, &quot;bold&quot;),</span>
<span class="gi">+    (&quot;button.focused&quot;, &quot;bg:#aa0000 #ffffff&quot;),</span>
<span class="gi">+    # Menu bars.</span>
<span class="gi">+    (&quot;menu-bar&quot;, &quot;bg:#aaaaaa #000000&quot;),</span>
<span class="gi">+    (&quot;menu-bar.selected-item&quot;, &quot;bg:#ffffff #000000&quot;),</span>
<span class="gi">+    (&quot;menu&quot;, &quot;bg:#888888 #ffffff&quot;),</span>
<span class="gi">+    (&quot;menu.border&quot;, &quot;#aaaaaa&quot;),</span>
<span class="gi">+    (&quot;menu.border shadow&quot;, &quot;#444444&quot;),</span>
<span class="gi">+    # Shadows.</span>
<span class="gi">+    (&quot;dialog shadow&quot;, &quot;bg:#000088&quot;),</span>
<span class="gi">+    (&quot;dialog.body shadow&quot;, &quot;bg:#aaaaaa&quot;),</span>
<span class="gi">+    (&quot;progress-bar&quot;, &quot;bg:#000088&quot;),</span>
<span class="gi">+    (&quot;progress-bar.used&quot;, &quot;bg:#ff0000&quot;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The default Pygments style, include this by default in case a Pygments lexer</span>
<span class="gi">+# is used.</span>
<span class="gi">+PYGMENTS_DEFAULT_STYLE = {</span>
<span class="gi">+    &quot;pygments.whitespace&quot;: &quot;#bbbbbb&quot;,</span>
<span class="gi">+    &quot;pygments.comment&quot;: &quot;italic #408080&quot;,</span>
<span class="gi">+    &quot;pygments.comment.preproc&quot;: &quot;noitalic #bc7a00&quot;,</span>
<span class="gi">+    &quot;pygments.keyword&quot;: &quot;bold #008000&quot;,</span>
<span class="gi">+    &quot;pygments.keyword.pseudo&quot;: &quot;nobold&quot;,</span>
<span class="gi">+    &quot;pygments.keyword.type&quot;: &quot;nobold #b00040&quot;,</span>
<span class="gi">+    &quot;pygments.operator&quot;: &quot;#666666&quot;,</span>
<span class="gi">+    &quot;pygments.operator.word&quot;: &quot;bold #aa22ff&quot;,</span>
<span class="gi">+    &quot;pygments.name.builtin&quot;: &quot;#008000&quot;,</span>
<span class="gi">+    &quot;pygments.name.function&quot;: &quot;#0000ff&quot;,</span>
<span class="gi">+    &quot;pygments.name.class&quot;: &quot;bold #0000ff&quot;,</span>
<span class="gi">+    &quot;pygments.name.namespace&quot;: &quot;bold #0000ff&quot;,</span>
<span class="gi">+    &quot;pygments.name.exception&quot;: &quot;bold #d2413a&quot;,</span>
<span class="gi">+    &quot;pygments.name.variable&quot;: &quot;#19177c&quot;,</span>
<span class="gi">+    &quot;pygments.name.constant&quot;: &quot;#880000&quot;,</span>
<span class="gi">+    &quot;pygments.name.label&quot;: &quot;#a0a000&quot;,</span>
<span class="gi">+    &quot;pygments.name.entity&quot;: &quot;bold #999999&quot;,</span>
<span class="gi">+    &quot;pygments.name.attribute&quot;: &quot;#7d9029&quot;,</span>
<span class="gi">+    &quot;pygments.name.tag&quot;: &quot;bold #008000&quot;,</span>
<span class="gi">+    &quot;pygments.name.decorator&quot;: &quot;#aa22ff&quot;,</span>
<span class="gi">+    # Note: In Pygments, Token.String is an alias for Token.Literal.String,</span>
<span class="gi">+    #       and Token.Number as an alias for Token.Literal.Number.</span>
<span class="gi">+    &quot;pygments.literal.string&quot;: &quot;#ba2121&quot;,</span>
<span class="gi">+    &quot;pygments.literal.string.doc&quot;: &quot;italic&quot;,</span>
<span class="gi">+    &quot;pygments.literal.string.interpol&quot;: &quot;bold #bb6688&quot;,</span>
<span class="gi">+    &quot;pygments.literal.string.escape&quot;: &quot;bold #bb6622&quot;,</span>
<span class="gi">+    &quot;pygments.literal.string.regex&quot;: &quot;#bb6688&quot;,</span>
<span class="gi">+    &quot;pygments.literal.string.symbol&quot;: &quot;#19177c&quot;,</span>
<span class="gi">+    &quot;pygments.literal.string.other&quot;: &quot;#008000&quot;,</span>
<span class="gi">+    &quot;pygments.literal.number&quot;: &quot;#666666&quot;,</span>
<span class="gi">+    &quot;pygments.generic.heading&quot;: &quot;bold #000080&quot;,</span>
<span class="gi">+    &quot;pygments.generic.subheading&quot;: &quot;bold #800080&quot;,</span>
<span class="gi">+    &quot;pygments.generic.deleted&quot;: &quot;#a00000&quot;,</span>
<span class="gi">+    &quot;pygments.generic.inserted&quot;: &quot;#00a000&quot;,</span>
<span class="gi">+    &quot;pygments.generic.error&quot;: &quot;#ff0000&quot;,</span>
<span class="gi">+    &quot;pygments.generic.emph&quot;: &quot;italic&quot;,</span>
<span class="gi">+    &quot;pygments.generic.strong&quot;: &quot;bold&quot;,</span>
<span class="gi">+    &quot;pygments.generic.prompt&quot;: &quot;bold #000080&quot;,</span>
<span class="gi">+    &quot;pygments.generic.output&quot;: &quot;#888&quot;,</span>
<span class="gi">+    &quot;pygments.generic.traceback&quot;: &quot;#04d&quot;,</span>
<span class="gi">+    &quot;pygments.error&quot;: &quot;border:#ff0000&quot;,</span>
<span class="gi">+}</span>


<span class="w"> </span>@memoized()
<span class="gd">-def default_ui_style() -&gt;BaseStyle:</span>
<span class="gi">+def default_ui_style() -&gt; BaseStyle:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a default `Style` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return merge_styles(</span>
<span class="gi">+        [</span>
<span class="gi">+            Style(PROMPT_TOOLKIT_STYLE),</span>
<span class="gi">+            Style(COLORS_STYLE),</span>
<span class="gi">+            Style(WIDGETS_STYLE),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>


<span class="w"> </span>@memoized()
<span class="gd">-def default_pygments_style() -&gt;Style:</span>
<span class="gi">+def default_pygments_style() -&gt; Style:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `Style` object that contains the default Pygments style.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Style.from_dict(PYGMENTS_DEFAULT_STYLE)</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/named_colors.py b/src/prompt_toolkit/styles/named_colors.py</span>
<span class="gh">index 1604c298..0395c8bc 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/named_colors.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/named_colors.py</span>
<span class="gu">@@ -3,57 +3,159 @@ All modern web browsers support these 140 color names.</span>
<span class="w"> </span>Taken from: https://www.w3schools.com/colors/colors_names.asp
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gd">-__all__ = [&#39;NAMED_COLORS&#39;]</span>
<span class="gd">-NAMED_COLORS: dict[str, str] = {&#39;AliceBlue&#39;: &#39;#f0f8ff&#39;, &#39;AntiqueWhite&#39;:</span>
<span class="gd">-    &#39;#faebd7&#39;, &#39;Aqua&#39;: &#39;#00ffff&#39;, &#39;Aquamarine&#39;: &#39;#7fffd4&#39;, &#39;Azure&#39;:</span>
<span class="gd">-    &#39;#f0ffff&#39;, &#39;Beige&#39;: &#39;#f5f5dc&#39;, &#39;Bisque&#39;: &#39;#ffe4c4&#39;, &#39;Black&#39;: &#39;#000000&#39;,</span>
<span class="gd">-    &#39;BlanchedAlmond&#39;: &#39;#ffebcd&#39;, &#39;Blue&#39;: &#39;#0000ff&#39;, &#39;BlueViolet&#39;: &#39;#8a2be2&#39;,</span>
<span class="gd">-    &#39;Brown&#39;: &#39;#a52a2a&#39;, &#39;BurlyWood&#39;: &#39;#deb887&#39;, &#39;CadetBlue&#39;: &#39;#5f9ea0&#39;,</span>
<span class="gd">-    &#39;Chartreuse&#39;: &#39;#7fff00&#39;, &#39;Chocolate&#39;: &#39;#d2691e&#39;, &#39;Coral&#39;: &#39;#ff7f50&#39;,</span>
<span class="gd">-    &#39;CornflowerBlue&#39;: &#39;#6495ed&#39;, &#39;Cornsilk&#39;: &#39;#fff8dc&#39;, &#39;Crimson&#39;:</span>
<span class="gd">-    &#39;#dc143c&#39;, &#39;Cyan&#39;: &#39;#00ffff&#39;, &#39;DarkBlue&#39;: &#39;#00008b&#39;, &#39;DarkCyan&#39;:</span>
<span class="gd">-    &#39;#008b8b&#39;, &#39;DarkGoldenRod&#39;: &#39;#b8860b&#39;, &#39;DarkGray&#39;: &#39;#a9a9a9&#39;,</span>
<span class="gd">-    &#39;DarkGreen&#39;: &#39;#006400&#39;, &#39;DarkGrey&#39;: &#39;#a9a9a9&#39;, &#39;DarkKhaki&#39;: &#39;#bdb76b&#39;,</span>
<span class="gd">-    &#39;DarkMagenta&#39;: &#39;#8b008b&#39;, &#39;DarkOliveGreen&#39;: &#39;#556b2f&#39;, &#39;DarkOrange&#39;:</span>
<span class="gd">-    &#39;#ff8c00&#39;, &#39;DarkOrchid&#39;: &#39;#9932cc&#39;, &#39;DarkRed&#39;: &#39;#8b0000&#39;, &#39;DarkSalmon&#39;:</span>
<span class="gd">-    &#39;#e9967a&#39;, &#39;DarkSeaGreen&#39;: &#39;#8fbc8f&#39;, &#39;DarkSlateBlue&#39;: &#39;#483d8b&#39;,</span>
<span class="gd">-    &#39;DarkSlateGray&#39;: &#39;#2f4f4f&#39;, &#39;DarkSlateGrey&#39;: &#39;#2f4f4f&#39;, &#39;DarkTurquoise&#39;:</span>
<span class="gd">-    &#39;#00ced1&#39;, &#39;DarkViolet&#39;: &#39;#9400d3&#39;, &#39;DeepPink&#39;: &#39;#ff1493&#39;,</span>
<span class="gd">-    &#39;DeepSkyBlue&#39;: &#39;#00bfff&#39;, &#39;DimGray&#39;: &#39;#696969&#39;, &#39;DimGrey&#39;: &#39;#696969&#39;,</span>
<span class="gd">-    &#39;DodgerBlue&#39;: &#39;#1e90ff&#39;, &#39;FireBrick&#39;: &#39;#b22222&#39;, &#39;FloralWhite&#39;:</span>
<span class="gd">-    &#39;#fffaf0&#39;, &#39;ForestGreen&#39;: &#39;#228b22&#39;, &#39;Fuchsia&#39;: &#39;#ff00ff&#39;, &#39;Gainsboro&#39;:</span>
<span class="gd">-    &#39;#dcdcdc&#39;, &#39;GhostWhite&#39;: &#39;#f8f8ff&#39;, &#39;Gold&#39;: &#39;#ffd700&#39;, &#39;GoldenRod&#39;:</span>
<span class="gd">-    &#39;#daa520&#39;, &#39;Gray&#39;: &#39;#808080&#39;, &#39;Green&#39;: &#39;#008000&#39;, &#39;GreenYellow&#39;:</span>
<span class="gd">-    &#39;#adff2f&#39;, &#39;Grey&#39;: &#39;#808080&#39;, &#39;HoneyDew&#39;: &#39;#f0fff0&#39;, &#39;HotPink&#39;:</span>
<span class="gd">-    &#39;#ff69b4&#39;, &#39;IndianRed&#39;: &#39;#cd5c5c&#39;, &#39;Indigo&#39;: &#39;#4b0082&#39;, &#39;Ivory&#39;:</span>
<span class="gd">-    &#39;#fffff0&#39;, &#39;Khaki&#39;: &#39;#f0e68c&#39;, &#39;Lavender&#39;: &#39;#e6e6fa&#39;, &#39;LavenderBlush&#39;:</span>
<span class="gd">-    &#39;#fff0f5&#39;, &#39;LawnGreen&#39;: &#39;#7cfc00&#39;, &#39;LemonChiffon&#39;: &#39;#fffacd&#39;,</span>
<span class="gd">-    &#39;LightBlue&#39;: &#39;#add8e6&#39;, &#39;LightCoral&#39;: &#39;#f08080&#39;, &#39;LightCyan&#39;: &#39;#e0ffff&#39;,</span>
<span class="gd">-    &#39;LightGoldenRodYellow&#39;: &#39;#fafad2&#39;, &#39;LightGray&#39;: &#39;#d3d3d3&#39;, &#39;LightGreen&#39;:</span>
<span class="gd">-    &#39;#90ee90&#39;, &#39;LightGrey&#39;: &#39;#d3d3d3&#39;, &#39;LightPink&#39;: &#39;#ffb6c1&#39;,</span>
<span class="gd">-    &#39;LightSalmon&#39;: &#39;#ffa07a&#39;, &#39;LightSeaGreen&#39;: &#39;#20b2aa&#39;, &#39;LightSkyBlue&#39;:</span>
<span class="gd">-    &#39;#87cefa&#39;, &#39;LightSlateGray&#39;: &#39;#778899&#39;, &#39;LightSlateGrey&#39;: &#39;#778899&#39;,</span>
<span class="gd">-    &#39;LightSteelBlue&#39;: &#39;#b0c4de&#39;, &#39;LightYellow&#39;: &#39;#ffffe0&#39;, &#39;Lime&#39;:</span>
<span class="gd">-    &#39;#00ff00&#39;, &#39;LimeGreen&#39;: &#39;#32cd32&#39;, &#39;Linen&#39;: &#39;#faf0e6&#39;, &#39;Magenta&#39;:</span>
<span class="gd">-    &#39;#ff00ff&#39;, &#39;Maroon&#39;: &#39;#800000&#39;, &#39;MediumAquaMarine&#39;: &#39;#66cdaa&#39;,</span>
<span class="gd">-    &#39;MediumBlue&#39;: &#39;#0000cd&#39;, &#39;MediumOrchid&#39;: &#39;#ba55d3&#39;, &#39;MediumPurple&#39;:</span>
<span class="gd">-    &#39;#9370db&#39;, &#39;MediumSeaGreen&#39;: &#39;#3cb371&#39;, &#39;MediumSlateBlue&#39;: &#39;#7b68ee&#39;,</span>
<span class="gd">-    &#39;MediumSpringGreen&#39;: &#39;#00fa9a&#39;, &#39;MediumTurquoise&#39;: &#39;#48d1cc&#39;,</span>
<span class="gd">-    &#39;MediumVioletRed&#39;: &#39;#c71585&#39;, &#39;MidnightBlue&#39;: &#39;#191970&#39;, &#39;MintCream&#39;:</span>
<span class="gd">-    &#39;#f5fffa&#39;, &#39;MistyRose&#39;: &#39;#ffe4e1&#39;, &#39;Moccasin&#39;: &#39;#ffe4b5&#39;, &#39;NavajoWhite&#39;:</span>
<span class="gd">-    &#39;#ffdead&#39;, &#39;Navy&#39;: &#39;#000080&#39;, &#39;OldLace&#39;: &#39;#fdf5e6&#39;, &#39;Olive&#39;: &#39;#808000&#39;,</span>
<span class="gd">-    &#39;OliveDrab&#39;: &#39;#6b8e23&#39;, &#39;Orange&#39;: &#39;#ffa500&#39;, &#39;OrangeRed&#39;: &#39;#ff4500&#39;,</span>
<span class="gd">-    &#39;Orchid&#39;: &#39;#da70d6&#39;, &#39;PaleGoldenRod&#39;: &#39;#eee8aa&#39;, &#39;PaleGreen&#39;: &#39;#98fb98&#39;,</span>
<span class="gd">-    &#39;PaleTurquoise&#39;: &#39;#afeeee&#39;, &#39;PaleVioletRed&#39;: &#39;#db7093&#39;, &#39;PapayaWhip&#39;:</span>
<span class="gd">-    &#39;#ffefd5&#39;, &#39;PeachPuff&#39;: &#39;#ffdab9&#39;, &#39;Peru&#39;: &#39;#cd853f&#39;, &#39;Pink&#39;: &#39;#ffc0cb&#39;,</span>
<span class="gd">-    &#39;Plum&#39;: &#39;#dda0dd&#39;, &#39;PowderBlue&#39;: &#39;#b0e0e6&#39;, &#39;Purple&#39;: &#39;#800080&#39;,</span>
<span class="gd">-    &#39;RebeccaPurple&#39;: &#39;#663399&#39;, &#39;Red&#39;: &#39;#ff0000&#39;, &#39;RosyBrown&#39;: &#39;#bc8f8f&#39;,</span>
<span class="gd">-    &#39;RoyalBlue&#39;: &#39;#4169e1&#39;, &#39;SaddleBrown&#39;: &#39;#8b4513&#39;, &#39;Salmon&#39;: &#39;#fa8072&#39;,</span>
<span class="gd">-    &#39;SandyBrown&#39;: &#39;#f4a460&#39;, &#39;SeaGreen&#39;: &#39;#2e8b57&#39;, &#39;SeaShell&#39;: &#39;#fff5ee&#39;,</span>
<span class="gd">-    &#39;Sienna&#39;: &#39;#a0522d&#39;, &#39;Silver&#39;: &#39;#c0c0c0&#39;, &#39;SkyBlue&#39;: &#39;#87ceeb&#39;,</span>
<span class="gd">-    &#39;SlateBlue&#39;: &#39;#6a5acd&#39;, &#39;SlateGray&#39;: &#39;#708090&#39;, &#39;SlateGrey&#39;: &#39;#708090&#39;,</span>
<span class="gd">-    &#39;Snow&#39;: &#39;#fffafa&#39;, &#39;SpringGreen&#39;: &#39;#00ff7f&#39;, &#39;SteelBlue&#39;: &#39;#4682b4&#39;,</span>
<span class="gd">-    &#39;Tan&#39;: &#39;#d2b48c&#39;, &#39;Teal&#39;: &#39;#008080&#39;, &#39;Thistle&#39;: &#39;#d8bfd8&#39;, &#39;Tomato&#39;:</span>
<span class="gd">-    &#39;#ff6347&#39;, &#39;Turquoise&#39;: &#39;#40e0d0&#39;, &#39;Violet&#39;: &#39;#ee82ee&#39;, &#39;Wheat&#39;:</span>
<span class="gd">-    &#39;#f5deb3&#39;, &#39;White&#39;: &#39;#ffffff&#39;, &#39;WhiteSmoke&#39;: &#39;#f5f5f5&#39;, &#39;Yellow&#39;:</span>
<span class="gd">-    &#39;#ffff00&#39;, &#39;YellowGreen&#39;: &#39;#9acd32&#39;}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;NAMED_COLORS&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+NAMED_COLORS: dict[str, str] = {</span>
<span class="gi">+    &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;,</span>
<span class="gi">+    &quot;AntiqueWhite&quot;: &quot;#faebd7&quot;,</span>
<span class="gi">+    &quot;Aqua&quot;: &quot;#00ffff&quot;,</span>
<span class="gi">+    &quot;Aquamarine&quot;: &quot;#7fffd4&quot;,</span>
<span class="gi">+    &quot;Azure&quot;: &quot;#f0ffff&quot;,</span>
<span class="gi">+    &quot;Beige&quot;: &quot;#f5f5dc&quot;,</span>
<span class="gi">+    &quot;Bisque&quot;: &quot;#ffe4c4&quot;,</span>
<span class="gi">+    &quot;Black&quot;: &quot;#000000&quot;,</span>
<span class="gi">+    &quot;BlanchedAlmond&quot;: &quot;#ffebcd&quot;,</span>
<span class="gi">+    &quot;Blue&quot;: &quot;#0000ff&quot;,</span>
<span class="gi">+    &quot;BlueViolet&quot;: &quot;#8a2be2&quot;,</span>
<span class="gi">+    &quot;Brown&quot;: &quot;#a52a2a&quot;,</span>
<span class="gi">+    &quot;BurlyWood&quot;: &quot;#deb887&quot;,</span>
<span class="gi">+    &quot;CadetBlue&quot;: &quot;#5f9ea0&quot;,</span>
<span class="gi">+    &quot;Chartreuse&quot;: &quot;#7fff00&quot;,</span>
<span class="gi">+    &quot;Chocolate&quot;: &quot;#d2691e&quot;,</span>
<span class="gi">+    &quot;Coral&quot;: &quot;#ff7f50&quot;,</span>
<span class="gi">+    &quot;CornflowerBlue&quot;: &quot;#6495ed&quot;,</span>
<span class="gi">+    &quot;Cornsilk&quot;: &quot;#fff8dc&quot;,</span>
<span class="gi">+    &quot;Crimson&quot;: &quot;#dc143c&quot;,</span>
<span class="gi">+    &quot;Cyan&quot;: &quot;#00ffff&quot;,</span>
<span class="gi">+    &quot;DarkBlue&quot;: &quot;#00008b&quot;,</span>
<span class="gi">+    &quot;DarkCyan&quot;: &quot;#008b8b&quot;,</span>
<span class="gi">+    &quot;DarkGoldenRod&quot;: &quot;#b8860b&quot;,</span>
<span class="gi">+    &quot;DarkGray&quot;: &quot;#a9a9a9&quot;,</span>
<span class="gi">+    &quot;DarkGreen&quot;: &quot;#006400&quot;,</span>
<span class="gi">+    &quot;DarkGrey&quot;: &quot;#a9a9a9&quot;,</span>
<span class="gi">+    &quot;DarkKhaki&quot;: &quot;#bdb76b&quot;,</span>
<span class="gi">+    &quot;DarkMagenta&quot;: &quot;#8b008b&quot;,</span>
<span class="gi">+    &quot;DarkOliveGreen&quot;: &quot;#556b2f&quot;,</span>
<span class="gi">+    &quot;DarkOrange&quot;: &quot;#ff8c00&quot;,</span>
<span class="gi">+    &quot;DarkOrchid&quot;: &quot;#9932cc&quot;,</span>
<span class="gi">+    &quot;DarkRed&quot;: &quot;#8b0000&quot;,</span>
<span class="gi">+    &quot;DarkSalmon&quot;: &quot;#e9967a&quot;,</span>
<span class="gi">+    &quot;DarkSeaGreen&quot;: &quot;#8fbc8f&quot;,</span>
<span class="gi">+    &quot;DarkSlateBlue&quot;: &quot;#483d8b&quot;,</span>
<span class="gi">+    &quot;DarkSlateGray&quot;: &quot;#2f4f4f&quot;,</span>
<span class="gi">+    &quot;DarkSlateGrey&quot;: &quot;#2f4f4f&quot;,</span>
<span class="gi">+    &quot;DarkTurquoise&quot;: &quot;#00ced1&quot;,</span>
<span class="gi">+    &quot;DarkViolet&quot;: &quot;#9400d3&quot;,</span>
<span class="gi">+    &quot;DeepPink&quot;: &quot;#ff1493&quot;,</span>
<span class="gi">+    &quot;DeepSkyBlue&quot;: &quot;#00bfff&quot;,</span>
<span class="gi">+    &quot;DimGray&quot;: &quot;#696969&quot;,</span>
<span class="gi">+    &quot;DimGrey&quot;: &quot;#696969&quot;,</span>
<span class="gi">+    &quot;DodgerBlue&quot;: &quot;#1e90ff&quot;,</span>
<span class="gi">+    &quot;FireBrick&quot;: &quot;#b22222&quot;,</span>
<span class="gi">+    &quot;FloralWhite&quot;: &quot;#fffaf0&quot;,</span>
<span class="gi">+    &quot;ForestGreen&quot;: &quot;#228b22&quot;,</span>
<span class="gi">+    &quot;Fuchsia&quot;: &quot;#ff00ff&quot;,</span>
<span class="gi">+    &quot;Gainsboro&quot;: &quot;#dcdcdc&quot;,</span>
<span class="gi">+    &quot;GhostWhite&quot;: &quot;#f8f8ff&quot;,</span>
<span class="gi">+    &quot;Gold&quot;: &quot;#ffd700&quot;,</span>
<span class="gi">+    &quot;GoldenRod&quot;: &quot;#daa520&quot;,</span>
<span class="gi">+    &quot;Gray&quot;: &quot;#808080&quot;,</span>
<span class="gi">+    &quot;Green&quot;: &quot;#008000&quot;,</span>
<span class="gi">+    &quot;GreenYellow&quot;: &quot;#adff2f&quot;,</span>
<span class="gi">+    &quot;Grey&quot;: &quot;#808080&quot;,</span>
<span class="gi">+    &quot;HoneyDew&quot;: &quot;#f0fff0&quot;,</span>
<span class="gi">+    &quot;HotPink&quot;: &quot;#ff69b4&quot;,</span>
<span class="gi">+    &quot;IndianRed&quot;: &quot;#cd5c5c&quot;,</span>
<span class="gi">+    &quot;Indigo&quot;: &quot;#4b0082&quot;,</span>
<span class="gi">+    &quot;Ivory&quot;: &quot;#fffff0&quot;,</span>
<span class="gi">+    &quot;Khaki&quot;: &quot;#f0e68c&quot;,</span>
<span class="gi">+    &quot;Lavender&quot;: &quot;#e6e6fa&quot;,</span>
<span class="gi">+    &quot;LavenderBlush&quot;: &quot;#fff0f5&quot;,</span>
<span class="gi">+    &quot;LawnGreen&quot;: &quot;#7cfc00&quot;,</span>
<span class="gi">+    &quot;LemonChiffon&quot;: &quot;#fffacd&quot;,</span>
<span class="gi">+    &quot;LightBlue&quot;: &quot;#add8e6&quot;,</span>
<span class="gi">+    &quot;LightCoral&quot;: &quot;#f08080&quot;,</span>
<span class="gi">+    &quot;LightCyan&quot;: &quot;#e0ffff&quot;,</span>
<span class="gi">+    &quot;LightGoldenRodYellow&quot;: &quot;#fafad2&quot;,</span>
<span class="gi">+    &quot;LightGray&quot;: &quot;#d3d3d3&quot;,</span>
<span class="gi">+    &quot;LightGreen&quot;: &quot;#90ee90&quot;,</span>
<span class="gi">+    &quot;LightGrey&quot;: &quot;#d3d3d3&quot;,</span>
<span class="gi">+    &quot;LightPink&quot;: &quot;#ffb6c1&quot;,</span>
<span class="gi">+    &quot;LightSalmon&quot;: &quot;#ffa07a&quot;,</span>
<span class="gi">+    &quot;LightSeaGreen&quot;: &quot;#20b2aa&quot;,</span>
<span class="gi">+    &quot;LightSkyBlue&quot;: &quot;#87cefa&quot;,</span>
<span class="gi">+    &quot;LightSlateGray&quot;: &quot;#778899&quot;,</span>
<span class="gi">+    &quot;LightSlateGrey&quot;: &quot;#778899&quot;,</span>
<span class="gi">+    &quot;LightSteelBlue&quot;: &quot;#b0c4de&quot;,</span>
<span class="gi">+    &quot;LightYellow&quot;: &quot;#ffffe0&quot;,</span>
<span class="gi">+    &quot;Lime&quot;: &quot;#00ff00&quot;,</span>
<span class="gi">+    &quot;LimeGreen&quot;: &quot;#32cd32&quot;,</span>
<span class="gi">+    &quot;Linen&quot;: &quot;#faf0e6&quot;,</span>
<span class="gi">+    &quot;Magenta&quot;: &quot;#ff00ff&quot;,</span>
<span class="gi">+    &quot;Maroon&quot;: &quot;#800000&quot;,</span>
<span class="gi">+    &quot;MediumAquaMarine&quot;: &quot;#66cdaa&quot;,</span>
<span class="gi">+    &quot;MediumBlue&quot;: &quot;#0000cd&quot;,</span>
<span class="gi">+    &quot;MediumOrchid&quot;: &quot;#ba55d3&quot;,</span>
<span class="gi">+    &quot;MediumPurple&quot;: &quot;#9370db&quot;,</span>
<span class="gi">+    &quot;MediumSeaGreen&quot;: &quot;#3cb371&quot;,</span>
<span class="gi">+    &quot;MediumSlateBlue&quot;: &quot;#7b68ee&quot;,</span>
<span class="gi">+    &quot;MediumSpringGreen&quot;: &quot;#00fa9a&quot;,</span>
<span class="gi">+    &quot;MediumTurquoise&quot;: &quot;#48d1cc&quot;,</span>
<span class="gi">+    &quot;MediumVioletRed&quot;: &quot;#c71585&quot;,</span>
<span class="gi">+    &quot;MidnightBlue&quot;: &quot;#191970&quot;,</span>
<span class="gi">+    &quot;MintCream&quot;: &quot;#f5fffa&quot;,</span>
<span class="gi">+    &quot;MistyRose&quot;: &quot;#ffe4e1&quot;,</span>
<span class="gi">+    &quot;Moccasin&quot;: &quot;#ffe4b5&quot;,</span>
<span class="gi">+    &quot;NavajoWhite&quot;: &quot;#ffdead&quot;,</span>
<span class="gi">+    &quot;Navy&quot;: &quot;#000080&quot;,</span>
<span class="gi">+    &quot;OldLace&quot;: &quot;#fdf5e6&quot;,</span>
<span class="gi">+    &quot;Olive&quot;: &quot;#808000&quot;,</span>
<span class="gi">+    &quot;OliveDrab&quot;: &quot;#6b8e23&quot;,</span>
<span class="gi">+    &quot;Orange&quot;: &quot;#ffa500&quot;,</span>
<span class="gi">+    &quot;OrangeRed&quot;: &quot;#ff4500&quot;,</span>
<span class="gi">+    &quot;Orchid&quot;: &quot;#da70d6&quot;,</span>
<span class="gi">+    &quot;PaleGoldenRod&quot;: &quot;#eee8aa&quot;,</span>
<span class="gi">+    &quot;PaleGreen&quot;: &quot;#98fb98&quot;,</span>
<span class="gi">+    &quot;PaleTurquoise&quot;: &quot;#afeeee&quot;,</span>
<span class="gi">+    &quot;PaleVioletRed&quot;: &quot;#db7093&quot;,</span>
<span class="gi">+    &quot;PapayaWhip&quot;: &quot;#ffefd5&quot;,</span>
<span class="gi">+    &quot;PeachPuff&quot;: &quot;#ffdab9&quot;,</span>
<span class="gi">+    &quot;Peru&quot;: &quot;#cd853f&quot;,</span>
<span class="gi">+    &quot;Pink&quot;: &quot;#ffc0cb&quot;,</span>
<span class="gi">+    &quot;Plum&quot;: &quot;#dda0dd&quot;,</span>
<span class="gi">+    &quot;PowderBlue&quot;: &quot;#b0e0e6&quot;,</span>
<span class="gi">+    &quot;Purple&quot;: &quot;#800080&quot;,</span>
<span class="gi">+    &quot;RebeccaPurple&quot;: &quot;#663399&quot;,</span>
<span class="gi">+    &quot;Red&quot;: &quot;#ff0000&quot;,</span>
<span class="gi">+    &quot;RosyBrown&quot;: &quot;#bc8f8f&quot;,</span>
<span class="gi">+    &quot;RoyalBlue&quot;: &quot;#4169e1&quot;,</span>
<span class="gi">+    &quot;SaddleBrown&quot;: &quot;#8b4513&quot;,</span>
<span class="gi">+    &quot;Salmon&quot;: &quot;#fa8072&quot;,</span>
<span class="gi">+    &quot;SandyBrown&quot;: &quot;#f4a460&quot;,</span>
<span class="gi">+    &quot;SeaGreen&quot;: &quot;#2e8b57&quot;,</span>
<span class="gi">+    &quot;SeaShell&quot;: &quot;#fff5ee&quot;,</span>
<span class="gi">+    &quot;Sienna&quot;: &quot;#a0522d&quot;,</span>
<span class="gi">+    &quot;Silver&quot;: &quot;#c0c0c0&quot;,</span>
<span class="gi">+    &quot;SkyBlue&quot;: &quot;#87ceeb&quot;,</span>
<span class="gi">+    &quot;SlateBlue&quot;: &quot;#6a5acd&quot;,</span>
<span class="gi">+    &quot;SlateGray&quot;: &quot;#708090&quot;,</span>
<span class="gi">+    &quot;SlateGrey&quot;: &quot;#708090&quot;,</span>
<span class="gi">+    &quot;Snow&quot;: &quot;#fffafa&quot;,</span>
<span class="gi">+    &quot;SpringGreen&quot;: &quot;#00ff7f&quot;,</span>
<span class="gi">+    &quot;SteelBlue&quot;: &quot;#4682b4&quot;,</span>
<span class="gi">+    &quot;Tan&quot;: &quot;#d2b48c&quot;,</span>
<span class="gi">+    &quot;Teal&quot;: &quot;#008080&quot;,</span>
<span class="gi">+    &quot;Thistle&quot;: &quot;#d8bfd8&quot;,</span>
<span class="gi">+    &quot;Tomato&quot;: &quot;#ff6347&quot;,</span>
<span class="gi">+    &quot;Turquoise&quot;: &quot;#40e0d0&quot;,</span>
<span class="gi">+    &quot;Violet&quot;: &quot;#ee82ee&quot;,</span>
<span class="gi">+    &quot;Wheat&quot;: &quot;#f5deb3&quot;,</span>
<span class="gi">+    &quot;White&quot;: &quot;#ffffff&quot;,</span>
<span class="gi">+    &quot;WhiteSmoke&quot;: &quot;#f5f5f5&quot;,</span>
<span class="gi">+    &quot;Yellow&quot;: &quot;#ffff00&quot;,</span>
<span class="gi">+    &quot;YellowGreen&quot;: &quot;#9acd32&quot;,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/pygments.py b/src/prompt_toolkit/styles/pygments.py</span>
<span class="gh">index 07c41282..3e101f1d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/pygments.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/pygments.py</span>
<span class="gu">@@ -7,16 +7,24 @@ Usage::</span>
<span class="w"> </span>    style = style_from_pygments_cls(pygments_style_cls=TangoStyle)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from .style import Style
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pygments.style import Style as PygmentsStyle
<span class="w"> </span>    from pygments.token import Token
<span class="gd">-__all__ = [&#39;style_from_pygments_cls&#39;, &#39;style_from_pygments_dict&#39;,</span>
<span class="gd">-    &#39;pygments_token_to_classname&#39;]</span>


<span class="gd">-def style_from_pygments_cls(pygments_style_cls: type[PygmentsStyle]) -&gt;Style:</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;style_from_pygments_cls&quot;,</span>
<span class="gi">+    &quot;style_from_pygments_dict&quot;,</span>
<span class="gi">+    &quot;pygments_token_to_classname&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def style_from_pygments_cls(pygments_style_cls: type[PygmentsStyle]) -&gt; Style:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Shortcut to create a :class:`.Style` instance from a Pygments style class
<span class="w"> </span>    and a style dictionary.
<span class="gu">@@ -29,22 +37,33 @@ def style_from_pygments_cls(pygments_style_cls: type[PygmentsStyle]) -&gt;Style:</span>

<span class="w"> </span>    :param pygments_style_cls: Pygments style class to start from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Import inline.</span>
<span class="gi">+    from pygments.style import Style as PygmentsStyle</span>
<span class="gi">+</span>
<span class="gi">+    assert issubclass(pygments_style_cls, PygmentsStyle)</span>
<span class="gi">+</span>
<span class="gi">+    return style_from_pygments_dict(pygments_style_cls.styles)</span>


<span class="gd">-def style_from_pygments_dict(pygments_dict: dict[Token, str]) -&gt;Style:</span>
<span class="gi">+def style_from_pygments_dict(pygments_dict: dict[Token, str]) -&gt; Style:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a :class:`.Style` instance from a Pygments style dictionary.
<span class="w"> </span>    (One that maps Token objects to style strings.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pygments_style = []</span>
<span class="gi">+</span>
<span class="gi">+    for token, style in pygments_dict.items():</span>
<span class="gi">+        pygments_style.append((pygments_token_to_classname(token), style))</span>
<span class="gi">+</span>
<span class="gi">+    return Style(pygments_style)</span>


<span class="gd">-def pygments_token_to_classname(token: Token) -&gt;str:</span>
<span class="gi">+def pygments_token_to_classname(token: Token) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn e.g. `Token.Name.Exception` into `&#39;pygments.name.exception&#39;`.

<span class="w"> </span>    (Our Pygments lexer will also turn the tokens that pygments produces in a
<span class="w"> </span>    prompt_toolkit list of fragments that match these styling rules.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = (&quot;pygments&quot;,) + token</span>
<span class="gi">+    return &quot;.&quot;.join(parts).lower()</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/style.py b/src/prompt_toolkit/styles/style.py</span>
<span class="gh">index ddd7ee70..1abee0f5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/style.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/style.py</span>
<span class="gu">@@ -2,50 +2,178 @@</span>
<span class="w"> </span>Tool for creating styles from a dictionary.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>import re
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import Hashable, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cache import SimpleCache
<span class="gd">-from .base import ANSI_COLOR_NAMES, ANSI_COLOR_NAMES_ALIASES, DEFAULT_ATTRS, Attrs, BaseStyle</span>
<span class="gi">+</span>
<span class="gi">+from .base import (</span>
<span class="gi">+    ANSI_COLOR_NAMES,</span>
<span class="gi">+    ANSI_COLOR_NAMES_ALIASES,</span>
<span class="gi">+    DEFAULT_ATTRS,</span>
<span class="gi">+    Attrs,</span>
<span class="gi">+    BaseStyle,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .named_colors import NAMED_COLORS
<span class="gd">-__all__ = [&#39;Style&#39;, &#39;parse_color&#39;, &#39;Priority&#39;, &#39;merge_styles&#39;]</span>
<span class="gd">-_named_colors_lowercase = {k.lower(): v.lstrip(&#39;#&#39;) for k, v in</span>
<span class="gd">-    NAMED_COLORS.items()}</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Style&quot;,</span>
<span class="gi">+    &quot;parse_color&quot;,</span>
<span class="gi">+    &quot;Priority&quot;,</span>
<span class="gi">+    &quot;merge_styles&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-def parse_color(text: str) -&gt;str:</span>
<span class="gi">+_named_colors_lowercase = {k.lower(): v.lstrip(&quot;#&quot;) for k, v in NAMED_COLORS.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_color(text: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse/validate color format.

<span class="w"> </span>    Like in Pygments, but also support the ANSI color names.
<span class="w"> </span>    (These will map to the colors of the 16 color palette.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # ANSI color names.</span>
<span class="gi">+    if text in ANSI_COLOR_NAMES:</span>
<span class="gi">+        return text</span>
<span class="gi">+    if text in ANSI_COLOR_NAMES_ALIASES:</span>
<span class="gi">+        return ANSI_COLOR_NAMES_ALIASES[text]</span>
<span class="gi">+</span>
<span class="gi">+    # 140 named colors.</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Replace by &#39;hex&#39; value.</span>
<span class="gi">+        return _named_colors_lowercase[text.lower()]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Hex codes.</span>
<span class="gi">+    if text[0:1] == &quot;#&quot;:</span>
<span class="gi">+        col = text[1:]</span>
<span class="gi">+</span>
<span class="gi">+        # Keep this for backwards-compatibility (Pygments does it).</span>
<span class="gi">+        # I don&#39;t like the &#39;#&#39; prefix for named colors.</span>
<span class="gi">+        if col in ANSI_COLOR_NAMES:</span>
<span class="gi">+            return col</span>
<span class="gi">+        elif col in ANSI_COLOR_NAMES_ALIASES:</span>
<span class="gi">+            return ANSI_COLOR_NAMES_ALIASES[col]</span>
<span class="gi">+</span>
<span class="gi">+        # 6 digit hex color.</span>
<span class="gi">+        elif len(col) == 6:</span>
<span class="gi">+            return col</span>
<span class="gi">+</span>
<span class="gi">+        # 3 digit hex color.</span>
<span class="gi">+        elif len(col) == 3:</span>
<span class="gi">+            return col[0] * 2 + col[1] * 2 + col[2] * 2</span>
<span class="gi">+</span>
<span class="gi">+    # Default.</span>
<span class="gi">+    elif text in (&quot;&quot;, &quot;default&quot;):</span>
<span class="gi">+        return text</span>

<span class="gi">+    raise ValueError(&quot;Wrong color format %r&quot; % text)</span>

<span class="gd">-_EMPTY_ATTRS = Attrs(color=None, bgcolor=None, bold=None, underline=None,</span>
<span class="gd">-    strike=None, italic=None, blink=None, reverse=None, hidden=None)</span>

<span class="gi">+# Attributes, when they are not filled in by a style. None means that we take</span>
<span class="gi">+# the value from the parent.</span>
<span class="gi">+_EMPTY_ATTRS = Attrs(</span>
<span class="gi">+    color=None,</span>
<span class="gi">+    bgcolor=None,</span>
<span class="gi">+    bold=None,</span>
<span class="gi">+    underline=None,</span>
<span class="gi">+    strike=None,</span>
<span class="gi">+    italic=None,</span>
<span class="gi">+    blink=None,</span>
<span class="gi">+    reverse=None,</span>
<span class="gi">+    hidden=None,</span>
<span class="gi">+)</span>

<span class="gd">-def _expand_classname(classname: str) -&gt;list[str]:</span>
<span class="gi">+</span>
<span class="gi">+def _expand_classname(classname: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Split a single class name at the `.` operator, and build a list of classes.

<span class="w"> </span>    E.g. &#39;a.b.c&#39; becomes [&#39;a&#39;, &#39;a.b&#39;, &#39;a.b.c&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    parts = classname.split(&quot;.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(1, len(parts) + 1):</span>
<span class="gi">+        result.append(&quot;.&quot;.join(parts[:i]).lower())</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="gd">-def _parse_style_str(style_str: str) -&gt;Attrs:</span>
<span class="gi">+def _parse_style_str(style_str: str) -&gt; Attrs:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a style string, e.g.  &#39;bg:red #88ff00 class:title&#39;
<span class="w"> </span>    and return a `Attrs` instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-CLASS_NAMES_RE = re.compile(&#39;^[a-z0-9.\\s_-]*$&#39;)</span>
<span class="gi">+    # Start from default Attrs.</span>
<span class="gi">+    if &quot;noinherit&quot; in style_str:</span>
<span class="gi">+        attrs = DEFAULT_ATTRS</span>
<span class="gi">+    else:</span>
<span class="gi">+        attrs = _EMPTY_ATTRS</span>
<span class="gi">+</span>
<span class="gi">+    # Now update with the given attributes.</span>
<span class="gi">+    for part in style_str.split():</span>
<span class="gi">+        if part == &quot;noinherit&quot;:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif part == &quot;bold&quot;:</span>
<span class="gi">+            attrs = attrs._replace(bold=True)</span>
<span class="gi">+        elif part == &quot;nobold&quot;:</span>
<span class="gi">+            attrs = attrs._replace(bold=False)</span>
<span class="gi">+        elif part == &quot;italic&quot;:</span>
<span class="gi">+            attrs = attrs._replace(italic=True)</span>
<span class="gi">+        elif part == &quot;noitalic&quot;:</span>
<span class="gi">+            attrs = attrs._replace(italic=False)</span>
<span class="gi">+        elif part == &quot;underline&quot;:</span>
<span class="gi">+            attrs = attrs._replace(underline=True)</span>
<span class="gi">+        elif part == &quot;nounderline&quot;:</span>
<span class="gi">+            attrs = attrs._replace(underline=False)</span>
<span class="gi">+        elif part == &quot;strike&quot;:</span>
<span class="gi">+            attrs = attrs._replace(strike=True)</span>
<span class="gi">+        elif part == &quot;nostrike&quot;:</span>
<span class="gi">+            attrs = attrs._replace(strike=False)</span>
<span class="gi">+</span>
<span class="gi">+        # prompt_toolkit extensions. Not in Pygments.</span>
<span class="gi">+        elif part == &quot;blink&quot;:</span>
<span class="gi">+            attrs = attrs._replace(blink=True)</span>
<span class="gi">+        elif part == &quot;noblink&quot;:</span>
<span class="gi">+            attrs = attrs._replace(blink=False)</span>
<span class="gi">+        elif part == &quot;reverse&quot;:</span>
<span class="gi">+            attrs = attrs._replace(reverse=True)</span>
<span class="gi">+        elif part == &quot;noreverse&quot;:</span>
<span class="gi">+            attrs = attrs._replace(reverse=False)</span>
<span class="gi">+        elif part == &quot;hidden&quot;:</span>
<span class="gi">+            attrs = attrs._replace(hidden=True)</span>
<span class="gi">+        elif part == &quot;nohidden&quot;:</span>
<span class="gi">+            attrs = attrs._replace(hidden=False)</span>
<span class="gi">+</span>
<span class="gi">+        # Pygments properties that we ignore.</span>
<span class="gi">+        elif part in (&quot;roman&quot;, &quot;sans&quot;, &quot;mono&quot;):</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif part.startswith(&quot;border:&quot;):</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore pieces in between square brackets. This is internal stuff.</span>
<span class="gi">+        # Like &#39;[transparent]&#39; or &#39;[set-cursor-position]&#39;.</span>
<span class="gi">+        elif part.startswith(&quot;[&quot;) and part.endswith(&quot;]&quot;):</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Colors.</span>
<span class="gi">+        elif part.startswith(&quot;bg:&quot;):</span>
<span class="gi">+            attrs = attrs._replace(bgcolor=parse_color(part[3:]))</span>
<span class="gi">+        elif part.startswith(&quot;fg:&quot;):  # The &#39;fg:&#39; prefix is optional.</span>
<span class="gi">+            attrs = attrs._replace(color=parse_color(part[3:]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            attrs = attrs._replace(color=parse_color(part))</span>
<span class="gi">+</span>
<span class="gi">+    return attrs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CLASS_NAMES_RE = re.compile(r&quot;^[a-z0-9.\s_-]*$&quot;)  # This one can&#39;t contain a comma!</span>


<span class="w"> </span>class Priority(Enum):
<span class="gu">@@ -64,10 +192,13 @@ class Priority(Enum):</span>
<span class="w"> </span>    - `MOST_PRECISE`: keys that are defined with most precision will get higher
<span class="w"> </span>      priority. (More precise means: more elements.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    DICT_KEY_ORDER = &#39;KEY_ORDER&#39;</span>
<span class="gd">-    MOST_PRECISE = &#39;MOST_PRECISE&#39;</span>

<span class="gi">+    DICT_KEY_ORDER = &quot;KEY_ORDER&quot;</span>
<span class="gi">+    MOST_PRECISE = &quot;MOST_PRECISE&quot;</span>

<span class="gi">+</span>
<span class="gi">+# We don&#39;t support Python versions older than 3.6 anymore, so we can always</span>
<span class="gi">+# depend on dictionary ordering. This is the default.</span>
<span class="w"> </span>default_priority = Priority.DICT_KEY_ORDER


<span class="gu">@@ -93,50 +224,135 @@ class Style(BaseStyle):</span>
<span class="w"> </span>    The ``from_dict`` classmethod is similar, but takes a dictionary as input.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, style_rules: list[tuple[str, str]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, style_rules: list[tuple[str, str]]) -&gt; None:</span>
<span class="w"> </span>        class_names_and_attrs = []
<span class="gi">+</span>
<span class="gi">+        # Loop through the rules in the order they were defined.</span>
<span class="gi">+        # Rules that are defined later get priority.</span>
<span class="w"> </span>        for class_names, style_str in style_rules:
<span class="w"> </span>            assert CLASS_NAMES_RE.match(class_names), repr(class_names)
<span class="gi">+</span>
<span class="gi">+            # The order of the class names doesn&#39;t matter.</span>
<span class="gi">+            # (But the order of rules does matter.)</span>
<span class="w"> </span>            class_names_set = frozenset(class_names.lower().split())
<span class="w"> </span>            attrs = _parse_style_str(style_str)
<span class="gi">+</span>
<span class="w"> </span>            class_names_and_attrs.append((class_names_set, attrs))
<span class="gi">+</span>
<span class="w"> </span>        self._style_rules = style_rules
<span class="w"> </span>        self.class_names_and_attrs = class_names_and_attrs

<span class="gi">+    @property</span>
<span class="gi">+    def style_rules(self) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+        return self._style_rules</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def from_dict(cls, style_dict: dict[str, str], priority: Priority=</span>
<span class="gd">-        default_priority) -&gt;Style:</span>
<span class="gi">+    def from_dict(</span>
<span class="gi">+        cls, style_dict: dict[str, str], priority: Priority = default_priority</span>
<span class="gi">+    ) -&gt; Style:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param style_dict: Style dictionary.
<span class="w"> </span>        :param priority: `Priority` value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if priority == Priority.MOST_PRECISE:</span>

<span class="gd">-    def get_attrs_for_style_str(self, style_str: str, default: Attrs=</span>
<span class="gd">-        DEFAULT_ATTRS) -&gt;Attrs:</span>
<span class="gi">+            def key(item: tuple[str, str]) -&gt; int:</span>
<span class="gi">+                # Split on &#39;.&#39; and whitespace. Count elements.</span>
<span class="gi">+                return sum(len(i.split(&quot;.&quot;)) for i in item[0].split())</span>
<span class="gi">+</span>
<span class="gi">+            return cls(sorted(style_dict.items(), key=key))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return cls(list(style_dict.items()))</span>
<span class="gi">+</span>
<span class="gi">+    def get_attrs_for_style_str(</span>
<span class="gi">+        self, style_str: str, default: Attrs = DEFAULT_ATTRS</span>
<span class="gi">+    ) -&gt; Attrs:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get `Attrs` for the given style string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        list_of_attrs = [default]</span>
<span class="gi">+        class_names: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        # Apply default styling.</span>
<span class="gi">+        for names, attr in self.class_names_and_attrs:</span>
<span class="gi">+            if not names:</span>
<span class="gi">+                list_of_attrs.append(attr)</span>
<span class="gi">+</span>
<span class="gi">+        # Go from left to right through the style string. Things on the right</span>
<span class="gi">+        # take precedence.</span>
<span class="gi">+        for part in style_str.split():</span>
<span class="gi">+            # This part represents a class.</span>
<span class="gi">+            # Do lookup of this class name in the style definition, as well</span>
<span class="gi">+            # as all class combinations that we have so far.</span>
<span class="gi">+            if part.startswith(&quot;class:&quot;):</span>
<span class="gi">+                # Expand all class names (comma separated list).</span>
<span class="gi">+                new_class_names = []</span>
<span class="gi">+                for p in part[6:].lower().split(&quot;,&quot;):</span>
<span class="gi">+                    new_class_names.extend(_expand_classname(p))</span>
<span class="gi">+</span>
<span class="gi">+                for new_name in new_class_names:</span>
<span class="gi">+                    # Build a set of all possible class combinations to be applied.</span>
<span class="gi">+                    combos = set()</span>
<span class="gi">+                    combos.add(frozenset([new_name]))</span>
<span class="gi">+</span>
<span class="gi">+                    for count in range(1, len(class_names) + 1):</span>
<span class="gi">+                        for c2 in itertools.combinations(class_names, count):</span>
<span class="gi">+                            combos.add(frozenset(c2 + (new_name,)))</span>
<span class="gi">+</span>
<span class="gi">+                    # Apply the styles that match these class names.</span>
<span class="gi">+                    for names, attr in self.class_names_and_attrs:</span>
<span class="gi">+                        if names in combos:</span>
<span class="gi">+                            list_of_attrs.append(attr)</span>

<span class="gi">+                    class_names.add(new_name)</span>

<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+            # Process inline style.</span>
<span class="gi">+            else:</span>
<span class="gi">+                inline_attrs = _parse_style_str(part)</span>
<span class="gi">+                list_of_attrs.append(inline_attrs)</span>

<span class="gi">+        return _merge_attrs(list_of_attrs)</span>

<span class="gd">-def _merge_attrs(list_of_attrs: list[Attrs]) -&gt;Attrs:</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return id(self.class_names_and_attrs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _merge_attrs(list_of_attrs: list[Attrs]) -&gt; Attrs:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a list of :class:`.Attrs` instances and merge them into one.
<span class="w"> </span>    Every `Attr` in the list can override the styling of the previous one. So,
<span class="w"> </span>    the last one has highest priority.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def merge_styles(styles: list[BaseStyle]) -&gt;_MergedStyle:</span>
<span class="gi">+    def _or(*values: _T) -&gt; _T:</span>
<span class="gi">+        &quot;Take first not-None value, starting at the end.&quot;</span>
<span class="gi">+        for v in values[::-1]:</span>
<span class="gi">+            if v is not None:</span>
<span class="gi">+                return v</span>
<span class="gi">+        raise ValueError  # Should not happen, there&#39;s always one non-null value.</span>
<span class="gi">+</span>
<span class="gi">+    return Attrs(</span>
<span class="gi">+        color=_or(&quot;&quot;, *[a.color for a in list_of_attrs]),</span>
<span class="gi">+        bgcolor=_or(&quot;&quot;, *[a.bgcolor for a in list_of_attrs]),</span>
<span class="gi">+        bold=_or(False, *[a.bold for a in list_of_attrs]),</span>
<span class="gi">+        underline=_or(False, *[a.underline for a in list_of_attrs]),</span>
<span class="gi">+        strike=_or(False, *[a.strike for a in list_of_attrs]),</span>
<span class="gi">+        italic=_or(False, *[a.italic for a in list_of_attrs]),</span>
<span class="gi">+        blink=_or(False, *[a.blink for a in list_of_attrs]),</span>
<span class="gi">+        reverse=_or(False, *[a.reverse for a in list_of_attrs]),</span>
<span class="gi">+        hidden=_or(False, *[a.hidden for a in list_of_attrs]),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge_styles(styles: list[BaseStyle]) -&gt; _MergedStyle:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple `Style` objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    styles = [s for s in styles if s is not None]</span>
<span class="gi">+    return _MergedStyle(styles)</span>


<span class="w"> </span>class _MergedStyle(BaseStyle):
<span class="gu">@@ -146,11 +362,39 @@ class _MergedStyle(BaseStyle):</span>
<span class="w"> </span>    then this style will be updated.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, styles: list[BaseStyle]) -&gt;None:</span>
<span class="gi">+    # NOTE: previously, we used an algorithm where we did not generate the</span>
<span class="gi">+    #       combined style. Instead this was a proxy that called one style</span>
<span class="gi">+    #       after the other, passing the outcome of the previous style as the</span>
<span class="gi">+    #       default for the next one. This did not work, because that way, the</span>
<span class="gi">+    #       priorities like described in the `Style` class don&#39;t work.</span>
<span class="gi">+    #       &#39;class:aborted&#39; was for instance never displayed in gray, because</span>
<span class="gi">+    #       the next style specified a default color for any text. (The</span>
<span class="gi">+    #       explicit styling of class:aborted should have taken priority,</span>
<span class="gi">+    #       because it was more precise.)</span>
<span class="gi">+    def __init__(self, styles: list[BaseStyle]) -&gt; None:</span>
<span class="w"> </span>        self.styles = styles
<span class="w"> </span>        self._style: SimpleCache[Hashable, Style] = SimpleCache(maxsize=1)

<span class="w"> </span>    @property
<span class="gd">-    def _merged_style(self) -&gt;Style:</span>
<span class="gd">-        &quot;&quot;&quot;The `Style` object that has the other styles merged together.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _merged_style(self) -&gt; Style:</span>
<span class="gi">+        &quot;The `Style` object that has the other styles merged together.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def get() -&gt; Style:</span>
<span class="gi">+            return Style(self.style_rules)</span>
<span class="gi">+</span>
<span class="gi">+        return self._style.get(self.invalidation_hash(), get)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def style_rules(self) -&gt; list[tuple[str, str]]:</span>
<span class="gi">+        style_rules = []</span>
<span class="gi">+        for s in self.styles:</span>
<span class="gi">+            style_rules.extend(s.style_rules)</span>
<span class="gi">+        return style_rules</span>
<span class="gi">+</span>
<span class="gi">+    def get_attrs_for_style_str(</span>
<span class="gi">+        self, style_str: str, default: Attrs = DEFAULT_ATTRS</span>
<span class="gi">+    ) -&gt; Attrs:</span>
<span class="gi">+        return self._merged_style.get_attrs_for_style_str(style_str, default)</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return tuple(s.invalidation_hash() for s in self.styles)</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/style_transformation.py b/src/prompt_toolkit/styles/style_transformation.py</span>
<span class="gh">index d15adc5c..fbb5a639 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/style_transformation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/style_transformation.py</span>
<span class="gu">@@ -10,19 +10,29 @@ style strings are turned into `Attrs` objects that represent the actual</span>
<span class="w"> </span>formatting.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from colorsys import hls_to_rgb, rgb_to_hls
<span class="w"> </span>from typing import Callable, Hashable, Sequence
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.cache import memoized
<span class="w"> </span>from prompt_toolkit.filters import FilterOrBool, to_filter
<span class="w"> </span>from prompt_toolkit.utils import AnyFloat, to_float, to_str
<span class="gi">+</span>
<span class="w"> </span>from .base import ANSI_COLOR_NAMES, Attrs
<span class="w"> </span>from .style import parse_color
<span class="gd">-__all__ = [&#39;StyleTransformation&#39;, &#39;SwapLightAndDarkStyleTransformation&#39;,</span>
<span class="gd">-    &#39;ReverseStyleTransformation&#39;, &#39;SetDefaultColorStyleTransformation&#39;,</span>
<span class="gd">-    &#39;AdjustBrightnessStyleTransformation&#39;, &#39;DummyStyleTransformation&#39;,</span>
<span class="gd">-    &#39;ConditionalStyleTransformation&#39;, &#39;DynamicStyleTransformation&#39;,</span>
<span class="gd">-    &#39;merge_style_transformations&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;StyleTransformation&quot;,</span>
<span class="gi">+    &quot;SwapLightAndDarkStyleTransformation&quot;,</span>
<span class="gi">+    &quot;ReverseStyleTransformation&quot;,</span>
<span class="gi">+    &quot;SetDefaultColorStyleTransformation&quot;,</span>
<span class="gi">+    &quot;AdjustBrightnessStyleTransformation&quot;,</span>
<span class="gi">+    &quot;DummyStyleTransformation&quot;,</span>
<span class="gi">+    &quot;ConditionalStyleTransformation&quot;,</span>
<span class="gi">+    &quot;DynamicStyleTransformation&quot;,</span>
<span class="gi">+    &quot;merge_style_transformations&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class StyleTransformation(metaclass=ABCMeta):
<span class="gu">@@ -31,20 +41,19 @@ class StyleTransformation(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def transform_attrs(self, attrs: Attrs) -&gt;Attrs:</span>
<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Take an `Attrs` object and return a new `Attrs` object.

<span class="w"> </span>        Remember that the color formats can be either &quot;ansi...&quot; or a 6 digit
<span class="w"> </span>        lowercase hexadecimal color (without &#39;#&#39; prefix).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When this changes, the cache should be invalidated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}-{id(self)}&quot;</span>


<span class="w"> </span>class SwapLightAndDarkStyleTransformation(StyleTransformation):
<span class="gu">@@ -65,11 +74,15 @@ class SwapLightAndDarkStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>    reverse works good with that.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def transform_attrs(self, attrs: Attrs) -&gt;Attrs:</span>
<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `Attrs` used when opposite luminosity should be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Reverse colors.</span>
<span class="gi">+        attrs = attrs._replace(color=get_opposite_color(attrs.color))</span>
<span class="gi">+        attrs = attrs._replace(bgcolor=get_opposite_color(attrs.bgcolor))</span>
<span class="gi">+</span>
<span class="gi">+        return attrs</span>


<span class="w"> </span>class ReverseStyleTransformation(StyleTransformation):
<span class="gu">@@ -79,6 +92,9 @@ class ReverseStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>    (This is still experimental.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        return attrs._replace(reverse=not attrs.reverse)</span>
<span class="gi">+</span>

<span class="w"> </span>class SetDefaultColorStyleTransformation(StyleTransformation):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -90,11 +106,28 @@ class SetDefaultColorStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>    :param bg: Like `fg`, but for the background.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, fg: (str | Callable[[], str]), bg: (str | Callable[[</span>
<span class="gd">-        ], str])) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, fg: str | Callable[[], str], bg: str | Callable[[], str]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.fg = fg
<span class="w"> </span>        self.bg = bg

<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        if attrs.bgcolor in (&quot;&quot;, &quot;default&quot;):</span>
<span class="gi">+            attrs = attrs._replace(bgcolor=parse_color(to_str(self.bg)))</span>
<span class="gi">+</span>
<span class="gi">+        if attrs.color in (&quot;&quot;, &quot;default&quot;):</span>
<span class="gi">+            attrs = attrs._replace(color=parse_color(to_str(self.fg)))</span>
<span class="gi">+</span>
<span class="gi">+        return attrs</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return (</span>
<span class="gi">+            &quot;set-default-color&quot;,</span>
<span class="gi">+            to_str(self.fg),</span>
<span class="gi">+            to_str(self.bg),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class AdjustBrightnessStyleTransformation(StyleTransformation):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -120,23 +153,78 @@ class AdjustBrightnessStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>        a float.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, min_brightness: AnyFloat=0.0, max_brightness:</span>
<span class="gd">-        AnyFloat=1.0) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, min_brightness: AnyFloat = 0.0, max_brightness: AnyFloat = 1.0</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.min_brightness = min_brightness
<span class="w"> </span>        self.max_brightness = max_brightness

<span class="gd">-    def _color_to_rgb(self, color: str) -&gt;tuple[float, float, float]:</span>
<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        min_brightness = to_float(self.min_brightness)</span>
<span class="gi">+        max_brightness = to_float(self.max_brightness)</span>
<span class="gi">+        assert 0 &lt;= min_brightness &lt;= 1</span>
<span class="gi">+        assert 0 &lt;= max_brightness &lt;= 1</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t do anything if the whole brightness range is acceptable.</span>
<span class="gi">+        # This also avoids turning ansi colors into RGB sequences.</span>
<span class="gi">+        if min_brightness == 0.0 and max_brightness == 1.0:</span>
<span class="gi">+            return attrs</span>
<span class="gi">+</span>
<span class="gi">+        # If a foreground color is given without a background color.</span>
<span class="gi">+        no_background = not attrs.bgcolor or attrs.bgcolor == &quot;default&quot;</span>
<span class="gi">+        has_fgcolor = attrs.color and attrs.color != &quot;ansidefault&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if has_fgcolor and no_background:</span>
<span class="gi">+            # Calculate new RGB values.</span>
<span class="gi">+            r, g, b = self._color_to_rgb(attrs.color or &quot;&quot;)</span>
<span class="gi">+            hue, brightness, saturation = rgb_to_hls(r, g, b)</span>
<span class="gi">+            brightness = self._interpolate_brightness(</span>
<span class="gi">+                brightness, min_brightness, max_brightness</span>
<span class="gi">+            )</span>
<span class="gi">+            r, g, b = hls_to_rgb(hue, brightness, saturation)</span>
<span class="gi">+            new_color = f&quot;{int(r * 255):02x}{int(g * 255):02x}{int(b * 255):02x}&quot;</span>
<span class="gi">+</span>
<span class="gi">+            attrs = attrs._replace(color=new_color)</span>
<span class="gi">+</span>
<span class="gi">+        return attrs</span>
<span class="gi">+</span>
<span class="gi">+    def _color_to_rgb(self, color: str) -&gt; tuple[float, float, float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parse `style.Attrs` color into RGB tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _interpolate_brightness(self, value: float, min_brightness: float,</span>
<span class="gd">-        max_brightness: float) -&gt;float:</span>
<span class="gi">+        # Do RGB lookup for ANSI colors.</span>
<span class="gi">+        try:</span>
<span class="gi">+            from prompt_toolkit.output.vt100 import ANSI_COLORS_TO_RGB</span>
<span class="gi">+</span>
<span class="gi">+            r, g, b = ANSI_COLORS_TO_RGB[color]</span>
<span class="gi">+            return r / 255.0, g / 255.0, b / 255.0</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Parse RRGGBB format.</span>
<span class="gi">+        return (</span>
<span class="gi">+            int(color[0:2], 16) / 255.0,</span>
<span class="gi">+            int(color[2:4], 16) / 255.0,</span>
<span class="gi">+            int(color[4:6], 16) / 255.0,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: we don&#39;t have to support named colors here. They are already</span>
<span class="gi">+        #       transformed into RGB values in `style.parse_color`.</span>
<span class="gi">+</span>
<span class="gi">+    def _interpolate_brightness(</span>
<span class="gi">+        self, value: float, min_brightness: float, max_brightness: float</span>
<span class="gi">+    ) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Map the brightness to the (min_brightness..max_brightness) range.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return min_brightness + (max_brightness - min_brightness) * value</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return (</span>
<span class="gi">+            &quot;adjust-brightness&quot;,</span>
<span class="gi">+            to_float(self.min_brightness),</span>
<span class="gi">+            to_float(self.max_brightness),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class DummyStyleTransformation(StyleTransformation):
<span class="gu">@@ -144,6 +232,13 @@ class DummyStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>    Don&#39;t transform anything at all.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        return attrs</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        # Always return the same hash for these dummy instances.</span>
<span class="gi">+        return &quot;dummy-style-transformation&quot;</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicStyleTransformation(StyleTransformation):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -154,52 +249,94 @@ class DynamicStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>        :class:`.StyleTransformation` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_style_transformation: Callable[[], </span>
<span class="gd">-        StyleTransformation | None]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, get_style_transformation: Callable[[], StyleTransformation | None]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.get_style_transformation = get_style_transformation

<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        style_transformation = (</span>
<span class="gi">+            self.get_style_transformation() or DummyStyleTransformation()</span>
<span class="gi">+        )</span>
<span class="gi">+        return style_transformation.transform_attrs(attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        style_transformation = (</span>
<span class="gi">+            self.get_style_transformation() or DummyStyleTransformation()</span>
<span class="gi">+        )</span>
<span class="gi">+        return style_transformation.invalidation_hash()</span>
<span class="gi">+</span>

<span class="w"> </span>class ConditionalStyleTransformation(StyleTransformation):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply the style transformation depending on a condition.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, style_transformation: StyleTransformation, filter:</span>
<span class="gd">-        FilterOrBool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, style_transformation: StyleTransformation, filter: FilterOrBool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.style_transformation = style_transformation
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.style_transformation.transform_attrs(attrs)</span>
<span class="gi">+        return attrs</span>

<span class="gd">-class _MergedStyleTransformation(StyleTransformation):</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return (self.filter(), self.style_transformation.invalidation_hash())</span>

<span class="gd">-    def __init__(self, style_transformations: Sequence[StyleTransformation]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class _MergedStyleTransformation(StyleTransformation):</span>
<span class="gi">+    def __init__(self, style_transformations: Sequence[StyleTransformation]) -&gt; None:</span>
<span class="w"> </span>        self.style_transformations = style_transformations

<span class="gi">+    def transform_attrs(self, attrs: Attrs) -&gt; Attrs:</span>
<span class="gi">+        for transformation in self.style_transformations:</span>
<span class="gi">+            attrs = transformation.transform_attrs(attrs)</span>
<span class="gi">+        return attrs</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt; Hashable:</span>
<span class="gi">+        return tuple(t.invalidation_hash() for t in self.style_transformations)</span>
<span class="gi">+</span>

<span class="gd">-def merge_style_transformations(style_transformations: Sequence[</span>
<span class="gd">-    StyleTransformation]) -&gt;StyleTransformation:</span>
<span class="gi">+def merge_style_transformations(</span>
<span class="gi">+    style_transformations: Sequence[StyleTransformation],</span>
<span class="gi">+) -&gt; StyleTransformation:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple transformations together.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-OPPOSITE_ANSI_COLOR_NAMES = {&#39;ansidefault&#39;: &#39;ansidefault&#39;, &#39;ansiblack&#39;:</span>
<span class="gd">-    &#39;ansiwhite&#39;, &#39;ansired&#39;: &#39;ansibrightred&#39;, &#39;ansigreen&#39;: &#39;ansibrightgreen&#39;,</span>
<span class="gd">-    &#39;ansiyellow&#39;: &#39;ansibrightyellow&#39;, &#39;ansiblue&#39;: &#39;ansibrightblue&#39;,</span>
<span class="gd">-    &#39;ansimagenta&#39;: &#39;ansibrightmagenta&#39;, &#39;ansicyan&#39;: &#39;ansibrightcyan&#39;,</span>
<span class="gd">-    &#39;ansigray&#39;: &#39;ansibrightblack&#39;, &#39;ansiwhite&#39;: &#39;ansiblack&#39;,</span>
<span class="gd">-    &#39;ansibrightred&#39;: &#39;ansired&#39;, &#39;ansibrightgreen&#39;: &#39;ansigreen&#39;,</span>
<span class="gd">-    &#39;ansibrightyellow&#39;: &#39;ansiyellow&#39;, &#39;ansibrightblue&#39;: &#39;ansiblue&#39;,</span>
<span class="gd">-    &#39;ansibrightmagenta&#39;: &#39;ansimagenta&#39;, &#39;ansibrightcyan&#39;: &#39;ansicyan&#39;,</span>
<span class="gd">-    &#39;ansibrightblack&#39;: &#39;ansigray&#39;}</span>
<span class="gi">+    return _MergedStyleTransformation(style_transformations)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Dictionary that maps ANSI color names to their opposite. This is useful for</span>
<span class="gi">+# turning color schemes that are optimized for a black background usable for a</span>
<span class="gi">+# white background.</span>
<span class="gi">+OPPOSITE_ANSI_COLOR_NAMES = {</span>
<span class="gi">+    &quot;ansidefault&quot;: &quot;ansidefault&quot;,</span>
<span class="gi">+    &quot;ansiblack&quot;: &quot;ansiwhite&quot;,</span>
<span class="gi">+    &quot;ansired&quot;: &quot;ansibrightred&quot;,</span>
<span class="gi">+    &quot;ansigreen&quot;: &quot;ansibrightgreen&quot;,</span>
<span class="gi">+    &quot;ansiyellow&quot;: &quot;ansibrightyellow&quot;,</span>
<span class="gi">+    &quot;ansiblue&quot;: &quot;ansibrightblue&quot;,</span>
<span class="gi">+    &quot;ansimagenta&quot;: &quot;ansibrightmagenta&quot;,</span>
<span class="gi">+    &quot;ansicyan&quot;: &quot;ansibrightcyan&quot;,</span>
<span class="gi">+    &quot;ansigray&quot;: &quot;ansibrightblack&quot;,</span>
<span class="gi">+    &quot;ansiwhite&quot;: &quot;ansiblack&quot;,</span>
<span class="gi">+    &quot;ansibrightred&quot;: &quot;ansired&quot;,</span>
<span class="gi">+    &quot;ansibrightgreen&quot;: &quot;ansigreen&quot;,</span>
<span class="gi">+    &quot;ansibrightyellow&quot;: &quot;ansiyellow&quot;,</span>
<span class="gi">+    &quot;ansibrightblue&quot;: &quot;ansiblue&quot;,</span>
<span class="gi">+    &quot;ansibrightmagenta&quot;: &quot;ansimagenta&quot;,</span>
<span class="gi">+    &quot;ansibrightcyan&quot;: &quot;ansicyan&quot;,</span>
<span class="gi">+    &quot;ansibrightblack&quot;: &quot;ansigray&quot;,</span>
<span class="gi">+}</span>
<span class="w"> </span>assert set(OPPOSITE_ANSI_COLOR_NAMES.keys()) == set(ANSI_COLOR_NAMES)
<span class="w"> </span>assert set(OPPOSITE_ANSI_COLOR_NAMES.values()) == set(ANSI_COLOR_NAMES)


<span class="w"> </span>@memoized()
<span class="gd">-def get_opposite_color(colorname: (str | None)) -&gt;(str | None):</span>
<span class="gi">+def get_opposite_color(colorname: str | None) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a color name in either &#39;ansi...&#39; format or 6 digit RGB, return the
<span class="w"> </span>    color of opposite luminosity (same hue/saturation).
<span class="gu">@@ -207,4 +344,30 @@ def get_opposite_color(colorname: (str | None)) -&gt;(str | None):</span>
<span class="w"> </span>    This is used for turning color schemes that work on a light background
<span class="w"> </span>    usable on a dark background.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if colorname is None:  # Because color/bgcolor can be None in `Attrs`.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # Special values.</span>
<span class="gi">+    if colorname in (&quot;&quot;, &quot;default&quot;):</span>
<span class="gi">+        return colorname</span>
<span class="gi">+</span>
<span class="gi">+    # Try ANSI color names.</span>
<span class="gi">+    try:</span>
<span class="gi">+        return OPPOSITE_ANSI_COLOR_NAMES[colorname]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        # Try 6 digit RGB colors.</span>
<span class="gi">+        r = int(colorname[:2], 16) / 255.0</span>
<span class="gi">+        g = int(colorname[2:4], 16) / 255.0</span>
<span class="gi">+        b = int(colorname[4:6], 16) / 255.0</span>
<span class="gi">+</span>
<span class="gi">+        h, l, s = rgb_to_hls(r, g, b)</span>
<span class="gi">+</span>
<span class="gi">+        l = 1 - l</span>
<span class="gi">+</span>
<span class="gi">+        r, g, b = hls_to_rgb(h, l, s)</span>
<span class="gi">+</span>
<span class="gi">+        r = int(r * 255)</span>
<span class="gi">+        g = int(g * 255)</span>
<span class="gi">+        b = int(b * 255)</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{r:02x}{g:02x}{b:02x}&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/token.py b/src/prompt_toolkit/token.py</span>
<span class="gh">index cd41734d..a2c80e54 100644</span>
<span class="gd">--- a/src/prompt_toolkit/token.py</span>
<span class="gi">+++ b/src/prompt_toolkit/token.py</span>
<span class="gu">@@ -1,5 +1,10 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gd">-__all__ = [&#39;ZeroWidthEscape&#39;]</span>
<span class="gd">-ZeroWidthEscape = &#39;[ZeroWidthEscape]&#39;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ZeroWidthEscape&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+ZeroWidthEscape = &quot;[ZeroWidthEscape]&quot;</span>
<span class="gh">diff --git a/src/prompt_toolkit/utils.py b/src/prompt_toolkit/utils.py</span>
<span class="gh">index 32a37c22..1a99a286 100644</span>
<span class="gd">--- a/src/prompt_toolkit/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/utils.py</span>
<span class="gu">@@ -1,18 +1,45 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import signal
<span class="w"> </span>import sys
<span class="w"> </span>import threading
<span class="w"> </span>from collections import deque
<span class="gd">-from typing import Callable, ContextManager, Dict, Generator, Generic, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    ContextManager,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from wcwidth import wcwidth
<span class="gd">-__all__ = [&#39;Event&#39;, &#39;DummyContext&#39;, &#39;get_cwidth&#39;,</span>
<span class="gd">-    &#39;suspend_to_background_supported&#39;, &#39;is_conemu_ansi&#39;, &#39;is_windows&#39;,</span>
<span class="gd">-    &#39;in_main_thread&#39;, &#39;get_bell_environment_variable&#39;,</span>
<span class="gd">-    &#39;get_term_environment_variable&#39;, &#39;take_using_weights&#39;, &#39;to_str&#39;,</span>
<span class="gd">-    &#39;to_int&#39;, &#39;AnyFloat&#39;, &#39;to_float&#39;, &#39;is_dumb_terminal&#39;]</span>
<span class="gd">-SPHINX_AUTODOC_RUNNING = &#39;sphinx.ext.autodoc&#39; in sys.modules</span>
<span class="gd">-_Sender = TypeVar(&#39;_Sender&#39;, covariant=True)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Event&quot;,</span>
<span class="gi">+    &quot;DummyContext&quot;,</span>
<span class="gi">+    &quot;get_cwidth&quot;,</span>
<span class="gi">+    &quot;suspend_to_background_supported&quot;,</span>
<span class="gi">+    &quot;is_conemu_ansi&quot;,</span>
<span class="gi">+    &quot;is_windows&quot;,</span>
<span class="gi">+    &quot;in_main_thread&quot;,</span>
<span class="gi">+    &quot;get_bell_environment_variable&quot;,</span>
<span class="gi">+    &quot;get_term_environment_variable&quot;,</span>
<span class="gi">+    &quot;take_using_weights&quot;,</span>
<span class="gi">+    &quot;to_str&quot;,</span>
<span class="gi">+    &quot;to_int&quot;,</span>
<span class="gi">+    &quot;AnyFloat&quot;,</span>
<span class="gi">+    &quot;to_float&quot;,</span>
<span class="gi">+    &quot;is_dumb_terminal&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Used to ensure sphinx autodoc does not try to import platform-specific</span>
<span class="gi">+# stuff when documenting win32.py modules.</span>
<span class="gi">+SPHINX_AUTODOC_RUNNING = &quot;sphinx.ext.autodoc&quot; in sys.modules</span>
<span class="gi">+</span>
<span class="gi">+_Sender = TypeVar(&quot;_Sender&quot;, covariant=True)</span>


<span class="w"> </span>class Event(Generic[_Sender]):
<span class="gu">@@ -36,44 +63,48 @@ class Event(Generic[_Sender]):</span>
<span class="w"> </span>        obj.event()
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, sender: _Sender, handler: (Callable[[_Sender], None] |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, sender: _Sender, handler: Callable[[_Sender], None] | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.sender = sender
<span class="w"> </span>        self._handlers: list[Callable[[_Sender], None]] = []
<span class="gi">+</span>
<span class="w"> </span>        if handler is not None:
<span class="w"> </span>            self += handler

<span class="gd">-    def __call__(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Fire event.&quot;&quot;&quot;</span>
<span class="gi">+    def __call__(self) -&gt; None:</span>
<span class="gi">+        &quot;Fire event.&quot;</span>
<span class="w"> </span>        for handler in self._handlers:
<span class="w"> </span>            handler(self.sender)

<span class="gd">-    def fire(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Alias for just calling the event.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def fire(self) -&gt; None:</span>
<span class="gi">+        &quot;Alias for just calling the event.&quot;</span>
<span class="gi">+        self()</span>

<span class="gd">-    def add_handler(self, handler: Callable[[_Sender], None]) -&gt;None:</span>
<span class="gi">+    def add_handler(self, handler: Callable[[_Sender], None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add another handler to this callback.
<span class="w"> </span>        (Handler should be a callable that takes exactly one parameter: the
<span class="w"> </span>        sender object.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Add to list of event handlers.</span>
<span class="gi">+        self._handlers.append(handler)</span>

<span class="gd">-    def remove_handler(self, handler: Callable[[_Sender], None]) -&gt;None:</span>
<span class="gi">+    def remove_handler(self, handler: Callable[[_Sender], None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove a handler from this callback.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if handler in self._handlers:</span>
<span class="gi">+            self._handlers.remove(handler)</span>

<span class="gd">-    def __iadd__(self, handler: Callable[[_Sender], None]) -&gt;Event[_Sender]:</span>
<span class="gi">+    def __iadd__(self, handler: Callable[[_Sender], None]) -&gt; Event[_Sender]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        `event += handler` notation for adding a handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.add_handler(handler)
<span class="w"> </span>        return self

<span class="gd">-    def __isub__(self, handler: Callable[[_Sender], None]) -&gt;Event[_Sender]:</span>
<span class="gi">+    def __isub__(self, handler: Callable[[_Sender], None]) -&gt; Event[_Sender]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        `event -= handler` notation for removing a handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -86,10 +117,10 @@ class DummyContext(ContextManager[None]):</span>
<span class="w"> </span>    (contextlib.nested is not available on Py3)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def __exit__(self, *a: object) -&gt;None:</span>
<span class="gi">+    def __exit__(self, *a: object) -&gt; None:</span>
<span class="w"> </span>        pass


<span class="gu">@@ -97,93 +128,114 @@ class _CharSizesCache(Dict[str, int]):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Cache for wcwidth sizes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    LONG_STRING_MIN_LEN = 64</span>
<span class="gd">-    MAX_LONG_STRINGS = 16</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    LONG_STRING_MIN_LEN = 64  # Minimum string length for considering it long.</span>
<span class="gi">+    MAX_LONG_STRINGS = 16  # Maximum number of long strings to remember.</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+        # Keep track of the &quot;long&quot; strings in this cache.</span>
<span class="w"> </span>        self._long_strings: deque[str] = deque()

<span class="gd">-    def __missing__(self, string: str) -&gt;int:</span>
<span class="gi">+    def __missing__(self, string: str) -&gt; int:</span>
<span class="gi">+        # Note: We use the `max(0, ...` because some non printable control</span>
<span class="gi">+        #       characters, like e.g. Ctrl-underscore get a -1 wcwidth value.</span>
<span class="gi">+        #       It can be possible that these characters end up in the input</span>
<span class="gi">+        #       text.</span>
<span class="w"> </span>        result: int
<span class="w"> </span>        if len(string) == 1:
<span class="w"> </span>            result = max(0, wcwidth(string))
<span class="w"> </span>        else:
<span class="w"> </span>            result = sum(self[c] for c in string)
<span class="gi">+</span>
<span class="gi">+        # Store in cache.</span>
<span class="w"> </span>        self[string] = result
<span class="gi">+</span>
<span class="gi">+        # Rotate long strings.</span>
<span class="gi">+        # (It&#39;s hard to tell what we can consider short...)</span>
<span class="w"> </span>        if len(string) &gt; self.LONG_STRING_MIN_LEN:
<span class="w"> </span>            long_strings = self._long_strings
<span class="w"> </span>            long_strings.append(string)
<span class="gi">+</span>
<span class="w"> </span>            if len(long_strings) &gt; self.MAX_LONG_STRINGS:
<span class="w"> </span>                key_to_remove = long_strings.popleft()
<span class="w"> </span>                if key_to_remove in self:
<span class="w"> </span>                    del self[key_to_remove]
<span class="gi">+</span>
<span class="w"> </span>        return result


<span class="w"> </span>_CHAR_SIZES_CACHE = _CharSizesCache()


<span class="gd">-def get_cwidth(string: str) -&gt;int:</span>
<span class="gi">+def get_cwidth(string: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return width of a string. Wrapper around ``wcwidth``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _CHAR_SIZES_CACHE[string]</span>


<span class="gd">-def suspend_to_background_supported() -&gt;bool:</span>
<span class="gi">+def suspend_to_background_supported() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns `True` when the Python implementation supports
<span class="w"> </span>    suspend-to-background. This is typically `False&#39; on Windows systems.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(signal, &quot;SIGTSTP&quot;)</span>


<span class="gd">-def is_windows() -&gt;bool:</span>
<span class="gi">+def is_windows() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when we are using Windows.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sys.platform == &quot;win32&quot;  # Not &#39;darwin&#39; or &#39;linux2&#39;</span>


<span class="gd">-def is_windows_vt100_supported() -&gt;bool:</span>
<span class="gi">+def is_windows_vt100_supported() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when we are using Windows, but VT100 escape sequences are supported.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        # Import needs to be inline. Windows libraries are not always available.</span>
<span class="gi">+        from prompt_toolkit.output.windows10 import is_win_vt100_enabled</span>
<span class="gi">+</span>
<span class="gi">+        return is_win_vt100_enabled()</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="gd">-def is_conemu_ansi() -&gt;bool:</span>
<span class="gi">+def is_conemu_ansi() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the ConEmu Windows console is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sys.platform == &quot;win32&quot; and os.environ.get(&quot;ConEmuANSI&quot;, &quot;OFF&quot;) == &quot;ON&quot;</span>


<span class="gd">-def in_main_thread() -&gt;bool:</span>
<span class="gi">+def in_main_thread() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the current thread is the main thread.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return threading.current_thread().__class__.__name__ == &quot;_MainThread&quot;</span>


<span class="gd">-def get_bell_environment_variable() -&gt;bool:</span>
<span class="gi">+def get_bell_environment_variable() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True if env variable is set to true (true, TRUE, True, 1).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = os.environ.get(&quot;PROMPT_TOOLKIT_BELL&quot;, &quot;true&quot;)</span>
<span class="gi">+    return value.lower() in (&quot;1&quot;, &quot;true&quot;)</span>


<span class="gd">-def get_term_environment_variable() -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Return the $TERM environment variable.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def get_term_environment_variable() -&gt; str:</span>
<span class="gi">+    &quot;Return the $TERM environment variable.&quot;</span>
<span class="gi">+    return os.environ.get(&quot;TERM&quot;, &quot;&quot;)</span>


<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="gd">-def take_using_weights(items: list[_T], weights: list[int]) -&gt;Generator[_T,</span>
<span class="gd">-    None, None]:</span>
<span class="gi">+def take_using_weights(</span>
<span class="gi">+    items: list[_T], weights: list[int]</span>
<span class="gi">+) -&gt; Generator[_T, None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generator that keeps yielding items from the items list, in proportion to
<span class="w"> </span>    their weight. For instance::
<span class="gu">@@ -196,32 +248,80 @@ def take_using_weights(items: list[_T], weights: list[int]) -&gt;Generator[_T,</span>
<span class="w"> </span>    :param weights: Integers representing the weight. (Numbers have to be
<span class="w"> </span>                    integers, not floats.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert len(items) == len(weights)</span>
<span class="gi">+    assert len(items) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    # Remove items with zero-weight.</span>
<span class="gi">+    items2 = []</span>
<span class="gi">+    weights2 = []</span>
<span class="gi">+    for item, w in zip(items, weights):</span>
<span class="gi">+        if w &gt; 0:</span>
<span class="gi">+            items2.append(item)</span>
<span class="gi">+            weights2.append(w)</span>
<span class="gi">+</span>
<span class="gi">+    items = items2</span>
<span class="gi">+    weights = weights2</span>
<span class="gi">+</span>
<span class="gi">+    # Make sure that we have some items left.</span>
<span class="gi">+    if not items:</span>
<span class="gi">+        raise ValueError(&quot;Did&#39;t got any items with a positive weight.&quot;)</span>

<span class="gi">+    #</span>
<span class="gi">+    already_taken = [0 for i in items]</span>
<span class="gi">+    item_count = len(items)</span>
<span class="gi">+    max_weight = max(weights)</span>

<span class="gd">-def to_str(value: (Callable[[], str] | str)) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Turn callable or string into string.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # Each iteration of this loop, we fill up until by (total_weight/max_weight).</span>
<span class="gi">+        adding = True</span>
<span class="gi">+        while adding:</span>
<span class="gi">+            adding = False</span>

<span class="gi">+            for item_i, item, weight in zip(range(item_count), items, weights):</span>
<span class="gi">+                if already_taken[item_i] &lt; i * weight / float(max_weight):</span>
<span class="gi">+                    yield item</span>
<span class="gi">+                    already_taken[item_i] += 1</span>
<span class="gi">+                    adding = True</span>

<span class="gd">-def to_int(value: (Callable[[], int] | int)) -&gt;int:</span>
<span class="gd">-    &quot;&quot;&quot;Turn callable or int into int.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+        i += 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_str(value: Callable[[], str] | str) -&gt; str:</span>
<span class="gi">+    &quot;Turn callable or string into string.&quot;</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return to_str(value())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_int(value: Callable[[], int] | int) -&gt; int:</span>
<span class="gi">+    &quot;Turn callable or int into int.&quot;</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return to_int(value())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return int(value)</span>


<span class="w"> </span>AnyFloat = Union[Callable[[], float], float]


<span class="gd">-def to_float(value: AnyFloat) -&gt;float:</span>
<span class="gd">-    &quot;&quot;&quot;Turn callable or float into float.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def to_float(value: AnyFloat) -&gt; float:</span>
<span class="gi">+    &quot;Turn callable or float into float.&quot;</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return to_float(value())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return float(value)</span>


<span class="gd">-def is_dumb_terminal(term: (str | None)=None) -&gt;bool:</span>
<span class="gi">+def is_dumb_terminal(term: str | None = None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True if this terminal type is considered &quot;dumb&quot;.

<span class="w"> </span>    If so, we should fall back to the simplest possible form of line editing,
<span class="w"> </span>    without cursor positioning and color support.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if term is None:</span>
<span class="gi">+        return is_dumb_terminal(os.environ.get(&quot;TERM&quot;, &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    return term.lower() in [&quot;dumb&quot;, &quot;unknown&quot;]</span>
<span class="gh">diff --git a/src/prompt_toolkit/validation.py b/src/prompt_toolkit/validation.py</span>
<span class="gh">index 76ed1cda..127445e8 100644</span>
<span class="gd">--- a/src/prompt_toolkit/validation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/validation.py</span>
<span class="gu">@@ -3,13 +3,23 @@ Input validation for a `Buffer`.</span>
<span class="w"> </span>(Validators will be called before accepting input.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABCMeta, abstractmethod
<span class="w"> </span>from typing import Callable
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.eventloop import run_in_executor_with_context
<span class="gi">+</span>
<span class="w"> </span>from .document import Document
<span class="w"> </span>from .filters import FilterOrBool, to_filter
<span class="gd">-__all__ = [&#39;ConditionalValidator&#39;, &#39;ValidationError&#39;, &#39;Validator&#39;,</span>
<span class="gd">-    &#39;ThreadedValidator&#39;, &#39;DummyValidator&#39;, &#39;DynamicValidator&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ConditionalValidator&quot;,</span>
<span class="gi">+    &quot;ValidationError&quot;,</span>
<span class="gi">+    &quot;Validator&quot;,</span>
<span class="gi">+    &quot;ThreadedValidator&quot;,</span>
<span class="gi">+    &quot;DummyValidator&quot;,</span>
<span class="gi">+    &quot;DynamicValidator&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ValidationError(Exception):
<span class="gu">@@ -20,14 +30,17 @@ class ValidationError(Exception):</span>
<span class="w"> </span>    :param message: Text.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cursor_position: int=0, message: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, cursor_position: int = 0, message: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)
<span class="w"> </span>        self.cursor_position = cursor_position
<span class="w"> </span>        self.message = message

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(cursor_position={!r}, message={!r})&#39;.format(self.</span>
<span class="gd">-            __class__.__name__, self.cursor_position, self.message)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(cursor_position={!r}, message={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.cursor_position,</span>
<span class="gi">+            self.message,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class Validator(metaclass=ABCMeta):
<span class="gu">@@ -44,7 +57,7 @@ class Validator(metaclass=ABCMeta):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def validate(self, document: Document) -&gt;None:</span>
<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Validate the input.
<span class="w"> </span>        If invalid, this should raise a :class:`.ValidationError`.
<span class="gu">@@ -53,18 +66,24 @@ class Validator(metaclass=ABCMeta):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    async def validate_async(self, document: Document) -&gt;None:</span>
<span class="gi">+    async def validate_async(self, document: Document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a `Future` which is set when the validation is ready.
<span class="w"> </span>        This function can be overloaded in order to provide an asynchronous
<span class="w"> </span>        implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.validate(document)</span>
<span class="gi">+        except ValidationError:</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_callable(cls, validate_func: Callable[[str], bool],</span>
<span class="gd">-        error_message: str=&#39;Invalid input&#39;, move_cursor_to_end: bool=False</span>
<span class="gd">-        ) -&gt;Validator:</span>
<span class="gi">+    def from_callable(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        validate_func: Callable[[str], bool],</span>
<span class="gi">+        error_message: str = &quot;Invalid input&quot;,</span>
<span class="gi">+        move_cursor_to_end: bool = False,</span>
<span class="gi">+    ) -&gt; Validator:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a validator from a simple validate callable. E.g.:

<span class="gu">@@ -80,7 +99,7 @@ class Validator(metaclass=ABCMeta):</span>
<span class="w"> </span>        :param move_cursor_to_end: Move the cursor to the end of the input, if
<span class="w"> </span>            the input is invalid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _ValidatorFromCallable(validate_func, error_message, move_cursor_to_end)</span>


<span class="w"> </span>class _ValidatorFromCallable(Validator):
<span class="gu">@@ -88,14 +107,24 @@ class _ValidatorFromCallable(Validator):</span>
<span class="w"> </span>    Validate input from a simple callable.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, func: Callable[[str], bool], error_message: str,</span>
<span class="gd">-        move_cursor_to_end: bool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, func: Callable[[str], bool], error_message: str, move_cursor_to_end: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.func = func
<span class="w"> </span>        self.error_message = error_message
<span class="w"> </span>        self.move_cursor_to_end = move_cursor_to_end

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;Validator.from_callable({self.func!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;Validator.from_callable({self.func!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="gi">+        if not self.func(document.text):</span>
<span class="gi">+            if self.move_cursor_to_end:</span>
<span class="gi">+                index = len(document.text)</span>
<span class="gi">+            else:</span>
<span class="gi">+                index = 0</span>
<span class="gi">+</span>
<span class="gi">+            raise ValidationError(cursor_position=index, message=self.error_message)</span>


<span class="w"> </span>class ThreadedValidator(Validator):
<span class="gu">@@ -105,14 +134,21 @@ class ThreadedValidator(Validator):</span>
<span class="w"> </span>    input validation takes too much time.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, validator: Validator) -&gt;None:</span>
<span class="gi">+    def __init__(self, validator: Validator) -&gt; None:</span>
<span class="w"> </span>        self.validator = validator

<span class="gd">-    async def validate_async(self, document: Document) -&gt;None:</span>
<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="gi">+        self.validator.validate(document)</span>
<span class="gi">+</span>
<span class="gi">+    async def validate_async(self, document: Document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run the `validate` function in a thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def run_validation_thread() -&gt; None:</span>
<span class="gi">+            return self.validate(document)</span>
<span class="gi">+</span>
<span class="gi">+        await run_in_executor_with_context(run_validation_thread)</span>


<span class="w"> </span>class DummyValidator(Validator):
<span class="gu">@@ -120,6 +156,9 @@ class DummyValidator(Validator):</span>
<span class="w"> </span>    Validator class that accepts any input.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="gi">+        pass  # Don&#39;t raise any exception.</span>
<span class="gi">+</span>

<span class="w"> </span>class ConditionalValidator(Validator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -127,10 +166,15 @@ class ConditionalValidator(Validator):</span>
<span class="w"> </span>    a filter. (This wraps around another validator.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, validator: Validator, filter: FilterOrBool) -&gt;None:</span>
<span class="gi">+    def __init__(self, validator: Validator, filter: FilterOrBool) -&gt; None:</span>
<span class="w"> </span>        self.validator = validator
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="gi">+        # Call the validator only if the filter is active.</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            self.validator.validate(document)</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicValidator(Validator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -139,5 +183,13 @@ class DynamicValidator(Validator):</span>
<span class="w"> </span>    :param get_validator: Callable that returns a :class:`.Validator` instance.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, get_validator: Callable[[], Validator | None]) -&gt;None:</span>
<span class="gi">+    def __init__(self, get_validator: Callable[[], Validator | None]) -&gt; None:</span>
<span class="w"> </span>        self.get_validator = get_validator
<span class="gi">+</span>
<span class="gi">+    def validate(self, document: Document) -&gt; None:</span>
<span class="gi">+        validator = self.get_validator() or DummyValidator()</span>
<span class="gi">+        validator.validate(document)</span>
<span class="gi">+</span>
<span class="gi">+    async def validate_async(self, document: Document) -&gt; None:</span>
<span class="gi">+        validator = self.get_validator() or DummyValidator()</span>
<span class="gi">+        await validator.validate_async(document)</span>
<span class="gh">diff --git a/src/prompt_toolkit/widgets/base.py b/src/prompt_toolkit/widgets/base.py</span>
<span class="gh">index dbba3ba3..f36a5457 100644</span>
<span class="gd">--- a/src/prompt_toolkit/widgets/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/widgets/base.py</span>
<span class="gu">@@ -13,45 +13,99 @@ container object.</span>
<span class="w"> </span>    `prompt_toolkit.shortcuts.dialogs` on the other hand is considered stable.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import Callable, Generic, Sequence, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.auto_suggest import AutoSuggest, DynamicAutoSuggest
<span class="w"> </span>from prompt_toolkit.buffer import Buffer, BufferAcceptHandler
<span class="w"> </span>from prompt_toolkit.completion import Completer, DynamicCompleter
<span class="w"> </span>from prompt_toolkit.document import Document
<span class="gd">-from prompt_toolkit.filters import Condition, FilterOrBool, has_focus, is_done, is_true, to_filter</span>
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, Template, to_formatted_text</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    FilterOrBool,</span>
<span class="gi">+    has_focus,</span>
<span class="gi">+    is_done,</span>
<span class="gi">+    is_true,</span>
<span class="gi">+    to_filter,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    Template,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.formatted_text.utils import fragment_list_to_text
<span class="w"> </span>from prompt_toolkit.history import History
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import KeyBindings
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="gd">-from prompt_toolkit.layout.containers import AnyContainer, ConditionalContainer, Container, DynamicContainer, Float, FloatContainer, HSplit, VSplit, Window, WindowAlign</span>
<span class="gd">-from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl, GetLinePrefixCallable</span>
<span class="gi">+from prompt_toolkit.layout.containers import (</span>
<span class="gi">+    AnyContainer,</span>
<span class="gi">+    ConditionalContainer,</span>
<span class="gi">+    Container,</span>
<span class="gi">+    DynamicContainer,</span>
<span class="gi">+    Float,</span>
<span class="gi">+    FloatContainer,</span>
<span class="gi">+    HSplit,</span>
<span class="gi">+    VSplit,</span>
<span class="gi">+    Window,</span>
<span class="gi">+    WindowAlign,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.layout.controls import (</span>
<span class="gi">+    BufferControl,</span>
<span class="gi">+    FormattedTextControl,</span>
<span class="gi">+    GetLinePrefixCallable,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.dimension import AnyDimension, to_dimension
<span class="w"> </span>from prompt_toolkit.layout.dimension import Dimension as D
<span class="gd">-from prompt_toolkit.layout.margins import ConditionalMargin, NumberedMargin, ScrollbarMargin</span>
<span class="gd">-from prompt_toolkit.layout.processors import AppendAutoSuggestion, BeforeInput, ConditionalProcessor, PasswordProcessor, Processor</span>
<span class="gi">+from prompt_toolkit.layout.margins import (</span>
<span class="gi">+    ConditionalMargin,</span>
<span class="gi">+    NumberedMargin,</span>
<span class="gi">+    ScrollbarMargin,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.layout.processors import (</span>
<span class="gi">+    AppendAutoSuggestion,</span>
<span class="gi">+    BeforeInput,</span>
<span class="gi">+    ConditionalProcessor,</span>
<span class="gi">+    PasswordProcessor,</span>
<span class="gi">+    Processor,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.lexers import DynamicLexer, Lexer
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent, MouseEventType
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="w"> </span>from prompt_toolkit.validation import DynamicValidator, Validator
<span class="gi">+</span>
<span class="w"> </span>from .toolbars import SearchToolbar
<span class="gd">-__all__ = [&#39;TextArea&#39;, &#39;Label&#39;, &#39;Button&#39;, &#39;Frame&#39;, &#39;Shadow&#39;, &#39;Box&#39;,</span>
<span class="gd">-    &#39;VerticalLine&#39;, &#39;HorizontalLine&#39;, &#39;RadioList&#39;, &#39;CheckboxList&#39;,</span>
<span class="gd">-    &#39;Checkbox&#39;, &#39;ProgressBar&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;TextArea&quot;,</span>
<span class="gi">+    &quot;Label&quot;,</span>
<span class="gi">+    &quot;Button&quot;,</span>
<span class="gi">+    &quot;Frame&quot;,</span>
<span class="gi">+    &quot;Shadow&quot;,</span>
<span class="gi">+    &quot;Box&quot;,</span>
<span class="gi">+    &quot;VerticalLine&quot;,</span>
<span class="gi">+    &quot;HorizontalLine&quot;,</span>
<span class="gi">+    &quot;RadioList&quot;,</span>
<span class="gi">+    &quot;CheckboxList&quot;,</span>
<span class="gi">+    &quot;Checkbox&quot;,  # backward compatibility</span>
<span class="gi">+    &quot;ProgressBar&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="w"> </span>class Border:
<span class="gd">-    &quot;&quot;&quot;Box drawing characters. (Thin)&quot;&quot;&quot;</span>
<span class="gd">-    HORIZONTAL = &#39;─&#39;</span>
<span class="gd">-    VERTICAL = &#39;│&#39;</span>
<span class="gd">-    TOP_LEFT = &#39;┌&#39;</span>
<span class="gd">-    TOP_RIGHT = &#39;┐&#39;</span>
<span class="gd">-    BOTTOM_LEFT = &#39;└&#39;</span>
<span class="gd">-    BOTTOM_RIGHT = &#39;┘&#39;</span>
<span class="gi">+    &quot;Box drawing characters. (Thin)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    HORIZONTAL = &quot;\u2500&quot;</span>
<span class="gi">+    VERTICAL = &quot;\u2502&quot;</span>
<span class="gi">+    TOP_LEFT = &quot;\u250c&quot;</span>
<span class="gi">+    TOP_RIGHT = &quot;\u2510&quot;</span>
<span class="gi">+    BOTTOM_LEFT = &quot;\u2514&quot;</span>
<span class="gi">+    BOTTOM_RIGHT = &quot;\u2518&quot;</span>


<span class="w"> </span>class TextArea:
<span class="gu">@@ -115,27 +169,45 @@ class TextArea:</span>
<span class="w"> </span>    :param search_field: An optional `SearchToolbar` object.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str=&#39;&#39;, multiline: FilterOrBool=True, password:</span>
<span class="gd">-        FilterOrBool=False, lexer: (Lexer | None)=None, auto_suggest: (</span>
<span class="gd">-        AutoSuggest | None)=None, completer: (Completer | None)=None,</span>
<span class="gd">-        complete_while_typing: FilterOrBool=True, validator: (Validator |</span>
<span class="gd">-        None)=None, accept_handler: (BufferAcceptHandler | None)=None,</span>
<span class="gd">-        history: (History | None)=None, focusable: FilterOrBool=True,</span>
<span class="gd">-        focus_on_click: FilterOrBool=False, wrap_lines: FilterOrBool=True,</span>
<span class="gd">-        read_only: FilterOrBool=False, width: AnyDimension=None, height:</span>
<span class="gd">-        AnyDimension=None, dont_extend_height: FilterOrBool=False,</span>
<span class="gd">-        dont_extend_width: FilterOrBool=False, line_numbers: bool=False,</span>
<span class="gd">-        get_line_prefix: (GetLinePrefixCallable | None)=None, scrollbar:</span>
<span class="gd">-        bool=False, style: str=&#39;&#39;, search_field: (SearchToolbar | None)=</span>
<span class="gd">-        None, preview_search: FilterOrBool=True, prompt: AnyFormattedText=</span>
<span class="gd">-        &#39;&#39;, input_processors: (list[Processor] | None)=None, name: str=&#39;&#39;</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: str = &quot;&quot;,</span>
<span class="gi">+        multiline: FilterOrBool = True,</span>
<span class="gi">+        password: FilterOrBool = False,</span>
<span class="gi">+        lexer: Lexer | None = None,</span>
<span class="gi">+        auto_suggest: AutoSuggest | None = None,</span>
<span class="gi">+        completer: Completer | None = None,</span>
<span class="gi">+        complete_while_typing: FilterOrBool = True,</span>
<span class="gi">+        validator: Validator | None = None,</span>
<span class="gi">+        accept_handler: BufferAcceptHandler | None = None,</span>
<span class="gi">+        history: History | None = None,</span>
<span class="gi">+        focusable: FilterOrBool = True,</span>
<span class="gi">+        focus_on_click: FilterOrBool = False,</span>
<span class="gi">+        wrap_lines: FilterOrBool = True,</span>
<span class="gi">+        read_only: FilterOrBool = False,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        dont_extend_height: FilterOrBool = False,</span>
<span class="gi">+        dont_extend_width: FilterOrBool = False,</span>
<span class="gi">+        line_numbers: bool = False,</span>
<span class="gi">+        get_line_prefix: GetLinePrefixCallable | None = None,</span>
<span class="gi">+        scrollbar: bool = False,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+        search_field: SearchToolbar | None = None,</span>
<span class="gi">+        preview_search: FilterOrBool = True,</span>
<span class="gi">+        prompt: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        input_processors: list[Processor] | None = None,</span>
<span class="gi">+        name: str = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if search_field is None:
<span class="w"> </span>            search_control = None
<span class="w"> </span>        elif isinstance(search_field, SearchToolbar):
<span class="w"> </span>            search_control = search_field.control
<span class="gi">+</span>
<span class="w"> </span>        if input_processors is None:
<span class="w"> </span>            input_processors = []
<span class="gi">+</span>
<span class="gi">+        # Writeable attributes.</span>
<span class="w"> </span>        self.completer = completer
<span class="w"> </span>        self.complete_while_typing = complete_while_typing
<span class="w"> </span>        self.lexer = lexer
<span class="gu">@@ -143,22 +215,41 @@ class TextArea:</span>
<span class="w"> </span>        self.read_only = read_only
<span class="w"> </span>        self.wrap_lines = wrap_lines
<span class="w"> </span>        self.validator = validator
<span class="gd">-        self.buffer = Buffer(document=Document(text, 0), multiline=</span>
<span class="gd">-            multiline, read_only=Condition(lambda : is_true(self.read_only)</span>
<span class="gd">-            ), completer=DynamicCompleter(lambda : self.completer),</span>
<span class="gd">-            complete_while_typing=Condition(lambda : is_true(self.</span>
<span class="gd">-            complete_while_typing)), validator=DynamicValidator(lambda :</span>
<span class="gd">-            self.validator), auto_suggest=DynamicAutoSuggest(lambda : self.</span>
<span class="gd">-            auto_suggest), accept_handler=accept_handler, history=history,</span>
<span class="gd">-            name=name)</span>
<span class="gd">-        self.control = BufferControl(buffer=self.buffer, lexer=DynamicLexer</span>
<span class="gd">-            (lambda : self.lexer), input_processors=[ConditionalProcessor(</span>
<span class="gd">-            AppendAutoSuggestion(), has_focus(self.buffer) &amp; ~is_done),</span>
<span class="gd">-            ConditionalProcessor(processor=PasswordProcessor(), filter=</span>
<span class="gd">-            to_filter(password)), BeforeInput(prompt, style=</span>
<span class="gd">-            &#39;class:text-area.prompt&#39;)] + input_processors,</span>
<span class="gd">-            search_buffer_control=search_control, preview_search=</span>
<span class="gd">-            preview_search, focusable=focusable, focus_on_click=focus_on_click)</span>
<span class="gi">+</span>
<span class="gi">+        self.buffer = Buffer(</span>
<span class="gi">+            document=Document(text, 0),</span>
<span class="gi">+            multiline=multiline,</span>
<span class="gi">+            read_only=Condition(lambda: is_true(self.read_only)),</span>
<span class="gi">+            completer=DynamicCompleter(lambda: self.completer),</span>
<span class="gi">+            complete_while_typing=Condition(</span>
<span class="gi">+                lambda: is_true(self.complete_while_typing)</span>
<span class="gi">+            ),</span>
<span class="gi">+            validator=DynamicValidator(lambda: self.validator),</span>
<span class="gi">+            auto_suggest=DynamicAutoSuggest(lambda: self.auto_suggest),</span>
<span class="gi">+            accept_handler=accept_handler,</span>
<span class="gi">+            history=history,</span>
<span class="gi">+            name=name,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.control = BufferControl(</span>
<span class="gi">+            buffer=self.buffer,</span>
<span class="gi">+            lexer=DynamicLexer(lambda: self.lexer),</span>
<span class="gi">+            input_processors=[</span>
<span class="gi">+                ConditionalProcessor(</span>
<span class="gi">+                    AppendAutoSuggestion(), has_focus(self.buffer) &amp; ~is_done</span>
<span class="gi">+                ),</span>
<span class="gi">+                ConditionalProcessor(</span>
<span class="gi">+                    processor=PasswordProcessor(), filter=to_filter(password)</span>
<span class="gi">+                ),</span>
<span class="gi">+                BeforeInput(prompt, style=&quot;class:text-area.prompt&quot;),</span>
<span class="gi">+            ]</span>
<span class="gi">+            + input_processors,</span>
<span class="gi">+            search_buffer_control=search_control,</span>
<span class="gi">+            preview_search=preview_search,</span>
<span class="gi">+            focusable=focusable,</span>
<span class="gi">+            focus_on_click=focus_on_click,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if multiline:
<span class="w"> </span>            if scrollbar:
<span class="w"> </span>                right_margins = [ScrollbarMargin(display_arrows=True)]
<span class="gu">@@ -172,37 +263,60 @@ class TextArea:</span>
<span class="w"> </span>            height = D.exact(1)
<span class="w"> </span>            left_margins = []
<span class="w"> </span>            right_margins = []
<span class="gd">-        style = &#39;class:text-area &#39; + style</span>
<span class="gi">+</span>
<span class="gi">+        style = &quot;class:text-area &quot; + style</span>
<span class="gi">+</span>
<span class="gi">+        # If no height was given, guarantee height of at least 1.</span>
<span class="w"> </span>        if height is None:
<span class="w"> </span>            height = D(min=1)
<span class="gd">-        self.window = Window(height=height, width=width, dont_extend_height</span>
<span class="gd">-            =dont_extend_height, dont_extend_width=dont_extend_width,</span>
<span class="gd">-            content=self.control, style=style, wrap_lines=Condition(lambda :</span>
<span class="gd">-            is_true(self.wrap_lines)), left_margins=left_margins,</span>
<span class="gd">-            right_margins=right_margins, get_line_prefix=get_line_prefix)</span>
<span class="gi">+</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            height=height,</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            dont_extend_height=dont_extend_height,</span>
<span class="gi">+            dont_extend_width=dont_extend_width,</span>
<span class="gi">+            content=self.control,</span>
<span class="gi">+            style=style,</span>
<span class="gi">+            wrap_lines=Condition(lambda: is_true(self.wrap_lines)),</span>
<span class="gi">+            left_margins=left_margins,</span>
<span class="gi">+            right_margins=right_margins,</span>
<span class="gi">+            get_line_prefix=get_line_prefix,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="gd">-    def text(self) -&gt;str:</span>
<span class="gi">+    def text(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The `Buffer` text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffer.text</span>
<span class="gi">+</span>
<span class="gi">+    @text.setter</span>
<span class="gi">+    def text(self, value: str) -&gt; None:</span>
<span class="gi">+        self.document = Document(value, 0)</span>

<span class="w"> </span>    @property
<span class="gd">-    def document(self) -&gt;Document:</span>
<span class="gi">+    def document(self) -&gt; Document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The `Buffer` document (text + cursor position).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffer.document</span>
<span class="gi">+</span>
<span class="gi">+    @document.setter</span>
<span class="gi">+    def document(self, value: Document) -&gt; None:</span>
<span class="gi">+        self.buffer.set_document(value, bypass_readonly=True)</span>

<span class="w"> </span>    @property
<span class="gd">-    def accept_handler(self) -&gt;(BufferAcceptHandler | None):</span>
<span class="gi">+    def accept_handler(self) -&gt; BufferAcceptHandler | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The accept handler. Called when the user accepts the input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffer.accept_handler</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    @accept_handler.setter</span>
<span class="gi">+    def accept_handler(self, value: BufferAcceptHandler) -&gt; None:</span>
<span class="gi">+        self.buffer.accept_handler = value</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.window


<span class="gu">@@ -225,32 +339,46 @@ class Label:</span>
<span class="w"> </span>                               the text. `False` by default.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: AnyFormattedText, style: str=&#39;&#39;, width:</span>
<span class="gd">-        AnyDimension=None, dont_extend_height: bool=True, dont_extend_width:</span>
<span class="gd">-        bool=False, align: (WindowAlign | Callable[[], WindowAlign])=</span>
<span class="gd">-        WindowAlign.LEFT, wrap_lines: FilterOrBool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: AnyFormattedText,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        dont_extend_height: bool = True,</span>
<span class="gi">+        dont_extend_width: bool = False,</span>
<span class="gi">+        align: WindowAlign | Callable[[], WindowAlign] = WindowAlign.LEFT,</span>
<span class="gi">+        # There is no cursor navigation in a label, so it makes sense to always</span>
<span class="gi">+        # wrap lines by default.</span>
<span class="gi">+        wrap_lines: FilterOrBool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.text = text

<span class="gd">-        def get_width() -&gt;AnyDimension:</span>
<span class="gi">+        def get_width() -&gt; AnyDimension:</span>
<span class="w"> </span>            if width is None:
<span class="w"> </span>                text_fragments = to_formatted_text(self.text)
<span class="w"> </span>                text = fragment_list_to_text(text_fragments)
<span class="w"> </span>                if text:
<span class="gd">-                    longest_line = max(get_cwidth(line) for line in text.</span>
<span class="gd">-                        splitlines())</span>
<span class="gi">+                    longest_line = max(get_cwidth(line) for line in text.splitlines())</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    return D(preferred=0)
<span class="w"> </span>                return D(preferred=longest_line)
<span class="w"> </span>            else:
<span class="w"> </span>                return width
<span class="gd">-        self.formatted_text_control = FormattedTextControl(text=lambda :</span>
<span class="gd">-            self.text)</span>
<span class="gd">-        self.window = Window(content=self.formatted_text_control, width=</span>
<span class="gd">-            get_width, height=D(min=1), style=&#39;class:label &#39; + style,</span>
<span class="gd">-            dont_extend_height=dont_extend_height, dont_extend_width=</span>
<span class="gd">-            dont_extend_width, align=align, wrap_lines=wrap_lines)</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        self.formatted_text_control = FormattedTextControl(text=lambda: self.text)</span>
<span class="gi">+</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            content=self.formatted_text_control,</span>
<span class="gi">+            width=get_width,</span>
<span class="gi">+            height=D(min=1),</span>
<span class="gi">+            style=&quot;class:label &quot; + style,</span>
<span class="gi">+            dont_extend_height=dont_extend_height,</span>
<span class="gi">+            dont_extend_width=dont_extend_width,</span>
<span class="gi">+            align=align,</span>
<span class="gi">+            wrap_lines=wrap_lines,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.window


<span class="gu">@@ -265,30 +393,80 @@ class Button:</span>
<span class="w"> </span>    :param width: Width of the button.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str, handler: (Callable[[], None] | None)=None,</span>
<span class="gd">-        width: int=12, left_symbol: str=&#39;&lt;&#39;, right_symbol: str=&#39;&gt;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: str,</span>
<span class="gi">+        handler: Callable[[], None] | None = None,</span>
<span class="gi">+        width: int = 12,</span>
<span class="gi">+        left_symbol: str = &quot;&lt;&quot;,</span>
<span class="gi">+        right_symbol: str = &quot;&gt;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.left_symbol = left_symbol
<span class="w"> </span>        self.right_symbol = right_symbol
<span class="w"> </span>        self.handler = handler
<span class="w"> </span>        self.width = width
<span class="gd">-        self.control = FormattedTextControl(self._get_text_fragments,</span>
<span class="gd">-            key_bindings=self._get_key_bindings(), focusable=True)</span>
<span class="gi">+        self.control = FormattedTextControl(</span>
<span class="gi">+            self._get_text_fragments,</span>
<span class="gi">+            key_bindings=self._get_key_bindings(),</span>
<span class="gi">+            focusable=True,</span>
<span class="gi">+        )</span>

<span class="gd">-        def get_style() -&gt;str:</span>
<span class="gi">+        def get_style() -&gt; str:</span>
<span class="w"> </span>            if get_app().layout.has_focus(self):
<span class="gd">-                return &#39;class:button.focused&#39;</span>
<span class="gi">+                return &quot;class:button.focused&quot;</span>
<span class="w"> </span>            else:
<span class="gd">-                return &#39;class:button&#39;</span>
<span class="gd">-        self.window = Window(self.control, align=WindowAlign.CENTER, height</span>
<span class="gd">-            =1, width=width, style=get_style, dont_extend_width=False,</span>
<span class="gd">-            dont_extend_height=True)</span>
<span class="gi">+                return &quot;class:button&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Note: `dont_extend_width` is False, because we want to allow buttons</span>
<span class="gi">+        #       to take more space if the parent container provides more space.</span>
<span class="gi">+        #       Otherwise, we will also truncate the text.</span>
<span class="gi">+        #       Probably we need a better way here to adjust to width of the</span>
<span class="gi">+        #       button to the text.</span>
<span class="gi">+</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            self.control,</span>
<span class="gi">+            align=WindowAlign.CENTER,</span>
<span class="gi">+            height=1,</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            style=get_style,</span>
<span class="gi">+            dont_extend_width=False,</span>
<span class="gi">+            dont_extend_height=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_text_fragments(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        width = self.width - (</span>
<span class="gi">+            get_cwidth(self.left_symbol) + get_cwidth(self.right_symbol)</span>
<span class="gi">+        )</span>
<span class="gi">+        text = (f&quot;{{:^{width}}}&quot;).format(self.text)</span>
<span class="gi">+</span>
<span class="gi">+        def handler(mouse_event: MouseEvent) -&gt; None:</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.handler is not None</span>
<span class="gi">+                and mouse_event.event_type == MouseEventType.MOUSE_UP</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.handler()</span>
<span class="gi">+</span>
<span class="gi">+        return [</span>
<span class="gi">+            (&quot;class:button.arrow&quot;, self.left_symbol, handler),</span>
<span class="gi">+            (&quot;[SetCursorPosition]&quot;, &quot;&quot;),</span>
<span class="gi">+            (&quot;class:button.text&quot;, text, handler),</span>
<span class="gi">+            (&quot;class:button.arrow&quot;, self.right_symbol, handler),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_key_bindings(self) -&gt; KeyBindings:</span>
<span class="gi">+        &quot;Key bindings for the Button.&quot;</span>
<span class="gi">+        kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot; &quot;)</span>
<span class="gi">+        @kb.add(&quot;enter&quot;)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            if self.handler is not None:</span>
<span class="gi">+                self.handler()</span>

<span class="gd">-    def _get_key_bindings(self) -&gt;KeyBindings:</span>
<span class="gd">-        &quot;&quot;&quot;Key bindings for the Button.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return kb</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.window


<span class="gu">@@ -304,37 +482,86 @@ class Frame:</span>
<span class="w"> </span>    :param style: Style string to be applied to this widget.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, body: AnyContainer, title: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-        style: str=&#39;&#39;, width: AnyDimension=None, height: AnyDimension=None,</span>
<span class="gd">-        key_bindings: (KeyBindings | None)=None, modal: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        body: AnyContainer,</span>
<span class="gi">+        title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        key_bindings: KeyBindings | None = None,</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.title = title
<span class="w"> </span>        self.body = body
<span class="gd">-        fill = partial(Window, style=&#39;class:frame.border&#39;)</span>
<span class="gd">-        style = &#39;class:frame &#39; + style</span>
<span class="gd">-        top_row_with_title = VSplit([fill(width=1, height=1, char=Border.</span>
<span class="gd">-            TOP_LEFT), fill(char=Border.HORIZONTAL), fill(width=1, height=1,</span>
<span class="gd">-            char=&#39;|&#39;), Label(lambda : Template(&#39; {} &#39;).format(self.title),</span>
<span class="gd">-            style=&#39;class:frame.label&#39;, dont_extend_width=True), fill(width=</span>
<span class="gd">-            1, height=1, char=&#39;|&#39;), fill(char=Border.HORIZONTAL), fill(</span>
<span class="gd">-            width=1, height=1, char=Border.TOP_RIGHT)], height=1)</span>
<span class="gd">-        top_row_without_title = VSplit([fill(width=1, height=1, char=Border</span>
<span class="gd">-            .TOP_LEFT), fill(char=Border.HORIZONTAL), fill(width=1, height=</span>
<span class="gd">-            1, char=Border.TOP_RIGHT)], height=1)</span>
<span class="gi">+</span>
<span class="gi">+        fill = partial(Window, style=&quot;class:frame.border&quot;)</span>
<span class="gi">+        style = &quot;class:frame &quot; + style</span>
<span class="gi">+</span>
<span class="gi">+        top_row_with_title = VSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                fill(width=1, height=1, char=Border.TOP_LEFT),</span>
<span class="gi">+                fill(char=Border.HORIZONTAL),</span>
<span class="gi">+                fill(width=1, height=1, char=&quot;|&quot;),</span>
<span class="gi">+                # Notice: we use `Template` here, because `self.title` can be an</span>
<span class="gi">+                # `HTML` object for instance.</span>
<span class="gi">+                Label(</span>
<span class="gi">+                    lambda: Template(&quot; {} &quot;).format(self.title),</span>
<span class="gi">+                    style=&quot;class:frame.label&quot;,</span>
<span class="gi">+                    dont_extend_width=True,</span>
<span class="gi">+                ),</span>
<span class="gi">+                fill(width=1, height=1, char=&quot;|&quot;),</span>
<span class="gi">+                fill(char=Border.HORIZONTAL),</span>
<span class="gi">+                fill(width=1, height=1, char=Border.TOP_RIGHT),</span>
<span class="gi">+            ],</span>
<span class="gi">+            height=1,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        top_row_without_title = VSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                fill(width=1, height=1, char=Border.TOP_LEFT),</span>
<span class="gi">+                fill(char=Border.HORIZONTAL),</span>
<span class="gi">+                fill(width=1, height=1, char=Border.TOP_RIGHT),</span>
<span class="gi">+            ],</span>
<span class="gi">+            height=1,</span>
<span class="gi">+        )</span>

<span class="w"> </span>        @Condition
<span class="gd">-        def has_title() -&gt;bool:</span>
<span class="gi">+        def has_title() -&gt; bool:</span>
<span class="w"> </span>            return bool(self.title)
<span class="gd">-        self.container = HSplit([ConditionalContainer(content=</span>
<span class="gd">-            top_row_with_title, filter=has_title), ConditionalContainer(</span>
<span class="gd">-            content=top_row_without_title, filter=~has_title), VSplit([fill</span>
<span class="gd">-            (width=1, char=Border.VERTICAL), DynamicContainer(lambda : self</span>
<span class="gd">-            .body), fill(width=1, char=Border.VERTICAL)], padding=0),</span>
<span class="gd">-            VSplit([fill(width=1, height=1, char=Border.BOTTOM_LEFT), fill(</span>
<span class="gd">-            char=Border.HORIZONTAL), fill(width=1, height=1, char=Border.</span>
<span class="gd">-            BOTTOM_RIGHT)], height=1)], width=width, height=height, style=</span>
<span class="gd">-            style, key_bindings=key_bindings, modal=modal)</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        self.container = HSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                ConditionalContainer(content=top_row_with_title, filter=has_title),</span>
<span class="gi">+                ConditionalContainer(content=top_row_without_title, filter=~has_title),</span>
<span class="gi">+                VSplit(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        fill(width=1, char=Border.VERTICAL),</span>
<span class="gi">+                        DynamicContainer(lambda: self.body),</span>
<span class="gi">+                        fill(width=1, char=Border.VERTICAL),</span>
<span class="gi">+                        # Padding is required to make sure that if the content is</span>
<span class="gi">+                        # too small, the right frame border is still aligned.</span>
<span class="gi">+                    ],</span>
<span class="gi">+                    padding=0,</span>
<span class="gi">+                ),</span>
<span class="gi">+                VSplit(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        fill(width=1, height=1, char=Border.BOTTOM_LEFT),</span>
<span class="gi">+                        fill(char=Border.HORIZONTAL),</span>
<span class="gi">+                        fill(width=1, height=1, char=Border.BOTTOM_RIGHT),</span>
<span class="gi">+                    ],</span>
<span class="gi">+                    # specifying height here will increase the rendering speed.</span>
<span class="gi">+                    height=1,</span>
<span class="gi">+                ),</span>
<span class="gi">+            ],</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            height=height,</span>
<span class="gi">+            style=style,</span>
<span class="gi">+            key_bindings=key_bindings,</span>
<span class="gi">+            modal=modal,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="gu">@@ -347,13 +574,30 @@ class Shadow:</span>
<span class="w"> </span>    :param body: Another container object.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, body: AnyContainer) -&gt;None:</span>
<span class="gd">-        self.container = FloatContainer(content=body, floats=[Float(bottom=</span>
<span class="gd">-            -1, height=1, left=1, right=-1, transparent=True, content=</span>
<span class="gd">-            Window(style=&#39;class:shadow&#39;)), Float(bottom=-1, top=1, width=1,</span>
<span class="gd">-            right=-1, transparent=True, content=Window(style=&#39;class:shadow&#39;))])</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    def __init__(self, body: AnyContainer) -&gt; None:</span>
<span class="gi">+        self.container = FloatContainer(</span>
<span class="gi">+            content=body,</span>
<span class="gi">+            floats=[</span>
<span class="gi">+                Float(</span>
<span class="gi">+                    bottom=-1,</span>
<span class="gi">+                    height=1,</span>
<span class="gi">+                    left=1,</span>
<span class="gi">+                    right=-1,</span>
<span class="gi">+                    transparent=True,</span>
<span class="gi">+                    content=Window(style=&quot;class:shadow&quot;),</span>
<span class="gi">+                ),</span>
<span class="gi">+                Float(</span>
<span class="gi">+                    bottom=-1,</span>
<span class="gi">+                    top=1,</span>
<span class="gi">+                    width=1,</span>
<span class="gi">+                    right=-1,</span>
<span class="gi">+                    transparent=True,</span>
<span class="gi">+                    content=Window(style=&quot;class:shadow&quot;),</span>
<span class="gi">+                ),</span>
<span class="gi">+            ],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="gu">@@ -376,111 +620,220 @@ class Box:</span>
<span class="w"> </span>        (This is supposed to be a character with a terminal width of 1.)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, body: AnyContainer, padding: AnyDimension=None,</span>
<span class="gd">-        padding_left: AnyDimension=None, padding_right: AnyDimension=None,</span>
<span class="gd">-        padding_top: AnyDimension=None, padding_bottom: AnyDimension=None,</span>
<span class="gd">-        width: AnyDimension=None, height: AnyDimension=None, style: str=&#39;&#39;,</span>
<span class="gd">-        char: (None | str | Callable[[], str])=None, modal: bool=False,</span>
<span class="gd">-        key_bindings: (KeyBindings | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        body: AnyContainer,</span>
<span class="gi">+        padding: AnyDimension = None,</span>
<span class="gi">+        padding_left: AnyDimension = None,</span>
<span class="gi">+        padding_right: AnyDimension = None,</span>
<span class="gi">+        padding_top: AnyDimension = None,</span>
<span class="gi">+        padding_bottom: AnyDimension = None,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        height: AnyDimension = None,</span>
<span class="gi">+        style: str = &quot;&quot;,</span>
<span class="gi">+        char: None | str | Callable[[], str] = None,</span>
<span class="gi">+        modal: bool = False,</span>
<span class="gi">+        key_bindings: KeyBindings | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if padding is None:
<span class="w"> </span>            padding = D(preferred=0)

<span class="gd">-        def get(value: AnyDimension) -&gt;D:</span>
<span class="gi">+        def get(value: AnyDimension) -&gt; D:</span>
<span class="w"> </span>            if value is None:
<span class="w"> </span>                value = padding
<span class="w"> </span>            return to_dimension(value)
<span class="gi">+</span>
<span class="w"> </span>        self.padding_left = get(padding_left)
<span class="w"> </span>        self.padding_right = get(padding_right)
<span class="w"> </span>        self.padding_top = get(padding_top)
<span class="w"> </span>        self.padding_bottom = get(padding_bottom)
<span class="w"> </span>        self.body = body
<span class="gd">-        self.container = HSplit([Window(height=self.padding_top, char=char),</span>
<span class="gd">-            VSplit([Window(width=self.padding_left, char=char), body,</span>
<span class="gd">-            Window(width=self.padding_right, char=char)]), Window(height=</span>
<span class="gd">-            self.padding_bottom, char=char)], width=width, height=height,</span>
<span class="gd">-            style=style, modal=modal, key_bindings=None)</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+        self.container = HSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                Window(height=self.padding_top, char=char),</span>
<span class="gi">+                VSplit(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        Window(width=self.padding_left, char=char),</span>
<span class="gi">+                        body,</span>
<span class="gi">+                        Window(width=self.padding_right, char=char),</span>
<span class="gi">+                    ]</span>
<span class="gi">+                ),</span>
<span class="gi">+                Window(height=self.padding_bottom, char=char),</span>
<span class="gi">+            ],</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            height=height,</span>
<span class="gi">+            style=style,</span>
<span class="gi">+            modal=modal,</span>
<span class="gi">+            key_bindings=None,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class _DialogList(Generic[_T]):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Common code for `RadioList` and `CheckboxList`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    open_character: str = &#39;&#39;</span>
<span class="gd">-    close_character: str = &#39;&#39;</span>
<span class="gd">-    container_style: str = &#39;&#39;</span>
<span class="gd">-    default_style: str = &#39;&#39;</span>
<span class="gd">-    selected_style: str = &#39;&#39;</span>
<span class="gd">-    checked_style: str = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    open_character: str = &quot;&quot;</span>
<span class="gi">+    close_character: str = &quot;&quot;</span>
<span class="gi">+    container_style: str = &quot;&quot;</span>
<span class="gi">+    default_style: str = &quot;&quot;</span>
<span class="gi">+    selected_style: str = &quot;&quot;</span>
<span class="gi">+    checked_style: str = &quot;&quot;</span>
<span class="w"> </span>    multiple_selection: bool = False
<span class="w"> </span>    show_scrollbar: bool = True

<span class="gd">-    def __init__(self, values: Sequence[tuple[_T, AnyFormattedText]],</span>
<span class="gd">-        default_values: (Sequence[_T] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        values: Sequence[tuple[_T, AnyFormattedText]],</span>
<span class="gi">+        default_values: Sequence[_T] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert len(values) &gt; 0
<span class="w"> </span>        default_values = default_values or []
<span class="gi">+</span>
<span class="w"> </span>        self.values = values
<span class="gd">-        keys: list[_T] = [value for value, _ in values]</span>
<span class="gd">-        self.current_values: list[_T] = [value for value in default_values if</span>
<span class="gd">-            value in keys]</span>
<span class="gd">-        self.current_value: _T = default_values[0] if len(default_values</span>
<span class="gd">-            ) and default_values[0] in keys else values[0][0]</span>
<span class="gi">+        # current_values will be used in multiple_selection,</span>
<span class="gi">+        # current_value will be used otherwise.</span>
<span class="gi">+        keys: list[_T] = [value for (value, _) in values]</span>
<span class="gi">+        self.current_values: list[_T] = [</span>
<span class="gi">+            value for value in default_values if value in keys</span>
<span class="gi">+        ]</span>
<span class="gi">+        self.current_value: _T = (</span>
<span class="gi">+            default_values[0]</span>
<span class="gi">+            if len(default_values) and default_values[0] in keys</span>
<span class="gi">+            else values[0][0]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Cursor index: take first selected item or first item otherwise.</span>
<span class="w"> </span>        if len(self.current_values) &gt; 0:
<span class="w"> </span>            self._selected_index = keys.index(self.current_values[0])
<span class="w"> </span>        else:
<span class="w"> </span>            self._selected_index = 0
<span class="gi">+</span>
<span class="gi">+        # Key bindings.</span>
<span class="w"> </span>        kb = KeyBindings()

<span class="gd">-        @kb.add(&#39;up&#39;)</span>
<span class="gd">-        def _up(event: E) -&gt;None:</span>
<span class="gi">+        @kb.add(&quot;up&quot;)</span>
<span class="gi">+        def _up(event: E) -&gt; None:</span>
<span class="w"> </span>            self._selected_index = max(0, self._selected_index - 1)

<span class="gd">-        @kb.add(&#39;down&#39;)</span>
<span class="gd">-        def _down(event: E) -&gt;None:</span>
<span class="gd">-            self._selected_index = min(len(self.values) - 1, self.</span>
<span class="gd">-                _selected_index + 1)</span>
<span class="gi">+        @kb.add(&quot;down&quot;)</span>
<span class="gi">+        def _down(event: E) -&gt; None:</span>
<span class="gi">+            self._selected_index = min(len(self.values) - 1, self._selected_index + 1)</span>

<span class="gd">-        @kb.add(&#39;pageup&#39;)</span>
<span class="gd">-        def _pageup(event: E) -&gt;None:</span>
<span class="gi">+        @kb.add(&quot;pageup&quot;)</span>
<span class="gi">+        def _pageup(event: E) -&gt; None:</span>
<span class="w"> </span>            w = event.app.layout.current_window
<span class="w"> </span>            if w.render_info:
<span class="gd">-                self._selected_index = max(0, self._selected_index - len(w.</span>
<span class="gd">-                    render_info.displayed_lines))</span>
<span class="gi">+                self._selected_index = max(</span>
<span class="gi">+                    0, self._selected_index - len(w.render_info.displayed_lines)</span>
<span class="gi">+                )</span>

<span class="gd">-        @kb.add(&#39;pagedown&#39;)</span>
<span class="gd">-        def _pagedown(event: E) -&gt;None:</span>
<span class="gi">+        @kb.add(&quot;pagedown&quot;)</span>
<span class="gi">+        def _pagedown(event: E) -&gt; None:</span>
<span class="w"> </span>            w = event.app.layout.current_window
<span class="w"> </span>            if w.render_info:
<span class="gd">-                self._selected_index = min(len(self.values) - 1, self.</span>
<span class="gd">-                    _selected_index + len(w.render_info.displayed_lines))</span>
<span class="gd">-</span>
<span class="gd">-        @kb.add(&#39;enter&#39;)</span>
<span class="gd">-        @kb.add(&#39; &#39;)</span>
<span class="gd">-        def _click(event: E) -&gt;None:</span>
<span class="gi">+                self._selected_index = min(</span>
<span class="gi">+                    len(self.values) - 1,</span>
<span class="gi">+                    self._selected_index + len(w.render_info.displayed_lines),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot;enter&quot;)</span>
<span class="gi">+        @kb.add(&quot; &quot;)</span>
<span class="gi">+        def _click(event: E) -&gt; None:</span>
<span class="w"> </span>            self._handle_enter()

<span class="w"> </span>        @kb.add(Keys.Any)
<span class="gd">-        def _find(event: E) -&gt;None:</span>
<span class="gi">+        def _find(event: E) -&gt; None:</span>
<span class="gi">+            # We first check values after the selected value, then all values.</span>
<span class="w"> </span>            values = list(self.values)
<span class="gd">-            for value in (values[self._selected_index + 1:] + values):</span>
<span class="gd">-                text = fragment_list_to_text(to_formatted_text(value[1])</span>
<span class="gd">-                    ).lower()</span>
<span class="gi">+            for value in values[self._selected_index + 1 :] + values:</span>
<span class="gi">+                text = fragment_list_to_text(to_formatted_text(value[1])).lower()</span>
<span class="gi">+</span>
<span class="w"> </span>                if text.startswith(event.data.lower()):
<span class="w"> </span>                    self._selected_index = self.values.index(value)
<span class="w"> </span>                    return
<span class="gd">-        self.control = FormattedTextControl(self._get_text_fragments,</span>
<span class="gd">-            key_bindings=kb, focusable=True)</span>
<span class="gd">-        self.window = Window(content=self.control, style=self.</span>
<span class="gd">-            container_style, right_margins=[ConditionalMargin(margin=</span>
<span class="gd">-            ScrollbarMargin(display_arrows=True), filter=Condition(lambda :</span>
<span class="gd">-            self.show_scrollbar))], dont_extend_height=True)</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        # Control and window.</span>
<span class="gi">+        self.control = FormattedTextControl(</span>
<span class="gi">+            self._get_text_fragments, key_bindings=kb, focusable=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            content=self.control,</span>
<span class="gi">+            style=self.container_style,</span>
<span class="gi">+            right_margins=[</span>
<span class="gi">+                ConditionalMargin(</span>
<span class="gi">+                    margin=ScrollbarMargin(display_arrows=True),</span>
<span class="gi">+                    filter=Condition(lambda: self.show_scrollbar),</span>
<span class="gi">+                ),</span>
<span class="gi">+            ],</span>
<span class="gi">+            dont_extend_height=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_enter(self) -&gt; None:</span>
<span class="gi">+        if self.multiple_selection:</span>
<span class="gi">+            val = self.values[self._selected_index][0]</span>
<span class="gi">+            if val in self.current_values:</span>
<span class="gi">+                self.current_values.remove(val)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.current_values.append(val)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.current_value = self.values[self._selected_index][0]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_text_fragments(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        def mouse_handler(mouse_event: MouseEvent) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Set `_selected_index` and `current_value` according to the y</span>
<span class="gi">+            position of the mouse click event.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if mouse_event.event_type == MouseEventType.MOUSE_UP:</span>
<span class="gi">+                self._selected_index = mouse_event.position.y</span>
<span class="gi">+                self._handle_enter()</span>
<span class="gi">+</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+        for i, value in enumerate(self.values):</span>
<span class="gi">+            if self.multiple_selection:</span>
<span class="gi">+                checked = value[0] in self.current_values</span>
<span class="gi">+            else:</span>
<span class="gi">+                checked = value[0] == self.current_value</span>
<span class="gi">+            selected = i == self._selected_index</span>
<span class="gi">+</span>
<span class="gi">+            style = &quot;&quot;</span>
<span class="gi">+            if checked:</span>
<span class="gi">+                style += &quot; &quot; + self.checked_style</span>
<span class="gi">+            if selected:</span>
<span class="gi">+                style += &quot; &quot; + self.selected_style</span>
<span class="gi">+</span>
<span class="gi">+            result.append((style, self.open_character))</span>
<span class="gi">+</span>
<span class="gi">+            if selected:</span>
<span class="gi">+                result.append((&quot;[SetCursorPosition]&quot;, &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            if checked:</span>
<span class="gi">+                result.append((style, &quot;*&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append((style, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+            result.append((style, self.close_character))</span>
<span class="gi">+            result.append((self.default_style, &quot; &quot;))</span>
<span class="gi">+            result.extend(to_formatted_text(value[1], style=self.default_style))</span>
<span class="gi">+            result.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # Add mouse handler to all fragments.</span>
<span class="gi">+        for i in range(len(result)):</span>
<span class="gi">+            result[i] = (result[i][0], result[i][1], mouse_handler)</span>
<span class="gi">+</span>
<span class="gi">+        result.pop()  # Remove last newline.</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.window


<span class="gu">@@ -490,20 +843,25 @@ class RadioList(_DialogList[_T]):</span>

<span class="w"> </span>    :param values: List of (value, label) tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    open_character = &#39;(&#39;</span>
<span class="gd">-    close_character = &#39;)&#39;</span>
<span class="gd">-    container_style = &#39;class:radio-list&#39;</span>
<span class="gd">-    default_style = &#39;class:radio&#39;</span>
<span class="gd">-    selected_style = &#39;class:radio-selected&#39;</span>
<span class="gd">-    checked_style = &#39;class:radio-checked&#39;</span>
<span class="gi">+</span>
<span class="gi">+    open_character = &quot;(&quot;</span>
<span class="gi">+    close_character = &quot;)&quot;</span>
<span class="gi">+    container_style = &quot;class:radio-list&quot;</span>
<span class="gi">+    default_style = &quot;class:radio&quot;</span>
<span class="gi">+    selected_style = &quot;class:radio-selected&quot;</span>
<span class="gi">+    checked_style = &quot;class:radio-checked&quot;</span>
<span class="w"> </span>    multiple_selection = False

<span class="gd">-    def __init__(self, values: Sequence[tuple[_T, AnyFormattedText]],</span>
<span class="gd">-        default: (_T | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        values: Sequence[tuple[_T, AnyFormattedText]],</span>
<span class="gi">+        default: _T | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if default is None:
<span class="w"> </span>            default_values = None
<span class="w"> </span>        else:
<span class="w"> </span>            default_values = [default]
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(values, default_values=default_values)


<span class="gu">@@ -513,12 +871,13 @@ class CheckboxList(_DialogList[_T]):</span>

<span class="w"> </span>    :param values: List of (value, label) tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    open_character = &#39;[&#39;</span>
<span class="gd">-    close_character = &#39;]&#39;</span>
<span class="gd">-    container_style = &#39;class:checkbox-list&#39;</span>
<span class="gd">-    default_style = &#39;class:checkbox&#39;</span>
<span class="gd">-    selected_style = &#39;class:checkbox-selected&#39;</span>
<span class="gd">-    checked_style = &#39;class:checkbox-checked&#39;</span>
<span class="gi">+</span>
<span class="gi">+    open_character = &quot;[&quot;</span>
<span class="gi">+    close_character = &quot;]&quot;</span>
<span class="gi">+    container_style = &quot;class:checkbox-list&quot;</span>
<span class="gi">+    default_style = &quot;class:checkbox&quot;</span>
<span class="gi">+    selected_style = &quot;class:checkbox-selected&quot;</span>
<span class="gi">+    checked_style = &quot;class:checkbox-checked&quot;</span>
<span class="w"> </span>    multiple_selection = True


<span class="gu">@@ -527,24 +886,37 @@ class Checkbox(CheckboxList[str]):</span>

<span class="w"> </span>    :param text: the text
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    show_scrollbar = False

<span class="gd">-    def __init__(self, text: AnyFormattedText=&#39;&#39;, checked: bool=False) -&gt;None:</span>
<span class="gd">-        values = [(&#39;value&#39;, text)]</span>
<span class="gi">+    def __init__(self, text: AnyFormattedText = &quot;&quot;, checked: bool = False) -&gt; None:</span>
<span class="gi">+        values = [(&quot;value&quot;, text)]</span>
<span class="w"> </span>        super().__init__(values=values)
<span class="w"> </span>        self.checked = checked

<span class="gi">+    @property</span>
<span class="gi">+    def checked(self) -&gt; bool:</span>
<span class="gi">+        return &quot;value&quot; in self.current_values</span>
<span class="gi">+</span>
<span class="gi">+    @checked.setter</span>
<span class="gi">+    def checked(self, value: bool) -&gt; None:</span>
<span class="gi">+        if value:</span>
<span class="gi">+            self.current_values = [&quot;value&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.current_values = []</span>
<span class="gi">+</span>

<span class="w"> </span>class VerticalLine:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A simple vertical line with a width of 1.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.window = Window(char=Border.VERTICAL, style=</span>
<span class="gd">-            &#39;class:line,vertical-line&#39;, width=1)</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            char=Border.VERTICAL, style=&quot;class:line,vertical-line&quot;, width=1</span>
<span class="gi">+        )</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.window


<span class="gu">@@ -553,25 +925,57 @@ class HorizontalLine:</span>
<span class="w"> </span>    A simple horizontal line with a height of 1.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.window = Window(char=Border.HORIZONTAL, style=</span>
<span class="gd">-            &#39;class:line,horizontal-line&#39;, height=1)</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            char=Border.HORIZONTAL, style=&quot;class:line,horizontal-line&quot;, height=1</span>
<span class="gi">+        )</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.window


<span class="w"> </span>class ProgressBar:
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._percentage = 60
<span class="gd">-        self.label = Label(&#39;60%&#39;)</span>
<span class="gd">-        self.container = FloatContainer(content=Window(height=1), floats=[</span>
<span class="gd">-            Float(content=self.label, top=0, bottom=0), Float(left=0, top=0,</span>
<span class="gd">-            right=0, bottom=0, content=VSplit([Window(style=</span>
<span class="gd">-            &#39;class:progress-bar.used&#39;, width=lambda : D(weight=int(self.</span>
<span class="gd">-            _percentage))), Window(style=&#39;class:progress-bar&#39;, width=lambda :</span>
<span class="gd">-            D(weight=int(100 - self._percentage)))]))])</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        self.label = Label(&quot;60%&quot;)</span>
<span class="gi">+        self.container = FloatContainer(</span>
<span class="gi">+            content=Window(height=1),</span>
<span class="gi">+            floats=[</span>
<span class="gi">+                # We first draw the label, then the actual progress bar.  Right</span>
<span class="gi">+                # now, this is the only way to have the colors of the progress</span>
<span class="gi">+                # bar appear on top of the label. The problem is that our label</span>
<span class="gi">+                # can&#39;t be part of any `Window` below.</span>
<span class="gi">+                Float(content=self.label, top=0, bottom=0),</span>
<span class="gi">+                Float(</span>
<span class="gi">+                    left=0,</span>
<span class="gi">+                    top=0,</span>
<span class="gi">+                    right=0,</span>
<span class="gi">+                    bottom=0,</span>
<span class="gi">+                    content=VSplit(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            Window(</span>
<span class="gi">+                                style=&quot;class:progress-bar.used&quot;,</span>
<span class="gi">+                                width=lambda: D(weight=int(self._percentage)),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            Window(</span>
<span class="gi">+                                style=&quot;class:progress-bar&quot;,</span>
<span class="gi">+                                width=lambda: D(weight=int(100 - self._percentage)),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ),</span>
<span class="gi">+            ],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def percentage(self) -&gt; int:</span>
<span class="gi">+        return self._percentage</span>
<span class="gi">+</span>
<span class="gi">+    @percentage.setter</span>
<span class="gi">+    def percentage(self, value: int) -&gt; None:</span>
<span class="gi">+        self._percentage = value</span>
<span class="gi">+        self.label.text = f&quot;{value}%&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container
<span class="gh">diff --git a/src/prompt_toolkit/widgets/dialogs.py b/src/prompt_toolkit/widgets/dialogs.py</span>
<span class="gh">index 29550fe1..c47c15b4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/widgets/dialogs.py</span>
<span class="gi">+++ b/src/prompt_toolkit/widgets/dialogs.py</span>
<span class="gu">@@ -2,16 +2,27 @@</span>
<span class="w"> </span>Collection of reusable components for building full screen applications.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Sequence
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.filters import has_completions, has_focus
<span class="w"> </span>from prompt_toolkit.formatted_text import AnyFormattedText
<span class="w"> </span>from prompt_toolkit.key_binding.bindings.focus import focus_next, focus_previous
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import KeyBindings
<span class="gd">-from prompt_toolkit.layout.containers import AnyContainer, DynamicContainer, HSplit, VSplit</span>
<span class="gi">+from prompt_toolkit.layout.containers import (</span>
<span class="gi">+    AnyContainer,</span>
<span class="gi">+    DynamicContainer,</span>
<span class="gi">+    HSplit,</span>
<span class="gi">+    VSplit,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.dimension import AnyDimension
<span class="w"> </span>from prompt_toolkit.layout.dimension import Dimension as D
<span class="gi">+</span>
<span class="w"> </span>from .base import Box, Button, Frame, Shadow
<span class="gd">-__all__ = [&#39;Dialog&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;Dialog&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Dialog:
<span class="gu">@@ -27,37 +38,70 @@ class Dialog:</span>
<span class="w"> </span>    :param buttons: A list of `Button` widgets, displayed at the bottom.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, body: AnyContainer, title: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-        buttons: (Sequence[Button] | None)=None, modal: bool=True, width:</span>
<span class="gd">-        AnyDimension=None, with_background: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        body: AnyContainer,</span>
<span class="gi">+        title: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        buttons: Sequence[Button] | None = None,</span>
<span class="gi">+        modal: bool = True,</span>
<span class="gi">+        width: AnyDimension = None,</span>
<span class="gi">+        with_background: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.body = body
<span class="w"> </span>        self.title = title
<span class="gi">+</span>
<span class="w"> </span>        buttons = buttons or []
<span class="gi">+</span>
<span class="gi">+        # When a button is selected, handle left/right key bindings.</span>
<span class="w"> </span>        buttons_kb = KeyBindings()
<span class="w"> </span>        if len(buttons) &gt; 1:
<span class="w"> </span>            first_selected = has_focus(buttons[0])
<span class="w"> </span>            last_selected = has_focus(buttons[-1])
<span class="gd">-            buttons_kb.add(&#39;left&#39;, filter=~first_selected)(focus_previous)</span>
<span class="gd">-            buttons_kb.add(&#39;right&#39;, filter=~last_selected)(focus_next)</span>
<span class="gi">+</span>
<span class="gi">+            buttons_kb.add(&quot;left&quot;, filter=~first_selected)(focus_previous)</span>
<span class="gi">+            buttons_kb.add(&quot;right&quot;, filter=~last_selected)(focus_next)</span>
<span class="gi">+</span>
<span class="w"> </span>        frame_body: AnyContainer
<span class="w"> </span>        if buttons:
<span class="gd">-            frame_body = HSplit([Box(body=DynamicContainer(lambda : self.</span>
<span class="gd">-                body), padding=D(preferred=1, max=1), padding_bottom=0),</span>
<span class="gd">-                Box(body=VSplit(buttons, padding=1, key_bindings=buttons_kb</span>
<span class="gd">-                ), height=D(min=1, max=3, preferred=3))])</span>
<span class="gi">+            frame_body = HSplit(</span>
<span class="gi">+                [</span>
<span class="gi">+                    # Add optional padding around the body.</span>
<span class="gi">+                    Box(</span>
<span class="gi">+                        body=DynamicContainer(lambda: self.body),</span>
<span class="gi">+                        padding=D(preferred=1, max=1),</span>
<span class="gi">+                        padding_bottom=0,</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    # The buttons.</span>
<span class="gi">+                    Box(</span>
<span class="gi">+                        body=VSplit(buttons, padding=1, key_bindings=buttons_kb),</span>
<span class="gi">+                        height=D(min=1, max=3, preferred=3),</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ]</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            frame_body = body
<span class="gi">+</span>
<span class="gi">+        # Key bindings for whole dialog.</span>
<span class="w"> </span>        kb = KeyBindings()
<span class="gd">-        kb.add(&#39;tab&#39;, filter=~has_completions)(focus_next)</span>
<span class="gd">-        kb.add(&#39;s-tab&#39;, filter=~has_completions)(focus_previous)</span>
<span class="gd">-        frame = Shadow(body=Frame(title=lambda : self.title, body=</span>
<span class="gd">-            frame_body, style=&#39;class:dialog.body&#39;, width=None if </span>
<span class="gd">-            with_background is None else width, key_bindings=kb, modal=modal))</span>
<span class="gi">+        kb.add(&quot;tab&quot;, filter=~has_completions)(focus_next)</span>
<span class="gi">+        kb.add(&quot;s-tab&quot;, filter=~has_completions)(focus_previous)</span>
<span class="gi">+</span>
<span class="gi">+        frame = Shadow(</span>
<span class="gi">+            body=Frame(</span>
<span class="gi">+                title=lambda: self.title,</span>
<span class="gi">+                body=frame_body,</span>
<span class="gi">+                style=&quot;class:dialog.body&quot;,</span>
<span class="gi">+                width=(None if with_background is None else width),</span>
<span class="gi">+                key_bindings=kb,</span>
<span class="gi">+                modal=modal,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.container: Box | Shadow
<span class="w"> </span>        if with_background:
<span class="gd">-            self.container = Box(body=frame, style=&#39;class:dialog&#39;, width=width)</span>
<span class="gi">+            self.container = Box(body=frame, style=&quot;class:dialog&quot;, width=width)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.container = frame

<span class="gd">-    def __pt_container__(self) -&gt;AnyContainer:</span>
<span class="gi">+    def __pt_container__(self) -&gt; AnyContainer:</span>
<span class="w"> </span>        return self.container
<span class="gh">diff --git a/src/prompt_toolkit/widgets/menus.py b/src/prompt_toolkit/widgets/menus.py</span>
<span class="gh">index 9174199f..c574c067 100644</span>
<span class="gd">--- a/src/prompt_toolkit/widgets/menus.py</span>
<span class="gi">+++ b/src/prompt_toolkit/widgets/menus.py</span>
<span class="gu">@@ -1,18 +1,34 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable, Iterable, Sequence
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.filters import Condition
<span class="w"> </span>from prompt_toolkit.formatted_text.base import OneStyleAndTextTuple, StyleAndTextTuples
<span class="w"> </span>from prompt_toolkit.key_binding.key_bindings import KeyBindings, KeyBindingsBase
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="gd">-from prompt_toolkit.layout.containers import AnyContainer, ConditionalContainer, Container, Float, FloatContainer, HSplit, Window</span>
<span class="gi">+from prompt_toolkit.layout.containers import (</span>
<span class="gi">+    AnyContainer,</span>
<span class="gi">+    ConditionalContainer,</span>
<span class="gi">+    Container,</span>
<span class="gi">+    Float,</span>
<span class="gi">+    FloatContainer,</span>
<span class="gi">+    HSplit,</span>
<span class="gi">+    Window,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.controls import FormattedTextControl
<span class="w"> </span>from prompt_toolkit.mouse_events import MouseEvent, MouseEventType
<span class="w"> </span>from prompt_toolkit.utils import get_cwidth
<span class="w"> </span>from prompt_toolkit.widgets import Shadow
<span class="gi">+</span>
<span class="w"> </span>from .base import Border
<span class="gd">-__all__ = [&#39;MenuContainer&#39;, &#39;MenuItem&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;MenuContainer&quot;,</span>
<span class="gi">+    &quot;MenuItem&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="gu">@@ -22,126 +38,337 @@ class MenuContainer:</span>
<span class="w"> </span>    :param menu_items: List of `MenuItem` objects.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, body: AnyContainer, menu_items: list[MenuItem],</span>
<span class="gd">-        floats: (list[Float] | None)=None, key_bindings: (KeyBindingsBase |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        body: AnyContainer,</span>
<span class="gi">+        menu_items: list[MenuItem],</span>
<span class="gi">+        floats: list[Float] | None = None,</span>
<span class="gi">+        key_bindings: KeyBindingsBase | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.body = body
<span class="w"> </span>        self.menu_items = menu_items
<span class="w"> </span>        self.selected_menu = [0]
<span class="gi">+</span>
<span class="gi">+        # Key bindings.</span>
<span class="w"> </span>        kb = KeyBindings()

<span class="w"> </span>        @Condition
<span class="gd">-        def in_main_menu() -&gt;bool:</span>
<span class="gi">+        def in_main_menu() -&gt; bool:</span>
<span class="w"> </span>            return len(self.selected_menu) == 1

<span class="w"> </span>        @Condition
<span class="gd">-        def in_sub_menu() -&gt;bool:</span>
<span class="gi">+        def in_sub_menu() -&gt; bool:</span>
<span class="w"> </span>            return len(self.selected_menu) &gt; 1

<span class="gd">-        @kb.add(&#39;left&#39;, filter=in_main_menu)</span>
<span class="gd">-        def _left(event: E) -&gt;None:</span>
<span class="gi">+        # Navigation through the main menu.</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot;left&quot;, filter=in_main_menu)</span>
<span class="gi">+        def _left(event: E) -&gt; None:</span>
<span class="w"> </span>            self.selected_menu[0] = max(0, self.selected_menu[0] - 1)

<span class="gd">-        @kb.add(&#39;right&#39;, filter=in_main_menu)</span>
<span class="gd">-        def _right(event: E) -&gt;None:</span>
<span class="gd">-            self.selected_menu[0] = min(len(self.menu_items) - 1, self.</span>
<span class="gd">-                selected_menu[0] + 1)</span>
<span class="gi">+        @kb.add(&quot;right&quot;, filter=in_main_menu)</span>
<span class="gi">+        def _right(event: E) -&gt; None:</span>
<span class="gi">+            self.selected_menu[0] = min(</span>
<span class="gi">+                len(self.menu_items) - 1, self.selected_menu[0] + 1</span>
<span class="gi">+            )</span>

<span class="gd">-        @kb.add(&#39;down&#39;, filter=in_main_menu)</span>
<span class="gd">-        def _down(event: E) -&gt;None:</span>
<span class="gi">+        @kb.add(&quot;down&quot;, filter=in_main_menu)</span>
<span class="gi">+        def _down(event: E) -&gt; None:</span>
<span class="w"> </span>            self.selected_menu.append(0)

<span class="gd">-        @kb.add(&#39;c-c&#39;, filter=in_main_menu)</span>
<span class="gd">-        @kb.add(&#39;c-g&#39;, filter=in_main_menu)</span>
<span class="gd">-        def _cancel(event: E) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;Leave menu.&quot;&quot;&quot;</span>
<span class="gi">+        @kb.add(&quot;c-c&quot;, filter=in_main_menu)</span>
<span class="gi">+        @kb.add(&quot;c-g&quot;, filter=in_main_menu)</span>
<span class="gi">+        def _cancel(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Leave menu.&quot;</span>
<span class="w"> </span>            event.app.layout.focus_last()

<span class="gd">-        @kb.add(&#39;left&#39;, filter=in_sub_menu)</span>
<span class="gd">-        @kb.add(&#39;c-g&#39;, filter=in_sub_menu)</span>
<span class="gd">-        @kb.add(&#39;c-c&#39;, filter=in_sub_menu)</span>
<span class="gd">-        def _back(event: E) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;Go back to parent menu.&quot;&quot;&quot;</span>
<span class="gi">+        # Sub menu navigation.</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&quot;left&quot;, filter=in_sub_menu)</span>
<span class="gi">+        @kb.add(&quot;c-g&quot;, filter=in_sub_menu)</span>
<span class="gi">+        @kb.add(&quot;c-c&quot;, filter=in_sub_menu)</span>
<span class="gi">+        def _back(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Go back to parent menu.&quot;</span>
<span class="w"> </span>            if len(self.selected_menu) &gt; 1:
<span class="w"> </span>                self.selected_menu.pop()

<span class="gd">-        @kb.add(&#39;right&#39;, filter=in_sub_menu)</span>
<span class="gd">-        def _submenu(event: E) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;go into sub menu.&quot;&quot;&quot;</span>
<span class="gi">+        @kb.add(&quot;right&quot;, filter=in_sub_menu)</span>
<span class="gi">+        def _submenu(event: E) -&gt; None:</span>
<span class="gi">+            &quot;go into sub menu.&quot;</span>
<span class="w"> </span>            if self._get_menu(len(self.selected_menu) - 1).children:
<span class="w"> </span>                self.selected_menu.append(0)
<span class="gd">-            elif len(self.selected_menu) == 2 and self.selected_menu[0] &lt; len(</span>
<span class="gd">-                self.menu_items) - 1:</span>
<span class="gd">-                self.selected_menu = [min(len(self.menu_items) - 1, self.</span>
<span class="gd">-                    selected_menu[0] + 1)]</span>
<span class="gi">+</span>
<span class="gi">+            # If This item does not have a sub menu. Go up in the parent menu.</span>
<span class="gi">+            elif (</span>
<span class="gi">+                len(self.selected_menu) == 2</span>
<span class="gi">+                and self.selected_menu[0] &lt; len(self.menu_items) - 1</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.selected_menu = [</span>
<span class="gi">+                    min(len(self.menu_items) - 1, self.selected_menu[0] + 1)</span>
<span class="gi">+                ]</span>
<span class="w"> </span>                if self.menu_items[self.selected_menu[0]].children:
<span class="w"> </span>                    self.selected_menu.append(0)

<span class="gd">-        @kb.add(&#39;up&#39;, filter=in_sub_menu)</span>
<span class="gd">-        def _up_in_submenu(event: E) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;Select previous (enabled) menu item or return to main menu.&quot;&quot;&quot;</span>
<span class="gi">+        @kb.add(&quot;up&quot;, filter=in_sub_menu)</span>
<span class="gi">+        def _up_in_submenu(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Select previous (enabled) menu item or return to main menu.&quot;</span>
<span class="gi">+            # Look for previous enabled items in this sub menu.</span>
<span class="w"> </span>            menu = self._get_menu(len(self.selected_menu) - 2)
<span class="w"> </span>            index = self.selected_menu[-1]
<span class="gd">-            previous_indexes = [i for i, item in enumerate(menu.children) if</span>
<span class="gd">-                i &lt; index and not item.disabled]</span>
<span class="gi">+</span>
<span class="gi">+            previous_indexes = [</span>
<span class="gi">+                i</span>
<span class="gi">+                for i, item in enumerate(menu.children)</span>
<span class="gi">+                if i &lt; index and not item.disabled</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="w"> </span>            if previous_indexes:
<span class="w"> </span>                self.selected_menu[-1] = previous_indexes[-1]
<span class="w"> </span>            elif len(self.selected_menu) == 2:
<span class="gi">+                # Return to main menu.</span>
<span class="w"> </span>                self.selected_menu.pop()

<span class="gd">-        @kb.add(&#39;down&#39;, filter=in_sub_menu)</span>
<span class="gd">-        def _down_in_submenu(event: E) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;Select next (enabled) menu item.&quot;&quot;&quot;</span>
<span class="gi">+        @kb.add(&quot;down&quot;, filter=in_sub_menu)</span>
<span class="gi">+        def _down_in_submenu(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Select next (enabled) menu item.&quot;</span>
<span class="w"> </span>            menu = self._get_menu(len(self.selected_menu) - 2)
<span class="w"> </span>            index = self.selected_menu[-1]
<span class="gd">-            next_indexes = [i for i, item in enumerate(menu.children) if i &gt;</span>
<span class="gd">-                index and not item.disabled]</span>
<span class="gi">+</span>
<span class="gi">+            next_indexes = [</span>
<span class="gi">+                i</span>
<span class="gi">+                for i, item in enumerate(menu.children)</span>
<span class="gi">+                if i &gt; index and not item.disabled</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="w"> </span>            if next_indexes:
<span class="w"> </span>                self.selected_menu[-1] = next_indexes[0]

<span class="gd">-        @kb.add(&#39;enter&#39;)</span>
<span class="gd">-        def _click(event: E) -&gt;None:</span>
<span class="gd">-            &quot;&quot;&quot;Click the selected menu item.&quot;&quot;&quot;</span>
<span class="gi">+        @kb.add(&quot;enter&quot;)</span>
<span class="gi">+        def _click(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Click the selected menu item.&quot;</span>
<span class="w"> </span>            item = self._get_menu(len(self.selected_menu) - 1)
<span class="w"> </span>            if item.handler:
<span class="w"> </span>                event.app.layout.focus_last()
<span class="w"> </span>                item.handler()
<span class="gd">-        self.control = FormattedTextControl(self._get_menu_fragments,</span>
<span class="gd">-            key_bindings=kb, focusable=True, show_cursor=False)</span>
<span class="gd">-        self.window = Window(height=1, content=self.control, style=</span>
<span class="gd">-            &#39;class:menu-bar&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Controls.</span>
<span class="gi">+        self.control = FormattedTextControl(</span>
<span class="gi">+            self._get_menu_fragments, key_bindings=kb, focusable=True, show_cursor=False</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.window = Window(height=1, content=self.control, style=&quot;class:menu-bar&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        submenu = self._submenu(0)
<span class="w"> </span>        submenu2 = self._submenu(1)
<span class="w"> </span>        submenu3 = self._submenu(2)

<span class="w"> </span>        @Condition
<span class="gd">-        def has_focus() -&gt;bool:</span>
<span class="gi">+        def has_focus() -&gt; bool:</span>
<span class="w"> </span>            return get_app().layout.current_window == self.window
<span class="gd">-        self.container = FloatContainer(content=HSplit([self.window, body]),</span>
<span class="gd">-            floats=[Float(xcursor=True, ycursor=True, content=</span>
<span class="gd">-            ConditionalContainer(content=Shadow(body=submenu), filter=</span>
<span class="gd">-            has_focus)), Float(attach_to_window=submenu, xcursor=True,</span>
<span class="gd">-            ycursor=True, allow_cover_cursor=True, content=</span>
<span class="gd">-            ConditionalContainer(content=Shadow(body=submenu2), filter=</span>
<span class="gd">-            has_focus &amp; Condition(lambda : len(self.selected_menu) &gt;= 1))),</span>
<span class="gd">-            Float(attach_to_window=submenu2, xcursor=True, ycursor=True,</span>
<span class="gd">-            allow_cover_cursor=True, content=ConditionalContainer(content=</span>
<span class="gd">-            Shadow(body=submenu3), filter=has_focus &amp; Condition(lambda : </span>
<span class="gd">-            len(self.selected_menu) &gt;= 2)))] + (floats or []), key_bindings</span>
<span class="gd">-            =key_bindings)</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        self.container = FloatContainer(</span>
<span class="gi">+            content=HSplit(</span>
<span class="gi">+                [</span>
<span class="gi">+                    # The titlebar.</span>
<span class="gi">+                    self.window,</span>
<span class="gi">+                    # The &#39;body&#39;, like defined above.</span>
<span class="gi">+                    body,</span>
<span class="gi">+                ]</span>
<span class="gi">+            ),</span>
<span class="gi">+            floats=[</span>
<span class="gi">+                Float(</span>
<span class="gi">+                    xcursor=True,</span>
<span class="gi">+                    ycursor=True,</span>
<span class="gi">+                    content=ConditionalContainer(</span>
<span class="gi">+                        content=Shadow(body=submenu), filter=has_focus</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ),</span>
<span class="gi">+                Float(</span>
<span class="gi">+                    attach_to_window=submenu,</span>
<span class="gi">+                    xcursor=True,</span>
<span class="gi">+                    ycursor=True,</span>
<span class="gi">+                    allow_cover_cursor=True,</span>
<span class="gi">+                    content=ConditionalContainer(</span>
<span class="gi">+                        content=Shadow(body=submenu2),</span>
<span class="gi">+                        filter=has_focus</span>
<span class="gi">+                        &amp; Condition(lambda: len(self.selected_menu) &gt;= 1),</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ),</span>
<span class="gi">+                Float(</span>
<span class="gi">+                    attach_to_window=submenu2,</span>
<span class="gi">+                    xcursor=True,</span>
<span class="gi">+                    ycursor=True,</span>
<span class="gi">+                    allow_cover_cursor=True,</span>
<span class="gi">+                    content=ConditionalContainer(</span>
<span class="gi">+                        content=Shadow(body=submenu3),</span>
<span class="gi">+                        filter=has_focus</span>
<span class="gi">+                        &amp; Condition(lambda: len(self.selected_menu) &gt;= 2),</span>
<span class="gi">+                    ),</span>
<span class="gi">+                ),</span>
<span class="gi">+                # --</span>
<span class="gi">+            ]</span>
<span class="gi">+            + (floats or []),</span>
<span class="gi">+            key_bindings=key_bindings,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_menu(self, level: int) -&gt; MenuItem:</span>
<span class="gi">+        menu = self.menu_items[self.selected_menu[0]]</span>
<span class="gi">+</span>
<span class="gi">+        for i, index in enumerate(self.selected_menu[1:]):</span>
<span class="gi">+            if i &lt; level:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    menu = menu.children[index]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    return MenuItem(&quot;debug&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return menu</span>
<span class="gi">+</span>
<span class="gi">+    def _get_menu_fragments(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        focused = get_app().layout.has_focus(self.window)</span>
<span class="gi">+</span>
<span class="gi">+        # This is called during the rendering. When we discover that this</span>
<span class="gi">+        # widget doesn&#39;t have the focus anymore. Reset menu state.</span>
<span class="gi">+        if not focused:</span>
<span class="gi">+            self.selected_menu = [0]</span>
<span class="gi">+</span>
<span class="gi">+        # Generate text fragments for the main menu.</span>
<span class="gi">+        def one_item(i: int, item: MenuItem) -&gt; Iterable[OneStyleAndTextTuple]:</span>
<span class="gi">+            def mouse_handler(mouse_event: MouseEvent) -&gt; None:</span>
<span class="gi">+                hover = mouse_event.event_type == MouseEventType.MOUSE_MOVE</span>
<span class="gi">+                if (</span>
<span class="gi">+                    mouse_event.event_type == MouseEventType.MOUSE_DOWN</span>
<span class="gi">+                    or hover</span>
<span class="gi">+                    and focused</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Toggle focus.</span>
<span class="gi">+                    app = get_app()</span>
<span class="gi">+                    if not hover:</span>
<span class="gi">+                        if app.layout.has_focus(self.window):</span>
<span class="gi">+                            if self.selected_menu == [i]:</span>
<span class="gi">+                                app.layout.focus_last()</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            app.layout.focus(self.window)</span>
<span class="gi">+                    self.selected_menu = [i]</span>
<span class="gi">+</span>
<span class="gi">+            yield (&quot;class:menu-bar&quot;, &quot; &quot;, mouse_handler)</span>
<span class="gi">+            if i == self.selected_menu[0] and focused:</span>
<span class="gi">+                yield (&quot;[SetMenuPosition]&quot;, &quot;&quot;, mouse_handler)</span>
<span class="gi">+                style = &quot;class:menu-bar.selected-item&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                style = &quot;class:menu-bar&quot;</span>
<span class="gi">+            yield style, item.text, mouse_handler</span>
<span class="gi">+</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+        for i, item in enumerate(self.menu_items):</span>
<span class="gi">+            result.extend(one_item(i, item))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _submenu(self, level: int = 0) -&gt; Window:</span>
<span class="gi">+        def get_text_fragments() -&gt; StyleAndTextTuples:</span>
<span class="gi">+            result: StyleAndTextTuples = []</span>
<span class="gi">+            if level &lt; len(self.selected_menu):</span>
<span class="gi">+                menu = self._get_menu(level)</span>
<span class="gi">+                if menu.children:</span>
<span class="gi">+                    result.append((&quot;class:menu&quot;, Border.TOP_LEFT))</span>
<span class="gi">+                    result.append((&quot;class:menu&quot;, Border.HORIZONTAL * (menu.width + 4)))</span>
<span class="gi">+                    result.append((&quot;class:menu&quot;, Border.TOP_RIGHT))</span>
<span class="gi">+                    result.append((&quot;&quot;, &quot;\n&quot;))</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        selected_item = self.selected_menu[level + 1]</span>
<span class="gi">+                    except IndexError:</span>
<span class="gi">+                        selected_item = -1</span>
<span class="gi">+</span>
<span class="gi">+                    def one_item(</span>
<span class="gi">+                        i: int, item: MenuItem</span>
<span class="gi">+                    ) -&gt; Iterable[OneStyleAndTextTuple]:</span>
<span class="gi">+                        def mouse_handler(mouse_event: MouseEvent) -&gt; None:</span>
<span class="gi">+                            if item.disabled:</span>
<span class="gi">+                                # The arrow keys can&#39;t interact with menu items that are disabled.</span>
<span class="gi">+                                # The mouse shouldn&#39;t be able to either.</span>
<span class="gi">+                                return</span>
<span class="gi">+                            hover = mouse_event.event_type == MouseEventType.MOUSE_MOVE</span>
<span class="gi">+                            if (</span>
<span class="gi">+                                mouse_event.event_type == MouseEventType.MOUSE_UP</span>
<span class="gi">+                                or hover</span>
<span class="gi">+                            ):</span>
<span class="gi">+                                app = get_app()</span>
<span class="gi">+                                if not hover and item.handler:</span>
<span class="gi">+                                    app.layout.focus_last()</span>
<span class="gi">+                                    item.handler()</span>
<span class="gi">+                                else:</span>
<span class="gi">+                                    self.selected_menu = self.selected_menu[</span>
<span class="gi">+                                        : level + 1</span>
<span class="gi">+                                    ] + [i]</span>
<span class="gi">+</span>
<span class="gi">+                        if i == selected_item:</span>
<span class="gi">+                            yield (&quot;[SetCursorPosition]&quot;, &quot;&quot;)</span>
<span class="gi">+                            style = &quot;class:menu-bar.selected-item&quot;</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            style = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+                        yield (&quot;class:menu&quot;, Border.VERTICAL)</span>
<span class="gi">+                        if item.text == &quot;-&quot;:</span>
<span class="gi">+                            yield (</span>
<span class="gi">+                                style + &quot;class:menu-border&quot;,</span>
<span class="gi">+                                f&quot;{Border.HORIZONTAL * (menu.width + 3)}&quot;,</span>
<span class="gi">+                                mouse_handler,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            yield (</span>
<span class="gi">+                                style,</span>
<span class="gi">+                                f&quot; {item.text}&quot;.ljust(menu.width + 3),</span>
<span class="gi">+                                mouse_handler,</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+                        if item.children:</span>
<span class="gi">+                            yield (style, &quot;&gt;&quot;, mouse_handler)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            yield (style, &quot; &quot;, mouse_handler)</span>
<span class="gi">+</span>
<span class="gi">+                        if i == selected_item:</span>
<span class="gi">+                            yield (&quot;[SetMenuPosition]&quot;, &quot;&quot;)</span>
<span class="gi">+                        yield (&quot;class:menu&quot;, Border.VERTICAL)</span>
<span class="gi">+</span>
<span class="gi">+                        yield (&quot;&quot;, &quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                    for i, item in enumerate(menu.children):</span>
<span class="gi">+                        result.extend(one_item(i, item))</span>
<span class="gi">+</span>
<span class="gi">+                    result.append((&quot;class:menu&quot;, Border.BOTTOM_LEFT))</span>
<span class="gi">+                    result.append((&quot;class:menu&quot;, Border.HORIZONTAL * (menu.width + 4)))</span>
<span class="gi">+                    result.append((&quot;class:menu&quot;, Border.BOTTOM_RIGHT))</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return Window(FormattedTextControl(get_text_fragments), style=&quot;class:menu&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def floats(self) -&gt; list[Float] | None:</span>
<span class="gi">+        return self.container.floats</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="w"> </span>class MenuItem:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, text: str=&#39;&#39;, handler: (Callable[[], None] | None)=</span>
<span class="gd">-        None, children: (list[MenuItem] | None)=None, shortcut: (Sequence[</span>
<span class="gd">-        Keys | str] | None)=None, disabled: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text: str = &quot;&quot;,</span>
<span class="gi">+        handler: Callable[[], None] | None = None,</span>
<span class="gi">+        children: list[MenuItem] | None = None,</span>
<span class="gi">+        shortcut: Sequence[Keys | str] | None = None,</span>
<span class="gi">+        disabled: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.handler = handler
<span class="w"> </span>        self.children = children or []
<span class="w"> </span>        self.shortcut = shortcut
<span class="w"> </span>        self.disabled = disabled
<span class="w"> </span>        self.selected_item = 0
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def width(self) -&gt; int:</span>
<span class="gi">+        if self.children:</span>
<span class="gi">+            return max(get_cwidth(c.text) for c in self.children)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gh">diff --git a/src/prompt_toolkit/widgets/toolbars.py b/src/prompt_toolkit/widgets/toolbars.py</span>
<span class="gh">index 69e19222..deddf154 100644</span>
<span class="gd">--- a/src/prompt_toolkit/widgets/toolbars.py</span>
<span class="gi">+++ b/src/prompt_toolkit/widgets/toolbars.py</span>
<span class="gu">@@ -1,31 +1,72 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from prompt_toolkit.application.current import get_app
<span class="w"> </span>from prompt_toolkit.buffer import Buffer
<span class="w"> </span>from prompt_toolkit.enums import SYSTEM_BUFFER
<span class="gd">-from prompt_toolkit.filters import Condition, FilterOrBool, emacs_mode, has_arg, has_completions, has_focus, has_validation_error, to_filter, vi_mode, vi_navigation_mode</span>
<span class="gd">-from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, fragment_list_len, to_formatted_text</span>
<span class="gd">-from prompt_toolkit.key_binding.key_bindings import ConditionalKeyBindings, KeyBindings, KeyBindingsBase, merge_key_bindings</span>
<span class="gi">+from prompt_toolkit.filters import (</span>
<span class="gi">+    Condition,</span>
<span class="gi">+    FilterOrBool,</span>
<span class="gi">+    emacs_mode,</span>
<span class="gi">+    has_arg,</span>
<span class="gi">+    has_completions,</span>
<span class="gi">+    has_focus,</span>
<span class="gi">+    has_validation_error,</span>
<span class="gi">+    to_filter,</span>
<span class="gi">+    vi_mode,</span>
<span class="gi">+    vi_navigation_mode,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.formatted_text import (</span>
<span class="gi">+    AnyFormattedText,</span>
<span class="gi">+    StyleAndTextTuples,</span>
<span class="gi">+    fragment_list_len,</span>
<span class="gi">+    to_formatted_text,</span>
<span class="gi">+)</span>
<span class="gi">+from prompt_toolkit.key_binding.key_bindings import (</span>
<span class="gi">+    ConditionalKeyBindings,</span>
<span class="gi">+    KeyBindings,</span>
<span class="gi">+    KeyBindingsBase,</span>
<span class="gi">+    merge_key_bindings,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.key_binding.key_processor import KeyPressEvent
<span class="w"> </span>from prompt_toolkit.key_binding.vi_state import InputMode
<span class="w"> </span>from prompt_toolkit.keys import Keys
<span class="w"> </span>from prompt_toolkit.layout.containers import ConditionalContainer, Container, Window
<span class="gd">-from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl, SearchBufferControl, UIContent, UIControl</span>
<span class="gi">+from prompt_toolkit.layout.controls import (</span>
<span class="gi">+    BufferControl,</span>
<span class="gi">+    FormattedTextControl,</span>
<span class="gi">+    SearchBufferControl,</span>
<span class="gi">+    UIContent,</span>
<span class="gi">+    UIControl,</span>
<span class="gi">+)</span>
<span class="w"> </span>from prompt_toolkit.layout.dimension import Dimension
<span class="w"> </span>from prompt_toolkit.layout.processors import BeforeInput
<span class="w"> </span>from prompt_toolkit.lexers import SimpleLexer
<span class="w"> </span>from prompt_toolkit.search import SearchDirection
<span class="gd">-__all__ = [&#39;ArgToolbar&#39;, &#39;CompletionsToolbar&#39;, &#39;FormattedTextToolbar&#39;,</span>
<span class="gd">-    &#39;SearchToolbar&#39;, &#39;SystemToolbar&#39;, &#39;ValidationToolbar&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;ArgToolbar&quot;,</span>
<span class="gi">+    &quot;CompletionsToolbar&quot;,</span>
<span class="gi">+    &quot;FormattedTextToolbar&quot;,</span>
<span class="gi">+    &quot;SearchToolbar&quot;,</span>
<span class="gi">+    &quot;SystemToolbar&quot;,</span>
<span class="gi">+    &quot;ValidationToolbar&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>E = KeyPressEvent


<span class="w"> </span>class FormattedTextToolbar(Window):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, text: AnyFormattedText, style: str=&#39;&#39;, **kw: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(FormattedTextControl(text, **kw), style=style,</span>
<span class="gd">-            dont_extend_height=True, height=Dimension(min=1))</span>
<span class="gi">+    def __init__(self, text: AnyFormattedText, style: str = &quot;&quot;, **kw: Any) -&gt; None:</span>
<span class="gi">+        # Note: The style needs to be applied to the toolbar as a whole, not</span>
<span class="gi">+        #       just the `FormattedTextControl`.</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            FormattedTextControl(text, **kw),</span>
<span class="gi">+            style=style,</span>
<span class="gi">+            dont_extend_height=True,</span>
<span class="gi">+            height=Dimension(min=1),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class SystemToolbar:
<span class="gu">@@ -35,41 +76,135 @@ class SystemToolbar:</span>
<span class="w"> </span>    :param prompt: Prompt to be displayed to the user.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, prompt: AnyFormattedText=&#39;Shell command: &#39;,</span>
<span class="gd">-        enable_global_bindings: FilterOrBool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        prompt: AnyFormattedText = &quot;Shell command: &quot;,</span>
<span class="gi">+        enable_global_bindings: FilterOrBool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.prompt = prompt
<span class="w"> </span>        self.enable_global_bindings = to_filter(enable_global_bindings)
<span class="gi">+</span>
<span class="w"> </span>        self.system_buffer = Buffer(name=SYSTEM_BUFFER)
<span class="gi">+</span>
<span class="w"> </span>        self._bindings = self._build_key_bindings()
<span class="gd">-        self.buffer_control = BufferControl(buffer=self.system_buffer,</span>
<span class="gd">-            lexer=SimpleLexer(style=&#39;class:system-toolbar.text&#39;),</span>
<span class="gd">-            input_processors=[BeforeInput(lambda : self.prompt, style=</span>
<span class="gd">-            &#39;class:system-toolbar&#39;)], key_bindings=self._bindings)</span>
<span class="gd">-        self.window = Window(self.buffer_control, height=1, style=</span>
<span class="gd">-            &#39;class:system-toolbar&#39;)</span>
<span class="gd">-        self.container = ConditionalContainer(content=self.window, filter=</span>
<span class="gd">-            has_focus(self.system_buffer))</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        self.buffer_control = BufferControl(</span>
<span class="gi">+            buffer=self.system_buffer,</span>
<span class="gi">+            lexer=SimpleLexer(style=&quot;class:system-toolbar.text&quot;),</span>
<span class="gi">+            input_processors=[</span>
<span class="gi">+                BeforeInput(lambda: self.prompt, style=&quot;class:system-toolbar&quot;)</span>
<span class="gi">+            ],</span>
<span class="gi">+            key_bindings=self._bindings,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.window = Window(</span>
<span class="gi">+            self.buffer_control, height=1, style=&quot;class:system-toolbar&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.container = ConditionalContainer(</span>
<span class="gi">+            content=self.window, filter=has_focus(self.system_buffer)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_display_before_text(self) -&gt; StyleAndTextTuples:</span>
<span class="gi">+        return [</span>
<span class="gi">+            (&quot;class:system-toolbar&quot;, &quot;Shell command: &quot;),</span>
<span class="gi">+            (&quot;class:system-toolbar.text&quot;, self.system_buffer.text),</span>
<span class="gi">+            (&quot;&quot;, &quot;\n&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _build_key_bindings(self) -&gt; KeyBindingsBase:</span>
<span class="gi">+        focused = has_focus(self.system_buffer)</span>
<span class="gi">+</span>
<span class="gi">+        # Emacs</span>
<span class="gi">+        emacs_bindings = KeyBindings()</span>
<span class="gi">+        handle = emacs_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;escape&quot;, filter=focused)</span>
<span class="gi">+        @handle(&quot;c-g&quot;, filter=focused)</span>
<span class="gi">+        @handle(&quot;c-c&quot;, filter=focused)</span>
<span class="gi">+        def _cancel(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Hide system prompt.&quot;</span>
<span class="gi">+            self.system_buffer.reset()</span>
<span class="gi">+            event.app.layout.focus_last()</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;enter&quot;, filter=focused)</span>
<span class="gi">+        async def _accept(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Run system command.&quot;</span>
<span class="gi">+            await event.app.run_system_command(</span>
<span class="gi">+                self.system_buffer.text,</span>
<span class="gi">+                display_before_text=self._get_display_before_text(),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.system_buffer.reset(append_to_history=True)</span>
<span class="gi">+            event.app.layout.focus_last()</span>
<span class="gi">+</span>
<span class="gi">+        # Vi.</span>
<span class="gi">+        vi_bindings = KeyBindings()</span>
<span class="gi">+        handle = vi_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;escape&quot;, filter=focused)</span>
<span class="gi">+        @handle(&quot;c-c&quot;, filter=focused)</span>
<span class="gi">+        def _cancel_vi(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Hide system prompt.&quot;</span>
<span class="gi">+            event.app.vi_state.input_mode = InputMode.NAVIGATION</span>
<span class="gi">+            self.system_buffer.reset()</span>
<span class="gi">+            event.app.layout.focus_last()</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;enter&quot;, filter=focused)</span>
<span class="gi">+        async def _accept_vi(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Run system command.&quot;</span>
<span class="gi">+            event.app.vi_state.input_mode = InputMode.NAVIGATION</span>
<span class="gi">+            await event.app.run_system_command(</span>
<span class="gi">+                self.system_buffer.text,</span>
<span class="gi">+                display_before_text=self._get_display_before_text(),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.system_buffer.reset(append_to_history=True)</span>
<span class="gi">+            event.app.layout.focus_last()</span>
<span class="gi">+</span>
<span class="gi">+        # Global bindings. (Listen to these bindings, even when this widget is</span>
<span class="gi">+        # not focussed.)</span>
<span class="gi">+        global_bindings = KeyBindings()</span>
<span class="gi">+        handle = global_bindings.add</span>
<span class="gi">+</span>
<span class="gi">+        @handle(Keys.Escape, &quot;!&quot;, filter=~focused &amp; emacs_mode, is_global=True)</span>
<span class="gi">+        def _focus_me(event: E) -&gt; None:</span>
<span class="gi">+            &quot;M-&#39;!&#39; will focus this user control.&quot;</span>
<span class="gi">+            event.app.layout.focus(self.window)</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;!&quot;, filter=~focused &amp; vi_mode &amp; vi_navigation_mode, is_global=True)</span>
<span class="gi">+        def _focus_me_vi(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Focus.&quot;</span>
<span class="gi">+            event.app.vi_state.input_mode = InputMode.INSERT</span>
<span class="gi">+            event.app.layout.focus(self.window)</span>
<span class="gi">+</span>
<span class="gi">+        return merge_key_bindings(</span>
<span class="gi">+            [</span>
<span class="gi">+                ConditionalKeyBindings(emacs_bindings, emacs_mode),</span>
<span class="gi">+                ConditionalKeyBindings(vi_bindings, vi_mode),</span>
<span class="gi">+                ConditionalKeyBindings(global_bindings, self.enable_global_bindings),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="w"> </span>class ArgToolbar:
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        def get_formatted_text() -&gt; StyleAndTextTuples:</span>
<span class="gi">+            arg = get_app().key_processor.arg or &quot;&quot;</span>
<span class="gi">+            if arg == &quot;-&quot;:</span>
<span class="gi">+                arg = &quot;-1&quot;</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+            return [</span>
<span class="gi">+                (&quot;class:arg-toolbar&quot;, &quot;Repeat: &quot;),</span>
<span class="gi">+                (&quot;class:arg-toolbar.text&quot;, arg),</span>
<span class="gi">+            ]</span>

<span class="gd">-        def get_formatted_text() -&gt;StyleAndTextTuples:</span>
<span class="gd">-            arg = get_app().key_processor.arg or &#39;&#39;</span>
<span class="gd">-            if arg == &#39;-&#39;:</span>
<span class="gd">-                arg = &#39;-1&#39;</span>
<span class="gd">-            return [(&#39;class:arg-toolbar&#39;, &#39;Repeat: &#39;), (</span>
<span class="gd">-                &#39;class:arg-toolbar.text&#39;, arg)]</span>
<span class="gd">-        self.window = Window(FormattedTextControl(get_formatted_text), height=1</span>
<span class="gd">-            )</span>
<span class="gd">-        self.container = ConditionalContainer(content=self.window, filter=</span>
<span class="gd">-            has_arg)</span>
<span class="gi">+        self.window = Window(FormattedTextControl(get_formatted_text), height=1)</span>
<span class="gi">+</span>
<span class="gi">+        self.container = ConditionalContainer(content=self.window, filter=has_arg)</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="gu">@@ -79,72 +214,161 @@ class SearchToolbar:</span>
<span class="w"> </span>    :param ignore_case: Search case insensitive.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, search_buffer: (Buffer | None)=None, vi_mode: bool=</span>
<span class="gd">-        False, text_if_not_searching: AnyFormattedText=&#39;&#39;,</span>
<span class="gd">-        forward_search_prompt: AnyFormattedText=&#39;I-search: &#39;,</span>
<span class="gd">-        backward_search_prompt: AnyFormattedText=&#39;I-search backward: &#39;,</span>
<span class="gd">-        ignore_case: FilterOrBool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        search_buffer: Buffer | None = None,</span>
<span class="gi">+        vi_mode: bool = False,</span>
<span class="gi">+        text_if_not_searching: AnyFormattedText = &quot;&quot;,</span>
<span class="gi">+        forward_search_prompt: AnyFormattedText = &quot;I-search: &quot;,</span>
<span class="gi">+        backward_search_prompt: AnyFormattedText = &quot;I-search backward: &quot;,</span>
<span class="gi">+        ignore_case: FilterOrBool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if search_buffer is None:
<span class="w"> </span>            search_buffer = Buffer()

<span class="w"> </span>        @Condition
<span class="gd">-        def is_searching() -&gt;bool:</span>
<span class="gi">+        def is_searching() -&gt; bool:</span>
<span class="w"> </span>            return self.control in get_app().layout.search_links

<span class="gd">-        def get_before_input() -&gt;AnyFormattedText:</span>
<span class="gi">+        def get_before_input() -&gt; AnyFormattedText:</span>
<span class="w"> </span>            if not is_searching():
<span class="w"> </span>                return text_if_not_searching
<span class="gd">-            elif self.control.searcher_search_state.direction == SearchDirection.BACKWARD:</span>
<span class="gd">-                return &#39;?&#39; if vi_mode else backward_search_prompt</span>
<span class="gi">+            elif (</span>
<span class="gi">+                self.control.searcher_search_state.direction == SearchDirection.BACKWARD</span>
<span class="gi">+            ):</span>
<span class="gi">+                return &quot;?&quot; if vi_mode else backward_search_prompt</span>
<span class="w"> </span>            else:
<span class="gd">-                return &#39;/&#39; if vi_mode else forward_search_prompt</span>
<span class="gi">+                return &quot;/&quot; if vi_mode else forward_search_prompt</span>
<span class="gi">+</span>
<span class="w"> </span>        self.search_buffer = search_buffer
<span class="gd">-        self.control = SearchBufferControl(buffer=search_buffer,</span>
<span class="gd">-            input_processors=[BeforeInput(get_before_input, style=</span>
<span class="gd">-            &#39;class:search-toolbar.prompt&#39;)], lexer=SimpleLexer(style=</span>
<span class="gd">-            &#39;class:search-toolbar.text&#39;), ignore_case=ignore_case)</span>
<span class="gd">-        self.container = ConditionalContainer(content=Window(self.control,</span>
<span class="gd">-            height=1, style=&#39;class:search-toolbar&#39;), filter=is_searching)</span>
<span class="gd">-</span>
<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+</span>
<span class="gi">+        self.control = SearchBufferControl(</span>
<span class="gi">+            buffer=search_buffer,</span>
<span class="gi">+            input_processors=[</span>
<span class="gi">+                BeforeInput(get_before_input, style=&quot;class:search-toolbar.prompt&quot;)</span>
<span class="gi">+            ],</span>
<span class="gi">+            lexer=SimpleLexer(style=&quot;class:search-toolbar.text&quot;),</span>
<span class="gi">+            ignore_case=ignore_case,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.container = ConditionalContainer(</span>
<span class="gi">+            content=Window(self.control, height=1, style=&quot;class:search-toolbar&quot;),</span>
<span class="gi">+            filter=is_searching,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container


<span class="w"> </span>class _CompletionsToolbarControl(UIControl):
<span class="gd">-    pass</span>
<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="gi">+        all_fragments: StyleAndTextTuples = []</span>

<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state:</span>
<span class="gi">+            completions = complete_state.completions</span>
<span class="gi">+            index = complete_state.complete_index  # Can be None!</span>

<span class="gd">-class CompletionsToolbar:</span>
<span class="gi">+            # Width of the completions without the left/right arrows in the margins.</span>
<span class="gi">+            content_width = width - 6</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.container = ConditionalContainer(content=Window(</span>
<span class="gd">-            _CompletionsToolbarControl(), height=1, style=</span>
<span class="gd">-            &#39;class:completion-toolbar&#39;), filter=has_completions)</span>
<span class="gi">+            # Booleans indicating whether we stripped from the left/right</span>
<span class="gi">+            cut_left = False</span>
<span class="gi">+            cut_right = False</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gd">-        return self.container</span>
<span class="gi">+            # Create Menu content.</span>
<span class="gi">+            fragments: StyleAndTextTuples = []</span>

<span class="gi">+            for i, c in enumerate(completions):</span>
<span class="gi">+                # When there is no more place for the next completion</span>
<span class="gi">+                if fragment_list_len(fragments) + len(c.display_text) &gt;= content_width:</span>
<span class="gi">+                    # If the current one was not yet displayed, page to the next sequence.</span>
<span class="gi">+                    if i &lt;= (index or 0):</span>
<span class="gi">+                        fragments = []</span>
<span class="gi">+                        cut_left = True</span>
<span class="gi">+                    # If the current one is visible, stop here.</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        cut_right = True</span>
<span class="gi">+                        break</span>

<span class="gd">-class ValidationToolbar:</span>
<span class="gi">+                fragments.extend(</span>
<span class="gi">+                    to_formatted_text(</span>
<span class="gi">+                        c.display_text,</span>
<span class="gi">+                        style=(</span>
<span class="gi">+                            &quot;class:completion-toolbar.completion.current&quot;</span>
<span class="gi">+                            if i == index</span>
<span class="gi">+                            else &quot;class:completion-toolbar.completion&quot;</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                fragments.append((&quot;&quot;, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+            # Extend/strip until the content width.</span>
<span class="gi">+            fragments.append((&quot;&quot;, &quot; &quot; * (content_width - fragment_list_len(fragments))))</span>
<span class="gi">+            fragments = fragments[:content_width]</span>
<span class="gi">+</span>
<span class="gi">+            # Return fragments</span>
<span class="gi">+            all_fragments.append((&quot;&quot;, &quot; &quot;))</span>
<span class="gi">+            all_fragments.append(</span>
<span class="gi">+                (&quot;class:completion-toolbar.arrow&quot;, &quot;&lt;&quot; if cut_left else &quot; &quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+            all_fragments.append((&quot;&quot;, &quot; &quot;))</span>
<span class="gi">+</span>
<span class="gi">+            all_fragments.extend(fragments)</span>
<span class="gi">+</span>
<span class="gi">+            all_fragments.append((&quot;&quot;, &quot; &quot;))</span>
<span class="gi">+            all_fragments.append(</span>
<span class="gi">+                (&quot;class:completion-toolbar.arrow&quot;, &quot;&gt;&quot; if cut_right else &quot; &quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+            all_fragments.append((&quot;&quot;, &quot; &quot;))</span>

<span class="gd">-    def __init__(self, show_position: bool=False) -&gt;None:</span>
<span class="gi">+        def get_line(i: int) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            return all_fragments</span>

<span class="gd">-        def get_formatted_text() -&gt;StyleAndTextTuples:</span>
<span class="gi">+        return UIContent(get_line=get_line, line_count=1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class CompletionsToolbar:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.container = ConditionalContainer(</span>
<span class="gi">+            content=Window(</span>
<span class="gi">+                _CompletionsToolbarControl(), height=1, style=&quot;class:completion-toolbar&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=has_completions,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="gi">+        return self.container</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ValidationToolbar:</span>
<span class="gi">+    def __init__(self, show_position: bool = False) -&gt; None:</span>
<span class="gi">+        def get_formatted_text() -&gt; StyleAndTextTuples:</span>
<span class="w"> </span>            buff = get_app().current_buffer
<span class="gi">+</span>
<span class="w"> </span>            if buff.validation_error:
<span class="gd">-                row, column = buff.document.translate_index_to_position(buff</span>
<span class="gd">-                    .validation_error.cursor_position)</span>
<span class="gi">+                row, column = buff.document.translate_index_to_position(</span>
<span class="gi">+                    buff.validation_error.cursor_position</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>                if show_position:
<span class="gd">-                    text = &#39;{} (line={} column={})&#39;.format(buff.</span>
<span class="gd">-                        validation_error.message, row + 1, column + 1)</span>
<span class="gi">+                    text = &quot;{} (line={} column={})&quot;.format(</span>
<span class="gi">+                        buff.validation_error.message,</span>
<span class="gi">+                        row + 1,</span>
<span class="gi">+                        column + 1,</span>
<span class="gi">+                    )</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    text = buff.validation_error.message
<span class="gd">-                return [(&#39;class:validation-toolbar&#39;, text)]</span>
<span class="gi">+</span>
<span class="gi">+                return [(&quot;class:validation-toolbar&quot;, text)]</span>
<span class="w"> </span>            else:
<span class="w"> </span>                return []
<span class="gi">+</span>
<span class="w"> </span>        self.control = FormattedTextControl(get_formatted_text)
<span class="gd">-        self.container = ConditionalContainer(content=Window(self.control,</span>
<span class="gd">-            height=1), filter=has_validation_error)</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+        self.container = ConditionalContainer(</span>
<span class="gi">+            content=Window(self.control, height=1), filter=has_validation_error</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container
<span class="gh">diff --git a/src/prompt_toolkit/win32_types.py b/src/prompt_toolkit/win32_types.py</span>
<span class="gh">index a86fc3bd..79283b8b 100644</span>
<span class="gd">--- a/src/prompt_toolkit/win32_types.py</span>
<span class="gi">+++ b/src/prompt_toolkit/win32_types.py</span>
<span class="gu">@@ -1,7 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from ctypes import Structure, Union, c_char, c_long, c_short, c_ulong
<span class="w"> </span>from ctypes.wintypes import BOOL, DWORD, LPVOID, WCHAR, WORD
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="gi">+# Input/Output standard device numbers. Note that these are not handle objects.</span>
<span class="gi">+# It&#39;s the `windll.kernel32.GetStdHandle` system call that turns them into a</span>
<span class="gi">+# real handle object.</span>
<span class="w"> </span>STD_INPUT_HANDLE = c_ulong(-10)
<span class="w"> </span>STD_OUTPUT_HANDLE = c_ulong(-11)
<span class="w"> </span>STD_ERROR_HANDLE = c_ulong(-12)
<span class="gu">@@ -12,27 +17,42 @@ class COORD(Structure):</span>
<span class="w"> </span>    Struct in wincon.h
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms682119(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        X: int
<span class="w"> </span>        Y: int
<span class="gd">-    _fields_ = [(&#39;X&#39;, c_short), (&#39;Y&#39;, c_short)]</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;{}(X={!r}, Y={!r}, type_x={!r}, type_y={!r})&#39;.format(self.</span>
<span class="gd">-            __class__.__name__, self.X, self.Y, type(self.X), type(self.Y))</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;X&quot;, c_short),  # Short</span>
<span class="gi">+        (&quot;Y&quot;, c_short),  # Short</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;{}(X={!r}, Y={!r}, type_x={!r}, type_y={!r})&quot;.format(</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self.X,</span>
<span class="gi">+            self.Y,</span>
<span class="gi">+            type(self.X),</span>
<span class="gi">+            type(self.Y),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class UNICODE_OR_ASCII(Union):
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        AsciiChar: bytes
<span class="w"> </span>        UnicodeChar: str
<span class="gd">-    _fields_ = [(&#39;AsciiChar&#39;, c_char), (&#39;UnicodeChar&#39;, WCHAR)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;AsciiChar&quot;, c_char),</span>
<span class="gi">+        (&quot;UnicodeChar&quot;, WCHAR),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class KEY_EVENT_RECORD(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms684166(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        KeyDown: int
<span class="w"> </span>        RepeatCount: int
<span class="gu">@@ -40,49 +60,67 @@ class KEY_EVENT_RECORD(Structure):</span>
<span class="w"> </span>        VirtualScanCode: int
<span class="w"> </span>        uChar: UNICODE_OR_ASCII
<span class="w"> </span>        ControlKeyState: int
<span class="gd">-    _fields_ = [(&#39;KeyDown&#39;, c_long), (&#39;RepeatCount&#39;, c_short), (</span>
<span class="gd">-        &#39;VirtualKeyCode&#39;, c_short), (&#39;VirtualScanCode&#39;, c_short), (&#39;uChar&#39;,</span>
<span class="gd">-        UNICODE_OR_ASCII), (&#39;ControlKeyState&#39;, c_long)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;KeyDown&quot;, c_long),  # bool</span>
<span class="gi">+        (&quot;RepeatCount&quot;, c_short),  # word</span>
<span class="gi">+        (&quot;VirtualKeyCode&quot;, c_short),  # word</span>
<span class="gi">+        (&quot;VirtualScanCode&quot;, c_short),  # word</span>
<span class="gi">+        (&quot;uChar&quot;, UNICODE_OR_ASCII),  # Unicode or ASCII.</span>
<span class="gi">+        (&quot;ControlKeyState&quot;, c_long),  # double word</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class MOUSE_EVENT_RECORD(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms684239(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        MousePosition: COORD
<span class="w"> </span>        ButtonState: int
<span class="w"> </span>        ControlKeyState: int
<span class="w"> </span>        EventFlags: int
<span class="gd">-    _fields_ = [(&#39;MousePosition&#39;, COORD), (&#39;ButtonState&#39;, c_long), (</span>
<span class="gd">-        &#39;ControlKeyState&#39;, c_long), (&#39;EventFlags&#39;, c_long)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;MousePosition&quot;, COORD),</span>
<span class="gi">+        (&quot;ButtonState&quot;, c_long),  # dword</span>
<span class="gi">+        (&quot;ControlKeyState&quot;, c_long),  # dword</span>
<span class="gi">+        (&quot;EventFlags&quot;, c_long),  # dword</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class WINDOW_BUFFER_SIZE_RECORD(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms687093(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        Size: COORD
<span class="gd">-    _fields_ = [(&#39;Size&#39;, COORD)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [(&quot;Size&quot;, COORD)]</span>


<span class="w"> </span>class MENU_EVENT_RECORD(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms684213(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        CommandId: int
<span class="gd">-    _fields_ = [(&#39;CommandId&#39;, c_long)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [(&quot;CommandId&quot;, c_long)]  # uint</span>


<span class="w"> </span>class FOCUS_EVENT_RECORD(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms683149(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        SetFocus: int
<span class="gd">-    _fields_ = [(&#39;SetFocus&#39;, c_long)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [(&quot;SetFocus&quot;, c_long)]  # bool</span>


<span class="w"> </span>class EVENT_RECORD(Union):
<span class="gu">@@ -92,65 +130,100 @@ class EVENT_RECORD(Union):</span>
<span class="w"> </span>        WindowBufferSizeEvent: WINDOW_BUFFER_SIZE_RECORD
<span class="w"> </span>        MenuEvent: MENU_EVENT_RECORD
<span class="w"> </span>        FocusEvent: FOCUS_EVENT_RECORD
<span class="gd">-    _fields_ = [(&#39;KeyEvent&#39;, KEY_EVENT_RECORD), (&#39;MouseEvent&#39;,</span>
<span class="gd">-        MOUSE_EVENT_RECORD), (&#39;WindowBufferSizeEvent&#39;,</span>
<span class="gd">-        WINDOW_BUFFER_SIZE_RECORD), (&#39;MenuEvent&#39;, MENU_EVENT_RECORD), (</span>
<span class="gd">-        &#39;FocusEvent&#39;, FOCUS_EVENT_RECORD)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;KeyEvent&quot;, KEY_EVENT_RECORD),</span>
<span class="gi">+        (&quot;MouseEvent&quot;, MOUSE_EVENT_RECORD),</span>
<span class="gi">+        (&quot;WindowBufferSizeEvent&quot;, WINDOW_BUFFER_SIZE_RECORD),</span>
<span class="gi">+        (&quot;MenuEvent&quot;, MENU_EVENT_RECORD),</span>
<span class="gi">+        (&quot;FocusEvent&quot;, FOCUS_EVENT_RECORD),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class INPUT_RECORD(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms683499(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        EventType: int
<span class="w"> </span>        Event: EVENT_RECORD
<span class="gd">-    _fields_ = [(&#39;EventType&#39;, c_short), (&#39;Event&#39;, EVENT_RECORD)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [(&quot;EventType&quot;, c_short), (&quot;Event&quot;, EVENT_RECORD)]  # word  # Union.</span>


<span class="gd">-EventTypes = {(1): &#39;KeyEvent&#39;, (2): &#39;MouseEvent&#39;, (4):</span>
<span class="gd">-    &#39;WindowBufferSizeEvent&#39;, (8): &#39;MenuEvent&#39;, (16): &#39;FocusEvent&#39;}</span>
<span class="gi">+EventTypes = {</span>
<span class="gi">+    1: &quot;KeyEvent&quot;,</span>
<span class="gi">+    2: &quot;MouseEvent&quot;,</span>
<span class="gi">+    4: &quot;WindowBufferSizeEvent&quot;,</span>
<span class="gi">+    8: &quot;MenuEvent&quot;,</span>
<span class="gi">+    16: &quot;FocusEvent&quot;,</span>
<span class="gi">+}</span>


<span class="w"> </span>class SMALL_RECT(Structure):
<span class="w"> </span>    &quot;&quot;&quot;struct in wincon.h.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        Left: int
<span class="w"> </span>        Top: int
<span class="w"> </span>        Right: int
<span class="w"> </span>        Bottom: int
<span class="gd">-    _fields_ = [(&#39;Left&#39;, c_short), (&#39;Top&#39;, c_short), (&#39;Right&#39;, c_short), (</span>
<span class="gd">-        &#39;Bottom&#39;, c_short)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;Left&quot;, c_short),</span>
<span class="gi">+        (&quot;Top&quot;, c_short),</span>
<span class="gi">+        (&quot;Right&quot;, c_short),</span>
<span class="gi">+        (&quot;Bottom&quot;, c_short),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class CONSOLE_SCREEN_BUFFER_INFO(Structure):
<span class="w"> </span>    &quot;&quot;&quot;struct in wincon.h.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        dwSize: COORD
<span class="w"> </span>        dwCursorPosition: COORD
<span class="w"> </span>        wAttributes: int
<span class="w"> </span>        srWindow: SMALL_RECT
<span class="w"> </span>        dwMaximumWindowSize: COORD
<span class="gd">-    _fields_ = [(&#39;dwSize&#39;, COORD), (&#39;dwCursorPosition&#39;, COORD), (</span>
<span class="gd">-        &#39;wAttributes&#39;, WORD), (&#39;srWindow&#39;, SMALL_RECT), (</span>
<span class="gd">-        &#39;dwMaximumWindowSize&#39;, COORD)]</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            &#39;CONSOLE_SCREEN_BUFFER_INFO({!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r})&#39;</span>
<span class="gd">-            .format(self.dwSize.Y, self.dwSize.X, self.dwCursorPosition.Y,</span>
<span class="gd">-            self.dwCursorPosition.X, self.wAttributes, self.srWindow.Top,</span>
<span class="gd">-            self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right,</span>
<span class="gd">-            self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X))</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;dwSize&quot;, COORD),</span>
<span class="gi">+        (&quot;dwCursorPosition&quot;, COORD),</span>
<span class="gi">+        (&quot;wAttributes&quot;, WORD),</span>
<span class="gi">+        (&quot;srWindow&quot;, SMALL_RECT),</span>
<span class="gi">+        (&quot;dwMaximumWindowSize&quot;, COORD),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;CONSOLE_SCREEN_BUFFER_INFO({!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r},{!r})&quot;.format(</span>
<span class="gi">+            self.dwSize.Y,</span>
<span class="gi">+            self.dwSize.X,</span>
<span class="gi">+            self.dwCursorPosition.Y,</span>
<span class="gi">+            self.dwCursorPosition.X,</span>
<span class="gi">+            self.wAttributes,</span>
<span class="gi">+            self.srWindow.Top,</span>
<span class="gi">+            self.srWindow.Left,</span>
<span class="gi">+            self.srWindow.Bottom,</span>
<span class="gi">+            self.srWindow.Right,</span>
<span class="gi">+            self.dwMaximumWindowSize.Y,</span>
<span class="gi">+            self.dwMaximumWindowSize.X,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class SECURITY_ATTRIBUTES(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="w"> </span>        nLength: int
<span class="w"> </span>        lpSecurityDescriptor: int
<span class="gd">-        bInheritHandle: int</span>
<span class="gd">-    _fields_ = [(&#39;nLength&#39;, DWORD), (&#39;lpSecurityDescriptor&#39;, LPVOID), (</span>
<span class="gd">-        &#39;bInheritHandle&#39;, BOOL)]</span>
<span class="gi">+        bInheritHandle: int  # BOOL comes back as &#39;int&#39;.</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;nLength&quot;, DWORD),</span>
<span class="gi">+        (&quot;lpSecurityDescriptor&quot;, LPVOID),</span>
<span class="gi">+        (&quot;bInheritHandle&quot;, BOOL),</span>
<span class="gi">+    ]</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>