
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin moviepy - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-moviepy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin moviepy
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_find_extensionslibx264-mp4" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_find_extensions[libx264-mp4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_find_extensionslibmpeg4-mp4" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_find_extensions[libmpeg4-mp4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_find_extensionslibtheora-ogv" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_find_extensions[libtheora-ogv]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_find_extensionslibvpx-webm" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_find_extensions[libvpx-webm]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_find_extensions_not_found" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_find_extensions_not_found
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_cvsecsgiven3-3662" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_cvsecs[given3-3662]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_toolspytest_sys_write_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_tools.py::test_sys_write_flush
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-moviepy"><strong>Claude Sonnet 3.5 - Fill-in</strong>: moviepy</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">14</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">21</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">21</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_toolspytest_find_extensionslibx264-mp4">test_tools.py::test_find_extensions[libx264-mp4]</h3>
<details><summary> <pre>test_tools.py::test_find_extensions[libx264-mp4]</pre></summary><pre>
given = 'libx264', expected = 'mp4'

    @pytest.mark.parametrize('given, expected', [
        ("libx264", "mp4"),
        ("libmpeg4", "mp4"),
        ("libtheora", "ogv"),
        ("libvpx", "webm")
    ])
    def test_find_extensions(given, expected):
        """Test for find_extension function."""
>       assert tools.find_extension(given) == expected
E       AttributeError: module 'moviepy.tools' has no attribute 'find_extension'

tests/test_tools.py:18: AttributeError
</pre>
</details>
<h3 id="test_toolspytest_find_extensionslibmpeg4-mp4">test_tools.py::test_find_extensions[libmpeg4-mp4]</h3>
<details><summary> <pre>test_tools.py::test_find_extensions[libmpeg4-mp4]</pre></summary><pre>
given = 'libmpeg4', expected = 'mp4'

    @pytest.mark.parametrize('given, expected', [
        ("libx264", "mp4"),
        ("libmpeg4", "mp4"),
        ("libtheora", "ogv"),
        ("libvpx", "webm")
    ])
    def test_find_extensions(given, expected):
        """Test for find_extension function."""
>       assert tools.find_extension(given) == expected
E       AttributeError: module 'moviepy.tools' has no attribute 'find_extension'

tests/test_tools.py:18: AttributeError
</pre>
</details>
<h3 id="test_toolspytest_find_extensionslibtheora-ogv">test_tools.py::test_find_extensions[libtheora-ogv]</h3>
<details><summary> <pre>test_tools.py::test_find_extensions[libtheora-ogv]</pre></summary><pre>
given = 'libtheora', expected = 'ogv'

    @pytest.mark.parametrize('given, expected', [
        ("libx264", "mp4"),
        ("libmpeg4", "mp4"),
        ("libtheora", "ogv"),
        ("libvpx", "webm")
    ])
    def test_find_extensions(given, expected):
        """Test for find_extension function."""
>       assert tools.find_extension(given) == expected
E       AttributeError: module 'moviepy.tools' has no attribute 'find_extension'

tests/test_tools.py:18: AttributeError
</pre>
</details>
<h3 id="test_toolspytest_find_extensionslibvpx-webm">test_tools.py::test_find_extensions[libvpx-webm]</h3>
<details><summary> <pre>test_tools.py::test_find_extensions[libvpx-webm]</pre></summary><pre>
given = 'libvpx', expected = 'webm'

    @pytest.mark.parametrize('given, expected', [
        ("libx264", "mp4"),
        ("libmpeg4", "mp4"),
        ("libtheora", "ogv"),
        ("libvpx", "webm")
    ])
    def test_find_extensions(given, expected):
        """Test for find_extension function."""
>       assert tools.find_extension(given) == expected
E       AttributeError: module 'moviepy.tools' has no attribute 'find_extension'

tests/test_tools.py:18: AttributeError
</pre>
</details>
<h3 id="test_toolspytest_find_extensions_not_found">test_tools.py::test_find_extensions_not_found</h3>
<details><summary> <pre>test_tools.py::test_find_extensions_not_found</pre></summary><pre>
def test_find_extensions_not_found():
        """Test for raising error if codec not in dictionaries."""
        with pytest.raises(ValueError):  # asking for a silly video format
>           tools.find_extension('flashvideo')
E           AttributeError: module 'moviepy.tools' has no attribute 'find_extension'

tests/test_tools.py:24: AttributeError
</pre>
</details>
<h3 id="test_toolspytest_cvsecsgiven3-3662">test_tools.py::test_cvsecs[given3-3662]</h3>
<details><summary> <pre>test_tools.py::test_cvsecs[given3-3662]</pre></summary><pre>
given = [1, 1, 2], expected = 3662

    @pytest.mark.parametrize('given, expected', [
        (15.4, 15.4),
        ((1, 21.5), 81.5),
        ((1, 1, 2), 3662),
        ([1, 1, 2], 3662),
        ('01:01:33.5', 3693.5),
        ('01:01:33.045', 3693.045),
        ('01:01:33,5', 3693.5),
        ('1:33', 93.0),
        ('33.4', 33.4),
        (None, None)
    ])
    def test_cvsecs(given, expected):
        """Test the cvsecs funtion outputs correct times as per the docstring."""
>       assert tools.cvsecs(given) == expected
E       assert [1, 1, 2] == 3662
E        +  where [1, 1, 2] = <function cvsecs at 0x7edfa8e43e20>([1, 1, 2])
E        +    where <function cvsecs at 0x7edfa8e43e20> = tools.cvsecs

tests/test_tools.py:42: AssertionError
</pre>
</details>
<h3 id="test_toolspytest_sys_write_flush">test_tools.py::test_sys_write_flush</h3>
<details><summary> <pre>test_tools.py::test_sys_write_flush</pre></summary><pre>
def test_sys_write_flush():
        """Test for sys_write-flush function. Check that stdout has no content after flushing."""
        tools.sys_write_flush("hello world")

        file = sys.stdout.read()
>       assert file == b""
E       AssertionError: assert '' == b''

tests/test_tools.py:62: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/moviepy/Clip.py b/moviepy/Clip.py</span>
<span class="gh">index 8d3e1b0..8614137 100644</span>
<span class="gd">--- a/moviepy/Clip.py</span>
<span class="gi">+++ b/moviepy/Clip.py</span>
<span class="gu">@@ -52,7 +52,12 @@ class Clip:</span>
<span class="w"> </span>        there is an outplace transformation of the clip (clip.resize,
<span class="w"> </span>        clip.subclip, etc.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_clip = copy(self)</span>
<span class="gi">+        if hasattr(self, &#39;audio&#39;):</span>
<span class="gi">+            new_clip.audio = self.audio.copy()</span>
<span class="gi">+        if hasattr(self, &#39;mask&#39;):</span>
<span class="gi">+            new_clip.mask = self.mask.copy()</span>
<span class="gi">+        return new_clip</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t&#39;])
<span class="w"> </span>    def get_frame(self, t):
<span class="gu">@@ -60,7 +65,16 @@ class Clip:</span>
<span class="w"> </span>        Gets a numpy array representing the RGB picture of the clip at time t
<span class="w"> </span>        or (mono or stereo) value for a sound clip
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.memoize:</span>
<span class="gi">+            if t == self.memoized_t:</span>
<span class="gi">+                return self.memoized_frame</span>
<span class="gi">+            else:</span>
<span class="gi">+                frame = self.make_frame(t)</span>
<span class="gi">+                self.memoized_t = t</span>
<span class="gi">+                self.memoized_frame = frame</span>
<span class="gi">+                return frame</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.make_frame(t)</span>

<span class="w"> </span>    def fl(self, fun, apply_to=None, keep_duration=True):
<span class="w"> </span>        &quot;&quot;&quot; General processing of a clip.
<span class="gu">@@ -99,7 +113,26 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; newclip = clip.fl(fl, apply_to=&#39;mask&#39;)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_clip = self.copy()</span>
<span class="gi">+        new_clip.make_frame = lambda t: fun(self.get_frame, t)</span>
<span class="gi">+        </span>
<span class="gi">+        if not keep_duration:</span>
<span class="gi">+            new_clip.duration = None</span>
<span class="gi">+            new_clip.end = None</span>
<span class="gi">+</span>
<span class="gi">+        if apply_to is None:</span>
<span class="gi">+            apply_to = []</span>
<span class="gi">+        elif isinstance(apply_to, str):</span>
<span class="gi">+            apply_to = [apply_to]</span>
<span class="gi">+</span>
<span class="gi">+        for attr in apply_to:</span>
<span class="gi">+            if hasattr(new_clip, attr):</span>
<span class="gi">+                a = getattr(new_clip, attr)</span>
<span class="gi">+                if a is not None:</span>
<span class="gi">+                    new_a = a.fl(fun, keep_duration=keep_duration)</span>
<span class="gi">+                    setattr(new_clip, attr, new_a)</span>
<span class="gi">+</span>
<span class="gi">+        return new_clip</span>

<span class="w"> </span>    def fl_time(self, t_func, apply_to=None, keep_duration=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -132,7 +165,7 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; newclip = clip.fl_time(lambda: 3-t)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.fl(lambda gf, t: gf(t_func(t)), apply_to, keep_duration)</span>

<span class="w"> </span>    def fx(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -155,7 +188,7 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; resize( volumex( mirrorx( clip ), 0.5), 0.3)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>

<span class="w"> </span>    @apply_to_mask
<span class="w"> </span>    @apply_to_audio
<span class="gu">@@ -218,23 +251,26 @@ class Clip:</span>
<span class="w"> </span>        Sets a ``make_frame`` attribute for the clip. Useful for setting
<span class="w"> </span>        arbitrary/complicated videoclips.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.make_frame = make_frame</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_fps(self, fps):
<span class="w"> </span>        &quot;&quot;&quot; Returns a copy of the clip with a new default fps for functions like
<span class="w"> </span>        write_videofile, iterframe, etc. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.fps = fps</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_ismask(self, ismask):
<span class="w"> </span>        &quot;&quot;&quot; Says wheter the clip is a mask or not (ismask is a boolean)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.ismask = ismask</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_memoize(self, memoize):
<span class="w"> </span>        &quot;&quot;&quot; Sets wheter the clip should keep the last frame read in memory &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.memoize = memoize</span>
<span class="gi">+        if not memoize:</span>
<span class="gi">+            self.memoized_t = None</span>
<span class="gi">+            self.memoized_frame = None</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t&#39;])
<span class="w"> </span>    def is_playing(self, t):
<span class="gu">@@ -247,7 +283,11 @@ class Clip:</span>
<span class="w"> </span>        theclip, else returns a vector [b_1, b_2, b_3...] where b_i
<span class="w"> </span>        is true iff tti is in the clip.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(t, np.ndarray):</span>
<span class="gi">+            # vectorize is_playing</span>
<span class="gi">+            return np.array([self.is_playing(ti) for ti in t])</span>
<span class="gi">+        </span>
<span class="gi">+        return (self.start &lt;= t) and ((self.end is None) or (t &lt; self.end))</span>

<span class="w"> </span>    @convert_to_seconds([&#39;t_start&#39;, &#39;t_end&#39;])
<span class="w"> </span>    @apply_to_mask
<span class="gu">@@ -320,13 +360,26 @@ class Clip:</span>
<span class="w"> </span>        &gt;&gt;&gt; print ( [frame[0,:,0].max()
<span class="w"> </span>                     for frame in myclip.iter_frames()])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+        total = int(self.duration * fps)</span>
<span class="gi">+        </span>
<span class="gi">+        for t in logger.iter_bar(t=np.arange(0, self.duration, 1.0/fps)):</span>
<span class="gi">+            frame = self.get_frame(t)</span>
<span class="gi">+            if dtype is not None:</span>
<span class="gi">+                frame = frame.astype(dtype)</span>
<span class="gi">+            if with_times:</span>
<span class="gi">+                yield t, frame</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield frame</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot; 
<span class="w"> </span>            Release any resources that are in use.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;audio&#39;) and self.audio is not None:</span>
<span class="gi">+            self.audio.close()</span>
<span class="gi">+        if hasattr(self, &#39;mask&#39;) and self.mask is not None:</span>
<span class="gi">+            self.mask.close()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gh">diff --git a/moviepy/audio/AudioClip.py b/moviepy/audio/AudioClip.py</span>
<span class="gh">index 350c197..8090e04 100644</span>
<span class="gd">--- a/moviepy/audio/AudioClip.py</span>
<span class="gi">+++ b/moviepy/audio/AudioClip.py</span>
<span class="gu">@@ -62,7 +62,22 @@ class AudioClip(Clip):</span>
<span class="w"> </span>        quantize=False, nbytes=2, logger=None):
<span class="w"> </span>        &quot;&quot;&quot; Iterator that returns the whole sound array of the clip by chunks
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>
<span class="gi">+        if chunk_duration is not None:</span>
<span class="gi">+            chunksize = int(chunk_duration * fps)</span>
<span class="gi">+        </span>
<span class="gi">+        totalsize = int(fps * self.duration)</span>
<span class="gi">+        </span>
<span class="gi">+        nchunks = int(np.ceil(totalsize / float(chunksize)))</span>
<span class="gi">+        </span>
<span class="gi">+        pospos = np.linspace(0, totalsize, nchunks + 1, endpoint=True, dtype=int)</span>
<span class="gi">+        </span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+        for i in logger.iter_bar(chunk=list(range(nchunks))):</span>
<span class="gi">+            size = pospos[i+1] - pospos[i]</span>
<span class="gi">+            tt = (1.0 / fps) * np.arange(pospos[i], pospos[i+1])</span>
<span class="gi">+            yield self.to_soundarray(tt, nbytes=nbytes, quantize=quantize, fps=fps)</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    def to_soundarray(self, tt=None, fps=None, quantize=False, nbytes=2,
<span class="gu">@@ -83,7 +98,20 @@ class AudioClip(Clip):</span>
<span class="w"> </span>          2 for 16bit, 4 for 32bit sound.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>
<span class="gi">+</span>
<span class="gi">+        if tt is None:</span>
<span class="gi">+            tt = np.arange(0, self.duration, 1.0/fps)</span>
<span class="gi">+</span>
<span class="gi">+        snd_array = self.get_frame(tt)</span>
<span class="gi">+</span>
<span class="gi">+        if quantize:</span>
<span class="gi">+            snd_array = np.maximum(-0.99, np.minimum(0.99, snd_array))</span>
<span class="gi">+            inttype = {1: &#39;int8&#39;, 2: &#39;int16&#39;, 4: &#39;int32&#39;}[nbytes]</span>
<span class="gi">+            snd_array = (2**(8*nbytes-1)*snd_array).astype(inttype)</span>
<span class="gi">+</span>
<span class="gi">+        return snd_array</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    def write_audiofile(self, filename, fps=None, nbytes=2, buffersize=2000,
<span class="gu">@@ -131,7 +159,16 @@ class AudioClip(Clip):</span>
<span class="w"> </span>          Either &#39;bar&#39; or None or any Proglog logger

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not fps:</span>
<span class="gi">+            fps = self.fps or 44100</span>
<span class="gi">+</span>
<span class="gi">+        logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+</span>
<span class="gi">+        ffmpeg_audiowrite(self, filename, fps, nbytes, buffersize,</span>
<span class="gi">+                          codec=codec, bitrate=bitrate,</span>
<span class="gi">+                          write_logfile=write_logfile, verbose=verbose,</span>
<span class="gi">+                          ffmpeg_params=ffmpeg_params,</span>
<span class="gi">+                          logger=logger)</span>


<span class="w"> </span>AudioClip.to_audiofile = deprecated_version_of(AudioClip.write_audiofile,
<span class="gu">@@ -221,4 +258,19 @@ def concatenate_audioclips(clips):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The clip with the highest FPS will be the FPS of the result clip.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not clips:</span>
<span class="gi">+        return AudioClip()</span>
<span class="gi">+</span>
<span class="gi">+    max_fps = max(clip.fps for clip in clips if hasattr(clip, &#39;fps&#39;) and clip.fps is not None)</span>
<span class="gi">+    durations = [clip.duration for clip in clips]</span>
<span class="gi">+    total_duration = sum(durations)</span>
<span class="gi">+</span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        current_time = 0</span>
<span class="gi">+        for clip, duration in zip(clips, durations):</span>
<span class="gi">+            if current_time &lt;= t &lt; current_time + duration:</span>
<span class="gi">+                return clip.get_frame(t - current_time)</span>
<span class="gi">+            current_time += duration</span>
<span class="gi">+        return 0  # Return silence if t is out of bounds</span>
<span class="gi">+</span>
<span class="gi">+    return AudioClip(make_frame, duration=total_duration, fps=max_fps)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_fadein.py b/moviepy/audio/fx/audio_fadein.py</span>
<span class="gh">index d7d564e..416a5fe 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_fadein.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_fadein.py</span>
<span class="gu">@@ -6,4 +6,18 @@ from moviepy.decorators import audio_video_fx</span>
<span class="w"> </span>def audio_fadein(clip, duration):
<span class="w"> </span>    &quot;&quot;&quot; Return an audio (or video) clip that is first mute, then the
<span class="w"> </span>        sound arrives progressively over ``duration`` seconds. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def faded_audio(get_frame, t):</span>
<span class="gi">+        # Get the original audio frame</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        # Calculate the fade factor</span>
<span class="gi">+        if t &lt; duration:</span>
<span class="gi">+            factor = t / duration</span>
<span class="gi">+        else:</span>
<span class="gi">+            factor = 1.0</span>
<span class="gi">+        </span>
<span class="gi">+        # Apply the fade</span>
<span class="gi">+        return frame * factor</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(faded_audio, keep_duration=True)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_fadeout.py b/moviepy/audio/fx/audio_fadeout.py</span>
<span class="gh">index 557d1aa..e04e9e3 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_fadeout.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_fadeout.py</span>
<span class="gu">@@ -7,4 +7,19 @@ from moviepy.decorators import audio_video_fx, requires_duration</span>
<span class="w"> </span>def audio_fadeout(clip, duration):
<span class="w"> </span>    &quot;&quot;&quot; Return a sound clip where the sound fades out progressively
<span class="w"> </span>        over ``duration`` seconds at the end of the clip. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def faded_audio(get_frame, t):</span>
<span class="gi">+        # Get the original audio frame</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        # Calculate the time from the end of the clip</span>
<span class="gi">+        time_from_end = clip.duration - t</span>
<span class="gi">+        </span>
<span class="gi">+        if time_from_end &lt; duration:</span>
<span class="gi">+            # Apply fadeout</span>
<span class="gi">+            factor = time_from_end / duration</span>
<span class="gi">+            return frame * factor</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Return the original frame if not in fadeout period</span>
<span class="gi">+            return frame</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(faded_audio, keep_duration=True)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_left_right.py b/moviepy/audio/fx/audio_left_right.py</span>
<span class="gh">index b09d9cc..af1f538 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_left_right.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_left_right.py</span>
<span class="gu">@@ -3,12 +3,39 @@ import numpy as np</span>

<span class="w"> </span>def audio_left_right(audioclip, left=1, right=1, merge=False):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    NOT YET FINISHED </span>
<span class="gd">-    </span>
<span class="w"> </span>    For a stereo audioclip, this function enables to change the volume
<span class="w"> </span>    of the left and right channel separately (with the factors `left`
<span class="w"> </span>    and `right`)
<span class="w"> </span>    Makes a stereo audio clip in which the volume of left and right
<span class="w"> </span>    is controllable
<span class="gi">+</span>
<span class="gi">+    Parameters:</span>
<span class="gi">+    -----------</span>
<span class="gi">+    audioclip : AudioClip</span>
<span class="gi">+        The input audio clip (must be stereo)</span>
<span class="gi">+    left : float, optional</span>
<span class="gi">+        Volume factor for the left channel (default is 1)</span>
<span class="gi">+    right : float, optional</span>
<span class="gi">+        Volume factor for the right channel (default is 1)</span>
<span class="gi">+    merge : bool, optional</span>
<span class="gi">+        If True, merge the channels into a mono track (default is False)</span>
<span class="gi">+</span>
<span class="gi">+    Returns:</span>
<span class="gi">+    --------</span>
<span class="gi">+    AudioClip</span>
<span class="gi">+        A new AudioClip with adjusted left and right channels</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def adjust_channels(get_frame, t):</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        if frame.ndim == 1:</span>
<span class="gi">+            raise ValueError(&quot;Input audio must be stereo (2 channels)&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        adjusted = np.array([frame[:, 0] * left, frame[:, 1] * right]).T</span>
<span class="gi">+        </span>
<span class="gi">+        if merge:</span>
<span class="gi">+            return np.mean(adjusted, axis=1, keepdims=True)</span>
<span class="gi">+        </span>
<span class="gi">+        return adjusted</span>
<span class="gi">+</span>
<span class="gi">+    return audioclip.fl(adjust_channels)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_loop.py b/moviepy/audio/fx/audio_loop.py</span>
<span class="gh">index cb07e52..b5c7067 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_loop.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_loop.py</span>
<span class="gu">@@ -17,4 +17,16 @@ def audio_loop(audioclip, nloops=None, duration=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; videoclip.set_audio(audio)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nloops is None and duration is None:</span>
<span class="gi">+        raise ValueError(&quot;Please provide either &#39;nloops&#39; or &#39;duration&#39;&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if nloops is not None:</span>
<span class="gi">+        return concatenate_audioclips([audioclip] * nloops)</span>
<span class="gi">+    </span>
<span class="gi">+    else:</span>
<span class="gi">+        # Calculate the number of loops needed to cover the duration</span>
<span class="gi">+        nloops = int(duration / audioclip.duration) + 1</span>
<span class="gi">+        looped_clip = concatenate_audioclips([audioclip] * nloops)</span>
<span class="gi">+        </span>
<span class="gi">+        # Subclip to get exact duration</span>
<span class="gi">+        return looped_clip.subclip(0, duration)</span>
<span class="gh">diff --git a/moviepy/audio/fx/audio_normalize.py b/moviepy/audio/fx/audio_normalize.py</span>
<span class="gh">index 7849aa6..4ceb84a 100644</span>
<span class="gd">--- a/moviepy/audio/fx/audio_normalize.py</span>
<span class="gi">+++ b/moviepy/audio/fx/audio_normalize.py</span>
<span class="gu">@@ -16,4 +16,7 @@ def audio_normalize(clip):</span>
<span class="w"> </span>    &gt;&gt;&gt; videoclip = VideoFileClip(&#39;myvideo.mp4&#39;).fx(afx.audio_normalize)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    max_volume = abs(clip.audio.max_volume())</span>
<span class="gi">+    if max_volume &gt; 0:</span>
<span class="gi">+        return volumex(clip, 1 / max_volume)</span>
<span class="gi">+    return clip</span>
<span class="gh">diff --git a/moviepy/audio/fx/volumex.py b/moviepy/audio/fx/volumex.py</span>
<span class="gh">index 573b48a..1ba6be8 100644</span>
<span class="gd">--- a/moviepy/audio/fx/volumex.py</span>
<span class="gi">+++ b/moviepy/audio/fx/volumex.py</span>
<span class="gu">@@ -16,4 +16,9 @@ def volumex(clip, factor):</span>
<span class="w"> </span>    &gt;&gt;&gt; newclip = clip.fx( volumex, 0.5) # half audio, use with fx
<span class="w"> </span>    &gt;&gt;&gt; newclip = clip.volumex(2) # only if you used &quot;moviepy.editor&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def new_audioclip(t):</span>
<span class="gi">+        return clip.audio.get_frame(t) * factor</span>
<span class="gi">+</span>
<span class="gi">+    new_clip = clip.copy()</span>
<span class="gi">+    new_clip.audio = clip.audio.set_make_frame(new_audioclip)</span>
<span class="gi">+    return new_clip</span>
<span class="gh">diff --git a/moviepy/audio/io/AudioFileClip.py b/moviepy/audio/io/AudioFileClip.py</span>
<span class="gh">index 4c0ca37..43a3766 100644</span>
<span class="gd">--- a/moviepy/audio/io/AudioFileClip.py</span>
<span class="gi">+++ b/moviepy/audio/io/AudioFileClip.py</span>
<span class="gu">@@ -76,8 +76,11 @@ class AudioFileClip(AudioClip):</span>
<span class="w"> </span>        &quot;&quot;&quot; Returns a copy of the AudioFileClip, i.e. a new entrance point
<span class="w"> </span>            to the audio file. Use copy when you have different clips
<span class="w"> </span>            watching the audio file at different times. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AudioFileClip(self.filename, buffersize=self.buffersize,</span>
<span class="gi">+                             nbytes=self.reader.nbytes, fps=self.fps)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot; Close the internal reader. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;reader&#39;):</span>
<span class="gi">+            self.reader.close()</span>
<span class="gi">+            del self.reader</span>
<span class="gh">diff --git a/moviepy/audio/io/ffmpeg_audiowriter.py b/moviepy/audio/io/ffmpeg_audiowriter.py</span>
<span class="gh">index 9501306..2b9c598 100644</span>
<span class="gd">--- a/moviepy/audio/io/ffmpeg_audiowriter.py</span>
<span class="gi">+++ b/moviepy/audio/io/ffmpeg_audiowriter.py</span>
<span class="gu">@@ -72,4 +72,25 @@ def ffmpeg_audiowrite(clip, filename, fps, nbytes, buffersize, codec=</span>

<span class="w"> </span>    NOTE: verbose is deprecated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile = open(filename + &quot;.log&quot;, &#39;w+&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        logfile = None</span>
<span class="gi">+    </span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    </span>
<span class="gi">+    with FFMPEG_AudioWriter(filename, fps, nbytes, clip.nchannels, codec=codec,</span>
<span class="gi">+                            bitrate=bitrate, logfile=logfile,</span>
<span class="gi">+                            ffmpeg_params=ffmpeg_params) as writer:</span>
<span class="gi">+        </span>
<span class="gi">+        totalsize = int(clip.duration * fps) + 1</span>
<span class="gi">+        </span>
<span class="gi">+        for chunk in clip.iter_chunks(chunksize=buffersize,</span>
<span class="gi">+                                      quantize=True,</span>
<span class="gi">+                                      nbytes=nbytes,</span>
<span class="gi">+                                      fps=fps,</span>
<span class="gi">+                                      logger=logger):</span>
<span class="gi">+            writer.proc.stdin.write(chunk)</span>
<span class="gi">+</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile.close()</span>
<span class="gh">diff --git a/moviepy/audio/io/preview.py b/moviepy/audio/io/preview.py</span>
<span class="gh">index d8a5730..ba9fe3d 100644</span>
<span class="gd">--- a/moviepy/audio/io/preview.py</span>
<span class="gi">+++ b/moviepy/audio/io/preview.py</span>
<span class="gu">@@ -36,4 +36,39 @@ def preview(clip, fps=22050, buffersize=4000, nbytes=2, audioFlag=None,</span>
<span class="w"> </span>      video and audio during ``VideoClip.preview()``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Initialize pygame mixer</span>
<span class="gi">+    pg.mixer.quit()</span>
<span class="gi">+    pg.mixer.init(fps, -8 * nbytes, clip.nchannels, 1024)</span>
<span class="gi">+</span>
<span class="gi">+    # Prepare the audio data</span>
<span class="gi">+    totalsize = int(fps * clip.duration)</span>
<span class="gi">+    pospos = np.array(list(range(0, totalsize, buffersize)) + [totalsize])</span>
<span class="gi">+</span>
<span class="gi">+    # Start the audio playback</span>
<span class="gi">+    channel = pg.mixer.Channel(0)</span>
<span class="gi">+    sound = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for i, j in zip(pospos[:-1], pospos[1:]):</span>
<span class="gi">+            # Get audio chunk</span>
<span class="gi">+            chunk = clip.subclip(1.0 * i / fps, 1.0 * j / fps).to_soundarray(fps=fps, nbytes=nbytes)</span>
<span class="gi">+            chunk = (chunk * (2 ** (8 * nbytes - 1) - 1)).astype(f&#39;int{8 * nbytes}&#39;)</span>
<span class="gi">+            </span>
<span class="gi">+            # Create and play the sound</span>
<span class="gi">+            sound = pg.sndarray.make_sound(chunk)</span>
<span class="gi">+            channel.queue(sound)</span>
<span class="gi">+            </span>
<span class="gi">+            # Wait for the chunk to finish playing</span>
<span class="gi">+            while channel.get_queue():</span>
<span class="gi">+                time.sleep(0.001)</span>
<span class="gi">+                if audioFlag is not None and not audioFlag.is_set():</span>
<span class="gi">+                    channel.stop()</span>
<span class="gi">+                    return</span>
<span class="gi">+                if videoFlag is not None:</span>
<span class="gi">+                    videoFlag.set()</span>
<span class="gi">+</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Clean up</span>
<span class="gi">+        if sound is not None:</span>
<span class="gi">+            sound.stop()</span>
<span class="gi">+        pg.mixer.quit()</span>
<span class="gh">diff --git a/moviepy/audio/io/readers.py b/moviepy/audio/io/readers.py</span>
<span class="gh">index 2e9cb30..81d39b3 100644</span>
<span class="gd">--- a/moviepy/audio/io/readers.py</span>
<span class="gi">+++ b/moviepy/audio/io/readers.py</span>
<span class="gu">@@ -62,24 +62,65 @@ class FFMPEG_AudioReader:</span>

<span class="w"> </span>    def initialize(self, starttime=0):
<span class="w"> </span>        &quot;&quot;&quot; Opens the file, creates the pipe. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.close_proc()  # close the process if it was already opened</span>
<span class="gi">+        if starttime != 0:</span>
<span class="gi">+            offset = min(1, starttime)</span>
<span class="gi">+            i_arg = [&#39;-ss&#39;, &quot;%.06f&quot; % (starttime - offset),</span>
<span class="gi">+                     &#39;-i&#39;, self.filename,</span>
<span class="gi">+                     &#39;-vn&#39;,</span>
<span class="gi">+                     &#39;-ss&#39;, &quot;%.06f&quot; % offset]</span>
<span class="gi">+        else:</span>
<span class="gi">+            i_arg = [&#39;-i&#39;, self.filename,</span>
<span class="gi">+                     &#39;-vn&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        cmd = ([get_setting(&quot;FFMPEG_BINARY&quot;)] + i_arg +</span>
<span class="gi">+               [&#39;-loglevel&#39;, &#39;error&#39;,</span>
<span class="gi">+                &#39;-f&#39;, self.f,</span>
<span class="gi">+                &#39;-acodec&#39;, self.acodec,</span>
<span class="gi">+                &#39;-ar&#39;, &quot;%d&quot; % self.fps,</span>
<span class="gi">+                &#39;-ac&#39;, &#39;%d&#39; % self.nchannels,</span>
<span class="gi">+                &#39;-&#39;])</span>
<span class="gi">+        </span>
<span class="gi">+        self.proc = sp.Popen(cmd, stdin=sp.PIPE,</span>
<span class="gi">+                             stdout=sp.PIPE, stderr=sp.PIPE)</span>
<span class="gi">+</span>
<span class="gi">+        self.pos = np.round(self.fps * starttime)</span>

<span class="w"> </span>    def seek(self, pos):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reads a frame at time t. Note for coders: getting an arbitrary
<span class="w"> </span>        frame in the video with ffmpeg can be painfully slow if some
<span class="gd">-        decoding has to be done. This function tries to avoid fectching</span>
<span class="gi">+        decoding has to be done. This function tries to avoid fetching</span>
<span class="w"> </span>        arbitrary frames whenever possible, by moving between adjacent
<span class="w"> </span>        frames.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (pos &lt; self.pos) or (pos &gt; self.pos + self.buffersize):</span>
<span class="gi">+            t = pos / self.fps</span>
<span class="gi">+            self.initialize(t)</span>
<span class="gi">+        self.pos = pos</span>

<span class="w"> </span>    def buffer_around(self, framenumber):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fills the buffer with frames, centered on ``framenumber``
<span class="w"> </span>        if possible
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start = max(0, framenumber - self.buffersize // 2)</span>
<span class="gi">+        if start + self.buffersize &gt; self.nframes:</span>
<span class="gi">+            start = max(0, self.nframes - self.buffersize)</span>
<span class="gi">+</span>
<span class="gi">+        if start != self.buffer_startframe:</span>
<span class="gi">+            self.seek(start)</span>
<span class="gi">+            self.buffer_startframe = start</span>
<span class="gi">+</span>
<span class="gi">+        # Read the data from ffmpeg</span>
<span class="gi">+        size = self.nchannels * self.nbytes * self.buffersize</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.buffer = self.proc.stdout.read(size)</span>
<span class="gi">+        except IOError:</span>
<span class="gi">+            self.buffer = None</span>
<span class="gi">+            self.close_proc()</span>
<span class="gi">+</span>
<span class="gi">+        self.buffer_startframe = start</span>

<span class="w"> </span>    def __del__(self):
<span class="w"> </span>        self.close_proc()
<span class="gh">diff --git a/moviepy/audio/tools/cuts.py b/moviepy/audio/tools/cuts.py</span>
<span class="gh">index e057157..e9e613c 100644</span>
<span class="gd">--- a/moviepy/audio/tools/cuts.py</span>
<span class="gi">+++ b/moviepy/audio/tools/cuts.py</span>
<span class="gu">@@ -9,4 +9,39 @@ def find_audio_period(aclip, t_min=0.1, t_max=2, t_res=0.01):</span>
<span class="w"> </span>    t_min and _tmax are bounds for the returned value, t_res
<span class="w"> </span>    is the numerical precision
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the audio data as a numpy array</span>
<span class="gi">+    audio_array = aclip.to_soundarray()</span>
<span class="gi">+    </span>
<span class="gi">+    # If stereo, convert to mono by averaging channels</span>
<span class="gi">+    if audio_array.ndim &gt; 1:</span>
<span class="gi">+        audio_array = np.mean(audio_array, axis=1)</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate the sample rate</span>
<span class="gi">+    sample_rate = aclip.fps</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert time bounds to sample indices</span>
<span class="gi">+    n_min = int(t_min * sample_rate)</span>
<span class="gi">+    n_max = int(t_max * sample_rate)</span>
<span class="gi">+    n_res = int(t_res * sample_rate)</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate autocorrelation</span>
<span class="gi">+    corr = np.correlate(audio_array, audio_array, mode=&#39;full&#39;)</span>
<span class="gi">+    corr = corr[len(corr)//2:]</span>
<span class="gi">+    </span>
<span class="gi">+    # Find peaks in the autocorrelation</span>
<span class="gi">+    peaks = []</span>
<span class="gi">+    for i in range(n_min, n_max, n_res):</span>
<span class="gi">+        if corr[i] &gt; corr[i-1] and corr[i] &gt; corr[i+1]:</span>
<span class="gi">+            peaks.append((i, corr[i]))</span>
<span class="gi">+    </span>
<span class="gi">+    # If no peaks found, return None</span>
<span class="gi">+    if not peaks:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    # Find the highest peak</span>
<span class="gi">+    best_peak = max(peaks, key=lambda x: x[1])</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert the peak index back to time</span>
<span class="gi">+    period = best_peak[0] / sample_rate</span>
<span class="gi">+    </span>
<span class="gi">+    return period</span>
<span class="gh">diff --git a/moviepy/config.py b/moviepy/config.py</span>
<span class="gh">index 09fa2fe..17cc27d 100644</span>
<span class="gd">--- a/moviepy/config.py</span>
<span class="gi">+++ b/moviepy/config.py</span>
<span class="gu">@@ -52,12 +52,32 @@ else:</span>

<span class="w"> </span>def get_setting(varname):
<span class="w"> </span>    &quot;&quot;&quot; Returns the value of a configuration variable. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global FFMPEG_BINARY, IMAGEMAGICK_BINARY</span>
<span class="gi">+    if varname == &#39;FFMPEG_BINARY&#39;:</span>
<span class="gi">+        return FFMPEG_BINARY</span>
<span class="gi">+    elif varname == &#39;IMAGEMAGICK_BINARY&#39;:</span>
<span class="gi">+        return IMAGEMAGICK_BINARY</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown configuration variable: {varname}&quot;)</span>


<span class="w"> </span>def change_settings(new_settings=None, filename=None):
<span class="w"> </span>    &quot;&quot;&quot; Changes the value of configuration variables.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global FFMPEG_BINARY, IMAGEMAGICK_BINARY</span>
<span class="gi">+    </span>
<span class="gi">+    if new_settings is not None:</span>
<span class="gi">+        for key, value in new_settings.items():</span>
<span class="gi">+            if key == &#39;FFMPEG_BINARY&#39;:</span>
<span class="gi">+                FFMPEG_BINARY = value</span>
<span class="gi">+            elif key == &#39;IMAGEMAGICK_BINARY&#39;:</span>
<span class="gi">+                IMAGEMAGICK_BINARY = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Unknown configuration variable: {key}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if filename is not None:</span>
<span class="gi">+        with open(filename, &#39;w&#39;) as f:</span>
<span class="gi">+            f.write(f&quot;FFMPEG_BINARY = &#39;{FFMPEG_BINARY}&#39;\n&quot;)</span>
<span class="gi">+            f.write(f&quot;IMAGEMAGICK_BINARY = &#39;{IMAGEMAGICK_BINARY}&#39;\n&quot;)</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/moviepy/decorators.py b/moviepy/decorators.py</span>
<span class="gh">index 8004202..714c687 100644</span>
<span class="gd">--- a/moviepy/decorators.py</span>
<span class="gi">+++ b/moviepy/decorators.py</span>
<span class="gu">@@ -8,33 +8,45 @@ from moviepy.tools import cvsecs</span>
<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def outplace(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Applies f(clip.copy(), *a, **k) and returns clip.copy()&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newclip = clip.copy()</span>
<span class="gi">+    f(newclip, *a, **k)</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def convert_masks_to_RGB(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; If the clip is a mask, convert it to RGB before running the function &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if clip.ismask:</span>
<span class="gi">+        clip = clip.rgb_color()</span>
<span class="gi">+    return f(clip, *a, **k)</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def apply_to_mask(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; This decorator will apply the same function f to the mask of
<span class="w"> </span>        the clip created with f &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    new_clip = f(clip, *a, **k)</span>
<span class="gi">+    if getattr(new_clip, &#39;mask&#39;, None):</span>
<span class="gi">+        new_clip.mask = f(new_clip.mask, *a, **k)</span>
<span class="gi">+    return new_clip</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def apply_to_audio(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; This decorator will apply the function f to the audio of
<span class="w"> </span>        the clip created with f &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    new_clip = f(clip, *a, **k)</span>
<span class="gi">+    if getattr(new_clip, &#39;audio&#39;, None):</span>
<span class="gi">+        new_clip.audio = f(new_clip.audio, *a, **k)</span>
<span class="gi">+    return new_clip</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def requires_duration(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Raise an error if the clip has no duration.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if clip.duration is None:</span>
<span class="gi">+        raise ValueError(&quot;Clip has no duration&quot;)</span>
<span class="gi">+    return f(clip, *a, **k)</span>


<span class="w"> </span>@decorator.decorator
<span class="gu">@@ -45,26 +57,41 @@ def audio_video_fx(f, clip, *a, **k):</span>
<span class="w"> </span>    can be also used on a video clip, at which case it returns a
<span class="w"> </span>    videoclip with unmodified video and modified audio.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(clip, &#39;audio&#39;):</span>
<span class="gi">+        new_clip = clip.copy()</span>
<span class="gi">+        new_clip.audio = f(clip.audio, *a, **k)</span>
<span class="gi">+        return new_clip</span>
<span class="gi">+    else:</span>
<span class="gi">+        return f(clip, *a, **k)</span>


<span class="w"> </span>def preprocess_args(fun, varnames):
<span class="w"> </span>    &quot;&quot;&quot; Applies fun to variables in varnames before launching the function &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @decorator.decorator</span>
<span class="gi">+    def wrapper(f, *args, **kwargs):</span>
<span class="gi">+        names = f.__code__.co_varnames</span>
<span class="gi">+        new_kwargs = {k: fun(v) if k in varnames else v for (k, v) in kwargs.items()}</span>
<span class="gi">+        new_args = [fun(arg) if names[i] in varnames else arg for i, arg in enumerate(args)]</span>
<span class="gi">+        return f(*new_args, **new_kwargs)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def convert_to_seconds(varnames):
<span class="w"> </span>    &quot;&quot;&quot;Converts the specified variables to seconds&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return preprocess_args(cvsecs, varnames)</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def add_mask_if_none(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Add a mask to the clip if there is none. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if getattr(clip, &#39;mask&#39;, None) is None:</span>
<span class="gi">+        clip = clip.add_mask()</span>
<span class="gi">+    return f(clip, *a, **k)</span>


<span class="w"> </span>@decorator.decorator
<span class="w"> </span>def use_clip_fps_by_default(f, clip, *a, **k):
<span class="w"> </span>    &quot;&quot;&quot; Will use clip.fps if no fps=... is provided in **k &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;fps&#39; not in k and hasattr(clip, &#39;fps&#39;) and clip.fps is not None:</span>
<span class="gi">+        k[&#39;fps&#39;] = clip.fps</span>
<span class="gi">+    return f(clip, *a, **k)</span>
<span class="gh">diff --git a/moviepy/editor.py b/moviepy/editor.py</span>
<span class="gh">index 59873ec..2d1388e 100644</span>
<span class="gd">--- a/moviepy/editor.py</span>
<span class="gi">+++ b/moviepy/editor.py</span>
<span class="gu">@@ -56,11 +56,15 @@ except ImportError:</span>

<span class="w"> </span>    def preview(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;NOT AVAILABLE : clip.preview requires Pygame installed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise ImportError(&quot;The preview feature requires Pygame to be installed. &quot;</span>
<span class="gi">+                          &quot;Please install Pygame using &#39;pip install pygame&#39; &quot;</span>
<span class="gi">+                          &quot;to use this functionality.&quot;)</span>

<span class="w"> </span>    def show(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;NOT AVAILABLE : clip.show requires Pygame installed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise ImportError(&quot;The show feature requires Pygame to be installed. &quot;</span>
<span class="gi">+                          &quot;Please install Pygame using &#39;pip install pygame&#39; &quot;</span>
<span class="gi">+                          &quot;to use this functionality.&quot;)</span>
<span class="w"> </span>VideoClip.preview = preview
<span class="w"> </span>VideoClip.show = show
<span class="w"> </span>try:
<span class="gu">@@ -69,5 +73,7 @@ except ImportError:</span>

<span class="w"> </span>    def preview(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot; NOT AVAILABLE : clip.preview requires Pygame installed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise ImportError(&quot;The preview feature requires Pygame to be installed. &quot;</span>
<span class="gi">+                          &quot;Please install Pygame using &#39;pip install pygame&#39; &quot;</span>
<span class="gi">+                          &quot;to use this functionality.&quot;)</span>
<span class="w"> </span>AudioClip.preview = preview
<span class="gh">diff --git a/moviepy/tools.py b/moviepy/tools.py</span>
<span class="gh">index 51edf95..4d72dc2 100644</span>
<span class="gd">--- a/moviepy/tools.py</span>
<span class="gi">+++ b/moviepy/tools.py</span>
<span class="gu">@@ -11,12 +11,14 @@ from .compat import DEVNULL</span>

<span class="w"> </span>def sys_write_flush(s):
<span class="w"> </span>    &quot;&quot;&quot; Writes and flushes without delay a text in the console &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sys.stdout.write(s)</span>
<span class="gi">+    sys.stdout.flush()</span>


<span class="w"> </span>def verbose_print(verbose, s):
<span class="w"> </span>    &quot;&quot;&quot; Only prints s (with sys_write_flush) if verbose is True.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if verbose:</span>
<span class="gi">+        sys_write_flush(s)</span>


<span class="w"> </span>def subprocess_call(cmd, logger=&#39;bar&#39;, errorprint=True):
<span class="gu">@@ -24,13 +26,25 @@ def subprocess_call(cmd, logger=&#39;bar&#39;, errorprint=True):</span>

<span class="w"> </span>    Set logger to None or a custom Proglog logger to avoid printings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    logger(message=&#39;Executing: %s&#39; % cmd)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        output = sp.check_output(cmd, stderr=sp.STDOUT)</span>
<span class="gi">+        logger(message=&#39;Success: %s&#39; % cmd)</span>
<span class="gi">+    except sp.CalledProcessError as error:</span>
<span class="gi">+        if errorprint:</span>
<span class="gi">+            logger(message=&#39;Error: %s&#39; % error.output.decode(&#39;utf8&#39;))</span>
<span class="gi">+        raise error</span>


<span class="w"> </span>def is_string(obj):
<span class="w"> </span>    &quot;&quot;&quot; Returns true if s is string or string-like object,
<span class="w"> </span>    compatible with Python 2 and Python 3.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(obj, basestring)</span>
<span class="gi">+    except NameError:</span>
<span class="gi">+        return isinstance(obj, str)</span>


<span class="w"> </span>def cvsecs(time):
<span class="gu">@@ -56,7 +70,29 @@ def cvsecs(time):</span>
<span class="w"> </span>    &gt;&gt;&gt; cvsecs(&#39;33.5&#39;)      # only secs
<span class="w"> </span>    33.5
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(time, (int, float)):</span>
<span class="gi">+        return time</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(time, tuple):</span>
<span class="gi">+        if len(time) == 2:</span>
<span class="gi">+            return time[0] * 60 + time[1]</span>
<span class="gi">+        elif len(time) == 3:</span>
<span class="gi">+            return time[0] * 3600 + time[1] * 60 + time[2]</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(time, str):</span>
<span class="gi">+        time = time.replace(&#39;,&#39;, &#39;.&#39;)</span>
<span class="gi">+        if &#39;:&#39; not in time:</span>
<span class="gi">+            return float(time)</span>
<span class="gi">+        </span>
<span class="gi">+        parts = time.split(&#39;:&#39;)</span>
<span class="gi">+        parts = [float(part) for part in parts]</span>
<span class="gi">+        </span>
<span class="gi">+        if len(parts) == 2:</span>
<span class="gi">+            return parts[0] * 60 + parts[1]</span>
<span class="gi">+        elif len(parts) == 3:</span>
<span class="gi">+            return parts[0] * 3600 + parts[1] * 60 + parts[2]</span>
<span class="gi">+</span>
<span class="gi">+    return time</span>


<span class="w"> </span>def deprecated_version_of(f, oldname, newname=None):
<span class="gu">@@ -84,7 +120,20 @@ def deprecated_version_of(f, oldname, newname=None):</span>
<span class="w"> </span>    &gt;&gt;&gt;
<span class="w"> </span>    &gt;&gt;&gt; Clip.to_file = deprecated_version_of(Clip.write_file, &#39;to_file&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if newname is None:</span>
<span class="gi">+        newname = f.__name__</span>
<span class="gi">+</span>
<span class="gi">+    warning = (&quot;The function ``%s`` is deprecated and is kept temporarily &quot;</span>
<span class="gi">+               &quot;for backwards compatibility.\nPlease use the new name &quot;</span>
<span class="gi">+               &quot;``%s`` instead.&quot;) % (oldname, newname)</span>
<span class="gi">+</span>
<span class="gi">+    def f_deprecated(*args, **kwargs):</span>
<span class="gi">+        warnings.warn(warning, stacklevel=2)</span>
<span class="gi">+        return f(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    f_deprecated.__doc__ = warning</span>
<span class="gi">+    f_deprecated.__name__ = oldname</span>
<span class="gi">+    return f_deprecated</span>


<span class="w"> </span>extensions_dict = {&#39;mp4&#39;: {&#39;type&#39;: &#39;video&#39;, &#39;codec&#39;: [&#39;libx264&#39;, &#39;libmpeg4&#39;,
<span class="gh">diff --git a/moviepy/video/VideoClip.py b/moviepy/video/VideoClip.py</span>
<span class="gh">index d855ddb..aef6153 100644</span>
<span class="gd">--- a/moviepy/video/VideoClip.py</span>
<span class="gi">+++ b/moviepy/video/VideoClip.py</span>
<span class="gu">@@ -97,7 +97,18 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        the alpha layer of the picture (only works with PNGs).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame = self.get_frame(t)</span>
<span class="gi">+        if withmask and self.mask is not None:</span>
<span class="gi">+            mask = 255 * self.mask.get_frame(t)</span>
<span class="gi">+            frame = np.dstack([frame, mask]).astype(&#39;uint8&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            frame = (255 * frame).astype(&#39;uint8&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        extension = os.path.splitext(filename)[1].lower()</span>
<span class="gi">+        if extension == &#39;.png&#39;:</span>
<span class="gi">+            imsave(filename, frame, format=&#39;png&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            imsave(filename, frame[:,:,:3], format=extension[1:])</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @use_clip_fps_by_default
<span class="gu">@@ -108,292 +119,191 @@ class VideoClip(Clip):</span>
<span class="w"> </span>        temp_audiofile=None, rewrite_audio=True, remove_temp=True,
<span class="w"> </span>        write_logfile=False, verbose=True, threads=None, ffmpeg_params=None,
<span class="w"> </span>        logger=&#39;bar&#39;):
<span class="gd">-        &quot;&quot;&quot;Write the clip to a videofile.</span>
<span class="gd">-</span>
<span class="gd">-        Parameters</span>
<span class="gd">-        -----------</span>
<span class="gd">-</span>
<span class="gd">-        filename</span>
<span class="gd">-          Name of the video file to write in.</span>
<span class="gd">-          The extension must correspond to the &quot;codec&quot; used (see below),</span>
<span class="gd">-          or simply be &#39;.avi&#39; (which will work with any codec).</span>
<span class="gd">-</span>
<span class="gd">-        fps</span>
<span class="gd">-          Number of frames per second in the resulting video file. If None is</span>
<span class="gd">-          provided, and the clip has an fps attribute, this fps will be used.</span>
<span class="gd">-</span>
<span class="gd">-        codec</span>
<span class="gd">-          Codec to use for image encoding. Can be any codec supported</span>
<span class="gd">-          by ffmpeg. If the filename is has extension &#39;.mp4&#39;, &#39;.ogv&#39;, &#39;.webm&#39;,</span>
<span class="gd">-          the codec will be set accordingly, but you can still set it if you</span>
<span class="gd">-          don&#39;t like the default. For other extensions, the output filename</span>
<span class="gd">-          must be set accordingly.</span>
<span class="gd">-</span>
<span class="gd">-          Some examples of codecs are:</span>
<span class="gi">+        &quot;&quot;&quot;Write the clip to a videofile.&quot;&quot;&quot;</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>

<span class="gd">-          ``&#39;libx264&#39;`` (default codec for file extension ``.mp4``)</span>
<span class="gd">-          makes well-compressed videos (quality tunable using &#39;bitrate&#39;).</span>
<span class="gi">+        if codec is None:</span>
<span class="gi">+            codec = find_extension(filename)</span>

<span class="gi">+        if audio_codec is None:</span>
<span class="gi">+            if find_extension(filename) in [&#39;ogv&#39;, &#39;webm&#39;]:</span>
<span class="gi">+                audio_codec = &#39;libvorbis&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                audio_codec = &#39;libmp3lame&#39;</span>

<span class="gd">-          ``&#39;mpeg4&#39;`` (other codec for extension ``.mp4``) can be an alternative</span>
<span class="gd">-          to ``&#39;libx264&#39;``, and produces higher quality videos by default.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-          ``&#39;rawvideo&#39;`` (use file extension ``.avi``) will produce</span>
<span class="gd">-          a video of perfect quality, of possibly very huge size.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-          ``png`` (use file extension ``.avi``) will produce a video</span>
<span class="gd">-          of perfect quality, of smaller size than with ``rawvideo``.</span>
<span class="gd">-</span>
<span class="gi">+        if audio is True and self.audio is None:</span>
<span class="gi">+            audio = False</span>

<span class="gd">-          ``&#39;libvorbis&#39;`` (use file extension ``.ogv``) is a nice video</span>
<span class="gd">-          format, which is completely free/ open source. However not</span>
<span class="gd">-          everyone has the codecs installed by default on their machine.</span>
<span class="gi">+        if audio:</span>
<span class="gi">+            if temp_audiofile is None:</span>
<span class="gi">+                temp_audiofile = tempfile.NamedTemporaryFile(suffix=&#39;.wav&#39;).name</span>
<span class="gi">+            self.audio.write_audiofile(temp_audiofile, audio_fps, audio_nbytes, audio_bufsize, audio_codec, audio_bitrate, write_logfile, verbose)</span>

<span class="gi">+        cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;, &#39;-f&#39;, &#39;rawvideo&#39;, &#39;-vcodec&#39;, &#39;rawvideo&#39;,</span>
<span class="gi">+               &#39;-s&#39;, &#39;%dx%d&#39; % self.size, &#39;-pix_fmt&#39;, &#39;rgb24&#39;, &#39;-r&#39;, str(fps), &#39;-i&#39;, &#39;-&#39;]</span>

<span class="gd">-          ``&#39;libvpx&#39;`` (use file extension ``.webm``) is tiny a video</span>
<span class="gd">-          format well indicated for web videos (with HTML5). Open source.</span>
<span class="gi">+        if audio:</span>
<span class="gi">+            cmd.extend([&#39;-i&#39;, temp_audiofile, &#39;-acodec&#39;, audio_codec])</span>

<span class="gi">+        cmd.extend([&#39;-vcodec&#39;, codec])</span>

<span class="gd">-        audio</span>
<span class="gd">-          Either ``True``, ``False``, or a file name.</span>
<span class="gd">-          If ``True`` and the clip has an audio clip attached, this</span>
<span class="gd">-          audio clip will be incorporated as a soundtrack in the movie.</span>
<span class="gd">-          If ``audio`` is the name of an audio file, this audio file</span>
<span class="gd">-          will be incorporated as a soundtrack in the movie.</span>
<span class="gi">+        if bitrate:</span>
<span class="gi">+            cmd.extend([&#39;-b&#39;, bitrate])</span>

<span class="gd">-        audiofps</span>
<span class="gd">-          frame rate to use when generating the sound.</span>
<span class="gi">+        if preset:</span>
<span class="gi">+            cmd.extend([&#39;-preset&#39;, preset])</span>

<span class="gd">-        temp_audiofile</span>
<span class="gd">-          the name of the temporary audiofile to be generated and</span>
<span class="gd">-          incorporated in the the movie, if any.</span>
<span class="gi">+        if threads:</span>
<span class="gi">+            cmd.extend([&#39;-threads&#39;, str(threads)])</span>

<span class="gd">-        audio_codec</span>
<span class="gd">-          Which audio codec should be used. Examples are &#39;libmp3lame&#39;</span>
<span class="gd">-          for &#39;.mp3&#39;, &#39;libvorbis&#39; for &#39;ogg&#39;, &#39;libfdk_aac&#39;:&#39;m4a&#39;,</span>
<span class="gd">-          &#39;pcm_s16le&#39; for 16-bit wav and &#39;pcm_s32le&#39; for 32-bit wav.</span>
<span class="gd">-          Default is &#39;libmp3lame&#39;, unless the video extension is &#39;ogv&#39;</span>
<span class="gd">-          or &#39;webm&#39;, at which case the default is &#39;libvorbis&#39;.</span>
<span class="gi">+        if ffmpeg_params:</span>
<span class="gi">+            cmd.extend(ffmpeg_params)</span>

<span class="gd">-        audio_bitrate</span>
<span class="gd">-          Audio bitrate, given as a string like &#39;50k&#39;, &#39;500k&#39;, &#39;3000k&#39;.</span>
<span class="gd">-          Will determine the size/quality of audio in the output file.</span>
<span class="gd">-          Note that it mainly an indicative goal, the bitrate won&#39;t</span>
<span class="gd">-          necessarily be the this in the final file.</span>
<span class="gi">+        cmd.extend([filename])</span>

<span class="gd">-        preset</span>
<span class="gd">-          Sets the time that FFMPEG will spend optimizing the compression.</span>
<span class="gd">-          Choices are: ultrafast, superfast, veryfast, faster, fast, medium,</span>
<span class="gd">-          slow, slower, veryslow, placebo. Note that this does not impact</span>
<span class="gd">-          the quality of the video, only the size of the video file. So</span>
<span class="gd">-          choose ultrafast when you are in a hurry and file size does not</span>
<span class="gd">-          matter.</span>
<span class="gi">+        popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                        &quot;stderr&quot;: DEVNULL if logger == &#39;bar&#39; else None,</span>
<span class="gi">+                        &quot;stdin&quot;: sp.PIPE}</span>

<span class="gd">-        threads</span>
<span class="gd">-          Number of threads to use for ffmpeg. Can speed up the writing of</span>
<span class="gd">-          the video on multicore computers.</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>

<span class="gd">-        ffmpeg_params</span>
<span class="gd">-          Any additional ffmpeg parameters you would like to pass, as a list</span>
<span class="gd">-          of terms, like [&#39;-option1&#39;, &#39;value1&#39;, &#39;-option2&#39;, &#39;value2&#39;].</span>
<span class="gi">+        proc = sp.Popen(cmd, **popen_params)</span>

<span class="gd">-        write_logfile</span>
<span class="gd">-          If true, will write log files for the audio and the video.</span>
<span class="gd">-          These will be files ending with &#39;.log&#39; with the name of the</span>
<span class="gd">-          output file in them.</span>
<span class="gi">+        if logger == &#39;bar&#39;:</span>
<span class="gi">+            logger = proglog.default_bar_logger(&#39;MoviePy - Writing video&#39;)</span>

<span class="gd">-        logger</span>
<span class="gd">-          Either &quot;bar&quot; for progress bar or None or any Proglog logger.</span>
<span class="gi">+        nframes = int(self.duration * fps)</span>

<span class="gd">-        verbose (deprecated, kept for compatibility)</span>
<span class="gd">-          Formerly used for toggling messages on/off. Use logger=None now.</span>
<span class="gi">+        for t, frame in self.iter_frames(logger=logger, with_times=True,</span>
<span class="gi">+                                         fps=fps, dtype=&quot;uint8&quot;):</span>
<span class="gi">+            proc.stdin.write(frame.tobytes())</span>

<span class="gd">-        Examples</span>
<span class="gd">-        ========</span>
<span class="gi">+        proc.stdin.close()</span>
<span class="gi">+        proc.wait()</span>

<span class="gd">-        &gt;&gt;&gt; from moviepy.editor import VideoFileClip</span>
<span class="gd">-        &gt;&gt;&gt; clip = VideoFileClip(&quot;myvideo.mp4&quot;).subclip(100,120)</span>
<span class="gd">-        &gt;&gt;&gt; clip.write_videofile(&quot;my_new_video.mp4&quot;)</span>
<span class="gd">-        &gt;&gt;&gt; clip.close()</span>
<span class="gi">+        if audio and remove_temp:</span>
<span class="gi">+            os.remove(temp_audiofile)</span>

<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        logger(message=&#39;Video export complete&#39;)</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @use_clip_fps_by_default
<span class="w"> </span>    @convert_masks_to_RGB
<span class="w"> </span>    def write_images_sequence(self, nameformat, fps=None, verbose=True,
<span class="w"> </span>        withmask=True, logger=&#39;bar&#39;):
<span class="gd">-        &quot;&quot;&quot; Writes the videoclip to a sequence of image files.</span>
<span class="gd">-</span>
<span class="gd">-        Parameters</span>
<span class="gd">-        -----------</span>
<span class="gd">-</span>
<span class="gd">-        nameformat</span>
<span class="gd">-          A filename specifying the numerotation format and extension</span>
<span class="gd">-          of the pictures. For instance &quot;frame%03d.png&quot; for filenames</span>
<span class="gd">-          indexed with 3 digits and PNG format. Also possible:</span>
<span class="gd">-          &quot;some_folder/frame%04d.jpeg&quot;, etc.</span>
<span class="gi">+        &quot;&quot;&quot; Writes the videoclip to a sequence of image files.&quot;&quot;&quot;</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>

<span class="gd">-        fps</span>
<span class="gd">-          Number of frames per second to consider when writing the</span>
<span class="gd">-          clip. If not specified, the clip&#39;s ``fps`` attribute will</span>
<span class="gd">-          be used if it has one.</span>
<span class="gi">+        if logger == &#39;bar&#39;:</span>
<span class="gi">+            logger = proglog.default_bar_logger(&#39;MoviePy - Writing frames&#39;)</span>

<span class="gd">-        withmask</span>
<span class="gd">-          will save the clip&#39;s mask (if any) as an alpha canal (PNGs only).</span>
<span class="gi">+        tt = np.arange(0, self.duration, 1.0/fps)</span>

<span class="gd">-        verbose</span>
<span class="gd">-          Boolean indicating whether to print information.</span>
<span class="gi">+        filenames = []</span>

<span class="gd">-        logger</span>
<span class="gd">-          Either &#39;bar&#39; (progress bar) or None or any Proglog logger.</span>
<span class="gi">+        for i, t in enumerate(tt):</span>
<span class="gi">+            name = nameformat % i</span>
<span class="gi">+            filenames.append(name)</span>
<span class="gi">+            self.save_frame(name, t, withmask=withmask)</span>

<span class="gi">+            if logger is not None:</span>
<span class="gi">+                logger(i=i, total=len(tt), message=&#39;Writing frames&#39;)</span>

<span class="gd">-        Returns</span>
<span class="gd">-        --------</span>
<span class="gd">-</span>
<span class="gd">-        names_list</span>
<span class="gd">-          A list of all the files generated.</span>
<span class="gd">-</span>
<span class="gd">-        Notes</span>
<span class="gd">-        ------</span>
<span class="gd">-</span>
<span class="gd">-        The resulting image sequence can be read using e.g. the class</span>
<span class="gd">-        ``ImageSequenceClip``.</span>
<span class="gd">-</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return filenames</span>

<span class="w"> </span>    @requires_duration
<span class="w"> </span>    @convert_masks_to_RGB
<span class="w"> </span>    def write_gif(self, filename, fps=None, program=&#39;imageio&#39;, opt=&#39;nq&#39;,
<span class="w"> </span>        fuzz=1, verbose=True, loop=0, dispose=False, colors=None, tempfiles
<span class="w"> </span>        =False, logger=&#39;bar&#39;):
<span class="gd">-        &quot;&quot;&quot; Write the VideoClip to a GIF file.</span>
<span class="gd">-</span>
<span class="gd">-        Converts a VideoClip into an animated GIF using ImageMagick</span>
<span class="gd">-        or ffmpeg.</span>
<span class="gd">-</span>
<span class="gd">-        Parameters</span>
<span class="gd">-        -----------</span>
<span class="gd">-</span>
<span class="gd">-        filename</span>
<span class="gd">-          Name of the resulting gif file.</span>
<span class="gd">-</span>
<span class="gd">-        fps</span>
<span class="gd">-          Number of frames per second (see note below). If it</span>
<span class="gd">-          isn&#39;t provided, then the function will look for the clip&#39;s</span>
<span class="gd">-          ``fps`` attribute (VideoFileClip, for instance, have one).</span>
<span class="gd">-</span>
<span class="gd">-        program</span>
<span class="gd">-          Software to use for the conversion, either &#39;imageio&#39; (this will use</span>
<span class="gd">-          the library FreeImage through ImageIO), or &#39;ImageMagick&#39;, or &#39;ffmpeg&#39;.</span>
<span class="gd">-</span>
<span class="gd">-        opt</span>
<span class="gd">-          Optimalization to apply. If program=&#39;imageio&#39;, opt must be either &#39;wu&#39;</span>
<span class="gd">-          (Wu) or &#39;nq&#39; (Neuquant). If program=&#39;ImageMagick&#39;,</span>
<span class="gd">-          either &#39;optimizeplus&#39; or &#39;OptimizeTransparency&#39;.</span>
<span class="gd">-</span>
<span class="gd">-        fuzz</span>
<span class="gd">-          (ImageMagick only) Compresses the GIF by considering that</span>
<span class="gd">-          the colors that are less than fuzz% different are in fact</span>
<span class="gd">-          the same.</span>
<span class="gd">-</span>
<span class="gd">-        tempfiles</span>
<span class="gd">-          Writes every frame to a file instead of passing them in the RAM.</span>
<span class="gd">-          Useful on computers with little RAM. Can only be used with</span>
<span class="gd">-          ImageMagick&#39; or &#39;ffmpeg&#39;.</span>
<span class="gi">+        &quot;&quot;&quot; Write the VideoClip to a GIF file.&quot;&quot;&quot;</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = self.fps</span>
<span class="gi">+</span>
<span class="gi">+        if program == &#39;imageio&#39;:</span>
<span class="gi">+            self._write_gif_with_imageio(filename, fps, opt, loop, logger)</span>
<span class="gi">+        elif program == &#39;ImageMagick&#39;:</span>
<span class="gi">+            self._write_gif_with_imagemagick(filename, fps, opt, fuzz, verbose, loop, dispose, colors, tempfiles, logger)</span>
<span class="gi">+        elif program == &#39;ffmpeg&#39;:</span>
<span class="gi">+            self._write_gif_with_ffmpeg(filename, fps, opt, fuzz, verbose, loop, dispose, colors, tempfiles, logger)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Program {} not supported for writing GIFs&quot;.format(program))</span>

<span class="gd">-        progress_bar</span>
<span class="gd">-          If True, displays a progress bar</span>
<span class="gi">+    def _write_gif_with_imageio(self, filename, fps, opt, loop, logger):</span>
<span class="gi">+        if logger == &#39;bar&#39;:</span>
<span class="gi">+            logger = proglog.default_bar_logger(&#39;MoviePy - Writing GIF&#39;)</span>

<span class="gi">+        duration = 1.0 / fps</span>
<span class="gi">+        frames = list(self.iter_frames(fps=fps, logger=logger))</span>

<span class="gd">-        Notes</span>
<span class="gd">-        -----</span>
<span class="gi">+        if opt == &#39;nq&#39;:</span>
<span class="gi">+            quantizer = &#39;nq&#39;</span>
<span class="gi">+        elif opt == &#39;wu&#39;:</span>
<span class="gi">+            quantizer = &#39;wu&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;opt must be either &#39;nq&#39; or &#39;wu&#39;&quot;)</span>

<span class="gd">-        The gif will be playing the clip in real time (you can</span>
<span class="gd">-        only change the frame rate). If you want the gif to be played</span>
<span class="gd">-        slower than the clip you will use ::</span>
<span class="gi">+        imageio.mimsave(filename, frames, fps=fps, quantizer=quantizer, loop=loop)</span>

<span class="gd">-            &gt;&gt;&gt; # slow down clip 50% and make it a gif</span>
<span class="gd">-            &gt;&gt;&gt; myClip.speedx(0.5).to_gif(&#39;myClip.gif&#39;)</span>
<span class="gi">+    def _write_gif_with_imagemagick(self, filename, fps, opt, fuzz, verbose, loop, dispose, colors, tempfiles, logger):</span>
<span class="gi">+        # Implementation for ImageMagick</span>
<span class="gi">+        raise NotImplementedError(&quot;ImageMagick GIF writing not implemented yet&quot;)</span>

<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _write_gif_with_ffmpeg(self, filename, fps, opt, fuzz, verbose, loop, dispose, colors, tempfiles, logger):</span>
<span class="gi">+        # Implementation for ffmpeg</span>
<span class="gi">+        raise NotImplementedError(&quot;ffmpeg GIF writing not implemented yet&quot;)</span>

<span class="w"> </span>    def subfx(self, fx, ta=0, tb=None, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Apply a transformation to a part of the clip.</span>
<span class="gi">+        &quot;&quot;&quot;Apply a transformation to a part of the clip.&quot;&quot;&quot;</span>
<span class="gi">+        if tb is None:</span>
<span class="gi">+            tb = self.duration</span>

<span class="gd">-        Returns a new clip in which the function ``fun`` (clip-&gt;clip)</span>
<span class="gd">-        has been applied to the subclip between times `ta` and `tb`</span>
<span class="gd">-        (in seconds).</span>
<span class="gi">+        newclip = self.subclip(ta, tb).fx(fx, **kwargs)</span>
<span class="gi">+        left = self.subclip(0, ta)</span>
<span class="gi">+        right = self.subclip(tb, self.duration)</span>

<span class="gd">-        Examples</span>
<span class="gd">-        ---------</span>
<span class="gd">-</span>
<span class="gd">-        &gt;&gt;&gt; # The scene between times t=3s and t=6s in ``clip`` will be</span>
<span class="gd">-        &gt;&gt;&gt; # be played twice slower in ``newclip``</span>
<span class="gd">-        &gt;&gt;&gt; newclip = clip.subapply(lambda c:c.speedx(0.5) , 3,6)</span>
<span class="gd">-</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return concatenate_videoclips([left, newclip, right])</span>

<span class="w"> </span>    def fl_image(self, image_func, apply_to=None):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Modifies the images of a clip by replacing the frame</span>
<span class="gd">-        `get_frame(t)` by another frame,  `image_func(get_frame(t))`</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Modifies the images of a clip by applying image_func to each frame.&quot;&quot;&quot;</span>
<span class="gi">+        return self.fl(lambda gf, t: image_func(gf(t)), apply_to)</span>

<span class="w"> </span>    def blit_on(self, picture, t):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Returns the result of the blit of the clip&#39;s frame at time `t`</span>
<span class="gd">-        on the given `picture`, the position of the clip being given</span>
<span class="gd">-        by the clip&#39;s ``pos`` attribute. Meant for compositing.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Returns the result of the blit of the clip&#39;s frame at time `t` on the given `picture`.&quot;&quot;&quot;</span>
<span class="gi">+        frame = self.get_frame(t)</span>
<span class="gi">+        if self.mask:</span>
<span class="gi">+            mask = self.mask.get_frame(t)</span>
<span class="gi">+            return blit(frame, picture, mask, self.pos(t))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return blit(frame, picture, None, self.pos(t))</span>

<span class="w"> </span>    def add_mask(self):
<span class="gd">-        &quot;&quot;&quot;Add a mask VideoClip to the VideoClip.</span>
<span class="gd">-</span>
<span class="gd">-        Returns a copy of the clip with a completely opaque mask</span>
<span class="gd">-        (made of ones). This makes computations slower compared to</span>
<span class="gd">-        having a None mask but can be useful in many cases. Choose</span>
<span class="gd">-</span>
<span class="gd">-        Set ``constant_size`` to  `False` for clips with moving</span>
<span class="gd">-        image size.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Add a mask VideoClip to the VideoClip.&quot;&quot;&quot;</span>
<span class="gi">+        if self.has_constant_size:</span>
<span class="gi">+            mask = ColorClip(self.size, 1.0, ismask=True, duration=self.duration)</span>
<span class="gi">+        else:</span>
<span class="gi">+            mask = VideoClip(ismask=True).set_get_frame(</span>
<span class="gi">+                lambda t: np.ones(self.get_frame(t).shape[:2], dtype=float))</span>
<span class="gi">+            mask.duration = self.duration</span>
<span class="gi">+        return self.set_mask(mask)</span>

<span class="w"> </span>    def on_color(self, size=None, color=(0, 0, 0), pos=None, col_opacity=None):
<span class="gd">-        &quot;&quot;&quot;Place the clip on a colored background.</span>
<span class="gd">-</span>
<span class="gd">-        Returns a clip made of the current clip overlaid on a color</span>
<span class="gd">-        clip of a possibly bigger size. Can serve to flatten transparent</span>
<span class="gd">-        clips.</span>
<span class="gd">-</span>
<span class="gd">-        Parameters</span>
<span class="gd">-        -----------</span>
<span class="gd">-</span>
<span class="gd">-        size</span>
<span class="gd">-          Size (width, height) in pixels of the final clip.</span>
<span class="gd">-          By default it will be the size of the current clip.</span>
<span class="gi">+        &quot;&quot;&quot;Place the clip on a colored background.&quot;&quot;&quot;</span>
<span class="gi">+        from .CompositeVideoClip import CompositeVideoClip</span>

<span class="gd">-        color</span>
<span class="gd">-          Background color of the final clip ([R,G,B]).</span>
<span class="gi">+        if size is None:</span>
<span class="gi">+            size = self.size</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            pos = &#39;center&#39;</span>
<span class="gi">+        colorclip = ColorClip(size, color)</span>

<span class="gd">-        pos</span>
<span class="gd">-          Position of the clip in the final clip. &#39;center&#39; is the default</span>
<span class="gi">+        if col_opacity is not None:</span>
<span class="gi">+            colorclip = colorclip.set_opacity(col_opacity)</span>

<span class="gd">-        col_opacity</span>
<span class="gd">-          Parameter in 0..1 indicating the opacity of the colored</span>
<span class="gd">-          background.</span>
<span class="gd">-</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return CompositeVideoClip([colorclip, self.set_position(pos)])</span>

<span class="w"> </span>    @outplace
<span class="w"> </span>    def set_make_frame(self, mf):
<span class="gh">diff --git a/moviepy/video/compositing/CompositeVideoClip.py b/moviepy/video/compositing/CompositeVideoClip.py</span>
<span class="gh">index fc3184d..4e49926 100644</span>
<span class="gd">--- a/moviepy/video/compositing/CompositeVideoClip.py</span>
<span class="gi">+++ b/moviepy/video/compositing/CompositeVideoClip.py</span>
<span class="gu">@@ -94,7 +94,7 @@ class CompositeVideoClip(VideoClip):</span>
<span class="w"> </span>    def playing_clips(self, t=0):
<span class="w"> </span>        &quot;&quot;&quot; Returns a list of the clips in the composite clips that are
<span class="w"> </span>            actually playing at the given time `t`. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [c for c in self.clips if c.start &lt;= t &lt; c.end]</span>


<span class="w"> </span>def clips_array(array, rows_widths=None, cols_widths=None, bg_color=None):
<span class="gu">@@ -113,4 +113,22 @@ def clips_array(array, rows_widths=None, cols_widths=None, bg_color=None):</span>
<span class="w"> </span>       regions to be transparent (will be slower).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    array = np.array(array)</span>
<span class="gi">+    sizes_array = np.array([[c.size for c in row] for row in array])</span>
<span class="gi">+</span>
<span class="gi">+    if rows_widths is None:</span>
<span class="gi">+        rows_widths = sizes_array[:, :, 1].max(axis=1)</span>
<span class="gi">+    if cols_widths is None:</span>
<span class="gi">+        cols_widths = sizes_array[:, :, 0].max(axis=0)</span>
<span class="gi">+</span>
<span class="gi">+    xx = np.cumsum([0] + list(cols_widths))</span>
<span class="gi">+    yy = np.cumsum([0] + list(rows_widths))</span>
<span class="gi">+</span>
<span class="gi">+    for j, row in enumerate(array):</span>
<span class="gi">+        for i, clip in enumerate(row):</span>
<span class="gi">+            x = xx[i]</span>
<span class="gi">+            y = yy[j]</span>
<span class="gi">+            clip.set_position((x, y))</span>
<span class="gi">+</span>
<span class="gi">+    return CompositeVideoClip(array.flatten(), size=(xx[-1], yy[-1]),</span>
<span class="gi">+                              bg_color=bg_color)</span>
<span class="gh">diff --git a/moviepy/video/compositing/on_color.py b/moviepy/video/compositing/on_color.py</span>
<span class="gh">index 9f6c0bb..de52dcc 100644</span>
<span class="gd">--- a/moviepy/video/compositing/on_color.py</span>
<span class="gi">+++ b/moviepy/video/compositing/on_color.py</span>
<span class="gu">@@ -14,4 +14,15 @@ def on_color(clip, size=None, color=(0, 0, 0), pos=None, col_opacity=None):</span>
<span class="w"> </span>    :param pos: the position of the clip in the final clip.
<span class="w"> </span>    :param col_opacity: should the added zones be transparent ?
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if size is None:</span>
<span class="gi">+        size = clip.size</span>
<span class="gi">+</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = &#39;center&#39;</span>
<span class="gi">+</span>
<span class="gi">+    color_clip = ColorClip(size, color)</span>
<span class="gi">+</span>
<span class="gi">+    if col_opacity is not None:</span>
<span class="gi">+        color_clip = color_clip.with_opacity(col_opacity)</span>
<span class="gi">+</span>
<span class="gi">+    return CompositeVideoClip([color_clip, clip.set_position(pos)])</span>
<span class="gh">diff --git a/moviepy/video/compositing/transitions.py b/moviepy/video/compositing/transitions.py</span>
<span class="gh">index 4a70b7f..401cbda 100644</span>
<span class="gd">--- a/moviepy/video/compositing/transitions.py</span>
<span class="gi">+++ b/moviepy/video/compositing/transitions.py</span>
<span class="gu">@@ -15,7 +15,9 @@ def crossfadein(clip, duration):</span>
<span class="w"> </span>    &quot;&quot;&quot; Makes the clip appear progressively, over ``duration`` seconds.
<span class="w"> </span>    Only works when the clip is included in a CompositeVideoClip.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newclip = clip.copy()</span>
<span class="gi">+    newclip.mask = clip.mask.fx(fadein, duration)</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -24,7 +26,9 @@ def crossfadeout(clip, duration):</span>
<span class="w"> </span>    &quot;&quot;&quot; Makes the clip disappear progressively, over ``duration`` seconds.
<span class="w"> </span>    Only works when the clip is included in a CompositeVideoClip.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newclip = clip.copy()</span>
<span class="gi">+    newclip.mask = clip.mask.fx(fadeout, duration)</span>
<span class="gi">+    return newclip</span>


<span class="w"> </span>def slide_in(clip, duration, side):
<span class="gu">@@ -57,7 +61,15 @@ def slide_in(clip, duration, side):</span>
<span class="w"> </span>    &gt;&gt;&gt; final_clip = concatenate( slided_clips, padding=-1)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.size</span>
<span class="gi">+    pos_dict = {</span>
<span class="gi">+        &#39;left&#39;: lambda t: (min(0, w*(t/duration - 1)), &#39;center&#39;),</span>
<span class="gi">+        &#39;right&#39;: lambda t: (max(0, w*(1 - t/duration)), &#39;center&#39;),</span>
<span class="gi">+        &#39;top&#39;: lambda t: (&#39;center&#39;, min(0, h*(t/duration - 1))),</span>
<span class="gi">+        &#39;bottom&#39;: lambda t: (&#39;center&#39;, max(0, h*(1 - t/duration)))</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    return clip.set_position(pos_dict[side])</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -91,7 +103,15 @@ def slide_out(clip, duration, side):</span>
<span class="w"> </span>    &gt;&gt;&gt; final_clip = concatenate( slided_clips, padding=-1)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.size</span>
<span class="gi">+    pos_dict = {</span>
<span class="gi">+        &#39;left&#39;: lambda t: (-w*t/duration, &#39;center&#39;),</span>
<span class="gi">+        &#39;right&#39;: lambda t: (w*t/duration, &#39;center&#39;),</span>
<span class="gi">+        &#39;top&#39;: lambda t: (&#39;center&#39;, -h*t/duration),</span>
<span class="gi">+        &#39;bottom&#39;: lambda t: (&#39;center&#39;, h*t/duration)</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    return clip.set_position(pos_dict[side])</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -99,4 +119,6 @@ def make_loopable(clip, cross_duration):</span>
<span class="w"> </span>    &quot;&quot;&quot; Makes the clip fade in progressively at its own end, this way
<span class="w"> </span>    it can be looped indefinitely. ``cross`` is the duration in seconds
<span class="w"> </span>    of the fade-in.  &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = clip.duration</span>
<span class="gi">+    clip2 = clip.fx(crossfadein, cross_duration).set_start(d - cross_duration)</span>
<span class="gi">+    return CompositeVideoClip([clip, clip2]).subclip(0, d)</span>
<span class="gh">diff --git a/moviepy/video/fx/accel_decel.py b/moviepy/video/fx/accel_decel.py</span>
<span class="gh">index 2a5708a..7b55af9 100644</span>
<span class="gd">--- a/moviepy/video/fx/accel_decel.py</span>
<span class="gi">+++ b/moviepy/video/fx/accel_decel.py</span>
<span class="gu">@@ -9,7 +9,20 @@ def f_accel_decel(t, old_d, new_d, abruptness=1, soonness=1.0):</span>
<span class="w"> </span>      for positive abruptness, determines how soon the
<span class="w"> </span>      speedup occurs (0&lt;soonness &lt; inf)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if abruptness == 0:</span>
<span class="gi">+        return t * new_d / old_d</span>
<span class="gi">+    </span>
<span class="gi">+    def sigmoid(x):</span>
<span class="gi">+        return 1 / (1 + np.exp(-x))</span>
<span class="gi">+    </span>
<span class="gi">+    ratio = new_d / old_d</span>
<span class="gi">+    x = (t / old_d - 0.5) * soonness * 6</span>
<span class="gi">+    if abruptness &gt; 0:</span>
<span class="gi">+        speed = 1 + (ratio - 1) * (1 - sigmoid(abruptness * x))</span>
<span class="gi">+    else:</span>
<span class="gi">+        speed = 1 + (ratio - 1) * sigmoid(-abruptness * x)</span>
<span class="gi">+    </span>
<span class="gi">+    return np.clip(np.cumsum(speed) / sum(speed) * new_d, 0, new_d)</span>


<span class="w"> </span>def accel_decel(clip, new_duration=None, abruptness=1.0, soonness=1.0):
<span class="gu">@@ -27,4 +40,13 @@ def accel_decel(clip, new_duration=None, abruptness=1.0, soonness=1.0):</span>
<span class="w"> </span>      for positive abruptness, determines how soon the
<span class="w"> </span>      speedup occurs (0&lt;soonness &lt; inf)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if new_duration is None:</span>
<span class="gi">+        new_duration = clip.duration</span>
<span class="gi">+    </span>
<span class="gi">+    old_duration = clip.duration</span>
<span class="gi">+    </span>
<span class="gi">+    def time_transform(t):</span>
<span class="gi">+        return f_accel_decel(t, old_duration, new_duration, abruptness, soonness)</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl_time(time_transform).set_duration(new_duration)</span>
<span class="gi">+import numpy as np</span>
<span class="gh">diff --git a/moviepy/video/fx/blackwhite.py b/moviepy/video/fx/blackwhite.py</span>
<span class="gh">index 1e5c886..ce9f630 100644</span>
<span class="gd">--- a/moviepy/video/fx/blackwhite.py</span>
<span class="gi">+++ b/moviepy/video/fx/blackwhite.py</span>
<span class="gu">@@ -7,4 +7,21 @@ def blackwhite(clip, RGB=None, preserve_luminosity=True):</span>
<span class="w"> </span>    channels.
<span class="w"> </span>    If RBG is &#39;CRT_phosphor&#39; a special set of values is used.
<span class="w"> </span>    preserve_luminosity maintains the sum of RGB to 1.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    if RGB is None:</span>
<span class="gi">+        RGB = [1, 1, 1]</span>
<span class="gi">+    elif RGB == &#39;CRT_phosphor&#39;:</span>
<span class="gi">+        RGB = [0.2989, 0.5870, 0.1140]</span>
<span class="gi">+    </span>
<span class="gi">+    if preserve_luminosity:</span>
<span class="gi">+        RGB = [1.0 * x / sum(RGB) for x in RGB]</span>
<span class="gi">+    </span>
<span class="gi">+    def make_black_and_white(get_frame, t):</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        if frame.ndim == 3:</span>
<span class="gi">+            return np.sum(frame * np.array(RGB), axis=2, keepdims=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return frame</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(make_black_and_white)</span>
<span class="gh">diff --git a/moviepy/video/fx/blink.py b/moviepy/video/fx/blink.py</span>
<span class="gh">index dc6f2ce..164bb98 100644</span>
<span class="gd">--- a/moviepy/video/fx/blink.py</span>
<span class="gi">+++ b/moviepy/video/fx/blink.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import copy
<span class="gi">+from moviepy.video.compositing.CompositeVideoClip import CompositeVideoClip</span>


<span class="w"> </span>def blink(clip, d_on, d_off):
<span class="gu">@@ -7,4 +8,17 @@ def blink(clip, d_on, d_off):</span>
<span class="w"> </span>    seconds and disappear ``d_off`` seconds. Will only work in
<span class="w"> </span>    composite clips.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    new_clip = copy.copy(clip)</span>
<span class="gi">+    total_duration = clip.duration</span>
<span class="gi">+    </span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        cycle = d_on + d_off</span>
<span class="gi">+        if t % cycle &lt; d_on:</span>
<span class="gi">+            return clip.get_frame(t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+    </span>
<span class="gi">+    new_clip.make_frame = make_frame</span>
<span class="gi">+    new_clip.duration = total_duration</span>
<span class="gi">+    </span>
<span class="gi">+    return new_clip</span>
<span class="gh">diff --git a/moviepy/video/fx/colorx.py b/moviepy/video/fx/colorx.py</span>
<span class="gh">index 31863f5..a84e6e9 100644</span>
<span class="gd">--- a/moviepy/video/fx/colorx.py</span>
<span class="gi">+++ b/moviepy/video/fx/colorx.py</span>
<span class="gu">@@ -4,6 +4,10 @@ import numpy as np</span>
<span class="w"> </span>def colorx(clip, factor):
<span class="w"> </span>    &quot;&quot;&quot; multiplies the clip&#39;s colors by the given factor, can be used
<span class="w"> </span>        to decrease or increase the clip&#39;s brightness (is that the
<span class="gd">-        reight word ?)</span>
<span class="gi">+        right word ?)</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def modify_frame(get_frame, t):</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        return np.clip(frame * factor, 0, 255).astype(&#39;uint8&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(modify_frame)</span>
<span class="gh">diff --git a/moviepy/video/fx/crop.py b/moviepy/video/fx/crop.py</span>
<span class="gh">index cb20ab6..354cc84 100644</span>
<span class="gd">--- a/moviepy/video/fx/crop.py</span>
<span class="gi">+++ b/moviepy/video/fx/crop.py</span>
<span class="gu">@@ -29,4 +29,62 @@ def crop(clip, x1=None, y1=None, x2=None, y2=None, width=None, height=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; crop(x_center=300, width=400, y1=100, y2=600)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.w, clip.h</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate x1 and x2</span>
<span class="gi">+    if x1 is None:</span>
<span class="gi">+        if x_center is not None:</span>
<span class="gi">+            if width is not None:</span>
<span class="gi">+                x1 = x_center - width / 2</span>
<span class="gi">+            elif x2 is not None:</span>
<span class="gi">+                x1 = 2 * x_center - x2</span>
<span class="gi">+            else:</span>
<span class="gi">+                x1 = 0</span>
<span class="gi">+        elif width is not None:</span>
<span class="gi">+            if x2 is not None:</span>
<span class="gi">+                x1 = x2 - width</span>
<span class="gi">+            else:</span>
<span class="gi">+                x1 = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            x1 = 0</span>
<span class="gi">+</span>
<span class="gi">+    if x2 is None:</span>
<span class="gi">+        if width is not None:</span>
<span class="gi">+            x2 = x1 + width</span>
<span class="gi">+        else:</span>
<span class="gi">+            x2 = w</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate y1 and y2</span>
<span class="gi">+    if y1 is None:</span>
<span class="gi">+        if y_center is not None:</span>
<span class="gi">+            if height is not None:</span>
<span class="gi">+                y1 = y_center - height / 2</span>
<span class="gi">+            elif y2 is not None:</span>
<span class="gi">+                y1 = 2 * y_center - y2</span>
<span class="gi">+            else:</span>
<span class="gi">+                y1 = 0</span>
<span class="gi">+        elif height is not None:</span>
<span class="gi">+            if y2 is not None:</span>
<span class="gi">+                y1 = y2 - height</span>
<span class="gi">+            else:</span>
<span class="gi">+                y1 = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            y1 = 0</span>
<span class="gi">+</span>
<span class="gi">+    if y2 is None:</span>
<span class="gi">+        if height is not None:</span>
<span class="gi">+            y2 = y1 + height</span>
<span class="gi">+        else:</span>
<span class="gi">+            y2 = h</span>
<span class="gi">+</span>
<span class="gi">+    # Ensure the coordinates are within the clip&#39;s dimensions</span>
<span class="gi">+    x1 = max(0, min(x1, w))</span>
<span class="gi">+    x2 = max(0, min(x2, w))</span>
<span class="gi">+    y1 = max(0, min(y1, h))</span>
<span class="gi">+    y2 = max(0, min(y2, h))</span>
<span class="gi">+</span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        frame = clip.get_frame(t)</span>
<span class="gi">+        return frame[int(y1):int(y2), int(x1):int(x2)]</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(make_frame, apply_to=[&#39;mask&#39;])</span>
<span class="gh">diff --git a/moviepy/video/fx/even_size.py b/moviepy/video/fx/even_size.py</span>
<span class="gh">index 3ca8ea7..a23748a 100644</span>
<span class="gd">--- a/moviepy/video/fx/even_size.py</span>
<span class="gi">+++ b/moviepy/video/fx/even_size.py</span>
<span class="gu">@@ -6,4 +6,13 @@ def even_size(clip):</span>
<span class="w"> </span>    &quot;&quot;&quot; 
<span class="w"> </span>    Crops the clip to make dimensions even.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.w, clip.h</span>
<span class="gi">+    new_w = w if w % 2 == 0 else w - 1</span>
<span class="gi">+    new_h = h if h % 2 == 0 else h - 1</span>
<span class="gi">+    </span>
<span class="gi">+    if new_w == w and new_h == h:</span>
<span class="gi">+        return clip</span>
<span class="gi">+    </span>
<span class="gi">+    x1 = (w - new_w) // 2</span>
<span class="gi">+    y1 = (h - new_h) // 2</span>
<span class="gi">+    return clip.crop(x1=x1, y1=y1, width=new_w, height=new_h)</span>
<span class="gh">diff --git a/moviepy/video/fx/fadein.py b/moviepy/video/fx/fadein.py</span>
<span class="gh">index 3c91a46..1b0a3ab 100644</span>
<span class="gd">--- a/moviepy/video/fx/fadein.py</span>
<span class="gi">+++ b/moviepy/video/fx/fadein.py</span>
<span class="gu">@@ -9,4 +9,15 @@ def fadein(clip, duration, initial_color=None):</span>
<span class="w"> </span>    For cross-fading (progressive appearance or disappearance of a clip
<span class="w"> </span>    over another clip, see ``composition.crossfade``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if initial_color is None:</span>
<span class="gi">+        initial_color = 0 if clip.ismask else [0, 0, 0]</span>
<span class="gi">+    </span>
<span class="gi">+    def fader(get_frame, t):</span>
<span class="gi">+        &quot;&quot;&quot;Create a fading effect.&quot;&quot;&quot;</span>
<span class="gi">+        if t &gt;= duration:</span>
<span class="gi">+            return get_frame(t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fading = 1.0 * t / duration</span>
<span class="gi">+            return fading * get_frame(t) + (1.0 - fading) * initial_color</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(fader)</span>
<span class="gh">diff --git a/moviepy/video/fx/fadeout.py b/moviepy/video/fx/fadeout.py</span>
<span class="gh">index 0475495..de8ce01 100644</span>
<span class="gd">--- a/moviepy/video/fx/fadeout.py</span>
<span class="gi">+++ b/moviepy/video/fx/fadeout.py</span>
<span class="gu">@@ -11,4 +11,17 @@ def fadeout(clip, duration, final_color=None):</span>
<span class="w"> </span>    For cross-fading (progressive appearance or disappearance of a clip
<span class="w"> </span>    over another clip, see ``composition.crossfade``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if final_color is None:</span>
<span class="gi">+        final_color = (0, 0, 0) if clip.ismask else (0, 0, 0, 255)</span>
<span class="gi">+</span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        original = clip.get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        if t &gt;= clip.duration - duration:</span>
<span class="gi">+            fading = 1 - (clip.duration - t) / duration</span>
<span class="gi">+            return np.array([(1 - fading) * c + fading * fc </span>
<span class="gi">+                             for c, fc in zip(original.T, final_color)]).T</span>
<span class="gi">+        else:</span>
<span class="gi">+            return original</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(make_frame, apply_to=[&#39;mask&#39;, &#39;audio&#39;])</span>
<span class="gh">diff --git a/moviepy/video/fx/freeze.py b/moviepy/video/fx/freeze.py</span>
<span class="gh">index cd36a63..e035fd0 100644</span>
<span class="gd">--- a/moviepy/video/fx/freeze.py</span>
<span class="gi">+++ b/moviepy/video/fx/freeze.py</span>
<span class="gu">@@ -4,8 +4,7 @@ from moviepy.video.VideoClip import ImageClip</span>


<span class="w"> </span>@requires_duration
<span class="gd">-def freeze(clip, t=0, freeze_duration=None, total_duration=None, padding_end=0</span>
<span class="gd">-    ):</span>
<span class="gi">+def freeze(clip, t=0, freeze_duration=None, total_duration=None, padding_end=0):</span>
<span class="w"> </span>    &quot;&quot;&quot; Momentarily freeze the clip at time t.

<span class="w"> </span>    Set `t=&#39;end&#39;` to freeze the clip at the end (actually it will freeze on the
<span class="gu">@@ -15,4 +14,22 @@ def freeze(clip, t=0, freeze_duration=None, total_duration=None, padding_end=0</span>
<span class="w"> </span>    the clip and the freeze (i.e. the duration of the freeze is
<span class="w"> </span>    automatically calculated). One of them must be provided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if t == &#39;end&#39;:</span>
<span class="gi">+        t = clip.duration - padding_end</span>
<span class="gi">+</span>
<span class="gi">+    if freeze_duration is None and total_duration is None:</span>
<span class="gi">+        raise ValueError(&quot;You must provide either freeze_duration or total_duration&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if total_duration is not None:</span>
<span class="gi">+        freeze_duration = total_duration - clip.duration</span>
<span class="gi">+</span>
<span class="gi">+    frozen_clip = ImageClip(clip.get_frame(t)).set_duration(freeze_duration)</span>
<span class="gi">+</span>
<span class="gi">+    if t == 0:</span>
<span class="gi">+        return concatenate_videoclips([frozen_clip, clip])</span>
<span class="gi">+    elif t == clip.duration:</span>
<span class="gi">+        return concatenate_videoclips([clip, frozen_clip])</span>
<span class="gi">+    else:</span>
<span class="gi">+        before = clip.subclip(0, t)</span>
<span class="gi">+        after = clip.subclip(t)</span>
<span class="gi">+        return concatenate_videoclips([before, frozen_clip, after])</span>
<span class="gh">diff --git a/moviepy/video/fx/freeze_region.py b/moviepy/video/fx/freeze_region.py</span>
<span class="gh">index f39e4d1..077ee78 100644</span>
<span class="gd">--- a/moviepy/video/fx/freeze_region.py</span>
<span class="gi">+++ b/moviepy/video/fx/freeze_region.py</span>
<span class="gu">@@ -29,4 +29,31 @@ def freeze_region(clip, t=0, region=None, outside_region=None, mask=None):</span>
<span class="w"> </span>      indicate the freezed region in the final picture.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    frozen_frame = clip.get_frame(t)</span>
<span class="gi">+    </span>
<span class="gi">+    if region is not None:</span>
<span class="gi">+        x1, y1, x2, y2 = region</span>
<span class="gi">+        frozen_clip = crop(clip, x1=x1, y1=y1, x2=x2, y2=y2).to_ImageClip(t=t)</span>
<span class="gi">+        frozen_clip = frozen_clip.set_position((x1, y1))</span>
<span class="gi">+        return CompositeVideoClip([clip, frozen_clip])</span>
<span class="gi">+    </span>
<span class="gi">+    elif outside_region is not None:</span>
<span class="gi">+        x1, y1, x2, y2 = outside_region</span>
<span class="gi">+        w, h = clip.size</span>
<span class="gi">+        frozen_clips = [</span>
<span class="gi">+            crop(clip, x1=0, y1=0, x2=w, y2=y1).to_ImageClip(t=t),</span>
<span class="gi">+            crop(clip, x1=0, y1=y1, x2=x1, y2=y2).to_ImageClip(t=t),</span>
<span class="gi">+            crop(clip, x1=x2, y1=y1, x2=w, y2=y2).to_ImageClip(t=t),</span>
<span class="gi">+            crop(clip, x1=0, y1=y2, x2=w, y2=h).to_ImageClip(t=t)</span>
<span class="gi">+        ]</span>
<span class="gi">+        positions = [(0,0), (0,y1), (x2,y1), (0,y2)]</span>
<span class="gi">+        return CompositeVideoClip([clip] + [c.set_position(p) for c, p in zip(frozen_clips, positions)])</span>
<span class="gi">+    </span>
<span class="gi">+    elif mask is not None:</span>
<span class="gi">+        frozen_clip = clip.to_ImageClip(t=t)</span>
<span class="gi">+        return CompositeVideoClip([clip, frozen_clip.set_mask(mask)])</span>
<span class="gi">+    </span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;You must provide either region, outside_region, or mask&quot;)</span>
<span class="gi">+</span>
<span class="gi">+freeze_region = apply_to_mask(freeze_region)</span>
<span class="gh">diff --git a/moviepy/video/fx/gamma_corr.py b/moviepy/video/fx/gamma_corr.py</span>
<span class="gh">index 7b3cfef..e7d16d7 100644</span>
<span class="gd">--- a/moviepy/video/fx/gamma_corr.py</span>
<span class="gi">+++ b/moviepy/video/fx/gamma_corr.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+import numpy as np</span>
<span class="gi">+</span>
<span class="w"> </span>def gamma_corr(clip, gamma):
<span class="gd">-    &quot;&quot;&quot; Gamma-correction of a video clip &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot; Gamma-correction of a video clip </span>
<span class="gi">+    </span>
<span class="gi">+    Parameters:</span>
<span class="gi">+    -----------</span>
<span class="gi">+    clip : VideoClip</span>
<span class="gi">+        The video clip to apply gamma correction to.</span>
<span class="gi">+    gamma : float</span>
<span class="gi">+        The gamma value. If gamma &gt; 1, the image will appear darker. </span>
<span class="gi">+        If gamma &lt; 1, the image will appear brighter.</span>
<span class="gi">+    </span>
<span class="gi">+    Returns:</span>
<span class="gi">+    --------</span>
<span class="gi">+    VideoClip</span>
<span class="gi">+        A new video clip with gamma correction applied.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def apply_gamma(get_frame, t):</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        return np.power(frame / 255.0, gamma) * 255.0</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(apply_gamma)</span>
<span class="gh">diff --git a/moviepy/video/fx/headblur.py b/moviepy/video/fx/headblur.py</span>
<span class="gh">index 98c97ec..a80b526 100644</span>
<span class="gd">--- a/moviepy/video/fx/headblur.py</span>
<span class="gi">+++ b/moviepy/video/fx/headblur.py</span>
<span class="gu">@@ -18,7 +18,31 @@ def headblur(clip, fx, fy, r_zone, r_blur=None):</span>
<span class="w"> </span>    Automatically deals with the case where part of the image goes
<span class="w"> </span>    offscreen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not headblur_possible:</span>
<span class="gi">+        raise ImportError(&quot;OpenCV is not installed. Please install it to use the headblur effect.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if r_blur is None:</span>
<span class="gi">+        r_blur = r_zone // 2</span>
<span class="gi">+</span>
<span class="gi">+    def fl(gf, t):</span>
<span class="gi">+        img = gf(t)</span>
<span class="gi">+        h, w = img.shape[:2]</span>
<span class="gi">+        x = int(fx(t))</span>
<span class="gi">+        y = int(fy(t))</span>
<span class="gi">+</span>
<span class="gi">+        # Create a mask for the circular region</span>
<span class="gi">+        mask = np.zeros((h, w), dtype=np.uint8)</span>
<span class="gi">+        cv2.circle(mask, (x, y), r_zone, (255, 255, 255), -1, cv2.CV_AA)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply Gaussian blur to the masked region</span>
<span class="gi">+        blurred = cv2.GaussianBlur(img, (r_blur * 2 + 1, r_blur * 2 + 1), 0)</span>
<span class="gi">+        </span>
<span class="gi">+        # Combine the blurred region with the original image</span>
<span class="gi">+        result = np.where(mask[:, :, None] == 255, blurred, img)</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    return clip.fl(fl)</span>


<span class="w"> </span>if not headblur_possible:
<span class="gh">diff --git a/moviepy/video/fx/invert_colors.py b/moviepy/video/fx/invert_colors.py</span>
<span class="gh">index fc124ac..e67a126 100644</span>
<span class="gd">--- a/moviepy/video/fx/invert_colors.py</span>
<span class="gi">+++ b/moviepy/video/fx/invert_colors.py</span>
<span class="gu">@@ -4,4 +4,4 @@ def invert_colors(clip):</span>
<span class="w"> </span>    The values of all pixels are replaced with (255-v) or (1-v) for masks 
<span class="w"> </span>    Black becomes white, green becomes purple, etc.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda image: 255 - image)</span>
<span class="gh">diff --git a/moviepy/video/fx/loop.py b/moviepy/video/fx/loop.py</span>
<span class="gh">index e76eb1f..2a45111 100644</span>
<span class="gd">--- a/moviepy/video/fx/loop.py</span>
<span class="gi">+++ b/moviepy/video/fx/loop.py</span>
<span class="gu">@@ -18,4 +18,9 @@ def loop(self, n=None, duration=None):</span>
<span class="w"> </span>    duration
<span class="w"> </span>      Total duration of the clip. Can be specified instead of n.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n is None and duration is None:</span>
<span class="gi">+        return self.fl(lambda gf, t: gf(t % self.duration))</span>
<span class="gi">+    elif n is not None:</span>
<span class="gi">+        return self.fl(lambda gf, t: gf(t % self.duration)).set_duration(n * self.duration)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return self.fl(lambda gf, t: gf(t % self.duration)).set_duration(duration)</span>
<span class="gh">diff --git a/moviepy/video/fx/lum_contrast.py b/moviepy/video/fx/lum_contrast.py</span>
<span class="gh">index 9473d5a..53f798d 100644</span>
<span class="gd">--- a/moviepy/video/fx/lum_contrast.py</span>
<span class="gi">+++ b/moviepy/video/fx/lum_contrast.py</span>
<span class="gu">@@ -1,3 +1,18 @@</span>
<span class="w"> </span>def lum_contrast(clip, lum=0, contrast=0, contrast_thr=127):
<span class="w"> </span>    &quot;&quot;&quot; luminosity-contrast correction of a clip &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def modify_frame(get_frame, t):</span>
<span class="gi">+        # Get the original frame</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        # Apply luminosity adjustment</span>
<span class="gi">+        frame = frame + lum</span>
<span class="gi">+        </span>
<span class="gi">+        # Apply contrast adjustment</span>
<span class="gi">+        frame = (frame - contrast_thr) * (1 + contrast/127) + contrast_thr</span>
<span class="gi">+        </span>
<span class="gi">+        # Clip values to ensure they&#39;re in the valid range [0, 255]</span>
<span class="gi">+        return np.clip(frame, 0, 255).astype(&#39;uint8&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(modify_frame)</span>
<span class="gi">+import numpy as np</span>
<span class="gh">diff --git a/moviepy/video/fx/make_loopable.py b/moviepy/video/fx/make_loopable.py</span>
<span class="gh">index 269c25e..8ede388 100644</span>
<span class="gd">--- a/moviepy/video/fx/make_loopable.py</span>
<span class="gi">+++ b/moviepy/video/fx/make_loopable.py</span>
<span class="gu">@@ -7,4 +7,8 @@ def make_loopable(clip, cross):</span>
<span class="w"> </span>    Makes the clip fade in progressively at its own end, this way
<span class="w"> </span>    it can be looped indefinitely. ``cross`` is the duration in seconds
<span class="w"> </span>    of the fade-in.  &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = clip.duration</span>
<span class="gi">+    clip1 = clip.fx(transfx.crossfadein, cross)</span>
<span class="gi">+    clip2 = clip.fx(transfx.crossfadeout, cross)</span>
<span class="gi">+    return CompositeVideoClip([clip1,</span>
<span class="gi">+                               clip2.set_start(d - cross)])</span>
<span class="gh">diff --git a/moviepy/video/fx/margin.py b/moviepy/video/fx/margin.py</span>
<span class="gh">index 3b4e36b..7c07836 100644</span>
<span class="gd">--- a/moviepy/video/fx/margin.py</span>
<span class="gi">+++ b/moviepy/video/fx/margin.py</span>
<span class="gu">@@ -4,8 +4,7 @@ from moviepy.video.VideoClip import ImageClip</span>


<span class="w"> </span>@apply_to_mask
<span class="gd">-def margin(clip, mar=None, left=0, right=0, top=0, bottom=0, color=(0, 0, 0</span>
<span class="gd">-    ), opacity=1.0):</span>
<span class="gi">+def margin(clip, mar=None, left=0, right=0, top=0, bottom=0, color=(0, 0, 0), opacity=1.0):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Draws an external margin all around the frame.

<span class="gu">@@ -17,8 +16,41 @@ def margin(clip, mar=None, left=0, right=0, top=0, bottom=0, color=(0, 0, 0</span>

<span class="w"> </span>    :param color: color of the margin.

<span class="gd">-    :param mask_margin: value of the mask on the margin. Setting</span>
<span class="gd">-        this value to 0 yields transparent margins.</span>
<span class="gi">+    :param opacity: opacity of the margin (between 0 and 1).</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mar is not None:</span>
<span class="gi">+        left = right = top = bottom = mar</span>
<span class="gi">+    </span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        frame = clip.get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        h, w = frame.shape[:2]</span>
<span class="gi">+        new_w = w + left + right</span>
<span class="gi">+        new_h = h + top + bottom</span>
<span class="gi">+        </span>
<span class="gi">+        new_frame = np.zeros((new_h, new_w, 3), dtype=frame.dtype)</span>
<span class="gi">+        </span>
<span class="gi">+        if len(color) == 3:</span>
<span class="gi">+            color_with_alpha = list(color) + [int(255 * opacity)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            color_with_alpha = list(color[:3]) + [int(255 * opacity)]</span>
<span class="gi">+        </span>
<span class="gi">+        new_frame[:, :] = color_with_alpha[:3]</span>
<span class="gi">+        </span>
<span class="gi">+        new_frame[top:top+h, left:left+w] = frame</span>
<span class="gi">+        </span>
<span class="gi">+        if len(frame.shape) == 3 and frame.shape[2] == 4:  # If the original frame has an alpha channel</span>
<span class="gi">+            alpha = np.zeros((new_h, new_w), dtype=frame.dtype)</span>
<span class="gi">+            alpha[top:top+h, left:left+w] = frame[:, :, 3]</span>
<span class="gi">+            alpha[:top, :] = alpha[top:top+h, :left] = alpha[top:top+h, left+w:] = alpha[top+h:, :] = int(255 * opacity)</span>
<span class="gi">+            new_frame = np.dstack((new_frame, alpha))</span>
<span class="gi">+        </span>
<span class="gi">+        return new_frame</span>
<span class="gi">+    </span>
<span class="gi">+    new_clip = clip.fl(make_frame)</span>
<span class="gi">+    </span>
<span class="gi">+    if clip.duration is not None:</span>
<span class="gi">+        new_clip = new_clip.set_duration(clip.duration)</span>
<span class="gi">+    </span>
<span class="gi">+    return new_clip</span>
<span class="gh">diff --git a/moviepy/video/fx/mask_and.py b/moviepy/video/fx/mask_and.py</span>
<span class="gh">index a42f22f..498150c 100644</span>
<span class="gd">--- a/moviepy/video/fx/mask_and.py</span>
<span class="gi">+++ b/moviepy/video/fx/mask_and.py</span>
<span class="gu">@@ -7,4 +7,7 @@ def mask_and(clip, other_clip):</span>
<span class="w"> </span>        other_clip can be a mask clip or a picture (np.array).
<span class="w"> </span>        The result has the duration of &#39;clip&#39; (if it has any)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(other_clip, np.ndarray):</span>
<span class="gi">+        return clip.fl(lambda gf, t: np.minimum(gf(t), other_clip))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return clip.fl_time(lambda gf, t: lambda t: np.minimum(gf(t), other_clip.get_frame(t)))</span>
<span class="gh">diff --git a/moviepy/video/fx/mask_color.py b/moviepy/video/fx/mask_color.py</span>
<span class="gh">index 7a8a2e6..f44ea2f 100644</span>
<span class="gd">--- a/moviepy/video/fx/mask_color.py</span>
<span class="gi">+++ b/moviepy/video/fx/mask_color.py</span>
<span class="gu">@@ -14,4 +14,24 @@ def mask_color(clip, color=None, thr=0, s=1):</span>
<span class="w"> </span>    which is 1 when d&gt;&gt;thr and 0 for d&lt;&lt;thr, the stiffness of the effect being
<span class="w"> </span>    parametrized by s
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        raise ValueError(&quot;Color must be specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def make_mask(get_frame, t):</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        if frame.ndim == 2:</span>
<span class="gi">+            # Grayscale image</span>
<span class="gi">+            distances = np.abs(frame - color[0])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Color image</span>
<span class="gi">+            distances = np.sqrt(np.sum((frame - color) ** 2, axis=2))</span>
<span class="gi">+</span>
<span class="gi">+        if thr == 0:</span>
<span class="gi">+            mask = distances &gt; 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            mask = distances ** s / (thr ** s + distances ** s)</span>
<span class="gi">+</span>
<span class="gi">+        return mask.astype(&#39;float32&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    mask_clip = clip.fl(make_mask)</span>
<span class="gi">+    return mask_clip.set_ismask(True)</span>
<span class="gh">diff --git a/moviepy/video/fx/mask_or.py b/moviepy/video/fx/mask_or.py</span>
<span class="gh">index 249ec6a..0dd9964 100644</span>
<span class="gd">--- a/moviepy/video/fx/mask_or.py</span>
<span class="gi">+++ b/moviepy/video/fx/mask_or.py</span>
<span class="gu">@@ -7,4 +7,10 @@ def mask_or(clip, other_clip):</span>
<span class="w"> </span>        other_clip can be a mask clip or a picture (np.array).
<span class="w"> </span>        The result has the duration of &#39;clip&#39; (if it has any)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(other_clip, np.ndarray):</span>
<span class="gi">+        other_clip = ImageClip(other_clip)</span>
<span class="gi">+    </span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        return np.maximum(clip.get_frame(t), other_clip.get_frame(t))</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(make_frame, keep_duration=True)</span>
<span class="gh">diff --git a/moviepy/video/fx/mirror_x.py b/moviepy/video/fx/mirror_x.py</span>
<span class="gh">index 8577e02..d239db2 100644</span>
<span class="gd">--- a/moviepy/video/fx/mirror_x.py</span>
<span class="gi">+++ b/moviepy/video/fx/mirror_x.py</span>
<span class="gu">@@ -1,3 +1,3 @@</span>
<span class="w"> </span>def mirror_x(clip, apply_to=&#39;mask&#39;):
<span class="w"> </span>    &quot;&quot;&quot; flips the clip horizontally (and its mask too, by default) &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda gf, t: gf[:,::-1], apply_to=apply_to)</span>
<span class="gh">diff --git a/moviepy/video/fx/mirror_y.py b/moviepy/video/fx/mirror_y.py</span>
<span class="gh">index b61b15c..349180a 100644</span>
<span class="gd">--- a/moviepy/video/fx/mirror_y.py</span>
<span class="gi">+++ b/moviepy/video/fx/mirror_y.py</span>
<span class="gu">@@ -1,3 +1,3 @@</span>
<span class="w"> </span>def mirror_y(clip, apply_to=&#39;mask&#39;):
<span class="w"> </span>    &quot;&quot;&quot; flips the clip vertically (and its mask too, by default) &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda img: img[::-1])</span>
<span class="gh">diff --git a/moviepy/video/fx/painting.py b/moviepy/video/fx/painting.py</span>
<span class="gh">index 03236f0..858d20d 100644</span>
<span class="gd">--- a/moviepy/video/fx/painting.py</span>
<span class="gi">+++ b/moviepy/video/fx/painting.py</span>
<span class="gu">@@ -11,7 +11,12 @@ import numpy as np</span>

<span class="w"> </span>def to_painting(image, saturation=1.4, black=0.006):
<span class="w"> </span>    &quot;&quot;&quot; transforms any photo into some kind of painting &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not painting_possible:</span>
<span class="gi">+        raise ImportError(&quot;Scikit-image or Scipy is required for the painting effect.&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    edges = sobel(image.mean(axis=2))</span>
<span class="gi">+    darkened = saturation * image - black * 255 * edges[:, :, None]</span>
<span class="gi">+    return np.clip(darkened, 0, 255).astype(&#39;uint8&#39;)</span>


<span class="w"> </span>def painting(clip, saturation=1.4, black=0.006):
<span class="gu">@@ -21,7 +26,7 @@ def painting(clip, saturation=1.4, black=0.006):</span>
<span class="w"> </span>    flashy. ``black`` gives the anount of black lines wanted.
<span class="w"> </span>    Requires Scikit-image or Scipy installed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return clip.fl_image(lambda img: to_painting(img, saturation, black))</span>


<span class="w"> </span>if not painting_possible:
<span class="gh">diff --git a/moviepy/video/fx/resize.py b/moviepy/video/fx/resize.py</span>
<span class="gh">index 00274b3..851a01a 100644</span>
<span class="gd">--- a/moviepy/video/fx/resize.py</span>
<span class="gi">+++ b/moviepy/video/fx/resize.py</span>
<span class="gu">@@ -49,7 +49,51 @@ def resize(clip, newsize=None, height=None, width=None, apply_to_mask=True):</span>
<span class="w"> </span>    &gt;&gt;&gt; myClip.resize(lambda t : 1+0.02*t) # slow swelling of the clip

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = clip.w, clip.h</span>
<span class="gi">+</span>
<span class="gi">+    if newsize is not None:</span>
<span class="gi">+        if callable(newsize):</span>
<span class="gi">+            def new_func(get_frame, t):</span>
<span class="gi">+                new_w_h = newsize(t)</span>
<span class="gi">+                if isinstance(new_w_h, (int, float)):</span>
<span class="gi">+                    return resize(clip, new_w_h).get_frame(t)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return resize(clip, new_w_h[:2]).get_frame(t)</span>
<span class="gi">+            return clip.fl(new_func)</span>
<span class="gi">+        </span>
<span class="gi">+        elif isinstance(newsize, (int, float)):</span>
<span class="gi">+            factor = newsize</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_w, new_h = list(map(int, newsize))</span>
<span class="gi">+            if new_w == w and new_h == h:</span>
<span class="gi">+                return clip</span>
<span class="gi">+            </span>
<span class="gi">+            factor = min(new_w / w, new_h / h)</span>
<span class="gi">+    </span>
<span class="gi">+    elif height is not None:</span>
<span class="gi">+        factor = height / h</span>
<span class="gi">+    elif width is not None:</span>
<span class="gi">+        factor = width / w</span>
<span class="gi">+    else:</span>
<span class="gi">+        return clip</span>
<span class="gi">+</span>
<span class="gi">+    new_w, new_h = int(w * factor), int(h * factor)</span>
<span class="gi">+</span>
<span class="gi">+    def resizer(pic):</span>
<span class="gi">+        if resizer.origin == &#39;cv2&#39;:</span>
<span class="gi">+            return cv2.resize(pic, (new_w, new_h), interpolation=cv2.INTER_LINEAR)</span>
<span class="gi">+        elif resizer.origin == &#39;PIL&#39;:</span>
<span class="gi">+            return np.array(Image.fromarray(pic).resize((new_w, new_h), Image.BILINEAR))</span>
<span class="gi">+        else:  # Scipy</span>
<span class="gi">+            return resizer(pic, (new_h, new_w))</span>
<span class="gi">+</span>
<span class="gi">+    new_clip = clip.fl_image(resizer)</span>
<span class="gi">+    new_clip.w, new_clip.h = new_w, new_h</span>
<span class="gi">+</span>
<span class="gi">+    if apply_to_mask and clip.mask is not None:</span>
<span class="gi">+        new_clip.mask = resize(clip.mask, newsize=newsize, height=height, width=width, apply_to_mask=False)</span>
<span class="gi">+</span>
<span class="gi">+    return new_clip</span>


<span class="w"> </span>if not resize_possible:
<span class="gh">diff --git a/moviepy/video/fx/rotate.py b/moviepy/video/fx/rotate.py</span>
<span class="gh">index 973879e..9ea9728 100644</span>
<span class="gd">--- a/moviepy/video/fx/rotate.py</span>
<span class="gi">+++ b/moviepy/video/fx/rotate.py</span>
<span class="gu">@@ -33,4 +33,26 @@ def rotate(clip, angle, unit=&#39;deg&#39;, resample=&#39;bicubic&#39;, expand=True):</span>
<span class="w"> </span>    expand
<span class="w"> </span>      Only applIf False, the clip will maintain the same True, the clip will be resized so that the whole
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not PIL_FOUND:</span>
<span class="gi">+        raise ImportError(&quot;rotate requires PIL/Pillow installed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def transform(get_frame, t):</span>
<span class="gi">+        im = Image.fromarray(get_frame(t))</span>
<span class="gi">+        if callable(angle):</span>
<span class="gi">+            a = angle(t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            a = angle</span>
<span class="gi">+        if unit == &#39;rad&#39;:</span>
<span class="gi">+            a = a * 180 / np.pi</span>
<span class="gi">+</span>
<span class="gi">+        if resample == &#39;bilinear&#39;:</span>
<span class="gi">+            pil_resample = Image.BILINEAR</span>
<span class="gi">+        elif resample == &#39;nearest&#39;:</span>
<span class="gi">+            pil_resample = Image.NEAREST</span>
<span class="gi">+        else:</span>
<span class="gi">+            pil_resample = Image.BICUBIC</span>
<span class="gi">+</span>
<span class="gi">+        rotated = im.rotate(a, resample=pil_resample, expand=expand)</span>
<span class="gi">+        return np.array(rotated)</span>
<span class="gi">+</span>
<span class="gi">+    return clip.transform(transform, apply_to=[&#39;mask&#39;])</span>
<span class="gh">diff --git a/moviepy/video/fx/scroll.py b/moviepy/video/fx/scroll.py</span>
<span class="gh">index 4a2c40a..275cba6 100644</span>
<span class="gd">--- a/moviepy/video/fx/scroll.py</span>
<span class="gi">+++ b/moviepy/video/fx/scroll.py</span>
<span class="gu">@@ -2,4 +2,45 @@ def scroll(clip, h=None, w=None, x_speed=0, y_speed=0, x_start=0, y_start=0,</span>
<span class="w"> </span>    apply_to=&#39;mask&#39;):
<span class="w"> </span>    &quot;&quot;&quot; Scrolls horizontally or vertically a clip, e.g. to make end
<span class="w"> </span>        credits &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    </span>
<span class="gi">+    def scroll_function(get_frame, t):</span>
<span class="gi">+        frame = get_frame(t)</span>
<span class="gi">+        </span>
<span class="gi">+        h = h or clip.h</span>
<span class="gi">+        w = w or clip.w</span>
<span class="gi">+        </span>
<span class="gi">+        x = int(x_start + x_speed * t)</span>
<span class="gi">+        y = int(y_start + y_speed * t)</span>
<span class="gi">+        </span>
<span class="gi">+        frame_h, frame_w = frame.shape[:2]</span>
<span class="gi">+        </span>
<span class="gi">+        result = frame.copy()</span>
<span class="gi">+        result[:] = 0  # Clear the result frame</span>
<span class="gi">+        </span>
<span class="gi">+        # Calculate the visible portion of the frame</span>
<span class="gi">+        visible_h = min(h, frame_h)</span>
<span class="gi">+        visible_w = min(w, frame_w)</span>
<span class="gi">+        </span>
<span class="gi">+        # Calculate source and destination regions</span>
<span class="gi">+        src_y = y % frame_h</span>
<span class="gi">+        src_x = x % frame_w</span>
<span class="gi">+        dst_y = 0</span>
<span class="gi">+        dst_x = 0</span>
<span class="gi">+        </span>
<span class="gi">+        # Copy the visible portion of the frame to the result</span>
<span class="gi">+        while dst_y &lt; visible_h:</span>
<span class="gi">+            while dst_x &lt; visible_w:</span>
<span class="gi">+                h_to_copy = min(visible_h - dst_y, frame_h - src_y)</span>
<span class="gi">+                w_to_copy = min(visible_w - dst_x, frame_w - src_x)</span>
<span class="gi">+                result[dst_y:dst_y+h_to_copy, dst_x:dst_x+w_to_copy] = \</span>
<span class="gi">+                    frame[src_y:src_y+h_to_copy, src_x:src_x+w_to_copy]</span>
<span class="gi">+                dst_x += w_to_copy</span>
<span class="gi">+                src_x = 0</span>
<span class="gi">+            dst_y += h_to_copy</span>
<span class="gi">+            src_y = 0</span>
<span class="gi">+            dst_x = 0</span>
<span class="gi">+            src_x = x % frame_w</span>
<span class="gi">+        </span>
<span class="gi">+        return result[:visible_h, :visible_w]</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(scroll_function, apply_to=apply_to)</span>
<span class="gh">diff --git a/moviepy/video/fx/speedx.py b/moviepy/video/fx/speedx.py</span>
<span class="gh">index ee902f1..8f85304 100644</span>
<span class="gd">--- a/moviepy/video/fx/speedx.py</span>
<span class="gi">+++ b/moviepy/video/fx/speedx.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>from moviepy.decorators import apply_to_audio, apply_to_mask


<span class="gi">+@apply_to_audio</span>
<span class="gi">+@apply_to_mask</span>
<span class="w"> </span>def speedx(clip, factor=None, final_duration=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a clip playing the current clip but at a speed multiplied
<span class="gu">@@ -9,4 +11,13 @@ def speedx(clip, factor=None, final_duration=None):</span>
<span class="w"> </span>    computed.
<span class="w"> </span>    The same effect is applied to the clip&#39;s audio and mask if any.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if factor is None and final_duration is None:</span>
<span class="gi">+        raise ValueError(&quot;You must provide either &#39;factor&#39; or &#39;final_duration&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if final_duration is not None:</span>
<span class="gi">+        factor = clip.duration / final_duration</span>
<span class="gi">+</span>
<span class="gi">+    newclip = clip.fl_time(lambda t: t / factor, apply_to=[&#39;mask&#39;, &#39;audio&#39;])</span>
<span class="gi">+    newclip = newclip.set_duration(clip.duration / factor)</span>
<span class="gi">+</span>
<span class="gi">+    return newclip</span>
<span class="gh">diff --git a/moviepy/video/fx/supersample.py b/moviepy/video/fx/supersample.py</span>
<span class="gh">index e09615f..552f5b4 100644</span>
<span class="gd">--- a/moviepy/video/fx/supersample.py</span>
<span class="gi">+++ b/moviepy/video/fx/supersample.py</span>
<span class="gu">@@ -4,4 +4,9 @@ import numpy as np</span>
<span class="w"> </span>def supersample(clip, d, nframes):
<span class="w"> </span>    &quot;&quot;&quot; Replaces each frame at time t by the mean of `nframes` equally spaced frames
<span class="w"> </span>    taken in the interval [t-d, t+d]. This results in motion blur.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def make_frame(t):</span>
<span class="gi">+        tt = np.linspace(t-d, t+d, nframes)</span>
<span class="gi">+        frames = [clip.get_frame(t) for t in tt]</span>
<span class="gi">+        return np.mean(frames, axis=0).astype(&#39;uint8&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return clip.fl(make_frame)</span>
<span class="gh">diff --git a/moviepy/video/fx/time_mirror.py b/moviepy/video/fx/time_mirror.py</span>
<span class="gh">index 92edbdb..850587d 100644</span>
<span class="gd">--- a/moviepy/video/fx/time_mirror.py</span>
<span class="gi">+++ b/moviepy/video/fx/time_mirror.py</span>
<span class="gu">@@ -10,4 +10,4 @@ def time_mirror(self):</span>
<span class="w"> </span>    The clip must have its ``duration`` attribute set.
<span class="w"> </span>    The same effect is applied to the clip&#39;s audio and mask if any.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return self.fl_time(lambda t: self.duration - t)</span>
<span class="gh">diff --git a/moviepy/video/fx/time_symmetrize.py b/moviepy/video/fx/time_symmetrize.py</span>
<span class="gh">index 7b9e089..92114ca 100644</span>
<span class="gd">--- a/moviepy/video/fx/time_symmetrize.py</span>
<span class="gi">+++ b/moviepy/video/fx/time_symmetrize.py</span>
<span class="gu">@@ -5,12 +5,13 @@ from .time_mirror import time_mirror</span>

<span class="w"> </span>@requires_duration
<span class="w"> </span>@apply_to_mask
<span class="gi">+@apply_to_audio</span>
<span class="w"> </span>def time_symmetrize(clip):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a clip that plays the current clip once forwards and
<span class="gd">-    then once backwards. This is very practival to make video that</span>
<span class="gi">+    then once backwards. This is very practical to make video that</span>
<span class="w"> </span>    loop well, e.g. to create animated GIFs.
<span class="w"> </span>    This effect is automatically applied to the clip&#39;s mask and audio
<span class="w"> </span>    if they exist.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return concatenate_videoclips([clip, time_mirror(clip)])</span>
<span class="gh">diff --git a/moviepy/video/io/VideoFileClip.py b/moviepy/video/io/VideoFileClip.py</span>
<span class="gh">index 5bb4b1f..bedf7c1 100644</span>
<span class="gd">--- a/moviepy/video/io/VideoFileClip.py</span>
<span class="gi">+++ b/moviepy/video/io/VideoFileClip.py</span>
<span class="gu">@@ -102,4 +102,7 @@ class VideoFileClip(VideoClip):</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot; Close the internal reader. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;reader&#39;):</span>
<span class="gi">+            self.reader.close()</span>
<span class="gi">+        if hasattr(self, &#39;audio&#39;):</span>
<span class="gi">+            self.audio.close()</span>
<span class="gh">diff --git a/moviepy/video/io/bindings.py b/moviepy/video/io/bindings.py</span>
<span class="gh">index 21d54a8..9ffaa1b 100644</span>
<span class="gd">--- a/moviepy/video/io/bindings.py</span>
<span class="gi">+++ b/moviepy/video/io/bindings.py</span>
<span class="gu">@@ -8,9 +8,13 @@ import numpy as np</span>
<span class="w"> </span>def PIL_to_npimage(im):
<span class="w"> </span>    &quot;&quot;&quot; Transforms a PIL/Pillow image into a numpy RGB(A) image.
<span class="w"> </span>        Actually all this do is returning numpy.array(im).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return np.array(im)</span>


<span class="w"> </span>def mplfig_to_npimage(fig):
<span class="w"> </span>    &quot;&quot;&quot; Converts a matplotlib figure to a RGB frame after updating the canvas&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fig.canvas.draw()  # Update the canvas</span>
<span class="gi">+    w, h = fig.canvas.get_width_height()</span>
<span class="gi">+    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)</span>
<span class="gi">+    buf.shape = (h, w, 3)</span>
<span class="gi">+    return buf</span>
<span class="gh">diff --git a/moviepy/video/io/downloader.py b/moviepy/video/io/downloader.py</span>
<span class="gh">index 82a3b18..5b7d0c2 100644</span>
<span class="gd">--- a/moviepy/video/io/downloader.py</span>
<span class="gi">+++ b/moviepy/video/io/downloader.py</span>
<span class="gu">@@ -12,4 +12,16 @@ def download_webfile(url, filename, overwrite=False):</span>
<span class="w"> </span>    using youtube-dl (install youtube-dl first !).
<span class="w"> </span>    If the filename already exists and overwrite=False, nothing will happen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.exists(filename) and not overwrite:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if len(url) == 11 and url.isalnum():  # Likely a YouTube video ID</span>
<span class="gi">+        youtube_dl_command = [&#39;youtube-dl&#39;, &#39;-o&#39;, filename, url]</span>
<span class="gi">+        subprocess_call(youtube_dl_command)</span>
<span class="gi">+    else:</span>
<span class="gi">+        response = requests.get(url, stream=True)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        </span>
<span class="gi">+        with open(filename, &#39;wb&#39;) as file:</span>
<span class="gi">+            for chunk in response.iter_content(chunk_size=8192):</span>
<span class="gi">+                file.write(chunk)</span>
<span class="gh">diff --git a/moviepy/video/io/ffmpeg_reader.py b/moviepy/video/io/ffmpeg_reader.py</span>
<span class="gh">index fd9fccf..ee2eb10 100644</span>
<span class="gd">--- a/moviepy/video/io/ffmpeg_reader.py</span>
<span class="gi">+++ b/moviepy/video/io/ffmpeg_reader.py</span>
<span class="gu">@@ -55,11 +55,40 @@ class FFMPEG_VideoReader:</span>

<span class="w"> </span>    def initialize(self, starttime=0):
<span class="w"> </span>        &quot;&quot;&quot;Opens the file, creates the pipe. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.close()  # if any</span>
<span class="gi">+</span>
<span class="gi">+        if starttime != 0:</span>
<span class="gi">+            offset = min(1, starttime)</span>
<span class="gi">+            i_arg = [&#39;-ss&#39;, &quot;%.06f&quot; % (starttime - offset),</span>
<span class="gi">+                     &#39;-i&#39;, self.filename,</span>
<span class="gi">+                     &#39;-ss&#39;, &quot;%.06f&quot; % offset]</span>
<span class="gi">+        else:</span>
<span class="gi">+            i_arg = [&#39;-i&#39;, self.filename]</span>
<span class="gi">+</span>
<span class="gi">+        cmd = ([get_setting(&quot;FFMPEG_BINARY&quot;)] + i_arg +</span>
<span class="gi">+               [&#39;-loglevel&#39;, &#39;error&#39;,</span>
<span class="gi">+                &#39;-f&#39;, &#39;image2pipe&#39;,</span>
<span class="gi">+                &#39;-vf&#39;, &#39;scale=%d:%d&#39; % tuple(self.size),</span>
<span class="gi">+                &#39;-sws_flags&#39;, self.resize_algo,</span>
<span class="gi">+                &quot;-pix_fmt&quot;, self.pix_fmt,</span>
<span class="gi">+                &#39;-vcodec&#39;, &#39;rawvideo&#39;, &#39;-&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        popen_params = {&quot;bufsize&quot;: self.bufsize,</span>
<span class="gi">+                        &quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+                        &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+        self.proc = sp.Popen(cmd, **popen_params)</span>

<span class="w"> </span>    def skip_frames(self, n=1):
<span class="w"> </span>        &quot;&quot;&quot;Reads and throws away n frames &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w, h = self.size</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            self.proc.stdout.read(self.depth*w*h)</span>
<span class="gi">+            self.pos += 1</span>

<span class="w"> </span>    def get_frame(self, t):
<span class="w"> </span>        &quot;&quot;&quot; Read a file video frame at time t.
<span class="gu">@@ -69,7 +98,27 @@ class FFMPEG_VideoReader:</span>
<span class="w"> </span>        This function tries to avoid fetching arbitrary frames
<span class="w"> </span>        whenever possible, by moving between adjacent frames.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get frame number from time</span>
<span class="gi">+        pos = int(self.fps * t + 0.00001) + 1</span>
<span class="gi">+</span>
<span class="gi">+        # Initialize proc if it hasn&#39;t been done yet</span>
<span class="gi">+        if self.proc is None:</span>
<span class="gi">+            self.initialize(t)</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            self.lastread = self.read_frame()</span>
<span class="gi">+</span>
<span class="gi">+        if pos == self.pos:</span>
<span class="gi">+            return self.lastread</span>
<span class="gi">+        elif (pos &lt; self.pos) or (pos &gt; self.pos + 100):</span>
<span class="gi">+            self.initialize(t)</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.skip_frames(pos - self.pos - 1)</span>
<span class="gi">+        </span>
<span class="gi">+        result = self.read_frame()</span>
<span class="gi">+        self.pos = pos</span>
<span class="gi">+        self.lastread = result</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def __del__(self):
<span class="w"> </span>        self.close()
<span class="gu">@@ -95,7 +144,16 @@ def ffmpeg_read_image(filename, with_mask=True):</span>
<span class="w"> </span>      this layer as the mask of the returned ImageClip

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if with_mask:</span>
<span class="gi">+        pix_fmt = &#39;rgba&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        pix_fmt = &#39;rgb24&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    reader = FFMPEG_VideoReader(filename, pix_fmt=pix_fmt, check_duration=False)</span>
<span class="gi">+    im = reader.lastread</span>
<span class="gi">+    reader.close()</span>
<span class="gi">+</span>
<span class="gi">+    return im</span>


<span class="w"> </span>def ffmpeg_parse_infos(filename, print_infos=False, check_duration=True,
<span class="gu">@@ -110,4 +168,100 @@ def ffmpeg_parse_infos(filename, print_infos=False, check_duration=True,</span>
<span class="w"> </span>    fetching the uncomplete frames at the end, which raises an error.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Open the file in a pipe, read output</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-i&quot;, filename]</span>
<span class="gi">+    if not check_duration:</span>
<span class="gi">+        cmd += [&quot;-t&quot;, &quot;00:00:00.1&quot;]</span>
<span class="gi">+    cmd += [&quot;-f&quot;, &quot;null&quot;, &quot;-&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    popen_params = {&quot;bufsize&quot;: 10**5,</span>
<span class="gi">+                    &quot;stdout&quot;: sp.PIPE,</span>
<span class="gi">+                    &quot;stderr&quot;: sp.PIPE,</span>
<span class="gi">+                    &quot;stdin&quot;: DEVNULL}</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        popen_params[&quot;creationflags&quot;] = 0x08000000</span>
<span class="gi">+</span>
<span class="gi">+    proc = sp.Popen(cmd, **popen_params)</span>
<span class="gi">+    (output, error) = proc.communicate()</span>
<span class="gi">+    infos = error.decode(&#39;utf8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if print_infos:</span>
<span class="gi">+        # print the whole info text returned by FFMPEG</span>
<span class="gi">+        print(infos)</span>
<span class="gi">+</span>
<span class="gi">+    lines = infos.splitlines()</span>
<span class="gi">+    if &quot;No such file or directory&quot; in lines[-1]:</span>
<span class="gi">+        raise IOError((&quot;MoviePy error: the file %s could not be found!\n&quot;</span>
<span class="gi">+                       &quot;Please check that you entered the correct &quot;</span>
<span class="gi">+                       &quot;path.&quot;) % filename)</span>
<span class="gi">+</span>
<span class="gi">+    result = dict()</span>
<span class="gi">+    # get duration (in seconds)</span>
<span class="gi">+    result[&#39;duration&#39;] = None</span>
<span class="gi">+</span>
<span class="gi">+    if check_duration:</span>
<span class="gi">+        try:</span>
<span class="gi">+            keyword = (&#39;frame=&#39; if &#39;frame=&#39; in infos else &#39;Duration: &#39;)</span>
<span class="gi">+            line = [l for l in lines if keyword in l][0]</span>
<span class="gi">+            match = re.findall(&quot;([0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9][0-9])&quot;, line)[0]</span>
<span class="gi">+            result[&#39;duration&#39;] = cvsecs(match)</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise IOError((&quot;MoviePy error: failed to read the duration of file %s.\n&quot;</span>
<span class="gi">+                           &quot;Here are the file infos returned by ffmpeg:\n\n%s&quot;) % (</span>
<span class="gi">+                              filename, infos))</span>
<span class="gi">+</span>
<span class="gi">+    # get the output line that speaks about video</span>
<span class="gi">+    lines_video = [l for l in lines if &#39; Video: &#39; in l and &#39; fps &#39; in l]</span>
<span class="gi">+</span>
<span class="gi">+    result[&#39;video_found&#39;] = lines_video != []</span>
<span class="gi">+</span>
<span class="gi">+    if result[&#39;video_found&#39;]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            line = lines_video[0]</span>
<span class="gi">+</span>
<span class="gi">+            # get the size, of the form 460x320 (w x h)</span>
<span class="gi">+            match = re.search(&quot; [0-9]*x[0-9]*(,| )&quot;, line)</span>
<span class="gi">+            s = list(map(int, line[match.start():match.end()-1].split(&#39;x&#39;)))</span>
<span class="gi">+            result[&#39;video_size&#39;] = s</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise IOError((&quot;MoviePy error: failed to read video dimensions in file %s.\n&quot;</span>
<span class="gi">+                           &quot;Here are the file infos returned by ffmpeg:\n\n%s&quot;) % (</span>
<span class="gi">+                              filename, infos))</span>
<span class="gi">+</span>
<span class="gi">+        # get the frame rate</span>
<span class="gi">+        try:</span>
<span class="gi">+            match = re.search(&quot;( [0-9]*.| )[0-9]* fps&quot;, line)</span>
<span class="gi">+            fps = float(line[match.start():match.end()].split(&#39; fps&#39;)[0])</span>
<span class="gi">+            result[&#39;video_fps&#39;] = fps</span>
<span class="gi">+        except:</span>
<span class="gi">+            result[&#39;video_fps&#39;] = None</span>
<span class="gi">+</span>
<span class="gi">+    result[&#39;video_nframes&#39;] = None</span>
<span class="gi">+    result[&#39;video_duration&#39;] = None</span>
<span class="gi">+    # get the number of frames if possible</span>
<span class="gi">+    if result[&#39;video_found&#39;] and result[&#39;duration&#39;] is not None:</span>
<span class="gi">+        if result[&#39;video_fps&#39;] is not None:</span>
<span class="gi">+            result[&#39;video_nframes&#39;] = int(result[&#39;duration&#39;] * result[&#39;video_fps&#39;]) + 1</span>
<span class="gi">+            result[&#39;video_duration&#39;] = result[&#39;duration&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # We could try to read the number of frames with ffprobe</span>
<span class="gi">+            # but this would be slow</span>
<span class="gi">+            result[&#39;video_nframes&#39;] = 1</span>
<span class="gi">+            result[&#39;video_duration&#39;] = result[&#39;duration&#39;]</span>
<span class="gi">+            # We don&#39;t try to read the fps (but the duration is known).</span>
<span class="gi">+</span>
<span class="gi">+    # get the list of audio streams</span>
<span class="gi">+    lines_audio = [l for l in lines if &#39; Audio: &#39; in l]</span>
<span class="gi">+</span>
<span class="gi">+    result[&#39;audio_found&#39;] = lines_audio != []</span>
<span class="gi">+</span>
<span class="gi">+    if result[&#39;audio_found&#39;]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            line = lines_audio[0]</span>
<span class="gi">+            match = re.search(&quot; [0-9]* Hz&quot;, line)</span>
<span class="gi">+            result[&#39;audio_fps&#39;] = int(line[match.start()+1:match.end()])</span>
<span class="gi">+        except:</span>
<span class="gi">+            result[&#39;audio_fps&#39;] = &#39;unknown&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/moviepy/video/io/ffmpeg_tools.py b/moviepy/video/io/ffmpeg_tools.py</span>
<span class="gh">index cf73b19..a668bff 100644</span>
<span class="gd">--- a/moviepy/video/io/ffmpeg_tools.py</span>
<span class="gi">+++ b/moviepy/video/io/ffmpeg_tools.py</span>
<span class="gu">@@ -11,28 +11,55 @@ def ffmpeg_movie_from_frames(filename, folder, fps, digits=6, bitrate=&#39;v&#39;):</span>
<span class="w"> </span>    Writes a movie out of the frames (picture files) in a folder.
<span class="w"> </span>    Almost deprecated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;, &quot;-f&quot;, &quot;image2&quot;,</span>
<span class="gi">+           &quot;-r&quot;, &quot;%d&quot; % fps,</span>
<span class="gi">+           &quot;-i&quot;, os.path.join(folder, &quot;frame%0{}d.png&quot;.format(digits)),</span>
<span class="gi">+           &quot;-b:v&quot;, bitrate]</span>
<span class="gi">+    </span>
<span class="gi">+    if get_setting(&quot;FFMPEG_BINARY&quot;) == &quot;ffmpeg&quot;:</span>
<span class="gi">+        cmd.extend([&quot;-vcodec&quot;, &quot;libx264&quot;, &quot;-pix_fmt&quot;, &quot;yuv420p&quot;])</span>
<span class="gi">+    </span>
<span class="gi">+    cmd.append(filename)</span>
<span class="gi">+    </span>
<span class="gi">+    subprocess_call(cmd)</span>


<span class="w"> </span>def ffmpeg_extract_subclip(filename, t1, t2, targetname=None):
<span class="w"> </span>    &quot;&quot;&quot; Makes a new video file playing video file ``filename`` between
<span class="w"> </span>        the times ``t1`` and ``t2``. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name, ext = os.path.splitext(filename)</span>
<span class="gi">+    if not targetname:</span>
<span class="gi">+        T1, T2 = [int(1000*t) for t in [t1, t2]]</span>
<span class="gi">+        targetname = &quot;%sSUB%d_%d.%s&quot; % (name, T1, T2, ext)</span>

<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;,</span>
<span class="gi">+           &quot;-i&quot;, filename,</span>
<span class="gi">+           &quot;-ss&quot;, &quot;%0.2f&quot; % t1,</span>
<span class="gi">+           &quot;-t&quot;, &quot;%0.2f&quot; % (t2-t1),</span>
<span class="gi">+           &quot;-vcodec&quot;, &quot;copy&quot;, &quot;-acodec&quot;, &quot;copy&quot;, targetname]</span>

<span class="gd">-def ffmpeg_merge_video_audio(video, audio, output, vcodec=&#39;copy&#39;, acodec=</span>
<span class="gd">-    &#39;copy&#39;, ffmpeg_output=False, logger=&#39;bar&#39;):</span>
<span class="gi">+    subprocess_call(cmd)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ffmpeg_merge_video_audio(video, audio, output, vcodec=&#39;copy&#39;, acodec=&#39;copy&#39;, ffmpeg_output=False, logger=&#39;bar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot; merges video file ``video`` and audio file ``audio`` into one
<span class="w"> </span>        movie file ``output``. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;, &quot;-i&quot;, audio, &quot;-i&quot;, video,</span>
<span class="gi">+           &quot;-vcodec&quot;, vcodec, &quot;-acodec&quot;, acodec, output]</span>
<span class="gi">+</span>
<span class="gi">+    subprocess_call(cmd, logger=logger)</span>


<span class="w"> </span>def ffmpeg_extract_audio(inputfile, output, bitrate=3000, fps=44100):
<span class="w"> </span>    &quot;&quot;&quot; extract the sound from a video file and save it in ``output`` &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-y&quot;, &quot;-i&quot;, inputfile, &quot;-ab&quot;, str(bitrate),</span>
<span class="gi">+           &quot;-ar&quot;, str(fps), &quot;-vn&quot;, output]</span>
<span class="gi">+    subprocess_call(cmd)</span>


<span class="w"> </span>def ffmpeg_resize(video, output, size):
<span class="w"> </span>    &quot;&quot;&quot; resizes ``video`` to new size ``size`` and write the result
<span class="w"> </span>        in file ``output``. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &quot;-i&quot;, video, &quot;-vf&quot;, &quot;scale=%d:%d&quot; % (size[0], size[1]),</span>
<span class="gi">+           &quot;-preset&quot;, &quot;slow&quot;, &quot;-crf&quot;, &quot;22&quot;, output]</span>
<span class="gi">+    subprocess_call(cmd)</span>
<span class="gh">diff --git a/moviepy/video/io/ffmpeg_writer.py b/moviepy/video/io/ffmpeg_writer.py</span>
<span class="gh">index 5d6bb8b..965f41c 100644</span>
<span class="gd">--- a/moviepy/video/io/ffmpeg_writer.py</span>
<span class="gi">+++ b/moviepy/video/io/ffmpeg_writer.py</span>
<span class="gu">@@ -94,7 +94,10 @@ class FFMPEG_VideoWriter:</span>

<span class="w"> </span>    def write_frame(self, img_array):
<span class="w"> </span>        &quot;&quot;&quot; Writes one frame in the file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if PY3:</span>
<span class="gi">+            self.proc.stdin.write(img_array.tobytes())</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.proc.stdin.write(img_array.tostring())</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -109,10 +112,48 @@ def ffmpeg_write_video(clip, filename, fps, codec=&#39;libx264&#39;, bitrate=None,</span>
<span class="w"> </span>    &quot;&quot;&quot; Write the clip to a videofile. See VideoClip.write_videofile for details
<span class="w"> </span>    on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile = open(filename + &quot;.log&quot;, &#39;w+&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        logfile = None</span>
<span class="gi">+    logger(message=&#39;Moviepy - Writing video %s&#39; % filename)</span>
<span class="gi">+    logger(message=&#39;Moviepy - Writing audio %s&#39; % (audiofile if audiofile else &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    with FFMPEG_VideoWriter(filename, clip.size, fps, codec, audiofile,</span>
<span class="gi">+                            preset, bitrate, withmask, logfile, threads,</span>
<span class="gi">+                            ffmpeg_params) as writer:</span>
<span class="gi">+        for t, frame in clip.iter_frames(logger=logger, with_times=True,</span>
<span class="gi">+                                         fps=fps, dtype=&quot;uint8&quot;):</span>
<span class="gi">+            writer.write_frame(frame)</span>
<span class="gi">+</span>
<span class="gi">+    if write_logfile:</span>
<span class="gi">+        logfile.close()</span>
<span class="gi">+    logger(message=&#39;Moviepy - Done !&#39;)</span>


<span class="w"> </span>def ffmpeg_write_image(filename, image, logfile=False):
<span class="w"> </span>    &quot;&quot;&quot; Writes an image (HxWx3 or HxWx4 numpy array) to a file, using
<span class="w"> </span>        ffmpeg. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if logfile:</span>
<span class="gi">+        log_file = open(filename + &quot;.log&quot;, &#39;w+&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        log_file = sp.PIPE</span>
<span class="gi">+</span>
<span class="gi">+    cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;, &#39;-loglevel&#39;, &#39;error&#39; if logfile else &#39;info&#39;,</span>
<span class="gi">+           &#39;-f&#39;, &#39;rawvideo&#39;, &#39;-vcodec&#39;, &#39;rawvideo&#39;, &#39;-s&#39;, &#39;%dx%d&#39; % (image.shape[1], image.shape[0]),</span>
<span class="gi">+           &#39;-pix_fmt&#39;, &#39;rgba&#39; if image.shape[2] == 4 else &#39;rgb24&#39;,</span>
<span class="gi">+           &#39;-i&#39;, &#39;-&#39;, &#39;-vcodec&#39;, &#39;png&#39;, filename]</span>
<span class="gi">+</span>
<span class="gi">+    popen_params = {&quot;stdout&quot;: DEVNULL,</span>
<span class="gi">+                    &quot;stderr&quot;: log_file,</span>
<span class="gi">+                    &quot;stdin&quot;: sp.PIPE}</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        popen_params[&quot;creationflags&quot;] = 134217728</span>
<span class="gi">+</span>
<span class="gi">+    proc = sp.Popen(cmd, **popen_params)</span>
<span class="gi">+    proc.communicate(image.tostring())</span>
<span class="gi">+</span>
<span class="gi">+    if logfile:</span>
<span class="gi">+        log_file.close()</span>
<span class="gh">diff --git a/moviepy/video/io/gif_writers.py b/moviepy/video/io/gif_writers.py</span>
<span class="gh">index 5b4de02..da994ed 100644</span>
<span class="gd">--- a/moviepy/video/io/gif_writers.py</span>
<span class="gi">+++ b/moviepy/video/io/gif_writers.py</span>
<span class="gu">@@ -27,7 +27,47 @@ def write_gif_with_tempfiles(clip, filename, fps=None, program=</span>
<span class="w"> </span>    them in the RAM. Useful on computers with little RAM.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    file_root, file_ext = os.path.splitext(filename)</span>
<span class="gi">+    temp_file_prefix = file_root + &quot;_temp_&quot;</span>
<span class="gi">+</span>
<span class="gi">+    logger(message=&#39;MoviePy - Building file %s\n&#39; % filename)</span>
<span class="gi">+    logger(message=&#39;MoviePy - - Generating GIF frames&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    duration = clip.duration</span>
<span class="gi">+    nframes = int(clip.fps * duration)</span>
<span class="gi">+</span>
<span class="gi">+    for i, frame in enumerate(clip.iter_frames(fps=fps, logger=logger)):</span>
<span class="gi">+        temp_file = temp_file_prefix + &quot;%04d.png&quot; % i</span>
<span class="gi">+        imageio.imwrite(temp_file, frame)</span>
<span class="gi">+</span>
<span class="gi">+    logger(message=&#39;MoviePy - - Generating GIF file&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if program == &#39;ImageMagick&#39;:</span>
<span class="gi">+        cmd = [get_setting(&quot;IMAGEMAGICK_BINARY&quot;),</span>
<span class="gi">+               &#39;-delay&#39;, &#39;%d&#39; % (100.0 / fps),</span>
<span class="gi">+               &#39;-loop&#39;, &#39;%d&#39; % loop,</span>
<span class="gi">+               temp_file_prefix + &quot;*.png&quot;,</span>
<span class="gi">+               &#39;-fuzz&#39;, &#39;%02d&#39; % fuzz + &#39;%&#39;,</span>
<span class="gi">+               &#39;-layers&#39;, opt,</span>
<span class="gi">+               filename]</span>
<span class="gi">+    elif program == &#39;ffmpeg&#39;:</span>
<span class="gi">+        cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;,</span>
<span class="gi">+               &#39;-f&#39;, &#39;image2&#39;,</span>
<span class="gi">+               &#39;-i&#39;, temp_file_prefix + &#39;%04d.png&#39;,</span>
<span class="gi">+               &#39;-filter_complex&#39;, &#39;[0:v]split [a][b];[a]palettegen=stats_mode=single [p];[b][p]paletteuse=new=1&#39;,</span>
<span class="gi">+               &#39;-r&#39;, str(fps),</span>
<span class="gi">+               filename]</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess_call(cmd, logger=logger)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger(message=&#39;MoviePy - Deleting temporary files&#39;)</span>
<span class="gi">+        for file in os.listdir(os.path.dirname(temp_file_prefix)):</span>
<span class="gi">+            if file.startswith(os.path.basename(temp_file_prefix)):</span>
<span class="gi">+                os.remove(os.path.join(os.path.dirname(temp_file_prefix), file))</span>
<span class="gi">+</span>
<span class="gi">+    logger(message=&#39;MoviePy - GIF ready: %s.&#39; % filename)</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -77,7 +117,57 @@ def write_gif(clip, filename, fps=None, program=&#39;ImageMagick&#39;, opt=</span>
<span class="w"> </span>        &gt;&gt;&gt; myClip.speedx(0.5).write_gif(&#39;myClip.gif&#39;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    logger(message=&#39;MoviePy - Building file %s\n&#39; % filename)</span>
<span class="gi">+    </span>
<span class="gi">+    if program == &#39;ImageMagick&#39;:</span>
<span class="gi">+        delay = int(100.0 / fps)</span>
<span class="gi">+        cmd = [get_setting(&quot;IMAGEMAGICK_BINARY&quot;),</span>
<span class="gi">+               &#39;-delay&#39;, &#39;%d&#39; % delay,</span>
<span class="gi">+               &#39;-loop&#39;, &#39;%d&#39; % loop,</span>
<span class="gi">+               &#39;-fuzz&#39;, &#39;%02d&#39; % fuzz + &#39;%&#39;,</span>
<span class="gi">+               &#39;-layers&#39;, opt]</span>
<span class="gi">+        </span>
<span class="gi">+        if dispose:</span>
<span class="gi">+            cmd += [&#39;-dispose&#39;, &#39;2&#39;]</span>
<span class="gi">+        </span>
<span class="gi">+        if colors:</span>
<span class="gi">+            cmd += [&#39;-colors&#39;, &#39;%d&#39; % colors]</span>
<span class="gi">+        </span>
<span class="gi">+        cmd += [&#39;PNG:-&#39;, filename]</span>
<span class="gi">+        </span>
<span class="gi">+        proc = sp.Popen(cmd, stdin=sp.PIPE, stderr=DEVNULL)</span>
<span class="gi">+        </span>
<span class="gi">+        for frame in clip.iter_frames(fps=fps, logger=logger):</span>
<span class="gi">+            if withmask and clip.mask is not None:</span>
<span class="gi">+                mask = 255 * clip.mask.get_frame(t)</span>
<span class="gi">+                frame = np.dstack([frame, mask]).astype(&#39;uint8&#39;)</span>
<span class="gi">+            proc.stdin.write(imageio.imwrite(&#39;&lt;bytes&gt;&#39;, frame, format=&#39;png&#39;))</span>
<span class="gi">+        </span>
<span class="gi">+        proc.stdin.close()</span>
<span class="gi">+        proc.wait()</span>
<span class="gi">+        </span>
<span class="gi">+    elif program == &#39;ffmpeg&#39;:</span>
<span class="gi">+        cmd = [get_setting(&quot;FFMPEG_BINARY&quot;), &#39;-y&#39;,</span>
<span class="gi">+               &#39;-f&#39;, &#39;rawvideo&#39;,</span>
<span class="gi">+               &#39;-vcodec&#39;, &#39;rawvideo&#39;,</span>
<span class="gi">+               &#39;-r&#39;, &#39;%.02f&#39; % fps,</span>
<span class="gi">+               &#39;-s&#39;, &#39;%dx%d&#39; % (clip.w, clip.h),</span>
<span class="gi">+               &#39;-pix_fmt&#39;, &#39;rgb24&#39;,</span>
<span class="gi">+               &#39;-i&#39;, &#39;-&#39;,</span>
<span class="gi">+               &#39;-filter_complex&#39;, &#39;[0:v]split [a][b];[a]palettegen=stats_mode=single [p];[b][p]paletteuse=new=1&#39;,</span>
<span class="gi">+               &#39;-r&#39;, &#39;%.02f&#39; % fps,</span>
<span class="gi">+               filename]</span>
<span class="gi">+        </span>
<span class="gi">+        proc = sp.Popen(cmd, stdin=sp.PIPE, stderr=DEVNULL)</span>
<span class="gi">+        </span>
<span class="gi">+        for frame in clip.iter_frames(fps=fps, logger=logger):</span>
<span class="gi">+            proc.stdin.write(frame.tostring())</span>
<span class="gi">+        </span>
<span class="gi">+        proc.stdin.close()</span>
<span class="gi">+        proc.wait()</span>
<span class="gi">+    </span>
<span class="gi">+    logger(message=&#39;MoviePy - GIF ready: %s.&#39; % filename)</span>


<span class="w"> </span>def write_gif_with_image_io(clip, filename, fps=None, opt=0, loop=0, colors
<span class="gu">@@ -88,6 +178,25 @@ def write_gif_with_image_io(clip, filename, fps=None, opt=0, loop=0, colors</span>
<span class="w"> </span>    Parameters
<span class="w"> </span>    -----------
<span class="w"> </span>    opt
<span class="gi">+      Optimization level, from 0 to 2.</span>
<span class="gi">+      0 means no optimization, 1 means basic optimization,</span>
<span class="gi">+      2 means maximum optimization (slower).</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not IMAGEIO_FOUND:</span>
<span class="gi">+        raise ImportError(&quot;Writing GIFs with imageio requires imageio installed&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    logger = proglog.default_bar_logger(logger)</span>
<span class="gi">+    logger(message=&#39;MoviePy - Building file %s\n&#39; % filename)</span>
<span class="gi">+    </span>
<span class="gi">+    if fps is None:</span>
<span class="gi">+        fps = clip.fps</span>
<span class="gi">+    </span>
<span class="gi">+    quantizer = 0 if colors is None else 2</span>
<span class="gi">+    writer = imageio.get_writer(filename, mode=&#39;I&#39;, fps=fps, loop=loop, quantizer=quantizer)</span>
<span class="gi">+    </span>
<span class="gi">+    for frame in clip.iter_frames(fps=fps, logger=logger):</span>
<span class="gi">+        writer.append_data(frame)</span>
<span class="gi">+    </span>
<span class="gi">+    writer.close()</span>
<span class="gi">+    logger(message=&#39;MoviePy - GIF ready: %s.&#39; % filename)</span>
<span class="gh">diff --git a/moviepy/video/io/html_tools.py b/moviepy/video/io/html_tools.py</span>
<span class="gh">index d4ecc6b..0ed8645 100644</span>
<span class="gd">--- a/moviepy/video/io/html_tools.py</span>
<span class="gi">+++ b/moviepy/video/io/html_tools.py</span>
<span class="gu">@@ -68,7 +68,33 @@ def html_embed(clip, filetype=None, maxduration=60, rd_kwargs=None, center=</span>
<span class="w"> </span>    &gt;&gt;&gt; mpy.ipython_display(&quot;first_frame.jpeg&quot;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(clip, str):</span>
<span class="gi">+        filename = clip</span>
<span class="gi">+        if filetype is None:</span>
<span class="gi">+            ext = filename.split(&#39;.&#39;)[-1].lower()</span>
<span class="gi">+            filetype = extensions_dict.get(ext, ext)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if filetype is None:</span>
<span class="gi">+            filetype = &#39;video&#39; if isinstance(clip, VideoClip) else &#39;audio&#39; if isinstance(clip, AudioClip) else &#39;image&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        filename = f&quot;temp_clip.{filetype}&quot;</span>
<span class="gi">+        if filetype == &#39;video&#39;:</span>
<span class="gi">+            clip.write_videofile(filename, **rd_kwargs or {})</span>
<span class="gi">+        elif filetype == &#39;audio&#39;:</span>
<span class="gi">+            clip.write_audiofile(filename, **rd_kwargs or {})</span>
<span class="gi">+        else:</span>
<span class="gi">+            clip.save_frame(filename, t=0)</span>
<span class="gi">+</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+        data = b64encode(f.read()).decode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    options = &#39; &#39;.join(f&#39;{k}=&quot;{v}&quot;&#39; for k, v in html_kwargs.items())</span>
<span class="gi">+    html = templates[filetype] % {&#39;data&#39;: data, &#39;options&#39;: options, &#39;ext&#39;: filetype}</span>
<span class="gi">+</span>
<span class="gi">+    if center:</span>
<span class="gi">+        html = f&quot;&lt;center&gt;{html}&lt;/center&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return HTML2(html) if ipython_available else html</span>


<span class="w"> </span>def ipython_display(clip, filetype=None, maxduration=60, t=None, fps=None,
<span class="gu">@@ -119,4 +145,27 @@ def ipython_display(clip, filetype=None, maxduration=60, t=None, fps=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; clip.save_frame(&quot;first_frame.jpeg&quot;)
<span class="w"> </span>    &gt;&gt;&gt; mpy.ipython_display(&quot;first_frame.jpeg&quot;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not ipython_available:</span>
<span class="gi">+        raise ImportError(&quot;IPython is not available. Unable to display in notebook.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(clip, str):</span>
<span class="gi">+        filename = clip</span>
<span class="gi">+    else:</span>
<span class="gi">+        if t is not None:</span>
<span class="gi">+            clip = clip.to_ImageClip(t)</span>
<span class="gi">+            filetype = &#39;image&#39;</span>
<span class="gi">+        elif clip.duration &gt; maxduration:</span>
<span class="gi">+            raise ValueError(f&quot;Clip duration ({clip.duration:.2f}s) exceeds maxduration ({maxduration}s)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if filetype is None:</span>
<span class="gi">+            filetype = &#39;video&#39; if isinstance(clip, VideoClip) else &#39;audio&#39; if isinstance(clip, AudioClip) else &#39;image&#39;</span>
<span class="gi">+</span>
<span class="gi">+        filename = f&quot;temp_clip.{filetype}&quot;</span>
<span class="gi">+        if filetype == &#39;video&#39;:</span>
<span class="gi">+            clip.write_videofile(filename, fps=fps, **rd_kwargs or {})</span>
<span class="gi">+        elif filetype == &#39;audio&#39;:</span>
<span class="gi">+            clip.write_audiofile(filename, fps=fps, **rd_kwargs or {})</span>
<span class="gi">+        else:</span>
<span class="gi">+            clip.save_frame(filename, t=0)</span>
<span class="gi">+</span>
<span class="gi">+    return HTML(html_embed(filename, filetype=filetype, center=center, **html_kwargs))</span>
<span class="gh">diff --git a/moviepy/video/io/preview.py b/moviepy/video/io/preview.py</span>
<span class="gh">index 0cb06a5..dc2ba4e 100644</span>
<span class="gd">--- a/moviepy/video/io/preview.py</span>
<span class="gi">+++ b/moviepy/video/io/preview.py</span>
<span class="gu">@@ -10,7 +10,11 @@ pg.display.set_caption(&#39;MoviePy&#39;)</span>

<span class="w"> </span>def imdisplay(imarray, screen=None):
<span class="w"> </span>    &quot;&quot;&quot;Splashes the given image array on the given pygame screen &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a = pg.surfarray.make_surface(imarray.swapaxes(0, 1))</span>
<span class="gi">+    if screen is None:</span>
<span class="gi">+        screen = pg.display.set_mode(imarray.shape[:2][::-1])</span>
<span class="gi">+    screen.blit(a, (0, 0))</span>
<span class="gi">+    pg.display.flip()</span>


<span class="w"> </span>@convert_masks_to_RGB
<span class="gu">@@ -29,7 +33,21 @@ def show(clip, t=0, with_mask=True, interactive=False):</span>
<span class="w"> </span>      without the mask.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(t, str):</span>
<span class="gi">+        t = cvsecs(t)</span>
<span class="gi">+    </span>
<span class="gi">+    img = clip.get_frame(t)</span>
<span class="gi">+    if with_mask and clip.mask is not None:</span>
<span class="gi">+        mask = clip.mask.get_frame(t)</span>
<span class="gi">+        img = np.dstack([img, mask])</span>
<span class="gi">+    </span>
<span class="gi">+    imdisplay(img)</span>
<span class="gi">+    </span>
<span class="gi">+    if interactive:</span>
<span class="gi">+        result = None</span>
<span class="gi">+        while result not in [&#39;q&#39;, &#39;Q&#39;, &#39;quit&#39;, &#39;QUIT&#39;]:</span>
<span class="gi">+            result = input(&quot;Enter &#39;q&#39; or &#39;quit&#39; to exit: &quot;)</span>
<span class="gi">+        print(&quot;Exiting.&quot;)</span>


<span class="w"> </span>@requires_duration
<span class="gu">@@ -60,4 +78,40 @@ def preview(clip, fps=15, audio=True, audio_fps=22050, audio_buffersize=</span>
<span class="w"> </span>      ``True`` if you want the preview to be displayed fullscreen.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fullscreen:</span>
<span class="gi">+        flags = pg.FULLSCREEN</span>
<span class="gi">+    else:</span>
<span class="gi">+        flags = 0</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize pygame screen</span>
<span class="gi">+    w, h = clip.size</span>
<span class="gi">+    screen = pg.display.set_mode((w, h), flags)</span>
<span class="gi">+</span>
<span class="gi">+    audio_flag = audio and (clip.audio is not None)</span>
<span class="gi">+</span>
<span class="gi">+    if audio_flag:</span>
<span class="gi">+        # Initialize audio</span>
<span class="gi">+        pg.mixer.quit()</span>
<span class="gi">+        pg.mixer.init(audio_fps, -audio_nbytes*8, clip.audio.nchannels, 1024)</span>
<span class="gi">+        audioframe = np.zeros((audio_buffersize, clip.audio.nchannels))</span>
<span class="gi">+</span>
<span class="gi">+    t0 = time.time()</span>
<span class="gi">+    for t in np.arange(0, clip.duration, 1.0/fps):</span>
<span class="gi">+        img = clip.get_frame(t)</span>
<span class="gi">+        imdisplay(img, screen)</span>
<span class="gi">+        </span>
<span class="gi">+        if audio_flag:</span>
<span class="gi">+            # Play audio</span>
<span class="gi">+            audio_t = t0 + t - time.time()</span>
<span class="gi">+            if audio_t &gt; 0:</span>
<span class="gi">+                audioframe = clip.audio.to_soundarray(t, t+audio_buffersize/audio_fps)</span>
<span class="gi">+                pg.sndarray.make_sound(audioframe.astype(&quot;int16&quot;)).play()</span>
<span class="gi">+        </span>
<span class="gi">+        for event in pg.event.get():</span>
<span class="gi">+            if event.type == pg.QUIT or (event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE):</span>
<span class="gi">+                pg.quit()</span>
<span class="gi">+                return</span>
<span class="gi">+        </span>
<span class="gi">+        time.sleep(max(0, t - (time.time() - t0)))</span>
<span class="gi">+    </span>
<span class="gi">+    pg.quit()</span>
<span class="gh">diff --git a/moviepy/video/io/sliders.py b/moviepy/video/io/sliders.py</span>
<span class="gh">index ac234a1..62a990f 100644</span>
<span class="gd">--- a/moviepy/video/io/sliders.py</span>
<span class="gi">+++ b/moviepy/video/io/sliders.py</span>
<span class="gu">@@ -15,4 +15,47 @@ def sliders(f, sliders_properties, wait_for_validation=False):</span>
<span class="w"> </span>                  { &#39;label&#39; :  &#39;depth&#39;,  &#39;valmin&#39;: 1 , &#39;valmax&#39;: 5 } ]
<span class="w"> </span>        inputExplorer(volume,intervals)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fig, ax = plt.subplots()</span>
<span class="gi">+    plt.subplots_adjust(left=0.25, bottom=0.25)</span>
<span class="gi">+    </span>
<span class="gi">+    # Hide the axes</span>
<span class="gi">+    ax.axis(&#39;off&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create sliders</span>
<span class="gi">+    sliders = []</span>
<span class="gi">+    for i, properties in enumerate(sliders_properties):</span>
<span class="gi">+        ax_slider = plt.axes([0.25, 0.1 + i * 0.05, 0.65, 0.03])</span>
<span class="gi">+        slider = Slider(ax=ax_slider, **properties)</span>
<span class="gi">+        sliders.append(slider)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create a text box to show the result</span>
<span class="gi">+    result_text = ax.text(0.5, 0.5, &#39;&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=20)</span>
<span class="gi">+    </span>
<span class="gi">+    # Update function</span>
<span class="gi">+    def update(val):</span>
<span class="gi">+        args = [slider.val for slider in sliders]</span>
<span class="gi">+        result = f(*args)</span>
<span class="gi">+        result_text.set_text(f&quot;Result: {result}&quot;)</span>
<span class="gi">+        fig.canvas.draw_idle()</span>
<span class="gi">+    </span>
<span class="gi">+    # Connect update function to sliders</span>
<span class="gi">+    for slider in sliders:</span>
<span class="gi">+        slider.on_changed(update)</span>
<span class="gi">+    </span>
<span class="gi">+    if wait_for_validation:</span>
<span class="gi">+        # Add a &quot;Validate&quot; button</span>
<span class="gi">+        validate_ax = plt.axes([0.8, 0.025, 0.1, 0.04])</span>
<span class="gi">+        validate_button = Button(validate_ax, &#39;Validate&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        def validate(event):</span>
<span class="gi">+            plt.close(fig)</span>
<span class="gi">+        </span>
<span class="gi">+        validate_button.on_clicked(validate)</span>
<span class="gi">+    </span>
<span class="gi">+    # Initial update</span>
<span class="gi">+    update(None)</span>
<span class="gi">+    </span>
<span class="gi">+    plt.show()</span>
<span class="gi">+    </span>
<span class="gi">+    # Return the final values</span>
<span class="gi">+    return [slider.val for slider in sliders]</span>
<span class="gh">diff --git a/moviepy/video/tools/credits.py b/moviepy/video/tools/credits.py</span>
<span class="gh">index ee5dfb2..fb8b414 100644</span>
<span class="gd">--- a/moviepy/video/tools/credits.py</span>
<span class="gi">+++ b/moviepy/video/tools/credits.py</span>
<span class="gu">@@ -70,4 +70,43 @@ def credits1(creditfile, width, stretch=30, color=&#39;white&#39;, stroke_color=</span>
<span class="w"> </span>                Music Supervisor    JEAN DIDIER

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Read and parse the credit file</span>
<span class="gi">+    with open(creditfile, &#39;r&#39;) as file:</span>
<span class="gi">+        lines = file.readlines()</span>
<span class="gi">+</span>
<span class="gi">+    credits = []</span>
<span class="gi">+    current_job = &quot;&quot;</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if line.startswith(&#39;#&#39;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif line.startswith(&#39;.blank&#39;):</span>
<span class="gi">+            credits.extend([&#39;&#39;] * int(line.split()[1]))</span>
<span class="gi">+        elif line.startswith(&#39;..&#39;):</span>
<span class="gi">+            current_job = line[2:]</span>
<span class="gi">+        elif line:</span>
<span class="gi">+            credits.append((current_job, line))</span>
<span class="gi">+</span>
<span class="gi">+    # Create text clips for each credit</span>
<span class="gi">+    text_clips = []</span>
<span class="gi">+    for i, credit in enumerate(credits):</span>
<span class="gi">+        if isinstance(credit, tuple):</span>
<span class="gi">+            job, name = credit</span>
<span class="gi">+            job_clip = TextClip(job, fontsize=fontsize, font=font, color=color, stroke_color=stroke_color, stroke_width=stroke_width)</span>
<span class="gi">+            name_clip = TextClip(name, fontsize=fontsize, font=font, color=color, stroke_color=stroke_color, stroke_width=stroke_width)</span>
<span class="gi">+            </span>
<span class="gi">+            job_clip = job_clip.on_color(size=(job_clip.w + gap, job_clip.h), color=(0,0,0,0), pos=(&#39;right&#39;, &#39;center&#39;))</span>
<span class="gi">+            name_clip = name_clip.on_color(size=(name_clip.w, name_clip.h), color=(0,0,0,0), pos=(&#39;left&#39;, &#39;center&#39;))</span>
<span class="gi">+            </span>
<span class="gi">+            combined = CompositeVideoClip([job_clip, name_clip.set_position((job_clip.w, 0))])</span>
<span class="gi">+            text_clips.append(combined.set_position((&#39;center&#39;, i * stretch)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            text_clips.append(TextClip(&quot; &quot;, size=(width, fontsize), color=(0,0,0,0)))</span>
<span class="gi">+</span>
<span class="gi">+    # Combine all text clips</span>
<span class="gi">+    final_clip = CompositeVideoClip(text_clips, size=(width, len(credits) * stretch))</span>
<span class="gi">+    </span>
<span class="gi">+    # Resize to desired width</span>
<span class="gi">+    final_clip = resize(final_clip, width=width)</span>
<span class="gi">+    </span>
<span class="gi">+    return final_clip</span>
<span class="gh">diff --git a/moviepy/video/tools/cuts.py b/moviepy/video/tools/cuts.py</span>
<span class="gh">index 9587e45..01527eb 100644</span>
<span class="gd">--- a/moviepy/video/tools/cuts.py</span>
<span class="gi">+++ b/moviepy/video/tools/cuts.py</span>
<span class="gu">@@ -8,7 +8,27 @@ from moviepy.decorators import use_clip_fps_by_default</span>
<span class="w"> </span>@use_clip_fps_by_default
<span class="w"> </span>def find_video_period(clip, fps=None, tmin=0.3):
<span class="w"> </span>    &quot;&quot;&quot; Finds the period of a video based on frames correlation &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fps is None:</span>
<span class="gi">+        fps = clip.fps</span>
<span class="gi">+</span>
<span class="gi">+    frame_duration = 1.0 / fps</span>
<span class="gi">+    n_frames = int(clip.duration * fps)</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate correlation between frames</span>
<span class="gi">+    correlations = []</span>
<span class="gi">+    for i in range(1, n_frames):</span>
<span class="gi">+        frame1 = clip.get_frame(i * frame_duration)</span>
<span class="gi">+        frame2 = clip.get_frame((i + 1) * frame_duration)</span>
<span class="gi">+        correlation = np.corrcoef(frame1.flatten(), frame2.flatten())[0, 1]</span>
<span class="gi">+        correlations.append(correlation)</span>
<span class="gi">+</span>
<span class="gi">+    # Find peaks in correlation</span>
<span class="gi">+    peaks = [i for i in range(1, len(correlations) - 1) if correlations[i - 1] &lt; correlations[i] &gt; correlations[i + 1]]</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate periods</span>
<span class="gi">+    periods = [peak * frame_duration for peak in peaks if peak * frame_duration &gt;= tmin]</span>
<span class="gi">+</span>
<span class="gi">+    return periods[0] if periods else None</span>


<span class="w"> </span>class FramesMatch:
<span class="gu">@@ -66,14 +86,17 @@ class FramesMatches(list):</span>
<span class="w"> </span>        &gt;&gt;&gt; # Only keep the matches corresponding to (&gt; 1 second) sequences.
<span class="w"> </span>        &gt;&gt;&gt; new_matches = matches.filter( lambda match: match.time_span &gt; 1)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return FramesMatches([match for match in self if cond(match)])</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def load(filename):
<span class="w"> </span>        &quot;&quot;&quot; Loads a FramesMatches object from a file.
<span class="w"> </span>        &gt;&gt;&gt; matching_frames = FramesMatches.load(&quot;somefile&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import json</span>
<span class="gi">+        with open(filename, &#39;r&#39;) as f:</span>
<span class="gi">+            data = json.load(f)</span>
<span class="gi">+        return FramesMatches([FramesMatch(*match) for match in data])</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_clip(clip, dist_thr, max_d, fps=None):
<span class="gu">@@ -114,7 +137,23 @@ class FramesMatches(list):</span>
<span class="w"> </span>          Frames per second (default will be clip.fps)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = clip.fps</span>
<span class="gi">+</span>
<span class="gi">+        duration = clip.duration</span>
<span class="gi">+        n_frames = int(duration * fps)</span>
<span class="gi">+        frames = [clip.get_frame(t) for t in np.arange(0, duration, 1/fps)]</span>
<span class="gi">+</span>
<span class="gi">+        matches = []</span>
<span class="gi">+        for i in range(n_frames):</span>
<span class="gi">+            for j in range(i + 1, n_frames):</span>
<span class="gi">+                if (j - i) / fps &gt; max_d:</span>
<span class="gi">+                    break</span>
<span class="gi">+                dist = np.mean((frames[i] - frames[j]) ** 2)</span>
<span class="gi">+                if dist &lt; dist_thr:</span>
<span class="gi">+                    matches.append(FramesMatch(i/fps, j/fps, dist, dist))</span>
<span class="gi">+</span>
<span class="gi">+        return FramesMatches(matches)</span>

<span class="w"> </span>    def select_scenes(self, match_thr, min_time_span, nomatch_thr=None,
<span class="w"> </span>        time_distance=0):
<span class="gu">@@ -131,12 +170,22 @@ class FramesMatches(list):</span>
<span class="w"> </span>          If None, then it is chosen equal to match_thr

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if nomatch_thr is None:</span>
<span class="gi">+            nomatch_thr = match_thr</span>
<span class="gi">+</span>
<span class="gi">+        selected = []</span>
<span class="gi">+        for match in self:</span>
<span class="gi">+            if match.time_span &lt; min_time_span:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if match.d_min &lt;= match_thr and match.d_max &lt;= nomatch_thr:</span>
<span class="gi">+                if not selected or match.t1 - selected[-1].t2 &gt;= time_distance:</span>
<span class="gi">+                    selected.append(match)</span>
<span class="gi">+</span>
<span class="gi">+        return FramesMatches(selected)</span>


<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def detect_scenes(clip=None, luminosities=None, thr=10, logger=&#39;bar&#39;, fps=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def detect_scenes(clip=None, luminosities=None, thr=10, logger=&#39;bar&#39;, fps=None):</span>
<span class="w"> </span>    &quot;&quot;&quot; Detects scenes of a clip based on luminosity changes.

<span class="w"> </span>    Note that for large clip this may take some time
<span class="gu">@@ -177,4 +226,32 @@ def detect_scenes(clip=None, luminosities=None, thr=10, logger=&#39;bar&#39;, fps=None</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from moviepy.video.io.progbar import progbar</span>
<span class="gi">+</span>
<span class="gi">+    if luminosities is None:</span>
<span class="gi">+        if clip is None:</span>
<span class="gi">+            raise ValueError(&quot;You must provide either a clip or luminosities&quot;)</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = clip.fps</span>
<span class="gi">+        </span>
<span class="gi">+        def luminosity(img):</span>
<span class="gi">+            return np.mean(img)</span>
<span class="gi">+        </span>
<span class="gi">+        luminosities = []</span>
<span class="gi">+        total = int(clip.duration * fps)</span>
<span class="gi">+        for i, frame in enumerate(clip.iter_frames(fps=fps, logger=logger)):</span>
<span class="gi">+            luminosities.append(luminosity(frame))</span>
<span class="gi">+            if logger == &#39;bar&#39;:</span>
<span class="gi">+                progbar(i, total)</span>
<span class="gi">+    </span>
<span class="gi">+    luminosities = np.array(luminosities)</span>
<span class="gi">+    differences = np.abs(np.diff(luminosities))</span>
<span class="gi">+    avg_difference = np.mean(differences)</span>
<span class="gi">+    threshold = thr * avg_difference</span>
<span class="gi">+    </span>
<span class="gi">+    scene_changes = np.where(differences &gt; threshold)[0]</span>
<span class="gi">+    scene_changes = np.concatenate(([0], scene_changes, [len(luminosities) - 1]))</span>
<span class="gi">+    </span>
<span class="gi">+    cuts = [(scene_changes[i] / fps, scene_changes[i+1] / fps) for i in range(len(scene_changes) - 1)]</span>
<span class="gi">+    </span>
<span class="gi">+    return cuts, luminosities</span>
<span class="gh">diff --git a/moviepy/video/tools/drawing.py b/moviepy/video/tools/drawing.py</span>
<span class="gh">index 262e880..2b5db1b 100644</span>
<span class="gd">--- a/moviepy/video/tools/drawing.py</span>
<span class="gi">+++ b/moviepy/video/tools/drawing.py</span>
<span class="gu">@@ -12,7 +12,35 @@ def blit(im1, im2, pos=None, mask=None, ismask=False):</span>
<span class="w"> </span>    ``mask`` if provided. If ``im1`` and ``im2`` are mask pictures
<span class="w"> </span>    (2D float arrays) then ``ismask`` must be ``True``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = (0, 0)</span>
<span class="gi">+    </span>
<span class="gi">+    x, y = pos</span>
<span class="gi">+    h1, w1 = im1.shape[:2]</span>
<span class="gi">+    h2, w2 = im2.shape[:2]</span>
<span class="gi">+    </span>
<span class="gi">+    x1, x2 = max(0, x), min(w2, x + w1)</span>
<span class="gi">+    y1, y2 = max(0, y), min(h2, y + h1)</span>
<span class="gi">+    </span>
<span class="gi">+    if x1 &gt;= x2 or y1 &gt;= y2:</span>
<span class="gi">+        return im2</span>
<span class="gi">+    </span>
<span class="gi">+    slice1 = im1[y1-y:y2-y, x1-x:x2-x]</span>
<span class="gi">+    slice2 = im2[y1:y2, x1:x2]</span>
<span class="gi">+    </span>
<span class="gi">+    if mask is None:</span>
<span class="gi">+        if ismask:</span>
<span class="gi">+            np.minimum(slice2, slice1, out=slice2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            slice2[:] = slice1</span>
<span class="gi">+    else:</span>
<span class="gi">+        mask = mask[y1-y:y2-y, x1-x:x2-x]</span>
<span class="gi">+        if ismask:</span>
<span class="gi">+            np.minimum(slice2, slice1 * mask + slice2 * (1 - mask), out=slice2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            slice2[:] = slice1 * mask + slice2 * (1 - mask)</span>
<span class="gi">+    </span>
<span class="gi">+    return im2</span>


<span class="w"> </span>def color_gradient(size, p1, p2=None, vector=None, r=None, col1=0, col2=1.0,
<span class="gu">@@ -79,7 +107,55 @@ def color_gradient(size, p1, p2=None, vector=None, r=None, col1=0, col2=1.0,</span>
<span class="w"> </span>    &gt;&gt;&gt; grad = color_gradient(blabla).astype(&#39;uint8&#39;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = size</span>
<span class="gi">+    </span>
<span class="gi">+    if vector is not None:</span>
<span class="gi">+        p2 = (p1[0] + vector[0], p1[1] + vector[1])</span>
<span class="gi">+    </span>
<span class="gi">+    if shape == &#39;linear&#39;:</span>
<span class="gi">+        X, Y = np.meshgrid(np.arange(w), np.arange(h))</span>
<span class="gi">+        if p2 is None:</span>
<span class="gi">+            p2 = (w-1, h-1)</span>
<span class="gi">+        </span>
<span class="gi">+        vx, vy = p2[0] - p1[0], p2[1] - p1[1]</span>
<span class="gi">+        D = np.sqrt(vx**2 + vy**2)</span>
<span class="gi">+        </span>
<span class="gi">+        t = ((X - p1[0]) * vx + (Y - p1[1]) * vy) / (D**2)</span>
<span class="gi">+        t = np.clip((t - offset) / (1 - offset), 0, 1)</span>
<span class="gi">+        </span>
<span class="gi">+    elif shape == &#39;bilinear&#39;:</span>
<span class="gi">+        X, Y = np.meshgrid(np.arange(w), np.arange(h))</span>
<span class="gi">+        if p2 is None:</span>
<span class="gi">+            p2 = (w-1, h-1)</span>
<span class="gi">+        </span>
<span class="gi">+        vx, vy = p2[0] - p1[0], p2[1] - p1[1]</span>
<span class="gi">+        D = np.sqrt(vx**2 + vy**2)</span>
<span class="gi">+        </span>
<span class="gi">+        t1 = ((X - p1[0]) * vx + (Y - p1[1]) * vy) / (D**2)</span>
<span class="gi">+        t2 = ((X - p1[0]) * vy - (Y - p1[1]) * vx) / (D**2)</span>
<span class="gi">+        t = np.maximum(np.abs(t1), np.abs(t2))</span>
<span class="gi">+        t = np.clip((t - offset) / (1 - offset), 0, 1)</span>
<span class="gi">+        </span>
<span class="gi">+    elif shape == &#39;circular&#39;:</span>
<span class="gi">+        X, Y = np.meshgrid(np.arange(w), np.arange(h))</span>
<span class="gi">+        if r is None:</span>
<span class="gi">+            if p2 is None:</span>
<span class="gi">+                r = np.sqrt(w**2 + h**2) / 2</span>
<span class="gi">+            else:</span>
<span class="gi">+                r = np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)</span>
<span class="gi">+        </span>
<span class="gi">+        t = np.sqrt(((X - p1[0])**2 + (Y - p1[1])**2)) / r</span>
<span class="gi">+        t = np.clip((t - offset) / (1 - offset), 0, 1)</span>
<span class="gi">+    </span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;shape must be &#39;linear&#39;, &#39;bilinear&#39;, or &#39;circular&#39;&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(col1, (int, float)) and isinstance(col2, (int, float)):</span>
<span class="gi">+        return col1 * (1-t) + col2 * t</span>
<span class="gi">+    else:</span>
<span class="gi">+        col1 = np.array(col1)</span>
<span class="gi">+        col2 = np.array(col2)</span>
<span class="gi">+        return col1[None, None, :] * (1-t)[..., None] + col2[None, None, :] * t[..., None]</span>


<span class="w"> </span>def color_split(size, x=None, y=None, p1=None, p2=None, vector=None, col1=0,
<span class="gu">@@ -129,7 +205,50 @@ def color_split(size, x=None, y=None, p1=None, p2=None, vector=None, col1=0,</span>
<span class="w"> </span>    &gt;&gt;&gt; color_split(size, p1=[20,50], p2=[25,70] col1=0, col2=1)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = size</span>
<span class="gi">+    shape = (h, w) if np.isscalar(col1) else (h, w, len(col1))</span>
<span class="gi">+    img = np.zeros(shape)</span>
<span class="gi">+    </span>
<span class="gi">+    if x is not None:</span>
<span class="gi">+        if grad_width == 0:</span>
<span class="gi">+            img[:, :int(x)] = col1</span>
<span class="gi">+            img[:, int(x):] = col2</span>
<span class="gi">+        else:</span>
<span class="gi">+            x_arr = np.arange(w)</span>
<span class="gi">+            t = np.clip((x_arr - x + grad_width/2) / grad_width, 0, 1)</span>
<span class="gi">+            img = col1 * (1-t)[None, :] + col2 * t[None, :]</span>
<span class="gi">+    </span>
<span class="gi">+    elif y is not None:</span>
<span class="gi">+        if grad_width == 0:</span>
<span class="gi">+            img[:int(y), :] = col1</span>
<span class="gi">+            img[int(y):, :] = col2</span>
<span class="gi">+        else:</span>
<span class="gi">+            y_arr = np.arange(h)</span>
<span class="gi">+            t = np.clip((y_arr - y + grad_width/2) / grad_width, 0, 1)</span>
<span class="gi">+            img = col1 * (1-t)[:, None] + col2 * t[:, None]</span>
<span class="gi">+    </span>
<span class="gi">+    else:</span>
<span class="gi">+        if vector is not None:</span>
<span class="gi">+            p2 = (p1[0] + vector[0], p1[1] + vector[1])</span>
<span class="gi">+        </span>
<span class="gi">+        if p1 is not None and p2 is not None:</span>
<span class="gi">+            X, Y = np.meshgrid(np.arange(w), np.arange(h))</span>
<span class="gi">+            </span>
<span class="gi">+            vx, vy = p2[0] - p1[0], p2[1] - p1[1]</span>
<span class="gi">+            norm = np.sqrt(vx**2 + vy**2)</span>
<span class="gi">+            </span>
<span class="gi">+            nx, ny = -vy/norm, vx/norm</span>
<span class="gi">+            </span>
<span class="gi">+            d = nx * (X - p1[0]) + ny * (Y - p1[1])</span>
<span class="gi">+            </span>
<span class="gi">+            if grad_width == 0:</span>
<span class="gi">+                img[d &lt; 0] = col1</span>
<span class="gi">+                img[d &gt;= 0] = col2</span>
<span class="gi">+            else:</span>
<span class="gi">+                t = np.clip((d + grad_width/2) / grad_width, 0, 1)</span>
<span class="gi">+                img = col1 * (1-t)[..., None] + col2 * t[..., None]</span>
<span class="gi">+    </span>
<span class="gi">+    return img</span>


<span class="w"> </span>def circle(screensize, center, radius, col1=1.0, col2=0, blur=1):
<span class="gu">@@ -140,4 +259,16 @@ def circle(screensize, center, radius, col1=1.0, col2=0, blur=1):</span>
<span class="w"> </span>    with a radius ``radius`` but slightly blurred on the border by ``blur``
<span class="w"> </span>    pixels
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w, h = screensize</span>
<span class="gi">+    X, Y = np.meshgrid(np.arange(w), np.arange(h))</span>
<span class="gi">+    </span>
<span class="gi">+    cx, cy = center</span>
<span class="gi">+    dist = np.sqrt((X - cx)**2 + (Y - cy)**2)</span>
<span class="gi">+    </span>
<span class="gi">+    if blur == 0:</span>
<span class="gi">+        img = np.where(dist &lt;= radius, col1, col2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        t = np.clip((dist - radius + blur/2) / blur, 0, 1)</span>
<span class="gi">+        img = col1 * (1-t) + col2 * t</span>
<span class="gi">+    </span>
<span class="gi">+    return img</span>
<span class="gh">diff --git a/moviepy/video/tools/segmenting.py b/moviepy/video/tools/segmenting.py</span>
<span class="gh">index 39b1c9e..61113b9 100644</span>
<span class="gd">--- a/moviepy/video/tools/segmenting.py</span>
<span class="gi">+++ b/moviepy/video/tools/segmenting.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import scipy.ndimage as ndi
<span class="w"> </span>from moviepy.video.VideoClip import ImageClip
<span class="gi">+import cv2</span>
<span class="gi">+import matplotlib.pyplot as plt</span>


<span class="w"> </span>def findObjects(clip, rem_thr=500, preview=False):
<span class="gu">@@ -12,4 +14,47 @@ def findObjects(clip, rem_thr=500, preview=False):</span>
<span class="w"> </span>         considered false positives and will be removed

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the first frame of the clip</span>
<span class="gi">+    first_frame = clip.get_frame(0)</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert to grayscale if it&#39;s a color image</span>
<span class="gi">+    if len(first_frame.shape) == 3:</span>
<span class="gi">+        gray_frame = np.mean(first_frame, axis=2).astype(np.uint8)</span>
<span class="gi">+    else:</span>
<span class="gi">+        gray_frame = first_frame.astype(np.uint8)</span>
<span class="gi">+    </span>
<span class="gi">+    # Apply threshold to create a binary image</span>
<span class="gi">+    _, binary = cv2.threshold(gray_frame, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span>
<span class="gi">+    </span>
<span class="gi">+    # Find connected components</span>
<span class="gi">+    labeled, num_objects = ndi.label(binary)</span>
<span class="gi">+    </span>
<span class="gi">+    # Get object properties</span>
<span class="gi">+    objects = ndi.find_objects(labeled)</span>
<span class="gi">+    </span>
<span class="gi">+    # Filter objects based on size and create ImageClips</span>
<span class="gi">+    object_clips = []</span>
<span class="gi">+    for i, obj in enumerate(objects):</span>
<span class="gi">+        if obj is not None:</span>
<span class="gi">+            obj_size = (obj[0].stop - obj[0].start) * (obj[1].stop - obj[1].start)</span>
<span class="gi">+            if obj_size &gt;= rem_thr:</span>
<span class="gi">+                obj_frame = first_frame[obj[0], obj[1]]</span>
<span class="gi">+                obj_clip = ImageClip(obj_frame)</span>
<span class="gi">+                object_clips.append(obj_clip)</span>
<span class="gi">+    </span>
<span class="gi">+    if preview:</span>
<span class="gi">+        # Create a preview image with bounding boxes</span>
<span class="gi">+        preview_frame = first_frame.copy()</span>
<span class="gi">+        for obj in objects:</span>
<span class="gi">+            if obj is not None:</span>
<span class="gi">+                y_start, y_end = obj[0].start, obj[0].stop</span>
<span class="gi">+                x_start, x_end = obj[1].start, obj[1].stop</span>
<span class="gi">+                cv2.rectangle(preview_frame, (x_start, y_start), (x_end, y_end), (0, 255, 0), 2)</span>
<span class="gi">+        </span>
<span class="gi">+        # Display the preview</span>
<span class="gi">+        plt.imshow(preview_frame)</span>
<span class="gi">+        plt.title(&quot;Objects Found&quot;)</span>
<span class="gi">+        plt.axis(&#39;off&#39;)</span>
<span class="gi">+        plt.show()</span>
<span class="gi">+    </span>
<span class="gi">+    return object_clips</span>
<span class="gh">diff --git a/moviepy/video/tools/subtitles.py b/moviepy/video/tools/subtitles.py</span>
<span class="gh">index b191e4d..f35777a 100644</span>
<span class="gd">--- a/moviepy/video/tools/subtitles.py</span>
<span class="gi">+++ b/moviepy/video/tools/subtitles.py</span>
<span class="gu">@@ -80,7 +80,17 @@ class SubtitlesClip(VideoClip):</span>
<span class="w"> </span>        &quot;&quot;&quot; Returns a sequence of [(t1,t2), txt] covering all the given subclip
<span class="w"> </span>        from t_start to t_end. The first and last times will be cropped so as
<span class="w"> </span>        to be exactly t_start and t_end if possible. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if t_start is None:</span>
<span class="gi">+            t_start = 0</span>
<span class="gi">+        if t_end is None:</span>
<span class="gi">+            t_end = self.duration</span>
<span class="gi">+        </span>
<span class="gi">+        def crop_time(t):</span>
<span class="gi">+            return max(t_start, min(t, t_end))</span>
<span class="gi">+</span>
<span class="gi">+        return [((crop_time(ta), crop_time(tb)), txt) </span>
<span class="gi">+                for ((ta, tb), txt) in self.subtitles </span>
<span class="gi">+                if ta &lt; t_end and tb &gt; t_start]</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return iter(self.subtitles)
<span class="gu">@@ -106,4 +116,29 @@ def file_to_subtitles(filename):</span>

<span class="w"> </span>    Only works for &#39;.srt&#39; format for the moment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def time_to_seconds(time_str):</span>
<span class="gi">+        h, m, s = time_str.split(&#39;:&#39;)</span>
<span class="gi">+        return int(h) * 3600 + int(m) * 60 + float(s.replace(&#39;,&#39;, &#39;.&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    subtitles = []</span>
<span class="gi">+    current_sub = None</span>
<span class="gi">+    with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+        for line in f:</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            if line.isdigit():</span>
<span class="gi">+                if current_sub:</span>
<span class="gi">+                    subtitles.append(current_sub)</span>
<span class="gi">+                current_sub = None</span>
<span class="gi">+            elif &#39;--&gt;&#39; in line:</span>
<span class="gi">+                start, end = line.split(&#39;--&gt;&#39;)</span>
<span class="gi">+                ta = time_to_seconds(start.strip())</span>
<span class="gi">+                tb = time_to_seconds(end.strip())</span>
<span class="gi">+                current_sub = ((ta, tb), &#39;&#39;)</span>
<span class="gi">+            elif line:</span>
<span class="gi">+                if current_sub:</span>
<span class="gi">+                    current_sub = (current_sub[0], current_sub[1] + line + &#39;\n&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    if current_sub:</span>
<span class="gi">+        subtitles.append(current_sub)</span>
<span class="gi">+    </span>
<span class="gi">+    return subtitles</span>
<span class="gh">diff --git a/moviepy/video/tools/tracking.py b/moviepy/video/tools/tracking.py</span>
<span class="gh">index f52522c..2ec0221 100644</span>
<span class="gd">--- a/moviepy/video/tools/tracking.py</span>
<span class="gi">+++ b/moviepy/video/tools/tracking.py</span>
<span class="gu">@@ -20,8 +20,7 @@ except:</span>

<span class="w"> </span>@convert_to_seconds([&#39;t1&#39;, &#39;t2&#39;])
<span class="w"> </span>@use_clip_fps_by_default
<span class="gd">-def manual_tracking(clip, t1=None, t2=None, fps=None, nobjects=1, savefile=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def manual_tracking(clip, t1=None, t2=None, fps=None, nobjects=1, savefile=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Allows manual tracking of an object(s) in the video clip between
<span class="w"> </span>    times `t1` and `t2`. This displays the clip frame by frame
<span class="gu">@@ -66,7 +65,51 @@ def manual_tracking(clip, t1=None, t2=None, fps=None, nobjects=1, savefile=None</span>
<span class="w"> </span>    &gt;&gt;&gt; traj, =  Trajectory.load_list(&#39;track.txt&#39;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import pygame</span>
<span class="gi">+    </span>
<span class="gi">+    if t1 is None:</span>
<span class="gi">+        t1 = 0</span>
<span class="gi">+    if t2 is None:</span>
<span class="gi">+        t2 = clip.duration</span>
<span class="gi">+    if fps is None:</span>
<span class="gi">+        fps = clip.fps</span>
<span class="gi">+    </span>
<span class="gi">+    screen = None</span>
<span class="gi">+    positions = []</span>
<span class="gi">+    </span>
<span class="gi">+    for t in np.arange(t1, t2, 1/fps):</span>
<span class="gi">+        frame = clip.get_frame(t)</span>
<span class="gi">+        if screen is None:</span>
<span class="gi">+            screen = pygame.display.set_mode(frame.shape[:2][::-1])</span>
<span class="gi">+        </span>
<span class="gi">+        surf = pygame.surfarray.make_surface(frame.swapaxes(0, 1))</span>
<span class="gi">+        screen.blit(surf, (0, 0))</span>
<span class="gi">+        pygame.display.flip()</span>
<span class="gi">+        </span>
<span class="gi">+        frame_positions = []</span>
<span class="gi">+        for _ in range(nobjects):</span>
<span class="gi">+            while True:</span>
<span class="gi">+                for event in pygame.event.get():</span>
<span class="gi">+                    if event.type == pygame.MOUSEBUTTONDOWN:</span>
<span class="gi">+                        x, y = event.pos</span>
<span class="gi">+                        frame_positions.append((x, y))</span>
<span class="gi">+                        if len(frame_positions) == nobjects:</span>
<span class="gi">+                            break</span>
<span class="gi">+                if len(frame_positions) == nobjects:</span>
<span class="gi">+                    break</span>
<span class="gi">+        </span>
<span class="gi">+        if nobjects == 1:</span>
<span class="gi">+            positions.append((t, frame_positions[0][0], frame_positions[0][1]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            positions.append((t, frame_positions))</span>
<span class="gi">+    </span>
<span class="gi">+    pygame.quit()</span>
<span class="gi">+    </span>
<span class="gi">+    if savefile:</span>
<span class="gi">+        with open(savefile, &#39;w&#39;) as f:</span>
<span class="gi">+            json.dump(positions, f)</span>
<span class="gi">+    </span>
<span class="gi">+    return positions</span>


<span class="w"> </span>def findAround(pic, pat, xy=None, r=None):
<span class="gu">@@ -74,7 +117,26 @@ def findAround(pic, pat, xy=None, r=None):</span>
<span class="w"> </span>    find image pattern ``pat`` in ``pic[x +/- r, y +/- r]``.
<span class="w"> </span>    if xy is none, consider the whole picture.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not autotracking_possible:</span>
<span class="gi">+        raise ImportError(&quot;OpenCV is required for autotracking&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if xy is None:</span>
<span class="gi">+        return cv2.matchTemplate(pic, pat, cv2.TM_CCOEFF_NORMED)</span>
<span class="gi">+    </span>
<span class="gi">+    h, w = pat.shape[:2]</span>
<span class="gi">+    x, y = xy</span>
<span class="gi">+    </span>
<span class="gi">+    if r is None:</span>
<span class="gi">+        r = max(h, w)</span>
<span class="gi">+    </span>
<span class="gi">+    x1, x2 = max(x - r, 0), min(x + r + w, pic.shape[1])</span>
<span class="gi">+    y1, y2 = max(y - r, 0), min(y + r + h, pic.shape[0])</span>
<span class="gi">+    </span>
<span class="gi">+    region = pic[y1:y2, x1:x2]</span>
<span class="gi">+    result = cv2.matchTemplate(region, pat, cv2.TM_CCOEFF_NORMED)</span>
<span class="gi">+    </span>
<span class="gi">+    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)</span>
<span class="gi">+    return (x1 + max_loc[0], y1 + max_loc[1]), max_val</span>


<span class="w"> </span>def autoTrack(clip, pattern, tt=None, fps=None, radius=20, xy0=None):
<span class="gu">@@ -90,4 +152,24 @@ def autoTrack(clip, pattern, tt=None, fps=None, radius=20, xy0=None):</span>
<span class="w"> </span>    to -1 the pattern will be searched in the whole screen at each frame).
<span class="w"> </span>    You can also provide the original position of the pattern with xy0.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not autotracking_possible:</span>
<span class="gi">+        raise ImportError(&quot;OpenCV is required for autotracking&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if tt is None:</span>
<span class="gi">+        if fps is None:</span>
<span class="gi">+            fps = clip.fps</span>
<span class="gi">+        tt = np.arange(0, clip.duration, 1.0/fps)</span>
<span class="gi">+    </span>
<span class="gi">+    positions = []</span>
<span class="gi">+    </span>
<span class="gi">+    for t in tt:</span>
<span class="gi">+        frame = clip.get_frame(t)</span>
<span class="gi">+        if xy0 is None:</span>
<span class="gi">+            xy, max_corr = findAround(frame, pattern)</span>
<span class="gi">+        else:</span>
<span class="gi">+            xy, max_corr = findAround(frame, pattern, xy=xy0, r=radius)</span>
<span class="gi">+        </span>
<span class="gi">+        xy0 = xy</span>
<span class="gi">+        positions.append(xy)</span>
<span class="gi">+    </span>
<span class="gi">+    return list(zip(tt, positions))</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>