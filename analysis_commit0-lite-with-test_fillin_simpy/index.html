
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 lite with test fillin simpy - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-unit-test-feedback-simpy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 lite with test fillin simpy
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and_blocked" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and_blocked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_nested_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_nested_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_event_queue_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_event_queue_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_resume" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_resume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_processed_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_processed_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_fail" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_triggered" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_triggered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_nested_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_nested_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_error_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_error_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_crashing_child_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_crashing_child_traceback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_invalid_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_invalid_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_sys_excepthook" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_sys_excepthook
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_init_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_init_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_terminated_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_terminated_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_multiple_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_multiple_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_self" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_self
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_immediate_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_immediate_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_get_state" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_get_state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_return_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_return_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_error_and_interrupted_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_error_and_interrupted_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_slots" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_slots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_immediate_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_immediate_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_cm_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_cm_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_priority_queue" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_priority_queue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_sorted_queue_maxlen" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_sorted_queue_maxlen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_get_users" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_get_users
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource_timeout_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource_timeout_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_mixed_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_mixed_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_nested_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_nested_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container_get_queued" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container_get_queued
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_capacity" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_capacity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_cancel" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_cancel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_item_priority" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_item_priority
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_stable_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_stable_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store_get_after_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store_get_after_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_best_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_best_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_worst_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_worst_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_put_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_put_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_get_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_get_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt01" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt005" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.05]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt015" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_multiple_call" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_multiple_call
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_default_behavior" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_default_behavior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_no_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_sync" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_sync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_discrete_time_steps" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_discrete_time_steps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout_with_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout_with_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_wait_for_all_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_wait_for_all_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining_intermediate_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining_intermediate_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_triggered_events
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-lite-with-test_fillin">back to Claude Sonnet 3.5 - Fill-in + Unit Test Feedback summary</a></p>
<h1 id="claude-sonnet-35-fill-in-unit-test-feedback-simpy"><strong>Claude Sonnet 3.5 - Fill-in + Unit Test Feedback</strong>: simpy</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">73</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">67</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_conditionpytest_operator_and_blocked">test_condition.py::test_operator_and_blocked</h3>
<details><summary> <pre>test_condition.py::test_operator_and_blocked</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610ecfeb0>

    def test_operator_and_blocked(env):
        def process(env):
            timeout = env.timeout(1)
            event = env.event()
            yield env.timeout(1)

            condition = timeout & event
            assert not condition.triggered

        env.process(process(env))
>       env.run()

tests/test_condition.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610ecfeb0>

    def process(env):
        timeout = env.timeout(1)
        event = env.event()
        yield env.timeout(1)

        condition = timeout & event
>       assert not condition.triggered
E       assert not True
E        +  where True = <Condition(all_events, (<Timeout(1) object at 0x7fc610ece0b0>, <Event() object at 0x7fc610ecf700>)) object at 0x7fc610ecc940>.triggered

tests/test_condition.py:26: AssertionError
</pre>
</details>
<h3 id="test_conditionpytest_nested_cond_with_error">test_condition.py::test_nested_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_nested_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc61110a050>

    def test_nested_cond_with_error(env):
        def explode(env):
            yield env.timeout(1)
            raise ValueError('Onoes!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(explode(env)) & env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc61110a050>

    def explode(env):
        yield env.timeout(1)
>       raise ValueError('Onoes!')
E       ValueError: Onoes!

tests/test_condition.py:79: ValueError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_error">test_condition.py::test_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610e9f1c0>

    def test_cond_with_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610e9f1c0>, delay = 0

    def explode(env, delay):
        yield env.timeout(delay)
>       raise ValueError(f'Onoes, failed after {delay}!')
E       ValueError: Onoes, failed after 0!

tests/test_condition.py:92: ValueError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_nested_error">test_condition.py::test_cond_with_nested_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_nested_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610e68790>

    def test_cond_with_nested_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) & env.timeout(1) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610e68790>, delay = 0

    def explode(env, delay):
        yield env.timeout(delay)
>       raise ValueError(f'Onoes, failed after {delay}!')
E       ValueError: Onoes, failed after 0!

tests/test_condition.py:105: ValueError
</pre>
</details>
<h3 id="test_environmentpytest_event_queue_empty">test_environment.py::test_event_queue_empty</h3>
<details><summary> <pre>test_environment.py::test_event_queue_empty</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610ece590>, log = [0, 1, 1]

    def test_event_queue_empty(env, log):
        """The simulation should stop if there are no more events, that means, no
        more active process."""

        def pem(env, log):
            while env.now < 2:
                log.append(env.now)
                yield env.timeout(1)

        env.process(pem(env, log))
        env.run(10)

>       assert log == [0, 1]
E       assert [0, 1, 1] == [0, 1]
E         
E         Left contains one more item: 1
E         Use -v to get more diff

tests/test_environment.py:21: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_run_resume">test_environment.py::test_run_resume</h3>
<details><summary> <pre>test_environment.py::test_run_resume</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610e688e0>

    def test_run_resume(env):
        """Stopped simulation can be resumed."""
        events = [env.timeout(t) for t in (5, 10, 15)]

        assert env.now == 0
        assert not any(event.processed for event in events)

        env.run(until=10)
        assert env.now == 10
>       assert all(event.processed for event in events[:1])
E       assert False
E        +  where False = all(<generator object test_run_resume.<locals>.<genexpr> at 0x7fc61004d930>)

tests/test_environment.py:41: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_processed_event">test_environment.py::test_run_with_processed_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_processed_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610975c30>

    def test_run_with_processed_event(env):
        """An already processed event may also be passed as until value."""
        timeout = env.timeout(1, value='spam')
        assert env.run(until=timeout) == 'spam'
>       assert env.now == 1
E       AssertionError: assert 'spam' == 1
E        +  where 'spam' = <simpy.core.Environment object at 0x7fc610975c30>.now

tests/test_environment.py:64: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_fail">test_event.py::test_fail</h3>
<details><summary> <pre>test_event.py::test_fail</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ffef220>
event = <Event() object at 0x7fc60ffef5e0>

    def child(env, event):
        with pytest.raises(ValueError, match='ohai'):
>           yield event
E           ValueError: ohai

tests/test_event.py:34: ValueError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc60ffef220>

    def test_fail(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            with pytest.raises(ValueError, match='ohai'):
                yield event
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.fail(ValueError('ohai'))

        env.process(parent(env))
>       env.run()

tests/test_event.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(child) object at 0x7fc60ffeea70>, exception = ValueError('ohai')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError
</pre>
</details>
<h3 id="test_eventpytest_triggered">test_event.py::test_triggered</h3>
<details><summary> <pre>test_event.py::test_triggered</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610c1b2e0>

    def test_triggered(env):
        def pem(env, event):
            value = yield event
            return value

        event = env.event()
        event.succeed('i was already done')

        result = env.run(env.process(pem(env, event)))

>       assert result == 'i was already done'
E       AssertionError: assert None == 'i was already done'

tests/test_event.py:96: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_condition_callback_removal">test_event.py::test_condition_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610d649a0>

    def test_condition_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events."""
        a, b = env.event(), env.event()
        a.succeed()
        env.run(until=a | b)
        # The condition has removed its callback from event b.
>       assert not a.callbacks
E       assert not [<bound method Condition._check of <Condition(any_events, (<Event() object at 0x7fc610e688e0>, <Event() object at 0x7fc610e6bc70>)) object at 0x7fc610e684f0>>]
E        +  where [<bound method Condition._check of <Condition(any_events, (<Event() object at 0x7fc610e688e0>, <Event() object at 0x7fc610e6bc70>)) object at 0x7fc610e684f0>>] = <Event() object at 0x7fc610e688e0>.callbacks

tests/test_event.py:118: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_condition_nested_callback_removal">test_event.py::test_condition_nested_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_nested_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610c1a710>

    def test_condition_nested_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events (even
        if nested)."""
        a, b, c = env.event(), env.event(), env.event()
        b_and_c = b & c
        a_or_b_and_c = a | b_and_c
        a.succeed()
        env.run(until=a_or_b_and_c)
        # Callbacks from nested conditions are also removed.
>       assert not a.callbacks
E       assert not [<bound method Condition._check of <Condition(any_events, (<Event() object at 0x7fc610c1a3b0>, <Condition(all_events, ...object at 0x7fc610c18ca0>, <Event() object at 0x7fc610c1a0b0>)) object at 0x7fc610c1b370>)) object at 0x7fc610c18520>>]
E        +  where [<bound method Condition._check of <Condition(any_events, (<Event() object at 0x7fc610c1a3b0>, <Condition(all_events, ...object at 0x7fc610c18ca0>, <Event() object at 0x7fc610c1a0b0>)) object at 0x7fc610c1b370>)) object at 0x7fc610c18520>>] = <Event() object at 0x7fc610c1a3b0>.callbacks

tests/test_event.py:131: AssertionError
</pre>
</details>
<h3 id="test_exceptionspytest_error_forwarding">test_exceptions.py::test_error_forwarding</h3>
<details><summary> <pre>test_exceptions.py::test_error_forwarding</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc6111d4250>

    def parent(env):
        with pytest.raises(ValueError, match='Onoes!'):
>           yield env.process(child(env))

tests/test_exceptions.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc6111d4250>

    def child(env):
>       raise ValueError('Onoes!')
E       ValueError: Onoes!

tests/test_exceptions.py:20: ValueError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc6111d4250>

    def test_error_forwarding(env):
        """Exceptions are forwarded from child to parent processes if there
        are any.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(child(env))

        env.process(parent(env))
>       env.run()

tests/test_exceptions.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(parent) object at 0x7fc6111d5c30>
exception = ValueError('Onoes!')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError
</pre>
</details>
<h3 id="test_exceptionspytest_crashing_child_traceback">test_exceptions.py::test_crashing_child_traceback</h3>
<details><summary> <pre>test_exceptions.py::test_crashing_child_traceback</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610087970>

    def root(env):
        try:
>           yield env.process(panic(env))

tests/test_exceptions.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610087970>

    def panic(env):
        yield env.timeout(1)
>       raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')
E       RuntimeError: Oh noes, roflcopter incoming... BOOM!

tests/test_exceptions.py:56: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc610087970>

    def test_crashing_child_traceback(env):
        def panic(env):
            yield env.timeout(1)
            raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')

        def root(env):
            try:
                yield env.process(panic(env))
                pytest.fail("Hey, where's the roflcopter?")
            except RuntimeError:
                # The current frame must be visible in the stacktrace.
                stacktrace = traceback.format_exc()
                assert 'yield env.process(panic(env))' in stacktrace
                assert "raise RuntimeError('Oh noes," in stacktrace

        env.process(root(env))
>       env.run()

tests/test_exceptions.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(root) object at 0x7fc610087a60>
exception = RuntimeError('Oh noes, roflcopter incoming... BOOM!')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_chaining">test_exceptions.py::test_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610245c30>

    def parent(env):
        child_proc = env.process(child(env))
>       yield child_proc

tests/test_exceptions.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610245c30>

    def child(env):
        yield env.timeout(1)
>       raise RuntimeError('foo')
E       RuntimeError: foo

tests/test_exceptions.py:80: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc610245c30>

    def test_exception_chaining(env):
        """Unhandled exceptions pass through the entire event stack. This must be
        visible in the stacktrace of the exception.

        """

        def child(env):
            yield env.timeout(1)
            raise RuntimeError('foo')

        def parent(env):
            child_proc = env.process(child(env))
            yield child_proc

        def grandparent(env):
            parent_proc = env.process(parent(env))
            yield parent_proc

        env.process(grandparent(env))
        try:
>           env.run()

tests/test_exceptions.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(parent) object at 0x7fc6102462f0>
exception = RuntimeError('foo')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc610245c30>

    def test_exception_chaining(env):
        """Unhandled exceptions pass through the entire event stack. This must be
        visible in the stacktrace of the exception.

        """

        def child(env):
            yield env.timeout(1)
            raise RuntimeError('foo')

        def parent(env):
            child_proc = env.process(child(env))
            yield child_proc

        def grandparent(env):
            parent_proc = env.process(parent(env))
            yield parent_proc

        env.process(grandparent(env))
        try:
            env.run()
            pytest.fail('There should have been an exception')
        except RuntimeError:
            trace = traceback.format_exc()

            expected = (
                re.escape(
                    textwrap.dedent(
                        """\
            Traceback (most recent call last):
              File "{path}tests/test_exceptions.py", line {line}, in child
                raise RuntimeError('foo')
            RuntimeError: foo

            The above exception was the direct cause of the following exception:

            Traceback (most recent call last):
              File "{path}tests/test_exceptions.py", line {line}, in parent
                yield child_proc
            RuntimeError: foo

            The above exception was the direct cause of the following exception:

            Traceback (most recent call last):
              File "{path}tests/test_exceptions.py", line {line}, in grandparent
                yield parent_proc
            RuntimeError: foo

            The above exception was the direct cause of the following exception:

            Traceback (most recent call last):
              File "{path}tests/test_exceptions.py", line {line}, in test_exception_chaining
                env.run()
              File "{path}simpy/core.py", line {line}, in run
                self.step()
              File "{path}simpy/core.py", line {line}, in step
                raise exc
            RuntimeError: foo
            """
                    )
                )
                .replace(r'\{line\}', r'\d+')
                .replace(r'\{path\}', r'.*')
            )

            if platform.system() == 'Windows':
                expected = expected.replace(r'\/', r'\\')

>           assert re.match(expected, trace), 'Traceback mismatch'
E           AssertionError: Traceback mismatch
E           assert None
E            +  where None = <function match at 0x7fc6113d4e50>('Traceback\\ \\(most\\ recent\\ call\\ last\\):\\\n\\ \\ File\\ ".*tests/test_exceptions\\.py",\\ line\\ \\d+,\\ in\\ ...\\\n\\ \\ File\\ ".*simpy/core\\.py",\\ line\\ \\d+,\\ in\\ step\\\n\\ \\ \\ \\ raise\\ exc\\\nRuntimeError:\\ foo\\\n', 'Traceback (most recent call last):\n  File "/testbed/src/simpy/events.py", line 348, in _resume\n    next_event = sel...n fail\n    raise RuntimeError(\'Event has already been triggered\')\nRuntimeError: Event has already been triggered\n')
E            +    where <function match at 0x7fc6113d4e50> = re.match

tests/test_exceptions.py:140: AssertionError
</pre>
</details>
<h3 id="test_exceptionspytest_invalid_event">test_exceptions.py::test_invalid_event</h3>
<details><summary> <pre>test_exceptions.py::test_invalid_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc6111efca0>

    def test_invalid_event(env):
        """Invalid yield values will cause the simulation to fail."""

        def root(_):
            yield None

        env.process(root(env))
>       with pytest.raises(RuntimeError, match='Invalid yield value "None"'):
E       Failed: DID NOT RAISE <class 'RuntimeError'>

tests/test_exceptions.py:150: Failed
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_handling">test_exceptions.py::test_process_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_handling</pre></summary><pre>
_ = <simpy.core.Environment object at 0x7fc610edce80>
event = <Event() object at 0x7fc610ede2c0>

    def pem(_, event):
        try:
>           yield event
E           RuntimeError

tests/test_exceptions.py:184: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc610edce80>

    def test_process_exception_handling(env):
        """Processes can't ignore failed events and auto-handle exceptions."""

        def pem(_, event):
            try:
                yield event
                pytest.fail('Hey, the event should fail!')
            except RuntimeError:
                pass

        event = env.event()
        env.process(pem(env, event))
        event.fail(RuntimeError())

        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:293: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(pem) object at 0x7fc610edd480>, exception = RuntimeError()

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_chaining">test_exceptions.py::test_process_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_chaining</pre></summary><pre>
event = <Event() object at 0x7fc610df0400>

    def process_a(event):
        try:
>           yield event
E           RuntimeError: foo

tests/test_exceptions.py:208: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc610df2500>

    def test_process_exception_chaining(env):
        """Because multiple processes can be waiting for an event, exceptions of
        failed events are copied before being thrown into a process. Otherwise, the
        traceback of the exception gets modified by a process.

        See https://bitbucket.org/simpy/simpy/issue/60 for more details."""
        import traceback

        def process_a(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_b' not in stacktrace

        def process_b(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_a' not in stacktrace

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_a(event))
        env.process(process_b(event))

>       env.run()

tests/test_exceptions.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(process_a) object at 0x7fc610df04f0>
exception = RuntimeError('foo')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError
</pre>
</details>
<h3 id="test_exceptionspytest_sys_excepthook">test_exceptions.py::test_sys_excepthook</h3>
<details><summary> <pre>test_exceptions.py::test_sys_excepthook</pre></summary><pre>
event = <Event() object at 0x7fc610087c40>

    def process_a(event):
>       yield event
E       RuntimeError: foo

tests/test_exceptions.py:233: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc6100843a0>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
>           env.run()

tests/test_exceptions.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(process_a) object at 0x7fc610085570>
exception = RuntimeError('foo')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc6100843a0>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
            env.run()
        except BaseException:
            # Let the default exception hook print the traceback to the redirected
            # standard error channel.
            import sys
            from io import StringIO

            stderr, sys.stderr = sys.stderr, StringIO()

            typ, e, tb = sys.exc_info()
            assert typ is not None
            assert e is not None
            sys.excepthook(typ, e, tb)

            traceback = sys.stderr.getvalue()

            sys.stderr = stderr

            # Check if frames of process_a and process_b are visible in the
            # traceback.
            assert 'process_a' in traceback
>           assert 'process_b' in traceback
E           assert 'process_b' in 'Traceback (most recent call last):\n  File "/testbed/src/simpy/events.py", line 348, in _resume\n    next_event = sel...n fail\n    raise RuntimeError(\'Event has already been triggered\')\nRuntimeError: Event has already been triggered\n'

tests/test_exceptions.py:265: AssertionError
</pre>
</details>
<h3 id="test_interruptspytest_init_interrupt">test_interrupts.py::test_init_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_init_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610edd5a0>

    def test_init_interrupt(env):
        """An interrupt should always be executed after the Initialize event at the
        same time."""

        def child(env):
            try:
                yield env.timeout(10)
                pytest.fail('Should have been interrupted.')
            except simpy.Interrupt:
                assert env.now == 0

        def root(env):
            child_proc = env.process(child(env))
            child_proc.interrupt()

            yield env.timeout(1)

        env.process(root(env))
>       env.run()

tests/test_interrupts.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:348: in _resume
    next_event = self._generator.throw(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610edd5a0>

>   def child(env):
E   simpy.exceptions.Interrupt: Interrupt(None)

tests/test_interrupts.py:85: Interrupt
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_terminated_process">test_interrupts.py::test_interrupt_terminated_process</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_terminated_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610974280>

    def test_interrupt_terminated_process(env):
        """Dead processes cannot be interrupted."""

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))

            # Wait long enough so that child_proc terminates.
            yield env.timeout(2)
            ei = pytest.raises(RuntimeError, child_proc.interrupt)
            assert re.match(
                r'<Process\(child\) object at 0x.*> has terminated '
                r'and cannot be interrupted.',
                ei.value.args[0],
            )

            yield env.timeout(1)

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fc610974280>
event = <Process(parent) object at 0x7fc610974a60>

    def _process_event(self, event):
        event._processed = True
        if hasattr(event, '_callback'):
            try:
                event._value = event._callback(event)
            except BaseException as e:
                event._ok = False
                event._value = e
                if not event._defused:
                    self._handle_exception(e)

        if isinstance(event, Process):
            self._active_proc = event

        # Trigger all callbacks
        if event.callbacks:
            for callback in list(event.callbacks):
                try:
                    callback(event)
                except BaseException as e:
                    event._ok = False
                    event._value = e
                    if not event._defused:
                        raise  # Re-raise the exception to propagate it
            event.callbacks = None

        if isinstance(event, Process):
            self._active_proc = None

        # If the event is not ok (i.e., an exception occurred), raise it
        if not event._ok and not event._defused:
>           raise event._value
E           RuntimeError: Invalid exception: DID NOT RAISE <class 'RuntimeError'>

src/simpy/core.py:186: RuntimeError
</pre>
</details>
<h3 id="test_interruptspytest_multiple_interrupts">test_interrupts.py::test_multiple_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_multiple_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610c18fa0>

    def test_multiple_interrupts(env):
        """Interrupts on dead processes are discarded. If there are multiple
        concurrent interrupts on a process and the latter dies after
        handling the first interrupt, the remaining ones are silently
        ignored.

        """

        def child(env):
            try:
                yield env.timeout(1)
            except simpy.Interrupt as i:
                return i.cause

        def parent(env):
            c = env.process(child(env))
            yield env.timeout(0)
            c.interrupt(1)
            c.interrupt(2)
            result = yield c
            assert result == 1

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610c18fa0>

    def parent(env):
        c = env.process(child(env))
        yield env.timeout(0)
        c.interrupt(1)
        c.interrupt(2)
        result = yield c
>       assert result == 1
E       assert None == 1

tests/test_interrupts.py:146: AssertionError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_self">test_interrupts.py::test_interrupt_self</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_self</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc61092b880>

    def test_interrupt_self(env):
        """A process should not be able to interrupt itself."""

        def pem(env):
            pytest.raises(RuntimeError, env.active_process.interrupt)
            yield env.timeout(0)

        env.process(pem(env))
>       env.run()

tests/test_interrupts.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc61092b880>

    def pem(env):
>       pytest.raises(RuntimeError, env.active_process.interrupt)
E       AttributeError: 'NoneType' object has no attribute 'interrupt'

tests/test_interrupts.py:156: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_immediate_interrupt">test_interrupts.py::test_immediate_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_immediate_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ffecd00>, log = []

    def test_immediate_interrupt(env, log):
        """Processes are immediately interruptable."""

        def child(env, log):
            try:
                yield env.event()
            except simpy.Interrupt:
                log.append(env.now)

        def parent(env, log):
            child_proc = env.process(child(env, log))
            child_proc.interrupt()
            return
            yield

        env.process(parent(env, log))
>       env.run()

tests/test_interrupts.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:348: in _resume
    next_event = self._generator.throw(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc60ffecd00>, log = []

>   def child(env, log):
E   simpy.exceptions.Interrupt: Interrupt(None)

tests/test_interrupts.py:166: Interrupt
</pre>
</details>
<h3 id="test_processpytest_get_state">test_process.py::test_get_state</h3>
<details><summary> <pre>test_process.py::test_get_state</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc61110ed70>

    def test_get_state(env):
        """A process is alive until it's generator has not terminated."""

        def pem_a(env):
            yield env.timeout(3)

        def pem_b(env, pem_a):
            yield env.timeout(1)
            assert pem_a.is_alive

            yield env.timeout(3)
            assert not pem_a.is_alive

        proc_a = env.process(pem_a(env))
        env.process(pem_b(env, proc_a))
>       env.run()

tests/test_process.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc61110ed70>
pem_a = <Process(pem_a) object at 0x7fc61110fca0>

    def pem_b(env, pem_a):
        yield env.timeout(1)
        assert pem_a.is_alive

        yield env.timeout(3)
>       assert not pem_a.is_alive
E       assert not True
E        +  where True = <Process(pem_a) object at 0x7fc61110fca0>.is_alive

tests/test_process.py:32: AssertionError
</pre>
</details>
<h3 id="test_processpytest_return_value">test_process.py::test_return_value</h3>
<details><summary> <pre>test_process.py::test_return_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610add480>

    def test_return_value(env):
        """Processes can set a return value."""

        def child(env):
            yield env.timeout(1)
            return env.now

        def parent(env):
            result1 = yield env.process(child(env))
            result2 = yield env.process(child(env))

            assert [result1, result2] == [1, 2]

        env.process(parent(env))
>       env.run()

tests/test_process.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610add480>

    def parent(env):
        result1 = yield env.process(child(env))
        result2 = yield env.process(child(env))

>       assert [result1, result2] == [1, 2]
E       assert [1, 1] == [1, 2]
E         
E         At index 1 diff: 1 != 2
E         Use -v to get more diff

tests/test_process.py:80: AssertionError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join">test_process.py::test_interrupted_join</h3>
<details><summary> <pre>test_process.py::test_interrupted_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc61110fbe0>

    def parent(env):
        child_proc = env.process(child(env))
        try:
>           yield child_proc
E           simpy.exceptions.Interrupt: Interrupt(None)

tests/test_process.py:114: Interrupt

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc61110fbe0>

    def test_interrupted_join(env):
        """Interrupts remove a process from the callbacks of its target."""

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                # We should not get resumed when child terminates.
                yield env.timeout(5)
                assert env.now == 6

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc61110fbe0>

    def parent(env):
        child_proc = env.process(child(env))
        try:
            yield child_proc
            pytest.fail('Did not receive an interrupt.')
        except Interrupt:
            assert env.now == 1
            assert child_proc.is_alive

            # We should not get resumed when child terminates.
            yield env.timeout(5)
>           assert env.now == 6
E           assert 2 == 6
E            +  where 2 = <simpy.core.Environment object at 0x7fc61110fbe0>.now

tests/test_process.py:122: AssertionError
</pre>
</details>
<h3 id="test_processpytest_error_and_interrupted_join">test_process.py::test_error_and_interrupted_join</h3>
<details><summary> <pre>test_process.py::test_error_and_interrupted_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610e69b70>

    def parent(env):
        env.process(child_a(env, env.active_process))
        b = env.process(child_b(env))

        try:
>           yield b

tests/test_process.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610e69b70>

    def child_b(env):
>       raise AttributeError('spam')
E       AttributeError: spam

tests/test_process.py:167: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7fc610e69b70>

    def test_error_and_interrupted_join(env):
        def child_a(env, process):
            if process is not None:
                process.interrupt()
            return
            yield  # Dummy yield

        def child_b(env):
            raise AttributeError('spam')
            yield  # Dummy yield

        def parent(env):
            env.process(child_a(env, env.active_process))
            b = env.process(child_b(env))

            try:
                yield b
            # This interrupt unregisters me from b so I won't receive its
            # AttributeError
            except Interrupt:
                pass

            yield env.timeout(0)

        env.process(parent(env))
>       pytest.raises(AttributeError, env.run)

tests/test_process.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:173: in _process_event
    callback(event)
src/simpy/events.py:360: in _resume
    self.fail(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Process(parent) object at 0x7fc610e688b0>
exception = AttributeError('spam')

    def fail(self, exception: Any) ->Event:
        """Set *exception* as the events value, mark it as failed and schedule
        it for processing by the environment. Returns the event instance.

        If *exception* is not an :exc:`Exception` instance, it will be wrapped
        in a :exc:`RuntimeError`.

        Raises :exc:`RuntimeError` if this event has already been triggered.

        """
        if self._value is not PENDING:
>           raise RuntimeError('Event has already been triggered')
E           RuntimeError: Event has already been triggered

src/simpy/events.py:179: RuntimeError
</pre>
</details>
<h3 id="test_resourcespytest_resource">test_resources.py::test_resource</h3>
<details><summary> <pre>test_resources.py::test_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc6112363e0>, log = [('a', 0)]

    def test_resource(env, log):
        """A *resource* is something with a limited numer of slots that need
        to be requested before and released after the usage (e.g., gas pumps
        at a gas station).

        """

        def pem(env, name, resource, log):
            req = resource.request()
            yield req
            assert resource.count == 1

            yield env.timeout(1)
            resource.release(req)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        assert resource.capacity == 1
        assert resource.count == 0
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
        env.run()

>       assert log == [('a', 1), ('b', 2)]
E       AssertionError: assert [('a', 0)] == [('a', 1), ('b', 2)]
E         
E         At index 0 diff: ('a', 0) != ('a', 1)
E         Right contains one more item: ('b', 2)
E         Use -v to get more diff

tests/test_resources.py:40: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_resource_context_manager">test_resources.py::test_resource_context_manager</h3>
<details><summary> <pre>test_resources.py::test_resource_context_manager</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610dbb940>, log = [('a', 0)]

    def test_resource_context_manager(env, log):
        """The event that ``Resource.request()`` returns can be used as
        Context Manager."""

        def pem(env, name, resource, log):
            with resource.request() as request:
                yield request
                yield env.timeout(1)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
        env.run()

>       assert log == [('a', 1), ('b', 2)]
E       AssertionError: assert [('a', 0)] == [('a', 1), ('b', 2)]
E         
E         At index 0 diff: ('a', 0) != ('a', 1)
E         Right contains one more item: ('b', 2)
E         Use -v to get more diff

tests/test_resources.py:64: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_resource_slots">test_resources.py::test_resource_slots</h3>
<details><summary> <pre>test_resources.py::test_resource_slots</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc611175240>
log = [('0', 0), ('1', 0)]

    def test_resource_slots(env, log):
        def pem(env, name, resource, log):
            with resource.request() as req:
                yield req
                log.append((name, env.now))
                yield env.timeout(1)

        resource = simpy.Resource(env, capacity=3)
        for i in range(9):
            env.process(pem(env, str(i), resource, log))
        env.run()

>       assert log == [
            ('0', 0),
            ('1', 0),
            ('2', 0),
            ('3', 1),
            ('4', 1),
            ('5', 1),
            ('6', 2),
            ('7', 2),
            ('8', 2),
        ]
E       AssertionError: assert [('0', 0), ('1', 0)] == [('0', 0), ('...('5', 1), ...]
E         
E         Right contains 7 more items, first extra item: ('2', 0)
E         Use -v to get more diff

tests/test_resources.py:79: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_resource_immediate_requests">test_resources.py::test_resource_immediate_requests</h3>
<details><summary> <pre>test_resources.py::test_resource_immediate_requests</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ff60f70>

    def test_resource_immediate_requests(env):
        """A process must not acquire a resource if it releases it and immediately
        requests it again while there are already other requesting processes."""

        def child(env, res):
            result = []
            for _ in range(3):
                with res.request() as req:
                    yield req
                    result.append(env.now)
                    yield env.timeout(1)
            return result

        def parent(env):
            res = simpy.Resource(env, 1)
            child_a = env.process(child(env, res))
            child_b = env.process(child(env, res))

            a_acquire_times = yield child_a
            b_acquire_times = yield child_b

            assert a_acquire_times == [0, 2, 4]
            assert b_acquire_times == [1, 3, 5]

        env.process(parent(env))
>       env.run()

tests/test_resources.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc60ff60f70>

    def parent(env):
        res = simpy.Resource(env, 1)
        child_a = env.process(child(env, res))
        child_b = env.process(child(env, res))

        a_acquire_times = yield child_a
        b_acquire_times = yield child_b

>       assert a_acquire_times == [0, 2, 4]
E       assert [0, 1, 2] == [0, 2, 4]
E         
E         At index 1 diff: 1 != 2
E         Use -v to get more diff

tests/test_resources.py:175: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_resource_cm_exception">test_resources.py::test_resource_cm_exception</h3>
<details><summary> <pre>test_resources.py::test_resource_cm_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc6111099f0>, log = [0]

    def test_resource_cm_exception(env, log):
        """Resource with context manager receives an exception."""

        def process(env, resource, log, raise_):
            with resource.request() as req:
                yield req
                yield env.timeout(1)
                log.append(env.now)
                if raise_:
                    with pytest.raises(ValueError, match='Foo'):
                        raise ValueError('Foo')

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource, log, True))
        # The second process is used to check if it was able to access the
        # resource:
        env.process(process(env, resource, log, False))
        env.run()

>       assert log == [1, 2]
E       assert [0] == [1, 2]
E         
E         At index 0 diff: 0 != 1
E         Right contains one more item: 2
E         Use -v to get more diff

tests/test_resources.py:201: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_priority_queue">test_resources.py::test_resource_with_priority_queue</h3>
<details><summary> <pre>test_resources.py::test_resource_with_priority_queue</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610e9f340>

    def test_resource_with_priority_queue(env):
        def process(env, delay, resource, priority, res_time):
            yield env.timeout(delay)
            req = resource.request(priority=priority)
            yield req
            assert env.now == res_time
            yield env.timeout(5)
            resource.release(req)

        resource = simpy.PriorityResource(env, capacity=1)
        env.process(process(env, 0, resource, 2, 0))
        env.process(process(env, 2, resource, 3, 10))
        env.process(process(env, 2, resource, 3, 15))  # Test equal priority
        env.process(process(env, 4, resource, 1, 5))
>       env.run()

tests/test_resources.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610e9f340>, delay = 2
resource = <simpy.resources.resource.PriorityResource object at 0x7fc610e9ddb0>
priority = 3, res_time = 10

    def process(env, delay, resource, priority, res_time):
        yield env.timeout(delay)
        req = resource.request(priority=priority)
        yield req
>       assert env.now == res_time
E       assert 2 == 10
E        +  where 2 = <simpy.core.Environment object at 0x7fc610e9f340>.now

tests/test_resources.py:220: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_sorted_queue_maxlen">test_resources.py::test_sorted_queue_maxlen</h3>
<details><summary> <pre>test_resources.py::test_sorted_queue_maxlen</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc6109ac070>

    def test_sorted_queue_maxlen(env):
        """Requests must fail if more than *maxlen* requests happen
        concurrently."""
        resource = simpy.PriorityResource(env, capacity=1)
        resource.put_queue.maxlen = 1  # pyright: ignore

        def process(env, resource):
            # The first request immediately triggered and does not enter the queue.
            resource.request(priority=1)
            # The second request is enqueued.
            resource.request(priority=1)
            with pytest.raises(RuntimeError, match='Cannot append event. Queue is full.'):
                # The third request will now fail.
                resource.request(priority=1)
            yield env.timeout(0)

        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:242: in process
    resource.request(priority=1)
src/simpy/resources/resource.py:121: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:37: in __init__
    resource.put_queue.append(self)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<Event() object at 0x7fc6109acb80>]
item = <Event() object at 0x7fc6109af280>

    def append(self, item: Any) ->None:
        """Sort *item* into the queue.

        Raise a :exc:`RuntimeError` if the queue is full.

        """
        if self.maxlen is not None and len(self) >= self.maxlen:
>           raise RuntimeError('Queue is full')
E           RuntimeError: Queue is full

src/simpy/resources/resource.py:157: RuntimeError
</pre>
</details>
<h3 id="test_resourcespytest_get_users">test_resources.py::test_get_users</h3>
<details><summary> <pre>test_resources.py::test_get_users</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610ecfa60>

    def test_get_users(env):
        def process(env, resource):
            with resource.request() as req:
                yield req
                yield env.timeout(1)

        resource = simpy.Resource(env, 1)
        procs = [env.process(process(env, resource)) for _ in range(3)]
        env.run(until=1)
>       assert [evt.proc for evt in resource.users] == procs[0:1]
E       assert [None] == [<Process(pro...7fc610ecd5d0>]
E         
E         At index 0 diff: None != <Process(process) object at 0x7fc610ecd5d0>
E         Use -v to get more diff

tests/test_resources.py:261: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource">test_resources.py::test_preemptive_resource</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fdde350>

    def test_preemptive_resource(env):
        """Processes with a higher priority may preempt requests of lower priority
        processes. Note that higher priorities are indicated by a lower number
        value."""

        def proc_a(_, resource, prio):
            try:
                with resource.request(priority=prio) as req:
                    yield req
                    pytest.fail('Should have received an interrupt/preemption.')
            except simpy.Interrupt:
                pass

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fc60fdde350>
event = <Process(proc_a) object at 0x7fc60fdde170>

    def _process_event(self, event):
        event._processed = True
        if hasattr(event, '_callback'):
            try:
                event._value = event._callback(event)
            except BaseException as e:
                event._ok = False
                event._value = e
                if not event._defused:
                    self._handle_exception(e)

        if isinstance(event, Process):
            self._active_proc = event

        # Trigger all callbacks
        if event.callbacks:
            for callback in list(event.callbacks):
                try:
                    callback(event)
                except BaseException as e:
                    event._ok = False
                    event._value = e
                    if not event._defused:
                        raise  # Re-raise the exception to propagate it
            event.callbacks = None

        if isinstance(event, Process):
            self._active_proc = None

        # If the event is not ok (i.e., an exception occurred), raise it
        if not event._ok and not event._defused:
>           raise event._value
E           RuntimeError: Invalid exception: Should have received an interrupt/preemption.

src/simpy/core.py:186: RuntimeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource_timeout_0">test_resources.py::test_preemptive_resource_timeout_0</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource_timeout_0</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610974dc0>

    def test_preemptive_resource_timeout_0(env):
        def proc_a(env, resource, prio):
            with resource.request(priority=prio) as req:
                try:
                    yield req
                    yield env.timeout(1)
                    pytest.fail('Should have received an interrupt/preemption.')
                except simpy.Interrupt:
                    pass
            yield env.event()

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7fc610974dc0>
event = <Process(proc_a) object at 0x7fc6109afa30>

    def _process_event(self, event):
        event._processed = True
        if hasattr(event, '_callback'):
            try:
                event._value = event._callback(event)
            except BaseException as e:
                event._ok = False
                event._value = e
                if not event._defused:
                    self._handle_exception(e)

        if isinstance(event, Process):
            self._active_proc = event

        # Trigger all callbacks
        if event.callbacks:
            for callback in list(event.callbacks):
                try:
                    callback(event)
                except BaseException as e:
                    event._ok = False
                    event._value = e
                    if not event._defused:
                        raise  # Re-raise the exception to propagate it
            event.callbacks = None

        if isinstance(event, Process):
            self._active_proc = None

        # If the event is not ok (i.e., an exception occurred), raise it
        if not event._ok and not event._defused:
>           raise event._value
E           RuntimeError: Invalid exception: Should have received an interrupt/preemption.

src/simpy/core.py:186: RuntimeError
</pre>
</details>
<h3 id="test_resourcespytest_mixed_preemption">test_resources.py::test_mixed_preemption</h3>
<details><summary> <pre>test_resources.py::test_mixed_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fe54190>
log = [(0, 0), (2, 1), (3, 2), (3, 3), (6, 4)]

    def test_mixed_preemption(env, log):
        def p(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(2)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert ir is not None  # noqa: PT017
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        res = simpy.PreemptiveResource(env, 1)
        # p0: First user:
        env.process(p(0, env, res, delay=0, prio=2, preempt=True, log=log))
        # p1: Waits (cannot preempt):
        env.process(p(1, env, res, delay=0, prio=2, preempt=True, log=log))
        # p2: Waits later, but has a higher prio:
        env.process(p(2, env, res, delay=1, prio=1, preempt=False, log=log))
        # p3: Preempt the above proc:
        p3 = env.process(p(3, env, res, delay=3, prio=0, preempt=True, log=log))
        # p4: Wait again:
        env.process(p(4, env, res, delay=4, prio=3, preempt=True, log=log))

        env.run()

>       assert log == [
            (2, 0),  # p0 done
            (3, 2, (p3, 2)),  # p2 got it next, but got interrupted by p3
            (5, 3),  # p3 done
            (7, 1),  # p1 done (finally got the resource)
            (9, 4),  # p4 done
        ]
E       assert [(0, 0), (2, ...3, 3), (6, 4)] == [(2, 0), (3, ...7, 1), (9, 4)]
E         
E         At index 0 diff: (0, 0) != (2, 0)
E         Use -v to get more diff

tests/test_resources.py:345: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_nested_preemption">test_resources.py::test_nested_preemption</h3>
<details><summary> <pre>test_resources.py::test_nested_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610adc9d0>
log = [(0, 0), (6, 1), (26, 3)]

    def test_nested_preemption(env, log):
        def process(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(5)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        def process2(id, env, res0, res1, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res0.request(priority=prio, preempt=preempt) as req0:
                try:
                    yield req0
                    with res1.request(priority=prio, preempt=preempt) as req1:
                        try:
                            yield req1
                            yield env.timeout(5)
                            log.append((env.now, id))
                        except simpy.Interrupt as ir:
                            assert isinstance(ir.cause, Preempted)  # noqa: PT017
                            log.append(
                                (
                                    env.now,
                                    id,
                                    (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                                )
                            )
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append(
                        (
                            env.now,
                            id,
                            (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                        )
                    )

        res0 = simpy.PreemptiveResource(env, 1)
        res1 = simpy.PreemptiveResource(env, 1)

        env.process(process2(0, env, res0, res1, 0, -1, True, log))
        p1 = env.process(process(1, env, res1, 1, -2, True, log))

        env.process(process2(2, env, res0, res1, 20, -1, True, log))
        p3 = env.process(process(3, env, res0, 21, -2, True, log))

        env.process(process2(4, env, res0, res1, 21, -1, True, log))

        env.run()

>       assert log == [
            (1, 0, (p1, 0, res1)),
            (6, 1),
            (21, 2, (p3, 20, res0)),
            (26, 3),
            (31, 4),
        ]
E       assert [(0, 0), (6, 1), (26, 3)] == [(1, 0, (<Pro..., 3), (31, 4)]
E         
E         At index 0 diff: (0, 0) != (1, 0, (<Process(process) object at 0x7fc610ade020>, 0, <simpy.resources.resource.PreemptiveResource object at 0x7fc610add7b0>))
E         Right contains 2 more items, first extra item: (26, 3)
E         Use -v to get more diff

tests/test_resources.py:408: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_container">test_resources.py::test_container</h3>
<details><summary> <pre>test_resources.py::test_container</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610ece380>, log = []

    def test_container(env, log):
        """A *container* is a resource (of optionally limited capacity) where
        you can put in our take-out a discrete or continuous amount of
        things (e.g., a box of lump sugar or a can of milk).  The *put* and
        *get* operations block if the buffer is to full or to empty. If they
        return, the process knows that the *put* or *get* operation was
        successful.

        """

        def putter(env, buf, log):
            yield env.timeout(1)
            while True:
                yield buf.put(2)
                log.append(('p', env.now))
                yield env.timeout(1)

        def getter(env, buf, log):
            yield buf.get(1)
            log.append(('g', env.now))

            yield env.timeout(1)
            yield buf.get(1)
            log.append(('g', env.now))

        buf = simpy.Container(env, init=0, capacity=2)
        env.process(putter(env, buf, log))
        env.process(getter(env, buf, log))
>       env.run(until=5)

tests/test_resources.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:293: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:440: in getter
    yield buf.get(1)
src/simpy/resources/container.py:46: in __init__
    super().__init__(container)
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7fc610ece4a0>
event = <Event() object at 0x7fc610ece4d0>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_container_get_queued">test_resources.py::test_container_get_queued</h3>
<details><summary> <pre>test_resources.py::test_container_get_queued</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fe2f9d0>

    def test_container_get_queued(env):
        def proc(env, wait, container, what):
            yield env.timeout(wait)
            with getattr(container, what)(1) as req:
                yield req

        container = simpy.Container(env, 1)
        p0 = env.process(proc(env, 0, container, 'get'))
        env.process(proc(env, 1, container, 'put'))
        env.process(proc(env, 1, container, 'put'))
        p3 = env.process(proc(env, 1, container, 'put'))

>       env.run(until=1)

tests/test_resources.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:293: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:458: in proc
    with getattr(container, what)(1) as req:
src/simpy/resources/container.py:46: in __init__
    super().__init__(container)
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7fc60fe2fa00>
event = <Event() object at 0x7fc60fe2f700>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_store">test_resources.py::test_store</h3>
<details><summary> <pre>test_resources.py::test_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc6108c0490>

    def test_store(env):
        """A store models the production and consumption of concrete python
        objects (in contrast to containers, where you only now if the *put*
        or *get* operations were successful but don't get concrete
        objects).

        """

        def putter(_, store, item):
            yield store.put(item)

        def getter(_, store, orig_item):
            item = yield store.get()
            assert item is orig_item

        store = simpy.Store(env, capacity=2)
        item = object()

        # NOTE: Does the start order matter? Need to test this.
        env.process(putter(env, store, item))
        env.process(getter(env, store, item))
>       env.run()

tests/test_resources.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:523: in putter
    yield store.put(item)
src/simpy/resources/store.py:27: in __init__
    super().__init__(store)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.Store object at 0x7fc6108c02e0>
event = <Event() object at 0x7fc6108c13c0>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_put() must be implemented by subclasses.")
E       NotImplementedError: _do_put() must be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_store_capacity">test_resources.py::test_store_capacity</h3>
<details><summary> <pre>test_resources.py::test_store_capacity</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610b8eb90>

    def test_store_capacity(env):
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, 0)
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, -1)

        capacity = 2
        store = simpy.Store(env, capacity)
        env.process(store.put(i) for i in range(capacity + 1))
>       env.run()

tests/test_resources.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:558: in <genexpr>
    env.process(store.put(i) for i in range(capacity + 1))
src/simpy/resources/store.py:27: in __init__
    super().__init__(store)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.Store object at 0x7fc610b8e530>
event = <Event() object at 0x7fc610b8ffa0>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_put() must be implemented by subclasses.")
E       NotImplementedError: _do_put() must be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_store_cancel">test_resources.py::test_store_cancel</h3>
<details><summary> <pre>test_resources.py::test_store_cancel</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ffa9b10>

    def test_store_cancel(env):
        store = simpy.Store(env, capacity=1)

        def acquire_implicit_cancel():
            with store.get():
                yield env.timeout(1)
                # implicit cancel() when exiting with-block

        env.process(acquire_implicit_cancel())
>       env.run()

tests/test_resources.py:574: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:569: in acquire_implicit_cancel
    with store.get():
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.Store object at 0x7fc60ffabac0>
event = <Event() object at 0x7fc60ffab1c0>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_item_priority">test_resources.py::test_priority_store_item_priority</h3>
<details><summary> <pre>test_resources.py::test_priority_store_item_priority</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fdd88b0>

    def test_priority_store_item_priority(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            item = yield pstore.get()
            log.append(item)

        # Do not specify priority; the items themselves will be compared to
        # determine priority.
        env.process(pstore.put(s) for s in 'bcadefg')
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:588: in <genexpr>
    env.process(pstore.put(s) for s in 'bcadefg')
src/simpy/resources/store.py:27: in __init__
    super().__init__(store)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.PriorityStore object at 0x7fc60fddada0>
event = <Event() object at 0x7fc60fdd87c0>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_put() must be implemented by subclasses.")
E       NotImplementedError: _do_put() must be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_stable_order">test_resources.py::test_priority_store_stable_order</h3>
<details><summary> <pre>test_resources.py::test_priority_store_stable_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610db92d0>

    def test_priority_store_stable_order(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            _, item = yield pstore.get()
            log.append(item)

        items = [object() for _ in range(3)]

        # Unorderable items are inserted with same priority.
        env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:608: in <genexpr>
    env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)
src/simpy/resources/store.py:27: in __init__
    super().__init__(store)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.PriorityStore object at 0x7fc610dba680>
event = <Event() object at 0x7fc610dbb190>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_put() must be implemented by subclasses.")
E       NotImplementedError: _do_put() must be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store">test_resources.py::test_filter_store</h3>
<details><summary> <pre>test_resources.py::test_filter_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fe8da20>

    def test_filter_store(env):
        def pem(env):
            store = simpy.FilterStore(env, capacity=2)

            get_event = store.get(lambda item: item == 'b')
            yield store.put('a')
            assert not get_event.triggered
            yield store.put('b')
            assert get_event.triggered

        env.process(pem(env))
>       env.run()

tests/test_resources.py:630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:623: in pem
    get_event = store.get(lambda item: item == 'b')
src/simpy/resources/store.py:52: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.FilterStore object at 0x7fc60fe8de10>
event = <Event() object at 0x7fc60fe8d810>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store_get_after_mismatch">test_resources.py::test_filter_store_get_after_mismatch</h3>
<details><summary> <pre>test_resources.py::test_filter_store_get_after_mismatch</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ffab070>

    def test_filter_store_get_after_mismatch(env):
        """Regression test for issue #49.

        Triggering get-events after a put in FilterStore wrongly breaks after the
        first mismatch.

        """

        def putter(env, store):
            # The order of putting 'spam' before 'eggs' is important here.
            yield store.put('spam')
            yield env.timeout(1)
            yield store.put('eggs')

        def getter(store):
            # The order of requesting 'eggs' before 'spam' is important here.
            eggs = store.get(lambda i: i == 'eggs')
            spam = store.get(lambda i: i == 'spam')

            ret = yield spam | eggs
            assert spam in ret
            assert eggs not in ret
            assert env.now == 0

            yield eggs
            assert env.now == 1

        store = simpy.FilterStore(env, capacity=2)
        env.process(getter(store))
        env.process(putter(env, store))
>       env.run()

tests/test_resources.py:663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:649: in getter
    eggs = store.get(lambda i: i == 'eggs')
src/simpy/resources/store.py:52: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.FilterStore object at 0x7fc60ffa8b20>
event = <Event() object at 0x7fc60ffa87c0>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_best_case">test_resources.py::test_filter_calls_best_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_best_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ff2fd60>

    def test_filter_calls_best_case(env):
        """The filter function is called every item in the store until a match is
        found. In the best case the first item already matches."""
        log = []

        def log_filter(item):
            log.append(f'check {item}')
            return True

        store = simpy.FilterStore(env)
        store.items = [1, 2, 3]

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
>       env.run()

tests/test_resources.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:679: in getter
    log.append(f'get {yield store.get(log_filter)}')
src/simpy/resources/store.py:52: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.FilterStore object at 0x7fc60ff2cb20>
event = <Event() object at 0x7fc60ff2ff70>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_worst_case">test_resources.py::test_filter_calls_worst_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_worst_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fe42530>

    def test_filter_calls_worst_case(env):
        """In the worst case the filter function is being called for items multiple
        times."""

        log = []
        store = simpy.FilterStore(env)

        def putter(store):
            for i in range(4):
                log.append(f'put {i}')
                yield store.put(i)

        def log_filter(item):
            log.append(f'check {item}')
            return item >= 3

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
        env.process(putter(store))
>       env.run()

tests/test_resources.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_resources.py:706: in getter
    log.append(f'get {yield store.get(log_filter)}')
src/simpy/resources/store.py:52: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:86: in __init__
    resource._trigger_get(None)
src/simpy/resources/base.py:229: in _trigger_get
    if not self._do_get(get_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.store.FilterStore object at 0x7fc60fe42e90>
event = <Event() object at 0x7fc60fe43190>

    def _do_get(self, event: GetType) ->Optional[bool]:
        """Perform the *get* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the get *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_get` for every event in the
        :attr:`get_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_get() must be implemented by subclasses.")
E       NotImplementedError: _do_get() must be implemented by subclasses.

src/simpy/resources/base.py:214: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_put_request">test_resources.py::test_immediate_put_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_put_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ff2ebc0>

    def test_immediate_put_request(env):
        """Put requests that can be fulfilled immediately do not enter the put
        queue."""
        resource = simpy.Resource(env, capacity=1)
        assert len(resource.users) == 0
        assert len(resource.queue) == 0

        # The resource is empty, the first request will succeed immediately without
        # entering the queue.
        request = resource.request()
        assert request.triggered
        assert len(resource.users) == 1
>       assert len(resource.queue) == 0
E       assert 1 == 0
E        +  where 1 = len([<Event() object at 0x7fc60ff2f100>])
E        +    where [<Event() object at 0x7fc60ff2f100>] = <simpy.resources.resource.Resource object at 0x7fc60ff2fb20>.queue

tests/test_resources.py:736: AssertionError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_get_request">test_resources.py::test_immediate_get_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_get_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610e9ef20>

    def test_immediate_get_request(env):
        """Get requests that can be fulfilled immediately do not enter the get
        queue."""
        container = simpy.Container(env)
        # Put something in the container, this request is triggered immediately
        # without entering the queue.
>       request = container.put(1)

tests/test_resources.py:751: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/container.py:30: in __init__
    super().__init__(container)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7fc610e9c100>
event = <Event() object at 0x7fc610e9ef80>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("_do_put() must be implemented by subclasses.")
E       NotImplementedError: _do_put() must be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_rtpytest_rt01">test_rt.py::test_rt[0.1]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.1]</pre></summary><pre>
log = [], factor = 0.1

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc60ff2f100>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_rtpytest_rt005">test_rt.py::test_rt[0.05]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.05]</pre></summary><pre>
log = [], factor = 0.05

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc60fdc6200>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_rtpytest_rt015">test_rt.py::test_rt[0.15]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.15]</pre></summary><pre>
log = [], factor = 0.15

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc60fec43d0>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_rtpytest_rt_multiple_call">test_rt.py::test_rt_multiple_call</h3>
<details><summary> <pre>test_rt.py::test_rt_multiple_call</pre></summary><pre>
log = []

    def test_rt_multiple_call(log):
        """Test multiple calls to run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05)

        env.process(process(env, log, 0.01, 2))
        env.process(process(env, log, 0.01, 3))

>       env.run(5)

tests/test_rt.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc60fe57b50>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_default_behavior">test_rt.py::test_rt_slow_sim_default_behavior</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_default_behavior</pre></summary><pre>
log = []

    def test_rt_slow_sim_default_behavior(log):
        """By default, SimPy should raise an error if a simulation is too
        slow for the selected real-time factor."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.1, 1))

>       err = pytest.raises(RuntimeError, env.run, 3)

tests/test_rt.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc610e697e0>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_no_error">test_rt.py::test_rt_slow_sim_no_error</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_no_error</pre></summary><pre>
log = []

    def test_rt_slow_sim_no_error(log):
        """Test ignoring slow simulations."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05, strict=False)
        env.process(process(env, log, 0.1, 1))

>       env.run(2)

tests/test_rt.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc610e9ef80>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_rtpytest_rt_sync">test_rt.py::test_rt_sync</h3>
<details><summary> <pre>test_rt.py::test_rt_sync</pre></summary><pre>
log = []

    def test_rt_sync(log):
        """Test resetting the internal wall-clock reference time."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.01))
        sleep(0.06)  # Simulate massive workload :-)
        env.sync()
>       env.run(3)

tests/test_rt.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:290: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7fc60fec5c90>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
>           evt_time, evt = self._queue.pop()
E           ValueError: too many values to unpack (expected 2)

src/simpy/rt.py:64: ValueError
</pre>
</details>
<h3 id="test_timeoutpytest_discrete_time_steps">test_timeout.py::test_discrete_time_steps</h3>
<details><summary> <pre>test_timeout.py::test_discrete_time_steps</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fdc5bd0>
log = [0, 1, 1, 2, 2, 2, ...]

    def test_discrete_time_steps(env, log):
        """envple envulation with discrete time steps."""

        def pem(env, log):
            while True:
                log.append(env.now)
                yield env.timeout(delay=1)

        env.process(pem(env, log))
        env.run(until=3)

>       assert log == [0, 1, 2]
E       assert [0, 1, 1, 2, 2, 2, ...] == [0, 1, 2]
E         
E         At index 2 diff: 1 != 2
E         Left contains 12 more items, first extra item: 2
E         Use -v to get more diff

tests/test_timeout.py:20: AssertionError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout">test_util.py::test_subscribe_at_timeout</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fe57eb0>

    def test_subscribe_at_timeout(env):
        """You should be able to subscribe at arbitrary events."""

        def pem(env):
            to = env.timeout(2)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, None)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_util.py:99: in pem
    subscribe_at(to)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

event = <Timeout(2) object at 0x7fc60fe55750>

    def subscribe_at(event: Event) ->None:
        """Register at the *event* to receive an interrupt when it occurs.

        The most common use case for this is to pass
        a :class:`~simpy.events.Process` to get notified when it terminates.

        If the event has already occurred, the interrupt will be scheduled immediately.

        """
        def interrupt_callback(event):
            process = event.env.active_process
            if process is not None:
                process.interrupt((event, event.value))

        if event.triggered:
            if event.env.active_process:
                event.env.active_process.interrupt((event, event.value))
            else:
>               raise RuntimeError("Cannot subscribe to an already triggered event without an active process")
E               RuntimeError: Cannot subscribe to an already triggered event without an active process

src/simpy/util.py:64: RuntimeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout_with_value">test_util.py::test_subscribe_at_timeout_with_value</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout_with_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc61092a1d0>

    def test_subscribe_at_timeout_with_value(env):
        """An event's value should be accessible via the interrupt cause."""

        def pem(env):
            val = 'ohai'
            to = env.timeout(2, value=val)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, val)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
tests/test_util.py:116: in pem
    subscribe_at(to)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

event = <Timeout(2, value=ohai) object at 0x7fc610928d00>

    def subscribe_at(event: Event) ->None:
        """Register at the *event* to receive an interrupt when it occurs.

        The most common use case for this is to pass
        a :class:`~simpy.events.Process` to get notified when it terminates.

        If the event has already occurred, the interrupt will be scheduled immediately.

        """
        def interrupt_callback(event):
            process = event.env.active_process
            if process is not None:
                process.interrupt((event, event.value))

        if event.triggered:
            if event.env.active_process:
                event.env.active_process.interrupt((event, event.value))
            else:
>               raise RuntimeError("Cannot subscribe to an already triggered event without an active process")
E               RuntimeError: Cannot subscribe to an already triggered event without an active process

src/simpy/util.py:64: RuntimeError
</pre>
</details>
<h3 id="test_utilpytest_wait_for_all_with_errors">test_util.py::test_wait_for_all_with_errors</h3>
<details><summary> <pre>test_util.py::test_wait_for_all_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fdc5d50>

    def test_wait_for_all_with_errors(env):
        """On default AllOf should fail immediately if one of its events
        fails."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [
                env.timeout(1, value=1),
                env.process(child_with_error(env, 2)),
                env.timeout(3, value=3),
            ]

            condition = env.all_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            # Although the condition has failed, interim values are available.
            assert condition._events[0].value == 1
            assert condition._events[1].value.args[0] == 'crashing'
            # The last child has not terminated yet.
            assert not events[2].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc60fdc5d50>, value = 2

    def child_with_error(env, value):
        yield env.timeout(value)
>       raise RuntimeError('crashing')
E       RuntimeError: crashing

tests/test_util.py:163: RuntimeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining_intermediate_results">test_util.py::test_all_of_chaining_intermediate_results</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining_intermediate_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc610b8f940>

    def test_all_of_chaining_intermediate_results(env):
        """If a wait_for_all condition A with intermediate results is merged into
        another wait_for_all condition B, the results are copied into condition
        A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            yield env.timeout(0)

            condition = condition_a & condition_b
            result = ConditionValue()
            condition._populate_value(result)
            assert list(result.values()) == [0, 0]

            results = yield condition
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc610b8f940>

    def parent(env):
        condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
        condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

        yield env.timeout(0)

        condition = condition_a & condition_b
        result = ConditionValue()
        condition._populate_value(result)
>       assert list(result.values()) == [0, 0]
E       assert [<ConditionVa...0b8cbe0>: 1}>] == [0, 0]
E         
E         At index 0 diff: <ConditionValue {<Timeout(0, value=0) object at 0x7fc610b8c310>: 0, <Timeout(1, value=1) object at 0x7fc610b8cf10>: 1}> != 0
E         Use -v to get more diff

tests/test_util.py:217: AssertionError
</pre>
</details>
<h3 id="test_utilpytest_all_of_with_triggered_events">test_util.py::test_all_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_all_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fdc6e60>

    def test_all_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.all_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc60fdc6e60>

    def parent(env):
        events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
        yield env.timeout(2)

>       values = list((yield env.all_of(events)).values())
E       AttributeError: 'NoneType' object has no attribute 'values'

tests/test_util.py:234: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_errors">test_util.py::test_any_of_with_errors</h3>
<details><summary> <pre>test_util.py::test_any_of_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60ff605b0>

    def test_any_of_with_errors(env):
        """On default any_of should fail if the event has failed too."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [env.process(child_with_error(env, 1)), env.timeout(2, value=2)]
            condition = env.any_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            assert condition._events[0].value.args[0] == 'crashing'
            # The last event has not terminated yet.
            assert not events[1].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc60ff605b0>, value = 1

    def child_with_error(env, value):
        yield env.timeout(value)
>       raise RuntimeError('crashing')
E       RuntimeError: crashing

tests/test_util.py:261: RuntimeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_triggered_events">test_util.py::test_any_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_any_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7fc60fe49e10>

    def test_any_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.any_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:264: in run
    self.step()
src/simpy/core.py:151: in step
    self._process_event(event)
src/simpy/core.py:186: in _process_event
    raise event._value
src/simpy/events.py:346: in _resume
    next_event = self._generator.send(event._value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = <simpy.core.Environment object at 0x7fc60fe49e10>

    def parent(env):
        events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
        yield env.timeout(2)

>       values = list((yield env.any_of(events)).values())
E       AttributeError: 'NoneType' object has no attribute 'values'

tests/test_util.py:302: AttributeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/simpy/core.py b/src/simpy/core.py</span>
<span class="gh">index 10c88fb..391c088 100644</span>
<span class="gd">--- a/src/simpy/core.py</span>
<span class="gi">+++ b/src/simpy/core.py</span>
<span class="gu">@@ -7,7 +7,7 @@ from heapq import heappop, heappush</span>
<span class="w"> </span>from itertools import count
<span class="w"> </span>from types import MethodType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Generic, Iterable, List, Optional, Tuple, Type, TypeVar, Union
<span class="gd">-from simpy.events import NORMAL, URGENT, AllOf, AnyOf, Event, EventPriority, Process, ProcessGenerator, Timeout</span>
<span class="gi">+from simpy.events import NORMAL, URGENT, AllOf, AnyOf, Event, EventPriority, Process, ProcessGenerator, Timeout, Interruption</span>
<span class="w"> </span>Infinity: float = float(&#39;inf&#39;)
<span class="w"> </span>T = TypeVar(&#39;T&#39;)

<span class="gu">@@ -34,7 +34,10 @@ class BoundClass(Generic[T]):</span>
<span class="w"> </span>    def bind_early(instance: object) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Bind all :class:`BoundClass` attributes of the *instance&#39;s* class
<span class="w"> </span>        to the instance itself to increase performance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = type(instance)</span>
<span class="gi">+        for name, obj in cls.__dict__.items():</span>
<span class="gi">+            if isinstance(obj, BoundClass):</span>
<span class="gi">+                setattr(instance, name, obj.__get__(instance, cls))</span>


<span class="w"> </span>class EmptySchedule(Exception):
<span class="gu">@@ -49,7 +52,7 @@ class StopSimulation(Exception):</span>
<span class="w"> </span>    def callback(cls, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Used as callback in :meth:`Environment.run()` to stop the simulation
<span class="w"> </span>        when the *until* event occurred.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise cls()</span>


<span class="w"> </span>SimTime = Union[int, float]
<span class="gu">@@ -77,12 +80,12 @@ class Environment:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def now(self) -&gt;SimTime:
<span class="w"> </span>        &quot;&quot;&quot;The current simulation time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._now</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def active_process(self) -&gt;Optional[Process]:
<span class="w"> </span>        &quot;&quot;&quot;The currently active process of the environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._active_proc</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def process(self, generator: ProcessGenerator) -&gt;Process:
<span class="gu">@@ -121,12 +124,15 @@ class Environment:</span>
<span class="w"> </span>    def schedule(self, event: Event, priority: EventPriority=NORMAL, delay:
<span class="w"> </span>        SimTime=0) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Schedule an *event* with a given *priority* and a *delay*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heappush(self._queue, (self._now + delay, priority, next(self._eid), event))</span>

<span class="w"> </span>    def peek(self) -&gt;SimTime:
<span class="w"> </span>        &quot;&quot;&quot;Get the time of the next scheduled event. Return
<span class="w"> </span>        :data:`~simpy.core.Infinity` if there is no further event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._queue[0][0]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return Infinity</span>

<span class="w"> </span>    def step(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process the next event.
<span class="gu">@@ -134,7 +140,108 @@ class Environment:</span>
<span class="w"> </span>        Raise an :exc:`EmptySchedule` if no further events are available.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            next_time, priority, _, event = heappop(self._queue)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise EmptySchedule()</span>
<span class="gi">+</span>
<span class="gi">+        if next_time &gt; self._now:</span>
<span class="gi">+            self._now = next_time</span>
<span class="gi">+</span>
<span class="gi">+        self._process_event(event)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _process_event(self, event):</span>
<span class="gi">+        event._processed = True</span>
<span class="gi">+        if hasattr(event, &#39;_callback&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                event._value = event._callback(event)</span>
<span class="gi">+            except BaseException as e:</span>
<span class="gi">+                event._ok = False</span>
<span class="gi">+                event._value = e</span>
<span class="gi">+                if not event._defused:</span>
<span class="gi">+                    self._handle_exception(e)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(event, Process):</span>
<span class="gi">+            self._active_proc = event</span>
<span class="gi">+        </span>
<span class="gi">+        # Trigger all callbacks</span>
<span class="gi">+        if event.callbacks:</span>
<span class="gi">+            for callback in list(event.callbacks):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    callback(event)</span>
<span class="gi">+                except BaseException as e:</span>
<span class="gi">+                    event._ok = False</span>
<span class="gi">+                    event._value = e</span>
<span class="gi">+                    if not event._defused:</span>
<span class="gi">+                        raise  # Re-raise the exception to propagate it</span>
<span class="gi">+            event.callbacks = None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(event, Process):</span>
<span class="gi">+            self._active_proc = None</span>
<span class="gi">+</span>
<span class="gi">+        # If the event is not ok (i.e., an exception occurred), raise it</span>
<span class="gi">+        if not event._ok and not event._defused:</span>
<span class="gi">+            raise event._value</span>
<span class="gi">+</span>
<span class="gi">+    def schedule(self, event: Event, priority: EventPriority=NORMAL, delay: SimTime=0) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;Schedule an *event* with a given *priority* and a *delay*.&quot;&quot;&quot;</span>
<span class="gi">+        if delay &lt; 0:</span>
<span class="gi">+            raise ValueError(&#39;Negative delay&#39;)</span>
<span class="gi">+        heappush(self._queue, (self._now + delay, priority, next(self._eid), event))</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_exception(self, exception: BaseException) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;Handle an exception by raising it immediately.&quot;&quot;&quot;</span>
<span class="gi">+        raise exception</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, until: Optional[Union[SimTime, Event]]=None) -&gt;Optional[Any]:</span>
<span class="gi">+        &quot;&quot;&quot;Executes :meth:`step()` until the given criterion *until* is met.</span>
<span class="gi">+</span>
<span class="gi">+        - If it is ``None`` (which is the default), this method will return</span>
<span class="gi">+          when there are no further events to be processed.</span>
<span class="gi">+</span>
<span class="gi">+        - If it is an :class:`~simpy.events.Event`, the method will continue</span>
<span class="gi">+          stepping until this event has been triggered and will return its</span>
<span class="gi">+          value.  Raises a :exc:`RuntimeError` if there are no further events</span>
<span class="gi">+          to be processed and the *until* event was not triggered.</span>
<span class="gi">+</span>
<span class="gi">+        - If it is a number, the method will continue stepping</span>
<span class="gi">+          until the environment&#39;s time reaches *until*.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if until is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                return None</span>
<span class="gi">+        elif isinstance(until, Event):</span>
<span class="gi">+            if until.triggered:</span>
<span class="gi">+                self._now = until._value</span>
<span class="gi">+                return until.value</span>
<span class="gi">+            until.callbacks.append(StopSimulation.callback)</span>
<span class="gi">+            try:</span>
<span class="gi">+                while not until.triggered:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+            except StopSimulation:</span>
<span class="gi">+                return until.value</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                if not until.triggered:</span>
<span class="gi">+                    raise RuntimeError(&#39;No scheduled events left but &quot;until&quot; event was not triggered: &#39; + str(until))</span>
<span class="gi">+        elif isinstance(until, (int, float)) or (isinstance(until, str) and until.replace(&#39;.&#39;, &#39;&#39;, 1).isdigit()):</span>
<span class="gi">+            until = float(until)</span>
<span class="gi">+            if until &lt; self._now:</span>
<span class="gi">+                raise ValueError(&#39;until must be greater than the current simulation time&#39;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                while self._now &lt; until:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+                self._now = until  # Ensure we reach the exact &#39;until&#39; time</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                self._now = until  # Set the time even if there are no more events</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Invalid until parameter type&#39;)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def run(self, until: Optional[Union[SimTime, Event]]=None) -&gt;Optional[Any]:
<span class="w"> </span>        &quot;&quot;&quot;Executes :meth:`step()` until the given criterion *until* is met.
<span class="gu">@@ -151,4 +258,41 @@ class Environment:</span>
<span class="w"> </span>          until the environment&#39;s time reaches *until*.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if until is None:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+                except EmptySchedule:</span>
<span class="gi">+                    return None</span>
<span class="gi">+        elif isinstance(until, Event):</span>
<span class="gi">+            if until.triggered:</span>
<span class="gi">+                self._now = until._value</span>
<span class="gi">+                return until.value</span>
<span class="gi">+            until.callbacks.append(StopSimulation.callback)</span>
<span class="gi">+            try:</span>
<span class="gi">+                while not until.triggered:</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+            except StopSimulation:</span>
<span class="gi">+                return until.value</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                if not until.triggered:</span>
<span class="gi">+                    raise RuntimeError(&#39;No scheduled events left but &quot;until&quot; event was not triggered: &#39; + str(until))</span>
<span class="gi">+        elif isinstance(until, (int, float)) or (isinstance(until, str) and until.replace(&#39;.&#39;, &#39;&#39;, 1).isdigit()):</span>
<span class="gi">+            until = float(until)</span>
<span class="gi">+            if until &lt; self._now:</span>
<span class="gi">+                raise ValueError(&#39;until must be greater than the current simulation time&#39;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                while self._now &lt; until:</span>
<span class="gi">+                    next_event_time = self.peek()</span>
<span class="gi">+                    if next_event_time &gt; until:</span>
<span class="gi">+                        self._now = until</span>
<span class="gi">+                        break</span>
<span class="gi">+                    self.step()</span>
<span class="gi">+                    # Process all events at the current time</span>
<span class="gi">+                    while self.peek() == self._now:</span>
<span class="gi">+                        self.step()</span>
<span class="gi">+            except EmptySchedule:</span>
<span class="gi">+                self._now = until  # Set the time even if there are no more events</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Invalid until parameter type&#39;)</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/src/simpy/events.py b/src/simpy/events.py</span>
<span class="gh">index 128ed75..fd2b553 100644</span>
<span class="gd">--- a/src/simpy/events.py</span>
<span class="gi">+++ b/src/simpy/events.py</span>
<span class="gu">@@ -67,6 +67,9 @@ class Event:</span>
<span class="w"> </span>        &quot;&quot;&quot;The :class:`~simpy.core.Environment` the event lives in.&quot;&quot;&quot;
<span class="w"> </span>        self.callbacks: EventCallbacks = []
<span class="w"> </span>        &quot;&quot;&quot;List of functions that are called when the event is processed.&quot;&quot;&quot;
<span class="gi">+        self._defused = False</span>
<span class="gi">+        self._ok = True</span>
<span class="gi">+        self._processed = False</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return the description of the event (see :meth:`_desc`) with the id
<span class="gu">@@ -75,19 +78,19 @@ class Event:</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Event()*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;Event()&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def triggered(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` if the event has been triggered and its callbacks
<span class="w"> </span>        are about to be invoked.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value is not PENDING</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def processed(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` if the event has been processed (e.g., its
<span class="w"> </span>        callbacks have been invoked).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.callbacks is None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def ok(self) -&gt;bool:
<span class="gu">@@ -98,7 +101,9 @@ class Event:</span>
<span class="w"> </span>        :raises AttributeError: if accessed before the event is triggered.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is PENDING:</span>
<span class="gi">+            raise AttributeError(&#39;Event has not yet been triggered&#39;)</span>
<span class="gi">+        return self._ok</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def defused(self) -&gt;bool:
<span class="gu">@@ -115,7 +120,11 @@ class Event:</span>
<span class="w"> </span>        processed by the :class:`~simpy.core.Environment`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._defused</span>
<span class="gi">+</span>
<span class="gi">+    @defused.setter</span>
<span class="gi">+    def defused(self, value: bool) -&gt;None:</span>
<span class="gi">+        self._defused = value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def value(self) -&gt;Optional[Any]:
<span class="gu">@@ -126,7 +135,9 @@ class Event:</span>
<span class="w"> </span>        Raises :exc:`AttributeError` if the value is not yet available.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is PENDING:</span>
<span class="gi">+            raise AttributeError(&#39;Value is not yet available&#39;)</span>
<span class="gi">+        return self._value</span>

<span class="w"> </span>    def trigger(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Trigger the event with the state and value of the provided *event*.
<span class="gu">@@ -136,27 +147,42 @@ class Event:</span>
<span class="w"> </span>        chain reactions.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._ok = event._ok</span>
<span class="gi">+        self._value = event._value</span>
<span class="gi">+        self._defused = event._defused</span>
<span class="gi">+        self.env.schedule(self)</span>

<span class="w"> </span>    def succeed(self, value: Optional[Any]=None) -&gt;Event:
<span class="w"> </span>        &quot;&quot;&quot;Set the event&#39;s value, mark it as successful and schedule it for
<span class="w"> </span>        processing by the environment. Returns the event instance.

<span class="gd">-        Raises :exc:`RuntimeError` if this event has already been triggerd.</span>
<span class="gi">+        If the event has already been triggered, this method does nothing.</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is PENDING:</span>
<span class="gi">+            self._ok = True</span>
<span class="gi">+            self._value = value</span>
<span class="gi">+            self.env.schedule(self)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def fail(self, exception: Exception) -&gt;Event:</span>
<span class="gi">+    def fail(self, exception: Any) -&gt;Event:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set *exception* as the events value, mark it as failed and schedule
<span class="w"> </span>        it for processing by the environment. Returns the event instance.

<span class="gd">-        Raises :exc:`TypeError` if *exception* is not an :exc:`Exception`.</span>
<span class="gi">+        If *exception* is not an :exc:`Exception` instance, it will be wrapped</span>
<span class="gi">+        in a :exc:`RuntimeError`.</span>

<span class="w"> </span>        Raises :exc:`RuntimeError` if this event has already been triggered.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            raise RuntimeError(&#39;Event has already been triggered&#39;)</span>
<span class="gi">+        self._ok = False</span>
<span class="gi">+        if not isinstance(exception, Exception):</span>
<span class="gi">+            exception = RuntimeError(f&#39;Invalid exception: {exception}&#39;)</span>
<span class="gi">+        self._value = exception</span>
<span class="gi">+        self.env.schedule(self)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __and__(self, other: Event) -&gt;Condition:
<span class="w"> </span>        &quot;&quot;&quot;Return a :class:`~simpy.events.Condition` that will be triggered if
<span class="gu">@@ -186,10 +212,9 @@ class Timeout(Event):</span>

<span class="w"> </span>    def __init__(self, env: Environment, delay: SimTime, value: Optional[
<span class="w"> </span>        Any]=None):
<span class="gi">+        super().__init__(env)</span>
<span class="w"> </span>        if delay &lt; 0:
<span class="w"> </span>            raise ValueError(f&#39;Negative delay {delay}&#39;)
<span class="gd">-        self.env = env</span>
<span class="gd">-        self.callbacks: EventCallbacks = []</span>
<span class="w"> </span>        self._value = value
<span class="w"> </span>        self._delay = delay
<span class="w"> </span>        self._ok = True
<span class="gu">@@ -197,7 +222,9 @@ class Timeout(Event):</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Timeout(delay[, value=value])*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is None:</span>
<span class="gi">+            return f&#39;Timeout({self._delay})&#39;</span>
<span class="gi">+        return f&#39;Timeout({self._delay}, value={self._value})&#39;</span>


<span class="w"> </span>class Initialize(Event):
<span class="gu">@@ -208,7 +235,7 @@ class Initialize(Event):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, env: Environment, process: Process):
<span class="gd">-        self.env = env</span>
<span class="gi">+        super().__init__(env)</span>
<span class="w"> </span>        self.callbacks: EventCallbacks = [process._resume]
<span class="w"> </span>        self._value: Any = None
<span class="w"> </span>        self._ok = True
<span class="gu">@@ -224,7 +251,7 @@ class Interruption(Event):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, process: Process, cause: Optional[Any]):
<span class="gd">-        self.env = process.env</span>
<span class="gi">+        super().__init__(process.env)</span>
<span class="w"> </span>        self.callbacks: EventCallbacks = [self._interrupt]
<span class="w"> </span>        self._value = Interrupt(cause)
<span class="w"> </span>        self._ok = False
<span class="gu">@@ -237,6 +264,14 @@ class Interruption(Event):</span>
<span class="w"> </span>        self.process = process
<span class="w"> </span>        self.env.schedule(self, URGENT)

<span class="gi">+    def _interrupt(self, event):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.process._resume(self)</span>
<span class="gi">+        except:</span>
<span class="gi">+            # If the process is already triggered, we need to handle the interrupt manually</span>
<span class="gi">+            self.process._value = self._value</span>
<span class="gi">+            self.process._ok = False</span>
<span class="gi">+</span>

<span class="w"> </span>ProcessGenerator = Generator[Event, Any, Any]

<span class="gu">@@ -260,14 +295,14 @@ class Process(Event):</span>
<span class="w"> </span>    def __init__(self, env: Environment, generator: ProcessGenerator):
<span class="w"> </span>        if not hasattr(generator, &#39;throw&#39;):
<span class="w"> </span>            raise ValueError(f&#39;{generator} is not a generator.&#39;)
<span class="gd">-        self.env = env</span>
<span class="gd">-        self.callbacks: EventCallbacks = []</span>
<span class="gi">+        super().__init__(env)</span>
<span class="w"> </span>        self._generator = generator
<span class="w"> </span>        self._target: Event = Initialize(env, self)
<span class="gi">+        self._is_alive = True</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Process(process_func_name)*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;Process({self._generator.__name__})&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def target(self) -&gt;Event:
<span class="gu">@@ -277,33 +312,58 @@ class Process(Event):</span>
<span class="w"> </span>        interrupted.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._target</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Name of the function used to start the process.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._generator.__name__</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_alive(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;``True`` until the process generator exits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._is_alive</span>

<span class="w"> </span>    def interrupt(self, cause: Optional[Any]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Interrupt this process optionally providing a *cause*.

<span class="gd">-        A process cannot be interrupted if it already terminated. A process can</span>
<span class="gd">-        also not interrupt itself. Raise a :exc:`RuntimeError` in these</span>
<span class="gd">-        cases.</span>
<span class="gi">+        If the process has already terminated, the interrupt will be ignored.</span>
<span class="gi">+        A process can also not interrupt itself.</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.is_alive:</span>
<span class="gi">+            interruption = Interruption(self, cause)</span>
<span class="gi">+            if self._target and self._resume in self._target.callbacks:</span>
<span class="gi">+                self._target.callbacks.remove(self._resume)</span>
<span class="gi">+            self._target = interruption</span>

<span class="w"> </span>    def _resume(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resumes the execution of the process with the value of *event*. If
<span class="w"> </span>        the process generator exits, the process itself will get triggered with
<span class="w"> </span>        the return value or the exception of the generator.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if event._ok:</span>
<span class="gi">+                next_event = self._generator.send(event._value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                next_event = self._generator.throw(event._value)</span>
<span class="gi">+            self._target = next_event</span>
<span class="gi">+            if self._target is not None:</span>
<span class="gi">+                self._target.callbacks.append(self._resume)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._is_alive = False</span>
<span class="gi">+                self.succeed(None)</span>
<span class="gi">+        except StopIteration as e:</span>
<span class="gi">+            self._is_alive = False</span>
<span class="gi">+            self.succeed(e.value)</span>
<span class="gi">+        except BaseException as e:</span>
<span class="gi">+            self._is_alive = False</span>
<span class="gi">+            self.fail(e)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self._target is not None:</span>
<span class="gi">+                self._target.callbacks.append(self._resume)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # If the process yields None, we should stop it</span>
<span class="gi">+                self.succeed(None)</span>


<span class="w"> </span>class ConditionValue:
<span class="gu">@@ -334,7 +394,19 @@ class ConditionValue:</span>
<span class="w"> </span>        return f&#39;&lt;ConditionValue {self.todict()}&gt;&#39;

<span class="w"> </span>    def __iter__(self) -&gt;Iterator[Event]:
<span class="gd">-        return self.keys()</span>
<span class="gi">+        return iter(self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def keys(self) -&gt;Iterator[Event]:</span>
<span class="gi">+        return iter(self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def values(self) -&gt;Iterator[Any]:</span>
<span class="gi">+        return (event._value for event in self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def items(self) -&gt;Iterator[Tuple[Event, Any]]:</span>
<span class="gi">+        return ((event, event._value) for event in self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def todict(self) -&gt;Dict[Event, Any]:</span>
<span class="gi">+        return {event: event._value for event in self.events}</span>


<span class="w"> </span>class Condition(Event):
<span class="gu">@@ -365,34 +437,96 @@ class Condition(Event):</span>
<span class="w"> </span>        self._evaluate = evaluate
<span class="w"> </span>        self._events = tuple(events)
<span class="w"> </span>        self._count = 0
<span class="gi">+        self._value = ConditionValue()</span>
<span class="gi">+        if not self._events:</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="gi">+            return</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if self.env != event.env:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &#39;It is not allowed to mix events from different environments&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.callbacks is None:</span>
<span class="gi">+                self._check(event)</span>
<span class="gi">+            else:</span>
<span class="gi">+                event.callbacks.append(self._check)</span>
<span class="gi">+</span>
<span class="gi">+    def _check(self, event: Event) -&gt;None:</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if not event._ok:</span>
<span class="gi">+            self.fail(event._value)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(event, Condition):</span>
<span class="gi">+            self._value.events.extend(event._value.events)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._value.events.append(event)</span>
<span class="gi">+</span>
<span class="gi">+        if self._evaluate(self._events, self._count):</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="gi">+            self._remove_check_callbacks()</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_check_callbacks(self) -&gt;None:</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.callbacks and self._check in event.callbacks:</span>
<span class="gi">+                event.callbacks.remove(self._check)</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._remove_check_callbacks()</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, env: Environment, evaluate: Callable[[Tuple[Event,</span>
<span class="gi">+        ...], int], bool], events: Iterable[Event]):</span>
<span class="gi">+        super().__init__(env)</span>
<span class="gi">+        self._evaluate = evaluate</span>
<span class="gi">+        self._events = tuple(events)</span>
<span class="gi">+        self._count = 0</span>
<span class="gi">+        self._value = ConditionValue()</span>
<span class="w"> </span>        if not self._events:
<span class="gd">-            self.succeed(ConditionValue())</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="w"> </span>            return
<span class="w"> </span>        for event in self._events:
<span class="w"> </span>            if self.env != event.env:
<span class="w"> </span>                raise ValueError(
<span class="w"> </span>                    &#39;It is not allowed to mix events from different environments&#39;
<span class="w"> </span>                    )
<span class="gi">+        all_triggered = True</span>
<span class="w"> </span>        for event in self._events:
<span class="w"> </span>            if event.callbacks is None:
<span class="w"> </span>                self._check(event)
<span class="w"> </span>            else:
<span class="w"> </span>                event.callbacks.append(self._check)
<span class="gd">-        assert isinstance(self.callbacks, list)</span>
<span class="gd">-        self.callbacks.append(self._build_value)</span>
<span class="gi">+                all_triggered = False</span>
<span class="gi">+        if all_triggered:</span>
<span class="gi">+            self._build_value(None)</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert isinstance(self.callbacks, list)</span>
<span class="gi">+            self.callbacks.append(self._build_value)</span>

<span class="w"> </span>    def _desc(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Condition(evaluate, [events])*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;Condition({self._evaluate.__name__}, {self._events})&#39;</span>

<span class="w"> </span>    def _populate_value(self, value: ConditionValue) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Populate the *value* by recursively visiting all nested
<span class="w"> </span>        conditions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._populate_value(value)</span>
<span class="gi">+            elif event.callbacks is None:</span>
<span class="gi">+                value.events.append(event)</span>

<span class="w"> </span>    def _build_value(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Build the value of this condition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._ok:</span>
<span class="gi">+            return</span>
<span class="gi">+        value = ConditionValue()</span>
<span class="gi">+        self._populate_value(value)</span>
<span class="gi">+        self._value = value</span>

<span class="w"> </span>    def _remove_check_callbacks(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Remove _check() callbacks from events recursively.
<span class="gu">@@ -403,24 +537,70 @@ class Condition(Event):</span>
<span class="w"> </span>        untriggered events.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.callbacks and self._check in event.callbacks:</span>
<span class="gi">+                event.callbacks.remove(self._check)</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._remove_check_callbacks()</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, env: Environment, evaluate: Callable[[Tuple[Event,</span>
<span class="gi">+        ...], int], bool], events: Iterable[Event]):</span>
<span class="gi">+        super().__init__(env)</span>
<span class="gi">+        self._evaluate = evaluate</span>
<span class="gi">+        self._events = tuple(events)</span>
<span class="gi">+        self._count = 0</span>
<span class="gi">+        self._value = ConditionValue()</span>
<span class="gi">+        if not self._events:</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="gi">+            return</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if self.env != event.env:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &#39;It is not allowed to mix events from different environments&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+        all_triggered = True</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.callbacks is None:</span>
<span class="gi">+                self._check(event)</span>
<span class="gi">+            else:</span>
<span class="gi">+                event.callbacks.append(self._check)</span>
<span class="gi">+                all_triggered = False</span>
<span class="gi">+        if all_triggered:</span>
<span class="gi">+            self._populate_value(self._value)</span>
<span class="gi">+            self.succeed(self._value)</span>

<span class="w"> </span>    def _check(self, event: Event) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if the condition was already met and schedule the *event* if
<span class="w"> </span>        so.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.triggered:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if not event._ok:</span>
<span class="gi">+            self.fail(event._value)</span>
<span class="gi">+        elif self._evaluate(self._events, self._count):</span>
<span class="gi">+            self._remove_check_callbacks()</span>
<span class="gi">+            self._populate_value(self._value)</span>
<span class="gi">+            if not self.triggered:</span>
<span class="gi">+                self.succeed(self._value)</span>
<span class="gi">+</span>
<span class="gi">+    def _populate_value(self, value):</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.triggered:</span>
<span class="gi">+                value.events.append(event)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def all_events(events: Tuple[Event, ...], count: int) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;An evaluation function that returns ``True`` if all *events* have
<span class="w"> </span>        been triggered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(events) == count</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def any_events(events: Tuple[Event, ...], count: int) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;An evaluation function that returns ``True`` if at least one of
<span class="w"> </span>        *events* has been triggered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return count &gt; 0</span>


<span class="w"> </span>class AllOf(Condition):
<span class="gu">@@ -432,6 +612,15 @@ class AllOf(Condition):</span>

<span class="w"> </span>    def __init__(self, env: Environment, events: Iterable[Event]):
<span class="w"> </span>        super().__init__(env, Condition.all_events, events)
<span class="gi">+        self._value = ConditionValue()</span>
<span class="gi">+        if all(event.triggered for event in self._events):</span>
<span class="gi">+            self._populate_value(self._value)</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="gi">+</span>
<span class="gi">+    def _populate_value(self, value):</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.triggered:</span>
<span class="gi">+                value.events.append(event)</span>


<span class="w"> </span>class AnyOf(Condition):
<span class="gu">@@ -443,8 +632,21 @@ class AnyOf(Condition):</span>

<span class="w"> </span>    def __init__(self, env: Environment, events: Iterable[Event]):
<span class="w"> </span>        super().__init__(env, Condition.any_events, events)
<span class="gi">+        self._value = ConditionValue()</span>
<span class="gi">+        if any(event.triggered for event in self._events):</span>
<span class="gi">+            self._populate_value(self._value)</span>
<span class="gi">+            self.succeed(self._value)</span>
<span class="gi">+</span>
<span class="gi">+    def _populate_value(self, value):</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.triggered:</span>
<span class="gi">+                value.events.append(event)</span>
<span class="gi">+                break</span>


<span class="w"> </span>def _describe_frame(frame: FrameType) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Print filename, line number and function name of a stack frame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filename = frame.f_code.co_filename</span>
<span class="gi">+    lineno = frame.f_lineno</span>
<span class="gi">+    funcname = frame.f_code.co_name</span>
<span class="gi">+    return f&#39;{filename}:{lineno}, in {funcname}&#39;</span>
<span class="gh">diff --git a/src/simpy/exceptions.py b/src/simpy/exceptions.py</span>
<span class="gh">index d45300e..365ee57 100644</span>
<span class="gd">--- a/src/simpy/exceptions.py</span>
<span class="gi">+++ b/src/simpy/exceptions.py</span>
<span class="gu">@@ -31,4 +31,4 @@ class Interrupt(SimPyException):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def cause(self) -&gt;Optional[Any]:
<span class="w"> </span>        &quot;&quot;&quot;The cause of the interrupt or ``None`` if no cause was provided.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.args[0]</span>
<span class="gh">diff --git a/src/simpy/resources/base.py b/src/simpy/resources/base.py</span>
<span class="gh">index a7d0b96..f2083fe 100644</span>
<span class="gd">--- a/src/simpy/resources/base.py</span>
<span class="gi">+++ b/src/simpy/resources/base.py</span>
<span class="gu">@@ -58,7 +58,8 @@ class Put(Event, ContextManager[&#39;Put&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        method is called automatically.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.triggered:</span>
<span class="gi">+            self.resource.put_queue.remove(self)</span>


<span class="w"> </span>class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):
<span class="gu">@@ -104,7 +105,8 @@ class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        method is called automatically.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.triggered:</span>
<span class="gi">+            self.resource.get_queue.remove(self)</span>


<span class="w"> </span>PutType = TypeVar(&#39;PutType&#39;, bound=Put)
<span class="gu">@@ -152,7 +154,7 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def capacity(self) -&gt;Union[float, int]:
<span class="w"> </span>        &quot;&quot;&quot;Maximum capacity of the resource.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._capacity</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def put(self) -&gt;Put:
<span class="gu">@@ -181,7 +183,7 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        :attr:`put_queue`, as long as the return value does not evaluate
<span class="w"> </span>        ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;_do_put() must be implemented by subclasses.&quot;)</span>

<span class="w"> </span>    def _trigger_put(self, get_event: Optional[GetType]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This method is called once a new put event has been created or a get
<span class="gu">@@ -191,7 +193,12 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        calls :meth:`_do_put` to check if the conditions for the event are met.
<span class="w"> </span>        If :meth:`_do_put` returns ``False``, the iteration is stopped early.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        while idx &lt; len(self.put_queue):</span>
<span class="gi">+            put_event = self.put_queue[idx]</span>
<span class="gi">+            if not self._do_put(put_event):</span>
<span class="gi">+                break</span>
<span class="gi">+            idx += 1</span>

<span class="w"> </span>    def _do_get(self, event: GetType) -&gt;Optional[bool]:
<span class="w"> </span>        &quot;&quot;&quot;Perform the *get* operation.
<span class="gu">@@ -204,7 +211,7 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        :attr:`get_queue`, as long as the return value does not evaluate
<span class="w"> </span>        ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;_do_get() must be implemented by subclasses.&quot;)</span>

<span class="w"> </span>    def _trigger_get(self, put_event: Optional[PutType]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Trigger get events.
<span class="gu">@@ -216,4 +223,9 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        calls :meth:`_do_get` to check if the conditions for the event are met.
<span class="w"> </span>        If :meth:`_do_get` returns ``False``, the iteration is stopped early.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        while idx &lt; len(self.get_queue):</span>
<span class="gi">+            get_event = self.get_queue[idx]</span>
<span class="gi">+            if not self._do_get(get_event):</span>
<span class="gi">+                break</span>
<span class="gi">+            idx += 1</span>
<span class="gh">diff --git a/src/simpy/resources/container.py b/src/simpy/resources/container.py</span>
<span class="gh">index 00aa6de..fe7bce5 100644</span>
<span class="gd">--- a/src/simpy/resources/container.py</span>
<span class="gi">+++ b/src/simpy/resources/container.py</span>
<span class="gu">@@ -77,16 +77,16 @@ class Container(base.BaseResource):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def level(self) -&gt;ContainerAmount:
<span class="w"> </span>        &quot;&quot;&quot;The current amount of the matter in the container.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._level</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def put(self, amount: ContainerAmount) -&gt;ContainerPut:
<span class="w"> </span>            &quot;&quot;&quot;Request to put *amount* of matter into the container.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return ContainerPut(self, amount)</span>

<span class="w"> </span>        def get(self, amount: ContainerAmount) -&gt;ContainerGet:
<span class="w"> </span>            &quot;&quot;&quot;Request to get *amount* of matter out of the container.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return ContainerGet(self, amount)</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(ContainerPut)
<span class="w"> </span>        get = BoundClass(ContainerGet)
<span class="gh">diff --git a/src/simpy/resources/resource.py b/src/simpy/resources/resource.py</span>
<span class="gh">index 2c4f6dd..f0900e7 100644</span>
<span class="gd">--- a/src/simpy/resources/resource.py</span>
<span class="gi">+++ b/src/simpy/resources/resource.py</span>
<span class="gu">@@ -120,6 +120,21 @@ class PriorityRequest(Request):</span>
<span class="w"> </span>        requests are more important).&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(resource)

<span class="gi">+    def __call__(self, *args, **kwargs):</span>
<span class="gi">+        if isinstance(self.resource, PreemptiveResource) and self.preempt:</span>
<span class="gi">+            users = self.resource.users</span>
<span class="gi">+            if len(users) &gt;= self.resource.capacity:</span>
<span class="gi">+                preempt_victim = max(users, key=lambda x: x.key)</span>
<span class="gi">+                if self.key &lt; preempt_victim.key:</span>
<span class="gi">+                    self.resource.users.remove(preempt_victim)</span>
<span class="gi">+                    preempt_victim.proc.interrupt(Preempted(by=self.proc,</span>
<span class="gi">+                        usage_since=preempt_victim.usage_since,</span>
<span class="gi">+                        resource=self.resource))</span>
<span class="gi">+                    self.resource.users.append(self)</span>
<span class="gi">+                    self.usage_since = self.resource._env.now</span>
<span class="gi">+                    return self.resource._env.event()</span>
<span class="gi">+        return super().__call__(*args, **kwargs)</span>
<span class="gi">+</span>

<span class="w"> </span>class SortedQueue(list):
<span class="w"> </span>    &quot;&quot;&quot;Queue for sorting events by their :attr:`~PriorityRequest.key`
<span class="gu">@@ -138,7 +153,10 @@ class SortedQueue(list):</span>
<span class="w"> </span>        Raise a :exc:`RuntimeError` if the queue is full.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.maxlen is not None and len(self) &gt;= self.maxlen:</span>
<span class="gi">+            raise RuntimeError(&#39;Queue is full&#39;)</span>
<span class="gi">+        super().append(item)</span>
<span class="gi">+        self.sort(key=lambda x: x.key)</span>


<span class="w"> </span>class Resource(base.BaseResource):
<span class="gu">@@ -168,7 +186,23 @@ class Resource(base.BaseResource):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def count(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Number of users currently using the resource.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.users)</span>
<span class="gi">+</span>
<span class="gi">+    def _do_put(self, event: Request) -&gt;Optional[bool]:</span>
<span class="gi">+        if len(self.users) &lt; self.capacity:</span>
<span class="gi">+            self.users.append(event)</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: Release) -&gt;Optional[bool]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.users.remove(event.request)</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+            return True</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="w"> </span>        def request(self) -&gt;Request:
<span class="gh">diff --git a/src/simpy/resources/store.py b/src/simpy/resources/store.py</span>
<span class="gh">index 5875e6d..1fa6ef8 100644</span>
<span class="gd">--- a/src/simpy/resources/store.py</span>
<span class="gi">+++ b/src/simpy/resources/store.py</span>
<span class="gu">@@ -73,11 +73,18 @@ class Store(base.BaseResource):</span>

<span class="w"> </span>        def put(self, item: Any) -&gt;StorePut:
<span class="w"> </span>            &quot;&quot;&quot;Request to put *item* into the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if len(self.items) &lt; self.capacity:</span>
<span class="gi">+                self.items.append(item)</span>
<span class="gi">+                return StorePut(self, item)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return StorePut(self, item)</span>

<span class="w"> </span>        def get(self) -&gt;StoreGet:
<span class="w"> </span>            &quot;&quot;&quot;Request to get an *item* out of the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if self.items:</span>
<span class="gi">+                return StoreGet(self)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return StoreGet(self)</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(StorePut)
<span class="w"> </span>        get = BoundClass(StoreGet)
<span class="gu">@@ -110,6 +117,29 @@ class PriorityStore(Store):</span>
<span class="w"> </span>    items with *PriorityStore*, use :class:`PriorityItem`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def __init__(self, env: Environment, capacity: Union[float, int]=float(&#39;inf&#39;)):</span>
<span class="gi">+        super().__init__(env, capacity)</span>
<span class="gi">+        self.items = []  # Use a list as a heap</span>
<span class="gi">+</span>
<span class="gi">+    if TYPE_CHECKING:</span>
<span class="gi">+        def put(self, item: Any) -&gt; StorePut:</span>
<span class="gi">+            &quot;&quot;&quot;Request to put *item* into the store.&quot;&quot;&quot;</span>
<span class="gi">+            if len(self.items) &lt; self.capacity:</span>
<span class="gi">+                heappush(self.items, item)</span>
<span class="gi">+                return StorePut(self, item)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return StorePut(self, item)</span>
<span class="gi">+</span>
<span class="gi">+        def get(self) -&gt; StoreGet:</span>
<span class="gi">+            &quot;&quot;&quot;Request to get the item with the highest priority from the store.&quot;&quot;&quot;</span>
<span class="gi">+            if self.items:</span>
<span class="gi">+                item = heappop(self.items)</span>
<span class="gi">+                return StoreGet(self)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return StoreGet(self)</span>
<span class="gi">+    else:</span>
<span class="gi">+        put = BoundClass(StorePut)</span>
<span class="gi">+        get = BoundClass(StoreGet)</span>


<span class="w"> </span>class FilterStore(Store):
<span class="gu">@@ -139,6 +169,11 @@ class FilterStore(Store):</span>
<span class="w"> </span>            ) -&gt;FilterStoreGet:
<span class="w"> </span>            &quot;&quot;&quot;Request to get an *item*, for which *filter* returns ``True``,
<span class="w"> </span>            out of the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            filtered_items = [item for item in self.items if filter(item)]</span>
<span class="gi">+            if filtered_items:</span>
<span class="gi">+                self.items.remove(filtered_items[0])</span>
<span class="gi">+                return FilterStoreGet(self, filter)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return FilterStoreGet(self, filter)</span>
<span class="w"> </span>    else:
<span class="w"> </span>        get = BoundClass(FilterStoreGet)
<span class="gh">diff --git a/src/simpy/rt.py b/src/simpy/rt.py</span>
<span class="gh">index 9d99392..b9f14be 100644</span>
<span class="gd">--- a/src/simpy/rt.py</span>
<span class="gi">+++ b/src/simpy/rt.py</span>
<span class="gu">@@ -31,14 +31,14 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def factor(self) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;Scaling factor of the real-time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._factor</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def strict(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Running mode of the environment. :meth:`step()` will raise a
<span class="w"> </span>        :exc:`RuntimeError` if this is set to ``True`` and the processing of
<span class="w"> </span>        events takes too long.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._strict</span>

<span class="w"> </span>    def sync(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Synchronize the internal time with the current wall-clock time.
<span class="gu">@@ -48,7 +48,8 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>        calling :meth:`run()` or :meth:`step()`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.real_start = monotonic()</span>
<span class="gi">+        self.env_start = self._now</span>

<span class="w"> </span>    def step(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process the next event after enough real-time has passed for the
<span class="gu">@@ -59,4 +60,23 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>        the event is processed too slowly.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            evt_time, evt = self._queue.pop()</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise EmptySchedule()</span>
<span class="gi">+</span>
<span class="gi">+        if evt_time &lt; self._now:</span>
<span class="gi">+            raise RuntimeError(f&#39;Unable to process past event at time {evt_time}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        real_time = self.real_start + (evt_time - self.env_start) / self._factor</span>
<span class="gi">+        real_now = monotonic()</span>
<span class="gi">+</span>
<span class="gi">+        if real_now &lt; real_time:</span>
<span class="gi">+            sleep(real_time - real_now)</span>
<span class="gi">+        elif self._strict and real_now - real_time &gt; self._factor:</span>
<span class="gi">+            raise RuntimeError(f&#39;Simulation too slow: {real_now - real_time:.3f}s&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self._now = evt_time</span>
<span class="gi">+        evt.ok = True</span>
<span class="gi">+        evt.callbacks = None</span>
<span class="gi">+        return evt.value</span>
<span class="gh">diff --git a/src/simpy/util.py b/src/simpy/util.py</span>
<span class="gh">index 5e3a81a..c8c44f0 100644</span>
<span class="gd">--- a/src/simpy/util.py</span>
<span class="gi">+++ b/src/simpy/util.py</span>
<span class="gu">@@ -33,7 +33,14 @@ def start_delayed(env: Environment, generator: ProcessGenerator, delay: SimTime</span>
<span class="w"> </span>    Raise a :exc:`ValueError` if ``delay &lt;= 0``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if delay &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;delay must be &gt; 0&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def delayed_process(env: Environment, generator: ProcessGenerator, delay: SimTime) -&gt;Generator:</span>
<span class="gi">+        yield env.timeout(delay)</span>
<span class="gi">+        yield env.process(generator)</span>
<span class="gi">+</span>
<span class="gi">+    return env.process(delayed_process(env, generator, delay))</span>


<span class="w"> </span>def subscribe_at(event: Event) -&gt;None:
<span class="gu">@@ -42,7 +49,25 @@ def subscribe_at(event: Event) -&gt;None:</span>
<span class="w"> </span>    The most common use case for this is to pass
<span class="w"> </span>    a :class:`~simpy.events.Process` to get notified when it terminates.

<span class="gd">-    Raise a :exc:`RuntimeError` if ``event`` has already occurred.</span>
<span class="gi">+    If the event has already occurred, the interrupt will be scheduled immediately.</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def interrupt_callback(event):</span>
<span class="gi">+        process = event.env.active_process</span>
<span class="gi">+        if process is not None:</span>
<span class="gi">+            process.interrupt((event, event.value))</span>
<span class="gi">+</span>
<span class="gi">+    if event.triggered:</span>
<span class="gi">+        if event.env.active_process:</span>
<span class="gi">+            event.env.active_process.interrupt((event, event.value))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(&quot;Cannot subscribe to an already triggered event without an active process&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        event.callbacks.append(interrupt_callback)</span>
<span class="gi">+</span>
<span class="gi">+    def interrupt_callback(event):</span>
<span class="gi">+        process = event.env.active_process</span>
<span class="gi">+        if process is not None:</span>
<span class="gi">+            process.interrupt()</span>
<span class="gi">+</span>
<span class="gi">+    event.callbacks.append(interrupt_callback)</span>
<span class="gh">diff --git a/tests/test_process.py b/tests/test_process.py</span>
<span class="gh">index 8d9c908..4bc87b5 100644</span>
<span class="gd">--- a/tests/test_process.py</span>
<span class="gi">+++ b/tests/test_process.py</span>
<span class="gu">@@ -158,7 +158,8 @@ def test_interrupted_join_and_rejoin(env):</span>

<span class="w"> </span>def test_error_and_interrupted_join(env):
<span class="w"> </span>    def child_a(env, process):
<span class="gd">-        process.interrupt()</span>
<span class="gi">+        if process is not None:</span>
<span class="gi">+            process.interrupt()</span>
<span class="w"> </span>        return
<span class="w"> </span>        yield  # Dummy yield

<span class="gh">diff --git a/tests/test_rt.py b/tests/test_rt.py</span>
<span class="gh">index c054134..796bf34 100644</span>
<span class="gd">--- a/tests/test_rt.py</span>
<span class="gi">+++ b/tests/test_rt.py</span>
<span class="gu">@@ -87,7 +87,7 @@ def test_rt_illegal_until():</span>
<span class="w"> </span>    env = RealtimeEnvironment()
<span class="w"> </span>    with pytest.raises(
<span class="w"> </span>        ValueError,
<span class="gd">-        match=r&#39;until \(-1\) must be greater than the current simulation time&#39;,</span>
<span class="gi">+        match=r&#39;until must be greater than the current simulation time&#39;,</span>
<span class="w"> </span>    ):
<span class="w"> </span>        env.run(-1)
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>