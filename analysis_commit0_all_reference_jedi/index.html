
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference jedi - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-jedi" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference jedi
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-test" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsnone-test-none-expected1" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[None-"test-None-expected1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsnone-test-4-expected2" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[None-"test-4-expected2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-rtes-5-expected7" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-r"tes"-5-expected7]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-rtes-5-expected9" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-r"tes"-5-expected9]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comp-5-expected10" class="md-nav__link">
    <span class="md-ellipsis">
      comp"-5-expected10]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tes-none-expected13" class="md-nav__link">
    <span class="md-ellipsis">
      tes-None-expected13]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-rtest-none-expected16" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-r"""test-None-expected16]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-utesn-column18-expected18" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-u"""tes\n-column18-expected18]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected24" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-x = f("te" + "st)-16-expected24]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected25" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-x = f("te" + "st-16-expected25]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected26" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-x = f("te" + "st"-16-expected26]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected27" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-x = f("te" + "st")-16-expected27]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-x-ft-est-16-expected28" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-x = f("t" + "est")-16-expected28]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_completionpytest_file_path_completionsexamplepy-test-none-expected30" class="md-nav__link">
    <span class="md-ellipsis">
      test_completion.py::test_file_path_completions[example.py-"test" + "-None-expected30]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test-none-expected31" class="md-nav__link">
    <span class="md-ellipsis">
      test-None-expected31]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-9-expected42" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin("tes-9-expected42]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-9-expected43" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin('tes)-9-expected43]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njoinrtes-10-expected44" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin(r"tes"-10-expected44]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-11-expected45" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin("""tes""")-11-expected45]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-9-expected46" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin["tes-9-expected46]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-9-expected47" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin["tes"-9-expected47]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-9-expected48" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin["tes"]-9-expected48]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-10-expected57" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin(["tes-10-expected57]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-10-expected58" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin(["tes"]-10-expected58]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examplepy-from-ospath-import-njointes-10-expected59" class="md-nav__link">
    <span class="md-ellipsis">
      example.py-from os.path import *\njoin(["tes"])-10-expected59]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_working_venv" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_working_venv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_scanning_venvs" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_scanning_venvs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_create_environment_venv_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_create_environment_venv_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_changing_venv" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_changing_venv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_importspytest_flask_extimport-flaskextfoo-flaskextfoo-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_imports.py::test_flask_ext[import flask.ext.foo; flask.ext.foo.-Foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_importspytest_flask_extimport-flaskextbar-flaskextbar-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_imports.py::test_flask_ext[import flask.ext.bar; flask.ext.bar.-Foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_importspytest_flask_extimport-flaskextbaz-flaskextbaz-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_imports.py::test_flask_ext[import flask.ext.baz; flask.ext.baz.-Foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_importspytest_flask_extimport-flaskextmoo-flaskextmoo-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_imports.py::test_flask_ext[import flask.ext.moo; flask.ext.moo.-Foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_precedencepytest_equals" class="md-nav__link">
    <span class="md-ellipsis">
      test_precedence.py::test_equals[... == ...]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sys_pathpytest_venv_and_pths" class="md-nav__link">
    <span class="md-ellipsis">
      test_sys_path.py::test_venv_and_pths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytestsetupreadlinetest_colorama" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::TestSetupReadline::test_colorama
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytestsetupreadlinetest_modules" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::TestSetupReadline::test_modules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytestsetupreadlinetest_preexisting_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::TestSetupReadline::test_preexisting_values
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-jedi"><strong>Reference (Gold)</strong>: jedi</h1>
<h2 id="pytest-summary-for-test-test">Pytest Summary for test <code>test</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">3814</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">28</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">22</td>
</tr>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">3874</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">3874</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_completionpytest_file_path_completionsnone-test-none-expected1">test_completion.py::test_file_path_completions[None-"test-None-expected1]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[None-"test-None-expected1]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = None, code = '"test', column = None, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['/', '_output.txt"'] == ['/']
E             
E             Left contains one more item: '_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsnone-test-4-expected2">test_completion.py::test_file_path_completions[None-"test-4-expected2]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[None-"test-4-expected2]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = None, code = '"test', column = 4, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t/', 't_output.txt"'] == ['t/']
E             
E             Left contains one more item: 't_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-rtes-5-expected7">test_completion.py::test_file_path_completions[example.py-r"tes"-5-expected7]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-r"tes"-5-expected7]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'r"tes"', column = 5, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t/', 't_output.txt'] == ['t/']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-rtes-5-expected9">example.py-r"tes"-5-expected9]</h3>
<details><summary> <pre>example.py-r"tes"-5-expected9]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'test/example.py', code = 'r"tes"', column = 5, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t/', 't_output.txt'] == ['t/']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="comp-5-expected10">comp"-5-expected10]</h3>
<details><summary> <pre>comp"-5-expected10]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'test/example.py', code = 'r"test/comp"', column = 5, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t/', 't_output.txt"'] == ['t/']
E             
E             Left contains one more item: 't_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="tes-none-expected13">tes-None-expected13]</h3>
<details><summary> <pre>tes-None-expected13]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'rb"../testbed/tes', column = None
expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t/', 't_output.txt"'] == ['t/']
E             
E             Left contains one more item: 't_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-rtest-none-expected16">test_completion.py::test_file_path_completions[example.py-r"""test-None-expected16]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-r"""test-None-expected16]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'r"""test', column = None, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['/', '_output.txt"""'] == ['/']
E             
E             Left contains one more item: '_output.txt"""'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-utesn-column18-expected18">test_completion.py::test_file_path_completions[example.py-u"""tes\n-column18-expected18]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-u"""tes\n-column18-expected18]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'u"""tes\n', column = 7, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t/', 't_output.txt"""'] == ['t/']
E             
E             Left contains one more item: 't_output.txt"""'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected24">test_completion.py::test_file_path_completions[example.py-x = f("te" + "st)-16-expected24]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-x = f("te" + "st)-16-expected24]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'x = f("te" + "st)', column = 16, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['/', '_output.txt"'] == ['/']
E             
E             Left contains one more item: '_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected25">test_completion.py::test_file_path_completions[example.py-x = f("te" + "st-16-expected25]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-x = f("te" + "st-16-expected25]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'x = f("te" + "st', column = 16, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['/', '_output.txt"'] == ['/']
E             
E             Left contains one more item: '_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected26">test_completion.py::test_file_path_completions[example.py-x = f("te" + "st"-16-expected26]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-x = f("te" + "st"-16-expected26]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'x = f("te" + "st"', column = 16, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['/', '_output.txt'] == ['/']
E             
E             Left contains one more item: '_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-x-fte-st-16-expected27">test_completion.py::test_file_path_completions[example.py-x = f("te" + "st")-16-expected27]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-x = f("te" + "st")-16-expected27]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'x = f("te" + "st")', column = 16, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['/', '_output.txt'] == ['/']
E             
E             Left contains one more item: '_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-x-ft-est-16-expected28">test_completion.py::test_file_path_completions[example.py-x = f("t" + "est")-16-expected28]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-x = f("t" + "est")-16-expected28]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = 'x = f("t" + "est")', column = 16, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['/', '_output.txt'] == ['/']
E             
E             Left contains one more item: '_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_completionpytest_file_path_completionsexamplepy-test-none-expected30">test_completion.py::test_file_path_completions[example.py-"test" + "-None-expected30]</h3>
<details><summary> <pre>test_completion.py::test_file_path_completions[example.py-"test" + "-None-expected30]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = 'example.py', code = '"test" + "', column = None, expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['/', '_output.txt"'] == ['/']
E             
E             Left contains one more item: '_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test-none-expected31">test-None-expected31]</h3>
<details><summary> <pre>test-None-expected31]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/example.py'
code = 'from os.path import *\ndirname(__file__) + "/test', column = None
expected = ['/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['/', '_output.txt"'] == ['/']
E             
E             Left contains one more item: '_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-9-expected42">example.py-from os.path import *\njoin("tes-9-expected42]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin("tes-9-expected42]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin("tes'
column = 9, expected = ['t"']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t"', 't_output.txt"'] == ['t"']
E             
E             Left contains one more item: 't_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-9-expected43">example.py-from os.path import *\njoin('tes)-9-expected43]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin('tes)-9-expected43]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = "from os.path import *\njoin('tes)"
column = 9, expected = ["t'"]

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ["t'", "t_output.txt'"] == ["t'"]
E             
E             Left contains one more item: "t_output.txt'"
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njoinrtes-10-expected44">example.py-from os.path import *\njoin(r"tes"-10-expected44]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin(r"tes"-10-expected44]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin(r"tes"'
column = 10, expected = ['t']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t', 't_output.txt'] == ['t']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-11-expected45">example.py-from os.path import *\njoin("""tes""")-11-expected45]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin("""tes""")-11-expected45]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py'
code = 'from os.path import *\njoin("""tes""")', column = 11, expected = ['t']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t', 't_output.txt'] == ['t']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-9-expected46">example.py-from os.path import *\njoin["tes-9-expected46]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin["tes-9-expected46]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin["tes'
column = 9, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t/', 't_output.txt"'] == ['t/']
E             
E             Left contains one more item: 't_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-9-expected47">example.py-from os.path import *\njoin["tes"-9-expected47]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin["tes"-9-expected47]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin["tes"'
column = 9, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t/', 't_output.txt'] == ['t/']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-9-expected48">example.py-from os.path import *\njoin["tes"]-9-expected48]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin["tes"]-9-expected48]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin["tes"]'
column = 9, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t/', 't_output.txt'] == ['t/']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-10-expected57">example.py-from os.path import *\njoin(["tes-10-expected57]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin(["tes-10-expected57]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin(["tes'
column = 10, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           assert ['t/', 't_output.txt"'] == ['t/']
E             
E             Left contains one more item: 't_output.txt"'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-10-expected58">example.py-from os.path import *\njoin(["tes"]-10-expected58]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin(["tes"]-10-expected58]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin(["tes"]'
column = 10, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t/', 't_output.txt'] == ['t/']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="examplepy-from-ospath-import-njointes-10-expected59">example.py-from os.path import *\njoin(["tes"])-10-expected59]</h3>
<details><summary> <pre>example.py-from os.path import *\njoin(["tes"])-10-expected59]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
file = '/testbed/test/example.py', code = 'from os.path import *\njoin(["tes"])'
column = 10, expected = ['t/']

    @pytest.mark.parametrize(
        'file, code, column, expected', [
            # General tests / relative paths
            (None, '"comp', None, []),  # No files like comp
            (None, '"test', None, [s]),
            (None, '"test', 4, ['t' + s]),
            ('example.py', '"test%scomp' % s, None, ['letion' + s]),
            ('example.py', 'r"comp"', None, []),
            ('example.py', 'r"tes"', None, []),
            ('example.py', '1 + r"tes"', None, []),
            ('example.py', 'r"tes"', 5, ['t' + s]),
            ('example.py', 'r" tes"', 6, []),
            ('test%sexample.py' % se, 'r"tes"', 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 5, ['t' + s]),
            ('test%sexample.py' % se, 'r"test%scomp"' % s, 11, ['letion' + s]),
            ('test%sexample.py' % se, '"%s"' % join('test', 'completion', 'basi'), 21, ['c.py']),
            ('example.py', 'rb"' + join('..', current_dirname, 'tes'), None, ['t' + s]),

            # Absolute paths
            (None, f'"{root_dir.joinpath("test", "test_ca")}', None, ['che.py"']),
            (None, f'"{root_dir.joinpath("test", "test_ca")}"', len(str(root_dir)) + 14, ['che.py']),

            # Longer quotes
            ('example.py', 'r"""test', None, [s]),
            ('example.py', 'r"""\ntest', None, []),
            ('example.py', 'u"""tes\n', (1, 7), ['t' + s]),
            ('example.py', '"""test%stest_cache.p"""' % s, 20, ['y']),
            ('example.py', '"""test%stest_cache.p"""' % s, 19, ['py"""']),

            # Adding
            ('example.py', '"test" + "%stest_cac' % se, None, ['he.py"']),
            ('example.py', '"test" + "%s" + "test_cac' % se, None, ['he.py"']),
            ('example.py', 'x = 1 + "test', None, []),
            ('example.py', 'x = f("te" + "st)', 16, [s]),
            ('example.py', 'x = f("te" + "st', 16, [s]),
            ('example.py', 'x = f("te" + "st"', 16, [s]),
            ('example.py', 'x = f("te" + "st")', 16, [s]),
            ('example.py', 'x = f("t" + "est")', 16, [s]),
            ('example.py', 'x = f(b"t" + "est")', 17, []),
            ('example.py', '"test" + "', None, [s]),

            # __file__
            (f1, os_path + 'dirname(__file__) + "%stest' % s, None, [s]),
            (f2, os_path + 'dirname(__file__) + "%stest_ca' % se, None, ['che.py"']),
            (f2, os_path + 'dirname(abspath(__file__)) + sep + "test_ca', None, ['che.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion") + sep + "basi', None, ['c.py"']),
            (f2, os_path + 'join("test", "completion") + sep + "basi', None, ['c.py"']),

            # inside join
            (f2, os_path + 'join(dirname(__file__), "completion", "basi', None, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 43, ['c.py"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 43, ['c.py']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 35, ['']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi)', 33, ['on"']),
            (f2, os_path + 'join(dirname(__file__), "completion", "basi")', 33, ['on"']),

            # join with one argument. join will not get inferred and the result is
            # that directories and in a slash. This is unfortunate, but doesn't
            # really matter.
            (f2, os_path + 'join("tes', 9, ['t"']),
            (f2, os_path + 'join(\'tes)', 9, ["t'"]),
            (f2, os_path + 'join(r"tes"', 10, ['t']),
            (f2, os_path + 'join("""tes""")', 11, ['t']),

            # Almost like join but not really
            (f2, os_path + 'join["tes', 9, ['t' + s]),
            (f2, os_path + 'join["tes"', 9, ['t' + s]),
            (f2, os_path + 'join["tes"]', 9, ['t' + s]),
            (f2, os_path + 'join[dirname(__file__), "completi', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"', 33, []),
            (f2, os_path + 'join[dirname(__file__), "completi"]', 33, []),

            # With full paths
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi', 49, ['on"']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi"', 49, ['on']),
            (f2, 'import os\nos.path.join(os.path.dirname(__file__), "completi")', 49, ['on']),

            # With alias
            (f2, 'import os.path as p as p\np.join(p.dirname(__file__), "completi', None, ['on"']),
            (f2, 'from os.path import dirname, join as j\nj(dirname(__file__), "completi',
             None, ['on"']),

            # Trying to break it
            (f2, os_path + 'join(["tes', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"]', 10, ['t' + s]),
            (f2, os_path + 'join(["tes"])', 10, ['t' + s]),
            (f2, os_path + 'join("test", "test_cac" + x,', 22, ['he.py']),

            # GH #1528
            (f2, "'a' 'b'", 4, Ellipsis),
        ]
    )
    def test_file_path_completions(Script, file, code, column, expected):
        line = None
        if isinstance(column, tuple):
            line, column = column
        comps = Script(code, path=file).complete(line=line, column=column)
        if expected is Ellipsis:
            assert len(comps) > 100  # This is basically global completions.
        else:
>           assert [c.complete for c in comps] == expected
E           AssertionError: assert ['t/', 't_output.txt'] == ['t/']
E             
E             Left contains one more item: 't_output.txt'
E             Use -v to get more diff

test/test_api/test_completion.py:297: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_working_venv">test_environment.py::test_working_venv</h3>
<details><summary> <pre>test_environment.py::test_working_venv</pre></summary><pre>
tmpdir_factory = TempdirFactory(_tmppath_factory=TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x7f7a40e158a0>, _basetemp=PosixPath('/tmp/pytest-of-root/pytest-0'), _retention_count=3, _retention_policy='all'))
environment = <Environment: 3.10.12 in /testbed/.venv>

    @pytest.fixture(scope='session')
    def venv_path(tmpdir_factory, environment):
        if isinstance(environment, InterpreterEnvironment):
            # The environment can be a tox virtualenv environment which we don't
            # want, so use the system environment.
            environment = get_system_environment(
                '.'.join(str(x) for x in environment.version_info[:2])
            )

        tmpdir = tmpdir_factory.mktemp('venv_path')
        dirname = os.path.join(tmpdir.strpath, 'venv')

        # We cannot use the Python from tox because tox creates virtualenvs and
        # they have different site.py files that work differently than the default
        # ones. Instead, we find the real Python executable by printing the value
        # of sys.base_prefix or sys.real_prefix if we are in a virtualenv.
        output = subprocess.check_output([
            environment.executable, "-c",
            "import sys; "
            "print(sys.real_prefix if hasattr(sys, 'real_prefix') else sys.base_prefix)"
        ])
        prefix = output.rstrip().decode('utf8')
        if os.name == 'nt':
            executable_path = os.path.join(prefix, 'python')
        else:
            executable_name = os.path.basename(environment.executable)
            executable_path = os.path.join(prefix, 'bin', executable_name)

        return_code = subprocess.call([executable_path, '-m', 'venv', dirname])
>       assert return_code == 0, return_code
E       AssertionError: 1
E       assert 1 == 0

test/conftest.py:128: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_scanning_venvs">test_environment.py::test_scanning_venvs</h3>
<details><summary> <pre>test_environment.py::test_scanning_venvs</pre></summary><pre>
tmpdir_factory = TempdirFactory(_tmppath_factory=TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x7f7a40e158a0>, _basetemp=PosixPath('/tmp/pytest-of-root/pytest-0'), _retention_count=3, _retention_policy='all'))
environment = <Environment: 3.10.12 in /testbed/.venv>

    @pytest.fixture(scope='session')
    def venv_path(tmpdir_factory, environment):
        if isinstance(environment, InterpreterEnvironment):
            # The environment can be a tox virtualenv environment which we don't
            # want, so use the system environment.
            environment = get_system_environment(
                '.'.join(str(x) for x in environment.version_info[:2])
            )

        tmpdir = tmpdir_factory.mktemp('venv_path')
        dirname = os.path.join(tmpdir.strpath, 'venv')

        # We cannot use the Python from tox because tox creates virtualenvs and
        # they have different site.py files that work differently than the default
        # ones. Instead, we find the real Python executable by printing the value
        # of sys.base_prefix or sys.real_prefix if we are in a virtualenv.
        output = subprocess.check_output([
            environment.executable, "-c",
            "import sys; "
            "print(sys.real_prefix if hasattr(sys, 'real_prefix') else sys.base_prefix)"
        ])
        prefix = output.rstrip().decode('utf8')
        if os.name == 'nt':
            executable_path = os.path.join(prefix, 'python')
        else:
            executable_name = os.path.basename(environment.executable)
            executable_path = os.path.join(prefix, 'bin', executable_name)

        return_code = subprocess.call([executable_path, '-m', 'venv', dirname])
>       assert return_code == 0, return_code
E       AssertionError: 1
E       assert 1 == 0

test/conftest.py:128: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_create_environment_venv_path">test_environment.py::test_create_environment_venv_path</h3>
<details><summary> <pre>test_environment.py::test_create_environment_venv_path</pre></summary><pre>
tmpdir_factory = TempdirFactory(_tmppath_factory=TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x7f7a40e158a0>, _basetemp=PosixPath('/tmp/pytest-of-root/pytest-0'), _retention_count=3, _retention_policy='all'))
environment = <Environment: 3.10.12 in /testbed/.venv>

    @pytest.fixture(scope='session')
    def venv_path(tmpdir_factory, environment):
        if isinstance(environment, InterpreterEnvironment):
            # The environment can be a tox virtualenv environment which we don't
            # want, so use the system environment.
            environment = get_system_environment(
                '.'.join(str(x) for x in environment.version_info[:2])
            )

        tmpdir = tmpdir_factory.mktemp('venv_path')
        dirname = os.path.join(tmpdir.strpath, 'venv')

        # We cannot use the Python from tox because tox creates virtualenvs and
        # they have different site.py files that work differently than the default
        # ones. Instead, we find the real Python executable by printing the value
        # of sys.base_prefix or sys.real_prefix if we are in a virtualenv.
        output = subprocess.check_output([
            environment.executable, "-c",
            "import sys; "
            "print(sys.real_prefix if hasattr(sys, 'real_prefix') else sys.base_prefix)"
        ])
        prefix = output.rstrip().decode('utf8')
        if os.name == 'nt':
            executable_path = os.path.join(prefix, 'python')
        else:
            executable_name = os.path.basename(environment.executable)
            executable_path = os.path.join(prefix, 'bin', executable_name)

        return_code = subprocess.call([executable_path, '-m', 'venv', dirname])
>       assert return_code == 0, return_code
E       AssertionError: 1
E       assert 1 == 0

test/conftest.py:128: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_changing_venv">test_environment.py::test_changing_venv</h3>
<details><summary> <pre>test_environment.py::test_changing_venv</pre></summary><pre>
tmpdir_factory = TempdirFactory(_tmppath_factory=TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x7f7a40e158a0>, _basetemp=PosixPath('/tmp/pytest-of-root/pytest-0'), _retention_count=3, _retention_policy='all'))
environment = <Environment: 3.10.12 in /testbed/.venv>

    @pytest.fixture(scope='session')
    def venv_path(tmpdir_factory, environment):
        if isinstance(environment, InterpreterEnvironment):
            # The environment can be a tox virtualenv environment which we don't
            # want, so use the system environment.
            environment = get_system_environment(
                '.'.join(str(x) for x in environment.version_info[:2])
            )

        tmpdir = tmpdir_factory.mktemp('venv_path')
        dirname = os.path.join(tmpdir.strpath, 'venv')

        # We cannot use the Python from tox because tox creates virtualenvs and
        # they have different site.py files that work differently than the default
        # ones. Instead, we find the real Python executable by printing the value
        # of sys.base_prefix or sys.real_prefix if we are in a virtualenv.
        output = subprocess.check_output([
            environment.executable, "-c",
            "import sys; "
            "print(sys.real_prefix if hasattr(sys, 'real_prefix') else sys.base_prefix)"
        ])
        prefix = output.rstrip().decode('utf8')
        if os.name == 'nt':
            executable_path = os.path.join(prefix, 'python')
        else:
            executable_name = os.path.basename(environment.executable)
            executable_path = os.path.join(prefix, 'bin', executable_name)

        return_code = subprocess.call([executable_path, '-m', 'venv', dirname])
>       assert return_code == 0, return_code
E       AssertionError: 1
E       assert 1 == 0

test/conftest.py:128: AssertionError
</pre>
</details>
<h3 id="test_importspytest_flask_extimport-flaskextfoo-flaskextfoo-foo">test_imports.py::test_flask_ext[import flask.ext.foo; flask.ext.foo.-Foo]</h3>
<details><summary> <pre>test_imports.py::test_flask_ext[import flask.ext.foo; flask.ext.foo.-Foo]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
code = 'import flask.ext.foo; flask.ext.foo.', name = 'Foo'

    @pytest.mark.parametrize("code,name", [
        ("from flask.ext import foo; foo.", "Foo"),  # flask_foo.py
        ("from flask.ext import bar; bar.", "Bar"),  # flaskext/bar.py
        ("from flask.ext import baz; baz.", "Baz"),  # flask_baz/__init__.py
        ("from flask.ext import moo; moo.", "Moo"),  # flaskext/moo/__init__.py
        ("from flask.ext.", "foo"),
        ("from flask.ext.", "bar"),
        ("from flask.ext.", "baz"),
        ("from flask.ext.", "moo"),
        pytest.param("import flask.ext.foo; flask.ext.foo.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.bar; flask.ext.bar.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.baz; flask.ext.baz.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.moo; flask.ext.moo.", "Foo", marks=pytest.mark.xfail),
    ])
    def test_flask_ext(Script, code, name):
        """flask.ext.foo is really imported from flaskext.foo or flask_foo.
        """
        path = get_example_dir('flask-site-packages')
        completions = Script(code, project=Project('.', sys_path=[path])).complete()
>       assert name in [c.name for c in completions]
E       AssertionError: assert 'Foo' in []

test/test_inference/test_imports.py:169: AssertionError
</pre>
</details>
<h3 id="test_importspytest_flask_extimport-flaskextbar-flaskextbar-foo">test_imports.py::test_flask_ext[import flask.ext.bar; flask.ext.bar.-Foo]</h3>
<details><summary> <pre>test_imports.py::test_flask_ext[import flask.ext.bar; flask.ext.bar.-Foo]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
code = 'import flask.ext.bar; flask.ext.bar.', name = 'Foo'

    @pytest.mark.parametrize("code,name", [
        ("from flask.ext import foo; foo.", "Foo"),  # flask_foo.py
        ("from flask.ext import bar; bar.", "Bar"),  # flaskext/bar.py
        ("from flask.ext import baz; baz.", "Baz"),  # flask_baz/__init__.py
        ("from flask.ext import moo; moo.", "Moo"),  # flaskext/moo/__init__.py
        ("from flask.ext.", "foo"),
        ("from flask.ext.", "bar"),
        ("from flask.ext.", "baz"),
        ("from flask.ext.", "moo"),
        pytest.param("import flask.ext.foo; flask.ext.foo.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.bar; flask.ext.bar.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.baz; flask.ext.baz.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.moo; flask.ext.moo.", "Foo", marks=pytest.mark.xfail),
    ])
    def test_flask_ext(Script, code, name):
        """flask.ext.foo is really imported from flaskext.foo or flask_foo.
        """
        path = get_example_dir('flask-site-packages')
        completions = Script(code, project=Project('.', sys_path=[path])).complete()
>       assert name in [c.name for c in completions]
E       AssertionError: assert 'Foo' in []

test/test_inference/test_imports.py:169: AssertionError
</pre>
</details>
<h3 id="test_importspytest_flask_extimport-flaskextbaz-flaskextbaz-foo">test_imports.py::test_flask_ext[import flask.ext.baz; flask.ext.baz.-Foo]</h3>
<details><summary> <pre>test_imports.py::test_flask_ext[import flask.ext.baz; flask.ext.baz.-Foo]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
code = 'import flask.ext.baz; flask.ext.baz.', name = 'Foo'

    @pytest.mark.parametrize("code,name", [
        ("from flask.ext import foo; foo.", "Foo"),  # flask_foo.py
        ("from flask.ext import bar; bar.", "Bar"),  # flaskext/bar.py
        ("from flask.ext import baz; baz.", "Baz"),  # flask_baz/__init__.py
        ("from flask.ext import moo; moo.", "Moo"),  # flaskext/moo/__init__.py
        ("from flask.ext.", "foo"),
        ("from flask.ext.", "bar"),
        ("from flask.ext.", "baz"),
        ("from flask.ext.", "moo"),
        pytest.param("import flask.ext.foo; flask.ext.foo.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.bar; flask.ext.bar.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.baz; flask.ext.baz.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.moo; flask.ext.moo.", "Foo", marks=pytest.mark.xfail),
    ])
    def test_flask_ext(Script, code, name):
        """flask.ext.foo is really imported from flaskext.foo or flask_foo.
        """
        path = get_example_dir('flask-site-packages')
        completions = Script(code, project=Project('.', sys_path=[path])).complete()
>       assert name in [c.name for c in completions]
E       AssertionError: assert 'Foo' in []

test/test_inference/test_imports.py:169: AssertionError
</pre>
</details>
<h3 id="test_importspytest_flask_extimport-flaskextmoo-flaskextmoo-foo">test_imports.py::test_flask_ext[import flask.ext.moo; flask.ext.moo.-Foo]</h3>
<details><summary> <pre>test_imports.py::test_flask_ext[import flask.ext.moo; flask.ext.moo.-Foo]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
code = 'import flask.ext.moo; flask.ext.moo.', name = 'Foo'

    @pytest.mark.parametrize("code,name", [
        ("from flask.ext import foo; foo.", "Foo"),  # flask_foo.py
        ("from flask.ext import bar; bar.", "Bar"),  # flaskext/bar.py
        ("from flask.ext import baz; baz.", "Baz"),  # flask_baz/__init__.py
        ("from flask.ext import moo; moo.", "Moo"),  # flaskext/moo/__init__.py
        ("from flask.ext.", "foo"),
        ("from flask.ext.", "bar"),
        ("from flask.ext.", "baz"),
        ("from flask.ext.", "moo"),
        pytest.param("import flask.ext.foo; flask.ext.foo.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.bar; flask.ext.bar.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.baz; flask.ext.baz.", "Foo", marks=pytest.mark.xfail),
        pytest.param("import flask.ext.moo; flask.ext.moo.", "Foo", marks=pytest.mark.xfail),
    ])
    def test_flask_ext(Script, code, name):
        """flask.ext.foo is really imported from flaskext.foo or flask_foo.
        """
        path = get_example_dir('flask-site-packages')
        completions = Script(code, project=Project('.', sys_path=[path])).complete()
>       assert name in [c.name for c in completions]
E       AssertionError: assert 'Foo' in []

test/test_inference/test_imports.py:169: AssertionError
</pre>
</details>
<h3 id="test_precedencepytest_equals">test_precedence.py::test_equals[... == ...]</h3>
<details><summary> <pre>test_precedence.py::test_equals[... == ...]</pre></summary><pre>
Script = functools.partial(<class 'jedi.api.Script'>, environment=<Environment: 3.10.12 in /testbed/.venv>)
environment = <Environment: 3.10.12 in /testbed/.venv>, source = '... == ...'

    @pytest.mark.parametrize('source', [
        pytest.param('1 == 1'),
        pytest.param('1.0 == 1'),
        # Unfortunately for now not possible, because it's a typeshed object.
        pytest.param('... == ...', marks=pytest.mark.xfail),
    ])
    def test_equals(Script, environment, source):
        script = Script(source)
        node = script._module_node.children[0]
>       first, = script._get_module_context().infer_node(node)
E       ValueError: too many values to unpack (expected 1)

test/test_inference/test_precedence.py:15: ValueError
</pre>
</details>
<h3 id="test_sys_pathpytest_venv_and_pths">test_sys_path.py::test_venv_and_pths</h3>
<details><summary> <pre>test_sys_path.py::test_venv_and_pths</pre></summary><pre>
tmpdir_factory = TempdirFactory(_tmppath_factory=TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x7f7a40e158a0>, _basetemp=PosixPath('/tmp/pytest-of-root/pytest-0'), _retention_count=3, _retention_policy='all'))
environment = <Environment: 3.10.12 in /testbed/.venv>

    @pytest.fixture(scope='session')
    def venv_path(tmpdir_factory, environment):
        if isinstance(environment, InterpreterEnvironment):
            # The environment can be a tox virtualenv environment which we don't
            # want, so use the system environment.
            environment = get_system_environment(
                '.'.join(str(x) for x in environment.version_info[:2])
            )

        tmpdir = tmpdir_factory.mktemp('venv_path')
        dirname = os.path.join(tmpdir.strpath, 'venv')

        # We cannot use the Python from tox because tox creates virtualenvs and
        # they have different site.py files that work differently than the default
        # ones. Instead, we find the real Python executable by printing the value
        # of sys.base_prefix or sys.real_prefix if we are in a virtualenv.
        output = subprocess.check_output([
            environment.executable, "-c",
            "import sys; "
            "print(sys.real_prefix if hasattr(sys, 'real_prefix') else sys.base_prefix)"
        ])
        prefix = output.rstrip().decode('utf8')
        if os.name == 'nt':
            executable_path = os.path.join(prefix, 'python')
        else:
            executable_name = os.path.basename(environment.executable)
            executable_path = os.path.join(prefix, 'bin', executable_name)

        return_code = subprocess.call([executable_path, '-m', 'venv', dirname])
>       assert return_code == 0, return_code
E       AssertionError: 1
E       assert 1 == 0

test/conftest.py:128: AssertionError
</pre>
</details>
<h3 id="test_utilspytestsetupreadlinetest_colorama">test_utils.py::TestSetupReadline::test_colorama</h3>
<details><summary> <pre>test_utils.py::TestSetupReadline::test_colorama</pre></summary><pre>
self = <test.test_utils.TestSetupReadline testMethod=test_colorama>

    def test_colorama(self):
        """
        Only test it if colorama library is available.

        This module is being tested because it uses ``setattr`` at some point,
        which Jedi doesn't understand, but it should still work in the REPL.
        """
        try:
            # if colorama is installed
            import colorama
        except ImportError:
            pass
        else:
            self.namespace.colorama = colorama
>           assert self.complete('colorama')
E           AssertionError: assert []
E            +  where [] = complete('colorama')
E            +    where complete = <test.test_utils.TestSetupReadline testMethod=test_colorama>.complete

test/test_utils.py:113: AssertionError
</pre>
</details>
<h3 id="test_utilspytestsetupreadlinetest_modules">test_utils.py::TestSetupReadline::test_modules</h3>
<details><summary> <pre>test_utils.py::TestSetupReadline::test_modules</pre></summary><pre>
self = <test.test_utils.TestSetupReadline testMethod=test_modules>

    def test_modules(self):
        import sys
        import os
        self.namespace.sys = sys
        self.namespace.os = os

        try:
>           assert self.complete('os.path.join') == ['os.path.join']
E           AssertionError: assert [] == ['os.path.join']
E             
E             Right contains one more item: 'os.path.join'
E             Use -v to get more diff

test/test_utils.py:54: AssertionError
</pre>
</details>
<h3 id="test_utilspytestsetupreadlinetest_preexisting_values">test_utils.py::TestSetupReadline::test_preexisting_values</h3>
<details><summary> <pre>test_utils.py::TestSetupReadline::test_preexisting_values</pre></summary><pre>
self = <test.test_utils.TestSetupReadline testMethod=test_preexisting_values>

    def test_preexisting_values(self):
        self.namespace.a = range(10)
>       assert set(self.complete('a.')) == {'a.' + n for n in dir(range(1))}
E       AssertionError: assert set() == {'a.__bool__'...__doc__', ...}
E         
E         Extra items in the right set:
E         'a.step'
E         'a.__class__'
E         'a.__le__'
E         'a.count'
E         'a.__len__'...
E         
E         ...Full output truncated (30 lines hidden), use '-vv' to show

test/test_utils.py:96: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/jedi/_compatibility.py b/jedi/_compatibility.py</span>
<span class="gh">index 976a96ed..13a74b7b 100644</span>
<span class="gd">--- a/jedi/_compatibility.py</span>
<span class="gi">+++ b/jedi/_compatibility.py</span>
<span class="gu">@@ -5,3 +5,28 @@ different Python versions.</span>
<span class="w"> </span>import errno
<span class="w"> </span>import sys
<span class="w"> </span>import pickle
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pickle_load(file):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return pickle.load(file)</span>
<span class="gi">+    # Python on Windows don&#39;t throw EOF errors for pipes. So reraise them with</span>
<span class="gi">+    # the correct type, which is caught upwards.</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+            raise EOFError()</span>
<span class="gi">+        raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pickle_dump(data, file, protocol):</span>
<span class="gi">+    try:</span>
<span class="gi">+        pickle.dump(data, file, protocol)</span>
<span class="gi">+        # On Python 3.3 flush throws sometimes an error even though the writing</span>
<span class="gi">+        # operation should be completed.</span>
<span class="gi">+        file.flush()</span>
<span class="gi">+    # Python on Windows don&#39;t throw EPIPE errors for pipes. So reraise them with</span>
<span class="gi">+    # the correct type and error number.</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+            raise IOError(errno.EPIPE, &quot;Broken pipe&quot;)</span>
<span class="gi">+        raise</span>
<span class="gh">diff --git a/jedi/api/classes.py b/jedi/api/classes.py</span>
<span class="gh">index 04b944e5..7054788e 100644</span>
<span class="gd">--- a/jedi/api/classes.py</span>
<span class="gi">+++ b/jedi/api/classes.py</span>
<span class="gu">@@ -16,7 +16,9 @@ the interesting information about all operations.</span>
<span class="w"> </span>import re
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Optional
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="gi">+</span>
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.utils import unite
<span class="gu">@@ -31,6 +33,10 @@ from jedi.api import completion_cache</span>
<span class="w"> </span>from jedi.api.helpers import filter_follow_imports


<span class="gi">+def _sort_names_by_start_pos(names):</span>
<span class="gi">+    return sorted(names, key=lambda s: s.start_pos or (0, 0))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def defined_names(inference_state, value):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    List sub-definitions (e.g., methods in class).
<span class="gu">@@ -38,20 +44,41 @@ def defined_names(inference_state, value):</span>
<span class="w"> </span>    :type scope: Scope
<span class="w"> </span>    :rtype: list of Name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        context = value.as_context()</span>
<span class="gi">+    except HasNoContext:</span>
<span class="gi">+        return []</span>
<span class="gi">+    filter = next(context.get_filters())</span>
<span class="gi">+    names = [name for name in filter.values()]</span>
<span class="gi">+    return [Name(inference_state, n) for n in _sort_names_by_start_pos(names)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _values_to_definitions(values):</span>
<span class="gi">+    return [Name(c.inference_state, c.name) for c in values]</span>


<span class="w"> </span>class BaseName:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The base class for all definitions, completions and signatures.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _mapping = {&#39;posixpath&#39;: &#39;os.path&#39;, &#39;riscospath&#39;: &#39;os.path&#39;, &#39;ntpath&#39;:</span>
<span class="gd">-        &#39;os.path&#39;, &#39;os2emxpath&#39;: &#39;os.path&#39;, &#39;macpath&#39;: &#39;os.path&#39;,</span>
<span class="gd">-        &#39;genericpath&#39;: &#39;os.path&#39;, &#39;posix&#39;: &#39;os&#39;, &#39;_io&#39;: &#39;io&#39;, &#39;_functools&#39;:</span>
<span class="gd">-        &#39;functools&#39;, &#39;_collections&#39;: &#39;collections&#39;, &#39;_socket&#39;: &#39;socket&#39;,</span>
<span class="gd">-        &#39;_sqlite3&#39;: &#39;sqlite3&#39;}</span>
<span class="gd">-    _tuple_mapping = dict((tuple(k.split(&#39;.&#39;)), v) for k, v in {</span>
<span class="gd">-        &#39;argparse._ActionsContainer&#39;: &#39;argparse.ArgumentParser&#39;}.items())</span>
<span class="gi">+    _mapping = {</span>
<span class="gi">+        &#39;posixpath&#39;: &#39;os.path&#39;,</span>
<span class="gi">+        &#39;riscospath&#39;: &#39;os.path&#39;,</span>
<span class="gi">+        &#39;ntpath&#39;: &#39;os.path&#39;,</span>
<span class="gi">+        &#39;os2emxpath&#39;: &#39;os.path&#39;,</span>
<span class="gi">+        &#39;macpath&#39;: &#39;os.path&#39;,</span>
<span class="gi">+        &#39;genericpath&#39;: &#39;os.path&#39;,</span>
<span class="gi">+        &#39;posix&#39;: &#39;os&#39;,</span>
<span class="gi">+        &#39;_io&#39;: &#39;io&#39;,</span>
<span class="gi">+        &#39;_functools&#39;: &#39;functools&#39;,</span>
<span class="gi">+        &#39;_collections&#39;: &#39;collections&#39;,</span>
<span class="gi">+        &#39;_socket&#39;: &#39;socket&#39;,</span>
<span class="gi">+        &#39;_sqlite3&#39;: &#39;sqlite3&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    _tuple_mapping = dict((tuple(k.split(&#39;.&#39;)), v) for (k, v) in {</span>
<span class="gi">+        &#39;argparse._ActionsContainer&#39;: &#39;argparse.ArgumentParser&#39;,</span>
<span class="gi">+    }.items())</span>

<span class="w"> </span>    def __init__(self, inference_state, name):
<span class="w"> </span>        self._inference_state = inference_state
<span class="gu">@@ -61,12 +88,26 @@ class BaseName:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.is_keyword = isinstance(self._name, KeywordName)

<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _get_module_context(self):</span>
<span class="gi">+        # This can take a while to complete, because in the worst case of</span>
<span class="gi">+        # imports (consider `import a` completions), we need to load all</span>
<span class="gi">+        # modules starting with a first.</span>
<span class="gi">+        return self._name.get_root_context()</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def module_path(self) -&gt;Optional[Path]:</span>
<span class="gi">+    def module_path(self) -&gt; Optional[Path]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Shows the file path of a module. e.g. ``/usr/lib/python3.9/os.py``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        module = self._get_module_context()</span>
<span class="gi">+        if module.is_stub() or not module.is_compiled():</span>
<span class="gi">+            # Compiled modules should not return a module path even if they</span>
<span class="gi">+            # have one.</span>
<span class="gi">+            path: Optional[Path] = self._get_module_context().py__file__()</span>
<span class="gi">+            return path</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name(self):
<span class="gu">@@ -77,7 +118,7 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: str or None
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name.get_public_name()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def type(self):
<span class="gu">@@ -136,7 +177,19 @@ class BaseName:</span>
<span class="w"> </span>        ``param``, ``path``, ``keyword``, ``property`` and ``statement``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tree_name = self._name.tree_name</span>
<span class="gi">+        resolve = False</span>
<span class="gi">+        if tree_name is not None:</span>
<span class="gi">+            # TODO move this to their respective names.</span>
<span class="gi">+            definition = tree_name.get_definition()</span>
<span class="gi">+            if definition is not None and definition.type == &#39;import_from&#39; and \</span>
<span class="gi">+                    tree_name.is_definition():</span>
<span class="gi">+                resolve = True</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self._name, SubModuleName) or resolve:</span>
<span class="gi">+            for value in self._name.infer():</span>
<span class="gi">+                return value.api_type</span>
<span class="gi">+        return self._name.api_type</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def module_name(self):
<span class="gu">@@ -151,23 +204,32 @@ class BaseName:</span>
<span class="w"> </span>        &gt;&gt;&gt; print(d.module_name)  # doctest: +ELLIPSIS
<span class="w"> </span>        json
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_module_context().py__name__()</span>

<span class="w"> </span>    def in_builtin_module(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns True, if this is a builtin module.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self._get_module_context().get_value()</span>
<span class="gi">+        if isinstance(value, StubModuleValue):</span>
<span class="gi">+            return any(v.is_compiled() for v in value.non_stub_value_set)</span>
<span class="gi">+        return value.is_compiled()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def line(self):
<span class="w"> </span>        &quot;&quot;&quot;The line where the definition occurs (starting with 1).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start_pos = self._name.start_pos</span>
<span class="gi">+        if start_pos is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return start_pos[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def column(self):
<span class="w"> </span>        &quot;&quot;&quot;The column where the definition occurs (starting with 0).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start_pos = self._name.start_pos</span>
<span class="gi">+        if start_pos is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return start_pos[1]</span>

<span class="w"> </span>    def get_definition_start_position(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -176,7 +238,12 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: Optional[Tuple[int, int]]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._name.tree_name is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        definition = self._name.tree_name.get_definition()</span>
<span class="gi">+        if definition is None:</span>
<span class="gi">+            return self._name.start_pos</span>
<span class="gi">+        return definition.start_pos</span>

<span class="w"> </span>    def get_definition_end_position(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -185,16 +252,26 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: Optional[Tuple[int, int]]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._name.tree_name is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        definition = self._name.tree_name.get_definition()</span>
<span class="gi">+        if definition is None:</span>
<span class="gi">+            return self._name.tree_name.end_pos</span>
<span class="gi">+        if self.type in (&quot;function&quot;, &quot;class&quot;):</span>
<span class="gi">+            last_leaf = definition.get_last_leaf()</span>
<span class="gi">+            if last_leaf.type == &quot;newline&quot;:</span>
<span class="gi">+                return last_leaf.get_previous_leaf().end_pos</span>
<span class="gi">+            return last_leaf.end_pos</span>
<span class="gi">+        return definition.end_pos</span>

<span class="w"> </span>    def docstring(self, raw=False, fast=True):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        r&quot;&quot;&quot;</span>
<span class="w"> </span>        Return a document string for this completion object.

<span class="w"> </span>        Example:

<span class="w"> </span>        &gt;&gt;&gt; from jedi import Script
<span class="gd">-        &gt;&gt;&gt; source = &#39;&#39;&#39;\\</span>
<span class="gi">+        &gt;&gt;&gt; source = &#39;&#39;&#39;\</span>
<span class="w"> </span>        ... def f(a, b=1):
<span class="w"> </span>        ...     &quot;Document for function f.&quot;
<span class="w"> </span>        ... &#39;&#39;&#39;
<span class="gu">@@ -218,7 +295,26 @@ class BaseName:</span>
<span class="w"> </span>            the ``foo.docstring(fast=False)`` on every object, because it
<span class="w"> </span>            parses all libraries starting with ``a``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self._name, ImportName) and fast:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        doc = self._get_docstring()</span>
<span class="gi">+        if raw:</span>
<span class="gi">+            return doc</span>
<span class="gi">+</span>
<span class="gi">+        signature_text = self._get_docstring_signature()</span>
<span class="gi">+        if signature_text and doc:</span>
<span class="gi">+            return signature_text + &#39;\n\n&#39; + doc</span>
<span class="gi">+        else:</span>
<span class="gi">+            return signature_text + doc</span>
<span class="gi">+</span>
<span class="gi">+    def _get_docstring(self):</span>
<span class="gi">+        return self._name.py__doc__()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_docstring_signature(self):</span>
<span class="gi">+        return &#39;\n&#39;.join(</span>
<span class="gi">+            signature.to_string()</span>
<span class="gi">+            for signature in self._get_signatures(for_docstring=True)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def description(self):
<span class="gu">@@ -249,7 +345,25 @@ class BaseName:</span>
<span class="w"> </span>        &#39;class C&#39;

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        typ = self.type</span>
<span class="gi">+        tree_name = self._name.tree_name</span>
<span class="gi">+        if typ == &#39;param&#39;:</span>
<span class="gi">+            return typ + &#39; &#39; + self._name.to_string()</span>
<span class="gi">+        if typ in (&#39;function&#39;, &#39;class&#39;, &#39;module&#39;, &#39;instance&#39;) or tree_name is None:</span>
<span class="gi">+            if typ == &#39;function&#39;:</span>
<span class="gi">+                # For the description we want a short and a pythonic way.</span>
<span class="gi">+                typ = &#39;def&#39;</span>
<span class="gi">+            return typ + &#39; &#39; + self._name.get_public_name()</span>
<span class="gi">+</span>
<span class="gi">+        definition = tree_name.get_definition(include_setitem=True) or tree_name</span>
<span class="gi">+        # Remove the prefix, because that&#39;s not what we want for get_code</span>
<span class="gi">+        # here.</span>
<span class="gi">+        txt = definition.get_code(include_prefix=False)</span>
<span class="gi">+        # Delete comments:</span>
<span class="gi">+        txt = re.sub(r&#39;#[^\n]+\n&#39;, &#39; &#39;, txt)</span>
<span class="gi">+        # Delete multi spaces/newlines</span>
<span class="gi">+        txt = re.sub(r&#39;\s+&#39;, &#39; &#39;, txt).strip()</span>
<span class="gi">+        return txt</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def full_name(self):
<span class="gu">@@ -275,24 +389,44 @@ class BaseName:</span>
<span class="w"> </span>        be ``&lt;module &#39;posixpath&#39; ...&gt;```. However most users find the latter
<span class="w"> </span>        more practical.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._name.is_value_name:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        names = self._name.get_qualified_names(include_module_names=True)</span>
<span class="gi">+        if names is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        names = list(names)</span>
<span class="gi">+        try:</span>
<span class="gi">+            names[0] = self._mapping[names[0]]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;.&#39;.join(names)</span>

<span class="w"> </span>    def is_stub(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns True if the current name is defined in a stub file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._name.is_value_name:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return self._name.get_root_context().is_stub()</span>

<span class="w"> </span>    def is_side_effect(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Checks if a name is defined as ``self.foo = 3``. In case of self, this
<span class="w"> </span>        function would return False, for foo it would return True.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tree_name = self._name.tree_name</span>
<span class="gi">+        if tree_name is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return tree_name.is_definition() and tree_name.parent.type == &#39;trailer&#39;</span>

<span class="w"> </span>    @debug.increase_indent_cm(&#39;goto on name&#39;)
<span class="w"> </span>    def goto(self, *, follow_imports=False, follow_builtin_imports=False,
<span class="gd">-        only_stubs=False, prefer_stubs=False):</span>
<span class="gi">+             only_stubs=False, prefer_stubs=False):</span>
<span class="gi">+</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Like :meth:`.Script.goto` (also supports the same params), but does it
<span class="w"> </span>        for the current name. This is typically useful if you are using
<span class="gu">@@ -305,7 +439,19 @@ class BaseName:</span>
<span class="w"> </span>        :param prefer_stubs: Prefer stubs to Python objects for this goto call.
<span class="w"> </span>        :rtype: list of :class:`Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._name.is_value_name:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        names = self._name.goto()</span>
<span class="gi">+        if follow_imports:</span>
<span class="gi">+            names = filter_follow_imports(names, follow_builtin_imports)</span>
<span class="gi">+        names = convert_names(</span>
<span class="gi">+            names,</span>
<span class="gi">+            only_stubs=only_stubs,</span>
<span class="gi">+            prefer_stubs=prefer_stubs,</span>
<span class="gi">+        )</span>
<span class="gi">+        return [self if n == self._name else Name(self._inference_state, n)</span>
<span class="gi">+                for n in names]</span>

<span class="w"> </span>    @debug.increase_indent_cm(&#39;infer on name&#39;)
<span class="w"> </span>    def infer(self, *, only_stubs=False, prefer_stubs=False):
<span class="gu">@@ -325,7 +471,23 @@ class BaseName:</span>
<span class="w"> </span>            inference call.
<span class="w"> </span>        :rtype: list of :class:`Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert not (only_stubs and prefer_stubs)</span>
<span class="gi">+</span>
<span class="gi">+        if not self._name.is_value_name:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        # First we need to make sure that we have stub names (if possible) that</span>
<span class="gi">+        # we can follow. If we don&#39;t do that, we can end up with the inferred</span>
<span class="gi">+        # results of Python objects instead of stubs.</span>
<span class="gi">+        names = convert_names([self._name], prefer_stubs=True)</span>
<span class="gi">+        values = convert_values(</span>
<span class="gi">+            ValueSet.from_sets(n.infer() for n in names),</span>
<span class="gi">+            only_stubs=only_stubs,</span>
<span class="gi">+            prefer_stubs=prefer_stubs,</span>
<span class="gi">+        )</span>
<span class="gi">+        resulting_names = [c.name for c in values]</span>
<span class="gi">+        return [self if n == self._name else Name(self._inference_state, n)</span>
<span class="gi">+                for n in resulting_names]</span>

<span class="w"> </span>    def parent(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -333,12 +495,40 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: Name
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._name.is_value_name:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if self.type in (&#39;function&#39;, &#39;class&#39;, &#39;param&#39;) and self._name.tree_name is not None:</span>
<span class="gi">+            # Since the parent_context doesn&#39;t really match what the user</span>
<span class="gi">+            # thinks of that the parent is here, we do these cases separately.</span>
<span class="gi">+            # The reason for this is the following:</span>
<span class="gi">+            # - class: Nested classes parent_context is always the</span>
<span class="gi">+            #   parent_context of the most outer one.</span>
<span class="gi">+            # - function: Functions in classes have the module as</span>
<span class="gi">+            #   parent_context.</span>
<span class="gi">+            # - param: The parent_context of a param is not its function but</span>
<span class="gi">+            #   e.g. the outer class or module.</span>
<span class="gi">+            cls_or_func_node = self._name.tree_name.get_definition()</span>
<span class="gi">+            parent = search_ancestor(cls_or_func_node, &#39;funcdef&#39;, &#39;classdef&#39;, &#39;file_input&#39;)</span>
<span class="gi">+            context = self._get_module_context().create_value(parent).as_context()</span>
<span class="gi">+        else:</span>
<span class="gi">+            context = self._name.parent_context</span>
<span class="gi">+</span>
<span class="gi">+        if context is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        while context.name is None:</span>
<span class="gi">+            # Happens for comprehension contexts</span>
<span class="gi">+            context = context.parent_context</span>
<span class="gi">+</span>
<span class="gi">+        return Name(self._inference_state, context.name)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s %sname=%r, description=%r&gt;&#39; % (self.__class__.__name__,</span>
<span class="gd">-            &#39;full_&#39; if self.full_name else &#39;&#39;, self.full_name or self.name,</span>
<span class="gd">-            self.description)</span>
<span class="gi">+        return &quot;&lt;%s %sname=%r, description=%r&gt;&quot; % (</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            &#39;full_&#39; if self.full_name else &#39;&#39;,</span>
<span class="gi">+            self.full_name or self.name,</span>
<span class="gi">+            self.description,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def get_line_code(self, before=0, after=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -350,7 +540,34 @@ class BaseName:</span>
<span class="w"> </span>        :return str: Returns the line(s) of code or an empty string if it&#39;s a
<span class="w"> </span>                     builtin.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._name.is_value_name:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        lines = self._name.get_root_context().code_lines</span>
<span class="gi">+        if lines is None:</span>
<span class="gi">+            # Probably a builtin module, just ignore in that case.</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        index = self._name.start_pos[0] - 1</span>
<span class="gi">+        start_index = max(index - before, 0)</span>
<span class="gi">+        return &#39;&#39;.join(lines[start_index:index + after + 1])</span>
<span class="gi">+</span>
<span class="gi">+    def _get_signatures(self, for_docstring=False):</span>
<span class="gi">+        if self._name.api_type == &#39;property&#39;:</span>
<span class="gi">+            return []</span>
<span class="gi">+        if for_docstring and self._name.api_type == &#39;statement&#39; and not self.is_stub():</span>
<span class="gi">+            # For docstrings we don&#39;t resolve signatures if they are simple</span>
<span class="gi">+            # statements and not stubs. This is a speed optimization.</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self._name, MixedName):</span>
<span class="gi">+            # While this would eventually happen anyway, it&#39;s basically just a</span>
<span class="gi">+            # shortcut to not infer anything tree related, because it&#39;s really</span>
<span class="gi">+            # not necessary.</span>
<span class="gi">+            return self._name.infer_compiled_value().get_signatures()</span>
<span class="gi">+</span>
<span class="gi">+        names = convert_names([self._name], prefer_stubs=True)</span>
<span class="gi">+        return [sig for name in names for sig in name.infer().get_signatures()]</span>

<span class="w"> </span>    def get_signatures(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -359,7 +576,10 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: list of :class:`BaseSignature`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            BaseSignature(self._inference_state, s)</span>
<span class="gi">+            for s in self._get_signatures()</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    def execute(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -368,7 +588,7 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: list of :class:`Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _values_to_definitions(self._name.infer().execute_with_values())</span>

<span class="w"> </span>    def get_type_hint(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -380,7 +600,7 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name.infer().get_type_hint()</span>


<span class="w"> </span>class Completion(BaseName):
<span class="gu">@@ -388,16 +608,30 @@ class Completion(BaseName):</span>
<span class="w"> </span>    ``Completion`` objects are returned from :meth:`.Script.complete`. They
<span class="w"> </span>    provide additional information about a completion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, name, stack, like_name_length,
<span class="gd">-        is_fuzzy, cached_name=None):</span>
<span class="gi">+                 is_fuzzy, cached_name=None):</span>
<span class="w"> </span>        super().__init__(inference_state, name)
<span class="gi">+</span>
<span class="w"> </span>        self._like_name_length = like_name_length
<span class="w"> </span>        self._stack = stack
<span class="w"> </span>        self._is_fuzzy = is_fuzzy
<span class="w"> </span>        self._cached_name = cached_name
<span class="gi">+</span>
<span class="gi">+        # Completion objects with the same Completion name (which means</span>
<span class="gi">+        # duplicate items in the completion)</span>
<span class="w"> </span>        self._same_name_completions = []

<span class="gi">+    def _complete(self, like_name):</span>
<span class="gi">+        append = &#39;&#39;</span>
<span class="gi">+        if settings.add_bracket_after_function \</span>
<span class="gi">+                and self.type == &#39;function&#39;:</span>
<span class="gi">+            append = &#39;(&#39;</span>
<span class="gi">+</span>
<span class="gi">+        name = self._name.get_public_name()</span>
<span class="gi">+        if like_name:</span>
<span class="gi">+            name = name[self._like_name_length:]</span>
<span class="gi">+        return name + append</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def complete(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -419,7 +653,9 @@ class Completion(BaseName):</span>
<span class="w"> </span>        completing ``foo(par`` would give a ``Completion`` which ``complete``
<span class="w"> </span>        would be ``am=``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._is_fuzzy:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self._complete(True)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name_with_symbols(self):
<span class="gu">@@ -434,20 +670,58 @@ class Completion(BaseName):</span>
<span class="w"> </span>        ``name_with_symbols`` would be &quot;param=&quot;.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._complete(False)</span>

<span class="w"> </span>    def docstring(self, raw=False, fast=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Documented under :meth:`BaseName.docstring`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._like_name_length &gt;= 3:</span>
<span class="gi">+            # In this case we can just resolve the like name, because we</span>
<span class="gi">+            # wouldn&#39;t load like &gt; 100 Python modules anymore.</span>
<span class="gi">+            fast = False</span>
<span class="gi">+</span>
<span class="gi">+        return super().docstring(raw=raw, fast=fast)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_docstring(self):</span>
<span class="gi">+        if self._cached_name is not None:</span>
<span class="gi">+            return completion_cache.get_docstring(</span>
<span class="gi">+                self._cached_name,</span>
<span class="gi">+                self._name.get_public_name(),</span>
<span class="gi">+                lambda: self._get_cache()</span>
<span class="gi">+            )</span>
<span class="gi">+        return super()._get_docstring()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_docstring_signature(self):</span>
<span class="gi">+        if self._cached_name is not None:</span>
<span class="gi">+            return completion_cache.get_docstring_signature(</span>
<span class="gi">+                self._cached_name,</span>
<span class="gi">+                self._name.get_public_name(),</span>
<span class="gi">+                lambda: self._get_cache()</span>
<span class="gi">+            )</span>
<span class="gi">+        return super()._get_docstring_signature()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_cache(self):</span>
<span class="gi">+        return (</span>
<span class="gi">+            super().type,</span>
<span class="gi">+            super()._get_docstring_signature(),</span>
<span class="gi">+            super()._get_docstring(),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def type(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Documented under :meth:`BaseName.type`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Purely a speed optimization.</span>
<span class="gi">+        if self._cached_name is not None:</span>
<span class="gi">+            return completion_cache.get_type(</span>
<span class="gi">+                self._cached_name,</span>
<span class="gi">+                self._name.get_public_name(),</span>
<span class="gi">+                lambda: self._get_cache()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return super().type</span>

<span class="w"> </span>    def get_completion_prefix_length(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -465,7 +739,7 @@ class Completion(BaseName):</span>

<span class="w"> </span>        completing ``foo(par`` would return 3.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._like_name_length</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (type(self).__name__, self._name.get_public_name())
<span class="gu">@@ -476,7 +750,6 @@ class Name(BaseName):</span>
<span class="w"> </span>    *Name* objects are returned from many different APIs including
<span class="w"> </span>    :meth:`.Script.goto` or :meth:`.Script.infer`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, definition):
<span class="w"> </span>        super().__init__(inference_state, definition)

<span class="gu">@@ -487,26 +760,33 @@ class Name(BaseName):</span>

<span class="w"> </span>        :rtype: list of :class:`Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        defs = self._name.infer()</span>
<span class="gi">+        return sorted(</span>
<span class="gi">+            unite(defined_names(self._inference_state, d) for d in defs),</span>
<span class="gi">+            key=lambda s: s._name.start_pos or (0, 0)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def is_definition(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns True, if defined as a name in a statement, function or class.
<span class="w"> </span>        Returns False, if it&#39;s a reference to such a definition.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._name.tree_name is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._name.tree_name.is_definition()</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return (self._name.start_pos == other._name.start_pos and self.</span>
<span class="gd">-            module_path == other.module_path and self.name == other.name and</span>
<span class="gd">-            self._inference_state == other._inference_state)</span>
<span class="gi">+        return self._name.start_pos == other._name.start_pos \</span>
<span class="gi">+            and self.module_path == other.module_path \</span>
<span class="gi">+            and self.name == other.name \</span>
<span class="gi">+            and self._inference_state == other._inference_state</span>

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self.__eq__(other)

<span class="w"> </span>    def __hash__(self):
<span class="gd">-        return hash((self._name.start_pos, self.module_path, self.name,</span>
<span class="gd">-            self._inference_state))</span>
<span class="gi">+        return hash((self._name.start_pos, self.module_path, self.name, self._inference_state))</span>


<span class="w"> </span>class BaseSignature(Name):
<span class="gu">@@ -514,7 +794,6 @@ class BaseSignature(Name):</span>
<span class="w"> </span>    These signatures are returned by :meth:`BaseName.get_signatures`
<span class="w"> </span>    calls.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, signature):
<span class="w"> </span>        super().__init__(inference_state, signature.name)
<span class="w"> </span>        self._signature = signature
<span class="gu">@@ -527,7 +806,8 @@ class BaseSignature(Name):</span>

<span class="w"> </span>        :rtype: list of :class:`.ParamName`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [ParamName(self._inference_state, n)</span>
<span class="gi">+                for n in self._signature.get_param_names(resolve_stars=True)]</span>

<span class="w"> </span>    def to_string(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -536,7 +816,7 @@ class BaseSignature(Name):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._signature.to_string()</span>


<span class="w"> </span>class Signature(BaseSignature):
<span class="gu">@@ -544,7 +824,6 @@ class Signature(BaseSignature):</span>
<span class="w"> </span>    A full signature object is the return value of
<span class="w"> </span>    :meth:`.Script.get_signatures`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, signature, call_details):
<span class="w"> </span>        super().__init__(inference_state, signature)
<span class="w"> </span>        self._call_details = call_details
<span class="gu">@@ -558,7 +837,9 @@ class Signature(BaseSignature):</span>

<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._call_details.calculate_index(</span>
<span class="gi">+            self._signature.get_param_names(resolve_stars=True)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def bracket_start(self):
<span class="gu">@@ -568,22 +849,24 @@ class Signature(BaseSignature):</span>

<span class="w"> </span>        :rtype: int, int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._call_details.bracket_leaf.start_pos</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: index=%r %s&gt;&#39; % (type(self).__name__, self.index, self</span>
<span class="gd">-            ._signature.to_string())</span>
<span class="gi">+        return &#39;&lt;%s: index=%r %s&gt;&#39; % (</span>
<span class="gi">+            type(self).__name__,</span>
<span class="gi">+            self.index,</span>
<span class="gi">+            self._signature.to_string(),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ParamName(Name):
<span class="gd">-</span>
<span class="w"> </span>    def infer_default(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns default values like the ``1`` of ``def foo(x=1):``.

<span class="w"> </span>        :rtype: list of :class:`.Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _values_to_definitions(self._name.infer_default())</span>

<span class="w"> </span>    def infer_annotation(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -591,7 +874,7 @@ class ParamName(Name):</span>
<span class="w"> </span>            executed and classes are returned instead of instances.
<span class="w"> </span>        :rtype: list of :class:`.Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _values_to_definitions(self._name.infer_annotation(ignore_stars=True, **kwargs))</span>

<span class="w"> </span>    def to_string(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -600,7 +883,7 @@ class ParamName(Name):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name.to_string()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def kind(self):
<span class="gu">@@ -609,4 +892,4 @@ class ParamName(Name):</span>

<span class="w"> </span>        :rtype: :py:attr:`inspect.Parameter.kind`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name.get_kind()</span>
<span class="gh">diff --git a/jedi/api/completion.py b/jedi/api/completion.py</span>
<span class="gh">index 2aa05f9a..342f7506 100644</span>
<span class="gd">--- a/jedi/api/completion.py</span>
<span class="gi">+++ b/jedi/api/completion.py</span>
<span class="gu">@@ -1,10 +1,12 @@</span>
<span class="w"> </span>import re
<span class="w"> </span>from textwrap import dedent
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from parso.python.token import PythonTokenTypes
<span class="w"> </span>from parso.python import tree
<span class="w"> </span>from parso.tree import search_ancestor, Leaf
<span class="w"> </span>from parso import split_lines
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.api import classes
<span class="gu">@@ -25,30 +27,160 @@ from jedi.plugins import plugin_manager</span>


<span class="w"> </span>class ParamNameWithEquals(ParamNameWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def get_public_name(self):</span>
<span class="gi">+        return self.string_name + &#39;=&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_signature_param_names(signatures, positional_count, used_kwargs):</span>
<span class="gi">+    # Add named params</span>
<span class="gi">+    for call_sig in signatures:</span>
<span class="gi">+        for i, p in enumerate(call_sig.params):</span>
<span class="gi">+            kind = p.kind</span>
<span class="gi">+            if i &lt; positional_count and kind == Parameter.POSITIONAL_OR_KEYWORD:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY) \</span>
<span class="gi">+                    and p.name not in used_kwargs:</span>
<span class="gi">+                yield ParamNameWithEquals(p._name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _must_be_kwarg(signatures, positional_count, used_kwargs):</span>
<span class="gi">+    if used_kwargs:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    must_be_kwarg = True</span>
<span class="gi">+    for signature in signatures:</span>
<span class="gi">+        for i, p in enumerate(signature.params):</span>
<span class="gi">+            kind = p.kind</span>
<span class="gi">+            if kind is Parameter.VAR_POSITIONAL:</span>
<span class="gi">+                # In case there were not already kwargs, the next param can</span>
<span class="gi">+                # always be a normal argument.</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            if i &gt;= positional_count and kind in (Parameter.POSITIONAL_OR_KEYWORD,</span>
<span class="gi">+                                                  Parameter.POSITIONAL_ONLY):</span>
<span class="gi">+                must_be_kwarg = False</span>
<span class="gi">+                break</span>
<span class="gi">+        if not must_be_kwarg:</span>
<span class="gi">+            break</span>
<span class="gi">+    return must_be_kwarg</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_names(inference_state, completion_names, stack, like_name, fuzzy, cached_name):</span>
<span class="gi">+    comp_dct = set()</span>
<span class="gi">+    if settings.case_insensitive_completion:</span>
<span class="gi">+        like_name = like_name.lower()</span>
<span class="gi">+    for name in completion_names:</span>
<span class="gi">+        string = name.string_name</span>
<span class="gi">+        if settings.case_insensitive_completion:</span>
<span class="gi">+            string = string.lower()</span>
<span class="gi">+        if helpers.match(string, like_name, fuzzy=fuzzy):</span>
<span class="gi">+            new = classes.Completion(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                name,</span>
<span class="gi">+                stack,</span>
<span class="gi">+                len(like_name),</span>
<span class="gi">+                is_fuzzy=fuzzy,</span>
<span class="gi">+                cached_name=cached_name,</span>
<span class="gi">+            )</span>
<span class="gi">+            k = (new.name, new.complete)  # key</span>
<span class="gi">+            if k not in comp_dct:</span>
<span class="gi">+                comp_dct.add(k)</span>
<span class="gi">+                tree_name = name.tree_name</span>
<span class="gi">+                if tree_name is not None:</span>
<span class="gi">+                    definition = tree_name.get_definition()</span>
<span class="gi">+                    if definition is not None and definition.type == &#39;del_stmt&#39;:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                yield new</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_duplicates(completions, other_completions):</span>
<span class="gi">+    names = {d.name for d in other_completions}</span>
<span class="gi">+    return [c for c in completions if c.name not in names]</span>


<span class="w"> </span>def get_user_context(module_context, position):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the scope in which the user resides. This includes flows.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    leaf = module_context.tree_node.get_leaf_for_position(position, include_prefixes=True)</span>
<span class="gi">+    return module_context.create_context(leaf)</span>


<span class="gd">-class Completion:</span>
<span class="gi">+def get_flow_scope_node(module_node, position):</span>
<span class="gi">+    node = module_node.get_leaf_for_position(position, include_prefixes=True)</span>
<span class="gi">+    while not isinstance(node, (tree.Scope, tree.Flow)):</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+    return node</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, inference_state, module_context, code_lines,</span>
<span class="gd">-        position, signatures_callback, fuzzy=False):</span>
<span class="gi">+@plugin_manager.decorate()</span>
<span class="gi">+def complete_param_names(context, function_name, decorator_nodes):</span>
<span class="gi">+    # Basically there&#39;s no way to do param completion. The plugins are</span>
<span class="gi">+    # responsible for this.</span>
<span class="gi">+    return []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Completion:</span>
<span class="gi">+    def __init__(self, inference_state, module_context, code_lines, position,</span>
<span class="gi">+                 signatures_callback, fuzzy=False):</span>
<span class="w"> </span>        self._inference_state = inference_state
<span class="w"> </span>        self._module_context = module_context
<span class="w"> </span>        self._module_node = module_context.tree_node
<span class="w"> </span>        self._code_lines = code_lines
<span class="gd">-        self._like_name = helpers.get_on_completion_name(self._module_node,</span>
<span class="gd">-            code_lines, position)</span>
<span class="gi">+</span>
<span class="gi">+        # The first step of completions is to get the name</span>
<span class="gi">+        self._like_name = helpers.get_on_completion_name(self._module_node, code_lines, position)</span>
<span class="gi">+        # The actual cursor position is not what we need to calculate</span>
<span class="gi">+        # everything. We want the start of the name we&#39;re on.</span>
<span class="w"> </span>        self._original_position = position
<span class="w"> </span>        self._signatures_callback = signatures_callback
<span class="gi">+</span>
<span class="w"> </span>        self._fuzzy = fuzzy

<span class="gi">+    def complete(self):</span>
<span class="gi">+        leaf = self._module_node.get_leaf_for_position(</span>
<span class="gi">+            self._original_position,</span>
<span class="gi">+            include_prefixes=True</span>
<span class="gi">+        )</span>
<span class="gi">+        string, start_leaf, quote = _extract_string_while_in_string(leaf, self._original_position)</span>
<span class="gi">+</span>
<span class="gi">+        prefixed_completions = complete_dict(</span>
<span class="gi">+            self._module_context,</span>
<span class="gi">+            self._code_lines,</span>
<span class="gi">+            start_leaf or leaf,</span>
<span class="gi">+            self._original_position,</span>
<span class="gi">+            None if string is None else quote + string,</span>
<span class="gi">+            fuzzy=self._fuzzy,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if string is not None and not prefixed_completions:</span>
<span class="gi">+            prefixed_completions = list(complete_file_name(</span>
<span class="gi">+                self._inference_state, self._module_context, start_leaf, quote, string,</span>
<span class="gi">+                self._like_name, self._signatures_callback,</span>
<span class="gi">+                self._code_lines, self._original_position,</span>
<span class="gi">+                self._fuzzy</span>
<span class="gi">+            ))</span>
<span class="gi">+        if string is not None:</span>
<span class="gi">+            if not prefixed_completions and &#39;\n&#39; in string:</span>
<span class="gi">+                # Complete only multi line strings</span>
<span class="gi">+                prefixed_completions = self._complete_in_string(start_leaf, string)</span>
<span class="gi">+            return prefixed_completions</span>
<span class="gi">+</span>
<span class="gi">+        cached_name, completion_names = self._complete_python(leaf)</span>
<span class="gi">+</span>
<span class="gi">+        completions = list(filter_names(self._inference_state, completion_names,</span>
<span class="gi">+                                        self.stack, self._like_name,</span>
<span class="gi">+                                        self._fuzzy, cached_name=cached_name))</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            # Removing duplicates mostly to remove False/True/None duplicates.</span>
<span class="gi">+            _remove_duplicates(prefixed_completions, completions)</span>
<span class="gi">+            + sorted(completions, key=lambda x: (x.name.startswith(&#39;__&#39;),</span>
<span class="gi">+                                                 x.name.startswith(&#39;_&#39;),</span>
<span class="gi">+                                                 x.name.lower()))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def _complete_python(self, leaf):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Analyzes the current context of a completion and decides what to
<span class="gu">@@ -63,13 +195,242 @@ class Completion:</span>
<span class="w"> </span>        - In args: */**: no completion
<span class="w"> </span>        - In params (also lambda): no completion before =
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        grammar = self._inference_state.grammar</span>
<span class="gi">+        self.stack = stack = None</span>
<span class="gi">+        self._position = (</span>
<span class="gi">+            self._original_position[0],</span>
<span class="gi">+            self._original_position[1] - len(self._like_name)</span>
<span class="gi">+        )</span>
<span class="gi">+        cached_name = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.stack = stack = helpers.get_stack_at_position(</span>
<span class="gi">+                grammar, self._code_lines, leaf, self._position</span>
<span class="gi">+            )</span>
<span class="gi">+        except helpers.OnErrorLeaf as e:</span>
<span class="gi">+            value = e.error_leaf.value</span>
<span class="gi">+            if value == &#39;.&#39;:</span>
<span class="gi">+                # After ErrorLeaf&#39;s that are dots, we will not do any</span>
<span class="gi">+                # completions since this probably just confuses the user.</span>
<span class="gi">+                return cached_name, []</span>
<span class="gi">+</span>
<span class="gi">+            # If we don&#39;t have a value, just use global completion.</span>
<span class="gi">+            return cached_name, self._complete_global_scope()</span>
<span class="gi">+</span>
<span class="gi">+        allowed_transitions = \</span>
<span class="gi">+            list(stack._allowed_transition_names_and_token_types())</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;if&#39; in allowed_transitions:</span>
<span class="gi">+            leaf = self._module_node.get_leaf_for_position(self._position, include_prefixes=True)</span>
<span class="gi">+            previous_leaf = leaf.get_previous_leaf()</span>
<span class="gi">+</span>
<span class="gi">+            indent = self._position[1]</span>
<span class="gi">+            if not (leaf.start_pos &lt;= self._position &lt;= leaf.end_pos):</span>
<span class="gi">+                indent = leaf.start_pos[1]</span>
<span class="gi">+</span>
<span class="gi">+            if previous_leaf is not None:</span>
<span class="gi">+                stmt = previous_leaf</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    stmt = search_ancestor(</span>
<span class="gi">+                        stmt, &#39;if_stmt&#39;, &#39;for_stmt&#39;, &#39;while_stmt&#39;, &#39;try_stmt&#39;,</span>
<span class="gi">+                        &#39;error_node&#39;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if stmt is None:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+                    type_ = stmt.type</span>
<span class="gi">+                    if type_ == &#39;error_node&#39;:</span>
<span class="gi">+                        first = stmt.children[0]</span>
<span class="gi">+                        if isinstance(first, Leaf):</span>
<span class="gi">+                            type_ = first.value + &#39;_stmt&#39;</span>
<span class="gi">+                    # Compare indents</span>
<span class="gi">+                    if stmt.start_pos[1] == indent:</span>
<span class="gi">+                        if type_ == &#39;if_stmt&#39;:</span>
<span class="gi">+                            allowed_transitions += [&#39;elif&#39;, &#39;else&#39;]</span>
<span class="gi">+                        elif type_ == &#39;try_stmt&#39;:</span>
<span class="gi">+                            allowed_transitions += [&#39;except&#39;, &#39;finally&#39;, &#39;else&#39;]</span>
<span class="gi">+                        elif type_ == &#39;for_stmt&#39;:</span>
<span class="gi">+                            allowed_transitions.append(&#39;else&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        completion_names = []</span>
<span class="gi">+</span>
<span class="gi">+        kwargs_only = False</span>
<span class="gi">+        if any(t in allowed_transitions for t in (PythonTokenTypes.NAME,</span>
<span class="gi">+                                                  PythonTokenTypes.INDENT)):</span>
<span class="gi">+            # This means that we actually have to do type inference.</span>
<span class="gi">+</span>
<span class="gi">+            nonterminals = [stack_node.nonterminal for stack_node in stack]</span>
<span class="gi">+</span>
<span class="gi">+            nodes = _gather_nodes(stack)</span>
<span class="gi">+            if nodes and nodes[-1] in (&#39;as&#39;, &#39;def&#39;, &#39;class&#39;):</span>
<span class="gi">+                # No completions for ``with x as foo`` and ``import x as foo``.</span>
<span class="gi">+                # Also true for defining names as a class or function.</span>
<span class="gi">+                return cached_name, list(self._complete_inherited(is_function=True))</span>
<span class="gi">+            elif &quot;import_stmt&quot; in nonterminals:</span>
<span class="gi">+                level, names = parse_dotted_names(nodes, &quot;import_from&quot; in nonterminals)</span>
<span class="gi">+</span>
<span class="gi">+                only_modules = not (&quot;import_from&quot; in nonterminals and &#39;import&#39; in nodes)</span>
<span class="gi">+                completion_names += self._get_importer_names(</span>
<span class="gi">+                    names,</span>
<span class="gi">+                    level,</span>
<span class="gi">+                    only_modules=only_modules,</span>
<span class="gi">+                )</span>
<span class="gi">+            elif nonterminals[-1] in (&#39;trailer&#39;, &#39;dotted_name&#39;) and nodes[-1] == &#39;.&#39;:</span>
<span class="gi">+                dot = self._module_node.get_leaf_for_position(self._position)</span>
<span class="gi">+                if dot.type == &quot;endmarker&quot;:</span>
<span class="gi">+                    # This is a bit of a weird edge case, maybe we can somehow</span>
<span class="gi">+                    # generalize this.</span>
<span class="gi">+                    dot = leaf.get_previous_leaf()</span>
<span class="gi">+                cached_name, n = self._complete_trailer(dot.get_previous_leaf())</span>
<span class="gi">+                completion_names += n</span>
<span class="gi">+            elif self._is_parameter_completion():</span>
<span class="gi">+                completion_names += self._complete_params(leaf)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Apparently this looks like it&#39;s good enough to filter most cases</span>
<span class="gi">+                # so that signature completions don&#39;t randomly appear.</span>
<span class="gi">+                # To understand why this works, three things are important:</span>
<span class="gi">+                # 1. trailer with a `,` in it is either a subscript or an arglist.</span>
<span class="gi">+                # 2. If there&#39;s no `,`, it&#39;s at the start and only signatures start</span>
<span class="gi">+                #    with `(`. Other trailers could start with `.` or `[`.</span>
<span class="gi">+                # 3. Decorators are very primitive and have an optional `(` with</span>
<span class="gi">+                #    optional arglist in them.</span>
<span class="gi">+                if nodes[-1] in [&#39;(&#39;, &#39;,&#39;] \</span>
<span class="gi">+                        and nonterminals[-1] in (&#39;trailer&#39;, &#39;arglist&#39;, &#39;decorator&#39;):</span>
<span class="gi">+                    signatures = self._signatures_callback(*self._position)</span>
<span class="gi">+                    if signatures:</span>
<span class="gi">+                        call_details = signatures[0]._call_details</span>
<span class="gi">+                        used_kwargs = list(call_details.iter_used_keyword_arguments())</span>
<span class="gi">+                        positional_count = call_details.count_positional_arguments()</span>
<span class="gi">+</span>
<span class="gi">+                        completion_names += _get_signature_param_names(</span>
<span class="gi">+                            signatures,</span>
<span class="gi">+                            positional_count,</span>
<span class="gi">+                            used_kwargs,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+                        kwargs_only = _must_be_kwarg(signatures, positional_count, used_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+                if not kwargs_only:</span>
<span class="gi">+                    completion_names += self._complete_global_scope()</span>
<span class="gi">+                    completion_names += self._complete_inherited(is_function=False)</span>
<span class="gi">+</span>
<span class="gi">+        if not kwargs_only:</span>
<span class="gi">+            current_line = self._code_lines[self._position[0] - 1][:self._position[1]]</span>
<span class="gi">+            completion_names += self._complete_keywords(</span>
<span class="gi">+                allowed_transitions,</span>
<span class="gi">+                only_values=not (not current_line or current_line[-1] in &#39; \t.;&#39;</span>
<span class="gi">+                                 and current_line[-3:] != &#39;...&#39;)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return cached_name, completion_names</span>
<span class="gi">+</span>
<span class="gi">+    def _is_parameter_completion(self):</span>
<span class="gi">+        tos = self.stack[-1]</span>
<span class="gi">+        if tos.nonterminal == &#39;lambdef&#39; and len(tos.nodes) == 1:</span>
<span class="gi">+            # We are at the position `lambda `, where basically the next node</span>
<span class="gi">+            # is a param.</span>
<span class="gi">+            return True</span>
<span class="gi">+        if tos.nonterminal in &#39;parameters&#39;:</span>
<span class="gi">+            # Basically we are at the position `foo(`, there&#39;s nothing there</span>
<span class="gi">+            # yet, so we have no `typedargslist`.</span>
<span class="gi">+            return True</span>
<span class="gi">+        # var args is for lambdas and typed args for normal functions</span>
<span class="gi">+        return tos.nonterminal in (&#39;typedargslist&#39;, &#39;varargslist&#39;) and tos.nodes[-1] == &#39;,&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def _complete_params(self, leaf):</span>
<span class="gi">+        stack_node = self.stack[-2]</span>
<span class="gi">+        if stack_node.nonterminal == &#39;parameters&#39;:</span>
<span class="gi">+            stack_node = self.stack[-3]</span>
<span class="gi">+        if stack_node.nonterminal == &#39;funcdef&#39;:</span>
<span class="gi">+            context = get_user_context(self._module_context, self._position)</span>
<span class="gi">+            node = search_ancestor(leaf, &#39;error_node&#39;, &#39;funcdef&#39;)</span>
<span class="gi">+            if node is not None:</span>
<span class="gi">+                if node.type == &#39;error_node&#39;:</span>
<span class="gi">+                    n = node.children[0]</span>
<span class="gi">+                    if n.type == &#39;decorators&#39;:</span>
<span class="gi">+                        decorators = n.children</span>
<span class="gi">+                    elif n.type == &#39;decorator&#39;:</span>
<span class="gi">+                        decorators = [n]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        decorators = []</span>
<span class="gi">+                else:</span>
<span class="gi">+                    decorators = node.get_decorators()</span>
<span class="gi">+                function_name = stack_node.nodes[1]</span>
<span class="gi">+</span>
<span class="gi">+                return complete_param_names(context, function_name.value, decorators)</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def _complete_keywords(self, allowed_transitions, only_values):</span>
<span class="gi">+        for k in allowed_transitions:</span>
<span class="gi">+            if isinstance(k, str) and k.isalpha():</span>
<span class="gi">+                if not only_values or k in (&#39;True&#39;, &#39;False&#39;, &#39;None&#39;):</span>
<span class="gi">+                    yield keywords.KeywordName(self._inference_state, k)</span>
<span class="gi">+</span>
<span class="gi">+    def _complete_global_scope(self):</span>
<span class="gi">+        context = get_user_context(self._module_context, self._position)</span>
<span class="gi">+        debug.dbg(&#39;global completion scope: %s&#39;, context)</span>
<span class="gi">+        flow_scope_node = get_flow_scope_node(self._module_node, self._position)</span>
<span class="gi">+        filters = get_global_filters(</span>
<span class="gi">+            context,</span>
<span class="gi">+            self._position,</span>
<span class="gi">+            flow_scope_node</span>
<span class="gi">+        )</span>
<span class="gi">+        completion_names = []</span>
<span class="gi">+        for filter in filters:</span>
<span class="gi">+            completion_names += filter.values()</span>
<span class="gi">+        return completion_names</span>
<span class="gi">+</span>
<span class="gi">+    def _complete_trailer(self, previous_leaf):</span>
<span class="gi">+        inferred_context = self._module_context.create_context(previous_leaf)</span>
<span class="gi">+        values = infer_call_of_leaf(inferred_context, previous_leaf)</span>
<span class="gi">+        debug.dbg(&#39;trailer completion values: %s&#39;, values, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # The cached name simply exists to make speed optimizations for certain</span>
<span class="gi">+        # modules.</span>
<span class="gi">+        cached_name = None</span>
<span class="gi">+        if len(values) == 1:</span>
<span class="gi">+            v, = values</span>
<span class="gi">+            if v.is_module():</span>
<span class="gi">+                if len(v.string_names) == 1:</span>
<span class="gi">+                    module_name = v.string_names[0]</span>
<span class="gi">+                    if module_name in (&#39;numpy&#39;, &#39;tensorflow&#39;, &#39;matplotlib&#39;, &#39;pandas&#39;):</span>
<span class="gi">+                        cached_name = module_name</span>
<span class="gi">+</span>
<span class="gi">+        return cached_name, self._complete_trailer_for_values(values)</span>
<span class="gi">+</span>
<span class="gi">+    def _complete_trailer_for_values(self, values):</span>
<span class="gi">+        user_context = get_user_context(self._module_context, self._position)</span>
<span class="gi">+</span>
<span class="gi">+        return complete_trailer(user_context, values)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_importer_names(self, names, level=0, only_modules=True):</span>
<span class="gi">+        names = [n.value for n in names]</span>
<span class="gi">+        i = imports.Importer(self._inference_state, names, self._module_context, level)</span>
<span class="gi">+        return i.completion_names(self._inference_state, only_modules=only_modules)</span>

<span class="w"> </span>    def _complete_inherited(self, is_function=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Autocomplete inherited methods when overriding in child class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        leaf = self._module_node.get_leaf_for_position(self._position, include_prefixes=True)</span>
<span class="gi">+        cls = tree.search_ancestor(leaf, &#39;classdef&#39;)</span>
<span class="gi">+        if cls is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Complete the methods that are defined in the super classes.</span>
<span class="gi">+        class_value = self._module_context.create_value(cls)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.start_pos[1] &gt;= leaf.start_pos[1]:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        filters = class_value.get_filters(is_instance=True)</span>
<span class="gi">+        # The first dict is the dictionary of class itself.</span>
<span class="gi">+        next(filters)</span>
<span class="gi">+        for filter in filters:</span>
<span class="gi">+            for name in filter.values():</span>
<span class="gi">+                # TODO we should probably check here for properties</span>
<span class="gi">+                if (name.api_type == &#39;function&#39;) == is_function:</span>
<span class="gi">+                    yield name</span>

<span class="w"> </span>    def _complete_in_string(self, start_leaf, string):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -81,10 +442,122 @@ class Completion:</span>
<span class="w"> </span>        - Having some doctest code that starts with `&gt;&gt;&gt;`
<span class="w"> </span>        - Having backticks that doesn&#39;t have whitespace inside it
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def iter_relevant_lines(lines):</span>
<span class="gi">+            include_next_line = False</span>
<span class="gi">+            for l in code_lines:</span>
<span class="gi">+                if include_next_line or l.startswith(&#39;&gt;&gt;&gt;&#39;) or l.startswith(&#39; &#39;):</span>
<span class="gi">+                    yield re.sub(r&#39;^( *&gt;&gt;&gt; ?| +)&#39;, &#39;&#39;, l)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield None</span>
<span class="gi">+</span>
<span class="gi">+                include_next_line = bool(re.match(&#39; *&gt;&gt;&gt;&#39;, l))</span>
<span class="gi">+</span>
<span class="gi">+        string = dedent(string)</span>
<span class="gi">+        code_lines = split_lines(string, keepends=True)</span>
<span class="gi">+        relevant_code_lines = list(iter_relevant_lines(code_lines))</span>
<span class="gi">+        if relevant_code_lines[-1] is not None:</span>
<span class="gi">+            # Some code lines might be None, therefore get rid of that.</span>
<span class="gi">+            relevant_code_lines = [&#39;\n&#39; if c is None else c for c in relevant_code_lines]</span>
<span class="gi">+            return self._complete_code_lines(relevant_code_lines)</span>
<span class="gi">+        match = re.search(r&#39;`([^`\s]+)&#39;, code_lines[-1])</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return self._complete_code_lines([match.group(1)])</span>
<span class="gi">+        return []</span>

<span class="gi">+    def _complete_code_lines(self, code_lines):</span>
<span class="gi">+        module_node = self._inference_state.grammar.parse(&#39;&#39;.join(code_lines))</span>
<span class="gi">+        module_value = DocstringModule(</span>
<span class="gi">+            in_module_context=self._module_context,</span>
<span class="gi">+            inference_state=self._inference_state,</span>
<span class="gi">+            module_node=module_node,</span>
<span class="gi">+            code_lines=code_lines,</span>
<span class="gi">+        )</span>
<span class="gi">+        return Completion(</span>
<span class="gi">+            self._inference_state,</span>
<span class="gi">+            module_value.as_context(),</span>
<span class="gi">+            code_lines=code_lines,</span>
<span class="gi">+            position=module_node.end_pos,</span>
<span class="gi">+            signatures_callback=lambda *args, **kwargs: [],</span>
<span class="gi">+            fuzzy=self._fuzzy</span>
<span class="gi">+        ).complete()</span>

<span class="gd">-_string_start = re.compile(&#39;^\\w*(\\\&#39;{3}|&quot;{3}|\\\&#39;|&quot;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def _gather_nodes(stack):</span>
<span class="gi">+    nodes = []</span>
<span class="gi">+    for stack_node in stack:</span>
<span class="gi">+        if stack_node.dfa.from_rule == &#39;small_stmt&#39;:</span>
<span class="gi">+            nodes = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            nodes += stack_node.nodes</span>
<span class="gi">+    return nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_string_start = re.compile(r&#39;^\w*(\&#39;{3}|&quot;{3}|\&#39;|&quot;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _extract_string_while_in_string(leaf, position):</span>
<span class="gi">+    def return_part_of_leaf(leaf):</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+        if leaf.line == position[0]:</span>
<span class="gi">+            kwargs[&#39;endpos&#39;] = position[1] - leaf.column</span>
<span class="gi">+        match = _string_start.match(leaf.value, **kwargs)</span>
<span class="gi">+        if not match:</span>
<span class="gi">+            return None, None, None</span>
<span class="gi">+        start = match.group(0)</span>
<span class="gi">+        if leaf.line == position[0] and position[1] &lt; leaf.column + match.end():</span>
<span class="gi">+            return None, None, None</span>
<span class="gi">+        return cut_value_at_position(leaf, position)[match.end():], leaf, start</span>
<span class="gi">+</span>
<span class="gi">+    if position &lt; leaf.start_pos:</span>
<span class="gi">+        return None, None, None</span>
<span class="gi">+</span>
<span class="gi">+    if leaf.type == &#39;string&#39;:</span>
<span class="gi">+        return return_part_of_leaf(leaf)</span>
<span class="gi">+</span>
<span class="gi">+    leaves = []</span>
<span class="gi">+    while leaf is not None:</span>
<span class="gi">+        if leaf.type == &#39;error_leaf&#39; and (&#39;&quot;&#39; in leaf.value or &quot;&#39;&quot; in leaf.value):</span>
<span class="gi">+            if len(leaf.value) &gt; 1:</span>
<span class="gi">+                return return_part_of_leaf(leaf)</span>
<span class="gi">+            prefix_leaf = None</span>
<span class="gi">+            if not leaf.prefix:</span>
<span class="gi">+                prefix_leaf = leaf.get_previous_leaf()</span>
<span class="gi">+                if prefix_leaf is None or prefix_leaf.type != &#39;name&#39; \</span>
<span class="gi">+                        or not all(c in &#39;rubf&#39; for c in prefix_leaf.value.lower()):</span>
<span class="gi">+                    prefix_leaf = None</span>
<span class="gi">+</span>
<span class="gi">+            return (</span>
<span class="gi">+                &#39;&#39;.join(cut_value_at_position(l, position) for l in leaves),</span>
<span class="gi">+                prefix_leaf or leaf,</span>
<span class="gi">+                (&#39;&#39; if prefix_leaf is None else prefix_leaf.value)</span>
<span class="gi">+                + cut_value_at_position(leaf, position),</span>
<span class="gi">+            )</span>
<span class="gi">+        if leaf.line != position[0]:</span>
<span class="gi">+            # Multi line strings are always simple error leaves and contain the</span>
<span class="gi">+            # whole string, single line error leaves are atherefore important</span>
<span class="gi">+            # now and since the line is different, it&#39;s not really a single</span>
<span class="gi">+            # line string anymore.</span>
<span class="gi">+            break</span>
<span class="gi">+        leaves.insert(0, leaf)</span>
<span class="gi">+        leaf = leaf.get_previous_leaf()</span>
<span class="gi">+    return None, None, None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def complete_trailer(user_context, values):</span>
<span class="gi">+    completion_names = []</span>
<span class="gi">+    for value in values:</span>
<span class="gi">+        for filter in value.get_filters(origin_scope=user_context.tree_node):</span>
<span class="gi">+            completion_names += filter.values()</span>
<span class="gi">+</span>
<span class="gi">+        if not value.is_stub() and isinstance(value, TreeInstance):</span>
<span class="gi">+            completion_names += _complete_getattr(user_context, value)</span>
<span class="gi">+</span>
<span class="gi">+    python_values = convert_values(values)</span>
<span class="gi">+    for c in python_values:</span>
<span class="gi">+        if c not in values:</span>
<span class="gi">+            for filter in c.get_filters(origin_scope=user_context.tree_node):</span>
<span class="gi">+                completion_names += filter.values()</span>
<span class="gi">+    return completion_names</span>


<span class="w"> </span>def _complete_getattr(user_context, instance):
<span class="gu">@@ -107,4 +580,87 @@ def _complete_getattr(user_context, instance):</span>
<span class="w"> </span>    will write it like this anyway and the other ones, well they are just
<span class="w"> </span>    out of luck I guess :) ~dave.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    names = (instance.get_function_slot_names(&#39;__getattr__&#39;)</span>
<span class="gi">+             or instance.get_function_slot_names(&#39;__getattribute__&#39;))</span>
<span class="gi">+    functions = ValueSet.from_sets(</span>
<span class="gi">+        name.infer()</span>
<span class="gi">+        for name in names</span>
<span class="gi">+    )</span>
<span class="gi">+    for func in functions:</span>
<span class="gi">+        tree_node = func.tree_node</span>
<span class="gi">+        if tree_node is None or tree_node.type != &#39;funcdef&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        for return_stmt in tree_node.iter_return_stmts():</span>
<span class="gi">+            # Basically until the next comment we just try to find out if a</span>
<span class="gi">+            # return statement looks exactly like `return getattr(x, name)`.</span>
<span class="gi">+            if return_stmt.type != &#39;return_stmt&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            atom_expr = return_stmt.children[1]</span>
<span class="gi">+            if atom_expr.type != &#39;atom_expr&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            atom = atom_expr.children[0]</span>
<span class="gi">+            trailer = atom_expr.children[1]</span>
<span class="gi">+            if len(atom_expr.children) != 2 or atom.type != &#39;name&#39; \</span>
<span class="gi">+                    or atom.value != &#39;getattr&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            arglist = trailer.children[1]</span>
<span class="gi">+            if arglist.type != &#39;arglist&#39; or len(arglist.children) &lt; 3:</span>
<span class="gi">+                continue</span>
<span class="gi">+            context = func.as_context()</span>
<span class="gi">+            object_node = arglist.children[0]</span>
<span class="gi">+</span>
<span class="gi">+            # Make sure it&#39;s a param: foo in __getattr__(self, foo)</span>
<span class="gi">+            name_node = arglist.children[2]</span>
<span class="gi">+            name_list = context.goto(name_node, name_node.start_pos)</span>
<span class="gi">+            if not any(n.api_type == &#39;param&#39; for n in name_list):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Now that we know that these are most probably completion</span>
<span class="gi">+            # objects, we just infer the object and return them as</span>
<span class="gi">+            # completions.</span>
<span class="gi">+            objects = context.infer_node(object_node)</span>
<span class="gi">+            return complete_trailer(user_context, objects)</span>
<span class="gi">+    return []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def search_in_module(inference_state, module_context, names, wanted_names,</span>
<span class="gi">+                     wanted_type, complete=False, fuzzy=False,</span>
<span class="gi">+                     ignore_imports=False, convert=False):</span>
<span class="gi">+    for s in wanted_names[:-1]:</span>
<span class="gi">+        new_names = []</span>
<span class="gi">+        for n in names:</span>
<span class="gi">+            if s == n.string_name:</span>
<span class="gi">+                if n.tree_name is not None and n.api_type in (&#39;module&#39;, &#39;namespace&#39;) \</span>
<span class="gi">+                        and ignore_imports:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                new_names += complete_trailer(</span>
<span class="gi">+                    module_context,</span>
<span class="gi">+                    n.infer()</span>
<span class="gi">+                )</span>
<span class="gi">+        debug.dbg(&#39;dot lookup on search %s from %s&#39;, new_names, names[:10])</span>
<span class="gi">+        names = new_names</span>
<span class="gi">+</span>
<span class="gi">+    last_name = wanted_names[-1].lower()</span>
<span class="gi">+    for n in names:</span>
<span class="gi">+        string = n.string_name.lower()</span>
<span class="gi">+        if complete and helpers.match(string, last_name, fuzzy=fuzzy) \</span>
<span class="gi">+                or not complete and string == last_name:</span>
<span class="gi">+            if isinstance(n, SubModuleName):</span>
<span class="gi">+                names = [v.name for v in n.infer()]</span>
<span class="gi">+            else:</span>
<span class="gi">+                names = [n]</span>
<span class="gi">+            if convert:</span>
<span class="gi">+                names = convert_names(names)</span>
<span class="gi">+            for n2 in names:</span>
<span class="gi">+                if complete:</span>
<span class="gi">+                    def_ = classes.Completion(</span>
<span class="gi">+                        inference_state, n2,</span>
<span class="gi">+                        stack=None,</span>
<span class="gi">+                        like_name_length=len(last_name),</span>
<span class="gi">+                        is_fuzzy=fuzzy,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    def_ = classes.Name(inference_state, n2)</span>
<span class="gi">+                if not wanted_type or wanted_type == def_.type:</span>
<span class="gi">+                    yield def_</span>
<span class="gh">diff --git a/jedi/api/completion_cache.py b/jedi/api/completion_cache.py</span>
<span class="gh">index 0fcf17c4..46e9bead 100644</span>
<span class="gd">--- a/jedi/api/completion_cache.py</span>
<span class="gi">+++ b/jedi/api/completion_cache.py</span>
<span class="gu">@@ -1,7 +1,31 @@</span>
<span class="w"> </span>from typing import Dict, Tuple, Callable
<span class="gi">+</span>
<span class="w"> </span>CacheValues = Tuple[str, str, str]
<span class="w"> </span>CacheValuesCallback = Callable[[], CacheValues]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_cache: Dict[str, Dict[str, CacheValues]] = {}
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def save_entry(module_name: str, name: str, cache: CacheValues) -&gt; None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_cache = _cache[module_name]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        module_cache = _cache[module_name] = {}</span>
<span class="gi">+    module_cache[name] = cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_get_from_cache(number: int) -&gt; Callable[[str, str, CacheValuesCallback], str]:</span>
<span class="gi">+    def _get_from_cache(module_name: str, name: str, get_cache_values: CacheValuesCallback) -&gt; str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _cache[module_name][name][number]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            v = get_cache_values()</span>
<span class="gi">+            save_entry(module_name, name, v)</span>
<span class="gi">+            return v[number]</span>
<span class="gi">+    return _get_from_cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>get_type = _create_get_from_cache(0)
<span class="w"> </span>get_docstring_signature = _create_get_from_cache(1)
<span class="w"> </span>get_docstring = _create_get_from_cache(2)
<span class="gh">diff --git a/jedi/api/environment.py b/jedi/api/environment.py</span>
<span class="gh">index ec0c00aa..771a9a83 100644</span>
<span class="gd">--- a/jedi/api/environment.py</span>
<span class="gi">+++ b/jedi/api/environment.py</span>
<span class="gu">@@ -8,10 +8,15 @@ import hashlib</span>
<span class="w"> </span>import filecmp
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from shutil import which
<span class="gi">+</span>
<span class="w"> </span>from jedi.cache import memoize_method, time_cache
<span class="gd">-from jedi.inference.compiled.subprocess import CompiledSubprocess, InferenceStateSameProcess, InferenceStateSubprocess</span>
<span class="gi">+from jedi.inference.compiled.subprocess import CompiledSubprocess, \</span>
<span class="gi">+    InferenceStateSameProcess, InferenceStateSubprocess</span>
<span class="gi">+</span>
<span class="w"> </span>import parso
<span class="gd">-_VersionInfo = namedtuple(&#39;VersionInfo&#39;, &#39;major minor micro&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_VersionInfo = namedtuple(&#39;VersionInfo&#39;, &#39;major minor micro&#39;)  # type: ignore[name-match]</span>
<span class="gi">+</span>
<span class="w"> </span>_SUPPORTED_PYTHONS = [&#39;3.12&#39;, &#39;3.11&#39;, &#39;3.10&#39;, &#39;3.9&#39;, &#39;3.8&#39;, &#39;3.7&#39;, &#39;3.6&#39;]
<span class="w"> </span>_SAFE_PATHS = [&#39;/usr/bin&#39;, &#39;/usr/local/bin&#39;]
<span class="w"> </span>_CONDA_VAR = &#39;CONDA_PREFIX&#39;
<span class="gu">@@ -26,7 +31,26 @@ class InvalidPythonEnvironment(Exception):</span>


<span class="w"> </span>class _BaseEnvironment:
<span class="gd">-    pass</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def get_grammar(self):</span>
<span class="gi">+        version_string = &#39;%s.%s&#39; % (self.version_info.major, self.version_info.minor)</span>
<span class="gi">+        return parso.load_grammar(version=version_string)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _sha256(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._hash</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            self._hash = _calculate_sha256_for_file(self.executable)</span>
<span class="gi">+            return self._hash</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_info():</span>
<span class="gi">+    return (</span>
<span class="gi">+        sys.executable,</span>
<span class="gi">+        sys.prefix,</span>
<span class="gi">+        sys.version_info[:3],</span>
<span class="gi">+    )</span>


<span class="w"> </span>class Environment(_BaseEnvironment):
<span class="gu">@@ -40,12 +64,47 @@ class Environment(_BaseEnvironment):</span>
<span class="w"> </span>    def __init__(self, executable, env_vars=None):
<span class="w"> </span>        self._start_executable = executable
<span class="w"> </span>        self._env_vars = env_vars
<span class="gi">+        # Initialize the environment</span>
<span class="w"> </span>        self._get_subprocess()

<span class="gi">+    def _get_subprocess(self):</span>
<span class="gi">+        if self._subprocess is not None and not self._subprocess.is_crashed:</span>
<span class="gi">+            return self._subprocess</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._subprocess = CompiledSubprocess(self._start_executable,</span>
<span class="gi">+                                                  env_vars=self._env_vars)</span>
<span class="gi">+            info = self._subprocess._send(None, _get_info)</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            raise InvalidPythonEnvironment(</span>
<span class="gi">+                &quot;Could not get version information for %r: %r&quot; % (</span>
<span class="gi">+                    self._start_executable,</span>
<span class="gi">+                    exc))</span>
<span class="gi">+</span>
<span class="gi">+        # Since it could change and might not be the same(?) as the one given,</span>
<span class="gi">+        # set it here.</span>
<span class="gi">+        self.executable = info[0]</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        The Python executable, matches ``sys.executable``.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        self.path = info[1]</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        The path to an environment, matches ``sys.prefix``.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        self.version_info = _VersionInfo(*info[2])</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Like :data:`sys.version_info`: a tuple to show the current</span>
<span class="gi">+        Environment&#39;s Python version.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self._subprocess</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        version = &#39;.&#39;.join(str(i) for i in self.version_info)
<span class="w"> </span>        return &#39;&lt;%s: %s in %s&gt;&#39; % (self.__class__.__name__, version, self.path)

<span class="gi">+    def get_inference_state_subprocess(self, inference_state):</span>
<span class="gi">+        return InferenceStateSubprocess(inference_state, self._get_subprocess())</span>
<span class="gi">+</span>
<span class="w"> </span>    @memoize_method
<span class="w"> </span>    def get_sys_path(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -54,11 +113,15 @@ class Environment(_BaseEnvironment):</span>

<span class="w"> </span>        :returns: list of str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # It&#39;s pretty much impossible to generate the sys path without actually</span>
<span class="gi">+        # executing Python. The sys path (when starting with -S) itself depends</span>
<span class="gi">+        # on how the Python version was compiled (ENV variables).</span>
<span class="gi">+        # If you omit -S when starting Python (normal case), additionally</span>
<span class="gi">+        # site.py gets executed.</span>
<span class="gi">+        return self._get_subprocess().get_sys_path()</span>


<span class="w"> </span>class _SameEnvironmentMixin:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._start_executable = self.executable = sys.executable
<span class="w"> </span>        self.path = sys.prefix
<span class="gu">@@ -71,7 +134,11 @@ class SameEnvironment(_SameEnvironmentMixin, Environment):</span>


<span class="w"> </span>class InterpreterEnvironment(_SameEnvironmentMixin, _BaseEnvironment):
<span class="gd">-    pass</span>
<span class="gi">+    def get_inference_state_subprocess(self, inference_state):</span>
<span class="gi">+        return InferenceStateSameProcess(inference_state)</span>
<span class="gi">+</span>
<span class="gi">+    def get_sys_path(self):</span>
<span class="gi">+        return sys.path</span>


<span class="w"> </span>def _get_virtual_env_from_var(env_var=&#39;VIRTUAL_ENV&#39;):
<span class="gu">@@ -80,7 +147,27 @@ def _get_virtual_env_from_var(env_var=&#39;VIRTUAL_ENV&#39;):</span>
<span class="w"> </span>    It uses `safe=False` with ``create_environment``, because the environment
<span class="w"> </span>    variable is considered to be safe / controlled by the user solely.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    var = os.environ.get(env_var)</span>
<span class="gi">+    if var:</span>
<span class="gi">+        # Under macOS in some cases - notably when using Pipenv - the</span>
<span class="gi">+        # sys.prefix of the virtualenv is /path/to/env/bin/.. instead of</span>
<span class="gi">+        # /path/to/env so we need to fully resolve the paths in order to</span>
<span class="gi">+        # compare them.</span>
<span class="gi">+        if os.path.realpath(var) == os.path.realpath(sys.prefix):</span>
<span class="gi">+            return _try_get_same_env()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return create_environment(var, safe=False)</span>
<span class="gi">+        except InvalidPythonEnvironment:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _calculate_sha256_for_file(path):</span>
<span class="gi">+    sha256 = hashlib.sha256()</span>
<span class="gi">+    with open(path, &#39;rb&#39;) as f:</span>
<span class="gi">+        for block in iter(lambda: f.read(filecmp.BUFSIZE), b&#39;&#39;):</span>
<span class="gi">+            sha256.update(block)</span>
<span class="gi">+    return sha256.hexdigest()</span>


<span class="w"> </span>def get_default_environment():
<span class="gu">@@ -93,7 +180,81 @@ def get_default_environment():</span>

<span class="w"> </span>    :returns: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    virtual_env = _get_virtual_env_from_var()</span>
<span class="gi">+    if virtual_env is not None:</span>
<span class="gi">+        return virtual_env</span>
<span class="gi">+</span>
<span class="gi">+    conda_env = _get_virtual_env_from_var(_CONDA_VAR)</span>
<span class="gi">+    if conda_env is not None:</span>
<span class="gi">+        return conda_env</span>
<span class="gi">+</span>
<span class="gi">+    return _try_get_same_env()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _try_get_same_env():</span>
<span class="gi">+    env = SameEnvironment()</span>
<span class="gi">+    if not os.path.basename(env.executable).lower().startswith(&#39;python&#39;):</span>
<span class="gi">+        # This tries to counter issues with embedding. In some cases (e.g.</span>
<span class="gi">+        # VIM&#39;s Python Mac/Windows, sys.executable is /foo/bar/vim. This</span>
<span class="gi">+        # happens, because for Mac a function called `_NSGetExecutablePath` is</span>
<span class="gi">+        # used and for Windows `GetModuleFileNameW`. These are both platform</span>
<span class="gi">+        # specific functions. For all other systems sys.executable should be</span>
<span class="gi">+        # alright. However here we try to generalize:</span>
<span class="gi">+        #</span>
<span class="gi">+        # 1. Check if the executable looks like python (heuristic)</span>
<span class="gi">+        # 2. In case it&#39;s not try to find the executable</span>
<span class="gi">+        # 3. In case we don&#39;t find it use an interpreter environment.</span>
<span class="gi">+        #</span>
<span class="gi">+        # The last option will always work, but leads to potential crashes of</span>
<span class="gi">+        # Jedi - which is ok, because it happens very rarely and even less,</span>
<span class="gi">+        # because the code below should work for most cases.</span>
<span class="gi">+        if os.name == &#39;nt&#39;:</span>
<span class="gi">+            # The first case would be a virtualenv and the second a normal</span>
<span class="gi">+            # Python installation.</span>
<span class="gi">+            checks = (r&#39;Scripts\python.exe&#39;, &#39;python.exe&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # For unix it looks like Python is always in a bin folder.</span>
<span class="gi">+            checks = (</span>
<span class="gi">+                &#39;bin/python%s.%s&#39; % (sys.version_info[0], sys.version[1]),</span>
<span class="gi">+                &#39;bin/python%s&#39; % (sys.version_info[0]),</span>
<span class="gi">+                &#39;bin/python&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        for check in checks:</span>
<span class="gi">+            guess = os.path.join(sys.exec_prefix, check)</span>
<span class="gi">+            if os.path.isfile(guess):</span>
<span class="gi">+                # Bingo - We think we have our Python.</span>
<span class="gi">+                return Environment(guess)</span>
<span class="gi">+        # It looks like there is no reasonable Python to be found.</span>
<span class="gi">+        return InterpreterEnvironment()</span>
<span class="gi">+    # If no virtualenv is found, use the environment we&#39;re already</span>
<span class="gi">+    # using.</span>
<span class="gi">+    return env</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_cached_default_environment():</span>
<span class="gi">+    var = os.environ.get(&#39;VIRTUAL_ENV&#39;) or os.environ.get(_CONDA_VAR)</span>
<span class="gi">+    environment = _get_cached_default_environment()</span>
<span class="gi">+</span>
<span class="gi">+    # Under macOS in some cases - notably when using Pipenv - the</span>
<span class="gi">+    # sys.prefix of the virtualenv is /path/to/env/bin/.. instead of</span>
<span class="gi">+    # /path/to/env so we need to fully resolve the paths in order to</span>
<span class="gi">+    # compare them.</span>
<span class="gi">+    if var and os.path.realpath(var) != os.path.realpath(environment.path):</span>
<span class="gi">+        _get_cached_default_environment.clear_cache()</span>
<span class="gi">+        return _get_cached_default_environment()</span>
<span class="gi">+    return environment</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@time_cache(seconds=10 * 60)  # 10 Minutes</span>
<span class="gi">+def _get_cached_default_environment():</span>
<span class="gi">+    try:</span>
<span class="gi">+        return get_default_environment()</span>
<span class="gi">+    except InvalidPythonEnvironment:</span>
<span class="gi">+        # It&#39;s possible that `sys.executable` is wrong. Typically happens</span>
<span class="gi">+        # when Jedi is used in an executable that embeds Python. For further</span>
<span class="gi">+        # information, have a look at:</span>
<span class="gi">+        # https://github.com/davidhalter/jedi/issues/1531</span>
<span class="gi">+        return InterpreterEnvironment()</span>


<span class="w"> </span>def find_virtualenvs(paths=None, *, safe=True, use_environment_vars=True):
<span class="gu">@@ -113,7 +274,41 @@ def find_virtualenvs(paths=None, *, safe=True, use_environment_vars=True):</span>

<span class="w"> </span>    :yields: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if paths is None:</span>
<span class="gi">+        paths = []</span>
<span class="gi">+</span>
<span class="gi">+    _used_paths = set()</span>
<span class="gi">+</span>
<span class="gi">+    if use_environment_vars:</span>
<span class="gi">+        # Using this variable should be safe, because attackers might be</span>
<span class="gi">+        # able to drop files (via git) but not environment variables.</span>
<span class="gi">+        virtual_env = _get_virtual_env_from_var()</span>
<span class="gi">+        if virtual_env is not None:</span>
<span class="gi">+            yield virtual_env</span>
<span class="gi">+            _used_paths.add(virtual_env.path)</span>
<span class="gi">+</span>
<span class="gi">+        conda_env = _get_virtual_env_from_var(_CONDA_VAR)</span>
<span class="gi">+        if conda_env is not None:</span>
<span class="gi">+            yield conda_env</span>
<span class="gi">+            _used_paths.add(conda_env.path)</span>
<span class="gi">+</span>
<span class="gi">+    for directory in paths:</span>
<span class="gi">+        if not os.path.isdir(directory):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        directory = os.path.abspath(directory)</span>
<span class="gi">+        for path in os.listdir(directory):</span>
<span class="gi">+            path = os.path.join(directory, path)</span>
<span class="gi">+            if path in _used_paths:</span>
<span class="gi">+                # A path shouldn&#39;t be inferred twice.</span>
<span class="gi">+                continue</span>
<span class="gi">+            _used_paths.add(path)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                executable = _get_executable_path(path, safe=safe)</span>
<span class="gi">+                yield Environment(executable)</span>
<span class="gi">+            except InvalidPythonEnvironment:</span>
<span class="gi">+                pass</span>


<span class="w"> </span>def find_system_environments(*, env_vars=None):
<span class="gu">@@ -126,9 +321,15 @@ def find_system_environments(*, env_vars=None):</span>

<span class="w"> </span>    :yields: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for version_string in _SUPPORTED_PYTHONS:</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield get_system_environment(version_string, env_vars=env_vars)</span>
<span class="gi">+        except InvalidPythonEnvironment:</span>
<span class="gi">+            pass</span>


<span class="gi">+# TODO: this function should probably return a list of environments since</span>
<span class="gi">+# multiple Python installations can be found on a system for the same version.</span>
<span class="w"> </span>def get_system_environment(version, *, env_vars=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the first Python environment found for a string of the form &#39;X.Y&#39;
<span class="gu">@@ -137,7 +338,19 @@ def get_system_environment(version, *, env_vars=None):</span>
<span class="w"> </span>    :raises: :exc:`.InvalidPythonEnvironment`
<span class="w"> </span>    :returns: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exe = which(&#39;python&#39; + version)</span>
<span class="gi">+    if exe:</span>
<span class="gi">+        if exe == sys.executable:</span>
<span class="gi">+            return SameEnvironment()</span>
<span class="gi">+        return Environment(exe)</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &#39;nt&#39;:</span>
<span class="gi">+        for exe in _get_executables_from_windows_registry(version):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return Environment(exe, env_vars=env_vars)</span>
<span class="gi">+            except InvalidPythonEnvironment:</span>
<span class="gi">+                pass</span>
<span class="gi">+    raise InvalidPythonEnvironment(&quot;Cannot find executable python%s.&quot; % version)</span>


<span class="w"> </span>def create_environment(path, *, safe=True, env_vars=None):
<span class="gu">@@ -148,11 +361,106 @@ def create_environment(path, *, safe=True, env_vars=None):</span>
<span class="w"> </span>    :raises: :exc:`.InvalidPythonEnvironment`
<span class="w"> </span>    :returns: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.isfile(path):</span>
<span class="gi">+        _assert_safe(path, safe)</span>
<span class="gi">+        return Environment(path, env_vars=env_vars)</span>
<span class="gi">+    return Environment(_get_executable_path(path, safe=safe), env_vars=env_vars)</span>


<span class="w"> </span>def _get_executable_path(path, safe=True):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns None if it&#39;s not actually a virtual env.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if os.name == &#39;nt&#39;:</span>
<span class="gi">+        python = os.path.join(path, &#39;Scripts&#39;, &#39;python.exe&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        python = os.path.join(path, &#39;bin&#39;, &#39;python&#39;)</span>
<span class="gi">+    if not os.path.exists(python):</span>
<span class="gi">+        raise InvalidPythonEnvironment(&quot;%s seems to be missing.&quot; % python)</span>
<span class="gi">+</span>
<span class="gi">+    _assert_safe(python, safe)</span>
<span class="gi">+    return python</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_executables_from_windows_registry(version):</span>
<span class="gi">+    import winreg</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: support Python Anaconda.</span>
<span class="gi">+    sub_keys = [</span>
<span class="gi">+        r&#39;SOFTWARE\Python\PythonCore\{version}\InstallPath&#39;,</span>
<span class="gi">+        r&#39;SOFTWARE\Wow6432Node\Python\PythonCore\{version}\InstallPath&#39;,</span>
<span class="gi">+        r&#39;SOFTWARE\Python\PythonCore\{version}-32\InstallPath&#39;,</span>
<span class="gi">+        r&#39;SOFTWARE\Wow6432Node\Python\PythonCore\{version}-32\InstallPath&#39;</span>
<span class="gi">+    ]</span>
<span class="gi">+    for root_key in [winreg.HKEY_CURRENT_USER, winreg.HKEY_LOCAL_MACHINE]:</span>
<span class="gi">+        for sub_key in sub_keys:</span>
<span class="gi">+            sub_key = sub_key.format(version=version)</span>
<span class="gi">+            try:</span>
<span class="gi">+                with winreg.OpenKey(root_key, sub_key) as key:</span>
<span class="gi">+                    prefix = winreg.QueryValueEx(key, &#39;&#39;)[0]</span>
<span class="gi">+                    exe = os.path.join(prefix, &#39;python.exe&#39;)</span>
<span class="gi">+                    if os.path.isfile(exe):</span>
<span class="gi">+                        yield exe</span>
<span class="gi">+            except WindowsError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _assert_safe(executable_path, safe):</span>
<span class="gi">+    if safe and not _is_safe(executable_path):</span>
<span class="gi">+        raise InvalidPythonEnvironment(</span>
<span class="gi">+            &quot;The python binary is potentially unsafe.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_safe(executable_path):</span>
<span class="gi">+    # Resolve sym links. A venv typically is a symlink to a known Python</span>
<span class="gi">+    # binary. Only virtualenvs copy symlinks around.</span>
<span class="gi">+    real_path = os.path.realpath(executable_path)</span>
<span class="gi">+</span>
<span class="gi">+    if _is_unix_safe_simple(real_path):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Just check the list of known Python versions. If it&#39;s not in there,</span>
<span class="gi">+    # it&#39;s likely an attacker or some Python that was not properly</span>
<span class="gi">+    # installed in the system.</span>
<span class="gi">+    for environment in find_system_environments():</span>
<span class="gi">+        if environment.executable == real_path:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        # If the versions don&#39;t match, just compare the binary files. If we</span>
<span class="gi">+        # don&#39;t do that, only venvs will be working and not virtualenvs.</span>
<span class="gi">+        # venvs are symlinks while virtualenvs are actual copies of the</span>
<span class="gi">+        # Python files.</span>
<span class="gi">+        # This still means that if the system Python is updated and the</span>
<span class="gi">+        # virtualenv&#39;s Python is not (which is probably never going to get</span>
<span class="gi">+        # upgraded), it will not work with Jedi. IMO that&#39;s fine, because</span>
<span class="gi">+        # people should just be using venv. ~ dave</span>
<span class="gi">+        if environment._sha256 == _calculate_sha256_for_file(real_path):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_unix_safe_simple(real_path):</span>
<span class="gi">+    if _is_unix_admin():</span>
<span class="gi">+        # In case we are root, just be conservative and</span>
<span class="gi">+        # only execute known paths.</span>
<span class="gi">+        return any(real_path.startswith(p) for p in _SAFE_PATHS)</span>
<span class="gi">+</span>
<span class="gi">+    uid = os.stat(real_path).st_uid</span>
<span class="gi">+    # The interpreter needs to be owned by root. This means that it wasn&#39;t</span>
<span class="gi">+    # written by a user and therefore attacking Jedi is not as simple.</span>
<span class="gi">+    # The attack could look like the following:</span>
<span class="gi">+    # 1. A user clones a repository.</span>
<span class="gi">+    # 2. The repository has an innocent looking folder called foobar. jedi</span>
<span class="gi">+    #    searches for the folder and executes foobar/bin/python --version if</span>
<span class="gi">+    #    there&#39;s also a foobar/bin/activate.</span>
<span class="gi">+    # 3. The attacker has gained code execution, since he controls</span>
<span class="gi">+    #    foobar/bin/python.</span>
<span class="gi">+    return uid == 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_unix_admin():</span>
<span class="gi">+    try:</span>
<span class="gi">+        return os.getuid() == 0</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False  # Windows</span>
<span class="gh">diff --git a/jedi/api/errors.py b/jedi/api/errors.py</span>
<span class="gh">index 6f0d001a..10cb62af 100644</span>
<span class="gd">--- a/jedi/api/errors.py</span>
<span class="gi">+++ b/jedi/api/errors.py</span>
<span class="gu">@@ -4,34 +4,43 @@ Jedi.</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gi">+def parso_to_jedi_errors(grammar, module_node):</span>
<span class="gi">+    return [SyntaxError(e) for e in grammar.iter_errors(module_node)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class SyntaxError:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Syntax errors are generated by :meth:`.Script.get_syntax_errors`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, parso_error):
<span class="w"> </span>        self._parso_error = parso_error

<span class="w"> </span>    @property
<span class="w"> </span>    def line(self):
<span class="w"> </span>        &quot;&quot;&quot;The line where the error starts (starting with 1).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.start_pos[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def column(self):
<span class="w"> </span>        &quot;&quot;&quot;The column where the error starts (starting with 0).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.start_pos[1]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def until_line(self):
<span class="w"> </span>        &quot;&quot;&quot;The line where the error ends (starting with 1).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.end_pos[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def until_column(self):
<span class="w"> </span>        &quot;&quot;&quot;The column where the error ends (starting with 0).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.end_pos[1]</span>
<span class="gi">+</span>
<span class="gi">+    def get_message(self):</span>
<span class="gi">+        return self._parso_error.message</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s from=%s to=%s&gt;&#39; % (self.__class__.__name__, self.</span>
<span class="gd">-            _parso_error.start_pos, self._parso_error.end_pos)</span>
<span class="gi">+        return &#39;&lt;%s from=%s to=%s&gt;&#39; % (</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self._parso_error.start_pos,</span>
<span class="gi">+            self._parso_error.end_pos,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/jedi/api/file_name.py b/jedi/api/file_name.py</span>
<span class="gh">index 23dce6e9..277f3220 100644</span>
<span class="gd">--- a/jedi/api/file_name.py</span>
<span class="gi">+++ b/jedi/api/file_name.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from jedi.api import classes
<span class="w"> </span>from jedi.api.strings import StringName, get_quote_ending
<span class="w"> </span>from jedi.api.helpers import match
<span class="gu">@@ -7,3 +8,148 @@ from jedi.inference.helpers import get_str_or_none</span>

<span class="w"> </span>class PathName(StringName):
<span class="w"> </span>    api_type = &#39;path&#39;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def complete_file_name(inference_state, module_context, start_leaf, quote, string,</span>
<span class="gi">+                       like_name, signatures_callback, code_lines, position, fuzzy):</span>
<span class="gi">+    # First we want to find out what can actually be changed as a name.</span>
<span class="gi">+    like_name_length = len(os.path.basename(string))</span>
<span class="gi">+</span>
<span class="gi">+    addition = _get_string_additions(module_context, start_leaf)</span>
<span class="gi">+    if string.startswith(&#39;~&#39;):</span>
<span class="gi">+        string = os.path.expanduser(string)</span>
<span class="gi">+    if addition is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    string = addition + string</span>
<span class="gi">+</span>
<span class="gi">+    # Here we use basename again, because if strings are added like</span>
<span class="gi">+    # `&#39;foo&#39; + &#39;bar`, it should complete to `foobar/`.</span>
<span class="gi">+    must_start_with = os.path.basename(string)</span>
<span class="gi">+    string = os.path.dirname(string)</span>
<span class="gi">+</span>
<span class="gi">+    sigs = signatures_callback(*position)</span>
<span class="gi">+    is_in_os_path_join = sigs and all(s.full_name == &#39;os.path.join&#39; for s in sigs)</span>
<span class="gi">+    if is_in_os_path_join:</span>
<span class="gi">+        to_be_added = _add_os_path_join(module_context, start_leaf, sigs[0].bracket_start)</span>
<span class="gi">+        if to_be_added is None:</span>
<span class="gi">+            is_in_os_path_join = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            string = to_be_added + string</span>
<span class="gi">+    base_path = os.path.join(inference_state.project.path, string)</span>
<span class="gi">+    try:</span>
<span class="gi">+        listed = sorted(os.scandir(base_path), key=lambda e: e.name)</span>
<span class="gi">+        # OSError: [Errno 36] File name too long: &#39;...&#39;</span>
<span class="gi">+    except (FileNotFoundError, OSError):</span>
<span class="gi">+        return</span>
<span class="gi">+    quote_ending = get_quote_ending(quote, code_lines, position)</span>
<span class="gi">+    for entry in listed:</span>
<span class="gi">+        name = entry.name</span>
<span class="gi">+        if match(name, must_start_with, fuzzy=fuzzy):</span>
<span class="gi">+            if is_in_os_path_join or not entry.is_dir():</span>
<span class="gi">+                name += quote_ending</span>
<span class="gi">+            else:</span>
<span class="gi">+                name += os.path.sep</span>
<span class="gi">+</span>
<span class="gi">+            yield classes.Completion(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                PathName(inference_state, name[len(must_start_with) - like_name_length:]),</span>
<span class="gi">+                stack=None,</span>
<span class="gi">+                like_name_length=like_name_length,</span>
<span class="gi">+                is_fuzzy=fuzzy,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_string_additions(module_context, start_leaf):</span>
<span class="gi">+    def iterate_nodes():</span>
<span class="gi">+        node = addition.parent</span>
<span class="gi">+        was_addition = True</span>
<span class="gi">+        for child_node in reversed(node.children[:node.children.index(addition)]):</span>
<span class="gi">+            if was_addition:</span>
<span class="gi">+                was_addition = False</span>
<span class="gi">+                yield child_node</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if child_node != &#39;+&#39;:</span>
<span class="gi">+                break</span>
<span class="gi">+            was_addition = True</span>
<span class="gi">+</span>
<span class="gi">+    addition = start_leaf.get_previous_leaf()</span>
<span class="gi">+    if addition != &#39;+&#39;:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    context = module_context.create_context(start_leaf)</span>
<span class="gi">+    return _add_strings(context, reversed(list(iterate_nodes())))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_strings(context, nodes, add_slash=False):</span>
<span class="gi">+    string = &#39;&#39;</span>
<span class="gi">+    first = True</span>
<span class="gi">+    for child_node in nodes:</span>
<span class="gi">+        values = context.infer_node(child_node)</span>
<span class="gi">+        if len(values) != 1:</span>
<span class="gi">+            return None</span>
<span class="gi">+        c, = values</span>
<span class="gi">+        s = get_str_or_none(c)</span>
<span class="gi">+        if s is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if not first and add_slash:</span>
<span class="gi">+            string += os.path.sep</span>
<span class="gi">+        string += s</span>
<span class="gi">+        first = False</span>
<span class="gi">+    return string</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_os_path_join(module_context, start_leaf, bracket_start):</span>
<span class="gi">+    def check(maybe_bracket, nodes):</span>
<span class="gi">+        if maybe_bracket.start_pos != bracket_start:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if not nodes:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        context = module_context.create_context(nodes[0])</span>
<span class="gi">+        return _add_strings(context, nodes, add_slash=True) or &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if start_leaf.type == &#39;error_leaf&#39;:</span>
<span class="gi">+        # Unfinished string literal, like `join(&#39;`</span>
<span class="gi">+        value_node = start_leaf.parent</span>
<span class="gi">+        index = value_node.children.index(start_leaf)</span>
<span class="gi">+        if index &gt; 0:</span>
<span class="gi">+            error_node = value_node.children[index - 1]</span>
<span class="gi">+            if error_node.type == &#39;error_node&#39; and len(error_node.children) &gt;= 2:</span>
<span class="gi">+                index = -2</span>
<span class="gi">+                if error_node.children[-1].type == &#39;arglist&#39;:</span>
<span class="gi">+                    arglist_nodes = error_node.children[-1].children</span>
<span class="gi">+                    index -= 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    arglist_nodes = []</span>
<span class="gi">+</span>
<span class="gi">+                return check(error_node.children[index + 1], arglist_nodes[::2])</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # Maybe an arglist or some weird error case. Therefore checked below.</span>
<span class="gi">+    searched_node_child = start_leaf</span>
<span class="gi">+    while searched_node_child.parent is not None \</span>
<span class="gi">+            and searched_node_child.parent.type not in (&#39;arglist&#39;, &#39;trailer&#39;, &#39;error_node&#39;):</span>
<span class="gi">+        searched_node_child = searched_node_child.parent</span>
<span class="gi">+</span>
<span class="gi">+    if searched_node_child.get_first_leaf() is not start_leaf:</span>
<span class="gi">+        return None</span>
<span class="gi">+    searched_node = searched_node_child.parent</span>
<span class="gi">+    if searched_node is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    index = searched_node.children.index(searched_node_child)</span>
<span class="gi">+    arglist_nodes = searched_node.children[:index]</span>
<span class="gi">+    if searched_node.type == &#39;arglist&#39;:</span>
<span class="gi">+        trailer = searched_node.parent</span>
<span class="gi">+        if trailer.type == &#39;error_node&#39;:</span>
<span class="gi">+            trailer_index = trailer.children.index(searched_node)</span>
<span class="gi">+            assert trailer_index &gt;= 2</span>
<span class="gi">+            assert trailer.children[trailer_index - 1] == &#39;(&#39;</span>
<span class="gi">+            return check(trailer.children[trailer_index - 1], arglist_nodes[::2])</span>
<span class="gi">+        elif trailer.type == &#39;trailer&#39;:</span>
<span class="gi">+            return check(trailer.children[0], arglist_nodes[::2])</span>
<span class="gi">+    elif searched_node.type == &#39;trailer&#39;:</span>
<span class="gi">+        return check(searched_node.children[0], [])</span>
<span class="gi">+    elif searched_node.type == &#39;error_node&#39;:</span>
<span class="gi">+        # Stuff like `join(&quot;&quot;`</span>
<span class="gi">+        return check(arglist_nodes[-1], [])</span>
<span class="gh">diff --git a/jedi/api/helpers.py b/jedi/api/helpers.py</span>
<span class="gh">index 18bd99de..111f75b4 100644</span>
<span class="gd">--- a/jedi/api/helpers.py</span>
<span class="gi">+++ b/jedi/api/helpers.py</span>
<span class="gu">@@ -7,48 +7,485 @@ from textwrap import dedent</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from parso.python.parser import Parser
<span class="w"> </span>from parso.python import tree
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.base_value import NO_VALUES
<span class="w"> </span>from jedi.inference.syntax_tree import infer_atom
<span class="w"> </span>from jedi.inference.helpers import infer_call_of_leaf
<span class="w"> </span>from jedi.inference.compiled import get_string_value_set
<span class="w"> </span>from jedi.cache import signature_time_cache, memoize_method
<span class="w"> </span>from jedi.parser_utils import get_parent_scope
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>CompletionParts = namedtuple(&#39;CompletionParts&#39;, [&#39;path&#39;, &#39;has_dot&#39;, &#39;name&#39;])


<span class="gi">+def _start_match(string, like_name):</span>
<span class="gi">+    return string.startswith(like_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _fuzzy_match(string, like_name):</span>
<span class="gi">+    if len(like_name) &lt;= 1:</span>
<span class="gi">+        return like_name in string</span>
<span class="gi">+    pos = string.find(like_name[0])</span>
<span class="gi">+    if pos &gt;= 0:</span>
<span class="gi">+        return _fuzzy_match(string[pos + 1:], like_name[1:])</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def match(string, like_name, fuzzy=False):</span>
<span class="gi">+    if fuzzy:</span>
<span class="gi">+        return _fuzzy_match(string, like_name)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _start_match(string, like_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sorted_definitions(defs):</span>
<span class="gi">+    # Note: `or &#39;&#39;` below is required because `module_path` could be</span>
<span class="gi">+    return sorted(defs, key=lambda x: (str(x.module_path or &#39;&#39;),</span>
<span class="gi">+                                       x.line or 0,</span>
<span class="gi">+                                       x.column or 0,</span>
<span class="gi">+                                       x.name))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_on_completion_name(module_node, lines, position):</span>
<span class="gi">+    leaf = module_node.get_leaf_for_position(position)</span>
<span class="gi">+    if leaf is None or leaf.type in (&#39;string&#39;, &#39;error_leaf&#39;):</span>
<span class="gi">+        # Completions inside strings are a bit special, we need to parse the</span>
<span class="gi">+        # string. The same is true for comments and error_leafs.</span>
<span class="gi">+        line = lines[position[0] - 1]</span>
<span class="gi">+        # The first step of completions is to get the name</span>
<span class="gi">+        return re.search(r&#39;(?!\d)\w+$|$&#39;, line[:position[1]]).group(0)</span>
<span class="gi">+    elif leaf.type not in (&#39;name&#39;, &#39;keyword&#39;):</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return leaf.value[:position[1] - leaf.start_pos[1]]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_code(code_lines, start_pos, end_pos):</span>
<span class="gi">+    # Get relevant lines.</span>
<span class="gi">+    lines = code_lines[start_pos[0] - 1:end_pos[0]]</span>
<span class="gi">+    # Remove the parts at the end of the line.</span>
<span class="gi">+    lines[-1] = lines[-1][:end_pos[1]]</span>
<span class="gi">+    # Remove first line indentation.</span>
<span class="gi">+    lines[0] = lines[0][start_pos[1]:]</span>
<span class="gi">+    return &#39;&#39;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class OnErrorLeaf(Exception):
<span class="gd">-    pass</span>
<span class="gi">+    @property</span>
<span class="gi">+    def error_leaf(self):</span>
<span class="gi">+        return self.args[0]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_code_for_stack(code_lines, leaf, position):</span>
<span class="gi">+    # It might happen that we&#39;re on whitespace or on a comment. This means</span>
<span class="gi">+    # that we would not get the right leaf.</span>
<span class="gi">+    if leaf.start_pos &gt;= position:</span>
<span class="gi">+        # If we&#39;re not on a comment simply get the previous leaf and proceed.</span>
<span class="gi">+        leaf = leaf.get_previous_leaf()</span>
<span class="gi">+        if leaf is None:</span>
<span class="gi">+            return &#39;&#39;  # At the beginning of the file.</span>
<span class="gi">+</span>
<span class="gi">+    is_after_newline = leaf.type == &#39;newline&#39;</span>
<span class="gi">+    while leaf.type == &#39;newline&#39;:</span>
<span class="gi">+        leaf = leaf.get_previous_leaf()</span>
<span class="gi">+        if leaf is None:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if leaf.type == &#39;error_leaf&#39; or leaf.type == &#39;string&#39;:</span>
<span class="gi">+        if leaf.start_pos[0] &lt; position[0]:</span>
<span class="gi">+            # On a different line, we just begin anew.</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Error leafs cannot be parsed, completion in strings is also</span>
<span class="gi">+        # impossible.</span>
<span class="gi">+        raise OnErrorLeaf(leaf)</span>
<span class="gi">+    else:</span>
<span class="gi">+        user_stmt = leaf</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if user_stmt.parent.type in (&#39;file_input&#39;, &#39;suite&#39;, &#39;simple_stmt&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+            user_stmt = user_stmt.parent</span>
<span class="gi">+</span>
<span class="gi">+        if is_after_newline:</span>
<span class="gi">+            if user_stmt.start_pos[1] &gt; position[1]:</span>
<span class="gi">+                # This means that it&#39;s actually a dedent and that means that we</span>
<span class="gi">+                # start without value (part of a suite).</span>
<span class="gi">+                return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # This is basically getting the relevant lines.</span>
<span class="gi">+        return _get_code(code_lines, user_stmt.get_start_pos_of_prefix(), position)</span>


<span class="w"> </span>def get_stack_at_position(grammar, code_lines, leaf, pos):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the possible node names (e.g. import_from, xor_test or yield_stmt).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    class EndMarkerReached(Exception):</span>
<span class="gi">+        pass</span>

<span class="gi">+    def tokenize_without_endmarker(code):</span>
<span class="gi">+        # TODO This is for now not an official parso API that exists purely</span>
<span class="gi">+        #   for Jedi.</span>
<span class="gi">+        tokens = grammar._tokenize(code)</span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            if token.string == safeword:</span>
<span class="gi">+                raise EndMarkerReached()</span>
<span class="gi">+            elif token.prefix.endswith(safeword):</span>
<span class="gi">+                # This happens with comments.</span>
<span class="gi">+                raise EndMarkerReached()</span>
<span class="gi">+            elif token.string.endswith(safeword):</span>
<span class="gi">+                yield token  # Probably an f-string literal that was not finished.</span>
<span class="gi">+                raise EndMarkerReached()</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield token</span>

<span class="gd">-class CallDetails:</span>
<span class="gi">+    # The code might be indedented, just remove it.</span>
<span class="gi">+    code = dedent(_get_code_for_stack(code_lines, leaf, pos))</span>
<span class="gi">+    # We use a word to tell Jedi when we have reached the start of the</span>
<span class="gi">+    # completion.</span>
<span class="gi">+    # Use Z as a prefix because it&#39;s not part of a number suffix.</span>
<span class="gi">+    safeword = &#39;ZZZ_USER_WANTS_TO_COMPLETE_HERE_WITH_JEDI&#39;</span>
<span class="gi">+    code = code + &#39; &#39; + safeword</span>
<span class="gi">+</span>
<span class="gi">+    p = Parser(grammar._pgen_grammar, error_recovery=True)</span>
<span class="gi">+    try:</span>
<span class="gi">+        p.parse(tokens=tokenize_without_endmarker(code))</span>
<span class="gi">+    except EndMarkerReached:</span>
<span class="gi">+        return p.stack</span>
<span class="gi">+    raise SystemError(</span>
<span class="gi">+        &quot;This really shouldn&#39;t happen. There&#39;s a bug in Jedi:\n%s&quot;</span>
<span class="gi">+        % list(tokenize_without_endmarker(code))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer(inference_state, context, leaf):</span>
<span class="gi">+    if leaf.type == &#39;name&#39;:</span>
<span class="gi">+        return inference_state.infer(context, leaf)</span>

<span class="gi">+    parent = leaf.parent</span>
<span class="gi">+    definitions = NO_VALUES</span>
<span class="gi">+    if parent.type == &#39;atom&#39;:</span>
<span class="gi">+        # e.g. `(a + b)`</span>
<span class="gi">+        definitions = context.infer_node(leaf.parent)</span>
<span class="gi">+    elif parent.type == &#39;trailer&#39;:</span>
<span class="gi">+        # e.g. `a()`</span>
<span class="gi">+        definitions = infer_call_of_leaf(context, leaf)</span>
<span class="gi">+    elif isinstance(leaf, tree.Literal):</span>
<span class="gi">+        # e.g. `&quot;foo&quot;` or `1.0`</span>
<span class="gi">+        return infer_atom(context, leaf)</span>
<span class="gi">+    elif leaf.type in (&#39;fstring_string&#39;, &#39;fstring_start&#39;, &#39;fstring_end&#39;):</span>
<span class="gi">+        return get_string_value_set(inference_state)</span>
<span class="gi">+    return definitions</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_follow_imports(names, follow_builtin_imports=False):</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        if name.is_import():</span>
<span class="gi">+            new_names = list(filter_follow_imports(</span>
<span class="gi">+                name.goto(),</span>
<span class="gi">+                follow_builtin_imports=follow_builtin_imports,</span>
<span class="gi">+            ))</span>
<span class="gi">+            found_builtin = False</span>
<span class="gi">+            if follow_builtin_imports:</span>
<span class="gi">+                for new_name in new_names:</span>
<span class="gi">+                    if new_name.start_pos is None:</span>
<span class="gi">+                        found_builtin = True</span>
<span class="gi">+</span>
<span class="gi">+            if found_builtin:</span>
<span class="gi">+                yield name</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield from new_names</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class CallDetails:</span>
<span class="w"> </span>    def __init__(self, bracket_leaf, children, position):
<span class="w"> </span>        self.bracket_leaf = bracket_leaf
<span class="w"> </span>        self._children = children
<span class="w"> </span>        self._position = position

<span class="gi">+    @property</span>
<span class="gi">+    def index(self):</span>
<span class="gi">+        return _get_index_and_key(self._children, self._position)[0]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def keyword_name_str(self):</span>
<span class="gi">+        return _get_index_and_key(self._children, self._position)[1]</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _list_arguments(self):</span>
<span class="gi">+        return list(_iter_arguments(self._children, self._position))</span>
<span class="gi">+</span>
<span class="gi">+    def calculate_index(self, param_names):</span>
<span class="gi">+        positional_count = 0</span>
<span class="gi">+        used_names = set()</span>
<span class="gi">+        star_count = -1</span>
<span class="gi">+        args = self._list_arguments()</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            if param_names:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        is_kwarg = False</span>
<span class="gi">+        for i, (star_count, key_start, had_equal) in enumerate(args):</span>
<span class="gi">+            is_kwarg |= had_equal | (star_count == 2)</span>
<span class="gi">+            if star_count:</span>
<span class="gi">+                pass  # For now do nothing, we don&#39;t know what&#39;s in there here.</span>
<span class="gi">+            else:</span>
<span class="gi">+                if i + 1 != len(args):  # Not last</span>
<span class="gi">+                    if had_equal:</span>
<span class="gi">+                        used_names.add(key_start)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        positional_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        for i, param_name in enumerate(param_names):</span>
<span class="gi">+            kind = param_name.get_kind()</span>
<span class="gi">+</span>
<span class="gi">+            if not is_kwarg:</span>
<span class="gi">+                if kind == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+                    return i</span>
<span class="gi">+                if kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.POSITIONAL_ONLY):</span>
<span class="gi">+                    if i == positional_count:</span>
<span class="gi">+                        return i</span>
<span class="gi">+</span>
<span class="gi">+            if key_start is not None and not star_count == 1 or star_count == 2:</span>
<span class="gi">+                if param_name.string_name not in used_names \</span>
<span class="gi">+                        and (kind == Parameter.KEYWORD_ONLY</span>
<span class="gi">+                             or kind == Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="gi">+                             and positional_count &lt;= i):</span>
<span class="gi">+                    if star_count:</span>
<span class="gi">+                        return i</span>
<span class="gi">+                    if had_equal:</span>
<span class="gi">+                        if param_name.string_name == key_start:</span>
<span class="gi">+                            return i</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if param_name.string_name.startswith(key_start):</span>
<span class="gi">+                            return i</span>
<span class="gi">+</span>
<span class="gi">+                if kind == Parameter.VAR_KEYWORD:</span>
<span class="gi">+                    return i</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def iter_used_keyword_arguments(self):</span>
<span class="gi">+        for star_count, key_start, had_equal in list(self._list_arguments()):</span>
<span class="gi">+            if had_equal and key_start:</span>
<span class="gi">+                yield key_start</span>
<span class="gi">+</span>
<span class="gi">+    def count_positional_arguments(self):</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        for star_count, key_start, had_equal in self._list_arguments()[:-1]:</span>
<span class="gi">+            if star_count or key_start:</span>
<span class="gi">+                break</span>
<span class="gi">+            count += 1</span>
<span class="gi">+        return count</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _iter_arguments(nodes, position):</span>
<span class="gi">+    def remove_after_pos(name):</span>
<span class="gi">+        if name.type != &#39;name&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return name.value[:position[1] - name.start_pos[1]]</span>
<span class="gi">+</span>
<span class="gi">+    # Returns Generator[Tuple[star_count, Optional[key_start: str], had_equal]]</span>
<span class="gi">+    nodes_before = [c for c in nodes if c.start_pos &lt; position]</span>
<span class="gi">+    if nodes_before[-1].type == &#39;arglist&#39;:</span>
<span class="gi">+        yield from _iter_arguments(nodes_before[-1].children, position)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    previous_node_yielded = False</span>
<span class="gi">+    stars_seen = 0</span>
<span class="gi">+    for i, node in enumerate(nodes_before):</span>
<span class="gi">+        if node.type == &#39;argument&#39;:</span>
<span class="gi">+            previous_node_yielded = True</span>
<span class="gi">+            first = node.children[0]</span>
<span class="gi">+            second = node.children[1]</span>
<span class="gi">+            if second == &#39;=&#39;:</span>
<span class="gi">+                if second.start_pos &lt; position and first.type == &#39;name&#39;:</span>
<span class="gi">+                    yield 0, first.value, True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield 0, remove_after_pos(first), False</span>
<span class="gi">+            elif first in (&#39;*&#39;, &#39;**&#39;):</span>
<span class="gi">+                yield len(first.value), remove_after_pos(second), False</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Must be a Comprehension</span>
<span class="gi">+                first_leaf = node.get_first_leaf()</span>
<span class="gi">+                if first_leaf.type == &#39;name&#39; and first_leaf.start_pos &gt;= position:</span>
<span class="gi">+                    yield 0, remove_after_pos(first_leaf), False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield 0, None, False</span>
<span class="gi">+            stars_seen = 0</span>
<span class="gi">+        elif node.type == &#39;testlist_star_expr&#39;:</span>
<span class="gi">+            for n in node.children[::2]:</span>
<span class="gi">+                if n.type == &#39;star_expr&#39;:</span>
<span class="gi">+                    stars_seen = 1</span>
<span class="gi">+                    n = n.children[1]</span>
<span class="gi">+                yield stars_seen, remove_after_pos(n), False</span>
<span class="gi">+                stars_seen = 0</span>
<span class="gi">+            # The count of children is even if there&#39;s a comma at the end.</span>
<span class="gi">+            previous_node_yielded = bool(len(node.children) % 2)</span>
<span class="gi">+        elif isinstance(node, tree.PythonLeaf) and node.value == &#39;,&#39;:</span>
<span class="gi">+            if not previous_node_yielded:</span>
<span class="gi">+                yield stars_seen, &#39;&#39;, False</span>
<span class="gi">+                stars_seen = 0</span>
<span class="gi">+            previous_node_yielded = False</span>
<span class="gi">+        elif isinstance(node, tree.PythonLeaf) and node.value in (&#39;*&#39;, &#39;**&#39;):</span>
<span class="gi">+            stars_seen = len(node.value)</span>
<span class="gi">+        elif node == &#39;=&#39; and nodes_before[-1]:</span>
<span class="gi">+            previous_node_yielded = True</span>
<span class="gi">+            before = nodes_before[i - 1]</span>
<span class="gi">+            if before.type == &#39;name&#39;:</span>
<span class="gi">+                yield 0, before.value, True</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield 0, None, False</span>
<span class="gi">+            # Just ignore the star that is probably a syntax error.</span>
<span class="gi">+            stars_seen = 0</span>
<span class="gi">+</span>
<span class="gi">+    if not previous_node_yielded:</span>
<span class="gi">+        if nodes_before[-1].type == &#39;name&#39;:</span>
<span class="gi">+            yield stars_seen, remove_after_pos(nodes_before[-1]), False</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield stars_seen, &#39;&#39;, False</span>
<span class="gi">+</span>

<span class="w"> </span>def _get_index_and_key(nodes, position):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the amount of commas and the keyword argument string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes_before = [c for c in nodes if c.start_pos &lt; position]</span>
<span class="gi">+    if nodes_before[-1].type == &#39;arglist&#39;:</span>
<span class="gi">+        return _get_index_and_key(nodes_before[-1].children, position)</span>
<span class="gi">+</span>
<span class="gi">+    key_str = None</span>
<span class="gi">+</span>
<span class="gi">+    last = nodes_before[-1]</span>
<span class="gi">+    if last.type == &#39;argument&#39; and last.children[1] == &#39;=&#39; \</span>
<span class="gi">+            and last.children[1].end_pos &lt;= position:</span>
<span class="gi">+        # Checked if the argument</span>
<span class="gi">+        key_str = last.children[0].value</span>
<span class="gi">+    elif last == &#39;=&#39;:</span>
<span class="gi">+        key_str = nodes_before[-2].value</span>
<span class="gi">+</span>
<span class="gi">+    return nodes_before.count(&#39;,&#39;), key_str</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_signature_details_from_error_node(node, additional_children, position):</span>
<span class="gi">+    for index, element in reversed(list(enumerate(node.children))):</span>
<span class="gi">+        # `index &gt; 0` means that it&#39;s a trailer and not an atom.</span>
<span class="gi">+        if element == &#39;(&#39; and element.end_pos &lt;= position and index &gt; 0:</span>
<span class="gi">+            # It&#39;s an error node, we don&#39;t want to match too much, just</span>
<span class="gi">+            # until the parentheses is enough.</span>
<span class="gi">+            children = node.children[index:]</span>
<span class="gi">+            name = element.get_previous_leaf()</span>
<span class="gi">+            if name is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if name.type == &#39;name&#39; or name.parent.type in (&#39;trailer&#39;, &#39;atom&#39;):</span>
<span class="gi">+                return CallDetails(element, children + additional_children, position)</span>
<span class="gi">+</span>

<span class="gi">+def get_signature_details(module, position):</span>
<span class="gi">+    leaf = module.get_leaf_for_position(position, include_prefixes=True)</span>
<span class="gi">+    # It&#39;s easier to deal with the previous token than the next one in this</span>
<span class="gi">+    # case.</span>
<span class="gi">+    if leaf.start_pos &gt;= position:</span>
<span class="gi">+        # Whitespace / comments after the leaf count towards the previous leaf.</span>
<span class="gi">+        leaf = leaf.get_previous_leaf()</span>
<span class="gi">+        if leaf is None:</span>
<span class="gi">+            return None</span>

<span class="gd">-@signature_time_cache(&#39;call_signatures_validity&#39;)</span>
<span class="gd">-def cache_signatures(inference_state, context, bracket_leaf, code_lines,</span>
<span class="gd">-    user_pos):</span>
<span class="gi">+    # Now that we know where we are in the syntax tree, we start to look at</span>
<span class="gi">+    # parents for possible function definitions.</span>
<span class="gi">+    node = leaf.parent</span>
<span class="gi">+    while node is not None:</span>
<span class="gi">+        if node.type in (&#39;funcdef&#39;, &#39;classdef&#39;, &#39;decorated&#39;, &#39;async_stmt&#39;):</span>
<span class="gi">+            # Don&#39;t show signatures if there&#39;s stuff before it that just</span>
<span class="gi">+            # makes it feel strange to have a signature.</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        additional_children = []</span>
<span class="gi">+        for n in reversed(node.children):</span>
<span class="gi">+            if n.start_pos &lt; position:</span>
<span class="gi">+                if n.type == &#39;error_node&#39;:</span>
<span class="gi">+                    result = _get_signature_details_from_error_node(</span>
<span class="gi">+                        n, additional_children, position</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if result is not None:</span>
<span class="gi">+                        return result</span>
<span class="gi">+</span>
<span class="gi">+                    additional_children[0:0] = n.children</span>
<span class="gi">+                    continue</span>
<span class="gi">+                additional_children.insert(0, n)</span>
<span class="gi">+</span>
<span class="gi">+        # Find a valid trailer</span>
<span class="gi">+        if node.type == &#39;trailer&#39; and node.children[0] == &#39;(&#39; \</span>
<span class="gi">+                or node.type == &#39;decorator&#39; and node.children[2] == &#39;(&#39;:</span>
<span class="gi">+            # Additionally we have to check that an ending parenthesis isn&#39;t</span>
<span class="gi">+            # interpreted wrong. There are two cases:</span>
<span class="gi">+            # 1. Cursor before paren -&gt; The current signature is good</span>
<span class="gi">+            # 2. Cursor after paren -&gt; We need to skip the current signature</span>
<span class="gi">+            if not (leaf is node.children[-1] and position &gt;= leaf.end_pos):</span>
<span class="gi">+                leaf = node.get_previous_leaf()</span>
<span class="gi">+                if leaf is None:</span>
<span class="gi">+                    return None</span>
<span class="gi">+                return CallDetails(</span>
<span class="gi">+                    node.children[0] if node.type == &#39;trailer&#39; else node.children[2],</span>
<span class="gi">+                    node.children,</span>
<span class="gi">+                    position</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@signature_time_cache(&quot;call_signatures_validity&quot;)</span>
<span class="gi">+def cache_signatures(inference_state, context, bracket_leaf, code_lines, user_pos):</span>
<span class="w"> </span>    &quot;&quot;&quot;This function calculates the cache key.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    line_index = user_pos[0] - 1</span>
<span class="gi">+</span>
<span class="gi">+    before_cursor = code_lines[line_index][:user_pos[1]]</span>
<span class="gi">+    other_lines = code_lines[bracket_leaf.start_pos[0]:line_index]</span>
<span class="gi">+    whole = &#39;&#39;.join(other_lines + [before_cursor])</span>
<span class="gi">+    before_bracket = re.match(r&#39;.*\(&#39;, whole, re.DOTALL)</span>
<span class="gi">+</span>
<span class="gi">+    module_path = context.get_root_context().py__file__()</span>
<span class="gi">+    if module_path is None:</span>
<span class="gi">+        yield None  # Don&#39;t cache!</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield (module_path, before_bracket, bracket_leaf.start_pos)</span>
<span class="gi">+    yield infer(</span>
<span class="gi">+        inference_state,</span>
<span class="gi">+        context,</span>
<span class="gi">+        bracket_leaf.get_previous_leaf(),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_line_column(func):</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def wrapper(self, line=None, column=None, *args, **kwargs):</span>
<span class="gi">+        line = max(len(self._code_lines), 1) if line is None else line</span>
<span class="gi">+        if not (0 &lt; line &lt;= len(self._code_lines)):</span>
<span class="gi">+            raise ValueError(&#39;`line` parameter is not in a valid range.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        line_string = self._code_lines[line - 1]</span>
<span class="gi">+        line_len = len(line_string)</span>
<span class="gi">+        if line_string.endswith(&#39;\r\n&#39;):</span>
<span class="gi">+            line_len -= 2</span>
<span class="gi">+        elif line_string.endswith(&#39;\n&#39;):</span>
<span class="gi">+            line_len -= 1</span>
<span class="gi">+</span>
<span class="gi">+        column = line_len if column is None else column</span>
<span class="gi">+        if not (0 &lt;= column &lt;= line_len):</span>
<span class="gi">+            raise ValueError(&#39;`column` parameter (%d) is not in a valid range &#39;</span>
<span class="gi">+                             &#39;(0-%d) for line %d (%r).&#39; % (</span>
<span class="gi">+                                 column, line_len, line, line_string))</span>
<span class="gi">+        return func(self, line, column, *args, **kwargs)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def get_module_names(module, all_scopes, definitions=True, references=False):
<span class="gu">@@ -56,4 +493,30 @@ def get_module_names(module, all_scopes, definitions=True, references=False):</span>
<span class="w"> </span>    Returns a dictionary with name parts as keys and their call paths as
<span class="w"> </span>    values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def def_ref_filter(name):</span>
<span class="gi">+        is_def = name.is_definition()</span>
<span class="gi">+        return definitions and is_def or references and not is_def</span>
<span class="gi">+</span>
<span class="gi">+    names = list(chain.from_iterable(module.get_used_names().values()))</span>
<span class="gi">+    if not all_scopes:</span>
<span class="gi">+        # We have to filter all the names that don&#39;t have the module as a</span>
<span class="gi">+        # parent_scope. There&#39;s None as a parent, because nodes in the module</span>
<span class="gi">+        # node have the parent module and not suite as all the others.</span>
<span class="gi">+        # Therefore it&#39;s important to catch that case.</span>
<span class="gi">+</span>
<span class="gi">+        def is_module_scope_name(name):</span>
<span class="gi">+            parent_scope = get_parent_scope(name)</span>
<span class="gi">+            # async functions have an extra wrapper. Strip it.</span>
<span class="gi">+            if parent_scope and parent_scope.type == &#39;async_stmt&#39;:</span>
<span class="gi">+                parent_scope = parent_scope.parent</span>
<span class="gi">+            return parent_scope in (module, None)</span>
<span class="gi">+</span>
<span class="gi">+        names = [n for n in names if is_module_scope_name(n)]</span>
<span class="gi">+    return filter(def_ref_filter, names)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def split_search_string(name):</span>
<span class="gi">+    type, _, dotted_names = name.rpartition(&#39; &#39;)</span>
<span class="gi">+    if type == &#39;def&#39;:</span>
<span class="gi">+        type = &#39;function&#39;</span>
<span class="gi">+    return type, dotted_names.split(&#39;.&#39;)</span>
<span class="gh">diff --git a/jedi/api/interpreter.py b/jedi/api/interpreter.py</span>
<span class="gh">index 7271aaec..befafe5a 100644</span>
<span class="gd">--- a/jedi/api/interpreter.py</span>
<span class="gi">+++ b/jedi/api/interpreter.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>TODO Some parts of this module are still not well documented.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference import compiled
<span class="w"> </span>from jedi.inference.base_value import ValueSet
<span class="w"> </span>from jedi.inference.filters import ParserTreeFilter, MergedFilter
<span class="gu">@@ -10,21 +11,34 @@ from jedi.inference.compiled.access import create_access_path</span>
<span class="w"> </span>from jedi.inference.context import ModuleContext


<span class="gd">-class NamespaceObject:</span>
<span class="gi">+def _create(inference_state, obj):</span>
<span class="gi">+    return compiled.create_from_access_path(</span>
<span class="gi">+        inference_state, create_access_path(inference_state, obj)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="gi">+class NamespaceObject:</span>
<span class="w"> </span>    def __init__(self, dct):
<span class="w"> </span>        self.__dict__ = dct


<span class="w"> </span>class MixedTreeName(TreeNameDefinition):
<span class="gd">-</span>
<span class="w"> </span>    def infer(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        In IPython notebook it is typical that some parts of the code that is
<span class="w"> </span>        provided was already executed. In that case if something is not properly
<span class="w"> </span>        inferred, it should still infer from the variables it already knows.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = super().infer()</span>
<span class="gi">+        if not inferred:</span>
<span class="gi">+            for compiled_value in self.parent_context.mixed_values:</span>
<span class="gi">+                for f in compiled_value.get_filters():</span>
<span class="gi">+                    values = ValueSet.from_sets(</span>
<span class="gi">+                        n.infer() for n in f.get(self.string_name)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if values:</span>
<span class="gi">+                        return values</span>
<span class="gi">+        return inferred</span>


<span class="w"> </span>class MixedParserTreeFilter(ParserTreeFilter):
<span class="gu">@@ -32,8 +46,29 @@ class MixedParserTreeFilter(ParserTreeFilter):</span>


<span class="w"> </span>class MixedModuleContext(ModuleContext):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, tree_module_value, namespaces):
<span class="w"> </span>        super().__init__(tree_module_value)
<span class="gd">-        self.mixed_values = [self._get_mixed_object(_create(self.</span>
<span class="gd">-            inference_state, NamespaceObject(n))) for n in namespaces]</span>
<span class="gi">+        self.mixed_values = [</span>
<span class="gi">+            self._get_mixed_object(</span>
<span class="gi">+                _create(self.inference_state, NamespaceObject(n))</span>
<span class="gi">+            ) for n in namespaces</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_mixed_object(self, compiled_value):</span>
<span class="gi">+        return mixed.MixedObject(</span>
<span class="gi">+            compiled_value=compiled_value,</span>
<span class="gi">+            tree_value=self._value</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield MergedFilter(</span>
<span class="gi">+            MixedParserTreeFilter(</span>
<span class="gi">+                parent_context=self,</span>
<span class="gi">+                until_position=until_position,</span>
<span class="gi">+                origin_scope=origin_scope</span>
<span class="gi">+            ),</span>
<span class="gi">+            self.get_global_filter(),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for mixed_object in self.mixed_values:</span>
<span class="gi">+            yield from mixed_object.get_filters(until_position, origin_scope)</span>
<span class="gh">diff --git a/jedi/api/keywords.py b/jedi/api/keywords.py</span>
<span class="gh">index 6a6e99e2..80ff13c3 100644</span>
<span class="gd">--- a/jedi/api/keywords.py</span>
<span class="gi">+++ b/jedi/api/keywords.py</span>
<span class="gu">@@ -1,21 +1,51 @@</span>
<span class="w"> </span>import pydoc
<span class="w"> </span>from contextlib import suppress
<span class="w"> </span>from typing import Dict, Optional
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.names import AbstractArbitraryName
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from pydoc_data import topics
<span class="w"> </span>    pydoc_topics: Optional[Dict[str, str]] = topics.topics
<span class="w"> </span>except ImportError:
<span class="gi">+    # Python 3.6.8 embeddable does not have pydoc_data.</span>
<span class="w"> </span>    pydoc_topics = None


<span class="w"> </span>class KeywordName(AbstractArbitraryName):
<span class="w"> </span>    api_type = &#39;keyword&#39;

<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return imitate_pydoc(self.string_name)</span>
<span class="gi">+</span>

<span class="w"> </span>def imitate_pydoc(string):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    It&#39;s not possible to get the pydoc&#39;s without starting the annoying pager
<span class="w"> </span>    stuff.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pydoc_topics is None:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    h = pydoc.help</span>
<span class="gi">+    with suppress(KeyError):</span>
<span class="gi">+        # try to access symbols</span>
<span class="gi">+        string = h.symbols[string]</span>
<span class="gi">+        string, _, related = string.partition(&#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_target(s):</span>
<span class="gi">+        return h.topics.get(s, h.keywords.get(s))</span>
<span class="gi">+</span>
<span class="gi">+    while isinstance(string, str):</span>
<span class="gi">+        string = get_target(string)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # is a tuple now</span>
<span class="gi">+        label, related = string</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return pydoc_topics[label].strip() if pydoc_topics else &#39;&#39;</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gh">diff --git a/jedi/api/project.py b/jedi/api/project.py</span>
<span class="gh">index d5ae11bb..8927e7ea 100644</span>
<span class="gd">--- a/jedi/api/project.py</span>
<span class="gi">+++ b/jedi/api/project.py</span>
<span class="gu">@@ -10,22 +10,52 @@ be used across repositories.</span>
<span class="w"> </span>import json
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.api.environment import get_cached_default_environment, create_environment
<span class="w"> </span>from jedi.api.exceptions import WrongVersion
<span class="w"> </span>from jedi.api.completion import search_in_module
<span class="w"> </span>from jedi.api.helpers import split_search_string, get_module_names
<span class="gd">-from jedi.inference.imports import load_module_from_path, load_namespace_from_path, iter_module_names</span>
<span class="gi">+from jedi.inference.imports import load_module_from_path, \</span>
<span class="gi">+    load_namespace_from_path, iter_module_names</span>
<span class="w"> </span>from jedi.inference.sys_path import discover_buildout_paths
<span class="w"> </span>from jedi.inference.cache import inference_state_as_method_param_cache
<span class="w"> </span>from jedi.inference.references import recurse_find_python_folders_and_files, search_in_file_ios
<span class="w"> </span>from jedi.file_io import FolderIO
<span class="gi">+</span>
<span class="w"> </span>_CONFIG_FOLDER = &#39;.jedi&#39;
<span class="gd">-_CONTAINS_POTENTIAL_PROJECT = (&#39;setup.py&#39;, &#39;.git&#39;, &#39;.hg&#39;,</span>
<span class="gd">-    &#39;requirements.txt&#39;, &#39;MANIFEST.in&#39;, &#39;pyproject.toml&#39;)</span>
<span class="gi">+_CONTAINS_POTENTIAL_PROJECT = \</span>
<span class="gi">+    &#39;setup.py&#39;, &#39;.git&#39;, &#39;.hg&#39;, &#39;requirements.txt&#39;, &#39;MANIFEST.in&#39;, &#39;pyproject.toml&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>_SERIALIZER_VERSION = 1


<span class="gi">+def _try_to_skip_duplicates(func):</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        found_tree_nodes = []</span>
<span class="gi">+        found_modules = []</span>
<span class="gi">+        for definition in func(*args, **kwargs):</span>
<span class="gi">+            tree_node = definition._name.tree_name</span>
<span class="gi">+            if tree_node is not None and tree_node in found_tree_nodes:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if definition.type == &#39;module&#39; and definition.module_path is not None:</span>
<span class="gi">+                if definition.module_path in found_modules:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                found_modules.append(definition.module_path)</span>
<span class="gi">+            yield definition</span>
<span class="gi">+            found_tree_nodes.append(tree_node)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_duplicates_from_path(path):</span>
<span class="gi">+    used = set()</span>
<span class="gi">+    for p in path:</span>
<span class="gi">+        if p in used:</span>
<span class="gi">+            continue</span>
<span class="gi">+        used.add(p)</span>
<span class="gi">+        yield p</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Project:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Projects are a simple way to manage Python folders and define how Jedi does
<span class="gu">@@ -34,6 +64,14 @@ class Project:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    _environment = None

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_config_folder_path(base_path):</span>
<span class="gi">+        return base_path.joinpath(_CONFIG_FOLDER)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_json_path(base_path):</span>
<span class="gi">+        return Project._get_config_folder_path(base_path).joinpath(&#39;project.json&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def load(cls, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -42,17 +80,42 @@ class Project:</span>

<span class="w"> </span>        :param path: The path of the directory you want to use as a project.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(path, str):</span>
<span class="gi">+            path = Path(path)</span>
<span class="gi">+        with open(cls._get_json_path(path)) as f:</span>
<span class="gi">+            version, data = json.load(f)</span>
<span class="gi">+</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return cls(**data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise WrongVersion(</span>
<span class="gi">+                &quot;The Jedi version of this project seems newer than what we can handle.&quot;</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def save(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Saves the project configuration in the project in ``.jedi/project.json``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = dict(self.__dict__)</span>
<span class="gi">+        data.pop(&#39;_environment&#39;, None)</span>
<span class="gi">+        data.pop(&#39;_django&#39;, None)  # TODO make django setting public?</span>
<span class="gi">+        data = {k.lstrip(&#39;_&#39;): v for k, v in data.items()}</span>
<span class="gi">+        data[&#39;path&#39;] = str(data[&#39;path&#39;])</span>

<span class="gd">-    def __init__(self, path, *, environment_path=None,</span>
<span class="gd">-        load_unsafe_extensions=False, sys_path=None, added_sys_path=(),</span>
<span class="gd">-        smart_sys_path=True) -&gt;None:</span>
<span class="gi">+        self._get_config_folder_path(self._path).mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+        with open(self._get_json_path(self._path), &#39;w&#39;) as f:</span>
<span class="gi">+            return json.dump((_SERIALIZER_VERSION, data), f)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        *,</span>
<span class="gi">+        environment_path=None,</span>
<span class="gi">+        load_unsafe_extensions=False,</span>
<span class="gi">+        sys_path=None,</span>
<span class="gi">+        added_sys_path=(),</span>
<span class="gi">+        smart_sys_path=True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param path: The base path for this project.
<span class="w"> </span>        :param environment_path: The Python executable path, typically the path
<span class="gu">@@ -71,16 +134,20 @@ class Project:</span>
<span class="w"> </span>            local directories. Otherwise you will have to rely on your packages
<span class="w"> </span>            being properly configured on the ``sys.path``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(path, str):
<span class="w"> </span>            path = Path(path).absolute()
<span class="w"> </span>        self._path = path
<span class="gi">+</span>
<span class="w"> </span>        self._environment_path = environment_path
<span class="w"> </span>        if sys_path is not None:
<span class="gi">+            # Remap potential pathlib.Path entries</span>
<span class="w"> </span>            sys_path = list(map(str, sys_path))
<span class="w"> </span>        self._sys_path = sys_path
<span class="w"> </span>        self._smart_sys_path = smart_sys_path
<span class="w"> </span>        self._load_unsafe_extensions = load_unsafe_extensions
<span class="w"> </span>        self._django = False
<span class="gi">+        # Remap potential pathlib.Path entries</span>
<span class="w"> </span>        self.added_sys_path = list(map(str, added_sys_path))
<span class="w"> </span>        &quot;&quot;&quot;The sys path that is going to be added at the end of the &quot;&quot;&quot;

<span class="gu">@@ -89,7 +156,7 @@ class Project:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The base path for this project.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._path</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def sys_path(self):
<span class="gu">@@ -97,7 +164,7 @@ class Project:</span>
<span class="w"> </span>        The sys path provided to this project. This can be None and in that
<span class="w"> </span>        case will be auto generated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._sys_path</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def smart_sys_path(self):
<span class="gu">@@ -105,23 +172,80 @@ class Project:</span>
<span class="w"> </span>        If the sys path is going to be calculated in a smart way, where
<span class="w"> </span>        additional paths are added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._smart_sys_path</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def load_unsafe_extensions(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wheter the project loads unsafe extensions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._load_unsafe_extensions</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_as_method_param_cache()</span>
<span class="gi">+    def _get_base_sys_path(self, inference_state):</span>
<span class="gi">+        # The sys path has not been set explicitly.</span>
<span class="gi">+        sys_path = list(inference_state.environment.get_sys_path())</span>
<span class="gi">+        try:</span>
<span class="gi">+            sys_path.remove(&#39;&#39;)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return sys_path</span>

<span class="w"> </span>    @inference_state_as_method_param_cache()
<span class="gd">-    def _get_sys_path(self, inference_state, add_parent_paths=True,</span>
<span class="gd">-        add_init_paths=False):</span>
<span class="gi">+    def _get_sys_path(self, inference_state, add_parent_paths=True, add_init_paths=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Keep this method private for all users of jedi. However internally this
<span class="w"> </span>        one is used like a public method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        suffixed = list(self.added_sys_path)</span>
<span class="gi">+        prefixed = []</span>
<span class="gi">+</span>
<span class="gi">+        if self._sys_path is None:</span>
<span class="gi">+            sys_path = list(self._get_base_sys_path(inference_state))</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys_path = list(self._sys_path)</span>
<span class="gi">+</span>
<span class="gi">+        if self._smart_sys_path:</span>
<span class="gi">+            prefixed.append(str(self._path))</span>
<span class="gi">+</span>
<span class="gi">+            if inference_state.script_path is not None:</span>
<span class="gi">+                suffixed += map(str, discover_buildout_paths(</span>
<span class="gi">+                    inference_state,</span>
<span class="gi">+                    inference_state.script_path</span>
<span class="gi">+                ))</span>
<span class="gi">+</span>
<span class="gi">+                if add_parent_paths:</span>
<span class="gi">+                    # Collect directories in upward search by:</span>
<span class="gi">+                    #   1. Skipping directories with __init__.py</span>
<span class="gi">+                    #   2. Stopping immediately when above self._path</span>
<span class="gi">+                    traversed = []</span>
<span class="gi">+                    for parent_path in inference_state.script_path.parents:</span>
<span class="gi">+                        if parent_path == self._path \</span>
<span class="gi">+                                or self._path not in parent_path.parents:</span>
<span class="gi">+                            break</span>
<span class="gi">+                        if not add_init_paths \</span>
<span class="gi">+                                and parent_path.joinpath(&quot;__init__.py&quot;).is_file():</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        traversed.append(str(parent_path))</span>
<span class="gi">+</span>
<span class="gi">+                    # AFAIK some libraries have imports like `foo.foo.bar`, which</span>
<span class="gi">+                    # leads to the conclusion to by default prefer longer paths</span>
<span class="gi">+                    # rather than shorter ones by default.</span>
<span class="gi">+                    suffixed += reversed(traversed)</span>
<span class="gi">+</span>
<span class="gi">+        if self._django:</span>
<span class="gi">+            prefixed.append(str(self._path))</span>
<span class="gi">+</span>
<span class="gi">+        path = prefixed + sys_path + suffixed</span>
<span class="gi">+        return list(_remove_duplicates_from_path(path))</span>
<span class="gi">+</span>
<span class="gi">+    def get_environment(self):</span>
<span class="gi">+        if self._environment is None:</span>
<span class="gi">+            if self._environment_path is not None:</span>
<span class="gi">+                self._environment = create_environment(self._environment_path, safe=False)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._environment = get_cached_default_environment()</span>
<span class="gi">+        return self._environment</span>

<span class="w"> </span>    def search(self, string, *, all_scopes=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,7 +268,7 @@ class Project:</span>
<span class="w"> </span>            functions and classes.
<span class="w"> </span>        :yields: :class:`.Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._search_func(string, all_scopes=all_scopes)</span>

<span class="w"> </span>    def complete_search(self, string, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -156,15 +280,113 @@ class Project:</span>
<span class="w"> </span>            functions and classes.
<span class="w"> </span>        :yields: :class:`.Completion`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._search_func(string, complete=True, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @_try_to_skip_duplicates</span>
<span class="gi">+    def _search_func(self, string, complete=False, all_scopes=False):</span>
<span class="gi">+        # Using a Script is they easiest way to get an empty module context.</span>
<span class="gi">+        from jedi import Script</span>
<span class="gi">+        s = Script(&#39;&#39;, project=self)</span>
<span class="gi">+        inference_state = s._inference_state</span>
<span class="gi">+        empty_module_context = s._get_module_context()</span>
<span class="gi">+</span>
<span class="gi">+        debug.dbg(&#39;Search for string %s, complete=%s&#39;, string, complete)</span>
<span class="gi">+        wanted_type, wanted_names = split_search_string(string)</span>
<span class="gi">+        name = wanted_names[0]</span>
<span class="gi">+        stub_folder_name = name + &#39;-stubs&#39;</span>
<span class="gi">+</span>
<span class="gi">+        ios = recurse_find_python_folders_and_files(FolderIO(str(self._path)))</span>
<span class="gi">+        file_ios = []</span>
<span class="gi">+</span>
<span class="gi">+        # 1. Search for modules in the current project</span>
<span class="gi">+        for folder_io, file_io in ios:</span>
<span class="gi">+            if file_io is None:</span>
<span class="gi">+                file_name = folder_io.get_base_name()</span>
<span class="gi">+                if file_name == name or file_name == stub_folder_name:</span>
<span class="gi">+                    f = folder_io.get_file_io(&#39;__init__.py&#39;)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        m = load_module_from_path(inference_state, f).as_context()</span>
<span class="gi">+                    except FileNotFoundError:</span>
<span class="gi">+                        f = folder_io.get_file_io(&#39;__init__.pyi&#39;)</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            m = load_module_from_path(inference_state, f).as_context()</span>
<span class="gi">+                        except FileNotFoundError:</span>
<span class="gi">+                            m = load_namespace_from_path(inference_state, folder_io).as_context()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                file_ios.append(file_io)</span>
<span class="gi">+                if Path(file_io.path).name in (name + &#39;.py&#39;, name + &#39;.pyi&#39;):</span>
<span class="gi">+                    m = load_module_from_path(inference_state, file_io).as_context()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            debug.dbg(&#39;Search of a specific module %s&#39;, m)</span>
<span class="gi">+            yield from search_in_module(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                m,</span>
<span class="gi">+                names=[m.name],</span>
<span class="gi">+                wanted_type=wanted_type,</span>
<span class="gi">+                wanted_names=wanted_names,</span>
<span class="gi">+                complete=complete,</span>
<span class="gi">+                convert=True,</span>
<span class="gi">+                ignore_imports=True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # 2. Search for identifiers in the project.</span>
<span class="gi">+        for module_context in search_in_file_ios(inference_state, file_ios,</span>
<span class="gi">+                                                 name, complete=complete):</span>
<span class="gi">+            names = get_module_names(module_context.tree_node, all_scopes=all_scopes)</span>
<span class="gi">+            names = [module_context.create_name(n) for n in names]</span>
<span class="gi">+            names = _remove_imports(names)</span>
<span class="gi">+            yield from search_in_module(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                module_context,</span>
<span class="gi">+                names=names,</span>
<span class="gi">+                wanted_type=wanted_type,</span>
<span class="gi">+                wanted_names=wanted_names,</span>
<span class="gi">+                complete=complete,</span>
<span class="gi">+                ignore_imports=True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # 3. Search for modules on sys.path</span>
<span class="gi">+        sys_path = [</span>
<span class="gi">+            p for p in self._get_sys_path(inference_state)</span>
<span class="gi">+            # Exclude the current folder which is handled by recursing the folders.</span>
<span class="gi">+            if p != self._path</span>
<span class="gi">+        ]</span>
<span class="gi">+        names = list(iter_module_names(inference_state, empty_module_context, sys_path))</span>
<span class="gi">+        yield from search_in_module(</span>
<span class="gi">+            inference_state,</span>
<span class="gi">+            empty_module_context,</span>
<span class="gi">+            names=names,</span>
<span class="gi">+            wanted_type=wanted_type,</span>
<span class="gi">+            wanted_names=wanted_names,</span>
<span class="gi">+            complete=complete,</span>
<span class="gi">+            convert=True,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._path)


<span class="gi">+def _is_potential_project(path):</span>
<span class="gi">+    for name in _CONTAINS_POTENTIAL_PROJECT:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if path.joinpath(name).exists():</span>
<span class="gi">+                return True</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def _is_django_path(directory):
<span class="w"> </span>    &quot;&quot;&quot; Detects the path of the very well known Django library (if used) &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        with open(directory.joinpath(&#39;manage.py&#39;), &#39;rb&#39;) as f:</span>
<span class="gi">+            return b&quot;DJANGO_SETTINGS_MODULE&quot; in f.read()</span>
<span class="gi">+    except (FileNotFoundError, IsADirectoryError, PermissionError):</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def get_default_project(path=None):
<span class="gu">@@ -177,4 +399,50 @@ def get_default_project(path=None):</span>
<span class="w"> </span>    2. One of the following files: ``setup.py``, ``.git``, ``.hg``,
<span class="w"> </span>       ``requirements.txt`` and ``MANIFEST.in``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        path = Path.cwd()</span>
<span class="gi">+    elif isinstance(path, str):</span>
<span class="gi">+        path = Path(path)</span>
<span class="gi">+</span>
<span class="gi">+    check = path.absolute()</span>
<span class="gi">+    probable_path = None</span>
<span class="gi">+    first_no_init_file = None</span>
<span class="gi">+    for dir in chain([check], check.parents):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return Project.load(dir)</span>
<span class="gi">+        except (FileNotFoundError, IsADirectoryError, PermissionError):</span>
<span class="gi">+            pass</span>
<span class="gi">+        except NotADirectoryError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if first_no_init_file is None:</span>
<span class="gi">+            if dir.joinpath(&#39;__init__.py&#39;).exists():</span>
<span class="gi">+                # In the case that a __init__.py exists, it&#39;s in 99% just a</span>
<span class="gi">+                # Python package and the project sits at least one level above.</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif not dir.is_file():</span>
<span class="gi">+                first_no_init_file = dir</span>
<span class="gi">+</span>
<span class="gi">+        if _is_django_path(dir):</span>
<span class="gi">+            project = Project(dir)</span>
<span class="gi">+            project._django = True</span>
<span class="gi">+            return project</span>
<span class="gi">+</span>
<span class="gi">+        if probable_path is None and _is_potential_project(dir):</span>
<span class="gi">+            probable_path = dir</span>
<span class="gi">+</span>
<span class="gi">+    if probable_path is not None:</span>
<span class="gi">+        return Project(probable_path)</span>
<span class="gi">+</span>
<span class="gi">+    if first_no_init_file is not None:</span>
<span class="gi">+        return Project(first_no_init_file)</span>
<span class="gi">+</span>
<span class="gi">+    curdir = path if path.is_dir() else path.parent</span>
<span class="gi">+    return Project(curdir)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_imports(names):</span>
<span class="gi">+    return [</span>
<span class="gi">+        n for n in names</span>
<span class="gi">+        if n.tree_name is None or n.api_type not in (&#39;module&#39;, &#39;namespace&#39;)</span>
<span class="gi">+    ]</span>
<span class="gh">diff --git a/jedi/api/refactoring/extract.py b/jedi/api/refactoring/extract.py</span>
<span class="gh">index 1cdeefac..6e7df7e1 100644</span>
<span class="gd">--- a/jedi/api/refactoring/extract.py</span>
<span class="gi">+++ b/jedi/api/refactoring/extract.py</span>
<span class="gu">@@ -1,21 +1,43 @@</span>
<span class="w"> </span>from textwrap import dedent
<span class="gi">+</span>
<span class="w"> </span>from parso import split_lines
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.api.exceptions import RefactoringError
<span class="w"> </span>from jedi.api.refactoring import Refactoring, EXPRESSION_PARTS
<span class="w"> </span>from jedi.common import indent_block
<span class="w"> </span>from jedi.parser_utils import function_is_classmethod, function_is_staticmethod
<span class="gd">-_DEFINITION_SCOPES = &#39;suite&#39;, &#39;file_input&#39;</span>
<span class="gd">-_VARIABLE_EXCTRACTABLE = (EXPRESSION_PARTS +</span>
<span class="gd">-    &#39;atom testlist_star_expr testlist test lambdef lambdef_nocond keyword name number string fstring&#39;</span>
<span class="gd">-    .split())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_DEFINITION_SCOPES = (&#39;suite&#39;, &#39;file_input&#39;)</span>
<span class="gi">+_VARIABLE_EXCTRACTABLE = EXPRESSION_PARTS + \</span>
<span class="gi">+    (&#39;atom testlist_star_expr testlist test lambdef lambdef_nocond &#39;</span>
<span class="gi">+     &#39;keyword name number string fstring&#39;).split()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_variable(inference_state, path, module_node, name, pos, until_pos):</span>
<span class="gi">+    nodes = _find_nodes(module_node, pos, until_pos)</span>
<span class="gi">+    debug.dbg(&#39;Extracting nodes: %s&#39;, nodes)</span>
<span class="gi">+</span>
<span class="gi">+    is_expression, message = _is_expression_with_error(nodes)</span>
<span class="gi">+    if not is_expression:</span>
<span class="gi">+        raise RefactoringError(message)</span>
<span class="gi">+</span>
<span class="gi">+    generated_code = name + &#39; = &#39; + _expression_nodes_to_string(nodes)</span>
<span class="gi">+    file_to_node_changes = {path: _replace(nodes, name, generated_code, pos)}</span>
<span class="gi">+    return Refactoring(inference_state, file_to_node_changes)</span>


<span class="w"> </span>def _is_expression_with_error(nodes):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a tuple (is_expression, error_string).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if any(node.type == &#39;name&#39; and node.is_definition() for node in nodes):</span>
<span class="gi">+        return False, &#39;Cannot extract a name that defines something&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if nodes[0].type not in _VARIABLE_EXCTRACTABLE:</span>
<span class="gi">+        return False, &#39;Cannot extract a &quot;%s&quot;&#39; % nodes[0].type</span>
<span class="gi">+    return True, &#39;&#39;</span>


<span class="w"> </span>def _find_nodes(module_node, pos, until_pos):
<span class="gu">@@ -23,7 +45,98 @@ def _find_nodes(module_node, pos, until_pos):</span>
<span class="w"> </span>    Looks up a module and tries to find the appropriate amount of nodes that
<span class="w"> </span>    are in there.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    start_node = module_node.get_leaf_for_position(pos, include_prefixes=True)</span>
<span class="gi">+</span>
<span class="gi">+    if until_pos is None:</span>
<span class="gi">+        if start_node.type == &#39;operator&#39;:</span>
<span class="gi">+            next_leaf = start_node.get_next_leaf()</span>
<span class="gi">+            if next_leaf is not None and next_leaf.start_pos == pos:</span>
<span class="gi">+                start_node = next_leaf</span>
<span class="gi">+</span>
<span class="gi">+        if _is_not_extractable_syntax(start_node):</span>
<span class="gi">+            start_node = start_node.parent</span>
<span class="gi">+</span>
<span class="gi">+        if start_node.parent.type == &#39;trailer&#39;:</span>
<span class="gi">+            start_node = start_node.parent.parent</span>
<span class="gi">+        while start_node.parent.type in EXPRESSION_PARTS:</span>
<span class="gi">+            start_node = start_node.parent</span>
<span class="gi">+</span>
<span class="gi">+        nodes = [start_node]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Get the next leaf if we are at the end of a leaf</span>
<span class="gi">+        if start_node.end_pos == pos:</span>
<span class="gi">+            next_leaf = start_node.get_next_leaf()</span>
<span class="gi">+            if next_leaf is not None:</span>
<span class="gi">+                start_node = next_leaf</span>
<span class="gi">+</span>
<span class="gi">+        # Some syntax is not exactable, just use its parent</span>
<span class="gi">+        if _is_not_extractable_syntax(start_node):</span>
<span class="gi">+            start_node = start_node.parent</span>
<span class="gi">+</span>
<span class="gi">+        # Find the end</span>
<span class="gi">+        end_leaf = module_node.get_leaf_for_position(until_pos, include_prefixes=True)</span>
<span class="gi">+        if end_leaf.start_pos &gt; until_pos:</span>
<span class="gi">+            end_leaf = end_leaf.get_previous_leaf()</span>
<span class="gi">+            if end_leaf is None:</span>
<span class="gi">+                raise RefactoringError(&#39;Cannot extract anything from that&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        parent_node = start_node</span>
<span class="gi">+        while parent_node.end_pos &lt; end_leaf.end_pos:</span>
<span class="gi">+            parent_node = parent_node.parent</span>
<span class="gi">+</span>
<span class="gi">+        nodes = _remove_unwanted_expression_nodes(parent_node, pos, until_pos)</span>
<span class="gi">+</span>
<span class="gi">+    # If the user marks just a return statement, we return the expression</span>
<span class="gi">+    # instead of the whole statement, because the user obviously wants to</span>
<span class="gi">+    # extract that part.</span>
<span class="gi">+    if len(nodes) == 1 and start_node.type in (&#39;return_stmt&#39;, &#39;yield_expr&#39;):</span>
<span class="gi">+        return [nodes[0].children[1]]</span>
<span class="gi">+    return nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _replace(nodes, expression_replacement, extracted, pos,</span>
<span class="gi">+             insert_before_leaf=None, remaining_prefix=None):</span>
<span class="gi">+    # Now try to replace the nodes found with a variable and move the code</span>
<span class="gi">+    # before the current statement.</span>
<span class="gi">+    definition = _get_parent_definition(nodes[0])</span>
<span class="gi">+    if insert_before_leaf is None:</span>
<span class="gi">+        insert_before_leaf = definition.get_first_leaf()</span>
<span class="gi">+    first_node_leaf = nodes[0].get_first_leaf()</span>
<span class="gi">+</span>
<span class="gi">+    lines = split_lines(insert_before_leaf.prefix, keepends=True)</span>
<span class="gi">+    if first_node_leaf is insert_before_leaf:</span>
<span class="gi">+        if remaining_prefix is not None:</span>
<span class="gi">+            # The remaining prefix has already been calculated.</span>
<span class="gi">+            lines[:-1] = remaining_prefix</span>
<span class="gi">+    lines[-1:-1] = [indent_block(extracted, lines[-1]) + &#39;\n&#39;]</span>
<span class="gi">+    extracted_prefix = &#39;&#39;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+    replacement_dct = {}</span>
<span class="gi">+    if first_node_leaf is insert_before_leaf:</span>
<span class="gi">+        replacement_dct[nodes[0]] = extracted_prefix + expression_replacement</span>
<span class="gi">+    else:</span>
<span class="gi">+        if remaining_prefix is None:</span>
<span class="gi">+            p = first_node_leaf.prefix</span>
<span class="gi">+        else:</span>
<span class="gi">+            p = remaining_prefix + _get_indentation(nodes[0])</span>
<span class="gi">+        replacement_dct[nodes[0]] = p + expression_replacement</span>
<span class="gi">+        replacement_dct[insert_before_leaf] = extracted_prefix + insert_before_leaf.value</span>
<span class="gi">+</span>
<span class="gi">+    for node in nodes[1:]:</span>
<span class="gi">+        replacement_dct[node] = &#39;&#39;</span>
<span class="gi">+    return replacement_dct</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _expression_nodes_to_string(nodes):</span>
<span class="gi">+    return &#39;&#39;.join(n.get_code(include_prefix=i != 0) for i, n in enumerate(nodes))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _suite_nodes_to_string(nodes, pos):</span>
<span class="gi">+    n = nodes[0]</span>
<span class="gi">+    prefix, part_of_code = _split_prefix_at(n.get_first_leaf(), pos[0] - 1)</span>
<span class="gi">+    code = part_of_code + n.get_code(include_prefix=False) \</span>
<span class="gi">+        + &#39;&#39;.join(n.get_code() for n in nodes[1:])</span>
<span class="gi">+    return prefix, code</span>


<span class="w"> </span>def _split_prefix_at(leaf, until_line):
<span class="gu">@@ -31,14 +144,25 @@ def _split_prefix_at(leaf, until_line):</span>
<span class="w"> </span>    Returns a tuple of the leaf&#39;s prefix, split at the until_line
<span class="w"> </span>    position.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # second means the second returned part</span>
<span class="gi">+    second_line_count = leaf.start_pos[0] - until_line</span>
<span class="gi">+    lines = split_lines(leaf.prefix, keepends=True)</span>
<span class="gi">+    return &#39;&#39;.join(lines[:-second_line_count]), &#39;&#39;.join(lines[-second_line_count:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_indentation(node):</span>
<span class="gi">+    return split_lines(node.get_first_leaf().prefix)[-1]</span>


<span class="w"> </span>def _get_parent_definition(node):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the statement where a node is defined.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while node is not None:</span>
<span class="gi">+        if node.parent.type in _DEFINITION_SCOPES:</span>
<span class="gi">+            return node</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    raise NotImplementedError(&#39;We should never even get here&#39;)</span>


<span class="w"> </span>def _remove_unwanted_expression_nodes(parent_node, pos, until_pos):
<span class="gu">@@ -46,13 +170,217 @@ def _remove_unwanted_expression_nodes(parent_node, pos, until_pos):</span>
<span class="w"> </span>    This function makes it so for `1 * 2 + 3` you can extract `2 + 3`, even
<span class="w"> </span>    though it is not part of the expression.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    typ = parent_node.type</span>
<span class="gi">+    is_suite_part = typ in (&#39;suite&#39;, &#39;file_input&#39;)</span>
<span class="gi">+    if typ in EXPRESSION_PARTS or is_suite_part:</span>
<span class="gi">+        nodes = parent_node.children</span>
<span class="gi">+        for i, n in enumerate(nodes):</span>
<span class="gi">+            if n.end_pos &gt; pos:</span>
<span class="gi">+                start_index = i</span>
<span class="gi">+                if n.type == &#39;operator&#39;:</span>
<span class="gi">+                    start_index -= 1</span>
<span class="gi">+                break</span>
<span class="gi">+        for i, n in reversed(list(enumerate(nodes))):</span>
<span class="gi">+            if n.start_pos &lt; until_pos:</span>
<span class="gi">+                end_index = i</span>
<span class="gi">+                if n.type == &#39;operator&#39;:</span>
<span class="gi">+                    end_index += 1</span>
<span class="gi">+</span>
<span class="gi">+                # Something like `not foo or bar` should not be cut after not</span>
<span class="gi">+                for n2 in nodes[i:]:</span>
<span class="gi">+                    if _is_not_extractable_syntax(n2):</span>
<span class="gi">+                        end_index += 1</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+                break</span>
<span class="gi">+        nodes = nodes[start_index:end_index + 1]</span>
<span class="gi">+        if not is_suite_part:</span>
<span class="gi">+            nodes[0:1] = _remove_unwanted_expression_nodes(nodes[0], pos, until_pos)</span>
<span class="gi">+            nodes[-1:] = _remove_unwanted_expression_nodes(nodes[-1], pos, until_pos)</span>
<span class="gi">+        return nodes</span>
<span class="gi">+    return [parent_node]</span>
<span class="gi">+</span>

<span class="gi">+def _is_not_extractable_syntax(node):</span>
<span class="gi">+    return node.type == &#39;operator&#39; \</span>
<span class="gi">+        or node.type == &#39;keyword&#39; and node.value not in (&#39;None&#39;, &#39;True&#39;, &#39;False&#39;)</span>

<span class="gd">-def _find_needed_output_variables(context, search_node, at_least_pos,</span>
<span class="gd">-    return_variables):</span>
<span class="gi">+</span>
<span class="gi">+def extract_function(inference_state, path, module_context, name, pos, until_pos):</span>
<span class="gi">+    nodes = _find_nodes(module_context.tree_node, pos, until_pos)</span>
<span class="gi">+    assert len(nodes)</span>
<span class="gi">+</span>
<span class="gi">+    is_expression, _ = _is_expression_with_error(nodes)</span>
<span class="gi">+    context = module_context.create_context(nodes[0])</span>
<span class="gi">+    is_bound_method = context.is_bound_method()</span>
<span class="gi">+    params, return_variables = list(_find_inputs_and_outputs(module_context, context, nodes))</span>
<span class="gi">+</span>
<span class="gi">+    # Find variables</span>
<span class="gi">+    # Is a class method / method</span>
<span class="gi">+    if context.is_module():</span>
<span class="gi">+        insert_before_leaf = None  # Leaf will be determined later</span>
<span class="gi">+    else:</span>
<span class="gi">+        node = _get_code_insertion_node(context.tree_node, is_bound_method)</span>
<span class="gi">+        insert_before_leaf = node.get_first_leaf()</span>
<span class="gi">+    if is_expression:</span>
<span class="gi">+        code_block = &#39;return &#39; + _expression_nodes_to_string(nodes) + &#39;\n&#39;</span>
<span class="gi">+        remaining_prefix = None</span>
<span class="gi">+        has_ending_return_stmt = False</span>
<span class="gi">+    else:</span>
<span class="gi">+        has_ending_return_stmt = _is_node_ending_return_stmt(nodes[-1])</span>
<span class="gi">+        if not has_ending_return_stmt:</span>
<span class="gi">+            # Find the actually used variables (of the defined ones). If none are</span>
<span class="gi">+            # used (e.g. if the range covers the whole function), return the last</span>
<span class="gi">+            # defined variable.</span>
<span class="gi">+            return_variables = list(_find_needed_output_variables(</span>
<span class="gi">+                context,</span>
<span class="gi">+                nodes[0].parent,</span>
<span class="gi">+                nodes[-1].end_pos,</span>
<span class="gi">+                return_variables</span>
<span class="gi">+            )) or [return_variables[-1]] if return_variables else []</span>
<span class="gi">+</span>
<span class="gi">+        remaining_prefix, code_block = _suite_nodes_to_string(nodes, pos)</span>
<span class="gi">+        after_leaf = nodes[-1].get_next_leaf()</span>
<span class="gi">+        first, second = _split_prefix_at(after_leaf, until_pos[0])</span>
<span class="gi">+        code_block += first</span>
<span class="gi">+</span>
<span class="gi">+        code_block = dedent(code_block)</span>
<span class="gi">+        if not has_ending_return_stmt:</span>
<span class="gi">+            output_var_str = &#39;, &#39;.join(return_variables)</span>
<span class="gi">+            code_block += &#39;return &#39; + output_var_str + &#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Check if we have to raise RefactoringError</span>
<span class="gi">+    _check_for_non_extractables(nodes[:-1] if has_ending_return_stmt else nodes)</span>
<span class="gi">+</span>
<span class="gi">+    decorator = &#39;&#39;</span>
<span class="gi">+    self_param = None</span>
<span class="gi">+    if is_bound_method:</span>
<span class="gi">+        if not function_is_staticmethod(context.tree_node):</span>
<span class="gi">+            function_param_names = context.get_value().get_param_names()</span>
<span class="gi">+            if len(function_param_names):</span>
<span class="gi">+                self_param = function_param_names[0].string_name</span>
<span class="gi">+                params = [p for p in params if p != self_param]</span>
<span class="gi">+</span>
<span class="gi">+        if function_is_classmethod(context.tree_node):</span>
<span class="gi">+            decorator = &#39;@classmethod\n&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        code_block += &#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+    function_code = &#39;%sdef %s(%s):\n%s&#39; % (</span>
<span class="gi">+        decorator,</span>
<span class="gi">+        name,</span>
<span class="gi">+        &#39;, &#39;.join(params if self_param is None else [self_param] + params),</span>
<span class="gi">+        indent_block(code_block)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    function_call = &#39;%s(%s)&#39; % (</span>
<span class="gi">+        (&#39;&#39; if self_param is None else self_param + &#39;.&#39;) + name,</span>
<span class="gi">+        &#39;, &#39;.join(params)</span>
<span class="gi">+    )</span>
<span class="gi">+    if is_expression:</span>
<span class="gi">+        replacement = function_call</span>
<span class="gi">+    else:</span>
<span class="gi">+        if has_ending_return_stmt:</span>
<span class="gi">+            replacement = &#39;return &#39; + function_call + &#39;\n&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            replacement = output_var_str + &#39; = &#39; + function_call + &#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+    replacement_dct = _replace(nodes, replacement, function_code, pos,</span>
<span class="gi">+                               insert_before_leaf, remaining_prefix)</span>
<span class="gi">+    if not is_expression:</span>
<span class="gi">+        replacement_dct[after_leaf] = second + after_leaf.value</span>
<span class="gi">+    file_to_node_changes = {path: replacement_dct}</span>
<span class="gi">+    return Refactoring(inference_state, file_to_node_changes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_for_non_extractables(nodes):</span>
<span class="gi">+    for n in nodes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            children = n.children</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            if n.value == &#39;return&#39;:</span>
<span class="gi">+                raise RefactoringError(</span>
<span class="gi">+                    &#39;Can only extract return statements if they are at the end.&#39;)</span>
<span class="gi">+            if n.value == &#39;yield&#39;:</span>
<span class="gi">+                raise RefactoringError(&#39;Cannot extract yield statements.&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            _check_for_non_extractables(children)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_name_input(module_context, names, first, last):</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        if name.api_type == &#39;param&#39; or not name.parent_context.is_module():</span>
<span class="gi">+            if name.get_root_context() is not module_context:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if name.start_pos is None or not (first &lt;= name.start_pos &lt; last):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_inputs_and_outputs(module_context, context, nodes):</span>
<span class="gi">+    first = nodes[0].start_pos</span>
<span class="gi">+    last = nodes[-1].end_pos</span>
<span class="gi">+</span>
<span class="gi">+    inputs = []</span>
<span class="gi">+    outputs = []</span>
<span class="gi">+    for name in _find_non_global_names(nodes):</span>
<span class="gi">+        if name.is_definition():</span>
<span class="gi">+            if name not in outputs:</span>
<span class="gi">+                outputs.append(name.value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if name.value not in inputs:</span>
<span class="gi">+                name_definitions = context.goto(name, name.start_pos)</span>
<span class="gi">+                if not name_definitions \</span>
<span class="gi">+                        or _is_name_input(module_context, name_definitions, first, last):</span>
<span class="gi">+                    inputs.append(name.value)</span>
<span class="gi">+</span>
<span class="gi">+    # Check if outputs are really needed:</span>
<span class="gi">+    return inputs, outputs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_non_global_names(nodes):</span>
<span class="gi">+    for node in nodes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            children = node.children</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            if node.type == &#39;name&#39;:</span>
<span class="gi">+                yield node</span>
<span class="gi">+        else:</span>
<span class="gi">+            # We only want to check foo in foo.bar</span>
<span class="gi">+            if node.type == &#39;trailer&#39; and node.children[0] == &#39;.&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            yield from _find_non_global_names(children)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_code_insertion_node(node, is_bound_method):</span>
<span class="gi">+    if not is_bound_method or function_is_staticmethod(node):</span>
<span class="gi">+        while node.parent.type != &#39;file_input&#39;:</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+    while node.parent.type in (&#39;async_funcdef&#39;, &#39;decorated&#39;, &#39;async_stmt&#39;):</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    return node</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_needed_output_variables(context, search_node, at_least_pos, return_variables):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Searches everything after at_least_pos in a node and checks if any of the
<span class="w"> </span>    return_variables are used in there and returns those.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in search_node.children:</span>
<span class="gi">+        if node.start_pos &lt; at_least_pos:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        return_variables = set(return_variables)</span>
<span class="gi">+        for name in _find_non_global_names([node]):</span>
<span class="gi">+            if not name.is_definition() and name.value in return_variables:</span>
<span class="gi">+                return_variables.remove(name.value)</span>
<span class="gi">+                yield name.value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_node_ending_return_stmt(node):</span>
<span class="gi">+    t = node.type</span>
<span class="gi">+    if t == &#39;simple_stmt&#39;:</span>
<span class="gi">+        return _is_node_ending_return_stmt(node.children[0])</span>
<span class="gi">+    return t == &#39;return_stmt&#39;</span>
<span class="gh">diff --git a/jedi/api/replstartup.py b/jedi/api/replstartup.py</span>
<span class="gh">index 0de20f06..e0f23d19 100644</span>
<span class="gd">--- a/jedi/api/replstartup.py</span>
<span class="gi">+++ b/jedi/api/replstartup.py</span>
<span class="gu">@@ -19,6 +19,11 @@ Then you will be able to use Jedi completer in your Python interpreter::</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import jedi.utils
<span class="w"> </span>from jedi import __version__ as __jedi_version__
<span class="gi">+</span>
<span class="w"> </span>print(&#39;REPL completion using Jedi %s&#39; % __jedi_version__)
<span class="w"> </span>jedi.utils.setup_readline(fuzzy=False)
<span class="gi">+</span>
<span class="w"> </span>del jedi
<span class="gi">+</span>
<span class="gi">+# Note: try not to do many things here, as it will contaminate global</span>
<span class="gi">+# namespace of the interpreter.</span>
<span class="gh">diff --git a/jedi/api/strings.py b/jedi/api/strings.py</span>
<span class="gh">index 498532e1..7850142c 100644</span>
<span class="gd">--- a/jedi/api/strings.py</span>
<span class="gi">+++ b/jedi/api/strings.py</span>
<span class="gu">@@ -8,13 +8,104 @@ and other completions is mostly that this module doesn&#39;t return defined</span>
<span class="w"> </span>names in a module, but pretty much an arbitrary string.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.names import AbstractArbitraryName
<span class="w"> </span>from jedi.inference.helpers import infer_call_of_leaf
<span class="w"> </span>from jedi.api.classes import Completion
<span class="w"> </span>from jedi.parser_utils import cut_value_at_position
<span class="gi">+</span>
<span class="w"> </span>_sentinel = object()


<span class="w"> </span>class StringName(AbstractArbitraryName):
<span class="w"> </span>    api_type = &#39;string&#39;
<span class="w"> </span>    is_value_name = False
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def complete_dict(module_context, code_lines, leaf, position, string, fuzzy):</span>
<span class="gi">+    bracket_leaf = leaf</span>
<span class="gi">+    if bracket_leaf != &#39;[&#39;:</span>
<span class="gi">+        bracket_leaf = leaf.get_previous_leaf()</span>
<span class="gi">+</span>
<span class="gi">+    cut_end_quote = &#39;&#39;</span>
<span class="gi">+    if string:</span>
<span class="gi">+        cut_end_quote = get_quote_ending(string, code_lines, position, invert_result=True)</span>
<span class="gi">+</span>
<span class="gi">+    if bracket_leaf == &#39;[&#39;:</span>
<span class="gi">+        if string is None and leaf is not bracket_leaf:</span>
<span class="gi">+            string = cut_value_at_position(leaf, position)</span>
<span class="gi">+</span>
<span class="gi">+        context = module_context.create_context(bracket_leaf)</span>
<span class="gi">+</span>
<span class="gi">+        before_node = before_bracket_leaf = bracket_leaf.get_previous_leaf()</span>
<span class="gi">+        if before_node in (&#39;)&#39;, &#39;]&#39;, &#39;}&#39;):</span>
<span class="gi">+            before_node = before_node.parent</span>
<span class="gi">+        if before_node.type in (&#39;atom&#39;, &#39;trailer&#39;, &#39;name&#39;):</span>
<span class="gi">+            values = infer_call_of_leaf(context, before_bracket_leaf)</span>
<span class="gi">+            return list(_completions_for_dicts(</span>
<span class="gi">+                module_context.inference_state,</span>
<span class="gi">+                values,</span>
<span class="gi">+                &#39;&#39; if string is None else string,</span>
<span class="gi">+                cut_end_quote,</span>
<span class="gi">+                fuzzy=fuzzy,</span>
<span class="gi">+            ))</span>
<span class="gi">+    return []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _completions_for_dicts(inference_state, dicts, literal_string, cut_end_quote, fuzzy):</span>
<span class="gi">+    for dict_key in sorted(_get_python_keys(dicts), key=lambda x: repr(x)):</span>
<span class="gi">+        dict_key_str = _create_repr_string(literal_string, dict_key)</span>
<span class="gi">+        if dict_key_str.startswith(literal_string):</span>
<span class="gi">+            name = StringName(inference_state, dict_key_str[:-len(cut_end_quote) or None])</span>
<span class="gi">+            yield Completion(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                name,</span>
<span class="gi">+                stack=None,</span>
<span class="gi">+                like_name_length=len(literal_string),</span>
<span class="gi">+                is_fuzzy=fuzzy</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_repr_string(literal_string, dict_key):</span>
<span class="gi">+    if not isinstance(dict_key, (str, bytes)) or not literal_string:</span>
<span class="gi">+        return repr(dict_key)</span>
<span class="gi">+</span>
<span class="gi">+    r = repr(dict_key)</span>
<span class="gi">+    prefix, quote = _get_string_prefix_and_quote(literal_string)</span>
<span class="gi">+    if quote is None:</span>
<span class="gi">+        return r</span>
<span class="gi">+    if quote == r[0]:</span>
<span class="gi">+        return prefix + r</span>
<span class="gi">+    return prefix + quote + r[1:-1] + quote</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_python_keys(dicts):</span>
<span class="gi">+    for dct in dicts:</span>
<span class="gi">+        if dct.array_type == &#39;dict&#39;:</span>
<span class="gi">+            for key in dct.get_key_values():</span>
<span class="gi">+                dict_key = key.get_safe_value(default=_sentinel)</span>
<span class="gi">+                if dict_key is not _sentinel:</span>
<span class="gi">+                    yield dict_key</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_string_prefix_and_quote(string):</span>
<span class="gi">+    match = re.match(r&#39;(\w*)(&quot;&quot;&quot;|\&#39;{3}|&quot;|\&#39;)&#39;, string)</span>
<span class="gi">+    if match is None:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+    return match.group(1), match.group(2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _matches_quote_at_position(code_lines, quote, position):</span>
<span class="gi">+    string = code_lines[position[0] - 1][position[1]:position[1] + len(quote)]</span>
<span class="gi">+    return string == quote</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_quote_ending(string, code_lines, position, invert_result=False):</span>
<span class="gi">+    _, quote = _get_string_prefix_and_quote(string)</span>
<span class="gi">+    if quote is None:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Add a quote only if it&#39;s not already there.</span>
<span class="gi">+    if _matches_quote_at_position(code_lines, quote, position) != invert_result:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    return quote</span>
<span class="gh">diff --git a/jedi/cache.py b/jedi/cache.py</span>
<span class="gh">index 1dc6e8ac..1ff45201 100644</span>
<span class="gd">--- a/jedi/cache.py</span>
<span class="gi">+++ b/jedi/cache.py</span>
<span class="gu">@@ -14,19 +14,34 @@ these variables are being cleaned after every API usage.</span>
<span class="w"> </span>import time
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from typing import Any, Dict, Tuple
<span class="gi">+</span>
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from parso.cache import parser_cache
<span class="gi">+</span>
<span class="w"> </span>_time_caches: Dict[str, Dict[Any, Tuple[float, Any]]] = {}


<span class="gd">-def clear_time_caches(delete_all: bool=False) -&gt;None:</span>
<span class="gi">+def clear_time_caches(delete_all: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot; Jedi caches many things, that should be completed after each completion
<span class="w"> </span>    finishes.

<span class="w"> </span>    :param delete_all: Deletes also the cache that is normally not deleted,
<span class="w"> </span>        like parser cache, which is important for faster parsing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _time_caches</span>
<span class="gi">+</span>
<span class="gi">+    if delete_all:</span>
<span class="gi">+        for cache in _time_caches.values():</span>
<span class="gi">+            cache.clear()</span>
<span class="gi">+        parser_cache.clear()</span>
<span class="gi">+    else:</span>
<span class="gi">+        # normally just kill the expired entries, not all</span>
<span class="gi">+        for tc in _time_caches.values():</span>
<span class="gi">+            # check time_cache for expired entries</span>
<span class="gi">+            for key, (t, value) in list(tc.items()):</span>
<span class="gi">+                if t &lt; time.time():</span>
<span class="gi">+                    # delete expired entries</span>
<span class="gi">+                    del tc[key]</span>


<span class="w"> </span>def signature_time_cache(time_add_setting):
<span class="gu">@@ -38,9 +53,63 @@ def signature_time_cache(time_add_setting):</span>

<span class="w"> </span>    If the given key is None, the function will not be cached.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _temp(key_func):</span>
<span class="gi">+        dct = {}</span>
<span class="gi">+        _time_caches[time_add_setting] = dct</span>
<span class="gi">+</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            generator = key_func(*args, **kwargs)</span>
<span class="gi">+            key = next(generator)</span>
<span class="gi">+            try:</span>
<span class="gi">+                expiry, value = dct[key]</span>
<span class="gi">+                if expiry &gt; time.time():</span>
<span class="gi">+                    return value</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            value = next(generator)</span>
<span class="gi">+            time_add = getattr(settings, time_add_setting)</span>
<span class="gi">+            if key is not None:</span>
<span class="gi">+                dct[key] = time.time() + time_add, value</span>
<span class="gi">+            return value</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return _temp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def time_cache(seconds):</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        cache = {}</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            key = (args, frozenset(kwargs.items()))</span>
<span class="gi">+            try:</span>
<span class="gi">+                created, result = cache[key]</span>
<span class="gi">+                if time.time() &lt; created + seconds:</span>
<span class="gi">+                    return result</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            result = func(*args, **kwargs)</span>
<span class="gi">+            cache[key] = time.time(), result</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        wrapper.clear_cache = lambda: cache.clear()</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def memoize_method(method):
<span class="w"> </span>    &quot;&quot;&quot;A normal memoize function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @wraps(method)</span>
<span class="gi">+    def wrapper(self, *args, **kwargs):</span>
<span class="gi">+        cache_dict = self.__dict__.setdefault(&#39;_memoize_method_dct&#39;, {})</span>
<span class="gi">+        dct = cache_dict.setdefault(method, {})</span>
<span class="gi">+        key = (args, frozenset(kwargs.items()))</span>
<span class="gi">+        try:</span>
<span class="gi">+            return dct[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            result = method(self, *args, **kwargs)</span>
<span class="gi">+            dct[key] = result</span>
<span class="gi">+            return result</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/common.py b/jedi/common.py</span>
<span class="gh">index 6254a2da..eb4b4996 100644</span>
<span class="gd">--- a/jedi/common.py</span>
<span class="gi">+++ b/jedi/common.py</span>
<span class="gu">@@ -6,9 +6,19 @@ def monkeypatch(obj, attribute_name, new_value):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Like pytest&#39;s monkeypatch, but as a value manager.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    old_value = getattr(obj, attribute_name)</span>
<span class="gi">+    try:</span>
<span class="gi">+        setattr(obj, attribute_name, new_value)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        setattr(obj, attribute_name, old_value)</span>


<span class="w"> </span>def indent_block(text, indention=&#39;    &#39;):
<span class="w"> </span>    &quot;&quot;&quot;This function indents a text block with a default of four spaces.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    temp = &#39;&#39;</span>
<span class="gi">+    while text and text[-1] == &#39;\n&#39;:</span>
<span class="gi">+        temp += text[-1]</span>
<span class="gi">+        text = text[:-1]</span>
<span class="gi">+    lines = text.split(&#39;\n&#39;)</span>
<span class="gi">+    return &#39;\n&#39;.join(map(lambda s: indention + s, lines)) + temp</span>
<span class="gh">diff --git a/jedi/debug.py b/jedi/debug.py</span>
<span class="gh">index a97c4eef..99a90601 100644</span>
<span class="gd">--- a/jedi/debug.py</span>
<span class="gi">+++ b/jedi/debug.py</span>
<span class="gu">@@ -2,6 +2,7 @@ import os</span>
<span class="w"> </span>import time
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from typing import Callable, Optional
<span class="gi">+</span>
<span class="w"> </span>_inited = False


<span class="gu">@@ -12,53 +13,112 @@ def _lazy_colorama_init():</span>

<span class="w"> </span>    This version of the function does nothing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>


<span class="w"> </span>try:
<span class="w"> </span>    if os.name == &#39;nt&#39;:
<span class="gi">+        # Does not work on Windows, as pyreadline and colorama interfere</span>
<span class="w"> </span>        raise ImportError
<span class="w"> </span>    else:
<span class="gd">-        from colorama import Fore, init</span>
<span class="gi">+        # Use colorama for nicer console output.</span>
<span class="gi">+        from colorama import Fore, init  # type: ignore[import]</span>
<span class="w"> </span>        from colorama import initialise

<span class="gd">-        def _lazy_colorama_init():</span>
<span class="gi">+        def _lazy_colorama_init():  # noqa: F811</span>
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Lazily init colorama if necessary, not to screw up stdout is
<span class="w"> </span>            debug not enabled.

<span class="w"> </span>            This version of the function does init colorama.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gd">-except ImportError:</span>
<span class="gi">+            global _inited</span>
<span class="gi">+            if not _inited:</span>
<span class="gi">+                # pytest resets the stream at the end - causes troubles. Since</span>
<span class="gi">+                # after every output the stream is reset automatically we don&#39;t</span>
<span class="gi">+                # need this.</span>
<span class="gi">+                initialise.atexit_done = True</span>
<span class="gi">+                try:</span>
<span class="gi">+                    init(strip=False)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    # Colorama fails with initializing under vim and is buggy in</span>
<span class="gi">+                    # version 0.3.6.</span>
<span class="gi">+                    pass</span>
<span class="gi">+            _inited = True</span>

<span class="gd">-</span>
<span class="gd">-    class Fore:</span>
<span class="gi">+except ImportError:</span>
<span class="gi">+    class Fore:  # type: ignore[no-redef]</span>
<span class="w"> </span>        RED = &#39;&#39;
<span class="w"> </span>        GREEN = &#39;&#39;
<span class="w"> </span>        YELLOW = &#39;&#39;
<span class="w"> </span>        MAGENTA = &#39;&#39;
<span class="w"> </span>        RESET = &#39;&#39;
<span class="w"> </span>        BLUE = &#39;&#39;
<span class="gi">+</span>
<span class="w"> </span>NOTICE = object()
<span class="w"> </span>WARNING = object()
<span class="w"> </span>SPEED = object()
<span class="gi">+</span>
<span class="w"> </span>enable_speed = False
<span class="w"> </span>enable_warning = False
<span class="w"> </span>enable_notice = False
<span class="gi">+</span>
<span class="gi">+# callback, interface: level, str</span>
<span class="w"> </span>debug_function: Optional[Callable[[str, str], None]] = None
<span class="w"> </span>_debug_indent = 0
<span class="w"> </span>_start_time = time.time()


<span class="gi">+def reset_time():</span>
<span class="gi">+    global _start_time, _debug_indent</span>
<span class="gi">+    _start_time = time.time()</span>
<span class="gi">+    _debug_indent = 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def increase_indent(func):
<span class="w"> </span>    &quot;&quot;&quot;Decorator for makin &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        with increase_indent_cm():</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def increase_indent_cm(title=None, color=&#39;MAGENTA&#39;):</span>
<span class="gi">+    global _debug_indent</span>
<span class="gi">+    if title:</span>
<span class="gi">+        dbg(&#39;Start: &#39; + title, color=color)</span>
<span class="gi">+    _debug_indent += 1</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        _debug_indent -= 1</span>
<span class="gi">+        if title:</span>
<span class="gi">+            dbg(&#39;End: &#39; + title, color=color)</span>


<span class="w"> </span>def dbg(message, *args, color=&#39;GREEN&#39;):
<span class="w"> </span>    &quot;&quot;&quot; Looks at the stack, to see if a debug message should be printed. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert color</span>
<span class="gi">+</span>
<span class="gi">+    if debug_function and enable_notice:</span>
<span class="gi">+        i = &#39; &#39; * _debug_indent</span>
<span class="gi">+        _lazy_colorama_init()</span>
<span class="gi">+        debug_function(color, i + &#39;dbg: &#39; + message % tuple(repr(a) for a in args))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def warning(message, *args, format=True):</span>
<span class="gi">+    if debug_function and enable_warning:</span>
<span class="gi">+        i = &#39; &#39; * _debug_indent</span>
<span class="gi">+        if format:</span>
<span class="gi">+            message = message % tuple(repr(a) for a in args)</span>
<span class="gi">+        debug_function(&#39;RED&#39;, i + &#39;warning: &#39; + message)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def speed(name):</span>
<span class="gi">+    if debug_function and enable_speed:</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        i = &#39; &#39; * _debug_indent</span>
<span class="gi">+        debug_function(&#39;YELLOW&#39;, i + &#39;speed: &#39; + &#39;%s %s&#39; % (name, now - _start_time))</span>


<span class="w"> </span>def print_to_stdout(color, str_out):
<span class="gu">@@ -67,4 +127,6 @@ def print_to_stdout(color, str_out):</span>

<span class="w"> </span>    :param str color: A string that is an attribute of ``colorama.Fore``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    col = getattr(Fore, color)</span>
<span class="gi">+    _lazy_colorama_init()</span>
<span class="gi">+    print(col + str_out + Fore.RESET)</span>
<span class="gh">diff --git a/jedi/file_io.py b/jedi/file_io.py</span>
<span class="gh">index 7258df1e..ead17335 100644</span>
<span class="gd">--- a/jedi/file_io.py</span>
<span class="gi">+++ b/jedi/file_io.py</span>
<span class="gu">@@ -1,31 +1,79 @@</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from parso import file_io


<span class="w"> </span>class AbstractFolderIO:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, path):
<span class="w"> </span>        self.path = path

<span class="gi">+    def get_base_name(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def list(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_file_io(self, name):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_parent_folder(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.path)


<span class="w"> </span>class FolderIO(AbstractFolderIO):
<span class="gd">-    pass</span>
<span class="gi">+    def get_base_name(self):</span>
<span class="gi">+        return os.path.basename(self.path)</span>
<span class="gi">+</span>
<span class="gi">+    def list(self):</span>
<span class="gi">+        return os.listdir(self.path)</span>
<span class="gi">+</span>
<span class="gi">+    def get_file_io(self, name):</span>
<span class="gi">+        return FileIO(os.path.join(self.path, name))</span>
<span class="gi">+</span>
<span class="gi">+    def get_parent_folder(self):</span>
<span class="gi">+        return FolderIO(os.path.dirname(self.path))</span>
<span class="gi">+</span>
<span class="gi">+    def walk(self):</span>
<span class="gi">+        for root, dirs, files in os.walk(self.path):</span>
<span class="gi">+            root_folder_io = FolderIO(root)</span>
<span class="gi">+            original_folder_ios = [FolderIO(os.path.join(root, d)) for d in dirs]</span>
<span class="gi">+            modified_folder_ios = list(original_folder_ios)</span>
<span class="gi">+            yield (</span>
<span class="gi">+                root_folder_io,</span>
<span class="gi">+                modified_folder_ios,</span>
<span class="gi">+                [FileIO(os.path.join(root, f)) for f in files],</span>
<span class="gi">+            )</span>
<span class="gi">+            modified_iterator = iter(reversed(modified_folder_ios))</span>
<span class="gi">+            current = next(modified_iterator, None)</span>
<span class="gi">+            i = len(original_folder_ios)</span>
<span class="gi">+            for folder_io in reversed(original_folder_ios):</span>
<span class="gi">+                i -= 1   # Basically enumerate but reversed</span>
<span class="gi">+                if current is folder_io:</span>
<span class="gi">+                    current = next(modified_iterator, None)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    del dirs[i]</span>


<span class="w"> </span>class FileIOFolderMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def get_parent_folder(self):</span>
<span class="gi">+        return FolderIO(os.path.dirname(self.path))</span>


<span class="w"> </span>class ZipFileIO(file_io.KnownContentFileIO, FileIOFolderMixin):
<span class="w"> </span>    &quot;&quot;&quot;For .zip and .egg archives&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, path, code, zip_path):
<span class="w"> </span>        super().__init__(path, code)
<span class="w"> </span>        self._zip_path = zip_path

<span class="gi">+    def get_last_modified(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return os.path.getmtime(self._zip_path)</span>
<span class="gi">+        except (FileNotFoundError, PermissionError, NotADirectoryError):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>

<span class="w"> </span>class FileIO(file_io.FileIO, FileIOFolderMixin):
<span class="w"> </span>    pass
<span class="gh">diff --git a/jedi/inference/analysis.py b/jedi/inference/analysis.py</span>
<span class="gh">index a45cec67..c272a9cb 100644</span>
<span class="gd">--- a/jedi/inference/analysis.py</span>
<span class="gi">+++ b/jedi/inference/analysis.py</span>
<span class="gu">@@ -2,26 +2,31 @@</span>
<span class="w"> </span>Module for statical analysis.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from parso.python import tree
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.helpers import is_string
<span class="gd">-CODES = {&#39;attribute-error&#39;: (1, AttributeError, &#39;Potential AttributeError.&#39;</span>
<span class="gd">-    ), &#39;name-error&#39;: (2, NameError, &#39;Potential NameError.&#39;), &#39;import-error&#39;:</span>
<span class="gd">-    (3, ImportError, &#39;Potential ImportError.&#39;),</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CODES = {</span>
<span class="gi">+    &#39;attribute-error&#39;: (1, AttributeError, &#39;Potential AttributeError.&#39;),</span>
<span class="gi">+    &#39;name-error&#39;: (2, NameError, &#39;Potential NameError.&#39;),</span>
<span class="gi">+    &#39;import-error&#39;: (3, ImportError, &#39;Potential ImportError.&#39;),</span>
<span class="w"> </span>    &#39;type-error-too-many-arguments&#39;: (4, TypeError, None),
<span class="w"> </span>    &#39;type-error-too-few-arguments&#39;: (5, TypeError, None),
<span class="w"> </span>    &#39;type-error-keyword-argument&#39;: (6, TypeError, None),
<span class="w"> </span>    &#39;type-error-multiple-values&#39;: (7, TypeError, None),
<span class="gd">-    &#39;type-error-star-star&#39;: (8, TypeError, None), &#39;type-error-star&#39;: (9,</span>
<span class="gd">-    TypeError, None), &#39;type-error-operation&#39;: (10, TypeError, None),</span>
<span class="gi">+    &#39;type-error-star-star&#39;: (8, TypeError, None),</span>
<span class="gi">+    &#39;type-error-star&#39;: (9, TypeError, None),</span>
<span class="gi">+    &#39;type-error-operation&#39;: (10, TypeError, None),</span>
<span class="w"> </span>    &#39;type-error-not-iterable&#39;: (11, TypeError, None),
<span class="w"> </span>    &#39;type-error-isinstance&#39;: (12, TypeError, None),
<span class="w"> </span>    &#39;type-error-not-subscriptable&#39;: (13, TypeError, None),
<span class="w"> </span>    &#39;value-error-too-many-values&#39;: (14, ValueError, None),
<span class="gd">-    &#39;value-error-too-few-values&#39;: (15, ValueError, None)}</span>
<span class="gi">+    &#39;value-error-too-few-values&#39;: (15, ValueError, None),</span>
<span class="gi">+}</span>


<span class="w"> </span>class Error:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, name, module_path, start_pos, message=None):
<span class="w"> </span>        self.path = module_path
<span class="w"> </span>        self._start_pos = start_pos
<span class="gu">@@ -30,13 +35,27 @@ class Error:</span>
<span class="w"> </span>            message = CODES[self.name][2]
<span class="w"> </span>        self.message = message

<span class="gi">+    @property</span>
<span class="gi">+    def line(self):</span>
<span class="gi">+        return self._start_pos[0]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def column(self):</span>
<span class="gi">+        return self._start_pos[1]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def code(self):</span>
<span class="gi">+        # The class name start</span>
<span class="gi">+        first = self.__class__.__name__[0]</span>
<span class="gi">+        return first + str(CODES[self.name][0])</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;%s:%s:%s: %s %s&#39; % (self.path, self.line, self.column, self</span>
<span class="gd">-            .code, self.message)</span>
<span class="gi">+        return &#39;%s:%s:%s: %s %s&#39; % (self.path, self.line, self.column,</span>
<span class="gi">+                                    self.code, self.message)</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return (self.path == other.path and self.name == other.name and </span>
<span class="gd">-            self._start_pos == other._start_pos)</span>
<span class="gi">+        return (self.path == other.path and self.name == other.name</span>
<span class="gi">+                and self._start_pos == other._start_pos)</span>

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self.__eq__(other)
<span class="gu">@@ -45,23 +64,66 @@ class Error:</span>
<span class="w"> </span>        return hash((self.path, self._start_pos, self.name))

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s %s: %s@%s,%s&gt;&#39; % (self.__class__.__name__, self.name,</span>
<span class="gd">-            self.path, self._start_pos[0], self._start_pos[1])</span>
<span class="gi">+        return &#39;&lt;%s %s: %s@%s,%s&gt;&#39; % (self.__class__.__name__,</span>
<span class="gi">+                                      self.name, self.path,</span>
<span class="gi">+                                      self._start_pos[0], self._start_pos[1])</span>


<span class="w"> </span>class Warning(Error):
<span class="w"> </span>    pass


<span class="gi">+def add(node_context, error_name, node, message=None, typ=Error, payload=None):</span>
<span class="gi">+    exception = CODES[error_name][1]</span>
<span class="gi">+    if _check_for_exception_catch(node_context, node, exception, payload):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # TODO this path is probably not right</span>
<span class="gi">+    module_context = node_context.get_root_context()</span>
<span class="gi">+    module_path = module_context.py__file__()</span>
<span class="gi">+    issue_instance = typ(error_name, module_path, node.start_pos, message)</span>
<span class="gi">+    debug.warning(str(issue_instance), format=False)</span>
<span class="gi">+    node_context.inference_state.analysis.append(issue_instance)</span>
<span class="gi">+    return issue_instance</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def _check_for_setattr(instance):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if there&#39;s any setattr method inside an instance. If so, return True.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module = instance.get_root_context()</span>
<span class="gi">+    node = module.tree_node</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        # If it&#39;s a compiled module or doesn&#39;t have a tree_node</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        stmt_names = node.get_used_names()[&#39;setattr&#39;]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return any(node.start_pos &lt; n.start_pos &lt; node.end_pos</span>
<span class="gi">+               # Check if it&#39;s a function called setattr.</span>
<span class="gi">+               and not (n.parent.type == &#39;funcdef&#39; and n.parent.name == n)</span>
<span class="gi">+               for n in stmt_names)</span>


<span class="gd">-def _check_for_exception_catch(node_context, jedi_name, exception, payload=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def add_attribute_error(name_context, lookup_value, name):</span>
<span class="gi">+    message = (&#39;AttributeError: %s has no attribute %s.&#39; % (lookup_value, name))</span>
<span class="gi">+    # Check for __getattr__/__getattribute__ existance and issue a warning</span>
<span class="gi">+    # instead of an error, if that happens.</span>
<span class="gi">+    typ = Error</span>
<span class="gi">+    if lookup_value.is_instance() and not lookup_value.is_compiled():</span>
<span class="gi">+        # TODO maybe make a warning for __getattr__/__getattribute__</span>
<span class="gi">+</span>
<span class="gi">+        if _check_for_setattr(lookup_value):</span>
<span class="gi">+            typ = Warning</span>
<span class="gi">+</span>
<span class="gi">+    payload = lookup_value, name</span>
<span class="gi">+    add(name_context, &#39;attribute-error&#39;, name, message, typ, payload)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_for_exception_catch(node_context, jedi_name, exception, payload=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks if a jedi object (e.g. `Statement`) sits inside a try/catch and
<span class="w"> </span>    doesn&#39;t count as an error (if equal to `exception`).
<span class="gu">@@ -69,4 +131,83 @@ def _check_for_exception_catch(node_context, jedi_name, exception, payload=None</span>
<span class="w"> </span>    it.
<span class="w"> </span>    Returns True if the exception was catched.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def check_match(cls, exception):</span>
<span class="gi">+        if not cls.is_class():</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for python_cls in exception.mro():</span>
<span class="gi">+            if cls.py__name__() == python_cls.__name__ \</span>
<span class="gi">+                    and cls.parent_context.is_builtins_module():</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def check_try_for_except(obj, exception):</span>
<span class="gi">+        # Only nodes in try</span>
<span class="gi">+        iterator = iter(obj.children)</span>
<span class="gi">+        for branch_type in iterator:</span>
<span class="gi">+            next(iterator)  # The colon</span>
<span class="gi">+            suite = next(iterator)</span>
<span class="gi">+            if branch_type == &#39;try&#39; \</span>
<span class="gi">+                    and not (branch_type.start_pos &lt; jedi_name.start_pos &lt;= suite.end_pos):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        for node in obj.get_except_clause_tests():</span>
<span class="gi">+            if node is None:</span>
<span class="gi">+                return True  # An exception block that catches everything.</span>
<span class="gi">+            else:</span>
<span class="gi">+                except_classes = node_context.infer_node(node)</span>
<span class="gi">+                for cls in except_classes:</span>
<span class="gi">+                    from jedi.inference.value import iterable</span>
<span class="gi">+                    if isinstance(cls, iterable.Sequence) and \</span>
<span class="gi">+                            cls.array_type == &#39;tuple&#39;:</span>
<span class="gi">+                        # multiple exceptions</span>
<span class="gi">+                        for lazy_value in cls.py__iter__():</span>
<span class="gi">+                            for typ in lazy_value.infer():</span>
<span class="gi">+                                if check_match(typ, exception):</span>
<span class="gi">+                                    return True</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if check_match(cls, exception):</span>
<span class="gi">+                            return True</span>
<span class="gi">+</span>
<span class="gi">+    def check_hasattr(node, suite):</span>
<span class="gi">+        try:</span>
<span class="gi">+            assert suite.start_pos &lt;= jedi_name.start_pos &lt; suite.end_pos</span>
<span class="gi">+            assert node.type in (&#39;power&#39;, &#39;atom_expr&#39;)</span>
<span class="gi">+            base = node.children[0]</span>
<span class="gi">+            assert base.type == &#39;name&#39; and base.value == &#39;hasattr&#39;</span>
<span class="gi">+            trailer = node.children[1]</span>
<span class="gi">+            assert trailer.type == &#39;trailer&#39;</span>
<span class="gi">+            arglist = trailer.children[1]</span>
<span class="gi">+            assert arglist.type == &#39;arglist&#39;</span>
<span class="gi">+            from jedi.inference.arguments import TreeArguments</span>
<span class="gi">+            args = TreeArguments(node_context.inference_state, node_context, arglist)</span>
<span class="gi">+            unpacked_args = list(args.unpack())</span>
<span class="gi">+            # Arguments should be very simple</span>
<span class="gi">+            assert len(unpacked_args) == 2</span>
<span class="gi">+</span>
<span class="gi">+            # Check name</span>
<span class="gi">+            key, lazy_value = unpacked_args[1]</span>
<span class="gi">+            names = list(lazy_value.infer())</span>
<span class="gi">+            assert len(names) == 1 and is_string(names[0])</span>
<span class="gi">+            assert names[0].get_safe_value() == payload[1].value</span>
<span class="gi">+</span>
<span class="gi">+            # Check objects</span>
<span class="gi">+            key, lazy_value = unpacked_args[0]</span>
<span class="gi">+            objects = lazy_value.infer()</span>
<span class="gi">+            return payload[0] in objects</span>
<span class="gi">+        except AssertionError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    obj = jedi_name</span>
<span class="gi">+    while obj is not None and not isinstance(obj, (tree.Function, tree.Class)):</span>
<span class="gi">+        if isinstance(obj, tree.Flow):</span>
<span class="gi">+            # try/except catch check</span>
<span class="gi">+            if obj.type == &#39;try_stmt&#39; and check_try_for_except(obj, exception):</span>
<span class="gi">+                return True</span>
<span class="gi">+            # hasattr check</span>
<span class="gi">+            if exception == AttributeError and obj.type in (&#39;if_stmt&#39;, &#39;while_stmt&#39;):</span>
<span class="gi">+                if check_hasattr(obj.children[1], obj.children[3]):</span>
<span class="gi">+                    return True</span>
<span class="gi">+        obj = obj.parent</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/jedi/inference/arguments.py b/jedi/inference/arguments.py</span>
<span class="gh">index 95120843..8602f494 100644</span>
<span class="gd">--- a/jedi/inference/arguments.py</span>
<span class="gi">+++ b/jedi/inference/arguments.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="w"> </span>import re
<span class="w"> </span>from itertools import zip_longest
<span class="gi">+</span>
<span class="w"> </span>from parso.python import tree
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.utils import PushBackIterator
<span class="w"> </span>from jedi.inference import analysis
<span class="gd">-from jedi.inference.lazy_value import LazyKnownValue, LazyKnownValues, LazyTreeValue, get_merged_lazy_value</span>
<span class="gi">+from jedi.inference.lazy_value import LazyKnownValue, LazyKnownValues, \</span>
<span class="gi">+    LazyTreeValue, get_merged_lazy_value</span>
<span class="w"> </span>from jedi.inference.names import ParamName, TreeNameDefinition, AnonymousParamName
<span class="w"> </span>from jedi.inference.base_value import NO_VALUES, ValueSet, ContextualizedNode
<span class="w"> </span>from jedi.inference.value import iterable
<span class="gu">@@ -13,7 +16,19 @@ from jedi.inference.cache import inference_state_as_method_param_cache</span>

<span class="w"> </span>def try_iter_content(types, depth=0):
<span class="w"> </span>    &quot;&quot;&quot;Helper method for static analysis.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if depth &gt; 10:</span>
<span class="gi">+        # It&#39;s possible that a loop has references on itself (especially with</span>
<span class="gi">+        # CompiledValue). Therefore don&#39;t loop infinitely.</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for typ in types:</span>
<span class="gi">+        try:</span>
<span class="gi">+            f = typ.py__iter__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            for lazy_value in f():</span>
<span class="gi">+                try_iter_content(lazy_value.infer(), depth + 1)</span>


<span class="w"> </span>class ParamIssue(Exception):
<span class="gu">@@ -31,16 +46,90 @@ def repack_with_argument_clinic(clinic_string):</span>
<span class="w"> </span>        str.split.__text_signature__
<span class="w"> </span>        # Results in: &#39;($self, /, sep=None, maxsplit=-1)&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        def wrapper(value, arguments):</span>
<span class="gi">+            try:</span>
<span class="gi">+                args = tuple(iterate_argument_clinic(</span>
<span class="gi">+                    value.inference_state,</span>
<span class="gi">+                    arguments,</span>
<span class="gi">+                    clinic_string,</span>
<span class="gi">+                ))</span>
<span class="gi">+            except ParamIssue:</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            else:</span>
<span class="gi">+                return func(value, *args)</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def iterate_argument_clinic(inference_state, arguments, clinic_string):
<span class="w"> </span>    &quot;&quot;&quot;Uses a list with argument clinic information (see PEP 436).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    clinic_args = list(_parse_argument_clinic(clinic_string))</span>
<span class="gi">+</span>
<span class="gi">+    iterator = PushBackIterator(arguments.unpack())</span>
<span class="gi">+    for i, (name, optional, allow_kwargs, stars) in enumerate(clinic_args):</span>
<span class="gi">+        if stars == 1:</span>
<span class="gi">+            lazy_values = []</span>
<span class="gi">+            for key, argument in iterator:</span>
<span class="gi">+                if key is not None:</span>
<span class="gi">+                    iterator.push_back((key, argument))</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+                lazy_values.append(argument)</span>
<span class="gi">+            yield ValueSet([iterable.FakeTuple(inference_state, lazy_values)])</span>
<span class="gi">+            lazy_values</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif stars == 2:</span>
<span class="gi">+            raise NotImplementedError()</span>
<span class="gi">+        key, argument = next(iterator, (None, None))</span>
<span class="gi">+        if key is not None:</span>
<span class="gi">+            debug.warning(&#39;Keyword arguments in argument clinic are currently not supported.&#39;)</span>
<span class="gi">+            raise ParamIssue</span>
<span class="gi">+        if argument is None and not optional:</span>
<span class="gi">+            debug.warning(&#39;TypeError: %s expected at least %s arguments, got %s&#39;,</span>
<span class="gi">+                          name, len(clinic_args), i)</span>
<span class="gi">+            raise ParamIssue</span>
<span class="gi">+</span>
<span class="gi">+        value_set = NO_VALUES if argument is None else argument.infer()</span>
<span class="gi">+</span>
<span class="gi">+        if not value_set and not optional:</span>
<span class="gi">+            # For the stdlib we always want values. If we don&#39;t get them,</span>
<span class="gi">+            # that&#39;s ok, maybe something is too hard to resolve, however,</span>
<span class="gi">+            # we will not proceed with the type inference of that function.</span>
<span class="gi">+            debug.warning(&#39;argument_clinic &quot;%s&quot; not resolvable.&#39;, name)</span>
<span class="gi">+            raise ParamIssue</span>
<span class="gi">+        yield value_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_argument_clinic(string):</span>
<span class="gi">+    allow_kwargs = False</span>
<span class="gi">+    optional = False</span>
<span class="gi">+    while string:</span>
<span class="gi">+        # Optional arguments have to begin with a bracket. And should always be</span>
<span class="gi">+        # at the end of the arguments. This is therefore not a proper argument</span>
<span class="gi">+        # clinic implementation. `range()` for exmple allows an optional start</span>
<span class="gi">+        # value at the beginning.</span>
<span class="gi">+        match = re.match(r&#39;(?:(?:(\[),? ?|, ?|)(\**\w+)|, ?/)\]*&#39;, string)</span>
<span class="gi">+        string = string[len(match.group(0)):]</span>
<span class="gi">+        if not match.group(2):  # A slash -&gt; allow named arguments</span>
<span class="gi">+            allow_kwargs = True</span>
<span class="gi">+            continue</span>
<span class="gi">+        optional = optional or bool(match.group(1))</span>
<span class="gi">+        word = match.group(2)</span>
<span class="gi">+        stars = word.count(&#39;*&#39;)</span>
<span class="gi">+        word = word[stars:]</span>
<span class="gi">+        yield (word, optional, allow_kwargs, stars)</span>
<span class="gi">+        if stars:</span>
<span class="gi">+            allow_kwargs = True</span>


<span class="w"> </span>class _AbstractArgumentsMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def unpack(self, funcdef=None):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_calling_nodes(self):</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class AbstractArguments(_AbstractArgumentsMixin):
<span class="gu">@@ -49,8 +138,32 @@ class AbstractArguments(_AbstractArgumentsMixin):</span>
<span class="w"> </span>    trailer = None


<span class="gd">-class TreeArguments(AbstractArguments):</span>
<span class="gi">+def unpack_arglist(arglist):</span>
<span class="gi">+    if arglist is None:</span>
<span class="gi">+        return</span>

<span class="gi">+    if arglist.type != &#39;arglist&#39; and not (</span>
<span class="gi">+            arglist.type == &#39;argument&#39; and arglist.children[0] in (&#39;*&#39;, &#39;**&#39;)):</span>
<span class="gi">+        yield 0, arglist</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    iterator = iter(arglist.children)</span>
<span class="gi">+    for child in iterator:</span>
<span class="gi">+        if child == &#39;,&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif child in (&#39;*&#39;, &#39;**&#39;):</span>
<span class="gi">+            c = next(iterator, None)</span>
<span class="gi">+            assert c is not None</span>
<span class="gi">+            yield len(child.value), c</span>
<span class="gi">+        elif child.type == &#39;argument&#39; and \</span>
<span class="gi">+                child.children[0] in (&#39;*&#39;, &#39;**&#39;):</span>
<span class="gi">+            assert len(child.children) == 2</span>
<span class="gi">+            yield len(child.children[0].value), child.children[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield 0, child</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class TreeArguments(AbstractArguments):</span>
<span class="w"> </span>    def __init__(self, inference_state, context, argument_node, trailer=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param argument_node: May be an argument_node or a list of nodes.
<span class="gu">@@ -58,25 +171,165 @@ class TreeArguments(AbstractArguments):</span>
<span class="w"> </span>        self.argument_node = argument_node
<span class="w"> </span>        self.context = context
<span class="w"> </span>        self._inference_state = inference_state
<span class="gd">-        self.trailer = trailer</span>
<span class="gi">+        self.trailer = trailer  # Can be None, e.g. in a class definition.</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @inference_state_as_method_param_cache()</span>
<span class="gi">+    def create_cached(cls, *args, **kwargs):</span>
<span class="gi">+        return cls(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def unpack(self, funcdef=None):</span>
<span class="gi">+        named_args = []</span>
<span class="gi">+        for star_count, el in unpack_arglist(self.argument_node):</span>
<span class="gi">+            if star_count == 1:</span>
<span class="gi">+                arrays = self.context.infer_node(el)</span>
<span class="gi">+                iterators = [_iterate_star_args(self.context, a, el, funcdef)</span>
<span class="gi">+                             for a in arrays]</span>
<span class="gi">+                for values in list(zip_longest(*iterators)):</span>
<span class="gi">+                    yield None, get_merged_lazy_value(</span>
<span class="gi">+                        [v for v in values if v is not None]</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif star_count == 2:</span>
<span class="gi">+                arrays = self.context.infer_node(el)</span>
<span class="gi">+                for dct in arrays:</span>
<span class="gi">+                    yield from _star_star_dict(self.context, dct, el, funcdef)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if el.type == &#39;argument&#39;:</span>
<span class="gi">+                    c = el.children</span>
<span class="gi">+                    if len(c) == 3:  # Keyword argument.</span>
<span class="gi">+                        named_args.append((c[0].value, LazyTreeValue(self.context, c[2]),))</span>
<span class="gi">+                    else:  # Generator comprehension.</span>
<span class="gi">+                        # Include the brackets with the parent.</span>
<span class="gi">+                        sync_comp_for = el.children[1]</span>
<span class="gi">+                        if sync_comp_for.type == &#39;comp_for&#39;:</span>
<span class="gi">+                            sync_comp_for = sync_comp_for.children[1]</span>
<span class="gi">+                        comp = iterable.GeneratorComprehension(</span>
<span class="gi">+                            self._inference_state,</span>
<span class="gi">+                            defining_context=self.context,</span>
<span class="gi">+                            sync_comp_for_node=sync_comp_for,</span>
<span class="gi">+                            entry_node=el.children[0],</span>
<span class="gi">+                        )</span>
<span class="gi">+                        yield None, LazyKnownValue(comp)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield None, LazyTreeValue(self.context, el)</span>
<span class="gi">+</span>
<span class="gi">+        # Reordering arguments is necessary, because star args sometimes appear</span>
<span class="gi">+        # after named argument, but in the actual order it&#39;s prepended.</span>
<span class="gi">+        yield from named_args</span>
<span class="gi">+</span>
<span class="gi">+    def _as_tree_tuple_objects(self):</span>
<span class="gi">+        for star_count, argument in unpack_arglist(self.argument_node):</span>
<span class="gi">+            default = None</span>
<span class="gi">+            if argument.type == &#39;argument&#39;:</span>
<span class="gi">+                if len(argument.children) == 3:  # Keyword argument.</span>
<span class="gi">+                    argument, default = argument.children[::2]</span>
<span class="gi">+            yield argument, default, star_count</span>
<span class="gi">+</span>
<span class="gi">+    def iter_calling_names_with_star(self):</span>
<span class="gi">+        for name, default, star_count in self._as_tree_tuple_objects():</span>
<span class="gi">+            # TODO this function is a bit strange. probably refactor?</span>
<span class="gi">+            if not star_count or not isinstance(name, tree.Name):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            yield TreeNameDefinition(self.context, name)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.argument_node)

<span class="gi">+    def get_calling_nodes(self):</span>
<span class="gi">+        old_arguments_list = []</span>
<span class="gi">+        arguments = self</span>

<span class="gd">-class ValuesArguments(AbstractArguments):</span>
<span class="gi">+        while arguments not in old_arguments_list:</span>
<span class="gi">+            if not isinstance(arguments, TreeArguments):</span>
<span class="gi">+                break</span>

<span class="gi">+            old_arguments_list.append(arguments)</span>
<span class="gi">+            for calling_name in reversed(list(arguments.iter_calling_names_with_star())):</span>
<span class="gi">+                names = calling_name.goto()</span>
<span class="gi">+                if len(names) != 1:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if isinstance(names[0], AnonymousParamName):</span>
<span class="gi">+                    # Dynamic parameters should not have calling nodes, because</span>
<span class="gi">+                    # they are dynamic and extremely random.</span>
<span class="gi">+                    return []</span>
<span class="gi">+                if not isinstance(names[0], ParamName):</span>
<span class="gi">+                    break</span>
<span class="gi">+                executed_param_name = names[0].get_executed_param_name()</span>
<span class="gi">+                arguments = executed_param_name.arguments</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if arguments.argument_node is not None:</span>
<span class="gi">+            return [ContextualizedNode(arguments.context, arguments.argument_node)]</span>
<span class="gi">+        if arguments.trailer is not None:</span>
<span class="gi">+            return [ContextualizedNode(arguments.context, arguments.trailer)]</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ValuesArguments(AbstractArguments):</span>
<span class="w"> </span>    def __init__(self, values_list):
<span class="w"> </span>        self._values_list = values_list

<span class="gi">+    def unpack(self, funcdef=None):</span>
<span class="gi">+        for values in self._values_list:</span>
<span class="gi">+            yield None, LazyKnownValues(values)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._values_list)


<span class="w"> </span>class TreeArgumentsWrapper(_AbstractArgumentsMixin):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, arguments):
<span class="w"> </span>        self._wrapped_arguments = arguments

<span class="gi">+    @property</span>
<span class="gi">+    def context(self):</span>
<span class="gi">+        return self._wrapped_arguments.context</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def argument_node(self):</span>
<span class="gi">+        return self._wrapped_arguments.argument_node</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailer(self):</span>
<span class="gi">+        return self._wrapped_arguments.trailer</span>
<span class="gi">+</span>
<span class="gi">+    def unpack(self, func=None):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_calling_nodes(self):</span>
<span class="gi">+        return self._wrapped_arguments.get_calling_nodes()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._wrapped_arguments)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _iterate_star_args(context, array, input_node, funcdef=None):</span>
<span class="gi">+    if not array.py__getattribute__(&#39;__iter__&#39;):</span>
<span class="gi">+        if funcdef is not None:</span>
<span class="gi">+            # TODO this funcdef should not be needed.</span>
<span class="gi">+            m = &quot;TypeError: %s() argument after * must be a sequence, not %s&quot; \</span>
<span class="gi">+                % (funcdef.name.value, array)</span>
<span class="gi">+            analysis.add(context, &#39;type-error-star&#39;, input_node, message=m)</span>
<span class="gi">+    try:</span>
<span class="gi">+        iter_ = array.py__iter__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from iter_()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _star_star_dict(context, array, input_node, funcdef):</span>
<span class="gi">+    from jedi.inference.value.instance import CompiledInstance</span>
<span class="gi">+    if isinstance(array, CompiledInstance) and array.name.string_name == &#39;dict&#39;:</span>
<span class="gi">+        # For now ignore this case. In the future add proper iterators and just</span>
<span class="gi">+        # make one call without crazy isinstance checks.</span>
<span class="gi">+        return {}</span>
<span class="gi">+    elif isinstance(array, iterable.Sequence) and array.array_type == &#39;dict&#39;:</span>
<span class="gi">+        return array.exact_key_items()</span>
<span class="gi">+    else:</span>
<span class="gi">+        if funcdef is not None:</span>
<span class="gi">+            m = &quot;TypeError: %s argument after ** must be a mapping, not %s&quot; \</span>
<span class="gi">+                % (funcdef.name.value, array)</span>
<span class="gi">+            analysis.add(context, &#39;type-error-star-star&#39;, input_node, message=m)</span>
<span class="gi">+        return {}</span>
<span class="gh">diff --git a/jedi/inference/base_value.py b/jedi/inference/base_value.py</span>
<span class="gh">index 3e35794a..9a789a4e 100644</span>
<span class="gd">--- a/jedi/inference/base_value.py</span>
<span class="gi">+++ b/jedi/inference/base_value.py</span>
<span class="gu">@@ -9,13 +9,16 @@ just one.</span>
<span class="w"> </span>from functools import reduce
<span class="w"> </span>from operator import add
<span class="w"> </span>from itertools import zip_longest
<span class="gi">+</span>
<span class="w"> </span>from parso.python.tree import Name
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.parser_utils import clean_scope_docstring
<span class="w"> </span>from jedi.inference.helpers import SimpleGetItemNotFound
<span class="w"> </span>from jedi.inference.utils import safe_property
<span class="w"> </span>from jedi.inference.cache import inference_state_as_method_param_cache
<span class="w"> </span>from jedi.cache import memoize_method
<span class="gi">+</span>
<span class="w"> </span>sentinel = object()


<span class="gu">@@ -24,13 +27,117 @@ class HasNoContext(Exception):</span>


<span class="w"> </span>class HelperValueMixin:
<span class="gd">-</span>
<span class="gd">-    def py__getattribute__(self, name_or_str, name_context=None, position=</span>
<span class="gd">-        None, analysis_errors=True):</span>
<span class="gi">+    def get_root_context(self):</span>
<span class="gi">+        value = self</span>
<span class="gi">+        if value.parent_context is None:</span>
<span class="gi">+            return value.as_context()</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if value.parent_context is None:</span>
<span class="gi">+                return value</span>
<span class="gi">+            value = value.parent_context</span>
<span class="gi">+</span>
<span class="gi">+    def execute(self, arguments):</span>
<span class="gi">+        return self.inference_state.execute(self, arguments=arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def execute_with_values(self, *value_list):</span>
<span class="gi">+        from jedi.inference.arguments import ValuesArguments</span>
<span class="gi">+        arguments = ValuesArguments([ValueSet([value]) for value in value_list])</span>
<span class="gi">+        return self.inference_state.execute(self, arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def execute_annotation(self):</span>
<span class="gi">+        return self.execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+    def gather_annotation_classes(self):</span>
<span class="gi">+        return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+    def merge_types_of_iterate(self, contextualized_node=None, is_async=False):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            lazy_value.infer()</span>
<span class="gi">+            for lazy_value in self.iterate(contextualized_node, is_async)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_value_filters(self, name_or_str):</span>
<span class="gi">+        origin_scope = name_or_str if isinstance(name_or_str, Name) else None</span>
<span class="gi">+        yield from self.get_filters(origin_scope=origin_scope)</span>
<span class="gi">+        # This covers the case where a stub files are incomplete.</span>
<span class="gi">+        if self.is_stub():</span>
<span class="gi">+            from jedi.inference.gradual.conversion import convert_values</span>
<span class="gi">+            for c in convert_values(ValueSet({self})):</span>
<span class="gi">+                yield from c.get_filters()</span>
<span class="gi">+</span>
<span class="gi">+    def goto(self, name_or_str, name_context=None, analysis_errors=True):</span>
<span class="gi">+        from jedi.inference import finder</span>
<span class="gi">+        filters = self._get_value_filters(name_or_str)</span>
<span class="gi">+        names = finder.filter_name(filters, name_or_str)</span>
<span class="gi">+        debug.dbg(&#39;context.goto %s in (%s): %s&#39;, name_or_str, self, names)</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def py__getattribute__(self, name_or_str, name_context=None, position=None,</span>
<span class="gi">+                           analysis_errors=True):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param position: Position of the last statement -&gt; tuple of line, column
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name_context is None:</span>
<span class="gi">+            name_context = self</span>
<span class="gi">+        names = self.goto(name_or_str, name_context, analysis_errors)</span>
<span class="gi">+        values = ValueSet.from_sets(name.infer() for name in names)</span>
<span class="gi">+        if not values:</span>
<span class="gi">+            n = name_or_str.value if isinstance(name_or_str, Name) else name_or_str</span>
<span class="gi">+            values = self.py__getattribute__alternatives(n)</span>
<span class="gi">+</span>
<span class="gi">+        if not names and not values and analysis_errors:</span>
<span class="gi">+            if isinstance(name_or_str, Name):</span>
<span class="gi">+                from jedi.inference import analysis</span>
<span class="gi">+                analysis.add_attribute_error(</span>
<span class="gi">+                    name_context, self, name_or_str)</span>
<span class="gi">+        debug.dbg(&#39;context.names_to_types: %s -&gt; %s&#39;, names, values)</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def py__await__(self):</span>
<span class="gi">+        await_value_set = self.py__getattribute__(&quot;__await__&quot;)</span>
<span class="gi">+        if not await_value_set:</span>
<span class="gi">+            debug.warning(&#39;Tried to run __await__ on value %s&#39;, self)</span>
<span class="gi">+        return await_value_set.execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.name.string_name</span>
<span class="gi">+</span>
<span class="gi">+    def iterate(self, contextualized_node=None, is_async=False):</span>
<span class="gi">+        debug.dbg(&#39;iterate %s&#39;, self)</span>
<span class="gi">+        if is_async:</span>
<span class="gi">+            from jedi.inference.lazy_value import LazyKnownValues</span>
<span class="gi">+            # TODO if no __aiter__ values are there, error should be:</span>
<span class="gi">+            # TypeError: &#39;async for&#39; requires an object with __aiter__ method, got int</span>
<span class="gi">+            return iter([</span>
<span class="gi">+                LazyKnownValues(</span>
<span class="gi">+                    self.py__getattribute__(&#39;__aiter__&#39;).execute_with_values()</span>
<span class="gi">+                        .py__getattribute__(&#39;__anext__&#39;).execute_with_values()</span>
<span class="gi">+                        .py__getattribute__(&#39;__await__&#39;).execute_with_values()</span>
<span class="gi">+                        .py__stop_iteration_returns()</span>
<span class="gi">+                )  # noqa: E124</span>
<span class="gi">+            ])</span>
<span class="gi">+        return self.py__iter__(contextualized_node)</span>
<span class="gi">+</span>
<span class="gi">+    def is_sub_class_of(self, class_value):</span>
<span class="gi">+        with debug.increase_indent_cm(&#39;subclass matching of %s &lt;=&gt; %s&#39; % (self, class_value),</span>
<span class="gi">+                                      color=&#39;BLUE&#39;):</span>
<span class="gi">+            for cls in self.py__mro__():</span>
<span class="gi">+                if cls.is_same_class(class_value):</span>
<span class="gi">+                    debug.dbg(&#39;matched subclass True&#39;, color=&#39;BLUE&#39;)</span>
<span class="gi">+                    return True</span>
<span class="gi">+            debug.dbg(&#39;matched subclass False&#39;, color=&#39;BLUE&#39;)</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_same_class(self, class2):</span>
<span class="gi">+        # Class matching should prefer comparisons that are not this function.</span>
<span class="gi">+        if type(class2).is_same_class != HelperValueMixin.is_same_class:</span>
<span class="gi">+            return class2.is_same_class(self)</span>
<span class="gi">+        return self == class2</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def as_context(self, *args, **kwargs):</span>
<span class="gi">+        return self._as_context(*args, **kwargs)</span>


<span class="w"> </span>class Value(HelperValueMixin):
<span class="gu">@@ -38,6 +145,8 @@ class Value(HelperValueMixin):</span>
<span class="w"> </span>    To be implemented by subclasses.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    tree_node = None
<span class="gi">+    # Possible values: None, tuple, list, dict and set. Here to deal with these</span>
<span class="gi">+    # very important containers.</span>
<span class="w"> </span>    array_type = None
<span class="w"> </span>    api_type = &#39;not_defined_please_report_bug&#39;

<span class="gu">@@ -45,18 +154,125 @@ class Value(HelperValueMixin):</span>
<span class="w"> </span>        self.inference_state = inference_state
<span class="w"> </span>        self.parent_context = parent_context

<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        from jedi.inference import analysis</span>
<span class="gi">+        # TODO this value is probably not right.</span>
<span class="gi">+        analysis.add(</span>
<span class="gi">+            contextualized_node.context,</span>
<span class="gi">+            &#39;type-error-not-subscriptable&#39;,</span>
<span class="gi">+            contextualized_node.node,</span>
<span class="gi">+            message=&quot;TypeError: &#39;%s&#39; object is not subscriptable&quot; % self</span>
<span class="gi">+        )</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        raise SimpleGetItemNotFound</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        if contextualized_node is not None:</span>
<span class="gi">+            from jedi.inference import analysis</span>
<span class="gi">+            analysis.add(</span>
<span class="gi">+                contextualized_node.context,</span>
<span class="gi">+                &#39;type-error-not-iterable&#39;,</span>
<span class="gi">+                contextualized_node.node,</span>
<span class="gi">+                message=&quot;TypeError: &#39;%s&#39; object is not iterable&quot; % self)</span>
<span class="gi">+        return iter([])</span>
<span class="gi">+</span>
<span class="gi">+    def py__next__(self, contextualized_node=None):</span>
<span class="gi">+        return self.py__iter__(contextualized_node)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_class_mixin(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_instance(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_function(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_module(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_namespace(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_compiled(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_bound_method(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_builtins_module(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="w"> </span>    def py__bool__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Since Wrapper is a super class for classes, functions and modules,
<span class="w"> </span>        the return value will always be true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.tree_node.get_doc_node</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return clean_scope_docstring(self.tree_node)</span>
<span class="gi">+</span>
<span class="gi">+    def get_safe_value(self, default=sentinel):</span>
<span class="gi">+        if default is sentinel:</span>
<span class="gi">+            raise ValueError(&quot;There exists no safe value for value %s&quot; % self)</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def execute_operation(self, other, operator):</span>
<span class="gi">+        debug.warning(&quot;%s not possible between %s and %s&quot;, operator, self, other)</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        debug.warning(&quot;no execution possible %s&quot;, self)</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def py__stop_iteration_returns(self):</span>
<span class="gi">+        debug.warning(&quot;Not possible to return the stop iterations of %s&quot;, self)</span>
<span class="gi">+        return NO_VALUES</span>

<span class="w"> </span>    def py__getattribute__alternatives(self, name_or_str):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For now a way to add values in cases like __getattr__.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        debug.warning(&quot;No __get__ defined on %s&quot;, self)</span>
<span class="gi">+        return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+    def py__get__on_class(self, calling_instance, instance, class_value):</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        # Returns Optional[Tuple[str, ...]]</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        # The root value knows if it&#39;s a stub or not.</span>
<span class="gi">+        return self.parent_context.is_stub()</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        raise HasNoContext</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def infer_type_vars(self, value_set):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -85,7 +301,7 @@ class Value(HelperValueMixin):</span>
<span class="w"> </span>            above example this would first be the representation of the list
<span class="w"> </span>            `[1]` and then, when recursing, just of `1`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {}</span>


<span class="w"> </span>def iterate_values(values, contextualized_node=None, is_async=False):
<span class="gu">@@ -93,10 +309,27 @@ def iterate_values(values, contextualized_node=None, is_async=False):</span>
<span class="w"> </span>    Calls `iterate`, on all values but ignores the ordering and just returns
<span class="w"> </span>    all values that the iterate functions yield.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return ValueSet.from_sets(</span>
<span class="gi">+        lazy_value.infer()</span>
<span class="gi">+        for lazy_value in values.iterate(contextualized_node, is_async=is_async)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class _ValueWrapperBase(HelperValueMixin):
<span class="gi">+    @safe_property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        from jedi.inference.names import ValueName</span>
<span class="gi">+        wrapped_name = self._wrapped_value.name</span>
<span class="gi">+        if wrapped_name.tree_name is not None:</span>
<span class="gi">+            return ValueName(self, wrapped_name.tree_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            from jedi.inference.compiled import CompiledValueName</span>
<span class="gi">+            return CompiledValueName(self, wrapped_name.string_name)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @inference_state_as_method_param_cache()</span>
<span class="gi">+    def create_cached(cls, inference_state, *args, **kwargs):</span>
<span class="gi">+        return cls(*args, **kwargs)</span>

<span class="w"> </span>    def __getattr__(self, name):
<span class="w"> </span>        assert name != &#39;_wrapped_value&#39;, &#39;Problem with _get_wrapped_value&#39;
<span class="gu">@@ -104,13 +337,20 @@ class _ValueWrapperBase(HelperValueMixin):</span>


<span class="w"> </span>class LazyValueWrapper(_ValueWrapperBase):
<span class="gi">+    @safe_property</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _wrapped_value(self):</span>
<span class="gi">+        with debug.increase_indent_cm(&#39;Resolve lazy value wrapper&#39;):</span>
<span class="gi">+            return self._get_wrapped_value()</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s&gt;&#39; % self.__class__.__name__</span>
<span class="gi">+        return &#39;&lt;%s&gt;&#39; % (self.__class__.__name__)</span>

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-class ValueWrapper(_ValueWrapperBase):</span>

<span class="gi">+class ValueWrapper(_ValueWrapperBase):</span>
<span class="w"> </span>    def __init__(self, wrapped_value):
<span class="w"> </span>        self._wrapped_value = wrapped_value

<span class="gu">@@ -119,7 +359,6 @@ class ValueWrapper(_ValueWrapperBase):</span>


<span class="w"> </span>class TreeValue(Value):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, parent_context, tree_node):
<span class="w"> </span>        super().__init__(inference_state, parent_context)
<span class="w"> </span>        self.tree_node = tree_node
<span class="gu">@@ -129,29 +368,71 @@ class TreeValue(Value):</span>


<span class="w"> </span>class ContextualizedNode:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, context, node):
<span class="w"> </span>        self.context = context
<span class="w"> </span>        self.node = node

<span class="gi">+    def get_root_context(self):</span>
<span class="gi">+        return self.context.get_root_context()</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return self.context.infer_node(self.node)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: %s in %s&gt;&#39; % (self.__class__.__name__, self.node, self</span>
<span class="gd">-            .context)</span>
<span class="gi">+        return &#39;&lt;%s: %s in %s&gt;&#39; % (self.__class__.__name__, self.node, self.context)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _getitem(value, index_values, contextualized_node):</span>
<span class="gi">+    # The actual getitem call.</span>
<span class="gi">+    result = NO_VALUES</span>
<span class="gi">+    unused_values = set()</span>
<span class="gi">+    for index_value in index_values:</span>
<span class="gi">+        index = index_value.get_safe_value(default=None)</span>
<span class="gi">+        if type(index) in (float, int, str, slice, bytes):</span>
<span class="gi">+            try:</span>
<span class="gi">+                result |= value.py__simple_getitem__(index)</span>
<span class="gi">+                continue</span>
<span class="gi">+            except SimpleGetItemNotFound:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        unused_values.add(index_value)</span>
<span class="gi">+</span>
<span class="gi">+    # The index was somehow not good enough or simply a wrong type.</span>
<span class="gi">+    # Therefore we now iterate through all the values and just take</span>
<span class="gi">+    # all results.</span>
<span class="gi">+    if unused_values or not index_values:</span>
<span class="gi">+        result |= value.py__getitem__(</span>
<span class="gi">+            ValueSet(unused_values),</span>
<span class="gi">+            contextualized_node</span>
<span class="gi">+        )</span>
<span class="gi">+    debug.dbg(&#39;py__getitem__ result: %s&#39;, result)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class ValueSet:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, iterable):
<span class="w"> </span>        self._set = frozenset(iterable)
<span class="w"> </span>        for value in iterable:
<span class="w"> </span>            assert not isinstance(value, ValueSet)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_frozen_set(cls, frozenset_):</span>
<span class="gi">+        self = cls.__new__(cls)</span>
<span class="gi">+        self._set = frozenset_</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_sets(cls, sets):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used to work with an iterable of set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        aggregated = set()</span>
<span class="gi">+        for set_ in sets:</span>
<span class="gi">+            if isinstance(set_, ValueSet):</span>
<span class="gi">+                aggregated |= set_._set</span>
<span class="gi">+            else:</span>
<span class="gi">+                aggregated |= frozenset(set_)</span>
<span class="gi">+        return cls._from_frozen_set(frozenset(aggregated))</span>

<span class="w"> </span>    def __or__(self, other):
<span class="w"> </span>        return self._from_frozen_set(self._set | other._set)
<span class="gu">@@ -169,13 +450,17 @@ class ValueSet:</span>
<span class="w"> </span>        return len(self._set)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;S{%s}&#39; % &#39;, &#39;.join(str(s) for s in self._set)</span>
<span class="gi">+        return &#39;S{%s}&#39; % (&#39;, &#39;.join(str(s) for s in self._set))</span>

<span class="gd">-    def __getattr__(self, name):</span>
<span class="gi">+    def filter(self, filter_func):</span>
<span class="gi">+        return self.__class__(filter(filter_func, self._set))</span>

<span class="gi">+    def __getattr__(self, name):</span>
<span class="w"> </span>        def mapper(*args, **kwargs):
<span class="gd">-            return self.from_sets(getattr(value, name)(*args, **kwargs) for</span>
<span class="gd">-                value in self._set)</span>
<span class="gi">+            return self.from_sets(</span>
<span class="gi">+                getattr(value, name)(*args, **kwargs)</span>
<span class="gi">+                for value in self._set</span>
<span class="gi">+            )</span>
<span class="w"> </span>        return mapper

<span class="w"> </span>    def __eq__(self, other):
<span class="gu">@@ -187,5 +472,87 @@ class ValueSet:</span>
<span class="w"> </span>    def __hash__(self):
<span class="w"> </span>        return hash(self._set)

<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return ValueSet(c.py__class__() for c in self._set)</span>
<span class="gi">+</span>
<span class="gi">+    def iterate(self, contextualized_node=None, is_async=False):</span>
<span class="gi">+        from jedi.inference.lazy_value import get_merged_lazy_value</span>
<span class="gi">+        type_iters = [c.iterate(contextualized_node, is_async=is_async) for c in self._set]</span>
<span class="gi">+        for lazy_values in zip_longest(*type_iters):</span>
<span class="gi">+            yield get_merged_lazy_value(</span>
<span class="gi">+                [l for l in lazy_values if l is not None]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def execute(self, arguments):</span>
<span class="gi">+        return ValueSet.from_sets(c.inference_state.execute(c, arguments) for c in self._set)</span>
<span class="gi">+</span>
<span class="gi">+    def execute_with_values(self, *args, **kwargs):</span>
<span class="gi">+        return ValueSet.from_sets(c.execute_with_values(*args, **kwargs) for c in self._set)</span>
<span class="gi">+</span>
<span class="gi">+    def goto(self, *args, **kwargs):</span>
<span class="gi">+        return reduce(add, [c.goto(*args, **kwargs) for c in self._set], [])</span>
<span class="gi">+</span>
<span class="gi">+    def py__getattribute__(self, *args, **kwargs):</span>
<span class="gi">+        return ValueSet.from_sets(c.py__getattribute__(*args, **kwargs) for c in self._set)</span>
<span class="gi">+</span>
<span class="gi">+    def get_item(self, *args, **kwargs):</span>
<span class="gi">+        return ValueSet.from_sets(_getitem(c, *args, **kwargs) for c in self._set)</span>
<span class="gi">+</span>
<span class="gi">+    def try_merge(self, function_name):</span>
<span class="gi">+        value_set = self.__class__([])</span>
<span class="gi">+        for c in self._set:</span>
<span class="gi">+            try:</span>
<span class="gi">+                method = getattr(c, function_name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                value_set |= method()</span>
<span class="gi">+        return value_set</span>
<span class="gi">+</span>
<span class="gi">+    def gather_annotation_classes(self):</span>
<span class="gi">+        return ValueSet.from_sets([c.gather_annotation_classes() for c in self._set])</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [sig for c in self._set for sig in c.get_signatures()]</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        t = [v.get_type_hint(add_class_info=add_class_info) for v in self._set]</span>
<span class="gi">+        type_hints = sorted(filter(None, t))</span>
<span class="gi">+        if len(type_hints) == 1:</span>
<span class="gi">+            return type_hints[0]</span>
<span class="gi">+</span>
<span class="gi">+        optional = &#39;None&#39; in type_hints</span>
<span class="gi">+        if optional:</span>
<span class="gi">+            type_hints.remove(&#39;None&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if len(type_hints) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif len(type_hints) == 1:</span>
<span class="gi">+            s = type_hints[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = &#39;Union[%s]&#39; % &#39;, &#39;.join(type_hints)</span>
<span class="gi">+        if optional:</span>
<span class="gi">+            s = &#39;Optional[%s]&#39; % s</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        # Circular</span>
<span class="gi">+        from jedi.inference.gradual.annotation import merge_type_var_dicts</span>
<span class="gi">+</span>
<span class="gi">+        type_var_dict = {}</span>
<span class="gi">+        for value in self._set:</span>
<span class="gi">+            merge_type_var_dicts(</span>
<span class="gi">+                type_var_dict,</span>
<span class="gi">+                value.infer_type_vars(value_set),</span>
<span class="gi">+            )</span>
<span class="gi">+        return type_var_dict</span>
<span class="gi">+</span>

<span class="w"> </span>NO_VALUES = ValueSet([])
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iterator_to_value_set(func):</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        return ValueSet(func(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/inference/cache.py b/jedi/inference/cache.py</span>
<span class="gh">index e584319c..8360a42a 100644</span>
<span class="gd">--- a/jedi/inference/cache.py</span>
<span class="gi">+++ b/jedi/inference/cache.py</span>
<span class="gu">@@ -4,13 +4,15 @@</span>
<span class="w"> </span>- ``CachedMetaClass`` uses ``_memoize_default`` to do the same with classes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from functools import wraps
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="gi">+</span>
<span class="w"> </span>_NO_DEFAULT = object()
<span class="w"> </span>_RECURSION_SENTINEL = object()


<span class="gd">-def _memoize_default(default=_NO_DEFAULT, inference_state_is_first_arg=</span>
<span class="gd">-    False, second_arg_is_inference_state=False):</span>
<span class="gi">+def _memoize_default(default=_NO_DEFAULT, inference_state_is_first_arg=False,</span>
<span class="gi">+                     second_arg_is_inference_state=False):</span>
<span class="w"> </span>    &quot;&quot;&quot; This is a typical memoization decorator, BUT there is one difference:
<span class="w"> </span>    To prevent recursion it sets defaults.

<span class="gu">@@ -18,7 +20,54 @@ def _memoize_default(default=_NO_DEFAULT, inference_state_is_first_arg=</span>
<span class="w"> </span>    don&#39;t think, that there is a big speed difference, but there are many cases
<span class="w"> </span>    where recursion could happen (think about a = b; b = a).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def func(function):</span>
<span class="gi">+        def wrapper(obj, *args, **kwargs):</span>
<span class="gi">+            # TODO These checks are kind of ugly and slow.</span>
<span class="gi">+            if inference_state_is_first_arg:</span>
<span class="gi">+                cache = obj.memoize_cache</span>
<span class="gi">+            elif second_arg_is_inference_state:</span>
<span class="gi">+                cache = args[0].memoize_cache  # needed for meta classes</span>
<span class="gi">+            else:</span>
<span class="gi">+                cache = obj.inference_state.memoize_cache</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                memo = cache[function]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                cache[function] = memo = {}</span>
<span class="gi">+</span>
<span class="gi">+            key = (obj, args, frozenset(kwargs.items()))</span>
<span class="gi">+            if key in memo:</span>
<span class="gi">+                return memo[key]</span>
<span class="gi">+            else:</span>
<span class="gi">+                if default is not _NO_DEFAULT:</span>
<span class="gi">+                    memo[key] = default</span>
<span class="gi">+                rv = function(obj, *args, **kwargs)</span>
<span class="gi">+                memo[key] = rv</span>
<span class="gi">+                return rv</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inference_state_function_cache(default=_NO_DEFAULT):</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        return _memoize_default(default=default, inference_state_is_first_arg=True)(func)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inference_state_method_cache(default=_NO_DEFAULT):</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        return _memoize_default(default=default)(func)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inference_state_as_method_param_cache():</span>
<span class="gi">+    def decorator(call):</span>
<span class="gi">+        return _memoize_default(second_arg_is_inference_state=True)(call)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>class CachedMetaClass(type):
<span class="gu">@@ -27,7 +76,6 @@ class CachedMetaClass(type):</span>
<span class="w"> </span>    class initializations. Either you do it this way or with decorators, but
<span class="w"> </span>    with decorators you lose class access (isinstance, etc).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    @inference_state_as_method_param_cache()
<span class="w"> </span>    def __call__(self, *args, **kwargs):
<span class="w"> </span>        return super().__call__(*args, **kwargs)
<span class="gu">@@ -38,4 +86,41 @@ def inference_state_method_generator_cache():</span>
<span class="w"> </span>    This is a special memoizer. It memoizes generators and also checks for
<span class="w"> </span>    recursion errors and returns no further iterator elemends in that case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def func(function):</span>
<span class="gi">+        @wraps(function)</span>
<span class="gi">+        def wrapper(obj, *args, **kwargs):</span>
<span class="gi">+            cache = obj.inference_state.memoize_cache</span>
<span class="gi">+            try:</span>
<span class="gi">+                memo = cache[function]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                cache[function] = memo = {}</span>
<span class="gi">+</span>
<span class="gi">+            key = (obj, args, frozenset(kwargs.items()))</span>
<span class="gi">+</span>
<span class="gi">+            if key in memo:</span>
<span class="gi">+                actual_generator, cached_lst = memo[key]</span>
<span class="gi">+            else:</span>
<span class="gi">+                actual_generator = function(obj, *args, **kwargs)</span>
<span class="gi">+                cached_lst = []</span>
<span class="gi">+                memo[key] = actual_generator, cached_lst</span>
<span class="gi">+</span>
<span class="gi">+            i = 0</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    next_element = cached_lst[i]</span>
<span class="gi">+                    if next_element is _RECURSION_SENTINEL:</span>
<span class="gi">+                        debug.warning(&#39;Found a generator recursion for %s&#39; % obj)</span>
<span class="gi">+                        # This means we have hit a recursion.</span>
<span class="gi">+                        return</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    cached_lst.append(_RECURSION_SENTINEL)</span>
<span class="gi">+                    next_element = next(actual_generator, None)</span>
<span class="gi">+                    if next_element is None:</span>
<span class="gi">+                        cached_lst.pop()</span>
<span class="gi">+                        return</span>
<span class="gi">+                    cached_lst[-1] = next_element</span>
<span class="gi">+                yield next_element</span>
<span class="gi">+                i += 1</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return func</span>
<span class="gh">diff --git a/jedi/inference/compiled/access.py b/jedi/inference/compiled/access.py</span>
<span class="gh">index 2da304b3..09ed1b64 100644</span>
<span class="gd">--- a/jedi/inference/compiled/access.py</span>
<span class="gi">+++ b/jedi/inference/compiled/access.py</span>
<span class="gu">@@ -10,40 +10,161 @@ import builtins</span>
<span class="w"> </span>import typing
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Optional, Tuple
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.compiled.getattr_static import getattr_static
<span class="gd">-ALLOWED_GETITEM_TYPES = str, list, tuple, bytes, bytearray, dict</span>
<span class="gi">+</span>
<span class="gi">+ALLOWED_GETITEM_TYPES = (str, list, tuple, bytes, bytearray, dict)</span>
<span class="gi">+</span>
<span class="w"> </span>MethodDescriptorType = type(str.replace)
<span class="gd">-NOT_CLASS_TYPES = (types.BuiltinFunctionType, types.CodeType, types.</span>
<span class="gd">-    FrameType, types.FunctionType, types.GeneratorType, types.</span>
<span class="gd">-    GetSetDescriptorType, types.LambdaType, types.MemberDescriptorType,</span>
<span class="gd">-    types.MethodType, types.ModuleType, types.TracebackType,</span>
<span class="gd">-    MethodDescriptorType, types.MappingProxyType, types.SimpleNamespace,</span>
<span class="gd">-    types.DynamicClassAttribute)</span>
<span class="gi">+# These are not considered classes and access is granted even though they have</span>
<span class="gi">+# a __class__ attribute.</span>
<span class="gi">+NOT_CLASS_TYPES = (</span>
<span class="gi">+    types.BuiltinFunctionType,</span>
<span class="gi">+    types.CodeType,</span>
<span class="gi">+    types.FrameType,</span>
<span class="gi">+    types.FunctionType,</span>
<span class="gi">+    types.GeneratorType,</span>
<span class="gi">+    types.GetSetDescriptorType,</span>
<span class="gi">+    types.LambdaType,</span>
<span class="gi">+    types.MemberDescriptorType,</span>
<span class="gi">+    types.MethodType,</span>
<span class="gi">+    types.ModuleType,</span>
<span class="gi">+    types.TracebackType,</span>
<span class="gi">+    MethodDescriptorType,</span>
<span class="gi">+    types.MappingProxyType,</span>
<span class="gi">+    types.SimpleNamespace,</span>
<span class="gi">+    types.DynamicClassAttribute,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# Those types don&#39;t exist in typing.</span>
<span class="w"> </span>MethodDescriptorType = type(str.replace)
<span class="w"> </span>WrapperDescriptorType = type(set.__iter__)
<span class="gd">-object_class_dict = type.__dict__[&#39;__dict__&#39;].__get__(object)</span>
<span class="gi">+# `object.__subclasshook__` is an already executed descriptor.</span>
<span class="gi">+object_class_dict = type.__dict__[&quot;__dict__&quot;].__get__(object)  # type: ignore[index]</span>
<span class="w"> </span>ClassMethodDescriptorType = type(object_class_dict[&#39;__subclasshook__&#39;])
<span class="gi">+</span>
<span class="w"> </span>_sentinel = object()
<span class="gd">-COMPARISON_OPERATORS = {&#39;==&#39;: op.eq, &#39;!=&#39;: op.ne, &#39;is&#39;: op.is_, &#39;is not&#39;:</span>
<span class="gd">-    op.is_not, &#39;&lt;&#39;: op.lt, &#39;&lt;=&#39;: op.le, &#39;&gt;&#39;: op.gt, &#39;&gt;=&#39;: op.ge}</span>
<span class="gd">-_OPERATORS = {&#39;+&#39;: op.add, &#39;-&#39;: op.sub}</span>
<span class="gi">+</span>
<span class="gi">+# Maps Python syntax to the operator module.</span>
<span class="gi">+COMPARISON_OPERATORS = {</span>
<span class="gi">+    &#39;==&#39;: op.eq,</span>
<span class="gi">+    &#39;!=&#39;: op.ne,</span>
<span class="gi">+    &#39;is&#39;: op.is_,</span>
<span class="gi">+    &#39;is not&#39;: op.is_not,</span>
<span class="gi">+    &#39;&lt;&#39;: op.lt,</span>
<span class="gi">+    &#39;&lt;=&#39;: op.le,</span>
<span class="gi">+    &#39;&gt;&#39;: op.gt,</span>
<span class="gi">+    &#39;&gt;=&#39;: op.ge,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+_OPERATORS = {</span>
<span class="gi">+    &#39;+&#39;: op.add,</span>
<span class="gi">+    &#39;-&#39;: op.sub,</span>
<span class="gi">+}</span>
<span class="w"> </span>_OPERATORS.update(COMPARISON_OPERATORS)
<span class="gd">-ALLOWED_DESCRIPTOR_ACCESS = (types.FunctionType, types.GetSetDescriptorType,</span>
<span class="gd">-    types.MemberDescriptorType, MethodDescriptorType, WrapperDescriptorType,</span>
<span class="gd">-    ClassMethodDescriptorType, staticmethod, classmethod)</span>
<span class="gd">-SignatureParam = namedtuple(&#39;SignatureParam&#39;,</span>
<span class="gi">+</span>
<span class="gi">+ALLOWED_DESCRIPTOR_ACCESS = (</span>
<span class="gi">+    types.FunctionType,</span>
<span class="gi">+    types.GetSetDescriptorType,</span>
<span class="gi">+    types.MemberDescriptorType,</span>
<span class="gi">+    MethodDescriptorType,</span>
<span class="gi">+    WrapperDescriptorType,</span>
<span class="gi">+    ClassMethodDescriptorType,</span>
<span class="gi">+    staticmethod,</span>
<span class="gi">+    classmethod,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safe_getattr(obj, name, default=_sentinel):</span>
<span class="gi">+    try:</span>
<span class="gi">+        attr, is_get_descriptor = getattr_static(obj, name)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        if default is _sentinel:</span>
<span class="gi">+            raise</span>
<span class="gi">+        return default</span>
<span class="gi">+    else:</span>
<span class="gi">+        if isinstance(attr, ALLOWED_DESCRIPTOR_ACCESS):</span>
<span class="gi">+            # In case of descriptors that have get methods we cannot return</span>
<span class="gi">+            # it&#39;s value, because that would mean code execution.</span>
<span class="gi">+            # Since it&#39;s an isinstance call, code execution is still possible,</span>
<span class="gi">+            # but this is not really a security feature, but much more of a</span>
<span class="gi">+            # safety feature. Code execution is basically always possible when</span>
<span class="gi">+            # a module is imported. This is here so people don&#39;t shoot</span>
<span class="gi">+            # themselves in the foot.</span>
<span class="gi">+            return getattr(obj, name)</span>
<span class="gi">+    return attr</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+SignatureParam = namedtuple(</span>
<span class="gi">+    &#39;SignatureParam&#39;,</span>
<span class="w"> </span>    &#39;name has_default default default_string has_annotation annotation annotation_string kind_name&#39;
<span class="gd">-    )</span>
<span class="gi">+)</span>


<span class="gd">-class AccessPath:</span>
<span class="gi">+def shorten_repr(func):</span>
<span class="gi">+    def wrapper(self):</span>
<span class="gi">+        r = func(self)</span>
<span class="gi">+        if len(r) &gt; 50:</span>
<span class="gi">+            r = r[:50] + &#39;..&#39;</span>
<span class="gi">+        return r</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_access(inference_state, obj):</span>
<span class="gi">+    return inference_state.compiled_subprocess.get_or_create_access_handle(obj)</span>
<span class="gi">+</span>

<span class="gi">+def load_module(inference_state, dotted_name, sys_path):</span>
<span class="gi">+    temp, sys.path = sys.path, sys_path</span>
<span class="gi">+    try:</span>
<span class="gi">+        __import__(dotted_name)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        # If a module is &quot;corrupt&quot; or not really a Python module or whatever.</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Module %s not importable in path %s.&quot; % (dotted_name, sys_path),</span>
<span class="gi">+            UserWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return None</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        # Since __import__ pretty much makes code execution possible, just</span>
<span class="gi">+        # catch any error here and print it.</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Cannot import:\n%s&quot; % traceback.format_exc(), UserWarning, stacklevel=2</span>
<span class="gi">+        )</span>
<span class="gi">+        return None</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.path = temp</span>
<span class="gi">+</span>
<span class="gi">+    # Just access the cache after import, because of #59 as well as the very</span>
<span class="gi">+    # complicated import structure of Python.</span>
<span class="gi">+    module = sys.modules[dotted_name]</span>
<span class="gi">+    return create_access_path(inference_state, module)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class AccessPath:</span>
<span class="w"> </span>    def __init__(self, accesses):
<span class="w"> </span>        self.accesses = accesses


<span class="gd">-class DirectObjectAccess:</span>
<span class="gi">+def create_access_path(inference_state, obj) -&gt; AccessPath:</span>
<span class="gi">+    access = create_access(inference_state, obj)</span>
<span class="gi">+    return AccessPath(access.get_access_path_tuples())</span>

<span class="gi">+</span>
<span class="gi">+def get_api_type(obj):</span>
<span class="gi">+    if inspect.isclass(obj):</span>
<span class="gi">+        return &#39;class&#39;</span>
<span class="gi">+    elif inspect.ismodule(obj):</span>
<span class="gi">+        return &#39;module&#39;</span>
<span class="gi">+    elif inspect.isbuiltin(obj) or inspect.ismethod(obj) \</span>
<span class="gi">+            or inspect.ismethoddescriptor(obj) or inspect.isfunction(obj):</span>
<span class="gi">+        return &#39;function&#39;</span>
<span class="gi">+    # Everything else...</span>
<span class="gi">+    return &#39;instance&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class DirectObjectAccess:</span>
<span class="w"> </span>    def __init__(self, inference_state, obj):
<span class="w"> </span>        self._inference_state = inference_state
<span class="w"> </span>        self._obj = obj
<span class="gu">@@ -51,20 +172,391 @@ class DirectObjectAccess:</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s)&#39; % (self.__class__.__name__, self.get_repr())

<span class="gi">+    def _create_access(self, obj):</span>
<span class="gi">+        return create_access(self._inference_state, obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_access_path(self, obj) -&gt; AccessPath:</span>
<span class="gi">+        return create_access_path(self._inference_state, obj)</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        return bool(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return Path(self._obj.__file__)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return inspect.getdoc(self._obj) or &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        if not _is_class_instance(self._obj) or \</span>
<span class="gi">+                inspect.ismethoddescriptor(self._obj):  # slots</span>
<span class="gi">+            cls = self._obj</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                cls = self._obj.__class__</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                # happens with numpy.core.umath._UFUNC_API (you get it</span>
<span class="gi">+                # automatically by doing `import numpy`.</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return cls.__name__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def py__mro__accesses(self):</span>
<span class="gi">+        return tuple(self._create_access_path(cls) for cls in self._obj.__mro__[1:])</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__all_values(self):</span>
<span class="gi">+        if isinstance(self._obj, dict):</span>
<span class="gi">+            return [self._create_access_path(v) for v in self._obj.values()]</span>
<span class="gi">+        if isinstance(self._obj, (list, tuple)):</span>
<span class="gi">+            return [self._create_access_path(v) for v in self._obj]</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_instance():</span>
<span class="gi">+            cls = DirectObjectAccess(self._inference_state, self._obj.__class__)</span>
<span class="gi">+            return cls.py__getitem__all_values()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            getitem = self._obj.__getitem__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            annotation = DirectObjectAccess(self._inference_state, getitem).get_return_annotation()</span>
<span class="gi">+            if annotation is not None:</span>
<span class="gi">+                return [annotation]</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index, *, safe=True):</span>
<span class="gi">+        if safe and type(self._obj) not in ALLOWED_GETITEM_TYPES:</span>
<span class="gi">+            # Get rid of side effects, we won&#39;t call custom `__getitem__`s.</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return self._create_access_path(self._obj[index])</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__list(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            iter_method = self._obj.__iter__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            p = DirectObjectAccess(self._inference_state, iter_method).get_return_annotation()</span>
<span class="gi">+            if p is not None:</span>
<span class="gi">+                return [p]</span>
<span class="gi">+</span>
<span class="gi">+        if type(self._obj) not in ALLOWED_GETITEM_TYPES:</span>
<span class="gi">+            # Get rid of side effects, we won&#39;t call custom `__getitem__`s.</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        lst = []</span>
<span class="gi">+        for i, part in enumerate(self._obj):</span>
<span class="gi">+            if i &gt; 20:</span>
<span class="gi">+                # Should not go crazy with large iterators</span>
<span class="gi">+                break</span>
<span class="gi">+            lst.append(self._create_access_path(part))</span>
<span class="gi">+        return lst</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return self._create_access_path(self._obj.__class__)</span>
<span class="gi">+</span>
<span class="gi">+    def py__bases__(self):</span>
<span class="gi">+        return [self._create_access_path(base) for base in self._obj.__bases__]</span>
<span class="gi">+</span>
<span class="gi">+    def py__path__(self):</span>
<span class="gi">+        paths = getattr(self._obj, &#39;__path__&#39;, None)</span>
<span class="gi">+        # Avoid some weird hacks that would just fail, because they cannot be</span>
<span class="gi">+        # used by pickle.</span>
<span class="gi">+        if not isinstance(paths, list) \</span>
<span class="gi">+                or not all(isinstance(p, str) for p in paths):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return paths</span>
<span class="gi">+</span>
<span class="gi">+    @shorten_repr</span>
<span class="gi">+    def get_repr(self):</span>
<span class="gi">+        if inspect.ismodule(self._obj):</span>
<span class="gi">+            return repr(self._obj)</span>
<span class="gi">+        # Try to avoid execution of the property.</span>
<span class="gi">+        if safe_getattr(self._obj, &#39;__module__&#39;, default=&#39;&#39;) == &#39;builtins&#39;:</span>
<span class="gi">+            return repr(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+        type_ = type(self._obj)</span>
<span class="gi">+        if type_ == type:</span>
<span class="gi">+            return type.__repr__(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+        if safe_getattr(type_, &#39;__module__&#39;, default=&#39;&#39;) == &#39;builtins&#39;:</span>
<span class="gi">+            # Allow direct execution of repr for builtins.</span>
<span class="gi">+            return repr(self._obj)</span>
<span class="gi">+        return object.__repr__(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return inspect.isclass(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def is_function(self):</span>
<span class="gi">+        return inspect.isfunction(self._obj) or inspect.ismethod(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def is_module(self):</span>
<span class="gi">+        return inspect.ismodule(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def is_instance(self):</span>
<span class="gi">+        return _is_class_instance(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def ismethoddescriptor(self):</span>
<span class="gi">+        return inspect.ismethoddescriptor(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        def try_to_get_name(obj):</span>
<span class="gi">+            return getattr(obj, &#39;__qualname__&#39;, getattr(obj, &#39;__name__&#39;, None))</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_module():</span>
<span class="gi">+            return ()</span>
<span class="gi">+        name = try_to_get_name(self._obj)</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            name = try_to_get_name(type(self._obj))</span>
<span class="gi">+            if name is None:</span>
<span class="gi">+                return ()</span>
<span class="gi">+        return tuple(name.split(&#39;.&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def dir(self):</span>
<span class="gi">+        return dir(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def has_iter(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            iter(self._obj)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_allowed_getattr(self, name, safe=True) -&gt; Tuple[bool, bool, Optional[AccessPath]]:</span>
<span class="gi">+        # TODO this API is ugly.</span>
<span class="gi">+        try:</span>
<span class="gi">+            attr, is_get_descriptor = getattr_static(self._obj, name)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            if not safe:</span>
<span class="gi">+                # Unsafe is mostly used to check for __getattr__/__getattribute__.</span>
<span class="gi">+                # getattr_static works for properties, but the underscore methods</span>
<span class="gi">+                # are just ignored (because it&#39;s safer and avoids more code</span>
<span class="gi">+                # execution). See also GH #1378.</span>
<span class="gi">+</span>
<span class="gi">+                # Avoid warnings, see comment in the next function.</span>
<span class="gi">+                with warnings.catch_warnings(record=True):</span>
<span class="gi">+                    warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return hasattr(self._obj, name), False, None</span>
<span class="gi">+                    except Exception:</span>
<span class="gi">+                        # Obviously has an attribute (probably a property) that</span>
<span class="gi">+                        # gets executed, so just avoid all exceptions here.</span>
<span class="gi">+                        pass</span>
<span class="gi">+            return False, False, None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if is_get_descriptor and type(attr) not in ALLOWED_DESCRIPTOR_ACCESS:</span>
<span class="gi">+                if isinstance(attr, property):</span>
<span class="gi">+                    if hasattr(attr.fget, &#39;__annotations__&#39;):</span>
<span class="gi">+                        a = DirectObjectAccess(self._inference_state, attr.fget)</span>
<span class="gi">+                        return True, True, a.get_return_annotation()</span>
<span class="gi">+                # In case of descriptors that have get methods we cannot return</span>
<span class="gi">+                # it&#39;s value, because that would mean code execution.</span>
<span class="gi">+                return True, True, None</span>
<span class="gi">+        return True, False, None</span>
<span class="gi">+</span>
<span class="gi">+    def getattr_paths(self, name, default=_sentinel):</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Make sure no warnings are printed here, this is autocompletion,</span>
<span class="gi">+            # warnings should not be shown. See also GH #1383.</span>
<span class="gi">+            with warnings.catch_warnings(record=True):</span>
<span class="gi">+                warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+                return_obj = getattr(self._obj, name)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            if default is _sentinel:</span>
<span class="gi">+                if isinstance(e, AttributeError):</span>
<span class="gi">+                    # Happens e.g. in properties of</span>
<span class="gi">+                    # PyQt4.QtGui.QStyleOptionComboBox.currentText</span>
<span class="gi">+                    # -&gt; just set it to None</span>
<span class="gi">+                    raise</span>
<span class="gi">+                # Just in case anything happens, return an AttributeError. It</span>
<span class="gi">+                # should not crash.</span>
<span class="gi">+                raise AttributeError</span>
<span class="gi">+            return_obj = default</span>
<span class="gi">+        access = self._create_access(return_obj)</span>
<span class="gi">+        if inspect.ismodule(return_obj):</span>
<span class="gi">+            return [access]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = return_obj.__module__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if module is not None and isinstance(module, str):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    __import__(module)</span>
<span class="gi">+                    # For some modules like _sqlite3, the __module__ for classes is</span>
<span class="gi">+                    # different, in this case it&#39;s sqlite3. So we have to try to</span>
<span class="gi">+                    # load that &quot;original&quot; module, because it&#39;s not loaded yet. If</span>
<span class="gi">+                    # we don&#39;t do that, we don&#39;t really have a &quot;parent&quot; module and</span>
<span class="gi">+                    # we would fall back to builtins.</span>
<span class="gi">+                except ImportError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+        module = inspect.getmodule(return_obj)</span>
<span class="gi">+        if module is None:</span>
<span class="gi">+            module = inspect.getmodule(type(return_obj))</span>
<span class="gi">+            if module is None:</span>
<span class="gi">+                module = builtins</span>
<span class="gi">+        return [self._create_access(module), access]</span>
<span class="gi">+</span>
<span class="gi">+    def get_safe_value(self):</span>
<span class="gi">+        if type(self._obj) in (bool, bytes, float, int, str, slice) or self._obj is None:</span>
<span class="gi">+            return self._obj</span>
<span class="gi">+        raise ValueError(&quot;Object is type %s and not simple&quot; % type(self._obj))</span>
<span class="gi">+</span>
<span class="gi">+    def get_api_type(self):</span>
<span class="gi">+        return get_api_type(self._obj)</span>
<span class="gi">+</span>
<span class="gi">+    def get_array_type(self):</span>
<span class="gi">+        if isinstance(self._obj, dict):</span>
<span class="gi">+            return &#39;dict&#39;</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_paths(self):</span>
<span class="gi">+        def iter_partial_keys():</span>
<span class="gi">+            # We could use list(keys()), but that might take a lot more memory.</span>
<span class="gi">+            for (i, k) in enumerate(self._obj.keys()):</span>
<span class="gi">+                # Limit key listing at some point. This is artificial, but this</span>
<span class="gi">+                # way we don&#39;t get stalled because of slow completions</span>
<span class="gi">+                if i &gt; 50:</span>
<span class="gi">+                    break</span>
<span class="gi">+                yield k</span>
<span class="gi">+</span>
<span class="gi">+        return [self._create_access_path(k) for k in iter_partial_keys()]</span>
<span class="gi">+</span>
<span class="gi">+    def get_access_path_tuples(self):</span>
<span class="gi">+        accesses = [create_access(self._inference_state, o) for o in self._get_objects_path()]</span>
<span class="gi">+        return [(access.py__name__(), access) for access in accesses]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_objects_path(self):</span>
<span class="gi">+        def get():</span>
<span class="gi">+            obj = self._obj</span>
<span class="gi">+            yield obj</span>
<span class="gi">+            try:</span>
<span class="gi">+                obj = obj.__objclass__</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield obj</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Returns a dotted string path.</span>
<span class="gi">+                imp_plz = obj.__module__</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                # Unfortunately in some cases like `int` there&#39;s no __module__</span>
<span class="gi">+                if not inspect.ismodule(obj):</span>
<span class="gi">+                    yield builtins</span>
<span class="gi">+            else:</span>
<span class="gi">+                if imp_plz is None:</span>
<span class="gi">+                    # Happens for example in `(_ for _ in []).send.__module__`.</span>
<span class="gi">+                    yield builtins</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        yield sys.modules[imp_plz]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        # __module__ can be something arbitrary that doesn&#39;t exist.</span>
<span class="gi">+                        yield builtins</span>
<span class="gi">+</span>
<span class="gi">+        return list(reversed(list(get())))</span>
<span class="gi">+</span>
<span class="gi">+    def execute_operation(self, other_access_handle, operator):</span>
<span class="gi">+        other_access = other_access_handle.access</span>
<span class="gi">+        op = _OPERATORS[operator]</span>
<span class="gi">+        return self._create_access_path(op(self._obj, other_access._obj))</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_annotation_name_and_args(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns Tuple[Optional[str], Tuple[AccessPath, ...]]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = None</span>
<span class="gi">+        args = ()</span>
<span class="gi">+        if safe_getattr(self._obj, &#39;__module__&#39;, default=&#39;&#39;) == &#39;typing&#39;:</span>
<span class="gi">+            m = re.match(r&#39;typing.(\w+)\[&#39;, repr(self._obj))</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                name = m.group(1)</span>
<span class="gi">+</span>
<span class="gi">+                import typing</span>
<span class="gi">+                if sys.version_info &gt;= (3, 8):</span>
<span class="gi">+                    args = typing.get_args(self._obj)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    args = safe_getattr(self._obj, &#39;__args__&#39;, default=None)</span>
<span class="gi">+        return name, tuple(self._create_access_path(arg) for arg in args)</span>
<span class="gi">+</span>
<span class="gi">+    def needs_type_completions(self):</span>
<span class="gi">+        return inspect.isclass(self._obj) and self._obj != type</span>
<span class="gi">+</span>
<span class="gi">+    def _annotation_to_str(self, annotation):</span>
<span class="gi">+        return inspect.formatannotation(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signature_params(self):</span>
<span class="gi">+        return [</span>
<span class="gi">+            SignatureParam(</span>
<span class="gi">+                name=p.name,</span>
<span class="gi">+                has_default=p.default is not p.empty,</span>
<span class="gi">+                default=self._create_access_path(p.default),</span>
<span class="gi">+                default_string=repr(p.default),</span>
<span class="gi">+                has_annotation=p.annotation is not p.empty,</span>
<span class="gi">+                annotation=self._create_access_path(p.annotation),</span>
<span class="gi">+                annotation_string=self._annotation_to_str(p.annotation),</span>
<span class="gi">+                kind_name=str(p.kind)</span>
<span class="gi">+            ) for p in self._get_signature().parameters.values()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_signature(self):</span>
<span class="gi">+        obj = self._obj</span>
<span class="gi">+        try:</span>
<span class="gi">+            return inspect.signature(obj)</span>
<span class="gi">+        except (RuntimeError, TypeError):</span>
<span class="gi">+            # Reading the code of the function in Python 3.6 implies there are</span>
<span class="gi">+            # at least these errors that might occur if something is wrong with</span>
<span class="gi">+            # the signature. In that case we just want a simple escape for now.</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+</span>
<span class="gi">+    def get_return_annotation(self) -&gt; Optional[AccessPath]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            o = self._obj.__annotations__.get(&#39;return&#39;)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if o is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            o = typing.get_type_hints(self._obj).get(&#39;return&#39;)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return self._create_access_path(o)</span>
<span class="gi">+</span>
<span class="gi">+    def negate(self):</span>
<span class="gi">+        return self._create_access_path(-self._obj)</span>

<span class="w"> </span>    def get_dir_infos(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used to return a couple of infos that are needed when accessing the sub
<span class="w"> </span>        objects of an objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tuples = dict(</span>
<span class="gi">+            (name, self.is_allowed_getattr(name))</span>
<span class="gi">+            for name in self.dir()</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.needs_type_completions(), tuples</span>


<span class="w"> </span>def _is_class_instance(obj):
<span class="w"> </span>    &quot;&quot;&quot;Like inspect.* methods.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        cls = obj.__class__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        # The isinstance check for cls is just there so issubclass doesn&#39;t</span>
<span class="gi">+        # raise an exception.</span>
<span class="gi">+        return cls != type and isinstance(cls, type) and not issubclass(cls, NOT_CLASS_TYPES)</span>
<span class="gh">diff --git a/jedi/inference/compiled/getattr_static.py b/jedi/inference/compiled/getattr_static.py</span>
<span class="gh">index 2fd959ee..03c199ef 100644</span>
<span class="gd">--- a/jedi/inference/compiled/getattr_static.py</span>
<span class="gi">+++ b/jedi/inference/compiled/getattr_static.py</span>
<span class="gu">@@ -3,11 +3,75 @@ A static version of getattr.</span>
<span class="w"> </span>This is a backport of the Python 3 code with a little bit of additional
<span class="w"> </span>information returned to enable Jedi to make decisions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import types
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="gi">+</span>
<span class="w"> </span>_sentinel = object()


<span class="gi">+def _check_instance(obj, attr):</span>
<span class="gi">+    instance_dict = {}</span>
<span class="gi">+    try:</span>
<span class="gi">+        instance_dict = object.__getattribute__(obj, &quot;__dict__&quot;)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return dict.get(instance_dict, attr, _sentinel)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_class(klass, attr):</span>
<span class="gi">+    for entry in _static_getmro(klass):</span>
<span class="gi">+        if _shadowed_dict(type(entry)) is _sentinel:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return entry.__dict__[attr]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    return _sentinel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_type(obj):</span>
<span class="gi">+    try:</span>
<span class="gi">+        _static_getmro(obj)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _shadowed_dict(klass):</span>
<span class="gi">+    dict_attr = type.__dict__[&quot;__dict__&quot;]</span>
<span class="gi">+    for entry in _static_getmro(klass):</span>
<span class="gi">+        try:</span>
<span class="gi">+            class_dict = dict_attr.__get__(entry)[&quot;__dict__&quot;]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not (type(class_dict) is types.GetSetDescriptorType</span>
<span class="gi">+                    and class_dict.__name__ == &quot;__dict__&quot;</span>
<span class="gi">+                    and class_dict.__objclass__ is entry):</span>
<span class="gi">+                return class_dict</span>
<span class="gi">+    return _sentinel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _static_getmro(klass):</span>
<span class="gi">+    mro = type.__dict__[&#39;__mro__&#39;].__get__(klass)</span>
<span class="gi">+    if not isinstance(mro, (tuple, list)):</span>
<span class="gi">+        # There are unfortunately no tests for this, I was not able to</span>
<span class="gi">+        # reproduce this in pure Python. However should still solve the issue</span>
<span class="gi">+        # raised in GH #1517.</span>
<span class="gi">+        debug.warning(&#39;mro of %s returned %s, should be a tuple&#39; % (klass, mro))</span>
<span class="gi">+        return ()</span>
<span class="gi">+    return mro</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _safe_hasattr(obj, name):</span>
<span class="gi">+    return _check_class(type(obj), name) is not _sentinel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _safe_is_data_descriptor(obj):</span>
<span class="gi">+    return _safe_hasattr(obj, &#39;__set__&#39;) or _safe_hasattr(obj, &#39;__delete__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def getattr_static(obj, attr, default=_sentinel):
<span class="w"> </span>    &quot;&quot;&quot;Retrieve attributes without triggering dynamic lookup via the
<span class="w"> </span>       descriptor protocol,  __getattr__ or __getattribute__.
<span class="gu">@@ -22,4 +86,36 @@ def getattr_static(obj, attr, default=_sentinel):</span>
<span class="w"> </span>       Returns a tuple `(attr, is_get_descriptor)`. is_get_descripter means that
<span class="w"> </span>       the attribute is a descriptor that has a `__get__` attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    instance_result = _sentinel</span>
<span class="gi">+    if not _is_type(obj):</span>
<span class="gi">+        klass = type(obj)</span>
<span class="gi">+        dict_attr = _shadowed_dict(klass)</span>
<span class="gi">+        if (dict_attr is _sentinel or type(dict_attr) is types.MemberDescriptorType):</span>
<span class="gi">+            instance_result = _check_instance(obj, attr)</span>
<span class="gi">+    else:</span>
<span class="gi">+        klass = obj</span>
<span class="gi">+</span>
<span class="gi">+    klass_result = _check_class(klass, attr)</span>
<span class="gi">+</span>
<span class="gi">+    if instance_result is not _sentinel and klass_result is not _sentinel:</span>
<span class="gi">+        if _safe_hasattr(klass_result, &#39;__get__&#39;) \</span>
<span class="gi">+                and _safe_is_data_descriptor(klass_result):</span>
<span class="gi">+            # A get/set descriptor has priority over everything.</span>
<span class="gi">+            return klass_result, True</span>
<span class="gi">+</span>
<span class="gi">+    if instance_result is not _sentinel:</span>
<span class="gi">+        return instance_result, False</span>
<span class="gi">+    if klass_result is not _sentinel:</span>
<span class="gi">+        return klass_result, _safe_hasattr(klass_result, &#39;__get__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if obj is klass:</span>
<span class="gi">+        # for types we check the metaclass too</span>
<span class="gi">+        for entry in _static_getmro(type(klass)):</span>
<span class="gi">+            if _shadowed_dict(type(entry)) is _sentinel:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return entry.__dict__[attr], False</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+    if default is not _sentinel:</span>
<span class="gi">+        return default, False</span>
<span class="gi">+    raise AttributeError(attr)</span>
<span class="gh">diff --git a/jedi/inference/compiled/mixed.py b/jedi/inference/compiled/mixed.py</span>
<span class="gh">index 747c0bd5..1bfa3405 100644</span>
<span class="gd">--- a/jedi/inference/compiled/mixed.py</span>
<span class="gi">+++ b/jedi/inference/compiled/mixed.py</span>
<span class="gu">@@ -1,9 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Used only for REPL Completion.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import inspect
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from jedi.parser_utils import get_cached_code_lines
<span class="gi">+</span>
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.cache import memoize_method
<span class="w"> </span>from jedi.inference import compiled
<span class="gu">@@ -11,10 +14,13 @@ from jedi.file_io import FileIO</span>
<span class="w"> </span>from jedi.inference.names import NameWrapper
<span class="w"> </span>from jedi.inference.base_value import ValueSet, ValueWrapper, NO_VALUES
<span class="w"> </span>from jedi.inference.value import ModuleValue
<span class="gd">-from jedi.inference.cache import inference_state_function_cache, inference_state_method_cache</span>
<span class="gi">+from jedi.inference.cache import inference_state_function_cache, \</span>
<span class="gi">+    inference_state_method_cache</span>
<span class="w"> </span>from jedi.inference.compiled.access import ALLOWED_GETITEM_TYPES, get_api_type
<span class="w"> </span>from jedi.inference.gradual.conversion import to_stub
<span class="gd">-from jedi.inference.context import CompiledContext, CompiledModuleContext, TreeContextMixin</span>
<span class="gi">+from jedi.inference.context import CompiledContext, CompiledModuleContext, \</span>
<span class="gi">+    TreeContextMixin</span>
<span class="gi">+</span>
<span class="w"> </span>_sentinel = object()


<span class="gu">@@ -35,19 +41,67 @@ class MixedObject(ValueWrapper):</span>
<span class="w"> </span>    fewer special cases, because we in Python you don&#39;t have the same freedoms
<span class="w"> </span>    to modify the runtime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, compiled_value, tree_value):
<span class="w"> </span>        super().__init__(tree_value)
<span class="w"> </span>        self.compiled_value = compiled_value
<span class="w"> </span>        self.access_handle = compiled_value.access_handle

<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        yield MixedObjectFilter(</span>
<span class="gi">+            self.inference_state, self.compiled_value, self._wrapped_value)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        # Prefer `inspect.signature` over somehow analyzing Python code. It</span>
<span class="gi">+        # should be very precise, especially for stuff like `partial`.</span>
<span class="gi">+        return self.compiled_value.get_signatures()</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=NO_VALUES)</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        # Fallback to the wrapped value if to stub returns no values.</span>
<span class="gi">+        values = to_stub(self._wrapped_value)</span>
<span class="gi">+        if not values:</span>
<span class="gi">+            values = self._wrapped_value</span>
<span class="gi">+        return values.py__call__(arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def get_safe_value(self, default=_sentinel):</span>
<span class="gi">+        if default is _sentinel:</span>
<span class="gi">+            return self.compiled_value.get_safe_value()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.compiled_value.get_safe_value(default)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def array_type(self):</span>
<span class="gi">+        return self.compiled_value.array_type</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        return self.compiled_value.get_key_values()</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        python_object = self.compiled_value.access_handle.access._obj</span>
<span class="gi">+        if type(python_object) in ALLOWED_GETITEM_TYPES:</span>
<span class="gi">+            return self.compiled_value.py__simple_getitem__(index)</span>
<span class="gi">+        return self._wrapped_value.py__simple_getitem__(index)</span>
<span class="gi">+</span>
<span class="gi">+    def negate(self):</span>
<span class="gi">+        return self.compiled_value.negate()</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        if self.parent_context is None:</span>
<span class="gi">+            return MixedModuleContext(self)</span>
<span class="gi">+        return MixedContext(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: %s; %s&gt;&#39; % (type(self).__name__, self.access_handle.</span>
<span class="gd">-            get_repr(), self._wrapped_value)</span>
<span class="gi">+        return &#39;&lt;%s: %s; %s&gt;&#39; % (</span>
<span class="gi">+            type(self).__name__,</span>
<span class="gi">+            self.access_handle.get_repr(),</span>
<span class="gi">+            self._wrapped_value,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class MixedContext(CompiledContext, TreeContextMixin):
<span class="gd">-    pass</span>
<span class="gi">+    @property</span>
<span class="gi">+    def compiled_value(self):</span>
<span class="gi">+        return self._value.compiled_value</span>


<span class="w"> </span>class MixedModuleContext(CompiledModuleContext, MixedContext):
<span class="gu">@@ -58,19 +112,198 @@ class MixedName(NameWrapper):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The ``CompiledName._compiled_value`` is our MixedObject.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, wrapped_name, parent_tree_value):
<span class="w"> </span>        super().__init__(wrapped_name)
<span class="w"> </span>        self._parent_tree_value = parent_tree_value

<span class="gi">+    @property</span>
<span class="gi">+    def start_pos(self):</span>
<span class="gi">+        values = list(self.infer())</span>
<span class="gi">+        if not values:</span>
<span class="gi">+            # This means a start_pos that doesn&#39;t exist (compiled objects).</span>
<span class="gi">+            return 0, 0</span>
<span class="gi">+        return values[0].name.start_pos</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        compiled_value = self._wrapped_name.infer_compiled_value()</span>
<span class="gi">+        tree_value = self._parent_tree_value</span>
<span class="gi">+        if tree_value.is_instance() or tree_value.is_class():</span>
<span class="gi">+            tree_values = tree_value.py__getattribute__(self.string_name)</span>
<span class="gi">+            if compiled_value.is_function():</span>
<span class="gi">+                return ValueSet({MixedObject(compiled_value, v) for v in tree_values})</span>
<span class="gi">+</span>
<span class="gi">+        module_context = tree_value.get_root_context()</span>
<span class="gi">+        return _create(self._inference_state, compiled_value, module_context)</span>

<span class="gd">-class MixedObjectFilter(compiled.CompiledValueFilter):</span>

<span class="gi">+class MixedObjectFilter(compiled.CompiledValueFilter):</span>
<span class="w"> </span>    def __init__(self, inference_state, compiled_value, tree_value):
<span class="w"> </span>        super().__init__(inference_state, compiled_value)
<span class="w"> </span>        self._tree_value = tree_value

<span class="gi">+    def _create_name(self, *args, **kwargs):</span>
<span class="gi">+        return MixedName(</span>
<span class="gi">+            super()._create_name(*args, **kwargs),</span>
<span class="gi">+            self._tree_value,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_function_cache()</span>
<span class="gi">+def _load_module(inference_state, path):</span>
<span class="gi">+    return inference_state.parse(</span>
<span class="gi">+        path=path,</span>
<span class="gi">+        cache=True,</span>
<span class="gi">+        diff_cache=settings.fast_parser,</span>
<span class="gi">+        cache_path=settings.cache_directory</span>
<span class="gi">+    ).get_root_node()</span>
<span class="gi">+</span>

<span class="w"> </span>def _get_object_to_check(python_object):
<span class="w"> </span>    &quot;&quot;&quot;Check if inspect.getfile has a chance to find the source.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        python_object = inspect.unwrap(python_object)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # Can return a ValueError when it wraps around</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    if (inspect.ismodule(python_object)</span>
<span class="gi">+            or inspect.isclass(python_object)</span>
<span class="gi">+            or inspect.ismethod(python_object)</span>
<span class="gi">+            or inspect.isfunction(python_object)</span>
<span class="gi">+            or inspect.istraceback(python_object)</span>
<span class="gi">+            or inspect.isframe(python_object)</span>
<span class="gi">+            or inspect.iscode(python_object)):</span>
<span class="gi">+        return python_object</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return python_object.__class__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise TypeError  # Prevents computation of `repr` within inspect.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_syntax_node_name(inference_state, python_object):</span>
<span class="gi">+    original_object = python_object</span>
<span class="gi">+    try:</span>
<span class="gi">+        python_object = _get_object_to_check(python_object)</span>
<span class="gi">+        path = inspect.getsourcefile(python_object)</span>
<span class="gi">+    except (OSError, TypeError):</span>
<span class="gi">+        # The type might not be known (e.g. class_with_dict.__weakref__)</span>
<span class="gi">+        return None</span>
<span class="gi">+    path = None if path is None else Path(path)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if path is None or not path.exists():</span>
<span class="gi">+            # The path might not exist or be e.g. &lt;stdin&gt;.</span>
<span class="gi">+            return None</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        # Might raise an OSError on Windows:</span>
<span class="gi">+        #</span>
<span class="gi">+        #     [WinError 123] The filename, directory name, or volume label</span>
<span class="gi">+        #     syntax is incorrect: &#39;&lt;string&gt;&#39;</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    file_io = FileIO(path)</span>
<span class="gi">+    module_node = _load_module(inference_state, path)</span>
<span class="gi">+</span>
<span class="gi">+    if inspect.ismodule(python_object):</span>
<span class="gi">+        # We don&#39;t need to check names for modules, because there&#39;s not really</span>
<span class="gi">+        # a way to write a module in a module in Python (and also __name__ can</span>
<span class="gi">+        # be something like ``email.utils``).</span>
<span class="gi">+        code_lines = get_cached_code_lines(inference_state.grammar, path)</span>
<span class="gi">+        return module_node, module_node, file_io, code_lines</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        name_str = python_object.__name__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # Stuff like python_function.__code__.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if name_str == &#39;&lt;lambda&gt;&#39;:</span>
<span class="gi">+        return None  # It&#39;s too hard to find lambdas.</span>
<span class="gi">+</span>
<span class="gi">+    # Doesn&#39;t always work (e.g. os.stat_result)</span>
<span class="gi">+    names = module_node.get_used_names().get(name_str, [])</span>
<span class="gi">+    # Only functions and classes are relevant. If a name e.g. points to an</span>
<span class="gi">+    # import, it&#39;s probably a builtin (like collections.deque) and needs to be</span>
<span class="gi">+    # ignored.</span>
<span class="gi">+    names = [</span>
<span class="gi">+        n for n in names</span>
<span class="gi">+        if n.parent.type in (&#39;funcdef&#39;, &#39;classdef&#39;) and n.parent.name == n</span>
<span class="gi">+    ]</span>
<span class="gi">+    if not names:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        code = python_object.__code__</span>
<span class="gi">+        # By using the line number of a code object we make the lookup in a</span>
<span class="gi">+        # file pretty easy. There&#39;s still a possibility of people defining</span>
<span class="gi">+        # stuff like ``a = 3; foo(a); a = 4`` on the same line, but if people</span>
<span class="gi">+        # do so we just don&#39;t care.</span>
<span class="gi">+        line_nr = code.co_firstlineno</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        line_names = [name for name in names if name.start_pos[0] == line_nr]</span>
<span class="gi">+        # There&#39;s a chance that the object is not available anymore, because</span>
<span class="gi">+        # the code has changed in the background.</span>
<span class="gi">+        if line_names:</span>
<span class="gi">+            names = line_names</span>
<span class="gi">+</span>
<span class="gi">+    code_lines = get_cached_code_lines(inference_state.grammar, path)</span>
<span class="gi">+    # It&#39;s really hard to actually get the right definition, here as a last</span>
<span class="gi">+    # resort we just return the last one. This chance might lead to odd</span>
<span class="gi">+    # completions at some points but will lead to mostly correct type</span>
<span class="gi">+    # inference, because people tend to define a public name in a module only</span>
<span class="gi">+    # once.</span>
<span class="gi">+    tree_node = names[-1].parent</span>
<span class="gi">+    if tree_node.type == &#39;funcdef&#39; and get_api_type(original_object) == &#39;instance&#39;:</span>
<span class="gi">+        # If an instance is given and we&#39;re landing on a function (e.g.</span>
<span class="gi">+        # partial in 3.5), something is completely wrong and we should not</span>
<span class="gi">+        # return that.</span>
<span class="gi">+        return None</span>
<span class="gi">+    return module_node, tree_node, file_io, code_lines</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_function_cache()</span>
<span class="gi">+def _create(inference_state, compiled_value, module_context):</span>
<span class="gi">+    # TODO accessing this is bad, but it probably doesn&#39;t matter that much,</span>
<span class="gi">+    # because we&#39;re working with interpreters only here.</span>
<span class="gi">+    python_object = compiled_value.access_handle.access._obj</span>
<span class="gi">+    result = _find_syntax_node_name(inference_state, python_object)</span>
<span class="gi">+    if result is None:</span>
<span class="gi">+        # TODO Care about generics from stuff like `[1]` and don&#39;t return like this.</span>
<span class="gi">+        if type(python_object) in (dict, list, tuple):</span>
<span class="gi">+            return ValueSet({compiled_value})</span>
<span class="gi">+</span>
<span class="gi">+        tree_values = to_stub(compiled_value)</span>
<span class="gi">+        if not tree_values:</span>
<span class="gi">+            return ValueSet({compiled_value})</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_node, tree_node, file_io, code_lines = result</span>
<span class="gi">+</span>
<span class="gi">+        if module_context is None or module_context.tree_node != module_node:</span>
<span class="gi">+            root_compiled_value = compiled_value.get_root_context().get_value()</span>
<span class="gi">+            # TODO this __name__ might be wrong.</span>
<span class="gi">+            name = root_compiled_value.py__name__()</span>
<span class="gi">+            string_names = tuple(name.split(&#39;.&#39;))</span>
<span class="gi">+            module_value = ModuleValue(</span>
<span class="gi">+                inference_state, module_node,</span>
<span class="gi">+                file_io=file_io,</span>
<span class="gi">+                string_names=string_names,</span>
<span class="gi">+                code_lines=code_lines,</span>
<span class="gi">+                is_package=root_compiled_value.is_package(),</span>
<span class="gi">+            )</span>
<span class="gi">+            if name is not None:</span>
<span class="gi">+                inference_state.module_cache.add(string_names, ValueSet([module_value]))</span>
<span class="gi">+            module_context = module_value.as_context()</span>
<span class="gi">+</span>
<span class="gi">+        tree_values = ValueSet({module_context.create_value(tree_node)})</span>
<span class="gi">+        if tree_node.type == &#39;classdef&#39;:</span>
<span class="gi">+            if not compiled_value.is_class():</span>
<span class="gi">+                # Is an instance, not a class.</span>
<span class="gi">+                tree_values = tree_values.execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+    return ValueSet(</span>
<span class="gi">+        MixedObject(compiled_value, tree_value=tree_value)</span>
<span class="gi">+        for tree_value in tree_values</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/jedi/inference/compiled/subprocess/functions.py b/jedi/inference/compiled/subprocess/functions.py</span>
<span class="gh">index ac69d794..50c47b83 100644</span>
<span class="gd">--- a/jedi/inference/compiled/subprocess/functions.py</span>
<span class="gi">+++ b/jedi/inference/compiled/subprocess/functions.py</span>
<span class="gu">@@ -6,31 +6,66 @@ from pathlib import Path</span>
<span class="w"> </span>from zipfile import ZipFile
<span class="w"> </span>from zipimport import zipimporter, ZipImportError
<span class="w"> </span>from importlib.machinery import all_suffixes
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.compiled import access
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import parser_utils
<span class="w"> </span>from jedi.file_io import KnownContentFileIO, ZipFileIO


<span class="gi">+def get_sys_path():</span>
<span class="gi">+    return sys.path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_module(inference_state, **kwargs):</span>
<span class="gi">+    return access.load_module(inference_state, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_compiled_method_return(inference_state, id, attribute, *args, **kwargs):</span>
<span class="gi">+    handle = inference_state.compiled_subprocess.get_access_handle(id)</span>
<span class="gi">+    return getattr(handle.access, attribute)(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_simple_object(inference_state, obj):</span>
<span class="gi">+    return access.create_access_path(inference_state, obj)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def get_module_info(inference_state, sys_path=None, full_name=None, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns Tuple[Union[NamespaceInfo, FileIO, None], Optional[bool]]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys_path is not None:</span>
<span class="gi">+        sys.path, temp = sys_path, sys.path</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _find_module(full_name=full_name, **kwargs)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if sys_path is not None:</span>
<span class="gi">+            sys.path = temp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_builtin_module_names(inference_state):</span>
<span class="gi">+    return sys.builtin_module_names</span>


<span class="w"> </span>def _test_raise_error(inference_state, exception_type):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raise an error to simulate certain problems for unit tests.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise exception_type</span>


<span class="w"> </span>def _test_print(inference_state, stderr=None, stdout=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Force some prints in the subprocesses. This exists for unit tests.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if stderr is not None:</span>
<span class="gi">+        print(stderr, file=sys.stderr)</span>
<span class="gi">+        sys.stderr.flush()</span>
<span class="gi">+    if stdout is not None:</span>
<span class="gi">+        print(stdout)</span>
<span class="gi">+        sys.stdout.flush()</span>


<span class="w"> </span>def _get_init_path(directory_path):
<span class="gu">@@ -38,7 +73,54 @@ def _get_init_path(directory_path):</span>
<span class="w"> </span>    The __init__ file can be searched in a directory. If found return it, else
<span class="w"> </span>    None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for suffix in all_suffixes():</span>
<span class="gi">+        path = os.path.join(directory_path, &#39;__init__&#39; + suffix)</span>
<span class="gi">+        if os.path.exists(path):</span>
<span class="gi">+            return path</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safe_literal_eval(inference_state, value):</span>
<span class="gi">+    return parser_utils.safe_literal_eval(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iter_module_names(*args, **kwargs):</span>
<span class="gi">+    return list(_iter_module_names(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _iter_module_names(inference_state, paths):</span>
<span class="gi">+    # Python modules/packages</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dir_entries = ((entry.name, entry.is_dir()) for entry in os.scandir(path))</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                zip_import_info = zipimporter(path)</span>
<span class="gi">+                # Unfortunately, there is no public way to access zipimporter&#39;s</span>
<span class="gi">+                # private _files member. We therefore have to use a</span>
<span class="gi">+                # custom function to iterate over the files.</span>
<span class="gi">+                dir_entries = _zip_list_subdirectory(</span>
<span class="gi">+                    zip_import_info.archive, zip_import_info.prefix)</span>
<span class="gi">+            except ZipImportError:</span>
<span class="gi">+                # The file might not exist or reading it might lead to an error.</span>
<span class="gi">+                debug.warning(&quot;Not possible to list directory: %s&quot;, path)</span>
<span class="gi">+                continue</span>
<span class="gi">+        for name, is_dir in dir_entries:</span>
<span class="gi">+            # First Namespaces then modules/stubs</span>
<span class="gi">+            if is_dir:</span>
<span class="gi">+                # pycache is obviously not an interesting namespace. Also the</span>
<span class="gi">+                # name must be a valid identifier.</span>
<span class="gi">+                if name != &#39;__pycache__&#39; and name.isidentifier():</span>
<span class="gi">+                    yield name</span>
<span class="gi">+            else:</span>
<span class="gi">+                if name.endswith(&#39;.pyi&#39;):  # Stub files</span>
<span class="gi">+                    modname = name[:-4]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    modname = inspect.getmodulename(name)</span>
<span class="gi">+</span>
<span class="gi">+                if modname and &#39;.&#39; not in modname:</span>
<span class="gi">+                    if modname != &#39;__init__&#39;:</span>
<span class="gi">+                        yield modname</span>


<span class="w"> </span>def _find_module(string, path=None, full_name=None, is_global_search=True):
<span class="gu">@@ -51,7 +133,97 @@ def _find_module(string, path=None, full_name=None, is_global_search=True):</span>
<span class="w"> </span>    or the name of the module if it is a builtin one and a boolean indicating
<span class="w"> </span>    if the module is contained in a package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    spec = None</span>
<span class="gi">+    loader = None</span>
<span class="gi">+</span>
<span class="gi">+    for finder in sys.meta_path:</span>
<span class="gi">+        if is_global_search and finder != importlib.machinery.PathFinder:</span>
<span class="gi">+            p = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            p = path</span>
<span class="gi">+        try:</span>
<span class="gi">+            find_spec = finder.find_spec</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # These are old-school clases that still have a different API, just</span>
<span class="gi">+            # ignore those.</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        spec = find_spec(string, p)</span>
<span class="gi">+        if spec is not None:</span>
<span class="gi">+            if spec.origin == &quot;frozen&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            loader = spec.loader</span>
<span class="gi">+</span>
<span class="gi">+            if loader is None and not spec.has_location:</span>
<span class="gi">+                # This is a namespace package.</span>
<span class="gi">+                full_name = string if not path else full_name</span>
<span class="gi">+                implicit_ns_info = ImplicitNSInfo(full_name, spec.submodule_search_locations._path)</span>
<span class="gi">+                return implicit_ns_info, True</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return _find_module_py33(string, path, loader)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_module_py33(string, path=None, loader=None, full_name=None, is_global_search=True):</span>
<span class="gi">+    if not loader:</span>
<span class="gi">+        spec = importlib.machinery.PathFinder.find_spec(string, path)</span>
<span class="gi">+        if spec is not None:</span>
<span class="gi">+            loader = spec.loader</span>
<span class="gi">+</span>
<span class="gi">+    if loader is None and path is None:  # Fallback to find builtins</span>
<span class="gi">+        try:</span>
<span class="gi">+            spec = importlib.util.find_spec(string)</span>
<span class="gi">+            if spec is not None:</span>
<span class="gi">+                loader = spec.loader</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            # See #491. Importlib might raise a ValueError, to avoid this, we</span>
<span class="gi">+            # just raise an ImportError to fix the issue.</span>
<span class="gi">+            raise ImportError(&quot;Originally  &quot; + repr(e))</span>
<span class="gi">+</span>
<span class="gi">+    if loader is None:</span>
<span class="gi">+        raise ImportError(&quot;Couldn&#39;t find a loader for {}&quot;.format(string))</span>
<span class="gi">+</span>
<span class="gi">+    return _from_loader(loader, string)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _from_loader(loader, string):</span>
<span class="gi">+    try:</span>
<span class="gi">+        is_package_method = loader.is_package</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        is_package = False</span>
<span class="gi">+    else:</span>
<span class="gi">+        is_package = is_package_method(string)</span>
<span class="gi">+    try:</span>
<span class="gi">+        get_filename = loader.get_filename</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return None, is_package</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_path = get_filename(string)</span>
<span class="gi">+</span>
<span class="gi">+    # To avoid unicode and read bytes, &quot;overwrite&quot; loader.get_source if</span>
<span class="gi">+    # possible.</span>
<span class="gi">+    try:</span>
<span class="gi">+        f = type(loader).get_source</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise ImportError(&quot;get_source was not defined on loader&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if f is not importlib.machinery.SourceFileLoader.get_source:</span>
<span class="gi">+        # Unfortunately we are reading unicode here, not bytes.</span>
<span class="gi">+        # It seems hard to get bytes, because the zip importer</span>
<span class="gi">+        # logic just unpacks the zip file and returns a file descriptor</span>
<span class="gi">+        # that we cannot as easily access. Therefore we just read it as</span>
<span class="gi">+        # a string in the cases where get_source was overwritten.</span>
<span class="gi">+        code = loader.get_source(string)</span>
<span class="gi">+    else:</span>
<span class="gi">+        code = _get_source(loader, string)</span>
<span class="gi">+</span>
<span class="gi">+    if code is None:</span>
<span class="gi">+        return None, is_package</span>
<span class="gi">+    if isinstance(loader, zipimporter):</span>
<span class="gi">+        return ZipFileIO(module_path, code, Path(loader.archive)), is_package</span>
<span class="gi">+</span>
<span class="gi">+    return KnownContentFileIO(module_path, code), is_package</span>


<span class="w"> </span>def _get_source(loader, fullname):
<span class="gu">@@ -59,12 +231,27 @@ def _get_source(loader, fullname):</span>
<span class="w"> </span>    This method is here as a replacement for SourceLoader.get_source. That
<span class="w"> </span>    method returns unicode, but we prefer bytes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = loader.get_filename(fullname)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return loader.get_data(path)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        raise ImportError(&#39;source not available through get_data()&#39;,</span>
<span class="gi">+                          name=fullname)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _zip_list_subdirectory(zip_path, zip_subdir_path):</span>
<span class="gi">+    zip_file = ZipFile(zip_path)</span>
<span class="gi">+    zip_subdir_path = Path(zip_subdir_path)</span>
<span class="gi">+    zip_content_file_paths = zip_file.namelist()</span>
<span class="gi">+    for raw_file_name in zip_content_file_paths:</span>
<span class="gi">+        file_path = Path(raw_file_name)</span>
<span class="gi">+        if file_path.parent == zip_subdir_path:</span>
<span class="gi">+            file_path = file_path.relative_to(zip_subdir_path)</span>
<span class="gi">+            yield file_path.name, raw_file_name.endswith(&quot;/&quot;)</span>


<span class="w"> </span>class ImplicitNSInfo:
<span class="w"> </span>    &quot;&quot;&quot;Stores information returned from an implicit namespace spec&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, name, paths):
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.paths = paths
<span class="gh">diff --git a/jedi/inference/compiled/value.py b/jedi/inference/compiled/value.py</span>
<span class="gh">index e49e6da0..b3a841b1 100644</span>
<span class="gd">--- a/jedi/inference/compiled/value.py</span>
<span class="gi">+++ b/jedi/inference/compiled/value.py</span>
<span class="gu">@@ -6,11 +6,13 @@ from functools import partial</span>
<span class="w"> </span>from inspect import Parameter
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Optional
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.utils import to_list
<span class="w"> </span>from jedi.cache import memoize_method
<span class="w"> </span>from jedi.inference.filters import AbstractFilter
<span class="gd">-from jedi.inference.names import AbstractNameDefinition, ValueNameMixin, ParamNameInterface</span>
<span class="gi">+from jedi.inference.names import AbstractNameDefinition, ValueNameMixin, \</span>
<span class="gi">+    ParamNameInterface</span>
<span class="w"> </span>from jedi.inference.base_value import Value, ValueSet, NO_VALUES
<span class="w"> </span>from jedi.inference.lazy_value import LazyKnownValue
<span class="w"> </span>from jedi.inference.compiled.access import _sentinel
<span class="gu">@@ -22,8 +24,8 @@ from jedi.inference.context import CompiledContext, CompiledModuleContext</span>

<span class="w"> </span>class CheckAttribute:
<span class="w"> </span>    &quot;&quot;&quot;Raises :exc:`AttributeError` if the attribute X is not available.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, check_name=None):
<span class="gi">+        # Remove the py in front of e.g. py__call__.</span>
<span class="w"> </span>        self.check_name = check_name

<span class="w"> </span>    def __call__(self, func):
<span class="gu">@@ -35,27 +37,282 @@ class CheckAttribute:</span>
<span class="w"> </span>    def __get__(self, instance, owner):
<span class="w"> </span>        if instance is None:
<span class="w"> </span>            return self
<span class="gi">+</span>
<span class="gi">+        # This might raise an AttributeError. That&#39;s wanted.</span>
<span class="w"> </span>        instance.access_handle.getattr_paths(self.check_name)
<span class="w"> </span>        return partial(self.func, instance)


<span class="w"> </span>class CompiledValue(Value):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, access_handle, parent_context=None):
<span class="w"> </span>        super().__init__(inference_state, parent_context)
<span class="w"> </span>        self.access_handle = access_handle

<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        return_annotation = self.access_handle.get_return_annotation()</span>
<span class="gi">+        if return_annotation is not None:</span>
<span class="gi">+            return create_from_access_path(</span>
<span class="gi">+                self.inference_state,</span>
<span class="gi">+                return_annotation</span>
<span class="gi">+            ).execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.access_handle.getattr_paths(&#39;__call__&#39;)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return super().py__call__(arguments)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.access_handle.is_class():</span>
<span class="gi">+                from jedi.inference.value import CompiledInstance</span>
<span class="gi">+                return ValueSet([</span>
<span class="gi">+                    CompiledInstance(self.inference_state, self.parent_context, self, arguments)</span>
<span class="gi">+                ])</span>
<span class="gi">+            else:</span>
<span class="gi">+                return ValueSet(self._execute_function(arguments))</span>
<span class="gi">+</span>
<span class="gi">+    @CheckAttribute()</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return create_from_access_path(self.inference_state, self.access_handle.py__class__())</span>
<span class="gi">+</span>
<span class="gi">+    @CheckAttribute()</span>
<span class="gi">+    def py__mro__(self):</span>
<span class="gi">+        return (self,) + tuple(</span>
<span class="gi">+            create_from_access_path(self.inference_state, access)</span>
<span class="gi">+            for access in self.access_handle.py__mro__accesses()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @CheckAttribute()</span>
<span class="gi">+    def py__bases__(self):</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            create_from_access_path(self.inference_state, access)</span>
<span class="gi">+            for access in self.access_handle.py__bases__()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return self.access_handle.get_qualified_names()</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        return self.access_handle.py__bool__()</span>
<span class="gi">+</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return self.access_handle.is_class()</span>
<span class="gi">+</span>
<span class="gi">+    def is_function(self):</span>
<span class="gi">+        return self.access_handle.is_function()</span>
<span class="gi">+</span>
<span class="gi">+    def is_module(self):</span>
<span class="gi">+        return self.access_handle.is_module()</span>
<span class="gi">+</span>
<span class="gi">+    def is_compiled(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_instance(self):</span>
<span class="gi">+        return self.access_handle.is_instance()</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return self.access_handle.py__doc__()</span>
<span class="gi">+</span>
<span class="gi">+    @to_list</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            signature_params = self.access_handle.get_signature_params()</span>
<span class="gi">+        except ValueError:  # Has no signature</span>
<span class="gi">+            params_str, ret = self._parse_function_doc()</span>
<span class="gi">+            if not params_str:</span>
<span class="gi">+                tokens = []</span>
<span class="gi">+            else:</span>
<span class="gi">+                tokens = params_str.split(&#39;,&#39;)</span>
<span class="gi">+            if self.access_handle.ismethoddescriptor():</span>
<span class="gi">+                tokens.insert(0, &#39;self&#39;)</span>
<span class="gi">+            for p in tokens:</span>
<span class="gi">+                name, _, default = p.strip().partition(&#39;=&#39;)</span>
<span class="gi">+                yield UnresolvableParamName(self, name, default)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for signature_param in signature_params:</span>
<span class="gi">+                yield SignatureParamName(self, signature_param)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        _, return_string = self._parse_function_doc()</span>
<span class="gi">+        return [BuiltinSignature(self, return_string)]</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.access_handle.</span>
<span class="gd">-            get_repr())</span>
<span class="gi">+        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.access_handle.get_repr())</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _parse_function_doc(self):</span>
<span class="gi">+        doc = self.py__doc__()</span>
<span class="gi">+        if doc is None:</span>
<span class="gi">+            return &#39;&#39;, &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return _parse_function_doc(doc)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        return self.access_handle.get_api_type()</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, is_instance=False, origin_scope=None):</span>
<span class="gi">+        yield self._ensure_one_filter(is_instance)</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _ensure_one_filter(self, is_instance):</span>
<span class="gi">+        return CompiledValueFilter(self.inference_state, self, is_instance)</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        with reraise_getitem_errors(IndexError, KeyError, TypeError):</span>
<span class="gi">+            try:</span>
<span class="gi">+                access = self.access_handle.py__simple_getitem__(</span>
<span class="gi">+                    index,</span>
<span class="gi">+                    safe=not self.inference_state.allow_unsafe_executions</span>
<span class="gi">+                )</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                return super().py__simple_getitem__(index)</span>
<span class="gi">+        if access is None:</span>
<span class="gi">+            return super().py__simple_getitem__(index)</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([create_from_access_path(self.inference_state, access)])</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        all_access_paths = self.access_handle.py__getitem__all_values()</span>
<span class="gi">+        if all_access_paths is None:</span>
<span class="gi">+            # This means basically that no __getitem__ has been defined on this</span>
<span class="gi">+            # object.</span>
<span class="gi">+            return super().py__getitem__(index_value_set, contextualized_node)</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            create_from_access_path(self.inference_state, access)</span>
<span class="gi">+            for access in all_access_paths</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        if not self.access_handle.has_iter():</span>
<span class="gi">+            yield from super().py__iter__(contextualized_node)</span>
<span class="gi">+</span>
<span class="gi">+        access_path_list = self.access_handle.py__iter__list()</span>
<span class="gi">+        if access_path_list is None:</span>
<span class="gi">+            # There is no __iter__ method on this object.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for access in access_path_list:</span>
<span class="gi">+            yield LazyKnownValue(create_from_access_path(self.inference_state, access))</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.access_handle.py__name__()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        name = self.py__name__()</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            name = self.access_handle.get_repr()</span>
<span class="gi">+        return CompiledValueName(self, name)</span>
<span class="gi">+</span>
<span class="gi">+    def _execute_function(self, params):</span>
<span class="gi">+        from jedi.inference import docstrings</span>
<span class="gi">+        from jedi.inference.compiled import builtin_from_name</span>
<span class="gi">+        if self.api_type != &#39;function&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for name in self._parse_function_doc()[1].split():</span>
<span class="gi">+            try:</span>
<span class="gi">+                # TODO wtf is this? this is exactly the same as the thing</span>
<span class="gi">+                # below. It uses getattr as well.</span>
<span class="gi">+                self.inference_state.builtins_module.access_handle.getattr_paths(name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                bltn_obj = builtin_from_name(self.inference_state, name)</span>
<span class="gi">+                yield from self.inference_state.execute(bltn_obj, params)</span>
<span class="gi">+        yield from docstrings.infer_return_types(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_safe_value(self, default=_sentinel):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.access_handle.get_safe_value()</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            if default == _sentinel:</span>
<span class="gi">+                raise</span>
<span class="gi">+            return default</span>
<span class="gi">+</span>
<span class="gi">+    def execute_operation(self, other, operator):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return ValueSet([create_from_access_path(</span>
<span class="gi">+                self.inference_state,</span>
<span class="gi">+                self.access_handle.execute_operation(other.access_handle, operator)</span>
<span class="gi">+            )])</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def execute_annotation(self):</span>
<span class="gi">+        if self.access_handle.get_repr() == &#39;None&#39;:</span>
<span class="gi">+            # None as an annotation doesn&#39;t need to be executed.</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+        name, args = self.access_handle.get_annotation_name_and_args()</span>
<span class="gi">+        arguments = [</span>
<span class="gi">+            ValueSet([create_from_access_path(self.inference_state, path)])</span>
<span class="gi">+            for path in args</span>
<span class="gi">+        ]</span>
<span class="gi">+        if name == &#39;Union&#39;:</span>
<span class="gi">+            return ValueSet.from_sets(arg.execute_annotation() for arg in arguments)</span>
<span class="gi">+        elif name:</span>
<span class="gi">+            # While with_generics only exists on very specific objects, we</span>
<span class="gi">+            # should probably be fine, because we control all the typing</span>
<span class="gi">+            # objects.</span>
<span class="gi">+            return ValueSet([</span>
<span class="gi">+                v.with_generics(arguments)</span>
<span class="gi">+                for v in self.inference_state.typing_module.py__getattribute__(name)</span>
<span class="gi">+            ]).execute_annotation()</span>
<span class="gi">+        return super().execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+    def negate(self):</span>
<span class="gi">+        return create_from_access_path(self.inference_state, self.access_handle.negate())</span>
<span class="gi">+</span>
<span class="gi">+    def get_metaclasses(self):</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return CompiledContext(self)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def array_type(self):</span>
<span class="gi">+        return self.access_handle.get_array_type()</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        return [</span>
<span class="gi">+            create_from_access_path(self.inference_state, k)</span>
<span class="gi">+            for k in self.access_handle.get_key_paths()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        if self.access_handle.get_repr() in (&#39;None&#39;, &quot;&lt;class &#39;NoneType&#39;&gt;&quot;):</span>
<span class="gi">+            return &#39;None&#39;</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class CompiledModule(CompiledValue):
<span class="gd">-    file_io = None</span>
<span class="gi">+    file_io = None  # For modules</span>

<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return CompiledModuleContext(self)</span>

<span class="gd">-class CompiledName(AbstractNameDefinition):</span>
<span class="gi">+    def py__path__(self):</span>
<span class="gi">+        return self.access_handle.py__path__()</span>
<span class="gi">+</span>
<span class="gi">+    def is_package(self):</span>
<span class="gi">+        return self.py__path__() is not None</span>

<span class="gi">+    @property</span>
<span class="gi">+    def string_names(self):</span>
<span class="gi">+        # For modules</span>
<span class="gi">+        name = self.py__name__()</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            return ()</span>
<span class="gi">+        return tuple(name.split(&#39;.&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="gi">+        return self.access_handle.py__file__()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class CompiledName(AbstractNameDefinition):</span>
<span class="w"> </span>    def __init__(self, inference_state, parent_value, name, is_descriptor):
<span class="w"> </span>        self._inference_state = inference_state
<span class="w"> </span>        self.parent_context = parent_value.as_context()
<span class="gu">@@ -63,32 +320,98 @@ class CompiledName(AbstractNameDefinition):</span>
<span class="w"> </span>        self.string_name = name
<span class="w"> </span>        self.is_descriptor = is_descriptor

<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return self.infer_compiled_value().py__doc__()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_qualified_names(self):</span>
<span class="gi">+        parent_qualified_names = self.parent_context.get_qualified_names()</span>
<span class="gi">+        if parent_qualified_names is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return parent_qualified_names + (self.string_name,)</span>
<span class="gi">+</span>
<span class="gi">+    def get_defining_qualified_value(self):</span>
<span class="gi">+        context = self.parent_context</span>
<span class="gi">+        if context.is_module() or context.is_class():</span>
<span class="gi">+            return self.parent_context.get_value()  # Might be None</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        try:
<span class="gd">-            name = self.parent_context.name</span>
<span class="gi">+            name = self.parent_context.name  # __name__ is not defined all the time</span>
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            name = None
<span class="gd">-        return &#39;&lt;%s: (%s).%s&gt;&#39; % (self.__class__.__name__, name, self.</span>
<span class="gd">-            string_name)</span>
<span class="gi">+        return &#39;&lt;%s: (%s).%s&gt;&#39; % (self.__class__.__name__, name, self.string_name)</span>

<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        if self.is_descriptor:</span>
<span class="gi">+            # In case of properties we want to avoid executions as much as</span>
<span class="gi">+            # possible. Since the api_type can be wrong for other reasons</span>
<span class="gi">+            # anyway, we just return instance here.</span>
<span class="gi">+            return &quot;instance&quot;</span>
<span class="gi">+        return self.infer_compiled_value().api_type</span>

<span class="gd">-class SignatureParamName(ParamNameInterface, AbstractNameDefinition):</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self.infer_compiled_value()])</span>

<span class="gi">+    @memoize_method</span>
<span class="gi">+    def infer_compiled_value(self):</span>
<span class="gi">+        return create_from_name(self._inference_state, self._parent_value, self.string_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class SignatureParamName(ParamNameInterface, AbstractNameDefinition):</span>
<span class="w"> </span>    def __init__(self, compiled_value, signature_param):
<span class="w"> </span>        self.parent_context = compiled_value.parent_context
<span class="w"> </span>        self._signature_param = signature_param

<span class="gi">+    @property</span>
<span class="gi">+    def string_name(self):</span>
<span class="gi">+        return self._signature_param.name</span>
<span class="gi">+</span>
<span class="gi">+    def to_string(self):</span>
<span class="gi">+        s = self._kind_string() + self.string_name</span>
<span class="gi">+        if self._signature_param.has_annotation:</span>
<span class="gi">+            s += &#39;: &#39; + self._signature_param.annotation_string</span>
<span class="gi">+        if self._signature_param.has_default:</span>
<span class="gi">+            s += &#39;=&#39; + self._signature_param.default_string</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        return getattr(Parameter, self._signature_param.kind_name)</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        p = self._signature_param</span>
<span class="gi">+        inference_state = self.parent_context.inference_state</span>
<span class="gi">+        values = NO_VALUES</span>
<span class="gi">+        if p.has_default:</span>
<span class="gi">+            values = ValueSet([create_from_access_path(inference_state, p.default)])</span>
<span class="gi">+        if p.has_annotation:</span>
<span class="gi">+            annotation = create_from_access_path(inference_state, p.annotation)</span>
<span class="gi">+            values |= annotation.execute_with_values()</span>
<span class="gi">+        return values</span>

<span class="gd">-class UnresolvableParamName(ParamNameInterface, AbstractNameDefinition):</span>

<span class="gi">+class UnresolvableParamName(ParamNameInterface, AbstractNameDefinition):</span>
<span class="w"> </span>    def __init__(self, compiled_value, name, default):
<span class="w"> </span>        self.parent_context = compiled_value.parent_context
<span class="w"> </span>        self.string_name = name
<span class="w"> </span>        self._default = default

<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        return Parameter.POSITIONAL_ONLY</span>
<span class="gi">+</span>
<span class="gi">+    def to_string(self):</span>
<span class="gi">+        string = self.string_name</span>
<span class="gi">+        if self._default:</span>
<span class="gi">+            string += &#39;=&#39; + self._default</span>
<span class="gi">+        return string</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return NO_VALUES</span>

<span class="gd">-class CompiledValueName(ValueNameMixin, AbstractNameDefinition):</span>

<span class="gi">+class CompiledValueName(ValueNameMixin, AbstractNameDefinition):</span>
<span class="w"> </span>    def __init__(self, value, name):
<span class="w"> </span>        self.string_name = name
<span class="w"> </span>        self._value = value
<span class="gu">@@ -101,32 +424,104 @@ class EmptyCompiledName(AbstractNameDefinition):</span>
<span class="w"> </span>    completions, just give Jedi the option to return this object. It infers to
<span class="w"> </span>    nothing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, name):
<span class="w"> </span>        self.parent_context = inference_state.builtins_module
<span class="w"> </span>        self.string_name = name

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return NO_VALUES</span>

<span class="gd">-class CompiledValueFilter(AbstractFilter):</span>

<span class="gi">+class CompiledValueFilter(AbstractFilter):</span>
<span class="w"> </span>    def __init__(self, inference_state, compiled_value, is_instance=False):
<span class="w"> </span>        self._inference_state = inference_state
<span class="w"> </span>        self.compiled_value = compiled_value
<span class="w"> </span>        self.is_instance = is_instance

<span class="gd">-    def _get(self, name, allowed_getattr_callback, in_dir_callback,</span>
<span class="gd">-        check_has_attribute=False):</span>
<span class="gi">+    def get(self, name):</span>
<span class="gi">+        access_handle = self.compiled_value.access_handle</span>
<span class="gi">+        safe = not self._inference_state.allow_unsafe_executions</span>
<span class="gi">+        return self._get(</span>
<span class="gi">+            name,</span>
<span class="gi">+            lambda name: access_handle.is_allowed_getattr(name, safe=safe),</span>
<span class="gi">+            lambda name: name in access_handle.dir(),</span>
<span class="gi">+            check_has_attribute=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get(self, name, allowed_getattr_callback, in_dir_callback, check_has_attribute=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        To remove quite a few access calls we introduced the callback here.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        has_attribute, is_descriptor, property_return_annotation = allowed_getattr_callback(</span>
<span class="gi">+            name,</span>
<span class="gi">+        )</span>
<span class="gi">+        if property_return_annotation is not None:</span>
<span class="gi">+            values = create_from_access_path(</span>
<span class="gi">+                self._inference_state,</span>
<span class="gi">+                property_return_annotation</span>
<span class="gi">+            ).execute_annotation()</span>
<span class="gi">+            if values:</span>
<span class="gi">+                return [CompiledValueName(v, name) for v in values]</span>
<span class="gi">+</span>
<span class="gi">+        if check_has_attribute and not has_attribute:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        if (is_descriptor or not has_attribute) \</span>
<span class="gi">+                and not self._inference_state.allow_unsafe_executions:</span>
<span class="gi">+            return [self._get_cached_name(name, is_empty=True)]</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_instance and not in_dir_callback(name):</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [self._get_cached_name(name, is_descriptor=is_descriptor)]</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _get_cached_name(self, name, is_empty=False, *, is_descriptor=False):</span>
<span class="gi">+        if is_empty:</span>
<span class="gi">+            return EmptyCompiledName(self._inference_state, name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._create_name(name, is_descriptor=is_descriptor)</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        from jedi.inference.compiled import builtin_from_name</span>
<span class="gi">+        names = []</span>
<span class="gi">+        needs_type_completions, dir_infos = self.compiled_value.access_handle.get_dir_infos()</span>
<span class="gi">+        # We could use `safe=False` here as well, especially as a parameter to</span>
<span class="gi">+        # get_dir_infos. But this would lead to a lot of property executions</span>
<span class="gi">+        # that are probably not wanted. The drawback for this is that we</span>
<span class="gi">+        # have a different name for `get` and `values`. For `get` we always</span>
<span class="gi">+        # execute.</span>
<span class="gi">+        for name in dir_infos:</span>
<span class="gi">+            names += self._get(</span>
<span class="gi">+                name,</span>
<span class="gi">+                lambda name: dir_infos[name],</span>
<span class="gi">+                lambda name: name in dir_infos,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # ``dir`` doesn&#39;t include the type names.</span>
<span class="gi">+        if not self.is_instance and needs_type_completions:</span>
<span class="gi">+            for filter in builtin_from_name(self._inference_state, &#39;type&#39;).get_filters():</span>
<span class="gi">+                names += filter.values()</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def _create_name(self, name, is_descriptor):</span>
<span class="gi">+        return CompiledName(</span>
<span class="gi">+            self._inference_state,</span>
<span class="gi">+            self.compiled_value,</span>
<span class="gi">+            name,</span>
<span class="gi">+            is_descriptor,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.compiled_value)</span>
<span class="gi">+        return &quot;&lt;%s: %s&gt;&quot; % (self.__class__.__name__, self.compiled_value)</span>


<span class="gd">-docstr_defaults = {&#39;floating point number&#39;: &#39;float&#39;, &#39;character&#39;: &#39;str&#39;,</span>
<span class="gd">-    &#39;integer&#39;: &#39;int&#39;, &#39;dictionary&#39;: &#39;dict&#39;, &#39;string&#39;: &#39;str&#39;}</span>
<span class="gi">+docstr_defaults = {</span>
<span class="gi">+    &#39;floating point number&#39;: &#39;float&#39;,</span>
<span class="gi">+    &#39;character&#39;: &#39;str&#39;,</span>
<span class="gi">+    &#39;integer&#39;: &#39;int&#39;,</span>
<span class="gi">+    &#39;dictionary&#39;: &#39;dict&#39;,</span>
<span class="gi">+    &#39;string&#39;: &#39;str&#39;,</span>
<span class="gi">+}</span>


<span class="w"> </span>def _parse_function_doc(doc):
<span class="gu">@@ -137,9 +532,95 @@ def _parse_function_doc(doc):</span>
<span class="w"> </span>    TODO docstrings like utime(path, (atime, mtime)) and a(b [, b]) -&gt; None
<span class="w"> </span>    TODO docstrings like &#39;tuple of integers&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # parse round parentheses: def func(a, (b,c))</span>
<span class="gi">+    try:</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        start = doc.index(&#39;(&#39;)</span>
<span class="gi">+        for i, s in enumerate(doc[start:]):</span>
<span class="gi">+            if s == &#39;(&#39;:</span>
<span class="gi">+                count += 1</span>
<span class="gi">+            elif s == &#39;)&#39;:</span>
<span class="gi">+                count -= 1</span>
<span class="gi">+            if count == 0:</span>
<span class="gi">+                end = start + i</span>
<span class="gi">+                break</span>
<span class="gi">+        param_str = doc[start + 1:end]</span>
<span class="gi">+    except (ValueError, UnboundLocalError):</span>
<span class="gi">+        # ValueError for doc.index</span>
<span class="gi">+        # UnboundLocalError for undefined end in last line</span>
<span class="gi">+        debug.dbg(&#39;no brackets found - no param&#39;)</span>
<span class="gi">+        end = 0</span>
<span class="gi">+        param_str = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # remove square brackets, that show an optional param ( = None)</span>
<span class="gi">+        def change_options(m):</span>
<span class="gi">+            args = m.group(1).split(&#39;,&#39;)</span>
<span class="gi">+            for i, a in enumerate(args):</span>
<span class="gi">+                if a and &#39;=&#39; not in a:</span>
<span class="gi">+                    args[i] += &#39;=None&#39;</span>
<span class="gi">+            return &#39;,&#39;.join(args)</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            param_str, changes = re.subn(r&#39; ?\[([^\[\]]+)\]&#39;,</span>
<span class="gi">+                                         change_options, param_str)</span>
<span class="gi">+            if changes == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+    param_str = param_str.replace(&#39;-&#39;, &#39;_&#39;)  # see: isinstance.__doc__</span>
<span class="gi">+</span>
<span class="gi">+    # parse return value</span>
<span class="gi">+    r = re.search(&#39;-[&gt;-]* &#39;, doc[end:end + 7])</span>
<span class="gi">+    if r is None:</span>
<span class="gi">+        ret = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        index = end + r.end()</span>
<span class="gi">+        # get result type, which can contain newlines</span>
<span class="gi">+        pattern = re.compile(r&#39;(,\n|[^\n-])+&#39;)</span>
<span class="gi">+        ret_str = pattern.match(doc, index).group(0).strip()</span>
<span class="gi">+        # New object -&gt; object()</span>
<span class="gi">+        ret_str = re.sub(r&#39;[nN]ew (.*)&#39;, r&#39;\1()&#39;, ret_str)</span>
<span class="gi">+</span>
<span class="gi">+        ret = docstr_defaults.get(ret_str, ret_str)</span>
<span class="gi">+</span>
<span class="gi">+    return param_str, ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_from_name(inference_state, compiled_value, name):</span>
<span class="gi">+    access_paths = compiled_value.access_handle.getattr_paths(name, default=None)</span>
<span class="gi">+</span>
<span class="gi">+    value = None</span>
<span class="gi">+    for access_path in access_paths:</span>
<span class="gi">+        value = create_cached_compiled_value(</span>
<span class="gi">+            inference_state,</span>
<span class="gi">+            access_path,</span>
<span class="gi">+            parent_context=None if value is None else value.as_context(),</span>
<span class="gi">+        )</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def _normalize_create_args(func):
<span class="w"> </span>    &quot;&quot;&quot;The cache doesn&#39;t care about keyword vs. normal args.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(inference_state, obj, parent_context=None):</span>
<span class="gi">+        return func(inference_state, obj, parent_context)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_from_access_path(inference_state, access_path):</span>
<span class="gi">+    value = None</span>
<span class="gi">+    for name, access in access_path.accesses:</span>
<span class="gi">+        value = create_cached_compiled_value(</span>
<span class="gi">+            inference_state,</span>
<span class="gi">+            access,</span>
<span class="gi">+            parent_context=None if value is None else value.as_context()</span>
<span class="gi">+        )</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@_normalize_create_args</span>
<span class="gi">+@inference_state_function_cache()</span>
<span class="gi">+def create_cached_compiled_value(inference_state, access_handle, parent_context):</span>
<span class="gi">+    assert not isinstance(parent_context, CompiledValue)</span>
<span class="gi">+    if parent_context is None:</span>
<span class="gi">+        cls = CompiledModule</span>
<span class="gi">+    else:</span>
<span class="gi">+        cls = CompiledValue</span>
<span class="gi">+    return cls(inference_state, access_handle, parent_context)</span>
<span class="gh">diff --git a/jedi/inference/context.py b/jedi/inference/context.py</span>
<span class="gh">index f08ebfd9..5bc6b994 100644</span>
<span class="gd">--- a/jedi/inference/context.py</span>
<span class="gi">+++ b/jedi/inference/context.py</span>
<span class="gu">@@ -2,9 +2,12 @@ from abc import abstractmethod</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Optional
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="w"> </span>from parso.python.tree import Name
<span class="gd">-from jedi.inference.filters import ParserTreeFilter, MergedFilter, GlobalNameFilter</span>
<span class="gi">+</span>
<span class="gi">+from jedi.inference.filters import ParserTreeFilter, MergedFilter, \</span>
<span class="gi">+    GlobalNameFilter</span>
<span class="w"> </span>from jedi.inference.names import AnonymousParamName, TreeNameDefinition
<span class="w"> </span>from jedi.inference.base_value import NO_VALUES, ValueSet
<span class="w"> </span>from jedi.parser_utils import get_parent_scope
<span class="gu">@@ -13,41 +16,326 @@ from jedi import parser_utils</span>


<span class="w"> </span>class AbstractContext:
<span class="gi">+    # Must be defined: inference_state and tree_node and parent_context as an attribute/property</span>

<span class="w"> </span>    def __init__(self, inference_state):
<span class="w"> </span>        self.inference_state = inference_state
<span class="w"> </span>        self.predefined_names = {}

<span class="gd">-    def py__getattribute__(self, name_or_str, name_context=None, position=</span>
<span class="gd">-        None, analysis_errors=True):</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def goto(self, name_or_str, position):</span>
<span class="gi">+        from jedi.inference import finder</span>
<span class="gi">+        filters = _get_global_filters_for_name(</span>
<span class="gi">+            self, name_or_str if isinstance(name_or_str, Name) else None, position,</span>
<span class="gi">+        )</span>
<span class="gi">+        names = finder.filter_name(filters, name_or_str)</span>
<span class="gi">+        debug.dbg(&#39;context.goto %s in (%s): %s&#39;, name_or_str, self, names)</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def py__getattribute__(self, name_or_str, name_context=None, position=None,</span>
<span class="gi">+                           analysis_errors=True):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param position: Position of the last statement -&gt; tuple of line, column
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name_context is None:</span>
<span class="gi">+            name_context = self</span>
<span class="gi">+        names = self.goto(name_or_str, position)</span>
<span class="gi">+</span>
<span class="gi">+        string_name = name_or_str.value if isinstance(name_or_str, Name) else name_or_str</span>
<span class="gi">+</span>
<span class="gi">+        # This paragraph is currently needed for proper branch type inference</span>
<span class="gi">+        # (static analysis).</span>
<span class="gi">+        found_predefined_types = None</span>
<span class="gi">+        if self.predefined_names and isinstance(name_or_str, Name):</span>
<span class="gi">+            node = name_or_str</span>
<span class="gi">+            while node is not None and not parser_utils.is_scope(node):</span>
<span class="gi">+                node = node.parent</span>
<span class="gi">+                if node.type in (&quot;if_stmt&quot;, &quot;for_stmt&quot;, &quot;comp_for&quot;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        name_dict = self.predefined_names[node]</span>
<span class="gi">+                        types = name_dict[string_name]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        found_predefined_types = types</span>
<span class="gi">+                        break</span>
<span class="gi">+        if found_predefined_types is not None and names:</span>
<span class="gi">+            from jedi.inference import flow_analysis</span>
<span class="gi">+            check = flow_analysis.reachability_check(</span>
<span class="gi">+                context=self,</span>
<span class="gi">+                value_scope=self.tree_node,</span>
<span class="gi">+                node=name_or_str,</span>
<span class="gi">+            )</span>
<span class="gi">+            if check is flow_analysis.UNREACHABLE:</span>
<span class="gi">+                values = NO_VALUES</span>
<span class="gi">+            else:</span>
<span class="gi">+                values = found_predefined_types</span>
<span class="gi">+        else:</span>
<span class="gi">+            values = ValueSet.from_sets(name.infer() for name in names)</span>
<span class="gi">+</span>
<span class="gi">+        if not names and not values and analysis_errors:</span>
<span class="gi">+            if isinstance(name_or_str, Name):</span>
<span class="gi">+                from jedi.inference import analysis</span>
<span class="gi">+                message = (&quot;NameError: name &#39;%s&#39; is not defined.&quot; % string_name)</span>
<span class="gi">+                analysis.add(name_context, &#39;name-error&#39;, name_or_str, message)</span>
<span class="gi">+</span>
<span class="gi">+        debug.dbg(&#39;context.names_to_types: %s -&gt; %s&#39;, names, values)</span>
<span class="gi">+        if values:</span>
<span class="gi">+            return values</span>
<span class="gi">+        return self._check_for_additional_knowledge(name_or_str, name_context, position)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_for_additional_knowledge(self, name_or_str, name_context, position):</span>
<span class="gi">+        name_context = name_context or self</span>
<span class="gi">+        # Add isinstance and other if/assert knowledge.</span>
<span class="gi">+        if isinstance(name_or_str, Name) and not name_context.is_instance():</span>
<span class="gi">+            flow_scope = name_or_str</span>
<span class="gi">+            base_nodes = [name_context.tree_node]</span>
<span class="gi">+</span>
<span class="gi">+            if any(b.type in (&#39;comp_for&#39;, &#39;sync_comp_for&#39;) for b in base_nodes):</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            from jedi.inference.finder import check_flow_information</span>
<span class="gi">+            while True:</span>
<span class="gi">+                flow_scope = get_parent_scope(flow_scope, include_flows=True)</span>
<span class="gi">+                n = check_flow_information(name_context, flow_scope,</span>
<span class="gi">+                                           name_or_str, position)</span>
<span class="gi">+                if n is not None:</span>
<span class="gi">+                    return n</span>
<span class="gi">+                if flow_scope in base_nodes:</span>
<span class="gi">+                    break</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def get_root_context(self):</span>
<span class="gi">+        parent_context = self.parent_context</span>
<span class="gi">+        if parent_context is None:</span>
<span class="gi">+            return self</span>
<span class="gi">+        return parent_context.get_root_context()</span>
<span class="gi">+</span>
<span class="gi">+    def is_module(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_builtins_module(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_instance(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_compiled(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_bound_method(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_value(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return ()</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def predefine_names(self, flow_scope, dct):</span>
<span class="gi">+        predefined = self.predefined_names</span>
<span class="gi">+        predefined[flow_scope] = dct</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            del predefined[flow_scope]</span>


<span class="w"> </span>class ValueContext(AbstractContext):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Should be defined, otherwise the API returns empty types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value):
<span class="w"> </span>        super().__init__(value.inference_state)
<span class="w"> </span>        self._value = value

<span class="gi">+    @property</span>
<span class="gi">+    def tree_node(self):</span>
<span class="gi">+        return self._value.tree_node</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def parent_context(self):</span>
<span class="gi">+        return self._value.parent_context</span>
<span class="gi">+</span>
<span class="gi">+    def is_module(self):</span>
<span class="gi">+        return self._value.is_module()</span>
<span class="gi">+</span>
<span class="gi">+    def is_builtins_module(self):</span>
<span class="gi">+        return self._value == self.inference_state.builtins_module</span>
<span class="gi">+</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return self._value.is_class()</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return self._value.is_stub()</span>
<span class="gi">+</span>
<span class="gi">+    def is_instance(self):</span>
<span class="gi">+        return self._value.is_instance()</span>
<span class="gi">+</span>
<span class="gi">+    def is_compiled(self):</span>
<span class="gi">+        return self._value.is_compiled()</span>
<span class="gi">+</span>
<span class="gi">+    def is_bound_method(self):</span>
<span class="gi">+        return self._value.is_bound_method()</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self._value.py__name__()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return self._value.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return self._value.get_qualified_names()</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return self._value.py__doc__()</span>
<span class="gi">+</span>
<span class="gi">+    def get_value(self):</span>
<span class="gi">+        return self._value</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s)&#39; % (self.__class__.__name__, self._value)


<span class="w"> </span>class TreeContextMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def infer_node(self, node):</span>
<span class="gi">+        from jedi.inference.syntax_tree import infer_node</span>
<span class="gi">+        return infer_node(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    def create_value(self, node):</span>
<span class="gi">+        from jedi.inference import value</span>
<span class="gi">+</span>
<span class="gi">+        if node == self.tree_node:</span>
<span class="gi">+            assert self.is_module()</span>
<span class="gi">+            return self.get_value()</span>
<span class="gi">+</span>
<span class="gi">+        parent_context = self.create_context(node)</span>
<span class="gi">+</span>
<span class="gi">+        if node.type in (&#39;funcdef&#39;, &#39;lambdef&#39;):</span>
<span class="gi">+            func = value.FunctionValue.from_context(parent_context, node)</span>
<span class="gi">+            if parent_context.is_class():</span>
<span class="gi">+                class_value = parent_context.parent_context.create_value(parent_context.tree_node)</span>
<span class="gi">+                instance = value.AnonymousInstance(</span>
<span class="gi">+                    self.inference_state, parent_context.parent_context, class_value)</span>
<span class="gi">+                func = value.BoundMethod(</span>
<span class="gi">+                    instance=instance,</span>
<span class="gi">+                    class_context=class_value.as_context(),</span>
<span class="gi">+                    function=func</span>
<span class="gi">+                )</span>
<span class="gi">+            return func</span>
<span class="gi">+        elif node.type == &#39;classdef&#39;:</span>
<span class="gi">+            return value.ClassValue(self.inference_state, parent_context, node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(&quot;Probably shouldn&#39;t happen: %s&quot; % node)</span>
<span class="gi">+</span>
<span class="gi">+    def create_context(self, node):</span>
<span class="gi">+        def from_scope_node(scope_node, is_nested=True):</span>
<span class="gi">+            if scope_node == self.tree_node:</span>
<span class="gi">+                return self</span>
<span class="gi">+</span>
<span class="gi">+            if scope_node.type in (&#39;funcdef&#39;, &#39;lambdef&#39;, &#39;classdef&#39;):</span>
<span class="gi">+                return self.create_value(scope_node).as_context()</span>
<span class="gi">+            elif scope_node.type in (&#39;comp_for&#39;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+                parent_context = from_scope_node(parent_scope(scope_node.parent))</span>
<span class="gi">+                if node.start_pos &gt;= scope_node.children[-1].start_pos:</span>
<span class="gi">+                    return parent_context</span>
<span class="gi">+                return CompForContext(parent_context, scope_node)</span>
<span class="gi">+            raise Exception(&quot;There&#39;s a scope that was not managed: %s&quot; % scope_node)</span>
<span class="gi">+</span>
<span class="gi">+        def parent_scope(node):</span>
<span class="gi">+            while True:</span>
<span class="gi">+                node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+                if parser_utils.is_scope(node):</span>
<span class="gi">+                    return node</span>
<span class="gi">+                elif node.type in (&#39;argument&#39;, &#39;testlist_comp&#39;):</span>
<span class="gi">+                    if node.children[1].type in (&#39;comp_for&#39;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+                        return node.children[1]</span>
<span class="gi">+                elif node.type == &#39;dictorsetmaker&#39;:</span>
<span class="gi">+                    for n in node.children[1:4]:</span>
<span class="gi">+                        # In dictionaries it can be pretty much anything.</span>
<span class="gi">+                        if n.type in (&#39;comp_for&#39;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+                            return n</span>
<span class="gi">+</span>
<span class="gi">+        scope_node = parent_scope(node)</span>
<span class="gi">+        if scope_node.type in (&#39;funcdef&#39;, &#39;classdef&#39;):</span>
<span class="gi">+            colon = scope_node.children[scope_node.children.index(&#39;:&#39;)]</span>
<span class="gi">+            if node.start_pos &lt; colon.start_pos:</span>
<span class="gi">+                parent = node.parent</span>
<span class="gi">+                if not (parent.type == &#39;param&#39; and parent.name == node):</span>
<span class="gi">+                    scope_node = parent_scope(scope_node)</span>
<span class="gi">+        return from_scope_node(scope_node, is_nested=True)</span>
<span class="gi">+</span>
<span class="gi">+    def create_name(self, tree_name):</span>
<span class="gi">+        definition = tree_name.get_definition()</span>
<span class="gi">+        if definition and definition.type == &#39;param&#39; and definition.name == tree_name:</span>
<span class="gi">+            funcdef = search_ancestor(definition, &#39;funcdef&#39;, &#39;lambdef&#39;)</span>
<span class="gi">+            func = self.create_value(funcdef)</span>
<span class="gi">+            return AnonymousParamName(func, tree_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            context = self.create_context(tree_name)</span>
<span class="gi">+            return TreeNameDefinition(context, tree_name)</span>


<span class="w"> </span>class FunctionContext(TreeContextMixin, ValueContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield ParserTreeFilter(</span>
<span class="gi">+            self.inference_state,</span>
<span class="gi">+            parent_context=self,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ModuleContext(TreeContextMixin, ValueContext):
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="gi">+        return self._value.py__file__()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        filters = self._value.get_filters(origin_scope)</span>
<span class="gi">+        # Skip the first filter and replace it.</span>
<span class="gi">+        next(filters, None)</span>
<span class="gi">+        yield MergedFilter(</span>
<span class="gi">+            ParserTreeFilter(</span>
<span class="gi">+                parent_context=self,</span>
<span class="gi">+                until_position=until_position,</span>
<span class="gi">+                origin_scope=origin_scope</span>
<span class="gi">+            ),</span>
<span class="gi">+            self.get_global_filter(),</span>
<span class="gi">+        )</span>
<span class="gi">+        yield from filters</span>
<span class="gi">+</span>
<span class="gi">+    def get_global_filter(self):</span>
<span class="gi">+        return GlobalNameFilter(self)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def string_names(self):</span>
<span class="gi">+        return self._value.string_names</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def code_lines(self):</span>
<span class="gi">+        return self._value.code_lines</span>

<span class="w"> </span>    def get_value(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -55,35 +343,94 @@ class ModuleContext(TreeContextMixin, ValueContext):</span>
<span class="w"> </span>        This is necessary for stub -&gt; python conversion and vice versa. However
<span class="w"> </span>        this method shouldn&#39;t be moved to AbstractContext.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value</span>


<span class="w"> </span>class NamespaceContext(TreeContextMixin, ValueContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        return self._value.get_filters()</span>
<span class="gi">+</span>
<span class="gi">+    def get_value(self):</span>
<span class="gi">+        return self._value</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def string_names(self):</span>
<span class="gi">+        return self._value.string_names</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="gi">+        return self._value.py__file__()  # type: ignore[no-any-return]</span>


<span class="w"> </span>class ClassContext(TreeContextMixin, ValueContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield self.get_global_filter(until_position, origin_scope)</span>

<span class="gi">+    def get_global_filter(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        return ParserTreeFilter(</span>
<span class="gi">+            parent_context=self,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope</span>
<span class="gi">+        )</span>

<span class="gd">-class CompForContext(TreeContextMixin, AbstractContext):</span>

<span class="gi">+class CompForContext(TreeContextMixin, AbstractContext):</span>
<span class="w"> </span>    def __init__(self, parent_context, comp_for):
<span class="w"> </span>        super().__init__(parent_context.inference_state)
<span class="w"> </span>        self.tree_node = comp_for
<span class="w"> </span>        self.parent_context = parent_context

<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield ParserTreeFilter(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_value(self):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return &#39;&lt;comprehension context&gt;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s)&#39; % (self.__class__.__name__, self.tree_node)


<span class="w"> </span>class CompiledContext(ValueContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        return self._value.get_filters()</span>


<span class="w"> </span>class CompiledModuleContext(CompiledContext):
<span class="w"> </span>    code_lines = None

<span class="gi">+    def get_value(self):</span>
<span class="gi">+        return self._value</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def string_names(self):</span>
<span class="gi">+        return self._value.string_names</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="gi">+        return self._value.py__file__()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_global_filters_for_name(context, name_or_none, position):</span>
<span class="gi">+    # For functions and classes the defaults don&#39;t belong to the</span>
<span class="gi">+    # function and get inferred in the value before the function. So</span>
<span class="gi">+    # make sure to exclude the function/class name.</span>
<span class="gi">+    if name_or_none is not None:</span>
<span class="gi">+        ancestor = search_ancestor(name_or_none, &#39;funcdef&#39;, &#39;classdef&#39;, &#39;lambdef&#39;)</span>
<span class="gi">+        lambdef = None</span>
<span class="gi">+        if ancestor == &#39;lambdef&#39;:</span>
<span class="gi">+            # For lambdas it&#39;s even more complicated since parts will</span>
<span class="gi">+            # be inferred later.</span>
<span class="gi">+            lambdef = ancestor</span>
<span class="gi">+            ancestor = search_ancestor(name_or_none, &#39;funcdef&#39;, &#39;classdef&#39;)</span>
<span class="gi">+        if ancestor is not None:</span>
<span class="gi">+            colon = ancestor.children[-2]</span>
<span class="gi">+            if position is not None and position &lt; colon.start_pos:</span>
<span class="gi">+                if lambdef is None or position &lt; lambdef.children[-2].start_pos:</span>
<span class="gi">+                    position = ancestor.start_pos</span>
<span class="gi">+</span>
<span class="gi">+    return get_global_filters(context, position, name_or_none)</span>
<span class="gi">+</span>

<span class="w"> </span>def get_global_filters(context, until_position, origin_scope):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -132,4 +479,21 @@ def get_global_filters(context, until_position, origin_scope):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(filters[3].values())  # doctest: +ELLIPSIS
<span class="w"> </span>    [...]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    base_context = context</span>
<span class="gi">+    from jedi.inference.value.function import BaseFunctionExecutionContext</span>
<span class="gi">+    while context is not None:</span>
<span class="gi">+        # Names in methods cannot be resolved within the class.</span>
<span class="gi">+        yield from context.get_filters(</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope</span>
<span class="gi">+        )</span>
<span class="gi">+        if isinstance(context, (BaseFunctionExecutionContext, ModuleContext)):</span>
<span class="gi">+            # The position should be reset if the current scope is a function.</span>
<span class="gi">+            until_position = None</span>
<span class="gi">+</span>
<span class="gi">+        context = context.parent_context</span>
<span class="gi">+</span>
<span class="gi">+    b = next(base_context.inference_state.builtins_module.get_filters(), None)</span>
<span class="gi">+    assert b is not None</span>
<span class="gi">+    # Add builtins to the global scope.</span>
<span class="gi">+    yield b</span>
<span class="gh">diff --git a/jedi/inference/docstring_utils.py b/jedi/inference/docstring_utils.py</span>
<span class="gh">index 307bddc3..bee0d75e 100644</span>
<span class="gd">--- a/jedi/inference/docstring_utils.py</span>
<span class="gi">+++ b/jedi/inference/docstring_utils.py</span>
<span class="gu">@@ -3,14 +3,19 @@ from jedi.inference.context import ModuleContext</span>


<span class="w"> </span>class DocstringModule(ModuleValue):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, in_module_context, **kwargs):
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self._in_module_context = in_module_context

<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return DocstringModuleContext(self, self._in_module_context)</span>

<span class="gd">-class DocstringModuleContext(ModuleContext):</span>

<span class="gi">+class DocstringModuleContext(ModuleContext):</span>
<span class="w"> </span>    def __init__(self, module_value, in_module_context):
<span class="w"> </span>        super().__init__(module_value)
<span class="w"> </span>        self._in_module_context = in_module_context
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, origin_scope=None, until_position=None):</span>
<span class="gi">+        yield from super().get_filters(until_position=until_position)</span>
<span class="gi">+        yield from self._in_module_context.get_filters()</span>
<span class="gh">diff --git a/jedi/inference/docstrings.py b/jedi/inference/docstrings.py</span>
<span class="gh">index c054a3b5..809974f3 100644</span>
<span class="gd">--- a/jedi/inference/docstrings.py</span>
<span class="gi">+++ b/jedi/inference/docstrings.py</span>
<span class="gu">@@ -14,38 +14,119 @@ type of ``foo`` is ``str``.</span>
<span class="w"> </span>As an addition to parameter searching, this module also provides return
<span class="w"> </span>annotations.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from parso import parse, ParserSyntaxError
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="gd">-from jedi.inference.base_value import iterator_to_value_set, ValueSet, NO_VALUES</span>
<span class="gi">+from jedi.inference.base_value import iterator_to_value_set, ValueSet, \</span>
<span class="gi">+    NO_VALUES</span>
<span class="w"> </span>from jedi.inference.lazy_value import LazyKnownValues
<span class="gd">-DOCSTRING_PARAM_PATTERNS = [&#39;\\s*:type\\s+%s:\\s*([^\\n]+)&#39;,</span>
<span class="gd">-    &#39;\\s*:param\\s+(\\w+)\\s+%s:[^\\n]*&#39;, &#39;\\s*@type\\s+%s:\\s*([^\\n]+)&#39;]</span>
<span class="gd">-DOCSTRING_RETURN_PATTERNS = [re.compile(&#39;\\s*:rtype:\\s*([^\\n]+)&#39;, re.M),</span>
<span class="gd">-    re.compile(&#39;\\s*@rtype:\\s*([^\\n]+)&#39;, re.M)]</span>
<span class="gd">-REST_ROLE_PATTERN = re.compile(&#39;:[^`]+:`([^`]+)`&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DOCSTRING_PARAM_PATTERNS = [</span>
<span class="gi">+    r&#39;\s*:type\s+%s:\s*([^\n]+)&#39;,  # Sphinx</span>
<span class="gi">+    r&#39;\s*:param\s+(\w+)\s+%s:[^\n]*&#39;,  # Sphinx param with type</span>
<span class="gi">+    r&#39;\s*@type\s+%s:\s*([^\n]+)&#39;,  # Epydoc</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+DOCSTRING_RETURN_PATTERNS = [</span>
<span class="gi">+    re.compile(r&#39;\s*:rtype:\s*([^\n]+)&#39;, re.M),  # Sphinx</span>
<span class="gi">+    re.compile(r&#39;\s*@rtype:\s*([^\n]+)&#39;, re.M),  # Epydoc</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+REST_ROLE_PATTERN = re.compile(r&#39;:[^`]+:`([^`]+)`&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_numpy_doc_string_cache = None


<span class="gi">+def _get_numpy_doc_string_cls():</span>
<span class="gi">+    global _numpy_doc_string_cache</span>
<span class="gi">+    if isinstance(_numpy_doc_string_cache, (ImportError, SyntaxError)):</span>
<span class="gi">+        raise _numpy_doc_string_cache</span>
<span class="gi">+    from numpydoc.docscrape import NumpyDocString  # type: ignore[import]</span>
<span class="gi">+    _numpy_doc_string_cache = NumpyDocString</span>
<span class="gi">+    return _numpy_doc_string_cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def _search_param_in_numpydocstr(docstr, param_str):
<span class="w"> </span>    &quot;&quot;&quot;Search `docstr` (in numpydoc format) for type(-s) of `param_str`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.simplefilter(&quot;ignore&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            # This is a non-public API. If it ever changes we should be</span>
<span class="gi">+            # prepared and return gracefully.</span>
<span class="gi">+            params = _get_numpy_doc_string_cls()(docstr)._parsed_data[&#39;Parameters&#39;]</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return []</span>
<span class="gi">+    for p_name, p_type, p_descr in params:</span>
<span class="gi">+        if p_name == param_str:</span>
<span class="gi">+            m = re.match(r&#39;([^,]+(,[^,]+)*?)(,[ ]*optional)?$&#39;, p_type)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                p_type = m.group(1)</span>
<span class="gi">+            return list(_expand_typestr(p_type))</span>
<span class="gi">+    return []</span>


<span class="w"> </span>def _search_return_in_numpydocstr(docstr):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Search `docstr` (in numpydoc format) for type(-s) of function returns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.simplefilter(&quot;ignore&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            doc = _get_numpy_doc_string_cls()(docstr)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return</span>
<span class="gi">+    try:</span>
<span class="gi">+        # This is a non-public API. If it ever changes we should be</span>
<span class="gi">+        # prepared and return gracefully.</span>
<span class="gi">+        returns = doc._parsed_data[&#39;Returns&#39;]</span>
<span class="gi">+        returns += doc._parsed_data[&#39;Yields&#39;]</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return</span>
<span class="gi">+    for r_name, r_type, r_descr in returns:</span>
<span class="gi">+        # Return names are optional and if so the type is in the name</span>
<span class="gi">+        if not r_type:</span>
<span class="gi">+            r_type = r_name</span>
<span class="gi">+        yield from _expand_typestr(r_type)</span>


<span class="w"> </span>def _expand_typestr(type_str):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attempts to interpret the possible types in `type_str`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check if alternative types are specified with &#39;or&#39;</span>
<span class="gi">+    if re.search(r&#39;\bor\b&#39;, type_str):</span>
<span class="gi">+        for t in type_str.split(&#39;or&#39;):</span>
<span class="gi">+            yield t.split(&#39;of&#39;)[0].strip()</span>
<span class="gi">+    # Check if like &quot;list of `type`&quot; and set type to list</span>
<span class="gi">+    elif re.search(r&#39;\bof\b&#39;, type_str):</span>
<span class="gi">+        yield type_str.split(&#39;of&#39;)[0]</span>
<span class="gi">+    # Check if type has is a set of valid literal values eg: {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}</span>
<span class="gi">+    elif type_str.startswith(&#39;{&#39;):</span>
<span class="gi">+        node = parse(type_str, version=&#39;3.7&#39;).children[0]</span>
<span class="gi">+        if node.type == &#39;atom&#39;:</span>
<span class="gi">+            for leaf in getattr(node.children[1], &quot;children&quot;, []):</span>
<span class="gi">+                if leaf.type == &#39;number&#39;:</span>
<span class="gi">+                    if &#39;.&#39; in leaf.value:</span>
<span class="gi">+                        yield &#39;float&#39;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield &#39;int&#39;</span>
<span class="gi">+                elif leaf.type == &#39;string&#39;:</span>
<span class="gi">+                    if &#39;b&#39; in leaf.string_prefix.lower():</span>
<span class="gi">+                        yield &#39;bytes&#39;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield &#39;str&#39;</span>
<span class="gi">+                # Ignore everything else.</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise just work with what we have.</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield type_str</span>


<span class="w"> </span>def _search_param_in_docstr(docstr, param_str):
<span class="gu">@@ -65,7 +146,15 @@ def _search_param_in_docstr(docstr, param_str):</span>
<span class="w"> </span>    [&#39;int&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # look at #40 to see definitions of those params</span>
<span class="gi">+    patterns = [re.compile(p % re.escape(param_str))</span>
<span class="gi">+                for p in DOCSTRING_PARAM_PATTERNS]</span>
<span class="gi">+    for pattern in patterns:</span>
<span class="gi">+        match = pattern.search(docstr)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return [_strip_rst_role(match.group(1))]</span>
<span class="gi">+</span>
<span class="gi">+    return _search_param_in_numpydocstr(docstr, param_str)</span>


<span class="w"> </span>def _strip_rst_role(type_str):
<span class="gu">@@ -83,7 +172,48 @@ def _strip_rst_role(type_str):</span>
<span class="w"> </span>    http://sphinx-doc.org/domains.html#cross-referencing-python-objects

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = REST_ROLE_PATTERN.match(type_str)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        return match.group(1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return type_str</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_for_statement_string(module_context, string):</span>
<span class="gi">+    if string is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    potential_imports = re.findall(r&#39;((?:\w+\.)*\w+)\.&#39;, string)</span>
<span class="gi">+    # Try to import module part in dotted name.</span>
<span class="gi">+    # (e.g., &#39;threading&#39; in &#39;threading.Thread&#39;).</span>
<span class="gi">+    imports = &quot;\n&quot;.join(f&quot;import {p}&quot; for p in potential_imports)</span>
<span class="gi">+    string = f&#39;{imports}\n{string}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    debug.dbg(&#39;Parse docstring code %s&#39;, string, color=&#39;BLUE&#39;)</span>
<span class="gi">+    grammar = module_context.inference_state.grammar</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = grammar.parse(string, error_recovery=False)</span>
<span class="gi">+    except ParserSyntaxError:</span>
<span class="gi">+        return []</span>
<span class="gi">+    try:</span>
<span class="gi">+        # It&#39;s not the last item, because that&#39;s an end marker.</span>
<span class="gi">+        stmt = module.children[-2]</span>
<span class="gi">+    except (AttributeError, IndexError):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if stmt.type not in (&#39;name&#39;, &#39;atom&#39;, &#39;atom_expr&#39;):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    # Here we basically use a fake module that also uses the filters in</span>
<span class="gi">+    # the actual module.</span>
<span class="gi">+    from jedi.inference.docstring_utils import DocstringModule</span>
<span class="gi">+    m = DocstringModule(</span>
<span class="gi">+        in_module_context=module_context,</span>
<span class="gi">+        inference_state=module_context.inference_state,</span>
<span class="gi">+        module_node=module,</span>
<span class="gi">+        code_lines=[],</span>
<span class="gi">+    )</span>
<span class="gi">+    return list(_execute_types_in_stmt(m.as_context(), stmt))</span>


<span class="w"> </span>def _execute_types_in_stmt(module_context, stmt):
<span class="gu">@@ -92,7 +222,11 @@ def _execute_types_in_stmt(module_context, stmt):</span>
<span class="w"> </span>    doesn&#39;t include tuple, list and dict literals, because the stuff they
<span class="w"> </span>    contain is executed. (Used as type information).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    definitions = module_context.infer_node(stmt)</span>
<span class="gi">+    return ValueSet.from_sets(</span>
<span class="gi">+        _execute_array_values(module_context.inference_state, d)</span>
<span class="gi">+        for d in definitions</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _execute_array_values(inference_state, array):
<span class="gu">@@ -100,4 +234,53 @@ def _execute_array_values(inference_state, array):</span>
<span class="w"> </span>    Tuples indicate that there&#39;s not just one return value, but the listed
<span class="w"> </span>    ones.  `(str, int)` means that it returns a tuple with both types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from jedi.inference.value.iterable import SequenceLiteralValue, FakeTuple, FakeList</span>
<span class="gi">+    if isinstance(array, SequenceLiteralValue) and array.array_type in (&#39;tuple&#39;, &#39;list&#39;):</span>
<span class="gi">+        values = []</span>
<span class="gi">+        for lazy_value in array.py__iter__():</span>
<span class="gi">+            objects = ValueSet.from_sets(</span>
<span class="gi">+                _execute_array_values(inference_state, typ)</span>
<span class="gi">+                for typ in lazy_value.infer()</span>
<span class="gi">+            )</span>
<span class="gi">+            values.append(LazyKnownValues(objects))</span>
<span class="gi">+        cls = FakeTuple if array.array_type == &#39;tuple&#39; else FakeList</span>
<span class="gi">+        return {cls(inference_state, values)}</span>
<span class="gi">+    else:</span>
<span class="gi">+        return array.execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_method_cache()</span>
<span class="gi">+def infer_param(function_value, param):</span>
<span class="gi">+    def infer_docstring(docstring):</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            p</span>
<span class="gi">+            for param_str in _search_param_in_docstr(docstring, param.name.value)</span>
<span class="gi">+            for p in _infer_for_statement_string(module_context, param_str)</span>
<span class="gi">+        )</span>
<span class="gi">+    module_context = function_value.get_root_context()</span>
<span class="gi">+    func = param.get_parent_function()</span>
<span class="gi">+    if func.type == &#39;lambdef&#39;:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    types = infer_docstring(function_value.py__doc__())</span>
<span class="gi">+    if function_value.is_bound_method() \</span>
<span class="gi">+            and function_value.py__name__() == &#39;__init__&#39;:</span>
<span class="gi">+        types |= infer_docstring(function_value.class_context.py__doc__())</span>
<span class="gi">+</span>
<span class="gi">+    debug.dbg(&#39;Found param types for docstring: %s&#39;, types, color=&#39;BLUE&#39;)</span>
<span class="gi">+    return types</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_method_cache()</span>
<span class="gi">+@iterator_to_value_set</span>
<span class="gi">+def infer_return_types(function_value):</span>
<span class="gi">+    def search_return_in_docstr(code):</span>
<span class="gi">+        for p in DOCSTRING_RETURN_PATTERNS:</span>
<span class="gi">+            match = p.search(code)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                yield _strip_rst_role(match.group(1))</span>
<span class="gi">+        # Check for numpy style return hint</span>
<span class="gi">+        yield from _search_return_in_numpydocstr(code)</span>
<span class="gi">+</span>
<span class="gi">+    for type_str in search_return_in_docstr(function_value.py__doc__()):</span>
<span class="gi">+        yield from _infer_for_statement_string(function_value.get_root_context(), type_str)</span>
<span class="gh">diff --git a/jedi/inference/dynamic_params.py b/jedi/inference/dynamic_params.py</span>
<span class="gh">index ef714079..e759111a 100644</span>
<span class="gd">--- a/jedi/inference/dynamic_params.py</span>
<span class="gi">+++ b/jedi/inference/dynamic_params.py</span>
<span class="gu">@@ -16,6 +16,7 @@ It works as follows:</span>
<span class="w"> </span>- search for function calls named ``foo``
<span class="w"> </span>- execute these calls and check the input.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.parser_utils import get_parent_scope
<span class="gu">@@ -28,9 +29,28 @@ from jedi.inference.value import instance</span>
<span class="w"> </span>from jedi.inference.base_value import ValueSet, NO_VALUES
<span class="w"> </span>from jedi.inference.references import get_module_contexts_containing_name
<span class="w"> </span>from jedi.inference import recursion
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>MAX_PARAM_SEARCHES = 20


<span class="gi">+def _avoid_recursions(func):</span>
<span class="gi">+    def wrapper(function_value, param_index):</span>
<span class="gi">+        inf = function_value.inference_state</span>
<span class="gi">+        with recursion.execution_allowed(inf, function_value.tree_node) as allowed:</span>
<span class="gi">+            # We need to catch recursions that may occur, because an</span>
<span class="gi">+            # anonymous functions can create an anonymous parameter that is</span>
<span class="gi">+            # more or less self referencing.</span>
<span class="gi">+            if allowed:</span>
<span class="gi">+                inf.dynamic_params_depth += 1</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return func(function_value, param_index)</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    inf.dynamic_params_depth -= 1</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@debug.increase_indent
<span class="w"> </span>@_avoid_recursions
<span class="w"> </span>def dynamic_param_lookup(function_value, param_index):
<span class="gu">@@ -46,7 +66,37 @@ def dynamic_param_lookup(function_value, param_index):</span>
<span class="w"> </span>    have to look for all calls to ``func`` to find out what ``foo`` possibly
<span class="w"> </span>    is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not function_value.inference_state.do_dynamic_params_search:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    funcdef = function_value.tree_node</span>
<span class="gi">+</span>
<span class="gi">+    path = function_value.get_root_context().py__file__()</span>
<span class="gi">+    if path is not None and is_stdlib_path(path):</span>
<span class="gi">+        # We don&#39;t want to search for references in the stdlib. Usually people</span>
<span class="gi">+        # don&#39;t work with it (except if you are a core maintainer, sorry).</span>
<span class="gi">+        # This makes everything slower. Just disable it and run the tests,</span>
<span class="gi">+        # you will see the slowdown, especially in 3.6.</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    if funcdef.type == &#39;lambdef&#39;:</span>
<span class="gi">+        string_name = _get_lambda_name(funcdef)</span>
<span class="gi">+        if string_name is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+    else:</span>
<span class="gi">+        string_name = funcdef.name.value</span>
<span class="gi">+    debug.dbg(&#39;Dynamic param search in %s.&#39;, string_name, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    module_context = function_value.get_root_context()</span>
<span class="gi">+    arguments_list = _search_function_arguments(module_context, funcdef, string_name)</span>
<span class="gi">+    values = ValueSet.from_sets(</span>
<span class="gi">+        get_executed_param_names(</span>
<span class="gi">+            function_value, arguments</span>
<span class="gi">+        )[param_index].infer()</span>
<span class="gi">+        for arguments in arguments_list</span>
<span class="gi">+    )</span>
<span class="gi">+    debug.dbg(&#39;Dynamic param result finished&#39;, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+    return values</span>


<span class="w"> </span>@inference_state_method_cache(default=None)
<span class="gu">@@ -55,4 +105,120 @@ def _search_function_arguments(module_context, funcdef, string_name):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a list of param names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    compare_node = funcdef</span>
<span class="gi">+    if string_name == &#39;__init__&#39;:</span>
<span class="gi">+        cls = get_parent_scope(funcdef)</span>
<span class="gi">+        if cls.type == &#39;classdef&#39;:</span>
<span class="gi">+            string_name = cls.name.value</span>
<span class="gi">+            compare_node = cls</span>
<span class="gi">+</span>
<span class="gi">+    found_arguments = False</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    inference_state = module_context.inference_state</span>
<span class="gi">+</span>
<span class="gi">+    if settings.dynamic_params_for_other_modules:</span>
<span class="gi">+        module_contexts = get_module_contexts_containing_name(</span>
<span class="gi">+            inference_state, [module_context], string_name,</span>
<span class="gi">+            # Limit the amounts of files to be opened massively.</span>
<span class="gi">+            limit_reduction=5,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_contexts = [module_context]</span>
<span class="gi">+</span>
<span class="gi">+    for for_mod_context in module_contexts:</span>
<span class="gi">+        for name, trailer in _get_potential_nodes(for_mod_context, string_name):</span>
<span class="gi">+            i += 1</span>
<span class="gi">+</span>
<span class="gi">+            # This is a simple way to stop Jedi&#39;s dynamic param recursion</span>
<span class="gi">+            # from going wild: The deeper Jedi&#39;s in the recursion, the less</span>
<span class="gi">+            # code should be inferred.</span>
<span class="gi">+            if i * inference_state.dynamic_params_depth &gt; MAX_PARAM_SEARCHES:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            random_context = for_mod_context.create_context(name)</span>
<span class="gi">+            for arguments in _check_name_for_execution(</span>
<span class="gi">+                    inference_state, random_context, compare_node, name, trailer):</span>
<span class="gi">+                found_arguments = True</span>
<span class="gi">+                yield arguments</span>
<span class="gi">+</span>
<span class="gi">+        # If there are results after processing a module, we&#39;re probably</span>
<span class="gi">+        # good to process. This is a speed optimization.</span>
<span class="gi">+        if found_arguments:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_lambda_name(node):</span>
<span class="gi">+    stmt = node.parent</span>
<span class="gi">+    if stmt.type == &#39;expr_stmt&#39;:</span>
<span class="gi">+        first_operator = next(stmt.yield_operators(), None)</span>
<span class="gi">+        if first_operator == &#39;=&#39;:</span>
<span class="gi">+            first = stmt.children[0]</span>
<span class="gi">+            if first.type == &#39;name&#39;:</span>
<span class="gi">+                return first.value</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_potential_nodes(module_value, func_string_name):</span>
<span class="gi">+    try:</span>
<span class="gi">+        names = module_value.tree_node.get_used_names()[func_string_name]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        bracket = name.get_next_leaf()</span>
<span class="gi">+        trailer = bracket.parent</span>
<span class="gi">+        if trailer.type == &#39;trailer&#39; and bracket == &#39;(&#39;:</span>
<span class="gi">+            yield name, trailer</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_name_for_execution(inference_state, context, compare_node, name, trailer):</span>
<span class="gi">+    from jedi.inference.value.function import BaseFunctionExecutionContext</span>
<span class="gi">+</span>
<span class="gi">+    def create_args(value):</span>
<span class="gi">+        arglist = trailer.children[1]</span>
<span class="gi">+        if arglist == &#39;)&#39;:</span>
<span class="gi">+            arglist = None</span>
<span class="gi">+        args = TreeArguments(inference_state, context, arglist, trailer)</span>
<span class="gi">+        from jedi.inference.value.instance import InstanceArguments</span>
<span class="gi">+        if value.tree_node.type == &#39;classdef&#39;:</span>
<span class="gi">+            created_instance = instance.TreeInstance(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                value.parent_context,</span>
<span class="gi">+                value,</span>
<span class="gi">+                args</span>
<span class="gi">+            )</span>
<span class="gi">+            return InstanceArguments(created_instance, args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if value.is_bound_method():</span>
<span class="gi">+                args = InstanceArguments(value.instance, args)</span>
<span class="gi">+            return args</span>
<span class="gi">+</span>
<span class="gi">+    for value in inference_state.infer(context, name):</span>
<span class="gi">+        value_node = value.tree_node</span>
<span class="gi">+        if compare_node == value_node:</span>
<span class="gi">+            yield create_args(value)</span>
<span class="gi">+        elif isinstance(value.parent_context, BaseFunctionExecutionContext) \</span>
<span class="gi">+                and compare_node.type == &#39;funcdef&#39;:</span>
<span class="gi">+            # Here we&#39;re trying to find decorators by checking the first</span>
<span class="gi">+            # parameter. It&#39;s not very generic though. Should find a better</span>
<span class="gi">+            # solution that also applies to nested decorators.</span>
<span class="gi">+            param_names = value.parent_context.get_param_names()</span>
<span class="gi">+            if len(param_names) != 1:</span>
<span class="gi">+                continue</span>
<span class="gi">+            values = param_names[0].infer()</span>
<span class="gi">+            if [v.tree_node for v in values] == [compare_node]:</span>
<span class="gi">+                # Found a decorator.</span>
<span class="gi">+                module_context = context.get_root_context()</span>
<span class="gi">+                execution_context = value.as_context(create_args(value))</span>
<span class="gi">+                potential_nodes = _get_potential_nodes(module_context, param_names[0].string_name)</span>
<span class="gi">+                for name, trailer in potential_nodes:</span>
<span class="gi">+                    if value_node.start_pos &lt; name.start_pos &lt; value_node.end_pos:</span>
<span class="gi">+                        random_context = execution_context.create_context(name)</span>
<span class="gi">+                        yield from _check_name_for_execution(</span>
<span class="gi">+                            inference_state,</span>
<span class="gi">+                            random_context,</span>
<span class="gi">+                            compare_node,</span>
<span class="gi">+                            name,</span>
<span class="gi">+                            trailer</span>
<span class="gi">+                        )</span>
<span class="gh">diff --git a/jedi/inference/filters.py b/jedi/inference/filters.py</span>
<span class="gh">index 4dab38a3..62782334 100644</span>
<span class="gd">--- a/jedi/inference/filters.py</span>
<span class="gi">+++ b/jedi/inference/filters.py</span>
<span class="gu">@@ -5,13 +5,18 @@ are needed for name resolution.</span>
<span class="w"> </span>from abc import abstractmethod
<span class="w"> </span>from typing import List, MutableMapping, Type
<span class="w"> </span>import weakref
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="w"> </span>from parso.python.tree import Name, UsedNamesMapping
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference import flow_analysis
<span class="gd">-from jedi.inference.base_value import ValueSet, ValueWrapper, LazyValueWrapper</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, ValueWrapper, \</span>
<span class="gi">+    LazyValueWrapper</span>
<span class="w"> </span>from jedi.parser_utils import get_cached_parent_scope, get_parso_cache_node
<span class="w"> </span>from jedi.inference.utils import to_list
<span class="gd">-from jedi.inference.names import TreeNameDefinition, ParamName, AnonymousParamName, AbstractNameDefinition, NameWrapper</span>
<span class="gi">+from jedi.inference.names import TreeNameDefinition, ParamName, \</span>
<span class="gi">+    AnonymousParamName, AbstractNameDefinition, NameWrapper</span>
<span class="gi">+</span>
<span class="w"> </span>_definition_name_cache: MutableMapping[UsedNamesMapping, List[Name]]
<span class="w"> </span>_definition_name_cache = weakref.WeakKeyDictionary()

<span class="gu">@@ -19,6 +24,19 @@ _definition_name_cache = weakref.WeakKeyDictionary()</span>
<span class="w"> </span>class AbstractFilter:
<span class="w"> </span>    _until_position = None

<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        if self._until_position is not None:</span>
<span class="gi">+            return [n for n in names if n.start_pos &lt; self._until_position]</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def get(self, name):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>

<span class="w"> </span>class FilterWrapper:
<span class="w"> </span>    name_wrapper_class: Type[NameWrapper]
<span class="gu">@@ -26,6 +44,35 @@ class FilterWrapper:</span>
<span class="w"> </span>    def __init__(self, wrapped_filter):
<span class="w"> </span>        self._wrapped_filter = wrapped_filter

<span class="gi">+    def wrap_names(self, names):</span>
<span class="gi">+        return [self.name_wrapper_class(name) for name in names]</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return self.wrap_names(self._wrapped_filter.get(name))</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self.wrap_names(self._wrapped_filter.values())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_definition_names(parso_cache_node, used_names, name_key):</span>
<span class="gi">+    if parso_cache_node is None:</span>
<span class="gi">+        names = used_names.get(name_key, ())</span>
<span class="gi">+        return tuple(name for name in names if name.is_definition(include_setitem=True))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for_module = _definition_name_cache[parso_cache_node]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        for_module = _definition_name_cache[parso_cache_node] = {}</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return for_module[name_key]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        names = used_names.get(name_key, ())</span>
<span class="gi">+        result = for_module[name_key] = tuple(</span>
<span class="gi">+            name for name in names if name.is_definition(include_setitem=True)</span>
<span class="gi">+        )</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class _AbstractUsedNamesFilter(AbstractFilter):
<span class="w"> </span>    name_class = TreeNameDefinition
<span class="gu">@@ -36,24 +83,52 @@ class _AbstractUsedNamesFilter(AbstractFilter):</span>
<span class="w"> </span>        self._node_context = node_context
<span class="w"> </span>        self._parser_scope = node_context.tree_node
<span class="w"> </span>        module_context = node_context.get_root_context()
<span class="gi">+        # It is quite hacky that we have to use that. This is for caching</span>
<span class="gi">+        # certain things with a WeakKeyDictionary. However, parso intentionally</span>
<span class="gi">+        # uses slots (to save memory) and therefore we end up with having to</span>
<span class="gi">+        # have a weak reference to the object that caches the tree.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Previously we have tried to solve this by using a weak reference onto</span>
<span class="gi">+        # used_names. However that also does not work, because it has a</span>
<span class="gi">+        # reference from the module, which itself is referenced by any node</span>
<span class="gi">+        # through parents.</span>
<span class="w"> </span>        path = module_context.py__file__()
<span class="w"> </span>        if path is None:
<span class="gi">+            # If the path is None, there is no guarantee that parso caches it.</span>
<span class="w"> </span>            self._parso_cache_node = None
<span class="w"> </span>        else:
<span class="gd">-            self._parso_cache_node = get_parso_cache_node(module_context.</span>
<span class="gd">-                inference_state.latest_grammar if module_context.is_stub() else</span>
<span class="gd">-                module_context.inference_state.grammar, path)</span>
<span class="gi">+            self._parso_cache_node = get_parso_cache_node(</span>
<span class="gi">+                module_context.inference_state.latest_grammar</span>
<span class="gi">+                if module_context.is_stub() else module_context.inference_state.grammar,</span>
<span class="gi">+                path</span>
<span class="gi">+            )</span>
<span class="w"> </span>        self._used_names = module_context.tree_node.get_used_names()
<span class="w"> </span>        self.parent_context = parent_context

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return self._convert_names(self._filter(</span>
<span class="gi">+            _get_definition_names(self._parso_cache_node, self._used_names, name),</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_names(self, names):</span>
<span class="gi">+        return [self.name_class(self.parent_context, name) for name in names]</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._convert_names(</span>
<span class="gi">+            name</span>
<span class="gi">+            for name_key in self._used_names</span>
<span class="gi">+            for name in self._filter(</span>
<span class="gi">+                _get_definition_names(self._parso_cache_node, self._used_names, name_key),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.parent_context)


<span class="w"> </span>class ParserTreeFilter(_AbstractUsedNamesFilter):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, parent_context, node_context=None, until_position=</span>
<span class="gd">-        None, origin_scope=None):</span>
<span class="gi">+    def __init__(self, parent_context, node_context=None, until_position=None,</span>
<span class="gi">+                 origin_scope=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        node_context is an option to specify a second value for use cases
<span class="w"> </span>        like the class mro where the parent class of a new name would be the
<span class="gu">@@ -64,49 +139,134 @@ class ParserTreeFilter(_AbstractUsedNamesFilter):</span>
<span class="w"> </span>        self._origin_scope = origin_scope
<span class="w"> </span>        self._until_position = until_position

<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        names = super()._filter(names)</span>
<span class="gi">+        names = [n for n in names if self._is_name_reachable(n)]</span>
<span class="gi">+        return list(self._check_flows(names))</span>
<span class="gi">+</span>
<span class="gi">+    def _is_name_reachable(self, name):</span>
<span class="gi">+        parent = name.parent</span>
<span class="gi">+        if parent.type == &#39;trailer&#39;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        base_node = parent if parent.type in (&#39;classdef&#39;, &#39;funcdef&#39;) else name</span>
<span class="gi">+        return get_cached_parent_scope(self._parso_cache_node, base_node) == self._parser_scope</span>
<span class="gi">+</span>
<span class="gi">+    def _check_flows(self, names):</span>
<span class="gi">+        for name in sorted(names, key=lambda name: name.start_pos, reverse=True):</span>
<span class="gi">+            check = flow_analysis.reachability_check(</span>
<span class="gi">+                context=self._node_context,</span>
<span class="gi">+                value_scope=self._parser_scope,</span>
<span class="gi">+                node=name,</span>
<span class="gi">+                origin_scope=self._origin_scope</span>
<span class="gi">+            )</span>
<span class="gi">+            if check is not flow_analysis.UNREACHABLE:</span>
<span class="gi">+                yield name</span>
<span class="gi">+</span>
<span class="gi">+            if check is flow_analysis.REACHABLE:</span>
<span class="gi">+                break</span>

<span class="gd">-class _FunctionExecutionFilter(ParserTreeFilter):</span>

<span class="gd">-    def __init__(self, parent_context, function_value, until_position,</span>
<span class="gd">-        origin_scope):</span>
<span class="gd">-        super().__init__(parent_context, until_position=until_position,</span>
<span class="gd">-            origin_scope=origin_scope)</span>
<span class="gi">+class _FunctionExecutionFilter(ParserTreeFilter):</span>
<span class="gi">+    def __init__(self, parent_context, function_value, until_position, origin_scope):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            parent_context,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._function_value = function_value

<span class="gi">+    def _convert_param(self, param, name):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @to_list</span>
<span class="gi">+    def _convert_names(self, names):</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            param = search_ancestor(name, &#39;param&#39;)</span>
<span class="gi">+            # Here we don&#39;t need to check if the param is a default/annotation,</span>
<span class="gi">+            # because those are not definitions and never make it to this</span>
<span class="gi">+            # point.</span>
<span class="gi">+            if param:</span>
<span class="gi">+                yield self._convert_param(param, name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield TreeNameDefinition(self.parent_context, name)</span>

<span class="gd">-class FunctionExecutionFilter(_FunctionExecutionFilter):</span>

<span class="gi">+class FunctionExecutionFilter(_FunctionExecutionFilter):</span>
<span class="w"> </span>    def __init__(self, *args, arguments, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self._arguments = arguments

<span class="gi">+    def _convert_param(self, param, name):</span>
<span class="gi">+        return ParamName(self._function_value, name, self._arguments)</span>
<span class="gi">+</span>

<span class="w"> </span>class AnonymousFunctionExecutionFilter(_FunctionExecutionFilter):
<span class="gd">-    pass</span>
<span class="gi">+    def _convert_param(self, param, name):</span>
<span class="gi">+        return AnonymousParamName(self._function_value, name)</span>


<span class="w"> </span>class GlobalNameFilter(_AbstractUsedNamesFilter):
<span class="gd">-    pass</span>
<span class="gi">+    def get(self, name):</span>
<span class="gi">+        try:</span>
<span class="gi">+            names = self._used_names[name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return self._convert_names(self._filter(names))</span>
<span class="gi">+</span>
<span class="gi">+    @to_list</span>
<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if name.parent.type == &#39;global_stmt&#39;:</span>
<span class="gi">+                yield name</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._convert_names(</span>
<span class="gi">+            name for name_list in self._used_names.values()</span>
<span class="gi">+            for name in self._filter(name_list)</span>
<span class="gi">+        )</span>


<span class="w"> </span>class DictFilter(AbstractFilter):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, dct):
<span class="w"> </span>        self._dct = dct

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = self._convert(name, self._dct[name])</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return list(self._filter([value]))</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        def yielder():</span>
<span class="gi">+            for item in self._dct.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield self._convert(*item)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        return self._filter(yielder())</span>
<span class="gi">+</span>
<span class="gi">+    def _convert(self, name, value):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        keys = &#39;, &#39;.join(self._dct.keys())
<span class="w"> </span>        return &#39;&lt;%s: for {%s}&gt;&#39; % (self.__class__.__name__, keys)


<span class="w"> </span>class MergedFilter:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, *filters):
<span class="w"> </span>        self._filters = filters

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return [n for filter in self._filters for n in filter.get(name)]</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return [n for filter in self._filters for n in filter.values()]</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;%s(%s)&#39; % (self.__class__.__name__, &#39;, &#39;.join(str(f) for f in</span>
<span class="gd">-            self._filters))</span>
<span class="gi">+        return &#39;%s(%s)&#39; % (self.__class__.__name__, &#39;, &#39;.join(str(f) for f in self._filters))</span>


<span class="w"> </span>class _BuiltinMappedMethod(ValueWrapper):
<span class="gu">@@ -118,24 +278,40 @@ class _BuiltinMappedMethod(ValueWrapper):</span>
<span class="w"> </span>        self._value = value
<span class="w"> </span>        self._method = method

<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        # TODO add TypeError if params are given/or not correct.</span>
<span class="gi">+        return self._method(self._value, arguments)</span>
<span class="gi">+</span>

<span class="w"> </span>class SpecialMethodFilter(DictFilter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A filter for methods that are defined in this module on the corresponding
<span class="w"> </span>    classes like Generator (for __next__, etc).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    class SpecialMethodName(AbstractNameDefinition):
<span class="w"> </span>        api_type = &#39;function&#39;

<span class="gd">-        def __init__(self, parent_context, string_name, callable_,</span>
<span class="gd">-            builtin_value):</span>
<span class="gi">+        def __init__(self, parent_context, string_name, callable_, builtin_value):</span>
<span class="w"> </span>            self.parent_context = parent_context
<span class="w"> </span>            self.string_name = string_name
<span class="w"> </span>            self._callable = callable_
<span class="w"> </span>            self._builtin_value = builtin_value

<span class="gi">+        def infer(self):</span>
<span class="gi">+            for filter in self._builtin_value.get_filters():</span>
<span class="gi">+                # We can take the first index, because on builtin methods there&#39;s</span>
<span class="gi">+                # always only going to be one name. The same is true for the</span>
<span class="gi">+                # inferred values.</span>
<span class="gi">+                for name in filter.get(self.string_name):</span>
<span class="gi">+                    builtin_func = next(iter(name.infer()))</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                break</span>
<span class="gi">+            return ValueSet([</span>
<span class="gi">+                _BuiltinMappedMethod(self.parent_context, self._callable, builtin_func)</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, value, dct, builtin_value):
<span class="w"> </span>        super().__init__(dct)
<span class="w"> </span>        self.value = value
<span class="gu">@@ -147,17 +323,21 @@ class SpecialMethodFilter(DictFilter):</span>
<span class="w"> </span>        We distinguish, because we have to.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gi">+    def _convert(self, name, value):</span>
<span class="gi">+        return self.SpecialMethodName(self.value, name, value, self._builtin_value)</span>

<span class="gd">-class _OverwriteMeta(type):</span>

<span class="gi">+class _OverwriteMeta(type):</span>
<span class="w"> </span>    def __init__(cls, name, bases, dct):
<span class="w"> </span>        super().__init__(name, bases, dct)
<span class="gi">+</span>
<span class="w"> </span>        base_dct = {}
<span class="w"> </span>        for base_cls in reversed(cls.__bases__):
<span class="w"> </span>            try:
<span class="w"> </span>                base_dct.update(base_cls.overwritten_methods)
<span class="w"> </span>            except AttributeError:
<span class="w"> </span>                pass
<span class="gi">+</span>
<span class="w"> </span>        for func in cls.__dict__.values():
<span class="w"> </span>            try:
<span class="w"> </span>                base_dct.update(func.registered_overwritten_methods)
<span class="gu">@@ -167,16 +347,25 @@ class _OverwriteMeta(type):</span>


<span class="w"> </span>class _AttributeOverwriteMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        yield SpecialMethodFilter(self, self.overwritten_methods, self._wrapped_value)</span>
<span class="gi">+        yield from self._wrapped_value.get_filters(*args, **kwargs)</span>


<span class="w"> </span>class LazyAttributeOverwrite(_AttributeOverwriteMixin, LazyValueWrapper,
<span class="gd">-    metaclass=_OverwriteMeta):</span>
<span class="gd">-</span>
<span class="gi">+                             metaclass=_OverwriteMeta):</span>
<span class="w"> </span>    def __init__(self, inference_state):
<span class="w"> </span>        self.inference_state = inference_state


<span class="gd">-class AttributeOverwrite(_AttributeOverwriteMixin, ValueWrapper, metaclass=</span>
<span class="gd">-    _OverwriteMeta):</span>
<span class="gi">+class AttributeOverwrite(_AttributeOverwriteMixin, ValueWrapper,</span>
<span class="gi">+                         metaclass=_OverwriteMeta):</span>
<span class="w"> </span>    pass
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def publish_method(method_name):</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        dct = func.__dict__.setdefault(&#39;registered_overwritten_methods&#39;, {})</span>
<span class="gi">+        dct[method_name] = func</span>
<span class="gi">+        return func</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/jedi/inference/finder.py b/jedi/inference/finder.py</span>
<span class="gh">index 48ed829c..aac58732 100644</span>
<span class="gd">--- a/jedi/inference/finder.py</span>
<span class="gi">+++ b/jedi/inference/finder.py</span>
<span class="gu">@@ -14,8 +14,10 @@ would check whether a flow has the form of ``if isinstance(a, type_or_tuple)``.</span>
<span class="w"> </span>Unfortunately every other thing is being ignored (e.g. a == &#39;&#39; would be easy to
<span class="w"> </span>check for -&gt; a is a string). There&#39;s big potential in these checks.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="w"> </span>from parso.python.tree import Name
<span class="gi">+</span>
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.inference.arguments import TreeArguments
<span class="w"> </span>from jedi.inference.value import iterable
<span class="gu">@@ -28,7 +30,24 @@ def filter_name(filters, name_or_str):</span>
<span class="w"> </span>    Searches names that are defined in a scope (the different
<span class="w"> </span>    ``filters``), until a name fits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    string_name = name_or_str.value if isinstance(name_or_str, Name) else name_or_str</span>
<span class="gi">+    names = []</span>
<span class="gi">+    for filter in filters:</span>
<span class="gi">+        names = filter.get(string_name)</span>
<span class="gi">+        if names:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return list(_remove_del_stmt(names))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_del_stmt(names):</span>
<span class="gi">+    # Catch del statements and remove them from results.</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        if name.tree_name is not None:</span>
<span class="gi">+            definition = name.tree_name.get_definition()</span>
<span class="gi">+            if definition is not None and definition.type == &#39;del_stmt&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+        yield name</span>


<span class="w"> </span>def check_flow_information(value, flow, search_name, pos):
<span class="gu">@@ -40,4 +59,88 @@ def check_flow_information(value, flow, search_name, pos):</span>

<span class="w"> </span>    ensures that `k` is a string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not settings.dynamic_flow_information:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    result = None</span>
<span class="gi">+    if is_scope(flow):</span>
<span class="gi">+        # Check for asserts.</span>
<span class="gi">+        module_node = flow.get_root_node()</span>
<span class="gi">+        try:</span>
<span class="gi">+            names = module_node.get_used_names()[search_name.value]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>
<span class="gi">+        names = reversed([</span>
<span class="gi">+            n for n in names</span>
<span class="gi">+            if flow.start_pos &lt;= n.start_pos &lt; (pos or flow.end_pos)</span>
<span class="gi">+        ])</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            ass = search_ancestor(name, &#39;assert_stmt&#39;)</span>
<span class="gi">+            if ass is not None:</span>
<span class="gi">+                result = _check_isinstance_type(value, ass.assertion, search_name)</span>
<span class="gi">+                if result is not None:</span>
<span class="gi">+                    return result</span>
<span class="gi">+</span>
<span class="gi">+    if flow.type in (&#39;if_stmt&#39;, &#39;while_stmt&#39;):</span>
<span class="gi">+        potential_ifs = [c for c in flow.children[1::4] if c != &#39;:&#39;]</span>
<span class="gi">+        for if_test in reversed(potential_ifs):</span>
<span class="gi">+            if search_name.start_pos &gt; if_test.end_pos:</span>
<span class="gi">+                return _check_isinstance_type(value, if_test, search_name)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_isinstance_trailer_arglist(node):</span>
<span class="gi">+    if node.type in (&#39;power&#39;, &#39;atom_expr&#39;) and len(node.children) == 2:</span>
<span class="gi">+        # This might be removed if we analyze and, etc</span>
<span class="gi">+        first, trailer = node.children</span>
<span class="gi">+        if first.type == &#39;name&#39; and first.value == &#39;isinstance&#39; \</span>
<span class="gi">+                and trailer.type == &#39;trailer&#39; and trailer.children[0] == &#39;(&#39;:</span>
<span class="gi">+            return trailer</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_isinstance_type(value, node, search_name):</span>
<span class="gi">+    lazy_cls = None</span>
<span class="gi">+    trailer = _get_isinstance_trailer_arglist(node)</span>
<span class="gi">+    if trailer is not None and len(trailer.children) == 3:</span>
<span class="gi">+        arglist = trailer.children[1]</span>
<span class="gi">+        args = TreeArguments(value.inference_state, value, arglist, trailer)</span>
<span class="gi">+        param_list = list(args.unpack())</span>
<span class="gi">+        # Disallow keyword arguments</span>
<span class="gi">+        if len(param_list) == 2 and len(arglist.children) == 3:</span>
<span class="gi">+            (key1, _), (key2, lazy_value_cls) = param_list</span>
<span class="gi">+            if key1 is None and key2 is None:</span>
<span class="gi">+                call = _get_call_string(search_name)</span>
<span class="gi">+                is_instance_call = _get_call_string(arglist.children[0])</span>
<span class="gi">+                # Do a simple get_code comparison of the strings . They should</span>
<span class="gi">+                # just have the same code, and everything will be all right.</span>
<span class="gi">+                # There are ways that this is not correct, if some stuff is</span>
<span class="gi">+                # redefined in between. However here we don&#39;t care, because</span>
<span class="gi">+                # it&#39;s a heuristic that works pretty well.</span>
<span class="gi">+                if call == is_instance_call:</span>
<span class="gi">+                    lazy_cls = lazy_value_cls</span>
<span class="gi">+    if lazy_cls is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    value_set = NO_VALUES</span>
<span class="gi">+    for cls_or_tup in lazy_cls.infer():</span>
<span class="gi">+        if isinstance(cls_or_tup, iterable.Sequence) and cls_or_tup.array_type == &#39;tuple&#39;:</span>
<span class="gi">+            for lazy_value in cls_or_tup.py__iter__():</span>
<span class="gi">+                value_set |= lazy_value.infer().execute_with_values()</span>
<span class="gi">+        else:</span>
<span class="gi">+            value_set |= cls_or_tup.execute_with_values()</span>
<span class="gi">+    return value_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_call_string(node):</span>
<span class="gi">+    if node.parent.type == &#39;atom_expr&#39;:</span>
<span class="gi">+        return _get_call_string(node.parent)</span>
<span class="gi">+</span>
<span class="gi">+    code = &#39;&#39;</span>
<span class="gi">+    leaf = node.get_first_leaf()</span>
<span class="gi">+    end = node.get_last_leaf().end_pos</span>
<span class="gi">+    while leaf.start_pos &lt; end:</span>
<span class="gi">+        code += leaf.value</span>
<span class="gi">+        leaf = leaf.get_next_leaf()</span>
<span class="gi">+    return code</span>
<span class="gh">diff --git a/jedi/inference/flow_analysis.py b/jedi/inference/flow_analysis.py</span>
<span class="gh">index d2a4ad77..89bfe578 100644</span>
<span class="gd">--- a/jedi/inference/flow_analysis.py</span>
<span class="gi">+++ b/jedi/inference/flow_analysis.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from typing import Dict, Optional
<span class="gi">+</span>
<span class="w"> </span>from jedi.parser_utils import get_flow_branch_keyword, is_scope, get_parent_scope
<span class="w"> </span>from jedi.inference.recursion import execution_allowed
<span class="w"> </span>from jedi.inference.helpers import is_big_annoying_library
<span class="gu">@@ -7,11 +8,19 @@ from jedi.inference.helpers import is_big_annoying_library</span>
<span class="w"> </span>class Status:
<span class="w"> </span>    lookup_table: Dict[Optional[bool], &#39;Status&#39;] = {}

<span class="gd">-    def __init__(self, value: Optional[bool], name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: Optional[bool], name: str) -&gt; None:</span>
<span class="w"> </span>        self._value = value
<span class="w"> </span>        self._name = name
<span class="w"> </span>        Status.lookup_table[value] = self

<span class="gi">+    def invert(self):</span>
<span class="gi">+        if self is REACHABLE:</span>
<span class="gi">+            return UNREACHABLE</span>
<span class="gi">+        elif self is UNREACHABLE:</span>
<span class="gi">+            return REACHABLE</span>
<span class="gi">+        else:</span>
<span class="gi">+            return UNSURE</span>
<span class="gi">+</span>
<span class="w"> </span>    def __and__(self, other):
<span class="w"> </span>        if UNSURE in (self, other):
<span class="w"> </span>            return UNSURE
<span class="gu">@@ -25,3 +34,92 @@ class Status:</span>
<span class="w"> </span>REACHABLE = Status(True, &#39;reachable&#39;)
<span class="w"> </span>UNREACHABLE = Status(False, &#39;unreachable&#39;)
<span class="w"> </span>UNSURE = Status(None, &#39;unsure&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_flow_scopes(node):</span>
<span class="gi">+    while True:</span>
<span class="gi">+        node = get_parent_scope(node, include_flows=True)</span>
<span class="gi">+        if node is None or is_scope(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        yield node</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def reachability_check(context, value_scope, node, origin_scope=None):</span>
<span class="gi">+    if is_big_annoying_library(context) \</span>
<span class="gi">+            or not context.inference_state.flow_analysis_enabled:</span>
<span class="gi">+        return UNSURE</span>
<span class="gi">+</span>
<span class="gi">+    first_flow_scope = get_parent_scope(node, include_flows=True)</span>
<span class="gi">+    if origin_scope is not None:</span>
<span class="gi">+        origin_flow_scopes = list(_get_flow_scopes(origin_scope))</span>
<span class="gi">+        node_flow_scopes = list(_get_flow_scopes(node))</span>
<span class="gi">+</span>
<span class="gi">+        branch_matches = True</span>
<span class="gi">+        for flow_scope in origin_flow_scopes:</span>
<span class="gi">+            if flow_scope in node_flow_scopes:</span>
<span class="gi">+                node_keyword = get_flow_branch_keyword(flow_scope, node)</span>
<span class="gi">+                origin_keyword = get_flow_branch_keyword(flow_scope, origin_scope)</span>
<span class="gi">+                branch_matches = node_keyword == origin_keyword</span>
<span class="gi">+                if flow_scope.type == &#39;if_stmt&#39;:</span>
<span class="gi">+                    if not branch_matches:</span>
<span class="gi">+                        return UNREACHABLE</span>
<span class="gi">+                elif flow_scope.type == &#39;try_stmt&#39;:</span>
<span class="gi">+                    if not branch_matches and origin_keyword == &#39;else&#39; \</span>
<span class="gi">+                            and node_keyword == &#39;except&#39;:</span>
<span class="gi">+                        return UNREACHABLE</span>
<span class="gi">+                if branch_matches:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        # Direct parents get resolved, we filter scopes that are separate</span>
<span class="gi">+        # branches.  This makes sense for autocompletion and static analysis.</span>
<span class="gi">+        # For actual Python it doesn&#39;t matter, because we&#39;re talking about</span>
<span class="gi">+        # potentially unreachable code.</span>
<span class="gi">+        # e.g. `if 0:` would cause all name lookup within the flow make</span>
<span class="gi">+        # unaccessible. This is not a &quot;problem&quot; in Python, because the code is</span>
<span class="gi">+        # never called. In Jedi though, we still want to infer types.</span>
<span class="gi">+        while origin_scope is not None:</span>
<span class="gi">+            if first_flow_scope == origin_scope and branch_matches:</span>
<span class="gi">+                return REACHABLE</span>
<span class="gi">+            origin_scope = origin_scope.parent</span>
<span class="gi">+</span>
<span class="gi">+    return _break_check(context, value_scope, first_flow_scope, node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _break_check(context, value_scope, flow_scope, node):</span>
<span class="gi">+    reachable = REACHABLE</span>
<span class="gi">+    if flow_scope.type == &#39;if_stmt&#39;:</span>
<span class="gi">+        if flow_scope.is_node_after_else(node):</span>
<span class="gi">+            for check_node in flow_scope.get_test_nodes():</span>
<span class="gi">+                reachable = _check_if(context, check_node)</span>
<span class="gi">+                if reachable in (REACHABLE, UNSURE):</span>
<span class="gi">+                    break</span>
<span class="gi">+            reachable = reachable.invert()</span>
<span class="gi">+        else:</span>
<span class="gi">+            flow_node = flow_scope.get_corresponding_test_node(node)</span>
<span class="gi">+            if flow_node is not None:</span>
<span class="gi">+                reachable = _check_if(context, flow_node)</span>
<span class="gi">+    elif flow_scope.type in (&#39;try_stmt&#39;, &#39;while_stmt&#39;):</span>
<span class="gi">+        return UNSURE</span>
<span class="gi">+</span>
<span class="gi">+    # Only reachable branches need to be examined further.</span>
<span class="gi">+    if reachable in (UNREACHABLE, UNSURE):</span>
<span class="gi">+        return reachable</span>
<span class="gi">+</span>
<span class="gi">+    if value_scope != flow_scope and value_scope != flow_scope.parent:</span>
<span class="gi">+        flow_scope = get_parent_scope(flow_scope, include_flows=True)</span>
<span class="gi">+        return reachable &amp; _break_check(context, value_scope, flow_scope, node)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return reachable</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_if(context, node):</span>
<span class="gi">+    with execution_allowed(context.inference_state, node) as allowed:</span>
<span class="gi">+        if not allowed:</span>
<span class="gi">+            return UNSURE</span>
<span class="gi">+</span>
<span class="gi">+        types = context.infer_node(node)</span>
<span class="gi">+        values = set(x.py__bool__() for x in types)</span>
<span class="gi">+        if len(values) == 1:</span>
<span class="gi">+            return Status.lookup_table[values.pop()]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return UNSURE</span>
<span class="gh">diff --git a/jedi/inference/gradual/annotation.py b/jedi/inference/gradual/annotation.py</span>
<span class="gh">index e720fb88..57098276 100644</span>
<span class="gd">--- a/jedi/inference/gradual/annotation.py</span>
<span class="gi">+++ b/jedi/inference/gradual/annotation.py</span>
<span class="gu">@@ -4,9 +4,12 @@ through function annotations. There is a strong suggestion in this document</span>
<span class="w"> </span>that only the type of type hinting defined in PEP0484 should be allowed
<span class="w"> </span>as annotations in future python versions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from parso import ParserSyntaxError, parse
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.base_value import ValueSet, NO_VALUES
<span class="w"> </span>from jedi.inference.gradual.base import DefineGenericBaseClass, GenericClass
<span class="gu">@@ -28,7 +31,51 @@ def infer_annotation(context, annotation):</span>

<span class="w"> </span>    Also checks for forward references (strings)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value_set = context.infer_node(annotation)</span>
<span class="gi">+    if len(value_set) != 1:</span>
<span class="gi">+        debug.warning(&quot;Inferred typing index %s should lead to 1 object, &quot;</span>
<span class="gi">+                      &quot; not %s&quot; % (annotation, value_set))</span>
<span class="gi">+        return value_set</span>
<span class="gi">+</span>
<span class="gi">+    inferred_value = list(value_set)[0]</span>
<span class="gi">+    if is_string(inferred_value):</span>
<span class="gi">+        result = _get_forward_reference_node(context, inferred_value.get_safe_value())</span>
<span class="gi">+        if result is not None:</span>
<span class="gi">+            return context.infer_node(result)</span>
<span class="gi">+    return value_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_annotation_string(context, string, index=None):</span>
<span class="gi">+    node = _get_forward_reference_node(context, string)</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    value_set = context.infer_node(node)</span>
<span class="gi">+    if index is not None:</span>
<span class="gi">+        value_set = value_set.filter(</span>
<span class="gi">+            lambda value: (</span>
<span class="gi">+                value.array_type == &#39;tuple&#39;</span>
<span class="gi">+                and len(list(value.py__iter__())) &gt;= index</span>
<span class="gi">+            )</span>
<span class="gi">+        ).py__simple_getitem__(index)</span>
<span class="gi">+    return value_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_forward_reference_node(context, string):</span>
<span class="gi">+    try:</span>
<span class="gi">+        new_node = context.inference_state.grammar.parse(</span>
<span class="gi">+            string,</span>
<span class="gi">+            start_symbol=&#39;eval_input&#39;,</span>
<span class="gi">+            error_recovery=False</span>
<span class="gi">+        )</span>
<span class="gi">+    except ParserSyntaxError:</span>
<span class="gi">+        debug.warning(&#39;Annotation not parsed: %s&#39; % string)</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        module = context.tree_node.get_root_node()</span>
<span class="gi">+        parser_utils.move(new_node, module.end_pos[0])</span>
<span class="gi">+        new_node.parent = context.tree_node</span>
<span class="gi">+        return new_node</span>


<span class="w"> </span>def _split_comment_param_declaration(decl_text):
<span class="gu">@@ -40,14 +87,139 @@ def _split_comment_param_declaration(decl_text):</span>
<span class="w"> </span>    [&#39;foo&#39;, &#39;Bar[baz, biz]&#39;].

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        node = parse(decl_text, error_recovery=False).children[0]</span>
<span class="gi">+    except ParserSyntaxError:</span>
<span class="gi">+        debug.warning(&#39;Comment annotation is not valid Python: %s&#39; % decl_text)</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if node.type in [&#39;name&#39;, &#39;atom_expr&#39;, &#39;power&#39;]:</span>
<span class="gi">+        return [node.get_code().strip()]</span>
<span class="gi">+</span>
<span class="gi">+    params = []</span>
<span class="gi">+    try:</span>
<span class="gi">+        children = node.children</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return []</span>
<span class="gi">+    else:</span>
<span class="gi">+        for child in children:</span>
<span class="gi">+            if child.type in [&#39;name&#39;, &#39;atom_expr&#39;, &#39;power&#39;]:</span>
<span class="gi">+                params.append(child.get_code().strip())</span>
<span class="gi">+</span>
<span class="gi">+    return params</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_method_cache()</span>
<span class="gi">+def infer_param(function_value, param, ignore_stars=False):</span>
<span class="gi">+    values = _infer_param(function_value, param)</span>
<span class="gi">+    if ignore_stars or not values:</span>
<span class="gi">+        return values</span>
<span class="gi">+    inference_state = function_value.inference_state</span>
<span class="gi">+    if param.star_count == 1:</span>
<span class="gi">+        tuple_ = builtin_from_name(inference_state, &#39;tuple&#39;)</span>
<span class="gi">+        return ValueSet([GenericClass(</span>
<span class="gi">+            tuple_,</span>
<span class="gi">+            TupleGenericManager((values,)),</span>
<span class="gi">+        )])</span>
<span class="gi">+    elif param.star_count == 2:</span>
<span class="gi">+        dct = builtin_from_name(inference_state, &#39;dict&#39;)</span>
<span class="gi">+        generics = (</span>
<span class="gi">+            ValueSet([builtin_from_name(inference_state, &#39;str&#39;)]),</span>
<span class="gi">+            values</span>
<span class="gi">+        )</span>
<span class="gi">+        return ValueSet([GenericClass(</span>
<span class="gi">+            dct,</span>
<span class="gi">+            TupleGenericManager(generics),</span>
<span class="gi">+        )])</span>
<span class="gi">+    return values</span>


<span class="w"> </span>def _infer_param(function_value, param):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Infers the type of a function parameter, using type annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotation = param.annotation</span>
<span class="gi">+    if annotation is None:</span>
<span class="gi">+        # If no Python 3-style annotation, look for a comment annotation.</span>
<span class="gi">+        # Identify parameters to function in the same sequence as they would</span>
<span class="gi">+        # appear in a type comment.</span>
<span class="gi">+        all_params = [child for child in param.parent.children</span>
<span class="gi">+                      if child.type == &#39;param&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        node = param.parent.parent</span>
<span class="gi">+        comment = parser_utils.get_following_comment_same_line(node)</span>
<span class="gi">+        if comment is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        match = re.match(r&quot;^#\s*type:\s*\(([^#]*)\)\s*-&gt;&quot;, comment)</span>
<span class="gi">+        if not match:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        params_comments = _split_comment_param_declaration(match.group(1))</span>
<span class="gi">+</span>
<span class="gi">+        # Find the specific param being investigated</span>
<span class="gi">+        index = all_params.index(param)</span>
<span class="gi">+        # If the number of parameters doesn&#39;t match length of type comment,</span>
<span class="gi">+        # ignore first parameter (assume it&#39;s self).</span>
<span class="gi">+        if len(params_comments) != len(all_params):</span>
<span class="gi">+            debug.warning(</span>
<span class="gi">+                &quot;Comments length != Params length %s %s&quot;,</span>
<span class="gi">+                params_comments, all_params</span>
<span class="gi">+            )</span>
<span class="gi">+        if function_value.is_bound_method():</span>
<span class="gi">+            if index == 0:</span>
<span class="gi">+                # Assume it&#39;s self, which is already handled</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            index -= 1</span>
<span class="gi">+        if index &gt;= len(params_comments):</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        param_comment = params_comments[index]</span>
<span class="gi">+        return _infer_annotation_string(</span>
<span class="gi">+            function_value.get_default_param_context(),</span>
<span class="gi">+            param_comment</span>
<span class="gi">+        )</span>
<span class="gi">+    # Annotations are like default params and resolve in the same way.</span>
<span class="gi">+    context = function_value.get_default_param_context()</span>
<span class="gi">+    return infer_annotation(context, annotation)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def py__annotations__(funcdef):</span>
<span class="gi">+    dct = {}</span>
<span class="gi">+    for function_param in funcdef.get_params():</span>
<span class="gi">+        param_annotation = function_param.annotation</span>
<span class="gi">+        if param_annotation is not None:</span>
<span class="gi">+            dct[function_param.name.value] = param_annotation</span>
<span class="gi">+</span>
<span class="gi">+    return_annotation = funcdef.annotation</span>
<span class="gi">+    if return_annotation:</span>
<span class="gi">+        dct[&#39;return&#39;] = return_annotation</span>
<span class="gi">+    return dct</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_forward_references(context, all_annotations):</span>
<span class="gi">+    def resolve(node):</span>
<span class="gi">+        if node is None or node.type != &#39;string&#39;:</span>
<span class="gi">+            return node</span>
<span class="gi">+</span>
<span class="gi">+        node = _get_forward_reference_node(</span>
<span class="gi">+            context,</span>
<span class="gi">+            context.inference_state.compiled_subprocess.safe_literal_eval(</span>
<span class="gi">+                node.value,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            # There was a string, but it&#39;s not a valid annotation</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # The forward reference tree has an additional root node (&#39;eval_input&#39;)</span>
<span class="gi">+        # that we don&#39;t want. Extract the node we do want, that is equivalent to</span>
<span class="gi">+        # the nodes returned by `py__annotations__` for a non-quoted node.</span>
<span class="gi">+        node = node.children[0]</span>
<span class="gi">+</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    return {name: resolve(node) for name, node in all_annotations.items()}</span>


<span class="w"> </span>@inference_state_method_cache()
<span class="gu">@@ -56,7 +228,41 @@ def infer_return_types(function, arguments):</span>
<span class="w"> </span>    Infers the type of a function&#39;s return value,
<span class="w"> </span>    according to type annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = function.get_default_param_context()</span>
<span class="gi">+    all_annotations = resolve_forward_references(</span>
<span class="gi">+        context,</span>
<span class="gi">+        py__annotations__(function.tree_node),</span>
<span class="gi">+    )</span>
<span class="gi">+    annotation = all_annotations.get(&quot;return&quot;, None)</span>
<span class="gi">+    if annotation is None:</span>
<span class="gi">+        # If there is no Python 3-type annotation, look for an annotation</span>
<span class="gi">+        # comment.</span>
<span class="gi">+        node = function.tree_node</span>
<span class="gi">+        comment = parser_utils.get_following_comment_same_line(node)</span>
<span class="gi">+        if comment is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        match = re.match(r&quot;^#\s*type:\s*\([^#]*\)\s*-&gt;\s*([^#]*)&quot;, comment)</span>
<span class="gi">+        if not match:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        return _infer_annotation_string(</span>
<span class="gi">+            context,</span>
<span class="gi">+            match.group(1).strip()</span>
<span class="gi">+        ).execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+    unknown_type_vars = find_unknown_type_vars(context, annotation)</span>
<span class="gi">+    annotation_values = infer_annotation(context, annotation)</span>
<span class="gi">+    if not unknown_type_vars:</span>
<span class="gi">+        return annotation_values.execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+    type_var_dict = infer_type_vars_for_execution(function, arguments, all_annotations)</span>
<span class="gi">+</span>
<span class="gi">+    return ValueSet.from_sets(</span>
<span class="gi">+        ann.define_generics(type_var_dict)</span>
<span class="gi">+        if isinstance(ann, (DefineGenericBaseClass, TypeVar)) else ValueSet({ann})</span>
<span class="gi">+        for ann in annotation_values</span>
<span class="gi">+    ).execute_annotation()</span>


<span class="w"> </span>def infer_type_vars_for_execution(function, arguments, annotation_dict):
<span class="gu">@@ -69,7 +275,47 @@ def infer_type_vars_for_execution(function, arguments, annotation_dict):</span>
<span class="w"> </span>    2. Infer type vars with the execution state we have.
<span class="w"> </span>    3. Return the union of all type vars that have been found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = function.get_default_param_context()</span>
<span class="gi">+</span>
<span class="gi">+    annotation_variable_results = {}</span>
<span class="gi">+    executed_param_names = get_executed_param_names(function, arguments)</span>
<span class="gi">+    for executed_param_name in executed_param_names:</span>
<span class="gi">+        try:</span>
<span class="gi">+            annotation_node = annotation_dict[executed_param_name.string_name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        annotation_variables = find_unknown_type_vars(context, annotation_node)</span>
<span class="gi">+        if annotation_variables:</span>
<span class="gi">+            # Infer unknown type var</span>
<span class="gi">+            annotation_value_set = context.infer_node(annotation_node)</span>
<span class="gi">+            kind = executed_param_name.get_kind()</span>
<span class="gi">+            actual_value_set = executed_param_name.infer()</span>
<span class="gi">+            if kind is Parameter.VAR_POSITIONAL:</span>
<span class="gi">+                actual_value_set = actual_value_set.merge_types_of_iterate()</span>
<span class="gi">+            elif kind is Parameter.VAR_KEYWORD:</span>
<span class="gi">+                # TODO _dict_values is not public.</span>
<span class="gi">+                actual_value_set = actual_value_set.try_merge(&#39;_dict_values&#39;)</span>
<span class="gi">+            merge_type_var_dicts(</span>
<span class="gi">+                annotation_variable_results,</span>
<span class="gi">+                annotation_value_set.infer_type_vars(actual_value_set),</span>
<span class="gi">+            )</span>
<span class="gi">+    return annotation_variable_results</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer_return_for_callable(arguments, param_values, result_values):</span>
<span class="gi">+    all_type_vars = {}</span>
<span class="gi">+    for pv in param_values:</span>
<span class="gi">+        if pv.array_type == &#39;list&#39;:</span>
<span class="gi">+            type_var_dict = _infer_type_vars_for_callable(arguments, pv.py__iter__())</span>
<span class="gi">+            all_type_vars.update(type_var_dict)</span>
<span class="gi">+</span>
<span class="gi">+    return ValueSet.from_sets(</span>
<span class="gi">+        v.define_generics(all_type_vars)</span>
<span class="gi">+        if isinstance(v, (DefineGenericBaseClass, TypeVar))</span>
<span class="gi">+        else ValueSet({v})</span>
<span class="gi">+        for v in result_values</span>
<span class="gi">+    ).execute_annotation()</span>


<span class="w"> </span>def _infer_type_vars_for_callable(arguments, lazy_params):
<span class="gu">@@ -78,7 +324,25 @@ def _infer_type_vars_for_callable(arguments, lazy_params):</span>

<span class="w"> </span>        def x() -&gt; Callable[[Callable[..., _T]], _T]: ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotation_variable_results = {}</span>
<span class="gi">+    for (_, lazy_value), lazy_callable_param in zip(arguments.unpack(), lazy_params):</span>
<span class="gi">+        callable_param_values = lazy_callable_param.infer()</span>
<span class="gi">+        # Infer unknown type var</span>
<span class="gi">+        actual_value_set = lazy_value.infer()</span>
<span class="gi">+        merge_type_var_dicts(</span>
<span class="gi">+            annotation_variable_results,</span>
<span class="gi">+            callable_param_values.infer_type_vars(actual_value_set),</span>
<span class="gi">+        )</span>
<span class="gi">+    return annotation_variable_results</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge_type_var_dicts(base_dict, new_dict):</span>
<span class="gi">+    for type_var_name, values in new_dict.items():</span>
<span class="gi">+        if values:</span>
<span class="gi">+            try:</span>
<span class="gi">+                base_dict[type_var_name] |= values</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                base_dict[type_var_name] = values</span>


<span class="w"> </span>def merge_pairwise_generics(annotation_value, annotated_argument_class):
<span class="gu">@@ -115,4 +379,96 @@ def merge_pairwise_generics(annotation_value, annotated_argument_class):</span>
<span class="w"> </span>    `annotated_argument_class`: represents the annotated class of the
<span class="w"> </span>        argument being passed to the object annotated by `annotation_value`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    type_var_dict = {}</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(annotated_argument_class, DefineGenericBaseClass):</span>
<span class="gi">+        return type_var_dict</span>
<span class="gi">+</span>
<span class="gi">+    annotation_generics = annotation_value.get_generics()</span>
<span class="gi">+    actual_generics = annotated_argument_class.get_generics()</span>
<span class="gi">+</span>
<span class="gi">+    for annotation_generics_set, actual_generic_set in zip(annotation_generics, actual_generics):</span>
<span class="gi">+        merge_type_var_dicts(</span>
<span class="gi">+            type_var_dict,</span>
<span class="gi">+            annotation_generics_set.infer_type_vars(actual_generic_set.execute_annotation()),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return type_var_dict</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_type_from_comment_hint_for(context, node, name):</span>
<span class="gi">+    return _find_type_from_comment_hint(context, node, node.children[1], name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_type_from_comment_hint_with(context, node, name):</span>
<span class="gi">+    if len(node.children) &gt; 4:</span>
<span class="gi">+        # In case there are multiple with_items, we do not want a type hint for</span>
<span class="gi">+        # now.</span>
<span class="gi">+        return []</span>
<span class="gi">+    assert len(node.children[1].children) == 3, \</span>
<span class="gi">+        &quot;Can only be here when children[1] is &#39;foo() as f&#39;&quot;</span>
<span class="gi">+    varlist = node.children[1].children[2]</span>
<span class="gi">+    return _find_type_from_comment_hint(context, node, varlist, name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_type_from_comment_hint_assign(context, node, name):</span>
<span class="gi">+    return _find_type_from_comment_hint(context, node, node.children[0], name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_type_from_comment_hint(context, node, varlist, name):</span>
<span class="gi">+    index = None</span>
<span class="gi">+    if varlist.type in (&quot;testlist_star_expr&quot;, &quot;exprlist&quot;, &quot;testlist&quot;):</span>
<span class="gi">+        # something like &quot;a, b = 1, 2&quot;</span>
<span class="gi">+        index = 0</span>
<span class="gi">+        for child in varlist.children:</span>
<span class="gi">+            if child == name:</span>
<span class="gi">+                break</span>
<span class="gi">+            if child.type == &quot;operator&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            index += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    comment = parser_utils.get_following_comment_same_line(node)</span>
<span class="gi">+    if comment is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+    match = re.match(r&quot;^#\s*type:\s*([^#]*)&quot;, comment)</span>
<span class="gi">+    if match is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+    return _infer_annotation_string(</span>
<span class="gi">+        context, match.group(1).strip(), index</span>
<span class="gi">+    ).execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_unknown_type_vars(context, node):</span>
<span class="gi">+    def check_node(node):</span>
<span class="gi">+        if node.type in (&#39;atom_expr&#39;, &#39;power&#39;):</span>
<span class="gi">+            trailer = node.children[-1]</span>
<span class="gi">+            if trailer.type == &#39;trailer&#39; and trailer.children[0] == &#39;[&#39;:</span>
<span class="gi">+                for subscript_node in _unpack_subscriptlist(trailer.children[1]):</span>
<span class="gi">+                    check_node(subscript_node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            found[:] = _filter_type_vars(context.infer_node(node), found)</span>
<span class="gi">+</span>
<span class="gi">+    found = []  # We&#39;re not using a set, because the order matters.</span>
<span class="gi">+    check_node(node)</span>
<span class="gi">+    return found</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _filter_type_vars(value_set, found=()):</span>
<span class="gi">+    new_found = list(found)</span>
<span class="gi">+    for type_var in value_set:</span>
<span class="gi">+        if isinstance(type_var, TypeVar) and type_var not in found:</span>
<span class="gi">+            new_found.append(type_var)</span>
<span class="gi">+    return new_found</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _unpack_subscriptlist(subscriptlist):</span>
<span class="gi">+    if subscriptlist.type == &#39;subscriptlist&#39;:</span>
<span class="gi">+        for subscript in subscriptlist.children[::2]:</span>
<span class="gi">+            if subscript.type != &#39;subscript&#39;:</span>
<span class="gi">+                yield subscript</span>
<span class="gi">+    else:</span>
<span class="gi">+        if subscriptlist.type != &#39;subscript&#39;:</span>
<span class="gi">+            yield subscriptlist</span>
<span class="gh">diff --git a/jedi/inference/gradual/base.py b/jedi/inference/gradual/base.py</span>
<span class="gh">index 6eb858d9..ce574297 100644</span>
<span class="gd">--- a/jedi/inference/gradual/base.py</span>
<span class="gi">+++ b/jedi/inference/gradual/base.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="gd">-from jedi.inference.base_value import ValueSet, NO_VALUES, Value, iterator_to_value_set, LazyValueWrapper, ValueWrapper</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, NO_VALUES, Value, \</span>
<span class="gi">+    iterator_to_value_set, LazyValueWrapper, ValueWrapper</span>
<span class="w"> </span>from jedi.inference.compiled import builtin_from_name
<span class="w"> </span>from jedi.inference.value.klass import ClassFilter
<span class="w"> </span>from jedi.inference.value.klass import ClassMixin
<span class="gu">@@ -13,15 +14,27 @@ class _BoundTypeVarName(AbstractNameDefinition):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This type var was bound to a certain type, e.g. int.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, type_var, value_set):
<span class="w"> </span>        self._type_var = type_var
<span class="w"> </span>        self.parent_context = type_var.parent_context
<span class="w"> </span>        self._value_set = value_set

<span class="gi">+    def infer(self):</span>
<span class="gi">+        def iter_():</span>
<span class="gi">+            for value in self._value_set:</span>
<span class="gi">+                # Replace any with the constraints if they are there.</span>
<span class="gi">+                from jedi.inference.gradual.typing import AnyClass</span>
<span class="gi">+                if isinstance(value, AnyClass):</span>
<span class="gi">+                    yield from self._type_var.constraints</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield value</span>
<span class="gi">+        return ValueSet(iter_())</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self._type_var.py__name__()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s %s -&gt; %s&gt;&#39; % (self.__class__.__name__, self.py__name__(</span>
<span class="gd">-            ), self._value_set)</span>
<span class="gi">+        return &#39;&lt;%s %s -&gt; %s&gt;&#39; % (self.__class__.__name__, self.py__name__(), self._value_set)</span>


<span class="w"> </span>class _TypeVarFilter:
<span class="gu">@@ -35,24 +48,113 @@ class _TypeVarFilter:</span>

<span class="w"> </span>    In this example we would have two type vars given: A and B
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, generics, type_vars):
<span class="w"> </span>        self._generics = generics
<span class="w"> </span>        self._type_vars = type_vars

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        for i, type_var in enumerate(self._type_vars):</span>
<span class="gi">+            if type_var.py__name__() == name:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return [_BoundTypeVarName(type_var, self._generics[i])]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    return [type_var.name]</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        # The values are not relevant. If it&#39;s not searched exactly, the type</span>
<span class="gi">+        # vars are just global and should be looked up as that.</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>

<span class="w"> </span>class _AnnotatedClassContext(ClassContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(</span>
<span class="gi">+            *args, **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+        yield from filters</span>

<span class="gi">+        # The type vars can only be looked up if it&#39;s a global search and</span>
<span class="gi">+        # not a direct lookup on the class.</span>
<span class="gi">+        yield self._value.get_type_var_filter()</span>

<span class="gd">-class DefineGenericBaseClass(LazyValueWrapper):</span>

<span class="gi">+class DefineGenericBaseClass(LazyValueWrapper):</span>
<span class="w"> </span>    def __init__(self, generics_manager):
<span class="w"> </span>        self._generics_manager = generics_manager

<span class="gi">+    def _create_instance_with_generics(self, generics_manager):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def get_generics(self):</span>
<span class="gi">+        return self._generics_manager.to_tuple()</span>
<span class="gi">+</span>
<span class="gi">+    def define_generics(self, type_var_dict):</span>
<span class="gi">+        from jedi.inference.gradual.type_var import TypeVar</span>
<span class="gi">+        changed = False</span>
<span class="gi">+        new_generics = []</span>
<span class="gi">+        for generic_set in self.get_generics():</span>
<span class="gi">+            values = NO_VALUES</span>
<span class="gi">+            for generic in generic_set:</span>
<span class="gi">+                if isinstance(generic, (DefineGenericBaseClass, TypeVar)):</span>
<span class="gi">+                    result = generic.define_generics(type_var_dict)</span>
<span class="gi">+                    values |= result</span>
<span class="gi">+                    if result != ValueSet({generic}):</span>
<span class="gi">+                        changed = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    values |= ValueSet([generic])</span>
<span class="gi">+            new_generics.append(values)</span>
<span class="gi">+</span>
<span class="gi">+        if not changed:</span>
<span class="gi">+            # There might not be any type vars that change. In that case just</span>
<span class="gi">+            # return itself, because it does not make sense to potentially lose</span>
<span class="gi">+            # cached results.</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([self._create_instance_with_generics(</span>
<span class="gi">+            TupleGenericManager(tuple(new_generics))</span>
<span class="gi">+        )])</span>
<span class="gi">+</span>
<span class="gi">+    def is_same_class(self, other):</span>
<span class="gi">+        if not isinstance(other, DefineGenericBaseClass):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if self.tree_node != other.tree_node:</span>
<span class="gi">+            # TODO not sure if this is nice.</span>
<span class="gi">+            return False</span>
<span class="gi">+        given_params1 = self.get_generics()</span>
<span class="gi">+        given_params2 = other.get_generics()</span>
<span class="gi">+</span>
<span class="gi">+        if len(given_params1) != len(given_params2):</span>
<span class="gi">+            # If the amount of type vars doesn&#39;t match, the class doesn&#39;t</span>
<span class="gi">+            # match.</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Now compare generics</span>
<span class="gi">+        return all(</span>
<span class="gi">+            any(</span>
<span class="gi">+                # TODO why is this ordering the correct one?</span>
<span class="gi">+                cls2.is_same_class(cls1)</span>
<span class="gi">+                # TODO I&#39;m still not sure gather_annotation_classes is a good</span>
<span class="gi">+                # idea. They are essentially here to avoid comparing Tuple &lt;=&gt;</span>
<span class="gi">+                # tuple and instead compare tuple &lt;=&gt; tuple, but at the moment</span>
<span class="gi">+                # the whole `is_same_class` and `is_sub_class` matching is just</span>
<span class="gi">+                # not in the best shape.</span>
<span class="gi">+                for cls1 in class_set1.gather_annotation_classes()</span>
<span class="gi">+                for cls2 in class_set2.gather_annotation_classes()</span>
<span class="gi">+            ) for class_set1, class_set2 in zip(given_params1, given_params2)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: %s%s&gt;&#39; % (self.__class__.__name__, self._wrapped_value,</span>
<span class="gd">-            list(self.get_generics()))</span>
<span class="gi">+        return &#39;&lt;%s: %s%s&gt;&#39; % (</span>
<span class="gi">+            self.__class__.__name__,</span>
<span class="gi">+            self._wrapped_value,</span>
<span class="gi">+            list(self.get_generics()),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class GenericClass(DefineGenericBaseClass, ClassMixin):
<span class="gu">@@ -62,25 +164,157 @@ class GenericClass(DefineGenericBaseClass, ClassMixin):</span>
<span class="w"> </span>        class Foo(Generic[T]): ...
<span class="w"> </span>        my_foo_int_cls = Foo[int]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, class_value, generics_manager):
<span class="w"> </span>        super().__init__(generics_manager)
<span class="w"> </span>        self._class_value = class_value

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        return self._class_value</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        n = self.py__name__()</span>
<span class="gi">+        # Not sure if this is the best way to do this, but all of these types</span>
<span class="gi">+        # are a bit special in that they have type aliases and other ways to</span>
<span class="gi">+        # become lower case. It&#39;s probably better to make them upper case,</span>
<span class="gi">+        # because that&#39;s what you can use in annotations.</span>
<span class="gi">+        n = dict(list=&quot;List&quot;, dict=&quot;Dict&quot;, set=&quot;Set&quot;, tuple=&quot;Tuple&quot;).get(n, n)</span>
<span class="gi">+        s = n + self._generics_manager.get_type_hint()</span>
<span class="gi">+        if add_class_info:</span>
<span class="gi">+            return &#39;Type[%s]&#39; % s</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_var_filter(self):</span>
<span class="gi">+        return _TypeVarFilter(self.get_generics(), self.list_type_vars())</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        instance, = super().py__call__(arguments)</span>
<span class="gi">+        return ValueSet([_GenericInstanceWrapper(instance)])</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return _AnnotatedClassContext(self)</span>
<span class="gi">+</span>
<span class="gi">+    @to_list</span>
<span class="gi">+    def py__bases__(self):</span>
<span class="gi">+        for base in self._wrapped_value.py__bases__():</span>
<span class="gi">+            yield _LazyGenericBaseClass(self, base, self._generics_manager)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_instance_with_generics(self, generics_manager):</span>
<span class="gi">+        return GenericClass(self._class_value, generics_manager)</span>
<span class="gi">+</span>
<span class="gi">+    def is_sub_class_of(self, class_value):</span>
<span class="gi">+        if super().is_sub_class_of(class_value):</span>
<span class="gi">+            return True</span>
<span class="gi">+        return self._class_value.is_sub_class_of(class_value)</span>
<span class="gi">+</span>
<span class="gi">+    def with_generics(self, generics_tuple):</span>
<span class="gi">+        return self._class_value.with_generics(generics_tuple)</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        # Circular</span>
<span class="gi">+        from jedi.inference.gradual.annotation import merge_pairwise_generics, merge_type_var_dicts</span>
<span class="gi">+</span>
<span class="gi">+        annotation_name = self.py__name__()</span>
<span class="gi">+        type_var_dict = {}</span>
<span class="gi">+        if annotation_name == &#39;Iterable&#39;:</span>
<span class="gi">+            annotation_generics = self.get_generics()</span>
<span class="gi">+            if annotation_generics:</span>
<span class="gi">+                return annotation_generics[0].infer_type_vars(</span>
<span class="gi">+                    value_set.merge_types_of_iterate(),</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Note: we need to handle the MRO _in order_, so we need to extract</span>
<span class="gi">+            # the elements from the set first, then handle them, even if we put</span>
<span class="gi">+            # them back in a set afterwards.</span>
<span class="gi">+            for py_class in value_set:</span>
<span class="gi">+                if py_class.is_instance() and not py_class.is_compiled():</span>
<span class="gi">+                    py_class = py_class.get_annotated_class_object()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if py_class.api_type != &#39;class&#39;:</span>
<span class="gi">+                    # Functions &amp; modules don&#39;t have an MRO and we&#39;re not</span>
<span class="gi">+                    # expecting a Callable (those are handled separately within</span>
<span class="gi">+                    # TypingClassValueWithIndex).</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for parent_class in py_class.py__mro__():</span>
<span class="gi">+                    class_name = parent_class.py__name__()</span>
<span class="gi">+                    if annotation_name == class_name:</span>
<span class="gi">+                        merge_type_var_dicts(</span>
<span class="gi">+                            type_var_dict,</span>
<span class="gi">+                            merge_pairwise_generics(self, parent_class),</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+        return type_var_dict</span>

<span class="gd">-class _LazyGenericBaseClass:</span>

<span class="gi">+class _LazyGenericBaseClass:</span>
<span class="w"> </span>    def __init__(self, class_value, lazy_base_class, generics_manager):
<span class="w"> </span>        self._class_value = class_value
<span class="w"> </span>        self._lazy_base_class = lazy_base_class
<span class="w"> </span>        self._generics_manager = generics_manager

<span class="gi">+    @iterator_to_value_set</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        for base in self._lazy_base_class.infer():</span>
<span class="gi">+            if isinstance(base, GenericClass):</span>
<span class="gi">+                # Here we have to recalculate the given types.</span>
<span class="gi">+                yield GenericClass.create_cached(</span>
<span class="gi">+                    base.inference_state,</span>
<span class="gi">+                    base._wrapped_value,</span>
<span class="gi">+                    TupleGenericManager(tuple(self._remap_type_vars(base))),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                if base.is_class_mixin():</span>
<span class="gi">+                    # This case basically allows classes like `class Foo(List)`</span>
<span class="gi">+                    # to be used like `Foo[int]`. The generics are not</span>
<span class="gi">+                    # necessary and can be used later.</span>
<span class="gi">+                    yield GenericClass.create_cached(</span>
<span class="gi">+                        base.inference_state,</span>
<span class="gi">+                        base,</span>
<span class="gi">+                        self._generics_manager,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield base</span>
<span class="gi">+</span>
<span class="gi">+    def _remap_type_vars(self, base):</span>
<span class="gi">+        from jedi.inference.gradual.type_var import TypeVar</span>
<span class="gi">+        filter = self._class_value.get_type_var_filter()</span>
<span class="gi">+        for type_var_set in base.get_generics():</span>
<span class="gi">+            new = NO_VALUES</span>
<span class="gi">+            for type_var in type_var_set:</span>
<span class="gi">+                if isinstance(type_var, TypeVar):</span>
<span class="gi">+                    names = filter.get(type_var.py__name__())</span>
<span class="gi">+                    new |= ValueSet.from_sets(</span>
<span class="gi">+                        name.infer() for name in names</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Mostly will be type vars, except if in some cases</span>
<span class="gi">+                    # a concrete type will already be there. In that</span>
<span class="gi">+                    # case just add it to the value set.</span>
<span class="gi">+                    new |= ValueSet([type_var])</span>
<span class="gi">+            yield new</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._lazy_base_class)


<span class="w"> </span>class _GenericInstanceWrapper(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__stop_iteration_returns(self):</span>
<span class="gi">+        for cls in self._wrapped_value.class_value.py__mro__():</span>
<span class="gi">+            if cls.py__name__() == &#39;Generator&#39;:</span>
<span class="gi">+                generics = cls.get_generics()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return generics[2].execute_annotation()</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            elif cls.py__name__() == &#39;Iterator&#39;:</span>
<span class="gi">+                return ValueSet([builtin_from_name(self.inference_state, &#39;None&#39;)])</span>
<span class="gi">+        return self._wrapped_value.py__stop_iteration_returns()</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        return self._wrapped_value.class_value.get_type_hint(add_class_info=False)</span>


<span class="w"> </span>class _PseudoTreeNameClass(Value):
<span class="gu">@@ -96,46 +330,105 @@ class _PseudoTreeNameClass(Value):</span>
<span class="w"> </span>    api_type = &#39;class&#39;

<span class="w"> </span>    def __init__(self, parent_context, tree_name):
<span class="gd">-        super().__init__(parent_context.inference_state, parent_context)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            parent_context.inference_state,</span>
<span class="gi">+            parent_context</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._tree_name = tree_name

<span class="gi">+    @property</span>
<span class="gi">+    def tree_node(self):</span>
<span class="gi">+        return self._tree_name</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        # TODO this is obviously wrong. Is it though?</span>
<span class="gi">+        class EmptyFilter(ClassFilter):</span>
<span class="gi">+            def __init__(self):</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            def get(self, name, **kwargs):</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+            def values(self, **kwargs):</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+        yield EmptyFilter()</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        # This might not be 100% correct, but it is good enough. The details of</span>
<span class="gi">+        # the typing library are not really an issue for Jedi.</span>
<span class="gi">+        return builtin_from_name(self.inference_state, &#39;type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self._tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return (self._tree_name.value,)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s)&#39; % (self.__class__.__name__, self._tree_name.value)


<span class="w"> </span>class BaseTypingValue(LazyValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, parent_context, tree_name):
<span class="w"> </span>        self.inference_state = parent_context.inference_state
<span class="w"> </span>        self.parent_context = parent_context
<span class="w"> </span>        self._tree_name = tree_name

<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self._tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        return _PseudoTreeNameClass(self.parent_context, self._tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return self._wrapped_value.get_signatures()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s)&#39; % (self.__class__.__name__, self._tree_name.value)


<span class="w"> </span>class BaseTypingClassWithGenerics(DefineGenericBaseClass):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, parent_context, tree_name, generics_manager):
<span class="w"> </span>        super().__init__(generics_manager)
<span class="w"> </span>        self.inference_state = parent_context.inference_state
<span class="w"> </span>        self.parent_context = parent_context
<span class="w"> </span>        self._tree_name = tree_name

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        return _PseudoTreeNameClass(self.parent_context, self._tree_name)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s%s)&#39; % (self.__class__.__name__, self._tree_name.value,
<span class="gd">-            self._generics_manager)</span>
<span class="gi">+                             self._generics_manager)</span>


<span class="w"> </span>class BaseTypingInstance(LazyValueWrapper):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, parent_context, class_value, tree_name, generics_manager</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, parent_context, class_value, tree_name, generics_manager):</span>
<span class="w"> </span>        self.inference_state = class_value.inference_state
<span class="w"> </span>        self.parent_context = parent_context
<span class="w"> </span>        self._class_value = class_value
<span class="w"> </span>        self._tree_name = tree_name
<span class="w"> </span>        self._generics_manager = generics_manager

<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return self._class_value</span>
<span class="gi">+</span>
<span class="gi">+    def get_annotated_class_object(self):</span>
<span class="gi">+        return self._class_value</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return (self.py__name__(),)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self._tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        object_, = builtin_from_name(self.inference_state, &#39;object&#39;).execute_annotation()</span>
<span class="gi">+        return object_</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._generics_manager)
<span class="gh">diff --git a/jedi/inference/gradual/conversion.py b/jedi/inference/gradual/conversion.py</span>
<span class="gh">index 7295c6d9..9b36a2e1 100644</span>
<span class="gd">--- a/jedi/inference/gradual/conversion.py</span>
<span class="gi">+++ b/jedi/inference/gradual/conversion.py</span>
<span class="gu">@@ -1,6 +1,209 @@</span>
<span class="w"> </span>from jedi import debug
<span class="gd">-from jedi.inference.base_value import ValueSet, NO_VALUES</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, \</span>
<span class="gi">+    NO_VALUES</span>
<span class="w"> </span>from jedi.inference.utils import to_list
<span class="w"> </span>from jedi.inference.gradual.stub_value import StubModuleValue
<span class="w"> </span>from jedi.inference.gradual.typeshed import try_to_load_stub_cached
<span class="w"> </span>from jedi.inference.value.decorator import Decoratee
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _stub_to_python_value_set(stub_value, ignore_compiled=False):</span>
<span class="gi">+    stub_module_context = stub_value.get_root_context()</span>
<span class="gi">+    if not stub_module_context.is_stub():</span>
<span class="gi">+        return ValueSet([stub_value])</span>
<span class="gi">+</span>
<span class="gi">+    decorates = None</span>
<span class="gi">+    if isinstance(stub_value, Decoratee):</span>
<span class="gi">+        decorates = stub_value._original_value</span>
<span class="gi">+</span>
<span class="gi">+    was_instance = stub_value.is_instance()</span>
<span class="gi">+    if was_instance:</span>
<span class="gi">+        arguments = getattr(stub_value, &#39;_arguments&#39;, None)</span>
<span class="gi">+        stub_value = stub_value.py__class__()</span>
<span class="gi">+</span>
<span class="gi">+    qualified_names = stub_value.get_qualified_names()</span>
<span class="gi">+    if qualified_names is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    was_bound_method = stub_value.is_bound_method()</span>
<span class="gi">+    if was_bound_method:</span>
<span class="gi">+        # Infer the object first. We can infer the method later.</span>
<span class="gi">+        method_name = qualified_names[-1]</span>
<span class="gi">+        qualified_names = qualified_names[:-1]</span>
<span class="gi">+        was_instance = True</span>
<span class="gi">+        arguments = None</span>
<span class="gi">+</span>
<span class="gi">+    values = _infer_from_stub(stub_module_context, qualified_names, ignore_compiled)</span>
<span class="gi">+    if was_instance:</span>
<span class="gi">+        values = ValueSet.from_sets(</span>
<span class="gi">+            c.execute_with_values() if arguments is None else c.execute(arguments)</span>
<span class="gi">+            for c in values</span>
<span class="gi">+            if c.is_class()</span>
<span class="gi">+        )</span>
<span class="gi">+    if was_bound_method:</span>
<span class="gi">+        # Now that the instance has been properly created, we can simply get</span>
<span class="gi">+        # the method.</span>
<span class="gi">+        values = values.py__getattribute__(method_name)</span>
<span class="gi">+    if decorates is not None:</span>
<span class="gi">+        values = ValueSet(Decoratee(v, decorates) for v in values)</span>
<span class="gi">+    return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_from_stub(stub_module_context, qualified_names, ignore_compiled):</span>
<span class="gi">+    from jedi.inference.compiled.mixed import MixedObject</span>
<span class="gi">+    stub_module = stub_module_context.get_value()</span>
<span class="gi">+    assert isinstance(stub_module, (StubModuleValue, MixedObject)), stub_module_context</span>
<span class="gi">+    non_stubs = stub_module.non_stub_value_set</span>
<span class="gi">+    if ignore_compiled:</span>
<span class="gi">+        non_stubs = non_stubs.filter(lambda c: not c.is_compiled())</span>
<span class="gi">+    for name in qualified_names:</span>
<span class="gi">+        non_stubs = non_stubs.py__getattribute__(name)</span>
<span class="gi">+    return non_stubs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@to_list</span>
<span class="gi">+def _try_stub_to_python_names(names, prefer_stub_to_compiled=False):</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        module_context = name.get_root_context()</span>
<span class="gi">+        if not module_context.is_stub():</span>
<span class="gi">+            yield name</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if name.api_type == &#39;module&#39;:</span>
<span class="gi">+            values = convert_values(name.infer(), ignore_compiled=prefer_stub_to_compiled)</span>
<span class="gi">+            if values:</span>
<span class="gi">+                for v in values:</span>
<span class="gi">+                    yield v.name</span>
<span class="gi">+                continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            v = name.get_defining_qualified_value()</span>
<span class="gi">+            if v is not None:</span>
<span class="gi">+                converted = _stub_to_python_value_set(v, ignore_compiled=prefer_stub_to_compiled)</span>
<span class="gi">+                if converted:</span>
<span class="gi">+                    converted_names = converted.goto(name.get_public_name())</span>
<span class="gi">+                    if converted_names:</span>
<span class="gi">+                        for n in converted_names:</span>
<span class="gi">+                            if n.get_root_context().is_stub():</span>
<span class="gi">+                                # If it&#39;s a stub again, it means we&#39;re going in</span>
<span class="gi">+                                # a circle. Probably some imports make it a</span>
<span class="gi">+                                # stub again.</span>
<span class="gi">+                                yield name</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                yield n</span>
<span class="gi">+                        continue</span>
<span class="gi">+        yield name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_stub_module(module):</span>
<span class="gi">+    if module.is_stub():</span>
<span class="gi">+        return module</span>
<span class="gi">+    return try_to_load_stub_cached(</span>
<span class="gi">+        module.inference_state,</span>
<span class="gi">+        import_names=module.string_names,</span>
<span class="gi">+        python_value_set=ValueSet([module]),</span>
<span class="gi">+        parent_module_value=None,</span>
<span class="gi">+        sys_path=module.inference_state.get_sys_path(),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@to_list</span>
<span class="gi">+def _python_to_stub_names(names, fallback_to_python=False):</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        module_context = name.get_root_context()</span>
<span class="gi">+        if module_context.is_stub():</span>
<span class="gi">+            yield name</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if name.api_type == &#39;module&#39;:</span>
<span class="gi">+            found_name = False</span>
<span class="gi">+            for n in name.goto():</span>
<span class="gi">+                if n.api_type == &#39;module&#39;:</span>
<span class="gi">+                    values = convert_values(n.infer(), only_stubs=True)</span>
<span class="gi">+                    for v in values:</span>
<span class="gi">+                        yield v.name</span>
<span class="gi">+                        found_name = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    for x in _python_to_stub_names([n], fallback_to_python=fallback_to_python):</span>
<span class="gi">+                        yield x</span>
<span class="gi">+                        found_name = True</span>
<span class="gi">+            if found_name:</span>
<span class="gi">+                continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            v = name.get_defining_qualified_value()</span>
<span class="gi">+            if v is not None:</span>
<span class="gi">+                converted = to_stub(v)</span>
<span class="gi">+                if converted:</span>
<span class="gi">+                    converted_names = converted.goto(name.get_public_name())</span>
<span class="gi">+                    if converted_names:</span>
<span class="gi">+                        yield from converted_names</span>
<span class="gi">+                        continue</span>
<span class="gi">+        if fallback_to_python:</span>
<span class="gi">+            # This is the part where if we haven&#39;t found anything, just return</span>
<span class="gi">+            # the stub name.</span>
<span class="gi">+            yield name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_names(names, only_stubs=False, prefer_stubs=False, prefer_stub_to_compiled=True):</span>
<span class="gi">+    if only_stubs and prefer_stubs:</span>
<span class="gi">+        raise ValueError(&quot;You cannot use both of only_stubs and prefer_stubs.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    with debug.increase_indent_cm(&#39;convert names&#39;):</span>
<span class="gi">+        if only_stubs or prefer_stubs:</span>
<span class="gi">+            return _python_to_stub_names(names, fallback_to_python=prefer_stubs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _try_stub_to_python_names(</span>
<span class="gi">+                names, prefer_stub_to_compiled=prefer_stub_to_compiled)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_values(values, only_stubs=False, prefer_stubs=False, ignore_compiled=True):</span>
<span class="gi">+    assert not (only_stubs and prefer_stubs)</span>
<span class="gi">+    with debug.increase_indent_cm(&#39;convert values&#39;):</span>
<span class="gi">+        if only_stubs or prefer_stubs:</span>
<span class="gi">+            return ValueSet.from_sets(</span>
<span class="gi">+                to_stub(value)</span>
<span class="gi">+                or (ValueSet({value}) if prefer_stubs else NO_VALUES)</span>
<span class="gi">+                for value in values</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ValueSet.from_sets(</span>
<span class="gi">+                _stub_to_python_value_set(stub_value, ignore_compiled=ignore_compiled)</span>
<span class="gi">+                or ValueSet({stub_value})</span>
<span class="gi">+                for stub_value in values</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_stub(value):</span>
<span class="gi">+    if value.is_stub():</span>
<span class="gi">+        return ValueSet([value])</span>
<span class="gi">+</span>
<span class="gi">+    was_instance = value.is_instance()</span>
<span class="gi">+    if was_instance:</span>
<span class="gi">+        value = value.py__class__()</span>
<span class="gi">+</span>
<span class="gi">+    qualified_names = value.get_qualified_names()</span>
<span class="gi">+    stub_module = _load_stub_module(value.get_root_context().get_value())</span>
<span class="gi">+    if stub_module is None or qualified_names is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    was_bound_method = value.is_bound_method()</span>
<span class="gi">+    if was_bound_method:</span>
<span class="gi">+        # Infer the object first. We can infer the method later.</span>
<span class="gi">+        method_name = qualified_names[-1]</span>
<span class="gi">+        qualified_names = qualified_names[:-1]</span>
<span class="gi">+        was_instance = True</span>
<span class="gi">+</span>
<span class="gi">+    stub_values = ValueSet([stub_module])</span>
<span class="gi">+    for name in qualified_names:</span>
<span class="gi">+        stub_values = stub_values.py__getattribute__(name)</span>
<span class="gi">+</span>
<span class="gi">+    if was_instance:</span>
<span class="gi">+        stub_values = ValueSet.from_sets(</span>
<span class="gi">+            c.execute_with_values()</span>
<span class="gi">+            for c in stub_values</span>
<span class="gi">+            if c.is_class()</span>
<span class="gi">+        )</span>
<span class="gi">+    if was_bound_method:</span>
<span class="gi">+        # Now that the instance has been properly created, we can simply get</span>
<span class="gi">+        # the method.</span>
<span class="gi">+        stub_values = stub_values.py__getattribute__(method_name)</span>
<span class="gi">+    return stub_values</span>
<span class="gh">diff --git a/jedi/inference/gradual/generics.py b/jedi/inference/gradual/generics.py</span>
<span class="gh">index b7bca99a..f4a5ae9c 100644</span>
<span class="gd">--- a/jedi/inference/gradual/generics.py</span>
<span class="gi">+++ b/jedi/inference/gradual/generics.py</span>
<span class="gu">@@ -2,6 +2,7 @@</span>
<span class="w"> </span>This module is about generics, like the `int` in `List[int]`. It&#39;s not about
<span class="w"> </span>the Generic class.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.cache import memoize_method
<span class="w"> </span>from jedi.inference.utils import to_tuple
<span class="gu">@@ -10,12 +11,31 @@ from jedi.inference.value.iterable import SequenceLiteralValue</span>
<span class="w"> </span>from jedi.inference.helpers import is_string


<span class="gi">+def _resolve_forward_references(context, value_set):</span>
<span class="gi">+    for value in value_set:</span>
<span class="gi">+        if is_string(value):</span>
<span class="gi">+            from jedi.inference.gradual.annotation import _get_forward_reference_node</span>
<span class="gi">+            node = _get_forward_reference_node(context, value.get_safe_value())</span>
<span class="gi">+            if node is not None:</span>
<span class="gi">+                for c in context.infer_node(node):</span>
<span class="gi">+                    yield c</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class _AbstractGenericManager:
<span class="gd">-    pass</span>
<span class="gi">+    def get_index_and_execute(self, index):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[index].execute_annotation()</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            debug.warning(&#39;No param #%s found for annotation %s&#39;, index, self)</span>
<span class="gi">+            return NO_VALUES</span>

<span class="gi">+    def get_type_hint(self):</span>
<span class="gi">+        return &#39;[%s]&#39; % &#39;, &#39;.join(t.get_type_hint(add_class_info=False) for t in self.to_tuple())</span>

<span class="gd">-class LazyGenericManager(_AbstractGenericManager):</span>

<span class="gi">+class LazyGenericManager(_AbstractGenericManager):</span>
<span class="w"> </span>    def __init__(self, context_of_index, index_value):
<span class="w"> </span>        self._context_of_index = context_of_index
<span class="w"> </span>        self._index_value = index_value
<span class="gu">@@ -27,12 +47,41 @@ class LazyGenericManager(_AbstractGenericManager):</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._tuple())

<span class="gi">+    @memoize_method</span>
<span class="gi">+    @to_tuple</span>
<span class="gi">+    def _tuple(self):</span>
<span class="gi">+        def lambda_scoping_in_for_loop_sucks(lazy_value):</span>
<span class="gi">+            return lambda: ValueSet(_resolve_forward_references(</span>
<span class="gi">+                self._context_of_index,</span>
<span class="gi">+                lazy_value.infer()</span>
<span class="gi">+            ))</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self._index_value, SequenceLiteralValue):</span>
<span class="gi">+            for lazy_value in self._index_value.py__iter__(contextualized_node=None):</span>
<span class="gi">+                yield lambda_scoping_in_for_loop_sucks(lazy_value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield lambda: ValueSet(_resolve_forward_references(</span>
<span class="gi">+                self._context_of_index,</span>
<span class="gi">+                ValueSet([self._index_value])</span>
<span class="gi">+            ))</span>
<span class="gi">+</span>
<span class="gi">+    @to_tuple</span>
<span class="gi">+    def to_tuple(self):</span>
<span class="gi">+        for callable_ in self._tuple():</span>
<span class="gi">+            yield callable_()</span>
<span class="gi">+</span>
<span class="gi">+    def is_homogenous_tuple(self):</span>
<span class="gi">+        if isinstance(self._index_value, SequenceLiteralValue):</span>
<span class="gi">+            entries = self._index_value.get_tree_entries()</span>
<span class="gi">+            if len(entries) == 2 and entries[1] == &#39;...&#39;:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;LazyG&gt;[%s]&#39; % &#39;, &#39;.join(repr(x) for x in self.to_tuple())</span>
<span class="gi">+        return &#39;&lt;LazyG&gt;[%s]&#39; % (&#39;, &#39;.join(repr(x) for x in self.to_tuple()))</span>


<span class="w"> </span>class TupleGenericManager(_AbstractGenericManager):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, tup):
<span class="w"> </span>        self._tuple = tup

<span class="gu">@@ -42,5 +91,11 @@ class TupleGenericManager(_AbstractGenericManager):</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._tuple)

<span class="gi">+    def to_tuple(self):</span>
<span class="gi">+        return self._tuple</span>
<span class="gi">+</span>
<span class="gi">+    def is_homogenous_tuple(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;TupG&gt;[%s]&#39; % &#39;, &#39;.join(repr(x) for x in self.to_tuple())</span>
<span class="gi">+        return &#39;&lt;TupG&gt;[%s]&#39; % (&#39;, &#39;.join(repr(x) for x in self.to_tuple()))</span>
<span class="gh">diff --git a/jedi/inference/gradual/stub_value.py b/jedi/inference/gradual/stub_value.py</span>
<span class="gh">index 17b168a1..22f08a10 100644</span>
<span class="gd">--- a/jedi/inference/gradual/stub_value.py</span>
<span class="gi">+++ b/jedi/inference/gradual/stub_value.py</span>
<span class="gu">@@ -13,30 +13,90 @@ class StubModuleValue(ModuleValue):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.non_stub_value_set = non_stub_value_set

<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="w"> </span>    def sub_modules_dict(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        We have to overwrite this, because it&#39;s possible to have stubs that
<span class="w"> </span>        don&#39;t have code for all the child modules. At the time of writing this
<span class="w"> </span>        there are for example no stubs for `json.tool`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        names = {}</span>
<span class="gi">+        for value in self.non_stub_value_set:</span>
<span class="gi">+            try:</span>
<span class="gi">+                method = value.sub_modules_dict</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                names.update(method())</span>
<span class="gi">+        names.update(super().sub_modules_dict())</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def _get_stub_filters(self, origin_scope):</span>
<span class="gi">+        return [StubFilter(</span>
<span class="gi">+            parent_context=self.as_context(),</span>
<span class="gi">+            origin_scope=origin_scope</span>
<span class="gi">+        )] + list(self.iter_star_filters())</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        filters = super().get_filters(origin_scope)</span>
<span class="gi">+        next(filters, None)  # Ignore the first filter and replace it with our own</span>
<span class="gi">+        stub_filters = self._get_stub_filters(origin_scope=origin_scope)</span>
<span class="gi">+        yield from stub_filters</span>
<span class="gi">+        yield from filters</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return StubModuleContext(self)</span>


<span class="w"> </span>class StubModuleContext(ModuleContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        # Make sure to ignore the position, because positions are not relevant</span>
<span class="gi">+        # for stubs.</span>
<span class="gi">+        return super().get_filters(origin_scope=origin_scope)</span>


<span class="w"> </span>class TypingModuleWrapper(StubModuleValue):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        f = next(filters, None)</span>
<span class="gi">+        assert f is not None</span>
<span class="gi">+        yield TypingModuleFilterWrapper(f)</span>
<span class="gi">+        yield from filters</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return TypingModuleContext(self)</span>


<span class="w"> </span>class TypingModuleContext(ModuleContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        yield TypingModuleFilterWrapper(next(filters, None))</span>
<span class="gi">+        yield from filters</span>


<span class="w"> </span>class StubFilter(ParserTreeFilter):
<span class="w"> </span>    name_class = StubName

<span class="gi">+    def _is_name_reachable(self, name):</span>
<span class="gi">+        if not super()._is_name_reachable(name):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Imports in stub files are only public if they have an &quot;as&quot;</span>
<span class="gi">+        # export.</span>
<span class="gi">+        definition = name.get_definition()</span>
<span class="gi">+        if definition is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if definition.type in (&#39;import_from&#39;, &#39;import_name&#39;):</span>
<span class="gi">+            if name.parent.type not in (&#39;import_as_name&#39;, &#39;dotted_as_name&#39;):</span>
<span class="gi">+                return False</span>
<span class="gi">+        n = name.value</span>
<span class="gi">+        # TODO rewrite direct return</span>
<span class="gi">+        if n.startswith(&#39;_&#39;) and not (n.startswith(&#39;__&#39;) and n.endswith(&#39;__&#39;)):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class VersionInfo(ValueWrapper):
<span class="w"> </span>    pass
<span class="gh">diff --git a/jedi/inference/gradual/type_var.py b/jedi/inference/gradual/type_var.py</span>
<span class="gh">index 207439f1..c09773f1 100644</span>
<span class="gd">--- a/jedi/inference/gradual/type_var.py</span>
<span class="gi">+++ b/jedi/inference/gradual/type_var.py</span>
<span class="gu">@@ -4,14 +4,51 @@ from jedi.inference.gradual.base import BaseTypingValue</span>


<span class="w"> </span>class TypeVarClass(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        unpacked = arguments.unpack()</span>

<span class="gi">+        key, lazy_value = next(unpacked, (None, None))</span>
<span class="gi">+        var_name = self._find_string_name(lazy_value)</span>
<span class="gi">+        # The name must be given, otherwise it&#39;s useless.</span>
<span class="gi">+        if var_name is None or key is not None:</span>
<span class="gi">+            debug.warning(&#39;Found a variable without a name %s&#39;, arguments)</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([TypeVar.create_cached(</span>
<span class="gi">+            self.inference_state,</span>
<span class="gi">+            self.parent_context,</span>
<span class="gi">+            tree_name=self.tree_node.name,</span>
<span class="gi">+            var_name=var_name,</span>
<span class="gi">+            unpacked_args=unpacked,</span>
<span class="gi">+        )])</span>
<span class="gi">+</span>
<span class="gi">+    def _find_string_name(self, lazy_value):</span>
<span class="gi">+        if lazy_value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        value_set = lazy_value.infer()</span>
<span class="gi">+        if not value_set:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if len(value_set) &gt; 1:</span>
<span class="gi">+            debug.warning(&#39;Found multiple values for a type variable: %s&#39;, value_set)</span>
<span class="gi">+</span>
<span class="gi">+        name_value = next(iter(value_set))</span>
<span class="gi">+        try:</span>
<span class="gi">+            method = name_value.get_safe_value</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            safe_value = method(default=None)</span>
<span class="gi">+            if isinstance(safe_value, str):</span>
<span class="gi">+                return safe_value</span>
<span class="gi">+            return None</span>

<span class="gd">-class TypeVar(BaseTypingValue):</span>

<span class="gi">+class TypeVar(BaseTypingValue):</span>
<span class="w"> </span>    def __init__(self, parent_context, tree_name, var_name, unpacked_args):
<span class="w"> </span>        super().__init__(parent_context, tree_name)
<span class="w"> </span>        self._var_name = var_name
<span class="gi">+</span>
<span class="w"> </span>        self._constraints_lazy_values = []
<span class="w"> </span>        self._bound_lazy_value = None
<span class="w"> </span>        self._covariant_lazy_value = None
<span class="gu">@@ -19,21 +56,72 @@ class TypeVar(BaseTypingValue):</span>
<span class="w"> </span>        for key, lazy_value in unpacked_args:
<span class="w"> </span>            if key is None:
<span class="w"> </span>                self._constraints_lazy_values.append(lazy_value)
<span class="gd">-            elif key == &#39;bound&#39;:</span>
<span class="gd">-                self._bound_lazy_value = lazy_value</span>
<span class="gd">-            elif key == &#39;covariant&#39;:</span>
<span class="gd">-                self._covariant_lazy_value = lazy_value</span>
<span class="gd">-            elif key == &#39;contravariant&#39;:</span>
<span class="gd">-                self._contra_variant_lazy_value = lazy_value</span>
<span class="w"> </span>            else:
<span class="gd">-                debug.warning(&#39;Invalid TypeVar param name %s&#39;, key)</span>
<span class="gi">+                if key == &#39;bound&#39;:</span>
<span class="gi">+                    self._bound_lazy_value = lazy_value</span>
<span class="gi">+                elif key == &#39;covariant&#39;:</span>
<span class="gi">+                    self._covariant_lazy_value = lazy_value</span>
<span class="gi">+                elif key == &#39;contravariant&#39;:</span>
<span class="gi">+                    self._contra_variant_lazy_value = lazy_value</span>
<span class="gi">+                else:</span>
<span class="gi">+                    debug.warning(&#39;Invalid TypeVar param name %s&#39;, key)</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self._var_name</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        return iter([])</span>
<span class="gi">+</span>
<span class="gi">+    def _get_classes(self):</span>
<span class="gi">+        if self._bound_lazy_value is not None:</span>
<span class="gi">+            return self._bound_lazy_value.infer()</span>
<span class="gi">+        if self._constraints_lazy_values:</span>
<span class="gi">+            return self.constraints</span>
<span class="gi">+        debug.warning(&#39;Tried to infer the TypeVar %s without a given type&#39;, self._var_name)</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def is_same_class(self, other):</span>
<span class="gi">+        # Everything can match an undefined type var.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def constraints(self):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            lazy.infer() for lazy in self._constraints_lazy_values</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def define_generics(self, type_var_dict):</span>
<span class="gi">+        try:</span>
<span class="gi">+            found = type_var_dict[self.py__name__()]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if found:</span>
<span class="gi">+                return found</span>
<span class="gi">+        return ValueSet({self})</span>
<span class="gi">+</span>
<span class="gi">+    def execute_annotation(self):</span>
<span class="gi">+        return self._get_classes().execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        def iterate():</span>
<span class="gi">+            for v in value_set:</span>
<span class="gi">+                cls = v.py__class__()</span>
<span class="gi">+                if v.is_function() or v.is_class():</span>
<span class="gi">+                    cls = TypeWrapper(cls, v)</span>
<span class="gi">+                yield cls</span>
<span class="gi">+</span>
<span class="gi">+        annotation_name = self.py__name__()</span>
<span class="gi">+        return {annotation_name: ValueSet(iterate())}</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.py__name__())


<span class="w"> </span>class TypeWrapper(ValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, wrapped_value, original_value):
<span class="w"> </span>        super().__init__(wrapped_value)
<span class="w"> </span>        self._original_value = original_value
<span class="gi">+</span>
<span class="gi">+    def execute_annotation(self):</span>
<span class="gi">+        return ValueSet({self._original_value})</span>
<span class="gh">diff --git a/jedi/inference/gradual/typeshed.py b/jedi/inference/gradual/typeshed.py</span>
<span class="gh">index 002795c5..50217cd3 100644</span>
<span class="gd">--- a/jedi/inference/gradual/typeshed.py</span>
<span class="gi">+++ b/jedi/inference/gradual/typeshed.py</span>
<span class="gu">@@ -4,25 +4,73 @@ from functools import wraps</span>
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from typing import Dict, Mapping, Tuple
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.file_io import FileIO
<span class="w"> </span>from jedi.parser_utils import get_cached_code_lines
<span class="w"> </span>from jedi.inference.base_value import ValueSet, NO_VALUES
<span class="w"> </span>from jedi.inference.gradual.stub_value import TypingModuleWrapper, StubModuleValue
<span class="w"> </span>from jedi.inference.value import ModuleValue
<span class="gi">+</span>
<span class="w"> </span>_jedi_path = Path(__file__).parent.parent.parent
<span class="w"> </span>TYPESHED_PATH = _jedi_path.joinpath(&#39;third_party&#39;, &#39;typeshed&#39;)
<span class="w"> </span>DJANGO_INIT_PATH = _jedi_path.joinpath(&#39;third_party&#39;, &#39;django-stubs&#39;,
<span class="gd">-    &#39;django-stubs&#39;, &#39;__init__.pyi&#39;)</span>
<span class="gd">-_IMPORT_MAP = dict(_collections=&#39;collections&#39;, _socket=&#39;socket&#39;)</span>
<span class="gi">+                                       &#39;django-stubs&#39;, &#39;__init__.pyi&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_IMPORT_MAP = dict(</span>
<span class="gi">+    _collections=&#39;collections&#39;,</span>
<span class="gi">+    _socket=&#39;socket&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>PathInfo = namedtuple(&#39;PathInfo&#39;, &#39;path is_third_party&#39;)


<span class="gi">+def _merge_create_stub_map(path_infos):</span>
<span class="gi">+    map_ = {}</span>
<span class="gi">+    for directory_path_info in path_infos:</span>
<span class="gi">+        map_.update(_create_stub_map(directory_path_info))</span>
<span class="gi">+    return map_</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def _create_stub_map(directory_path_info):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a mapping of an importable name in Python to a stub file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def generate():</span>
<span class="gi">+        try:</span>
<span class="gi">+            listed = os.listdir(directory_path_info.path)</span>
<span class="gi">+        except (FileNotFoundError, NotADirectoryError):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for entry in listed:</span>
<span class="gi">+            path = os.path.join(directory_path_info.path, entry)</span>
<span class="gi">+            if os.path.isdir(path):</span>
<span class="gi">+                init = os.path.join(path, &#39;__init__.pyi&#39;)</span>
<span class="gi">+                if os.path.isfile(init):</span>
<span class="gi">+                    yield entry, PathInfo(init, directory_path_info.is_third_party)</span>
<span class="gi">+            elif entry.endswith(&#39;.pyi&#39;) and os.path.isfile(path):</span>
<span class="gi">+                name = entry[:-4]</span>
<span class="gi">+                if name != &#39;__init__&#39;:</span>
<span class="gi">+                    yield name, PathInfo(path, directory_path_info.is_third_party)</span>
<span class="gi">+</span>
<span class="gi">+    # Create a dictionary from the tuple generator.</span>
<span class="gi">+    return dict(generate())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_typeshed_directories(version_info):</span>
<span class="gi">+    check_version_list = [&#39;2and3&#39;, &#39;3&#39;]</span>
<span class="gi">+    for base in [&#39;stdlib&#39;, &#39;third_party&#39;]:</span>
<span class="gi">+        base_path = TYPESHED_PATH.joinpath(base)</span>
<span class="gi">+        base_list = os.listdir(base_path)</span>
<span class="gi">+        for base_list_entry in base_list:</span>
<span class="gi">+            match = re.match(r&#39;(\d+)\.(\d+)$&#39;, base_list_entry)</span>
<span class="gi">+            if match is not None:</span>
<span class="gi">+                if match.group(1) == &#39;3&#39; and int(match.group(2)) &lt;= version_info.minor:</span>
<span class="gi">+                    check_version_list.append(base_list_entry)</span>
<span class="gi">+</span>
<span class="gi">+        for check_version in check_version_list:</span>
<span class="gi">+            is_third_party = base != &#39;stdlib&#39;</span>
<span class="gi">+            yield PathInfo(str(base_path.joinpath(check_version)), is_third_party)</span>


<span class="w"> </span>_version_cache: Dict[Tuple[int, int], Mapping[str, PathInfo]] = {}
<span class="gu">@@ -32,15 +80,231 @@ def _cache_stub_file_map(version_info):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a map of an importable name in Python to a stub file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO this caches the stub files indefinitely, maybe use a time cache</span>
<span class="gi">+    # for that?</span>
<span class="gi">+    version = version_info[:2]</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _version_cache[version]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    _version_cache[version] = file_set = \</span>
<span class="gi">+        _merge_create_stub_map(_get_typeshed_directories(version_info))</span>
<span class="gi">+    return file_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def import_module_decorator(func):</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def wrapper(inference_state, import_names, parent_module_value, sys_path, prefer_stubs):</span>
<span class="gi">+        python_value_set = inference_state.module_cache.get(import_names)</span>
<span class="gi">+        if python_value_set is None:</span>
<span class="gi">+            if parent_module_value is not None and parent_module_value.is_stub():</span>
<span class="gi">+                parent_module_values = parent_module_value.non_stub_value_set</span>
<span class="gi">+            else:</span>
<span class="gi">+                parent_module_values = [parent_module_value]</span>
<span class="gi">+            if import_names == (&#39;os&#39;, &#39;path&#39;):</span>
<span class="gi">+                # This is a huge exception, we follow a nested import</span>
<span class="gi">+                # ``os.path``, because it&#39;s a very important one in Python</span>
<span class="gi">+                # that is being achieved by messing with ``sys.modules`` in</span>
<span class="gi">+                # ``os``.</span>
<span class="gi">+                python_value_set = ValueSet.from_sets(</span>
<span class="gi">+                    func(inference_state, (n,), None, sys_path,)</span>
<span class="gi">+                    for n in [&#39;posixpath&#39;, &#39;ntpath&#39;, &#39;macpath&#39;, &#39;os2emxpath&#39;]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                python_value_set = ValueSet.from_sets(</span>
<span class="gi">+                    func(inference_state, import_names, p, sys_path,)</span>
<span class="gi">+                    for p in parent_module_values</span>
<span class="gi">+                )</span>
<span class="gi">+            inference_state.module_cache.add(import_names, python_value_set)</span>
<span class="gi">+</span>
<span class="gi">+        if not prefer_stubs or import_names[0] in settings.auto_import_modules:</span>
<span class="gi">+            return python_value_set</span>
<span class="gi">+</span>
<span class="gi">+        stub = try_to_load_stub_cached(inference_state, import_names, python_value_set,</span>
<span class="gi">+                                       parent_module_value, sys_path)</span>
<span class="gi">+        if stub is not None:</span>
<span class="gi">+            return ValueSet([stub])</span>
<span class="gi">+        return python_value_set</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def try_to_load_stub_cached(inference_state, import_names, *args, **kwargs):</span>
<span class="gi">+    if import_names is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return inference_state.stub_module_cache[import_names]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # TODO is this needed? where are the exceptions coming from that make this</span>
<span class="gi">+    # necessary? Just remove this line.</span>
<span class="gi">+    inference_state.stub_module_cache[import_names] = None</span>
<span class="gi">+    inference_state.stub_module_cache[import_names] = result = \</span>
<span class="gi">+        _try_to_load_stub(inference_state, import_names, *args, **kwargs)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _try_to_load_stub(inference_state, import_names, python_value_set,
<span class="gd">-    parent_module_value, sys_path):</span>
<span class="gi">+                      parent_module_value, sys_path):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Trying to load a stub for a set of import_names.

<span class="w"> </span>    This is modelled to work like &quot;PEP 561 -- Distributing and Packaging Type
<span class="w"> </span>    Information&quot;, see https://www.python.org/dev/peps/pep-0561.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if parent_module_value is None and len(import_names) &gt; 1:</span>
<span class="gi">+        try:</span>
<span class="gi">+            parent_module_value = try_to_load_stub_cached(</span>
<span class="gi">+                inference_state, import_names[:-1], NO_VALUES,</span>
<span class="gi">+                parent_module_value=None, sys_path=sys_path)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    # 1. Try to load foo-stubs folders on path for import name foo.</span>
<span class="gi">+    if len(import_names) == 1:</span>
<span class="gi">+        # foo-stubs</span>
<span class="gi">+        for p in sys_path:</span>
<span class="gi">+            init = os.path.join(p, *import_names) + &#39;-stubs&#39; + os.path.sep + &#39;__init__.pyi&#39;</span>
<span class="gi">+            m = _try_to_load_stub_from_file(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                python_value_set,</span>
<span class="gi">+                file_io=FileIO(init),</span>
<span class="gi">+                import_names=import_names,</span>
<span class="gi">+            )</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                return m</span>
<span class="gi">+        if import_names[0] == &#39;django&#39; and python_value_set:</span>
<span class="gi">+            return _try_to_load_stub_from_file(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                python_value_set,</span>
<span class="gi">+                file_io=FileIO(str(DJANGO_INIT_PATH)),</span>
<span class="gi">+                import_names=import_names,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # 2. Try to load pyi files next to py files.</span>
<span class="gi">+    for c in python_value_set:</span>
<span class="gi">+        try:</span>
<span class="gi">+            method = c.py__file__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            file_path = method()</span>
<span class="gi">+            file_paths = []</span>
<span class="gi">+            if c.is_namespace():</span>
<span class="gi">+                file_paths = [os.path.join(p, &#39;__init__.pyi&#39;) for p in c.py__path__()]</span>
<span class="gi">+            elif file_path is not None and file_path.suffix == &#39;.py&#39;:</span>
<span class="gi">+                file_paths = [str(file_path) + &#39;i&#39;]</span>
<span class="gi">+</span>
<span class="gi">+            for file_path in file_paths:</span>
<span class="gi">+                m = _try_to_load_stub_from_file(</span>
<span class="gi">+                    inference_state,</span>
<span class="gi">+                    python_value_set,</span>
<span class="gi">+                    # The file path should end with .pyi</span>
<span class="gi">+                    file_io=FileIO(file_path),</span>
<span class="gi">+                    import_names=import_names,</span>
<span class="gi">+                )</span>
<span class="gi">+                if m is not None:</span>
<span class="gi">+                    return m</span>
<span class="gi">+</span>
<span class="gi">+    # 3. Try to load typeshed</span>
<span class="gi">+    m = _load_from_typeshed(inference_state, python_value_set, parent_module_value, import_names)</span>
<span class="gi">+    if m is not None:</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    # 4. Try to load pyi file somewhere if python_value_set was not defined.</span>
<span class="gi">+    if not python_value_set:</span>
<span class="gi">+        if parent_module_value is not None:</span>
<span class="gi">+            check_path = parent_module_value.py__path__() or []</span>
<span class="gi">+            # In case import_names</span>
<span class="gi">+            names_for_path = (import_names[-1],)</span>
<span class="gi">+        else:</span>
<span class="gi">+            check_path = sys_path</span>
<span class="gi">+            names_for_path = import_names</span>
<span class="gi">+</span>
<span class="gi">+        for p in check_path:</span>
<span class="gi">+            m = _try_to_load_stub_from_file(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                python_value_set,</span>
<span class="gi">+                file_io=FileIO(os.path.join(p, *names_for_path) + &#39;.pyi&#39;),</span>
<span class="gi">+                import_names=import_names,</span>
<span class="gi">+            )</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                return m</span>
<span class="gi">+</span>
<span class="gi">+    # If no stub is found, that&#39;s fine, the calling function has to deal with</span>
<span class="gi">+    # it.</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_from_typeshed(inference_state, python_value_set, parent_module_value, import_names):</span>
<span class="gi">+    import_name = import_names[-1]</span>
<span class="gi">+    map_ = None</span>
<span class="gi">+    if len(import_names) == 1:</span>
<span class="gi">+        map_ = _cache_stub_file_map(inference_state.grammar.version_info)</span>
<span class="gi">+        import_name = _IMPORT_MAP.get(import_name, import_name)</span>
<span class="gi">+    elif isinstance(parent_module_value, ModuleValue):</span>
<span class="gi">+        if not parent_module_value.is_package():</span>
<span class="gi">+            # Only if it&#39;s a package (= a folder) something can be</span>
<span class="gi">+            # imported.</span>
<span class="gi">+            return None</span>
<span class="gi">+        paths = parent_module_value.py__path__()</span>
<span class="gi">+        # Once the initial package has been loaded, the sub packages will</span>
<span class="gi">+        # always be loaded, regardless if they are there or not. This makes</span>
<span class="gi">+        # sense, IMO, because stubs take preference, even if the original</span>
<span class="gi">+        # library doesn&#39;t provide a module (it could be dynamic). ~dave</span>
<span class="gi">+        map_ = _merge_create_stub_map([PathInfo(p, is_third_party=False) for p in paths])</span>
<span class="gi">+</span>
<span class="gi">+    if map_ is not None:</span>
<span class="gi">+        path_info = map_.get(import_name)</span>
<span class="gi">+        if path_info is not None and (not path_info.is_third_party or python_value_set):</span>
<span class="gi">+            return _try_to_load_stub_from_file(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                python_value_set,</span>
<span class="gi">+                file_io=FileIO(path_info.path),</span>
<span class="gi">+                import_names=import_names,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _try_to_load_stub_from_file(inference_state, python_value_set, file_io, import_names):</span>
<span class="gi">+    try:</span>
<span class="gi">+        stub_module_node = parse_stub_module(inference_state, file_io)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        # The file that you&#39;re looking for doesn&#39;t exist (anymore).</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return create_stub_module(</span>
<span class="gi">+            inference_state, inference_state.latest_grammar, python_value_set,</span>
<span class="gi">+            stub_module_node, file_io, import_names</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_stub_module(inference_state, file_io):</span>
<span class="gi">+    return inference_state.parse(</span>
<span class="gi">+        file_io=file_io,</span>
<span class="gi">+        cache=True,</span>
<span class="gi">+        diff_cache=settings.fast_parser,</span>
<span class="gi">+        cache_path=settings.cache_directory,</span>
<span class="gi">+        use_latest_grammar=True</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_stub_module(inference_state, grammar, python_value_set,</span>
<span class="gi">+                       stub_module_node, file_io, import_names):</span>
<span class="gi">+    if import_names == (&#39;typing&#39;,):</span>
<span class="gi">+        module_cls = TypingModuleWrapper</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_cls = StubModuleValue</span>
<span class="gi">+    file_name = os.path.basename(file_io.path)</span>
<span class="gi">+    stub_module_value = module_cls(</span>
<span class="gi">+        python_value_set, inference_state, stub_module_node,</span>
<span class="gi">+        file_io=file_io,</span>
<span class="gi">+        string_names=import_names,</span>
<span class="gi">+        # The code was loaded with latest_grammar, so use</span>
<span class="gi">+        # that.</span>
<span class="gi">+        code_lines=get_cached_code_lines(grammar, file_io.path),</span>
<span class="gi">+        is_package=file_name == &#39;__init__.pyi&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+    return stub_module_value</span>
<span class="gh">diff --git a/jedi/inference/gradual/typing.py b/jedi/inference/gradual/typing.py</span>
<span class="gh">index c13d5322..4466cbf4 100644</span>
<span class="gd">--- a/jedi/inference/gradual/typing.py</span>
<span class="gi">+++ b/jedi/inference/gradual/typing.py</span>
<span class="gu">@@ -6,27 +6,91 @@ values.</span>
<span class="w"> </span>This file deals with all the typing.py cases.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.compiled import builtin_from_name, create_simple_object
<span class="gd">-from jedi.inference.base_value import ValueSet, NO_VALUES, Value, LazyValueWrapper, ValueWrapper</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, NO_VALUES, Value, \</span>
<span class="gi">+    LazyValueWrapper, ValueWrapper</span>
<span class="w"> </span>from jedi.inference.lazy_value import LazyKnownValues
<span class="w"> </span>from jedi.inference.arguments import repack_with_argument_clinic
<span class="w"> </span>from jedi.inference.filters import FilterWrapper
<span class="w"> </span>from jedi.inference.names import NameWrapper, ValueName
<span class="w"> </span>from jedi.inference.value.klass import ClassMixin
<span class="gd">-from jedi.inference.gradual.base import BaseTypingValue, BaseTypingClassWithGenerics, BaseTypingInstance</span>
<span class="gi">+from jedi.inference.gradual.base import BaseTypingValue, \</span>
<span class="gi">+    BaseTypingClassWithGenerics, BaseTypingInstance</span>
<span class="w"> </span>from jedi.inference.gradual.type_var import TypeVarClass
<span class="w"> </span>from jedi.inference.gradual.generics import LazyGenericManager, TupleGenericManager
<span class="gi">+</span>
<span class="w"> </span>_PROXY_CLASS_TYPES = &#39;Tuple Generic Protocol Callable Type&#39;.split()
<span class="gd">-_TYPE_ALIAS_TYPES = {&#39;List&#39;: &#39;builtins.list&#39;, &#39;Dict&#39;: &#39;builtins.dict&#39;,</span>
<span class="gd">-    &#39;Set&#39;: &#39;builtins.set&#39;, &#39;FrozenSet&#39;: &#39;builtins.frozenset&#39;, &#39;ChainMap&#39;:</span>
<span class="gd">-    &#39;collections.ChainMap&#39;, &#39;Counter&#39;: &#39;collections.Counter&#39;, &#39;DefaultDict&#39;:</span>
<span class="gd">-    &#39;collections.defaultdict&#39;, &#39;Deque&#39;: &#39;collections.deque&#39;}</span>
<span class="gi">+_TYPE_ALIAS_TYPES = {</span>
<span class="gi">+    &#39;List&#39;: &#39;builtins.list&#39;,</span>
<span class="gi">+    &#39;Dict&#39;: &#39;builtins.dict&#39;,</span>
<span class="gi">+    &#39;Set&#39;: &#39;builtins.set&#39;,</span>
<span class="gi">+    &#39;FrozenSet&#39;: &#39;builtins.frozenset&#39;,</span>
<span class="gi">+    &#39;ChainMap&#39;: &#39;collections.ChainMap&#39;,</span>
<span class="gi">+    &#39;Counter&#39;: &#39;collections.Counter&#39;,</span>
<span class="gi">+    &#39;DefaultDict&#39;: &#39;collections.defaultdict&#39;,</span>
<span class="gi">+    &#39;Deque&#39;: &#39;collections.deque&#39;,</span>
<span class="gi">+}</span>
<span class="w"> </span>_PROXY_TYPES = &#39;Optional Union ClassVar Annotated&#39;.split()


<span class="w"> </span>class TypingModuleName(NameWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet(self._remap())</span>
<span class="gi">+</span>
<span class="gi">+    def _remap(self):</span>
<span class="gi">+        name = self.string_name</span>
<span class="gi">+        inference_state = self.parent_context.inference_state</span>
<span class="gi">+        try:</span>
<span class="gi">+            actual = _TYPE_ALIAS_TYPES[name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield TypeAlias.create_cached(</span>
<span class="gi">+                inference_state, self.parent_context, self.tree_name, actual)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if name in _PROXY_CLASS_TYPES:</span>
<span class="gi">+            yield ProxyTypingClassValue.create_cached(</span>
<span class="gi">+                inference_state, self.parent_context, self.tree_name)</span>
<span class="gi">+        elif name in _PROXY_TYPES:</span>
<span class="gi">+            yield ProxyTypingValue.create_cached(</span>
<span class="gi">+                inference_state, self.parent_context, self.tree_name)</span>
<span class="gi">+        elif name == &#39;runtime&#39;:</span>
<span class="gi">+            # We don&#39;t want anything here, not sure what this function is</span>
<span class="gi">+            # supposed to do, since it just appears in the stubs and shouldn&#39;t</span>
<span class="gi">+            # have any effects there (because it&#39;s never executed).</span>
<span class="gi">+            return</span>
<span class="gi">+        elif name == &#39;TypeVar&#39;:</span>
<span class="gi">+            cls, = self._wrapped_name.infer()</span>
<span class="gi">+            yield TypeVarClass.create_cached(inference_state, cls)</span>
<span class="gi">+        elif name == &#39;Any&#39;:</span>
<span class="gi">+            yield AnyClass.create_cached(</span>
<span class="gi">+                inference_state, self.parent_context, self.tree_name)</span>
<span class="gi">+        elif name == &#39;TYPE_CHECKING&#39;:</span>
<span class="gi">+            # This is needed for e.g. imports that are only available for type</span>
<span class="gi">+            # checking or are in cycles. The user can then check this variable.</span>
<span class="gi">+            yield builtin_from_name(inference_state, &#39;True&#39;)</span>
<span class="gi">+        elif name == &#39;overload&#39;:</span>
<span class="gi">+            yield OverloadFunction.create_cached(</span>
<span class="gi">+                inference_state, self.parent_context, self.tree_name)</span>
<span class="gi">+        elif name == &#39;NewType&#39;:</span>
<span class="gi">+            v, = self._wrapped_name.infer()</span>
<span class="gi">+            yield NewTypeFunction.create_cached(inference_state, v)</span>
<span class="gi">+        elif name == &#39;cast&#39;:</span>
<span class="gi">+            cast_fn, = self._wrapped_name.infer()</span>
<span class="gi">+            yield CastFunction.create_cached(inference_state, cast_fn)</span>
<span class="gi">+        elif name == &#39;TypedDict&#39;:</span>
<span class="gi">+            # TODO doesn&#39;t even exist in typeshed/typing.py, yet. But will be</span>
<span class="gi">+            # added soon.</span>
<span class="gi">+            yield TypedDictClass.create_cached(</span>
<span class="gi">+                inference_state, self.parent_context, self.tree_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Not necessary, as long as we are not doing type checking:</span>
<span class="gi">+            # no_type_check &amp; no_type_check_decorator</span>
<span class="gi">+            # Everything else shouldn&#39;t be relevant...</span>
<span class="gi">+            yield from self._wrapped_name.infer()</span>


<span class="w"> </span>class TypingModuleFilterWrapper(FilterWrapper):
<span class="gu">@@ -34,19 +98,142 @@ class TypingModuleFilterWrapper(FilterWrapper):</span>


<span class="w"> </span>class ProxyWithGenerics(BaseTypingClassWithGenerics):
<span class="gd">-    pass</span>
<span class="gi">+    def execute_annotation(self):</span>
<span class="gi">+        string_name = self._tree_name.value</span>
<span class="gi">+</span>
<span class="gi">+        if string_name == &#39;Union&#39;:</span>
<span class="gi">+            # This is kind of a special case, because we have Unions (in Jedi</span>
<span class="gi">+            # ValueSets).</span>
<span class="gi">+            return self.gather_annotation_classes().execute_annotation()</span>
<span class="gi">+        elif string_name == &#39;Optional&#39;:</span>
<span class="gi">+            # Optional is basically just saying it&#39;s either None or the actual</span>
<span class="gi">+            # type.</span>
<span class="gi">+            return self.gather_annotation_classes().execute_annotation() \</span>
<span class="gi">+                | ValueSet([builtin_from_name(self.inference_state, &#39;None&#39;)])</span>
<span class="gi">+        elif string_name == &#39;Type&#39;:</span>
<span class="gi">+            # The type is actually already given in the index_value</span>
<span class="gi">+            return self._generics_manager[0]</span>
<span class="gi">+        elif string_name in [&#39;ClassVar&#39;, &#39;Annotated&#39;]:</span>
<span class="gi">+            # For now don&#39;t do anything here, ClassVars are always used.</span>
<span class="gi">+            return self._generics_manager[0].execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+        mapped = {</span>
<span class="gi">+            &#39;Tuple&#39;: Tuple,</span>
<span class="gi">+            &#39;Generic&#39;: Generic,</span>
<span class="gi">+            &#39;Protocol&#39;: Protocol,</span>
<span class="gi">+            &#39;Callable&#39;: Callable,</span>
<span class="gi">+        }</span>
<span class="gi">+        cls = mapped[string_name]</span>
<span class="gi">+        return ValueSet([cls(</span>
<span class="gi">+            self.parent_context,</span>
<span class="gi">+            self,</span>
<span class="gi">+            self._tree_name,</span>
<span class="gi">+            generics_manager=self._generics_manager,</span>
<span class="gi">+        )])</span>
<span class="gi">+</span>
<span class="gi">+    def gather_annotation_classes(self):</span>
<span class="gi">+        return ValueSet.from_sets(self._generics_manager.to_tuple())</span>
<span class="gi">+</span>
<span class="gi">+    def _create_instance_with_generics(self, generics_manager):</span>
<span class="gi">+        return ProxyWithGenerics(</span>
<span class="gi">+            self.parent_context,</span>
<span class="gi">+            self._tree_name,</span>
<span class="gi">+            generics_manager</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        annotation_generics = self.get_generics()</span>
<span class="gi">+</span>
<span class="gi">+        if not annotation_generics:</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        annotation_name = self.py__name__()</span>
<span class="gi">+        if annotation_name == &#39;Optional&#39;:</span>
<span class="gi">+            # Optional[T] is equivalent to Union[T, None]. In Jedi unions</span>
<span class="gi">+            # are represented by members within a ValueSet, so we extract</span>
<span class="gi">+            # the T from the Optional[T] by removing the None value.</span>
<span class="gi">+            none = builtin_from_name(self.inference_state, &#39;None&#39;)</span>
<span class="gi">+            return annotation_generics[0].infer_type_vars(</span>
<span class="gi">+                value_set.filter(lambda x: x != none),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return {}</span>


<span class="w"> </span>class ProxyTypingValue(BaseTypingValue):
<span class="w"> </span>    index_class = ProxyWithGenerics

<span class="gi">+    def with_generics(self, generics_tuple):</span>
<span class="gi">+        return self.index_class.create_cached(</span>
<span class="gi">+            self.inference_state,</span>
<span class="gi">+            self.parent_context,</span>
<span class="gi">+            self._tree_name,</span>
<span class="gi">+            generics_manager=TupleGenericManager(generics_tuple)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            self.index_class.create_cached(</span>
<span class="gi">+                self.inference_state,</span>
<span class="gi">+                self.parent_context,</span>
<span class="gi">+                self._tree_name,</span>
<span class="gi">+                generics_manager=LazyGenericManager(</span>
<span class="gi">+                    context_of_index=contextualized_node.context,</span>
<span class="gi">+                    index_value=index_value,</span>
<span class="gi">+                )</span>
<span class="gi">+            ) for index_value in index_value_set</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class _TypingClassMixin(ClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def py__bases__(self):</span>
<span class="gi">+        return [LazyKnownValues(</span>
<span class="gi">+            self.inference_state.builtins_module.py__getattribute__(&#39;object&#39;)</span>
<span class="gi">+        )]</span>
<span class="gi">+</span>
<span class="gi">+    def get_metaclasses(self):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self._tree_name)</span>


<span class="w"> </span>class TypingClassWithGenerics(ProxyWithGenerics, _TypingClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        type_var_dict = {}</span>
<span class="gi">+        annotation_generics = self.get_generics()</span>
<span class="gi">+</span>
<span class="gi">+        if not annotation_generics:</span>
<span class="gi">+            return type_var_dict</span>
<span class="gi">+</span>
<span class="gi">+        annotation_name = self.py__name__()</span>
<span class="gi">+        if annotation_name == &#39;Type&#39;:</span>
<span class="gi">+            return annotation_generics[0].infer_type_vars(</span>
<span class="gi">+                # This is basically a trick to avoid extra code: We execute the</span>
<span class="gi">+                # incoming classes to be able to use the normal code for type</span>
<span class="gi">+                # var inference.</span>
<span class="gi">+                value_set.execute_annotation(),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        elif annotation_name == &#39;Callable&#39;:</span>
<span class="gi">+            if len(annotation_generics) == 2:</span>
<span class="gi">+                return annotation_generics[1].infer_type_vars(</span>
<span class="gi">+                    value_set.execute_annotation(),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        elif annotation_name == &#39;Tuple&#39;:</span>
<span class="gi">+            tuple_annotation, = self.execute_annotation()</span>
<span class="gi">+            return tuple_annotation.infer_type_vars(value_set)</span>
<span class="gi">+</span>
<span class="gi">+        return type_var_dict</span>
<span class="gi">+</span>
<span class="gi">+    def _create_instance_with_generics(self, generics_manager):</span>
<span class="gi">+        return TypingClassWithGenerics(</span>
<span class="gi">+            self.parent_context,</span>
<span class="gi">+            self._tree_name,</span>
<span class="gi">+            generics_manager</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ProxyTypingClassValue(ProxyTypingValue, _TypingClassMixin):
<span class="gu">@@ -54,28 +241,142 @@ class ProxyTypingClassValue(ProxyTypingValue, _TypingClassMixin):</span>


<span class="w"> </span>class TypeAlias(LazyValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, parent_context, origin_tree_name, actual):
<span class="w"> </span>        self.inference_state = parent_context.inference_state
<span class="w"> </span>        self.parent_context = parent_context
<span class="w"> </span>        self._origin_tree_name = origin_tree_name
<span class="gd">-        self._actual = actual</span>
<span class="gi">+        self._actual = actual  # e.g. builtins.list</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self._origin_tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.name.string_name</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._actual)

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        module_name, class_name = self._actual.split(&#39;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO use inference_state.import_module?</span>
<span class="gi">+        from jedi.inference.imports import Importer</span>
<span class="gi">+        module, = Importer(</span>
<span class="gi">+            self.inference_state, [module_name], self.inference_state.builtins_module</span>
<span class="gi">+        ).follow()</span>
<span class="gi">+        classes = module.py__getattribute__(class_name)</span>
<span class="gi">+        # There should only be one, because it&#39;s code that we control.</span>
<span class="gi">+        assert len(classes) == 1, classes</span>
<span class="gi">+        cls = next(iter(classes))</span>
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    def gather_annotation_classes(self):</span>
<span class="gi">+        return ValueSet([self._get_wrapped_value()])</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return []</span>

<span class="gd">-class Callable(BaseTypingInstance):</span>

<span class="gi">+class Callable(BaseTypingInstance):</span>
<span class="w"> </span>    def py__call__(self, arguments):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>            def x() -&gt; Callable[[Callable[..., _T]], _T]: ...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The 0th index are the arguments.</span>
<span class="gi">+        try:</span>
<span class="gi">+            param_values = self._generics_manager[0]</span>
<span class="gi">+            result_values = self._generics_manager[1]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            debug.warning(&#39;Callable[...] defined without two arguments&#39;)</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        else:</span>
<span class="gi">+            from jedi.inference.gradual.annotation import infer_return_for_callable</span>
<span class="gi">+            return infer_return_for_callable(arguments, param_values, result_values)</span>
<span class="gi">+</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        return ValueSet([self])</span>


<span class="w"> </span>class Tuple(BaseTypingInstance):
<span class="gd">-    pass</span>
<span class="gi">+    def _is_homogenous(self):</span>
<span class="gi">+        # To specify a variable-length tuple of homogeneous type, Tuple[T, ...]</span>
<span class="gi">+        # is used.</span>
<span class="gi">+        return self._generics_manager.is_homogenous_tuple()</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        if self._is_homogenous():</span>
<span class="gi">+            return self._generics_manager.get_index_and_execute(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(index, int):</span>
<span class="gi">+                return self._generics_manager.get_index_and_execute(index)</span>
<span class="gi">+</span>
<span class="gi">+            debug.dbg(&#39;The getitem type on Tuple was %s&#39; % index)</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        if self._is_homogenous():</span>
<span class="gi">+            yield LazyKnownValues(self._generics_manager.get_index_and_execute(0))</span>
<span class="gi">+        else:</span>
<span class="gi">+            for v in self._generics_manager.to_tuple():</span>
<span class="gi">+                yield LazyKnownValues(v.execute_annotation())</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        if self._is_homogenous():</span>
<span class="gi">+            return self._generics_manager.get_index_and_execute(0)</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            self._generics_manager.to_tuple()</span>
<span class="gi">+        ).execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        tuple_, = self.inference_state.builtins_module \</span>
<span class="gi">+            .py__getattribute__(&#39;tuple&#39;).execute_annotation()</span>
<span class="gi">+        return tuple_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return self._wrapped_value.name</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        # Circular</span>
<span class="gi">+        from jedi.inference.gradual.annotation import merge_pairwise_generics, merge_type_var_dicts</span>
<span class="gi">+</span>
<span class="gi">+        value_set = value_set.filter(</span>
<span class="gi">+            lambda x: x.py__name__().lower() == &#39;tuple&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self._is_homogenous():</span>
<span class="gi">+            # The parameter annotation is of the form `Tuple[T, ...]`,</span>
<span class="gi">+            # so we treat the incoming tuple like a iterable sequence</span>
<span class="gi">+            # rather than a positional container of elements.</span>
<span class="gi">+            return self._class_value.get_generics()[0].infer_type_vars(</span>
<span class="gi">+                value_set.merge_types_of_iterate(),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The parameter annotation has only explicit type parameters</span>
<span class="gi">+            # (e.g: `Tuple[T]`, `Tuple[T, U]`, `Tuple[T, U, V]`, etc.) so we</span>
<span class="gi">+            # treat the incoming values as needing to match the annotation</span>
<span class="gi">+            # exactly, just as we would for non-tuple annotations.</span>
<span class="gi">+</span>
<span class="gi">+            type_var_dict = {}</span>
<span class="gi">+            for element in value_set:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    method = element.get_annotated_class_object</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    # This might still happen, because the tuple name matching</span>
<span class="gi">+                    # above is not 100% correct, so just catch the remaining</span>
<span class="gi">+                    # cases here.</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                py_class = method()</span>
<span class="gi">+                merge_type_var_dicts(</span>
<span class="gi">+                    type_var_dict,</span>
<span class="gi">+                    merge_pairwise_generics(self._class_value, py_class),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            return type_var_dict</span>


<span class="w"> </span>class Generic(BaseTypingInstance):
<span class="gu">@@ -87,31 +388,60 @@ class Protocol(BaseTypingInstance):</span>


<span class="w"> </span>class AnyClass(BaseTypingValue):
<span class="gd">-    pass</span>
<span class="gi">+    def execute_annotation(self):</span>
<span class="gi">+        debug.warning(&#39;Used Any - returned no results&#39;)</span>
<span class="gi">+        return NO_VALUES</span>


<span class="w"> </span>class OverloadFunction(BaseTypingValue):
<span class="gd">-    pass</span>
<span class="gi">+    @repack_with_argument_clinic(&#39;func, /&#39;)</span>
<span class="gi">+    def py__call__(self, func_value_set):</span>
<span class="gi">+        # Just pass arguments through.</span>
<span class="gi">+        return func_value_set</span>


<span class="w"> </span>class NewTypeFunction(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        ordered_args = arguments.unpack()</span>
<span class="gi">+        next(ordered_args, (None, None))</span>
<span class="gi">+        _, second_arg = next(ordered_args, (None, None))</span>
<span class="gi">+        if second_arg is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            NewType(</span>
<span class="gi">+                self.inference_state,</span>
<span class="gi">+                contextualized_node.context,</span>
<span class="gi">+                contextualized_node.node,</span>
<span class="gi">+                second_arg.infer(),</span>
<span class="gi">+            ) for contextualized_node in arguments.get_calling_nodes())</span>


<span class="w"> </span>class NewType(Value):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, inference_state, parent_context, tree_node,</span>
<span class="gd">-        type_value_set):</span>
<span class="gi">+    def __init__(self, inference_state, parent_context, tree_node, type_value_set):</span>
<span class="w"> </span>        super().__init__(inference_state, parent_context)
<span class="w"> </span>        self._type_value_set = type_value_set
<span class="w"> </span>        self.tree_node = tree_node

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        c, = self._type_value_set.py__class__()</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        return self._type_value_set.execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        from jedi.inference.compiled.value import CompiledValueName</span>
<span class="gi">+        return CompiledValueName(self, &#39;NewType&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return &#39;&lt;NewType: %s&gt;%s&#39; % (self.tree_node, self._type_value_set)


<span class="w"> </span>class CastFunction(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    @repack_with_argument_clinic(&#39;type, object, /&#39;)</span>
<span class="gi">+    def py__call__(self, type_value_set, object_value_set):</span>
<span class="gi">+        return type_value_set.execute_annotation()</span>


<span class="w"> </span>class TypedDictClass(BaseTypingValue):
<span class="gu">@@ -123,9 +453,36 @@ class TypedDictClass(BaseTypingValue):</span>

<span class="w"> </span>class TypedDict(LazyValueWrapper):
<span class="w"> </span>    &quot;&quot;&quot;Represents the instance version of ``TypedDictClass``.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, definition_class):
<span class="w"> </span>        self.inference_state = definition_class.inference_state
<span class="w"> </span>        self.parent_context = definition_class.parent_context
<span class="w"> </span>        self.tree_node = definition_class.tree_node
<span class="w"> </span>        self._definition_class = definition_class
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self.tree_node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        if isinstance(index, str):</span>
<span class="gi">+            return ValueSet.from_sets(</span>
<span class="gi">+                name.infer()</span>
<span class="gi">+                for filter in self._definition_class.get_filters(is_instance=True)</span>
<span class="gi">+                for name in filter.get(index)</span>
<span class="gi">+            )</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        filtered_values = itertools.chain.from_iterable((</span>
<span class="gi">+            f.values()</span>
<span class="gi">+            for f in self._definition_class.get_filters(is_instance=True)</span>
<span class="gi">+        ))</span>
<span class="gi">+        return ValueSet({</span>
<span class="gi">+            create_simple_object(self.inference_state, v.string_name)</span>
<span class="gi">+            for v in filtered_values</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        d, = self.inference_state.builtins_module.py__getattribute__(&#39;dict&#39;)</span>
<span class="gi">+        result, = d.execute_with_values()</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/jedi/inference/gradual/utils.py b/jedi/inference/gradual/utils.py</span>
<span class="gh">index 70d131f0..af3703c7 100644</span>
<span class="gd">--- a/jedi/inference/gradual/utils.py</span>
<span class="gi">+++ b/jedi/inference/gradual/utils.py</span>
<span class="gu">@@ -1,11 +1,35 @@</span>
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.gradual.typeshed import TYPESHED_PATH, create_stub_module


<span class="gd">-def load_proper_stub_module(inference_state, grammar, file_io, import_names,</span>
<span class="gd">-    module_node):</span>
<span class="gi">+def load_proper_stub_module(inference_state, grammar, file_io, import_names, module_node):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This function is given a random .pyi file and should return the proper
<span class="w"> </span>    module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = file_io.path</span>
<span class="gi">+    path = Path(path)</span>
<span class="gi">+    assert path.suffix == &#39;.pyi&#39;</span>
<span class="gi">+    try:</span>
<span class="gi">+        relative_path = path.relative_to(TYPESHED_PATH)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        # /[...]/stdlib/3/os/__init__.pyi -&gt; stdlib/3/os/__init__</span>
<span class="gi">+        rest = relative_path.with_suffix(&#39;&#39;)</span>
<span class="gi">+        # Remove the stdlib/3 or third_party/3.6 part</span>
<span class="gi">+        import_names = rest.parts[2:]</span>
<span class="gi">+        if rest.name == &#39;__init__&#39;:</span>
<span class="gi">+            import_names = import_names[:-1]</span>
<span class="gi">+</span>
<span class="gi">+    if import_names is not None:</span>
<span class="gi">+        actual_value_set = inference_state.import_module(import_names, prefer_stubs=False)</span>
<span class="gi">+</span>
<span class="gi">+        stub = create_stub_module(</span>
<span class="gi">+            inference_state, grammar, actual_value_set,</span>
<span class="gi">+            module_node, file_io, import_names</span>
<span class="gi">+        )</span>
<span class="gi">+        inference_state.stub_module_cache[import_names] = stub</span>
<span class="gi">+        return stub</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/jedi/inference/helpers.py b/jedi/inference/helpers.py</span>
<span class="gh">index 528831da..0e344c24 100644</span>
<span class="gd">--- a/jedi/inference/helpers.py</span>
<span class="gi">+++ b/jedi/inference/helpers.py</span>
<span class="gu">@@ -4,14 +4,42 @@ import re</span>
<span class="w"> </span>import os
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>from parso.python import tree


<span class="gi">+def is_stdlib_path(path):</span>
<span class="gi">+    # Python standard library paths look like this:</span>
<span class="gi">+    # /usr/lib/python3.9/...</span>
<span class="gi">+    # TODO The implementation below is probably incorrect and not complete.</span>
<span class="gi">+    parts = path.parts</span>
<span class="gi">+    if &#39;dist-packages&#39; in parts or &#39;site-packages&#39; in parts:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    base_path = os.path.join(sys.prefix, &#39;lib&#39;, &#39;python&#39;)</span>
<span class="gi">+    return bool(re.match(re.escape(base_path) + r&#39;\d.\d&#39;, str(path)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def deep_ast_copy(obj):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Much, much faster than copy.deepcopy, but just for parser tree nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If it&#39;s already in the cache, just return it.</span>
<span class="gi">+    new_obj = copy.copy(obj)</span>
<span class="gi">+</span>
<span class="gi">+    # Copy children</span>
<span class="gi">+    new_children = []</span>
<span class="gi">+    for child in obj.children:</span>
<span class="gi">+        if isinstance(child, tree.Leaf):</span>
<span class="gi">+            new_child = copy.copy(child)</span>
<span class="gi">+            new_child.parent = new_obj</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_child = deep_ast_copy(child)</span>
<span class="gi">+            new_child.parent = new_obj</span>
<span class="gi">+        new_children.append(new_child)</span>
<span class="gi">+    new_obj.children = new_children</span>
<span class="gi">+</span>
<span class="gi">+    return new_obj</span>


<span class="w"> </span>def infer_call_of_leaf(context, leaf, cut_own_trailer=False):
<span class="gu">@@ -33,8 +61,142 @@ def infer_call_of_leaf(context, leaf, cut_own_trailer=False):</span>
<span class="w"> </span>      - infer the type of ``bar`` to be able to jump to the definition of foo
<span class="w"> </span>    The option ``cut_own_trailer`` must be set to true for the second purpose.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    trailer = leaf.parent</span>
<span class="gi">+    if trailer.type == &#39;fstring&#39;:</span>
<span class="gi">+        from jedi.inference import compiled</span>
<span class="gi">+        return compiled.get_string_value_set(context.inference_state)</span>
<span class="gi">+</span>
<span class="gi">+    # The leaf may not be the last or first child, because there exist three</span>
<span class="gi">+    # different trailers: `( x )`, `[ x ]` and `.x`. In the first two examples</span>
<span class="gi">+    # we should not match anything more than x.</span>
<span class="gi">+    if trailer.type != &#39;trailer&#39; or leaf not in (trailer.children[0], trailer.children[-1]):</span>
<span class="gi">+        if leaf == &#39;:&#39;:</span>
<span class="gi">+            # Basically happens with foo[:] when the cursor is on the colon</span>
<span class="gi">+            from jedi.inference.base_value import NO_VALUES</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        if trailer.type == &#39;atom&#39;:</span>
<span class="gi">+            return context.infer_node(trailer)</span>
<span class="gi">+        return context.infer_node(leaf)</span>
<span class="gi">+</span>
<span class="gi">+    power = trailer.parent</span>
<span class="gi">+    index = power.children.index(trailer)</span>
<span class="gi">+    if cut_own_trailer:</span>
<span class="gi">+        cut = index</span>
<span class="gi">+    else:</span>
<span class="gi">+        cut = index + 1</span>
<span class="gi">+</span>
<span class="gi">+    if power.type == &#39;error_node&#39;:</span>
<span class="gi">+        start = index</span>
<span class="gi">+        while True:</span>
<span class="gi">+            start -= 1</span>
<span class="gi">+            base = power.children[start]</span>
<span class="gi">+            if base.type != &#39;trailer&#39;:</span>
<span class="gi">+                break</span>
<span class="gi">+        trailers = power.children[start + 1:cut]</span>
<span class="gi">+    else:</span>
<span class="gi">+        base = power.children[0]</span>
<span class="gi">+        trailers = power.children[1:cut]</span>
<span class="gi">+</span>
<span class="gi">+    if base == &#39;await&#39;:</span>
<span class="gi">+        base = trailers[0]</span>
<span class="gi">+        trailers = trailers[1:]</span>
<span class="gi">+</span>
<span class="gi">+    values = context.infer_node(base)</span>
<span class="gi">+    from jedi.inference.syntax_tree import infer_trailer</span>
<span class="gi">+    for trailer in trailers:</span>
<span class="gi">+        values = infer_trailer(context, values, trailer)</span>
<span class="gi">+    return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_names_of_node(node):</span>
<span class="gi">+    try:</span>
<span class="gi">+        children = node.children</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        if node.type == &#39;name&#39;:</span>
<span class="gi">+            return [node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+    else:</span>
<span class="gi">+        return list(chain.from_iterable(get_names_of_node(c) for c in children))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_string(value):</span>
<span class="gi">+    return value.is_compiled() and isinstance(value.get_safe_value(default=None), str)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_literal(value):</span>
<span class="gi">+    return is_number(value) or is_string(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_safe_value_or_none(value, accept):</span>
<span class="gi">+    value = value.get_safe_value(default=None)</span>
<span class="gi">+    if isinstance(value, accept):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_int_or_none(value):</span>
<span class="gi">+    return _get_safe_value_or_none(value, int)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_str_or_none(value):</span>
<span class="gi">+    return _get_safe_value_or_none(value, str)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_number(value):</span>
<span class="gi">+    return _get_safe_value_or_none(value, (int, float)) is not None</span>


<span class="w"> </span>class SimpleGetItemNotFound(Exception):
<span class="w"> </span>    pass
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def reraise_getitem_errors(*exception_classes):</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    except exception_classes as e:</span>
<span class="gi">+        raise SimpleGetItemNotFound(e)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_dotted_names(nodes, is_import_from, until_node=None):</span>
<span class="gi">+    level = 0</span>
<span class="gi">+    names = []</span>
<span class="gi">+    for node in nodes[1:]:</span>
<span class="gi">+        if node in (&#39;.&#39;, &#39;...&#39;):</span>
<span class="gi">+            if not names:</span>
<span class="gi">+                level += len(node.value)</span>
<span class="gi">+        elif node.type == &#39;dotted_name&#39;:</span>
<span class="gi">+            for n in node.children[::2]:</span>
<span class="gi">+                names.append(n)</span>
<span class="gi">+                if n is until_node:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+        elif node.type == &#39;name&#39;:</span>
<span class="gi">+            names.append(node)</span>
<span class="gi">+            if node is until_node:</span>
<span class="gi">+                break</span>
<span class="gi">+        elif node == &#39;,&#39;:</span>
<span class="gi">+            if not is_import_from:</span>
<span class="gi">+                names = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Here if the keyword `import` comes along it stops checking</span>
<span class="gi">+            # for names.</span>
<span class="gi">+            break</span>
<span class="gi">+    return level, names</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def values_from_qualified_names(inference_state, *names):</span>
<span class="gi">+    return inference_state.import_module(names[:-1]).py__getattribute__(names[-1])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_big_annoying_library(context):</span>
<span class="gi">+    string_names = context.get_root_context().string_names</span>
<span class="gi">+    if string_names is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Especially pandas and tensorflow are huge complicated Python libraries</span>
<span class="gi">+    # that get even slower than they already are when Jedi tries to undrstand</span>
<span class="gi">+    # dynamic features like decorators, ifs and other stuff.</span>
<span class="gi">+    return string_names[0] in (&#39;pandas&#39;, &#39;numpy&#39;, &#39;tensorflow&#39;, &#39;matplotlib&#39;)</span>
<span class="gh">diff --git a/jedi/inference/imports.py b/jedi/inference/imports.py</span>
<span class="gh">index 960fd535..c1a4953f 100644</span>
<span class="gd">--- a/jedi/inference/imports.py</span>
<span class="gi">+++ b/jedi/inference/imports.py</span>
<span class="gu">@@ -10,8 +10,10 @@ statements like ``from datetim`` (cursor at the end would return ``datetime``).</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import os
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from parso.python import tree
<span class="w"> </span>from parso.tree import search_ancestor
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.file_io import FolderIO
<span class="gu">@@ -24,16 +26,102 @@ from jedi.inference.utils import unite</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.names import ImportName, SubModuleName
<span class="w"> </span>from jedi.inference.base_value import ValueSet, NO_VALUES
<span class="gd">-from jedi.inference.gradual.typeshed import import_module_decorator, create_stub_module, parse_stub_module</span>
<span class="gi">+from jedi.inference.gradual.typeshed import import_module_decorator, \</span>
<span class="gi">+    create_stub_module, parse_stub_module</span>
<span class="w"> </span>from jedi.inference.compiled.subprocess.functions import ImplicitNSInfo
<span class="w"> </span>from jedi.plugins import plugin_manager


<span class="w"> </span>class ModuleCache:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._name_cache = {}

<span class="gi">+    def add(self, string_names, value_set):</span>
<span class="gi">+        if string_names is not None:</span>
<span class="gi">+            self._name_cache[string_names] = value_set</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, string_names):</span>
<span class="gi">+        return self._name_cache.get(string_names)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This memoization is needed, because otherwise we will infinitely loop on</span>
<span class="gi">+# certain imports.</span>
<span class="gi">+@inference_state_method_cache(default=NO_VALUES)</span>
<span class="gi">+def infer_import(context, tree_name):</span>
<span class="gi">+    module_context = context.get_root_context()</span>
<span class="gi">+    from_import_name, import_path, level, values = \</span>
<span class="gi">+        _prepare_infer_import(module_context, tree_name)</span>
<span class="gi">+    if values:</span>
<span class="gi">+</span>
<span class="gi">+        if from_import_name is not None:</span>
<span class="gi">+            values = values.py__getattribute__(</span>
<span class="gi">+                from_import_name,</span>
<span class="gi">+                name_context=context,</span>
<span class="gi">+                analysis_errors=False</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if not values:</span>
<span class="gi">+                path = import_path + (from_import_name,)</span>
<span class="gi">+                importer = Importer(context.inference_state, path, module_context, level)</span>
<span class="gi">+                values = importer.follow()</span>
<span class="gi">+    debug.dbg(&#39;after import: %s&#39;, values)</span>
<span class="gi">+    return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_method_cache(default=[])</span>
<span class="gi">+def goto_import(context, tree_name):</span>
<span class="gi">+    module_context = context.get_root_context()</span>
<span class="gi">+    from_import_name, import_path, level, values = \</span>
<span class="gi">+        _prepare_infer_import(module_context, tree_name)</span>
<span class="gi">+    if not values:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if from_import_name is not None:</span>
<span class="gi">+        names = unite([</span>
<span class="gi">+            c.goto(</span>
<span class="gi">+                from_import_name,</span>
<span class="gi">+                name_context=context,</span>
<span class="gi">+                analysis_errors=False</span>
<span class="gi">+            ) for c in values</span>
<span class="gi">+        ])</span>
<span class="gi">+        # Avoid recursion on the same names.</span>
<span class="gi">+        if names and not any(n.tree_name is tree_name for n in names):</span>
<span class="gi">+            return names</span>
<span class="gi">+</span>
<span class="gi">+        path = import_path + (from_import_name,)</span>
<span class="gi">+        importer = Importer(context.inference_state, path, module_context, level)</span>
<span class="gi">+        values = importer.follow()</span>
<span class="gi">+    return set(s.name for s in values)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _prepare_infer_import(module_context, tree_name):</span>
<span class="gi">+    import_node = search_ancestor(tree_name, &#39;import_name&#39;, &#39;import_from&#39;)</span>
<span class="gi">+    import_path = import_node.get_path_for_name(tree_name)</span>
<span class="gi">+    from_import_name = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        from_names = import_node.get_from_names()</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # Is an import_name</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        if len(from_names) + 1 == len(import_path):</span>
<span class="gi">+            # We have to fetch the from_names part first and then check</span>
<span class="gi">+            # if from_names exists in the modules.</span>
<span class="gi">+            from_import_name = import_path[-1]</span>
<span class="gi">+            import_path = from_names</span>
<span class="gi">+</span>
<span class="gi">+    importer = Importer(module_context.inference_state, tuple(import_path),</span>
<span class="gi">+                        module_context, import_node.level)</span>
<span class="gi">+</span>
<span class="gi">+    return from_import_name, tuple(import_path), import_node.level, importer.follow()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_error(value, name, message):</span>
<span class="gi">+    if hasattr(name, &#39;parent&#39;) and value is not None:</span>
<span class="gi">+        analysis.add(value, &#39;import-error&#39;, name, message)</span>
<span class="gi">+    else:</span>
<span class="gi">+        debug.warning(&#39;ImportError without origin: &#39; + message)</span>
<span class="gi">+</span>

<span class="w"> </span>def _level_to_base_import_path(project_path, directory, level):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -41,11 +129,28 @@ def _level_to_base_import_path(project_path, directory, level):</span>
<span class="w"> </span>    import .....foo), we can still try our best to help the user for
<span class="w"> </span>    completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i in range(level - 1):</span>
<span class="gi">+        old = directory</span>
<span class="gi">+        directory = os.path.dirname(directory)</span>
<span class="gi">+        if old == directory:</span>
<span class="gi">+            return None, None</span>

<span class="gi">+    d = directory</span>
<span class="gi">+    level_import_paths = []</span>
<span class="gi">+    # Now that we are on the level that the user wants to be, calculate the</span>
<span class="gi">+    # import path for it.</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if d == project_path:</span>
<span class="gi">+            return level_import_paths, d</span>
<span class="gi">+        dir_name = os.path.basename(d)</span>
<span class="gi">+        if dir_name:</span>
<span class="gi">+            level_import_paths.insert(0, dir_name)</span>
<span class="gi">+            d = os.path.dirname(d)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None, directory</span>

<span class="gd">-class Importer:</span>

<span class="gi">+class Importer:</span>
<span class="w"> </span>    def __init__(self, inference_state, import_path, module_context, level=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        An implementation similar to ``__import__``. Use `follow`
<span class="gu">@@ -63,11 +168,22 @@ class Importer:</span>
<span class="w"> </span>        self._inference_state = inference_state
<span class="w"> </span>        self.level = level
<span class="w"> </span>        self._module_context = module_context
<span class="gi">+</span>
<span class="w"> </span>        self._fixed_sys_path = None
<span class="w"> </span>        self._infer_possible = True
<span class="w"> </span>        if level:
<span class="w"> </span>            base = module_context.get_value().py__package__()
<span class="gi">+            # We need to care for two cases, the first one is if it&#39;s a valid</span>
<span class="gi">+            # Python import. This import has a properly defined module name</span>
<span class="gi">+            # chain like `foo.bar.baz` and an import in baz is made for</span>
<span class="gi">+            # `..lala.` It can then resolve to `foo.bar.lala`.</span>
<span class="gi">+            # The else here is a heuristic for all other cases, if for example</span>
<span class="gi">+            # in `foo` you search for `...bar`, it&#39;s obviously out of scope.</span>
<span class="gi">+            # However since Jedi tries to just do it&#39;s best, we help the user</span>
<span class="gi">+            # here, because he might have specified something wrong in his</span>
<span class="gi">+            # project.</span>
<span class="w"> </span>            if level &lt;= len(base):
<span class="gi">+                # Here we basically rewrite the level to 0.</span>
<span class="w"> </span>                base = tuple(base)
<span class="w"> </span>                if level &gt; 1:
<span class="w"> </span>                    base = base[:-level + 1]
<span class="gu">@@ -77,20 +193,30 @@ class Importer:</span>
<span class="w"> </span>                project_path = self._inference_state.project.path
<span class="w"> </span>                import_path = list(import_path)
<span class="w"> </span>                if path is None:
<span class="gi">+                    # If no path is defined, our best guess is that the current</span>
<span class="gi">+                    # file is edited by a user on the current working</span>
<span class="gi">+                    # directory. We need to add an initial path, because it</span>
<span class="gi">+                    # will get removed as the name of the current file.</span>
<span class="w"> </span>                    directory = project_path
<span class="w"> </span>                else:
<span class="w"> </span>                    directory = os.path.dirname(path)
<span class="gi">+</span>
<span class="w"> </span>                base_import_path, base_directory = _level_to_base_import_path(
<span class="gd">-                    project_path, directory, level)</span>
<span class="gi">+                    project_path, directory, level,</span>
<span class="gi">+                )</span>
<span class="w"> </span>                if base_directory is None:
<span class="gi">+                    # Everything is lost, the relative import does point</span>
<span class="gi">+                    # somewhere out of the filesystem.</span>
<span class="w"> </span>                    self._infer_possible = False
<span class="w"> </span>                else:
<span class="w"> </span>                    self._fixed_sys_path = [base_directory]
<span class="gi">+</span>
<span class="w"> </span>                if base_import_path is None:
<span class="w"> </span>                    if import_path:
<span class="gd">-                        _add_error(module_context, import_path[0], message=</span>
<span class="gd">-                            &#39;Attempted relative import beyond top-level package.&#39;</span>
<span class="gd">-                            )</span>
<span class="gi">+                        _add_error(</span>
<span class="gi">+                            module_context, import_path[0],</span>
<span class="gi">+                            message=&#39;Attempted relative import beyond top-level package.&#39;</span>
<span class="gi">+                        )</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    import_path = base_import_path + import_path
<span class="w"> </span>        self.import_path = import_path
<span class="gu">@@ -98,47 +224,369 @@ class Importer:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def _str_import_path(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the import path as pure strings instead of `Name`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            name.value if isinstance(name, tree.Name) else name</span>
<span class="gi">+            for name in self.import_path</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _sys_path_with_modifications(self, is_completion):</span>
<span class="gi">+        if self._fixed_sys_path is not None:</span>
<span class="gi">+            return self._fixed_sys_path</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            # For import completions we don&#39;t want to see init paths, but for</span>
<span class="gi">+            # inference we want to show the user as much as possible.</span>
<span class="gi">+            # See GH #1446.</span>
<span class="gi">+            self._inference_state.get_sys_path(add_init_paths=not is_completion)</span>
<span class="gi">+            + [</span>
<span class="gi">+                str(p) for p</span>
<span class="gi">+                in sys_path.check_sys_path_modifications(self._module_context)</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def follow(self):</span>
<span class="gi">+        if not self.import_path:</span>
<span class="gi">+            if self._fixed_sys_path:</span>
<span class="gi">+                # This is a bit of a special case, that maybe should be</span>
<span class="gi">+                # revisited. If the project path is wrong or the user uses</span>
<span class="gi">+                # relative imports the wrong way, we might end up here, where</span>
<span class="gi">+                # the `fixed_sys_path == project.path` in that case we kind of</span>
<span class="gi">+                # use the project.path.parent directory as our path. This is</span>
<span class="gi">+                # usually not a problem, except if imports in other places are</span>
<span class="gi">+                # using the same names. Example:</span>
<span class="gi">+                #</span>
<span class="gi">+                # foo/                       &lt; #1</span>
<span class="gi">+                #   - setup.py</span>
<span class="gi">+                #   - foo/                   &lt; #2</span>
<span class="gi">+                #     - __init__.py</span>
<span class="gi">+                #     - foo.py               &lt; #3</span>
<span class="gi">+                #</span>
<span class="gi">+                # If the top foo is our project folder and somebody uses</span>
<span class="gi">+                # `from . import foo` in `setup.py`, it will resolve to foo #2,</span>
<span class="gi">+                # which means that the import for foo.foo is cached as</span>
<span class="gi">+                # `__init__.py` (#2) and not as `foo.py` (#3). This is usually</span>
<span class="gi">+                # not an issue, because this case is probably pretty rare, but</span>
<span class="gi">+                # might be an issue for some people.</span>
<span class="gi">+                #</span>
<span class="gi">+                # However for most normal cases where we work with different</span>
<span class="gi">+                # file names, this code path hits where we basically change the</span>
<span class="gi">+                # project path to an ancestor of project path.</span>
<span class="gi">+                from jedi.inference.value.namespace import ImplicitNamespaceValue</span>
<span class="gi">+                import_path = (os.path.basename(self._fixed_sys_path[0]),)</span>
<span class="gi">+                ns = ImplicitNamespaceValue(</span>
<span class="gi">+                    self._inference_state,</span>
<span class="gi">+                    string_names=import_path,</span>
<span class="gi">+                    paths=self._fixed_sys_path,</span>
<span class="gi">+                )</span>
<span class="gi">+                return ValueSet({ns})</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        if not self._infer_possible:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        # Check caches first</span>
<span class="gi">+        from_cache = self._inference_state.stub_module_cache.get(self._str_import_path)</span>
<span class="gi">+        if from_cache is not None:</span>
<span class="gi">+            return ValueSet({from_cache})</span>
<span class="gi">+        from_cache = self._inference_state.module_cache.get(self._str_import_path)</span>
<span class="gi">+        if from_cache is not None:</span>
<span class="gi">+            return from_cache</span>
<span class="gi">+</span>
<span class="gi">+        sys_path = self._sys_path_with_modifications(is_completion=False)</span>
<span class="gi">+</span>
<span class="gi">+        return import_module_by_names(</span>
<span class="gi">+            self._inference_state, self.import_path, sys_path, self._module_context</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _get_module_names(self, search_path=None, in_module=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the names of all modules in the search_path. This means file names
<span class="w"> </span>        and not names defined in the files.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if search_path is None:</span>
<span class="gi">+            sys_path = self._sys_path_with_modifications(is_completion=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys_path = search_path</span>
<span class="gi">+        return list(iter_module_names(</span>
<span class="gi">+            self._inference_state, self._module_context, sys_path,</span>
<span class="gi">+            module_cls=ImportName if in_module is None else SubModuleName,</span>
<span class="gi">+            add_builtin_modules=search_path is None and in_module is None,</span>
<span class="gi">+        ))</span>

<span class="w"> </span>    def completion_names(self, inference_state, only_modules=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param only_modules: Indicates wheter it&#39;s possible to import a
<span class="w"> </span>            definition that is not defined in a module.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._infer_possible:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        names = []</span>
<span class="gi">+        if self.import_path:</span>
<span class="gi">+            # flask</span>
<span class="gi">+            if self._str_import_path == (&#39;flask&#39;, &#39;ext&#39;):</span>
<span class="gi">+                # List Flask extensions like ``flask_foo``</span>
<span class="gi">+                for mod in self._get_module_names():</span>
<span class="gi">+                    modname = mod.string_name</span>
<span class="gi">+                    if modname.startswith(&#39;flask_&#39;):</span>
<span class="gi">+                        extname = modname[len(&#39;flask_&#39;):]</span>
<span class="gi">+                        names.append(ImportName(self._module_context, extname))</span>
<span class="gi">+                # Now the old style: ``flaskext.foo``</span>
<span class="gi">+                for dir in self._sys_path_with_modifications(is_completion=True):</span>
<span class="gi">+                    flaskext = os.path.join(dir, &#39;flaskext&#39;)</span>
<span class="gi">+                    if os.path.isdir(flaskext):</span>
<span class="gi">+                        names += self._get_module_names([flaskext])</span>
<span class="gi">+</span>
<span class="gi">+            values = self.follow()</span>
<span class="gi">+            for value in values:</span>
<span class="gi">+                # Non-modules are not completable.</span>
<span class="gi">+                if value.api_type not in (&#39;module&#39;, &#39;namespace&#39;):  # not a module</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if not value.is_compiled():</span>
<span class="gi">+                    # sub_modules_dict is not implemented for compiled modules.</span>
<span class="gi">+                    names += value.sub_modules_dict().values()</span>
<span class="gi">+</span>
<span class="gi">+            if not only_modules:</span>
<span class="gi">+                from jedi.inference.gradual.conversion import convert_values</span>
<span class="gi">+</span>
<span class="gi">+                both_values = values | convert_values(values)</span>
<span class="gi">+                for c in both_values:</span>
<span class="gi">+                    for filter in c.get_filters():</span>
<span class="gi">+                        names += filter.values()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.level:</span>
<span class="gi">+                # We only get here if the level cannot be properly calculated.</span>
<span class="gi">+                names += self._get_module_names(self._fixed_sys_path)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # This is just the list of global imports.</span>
<span class="gi">+                names += self._get_module_names()</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def import_module_by_names(inference_state, import_names, sys_path=None,</span>
<span class="gi">+                           module_context=None, prefer_stubs=True):</span>
<span class="gi">+    if sys_path is None:</span>
<span class="gi">+        sys_path = inference_state.get_sys_path()</span>
<span class="gi">+</span>
<span class="gi">+    str_import_names = tuple(</span>
<span class="gi">+        i.value if isinstance(i, tree.Name) else i</span>
<span class="gi">+        for i in import_names</span>
<span class="gi">+    )</span>
<span class="gi">+    value_set = [None]</span>
<span class="gi">+    for i, name in enumerate(import_names):</span>
<span class="gi">+        value_set = ValueSet.from_sets([</span>
<span class="gi">+            import_module(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                str_import_names[:i+1],</span>
<span class="gi">+                parent_module_value,</span>
<span class="gi">+                sys_path,</span>
<span class="gi">+                prefer_stubs=prefer_stubs,</span>
<span class="gi">+            ) for parent_module_value in value_set</span>
<span class="gi">+        ])</span>
<span class="gi">+        if not value_set:</span>
<span class="gi">+            message = &#39;No module named &#39; + &#39;.&#39;.join(str_import_names)</span>
<span class="gi">+            if module_context is not None:</span>
<span class="gi">+                _add_error(module_context, name, message)</span>
<span class="gi">+            else:</span>
<span class="gi">+                debug.warning(message)</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+    return value_set</span>


<span class="w"> </span>@plugin_manager.decorate()
<span class="w"> </span>@import_module_decorator
<span class="gd">-def import_module(inference_state, import_names, parent_module_value, sys_path</span>
<span class="gd">-    ):</span>
<span class="gi">+def import_module(inference_state, import_names, parent_module_value, sys_path):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This method is very similar to importlib&#39;s `_gcd_import`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if import_names[0] in settings.auto_import_modules:</span>
<span class="gi">+        module = _load_builtin_module(inference_state, import_names, sys_path)</span>
<span class="gi">+        if module is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        return ValueSet([module])</span>
<span class="gi">+</span>
<span class="gi">+    module_name = &#39;.&#39;.join(import_names)</span>
<span class="gi">+    if parent_module_value is None:</span>
<span class="gi">+        # Override the sys.path. It works only good that way.</span>
<span class="gi">+        # Injecting the path directly into `find_module` did not work.</span>
<span class="gi">+        file_io_or_ns, is_pkg = inference_state.compiled_subprocess.get_module_info(</span>
<span class="gi">+            string=import_names[-1],</span>
<span class="gi">+            full_name=module_name,</span>
<span class="gi">+            sys_path=sys_path,</span>
<span class="gi">+            is_global_search=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        if is_pkg is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+    else:</span>
<span class="gi">+        paths = parent_module_value.py__path__()</span>
<span class="gi">+        if paths is None:</span>
<span class="gi">+            # The module might not be a package.</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        file_io_or_ns, is_pkg = inference_state.compiled_subprocess.get_module_info(</span>
<span class="gi">+            string=import_names[-1],</span>
<span class="gi">+            path=paths,</span>
<span class="gi">+            full_name=module_name,</span>
<span class="gi">+            is_global_search=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        if is_pkg is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(file_io_or_ns, ImplicitNSInfo):</span>
<span class="gi">+        from jedi.inference.value.namespace import ImplicitNamespaceValue</span>
<span class="gi">+        module = ImplicitNamespaceValue(</span>
<span class="gi">+            inference_state,</span>
<span class="gi">+            string_names=tuple(file_io_or_ns.name.split(&#39;.&#39;)),</span>
<span class="gi">+            paths=file_io_or_ns.paths,</span>
<span class="gi">+        )</span>
<span class="gi">+    elif file_io_or_ns is None:</span>
<span class="gi">+        module = _load_builtin_module(inference_state, import_names, sys_path)</span>
<span class="gi">+        if module is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+    else:</span>
<span class="gi">+        module = _load_python_module(</span>
<span class="gi">+            inference_state, file_io_or_ns,</span>
<span class="gi">+            import_names=import_names,</span>
<span class="gi">+            is_package=is_pkg,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if parent_module_value is None:</span>
<span class="gi">+        debug.dbg(&#39;global search_module %s: %s&#39;, import_names[-1], module)</span>
<span class="gi">+    else:</span>
<span class="gi">+        debug.dbg(&#39;search_module %s in paths %s: %s&#39;, module_name, paths, module)</span>
<span class="gi">+    return ValueSet([module])</span>


<span class="gd">-def load_module_from_path(inference_state, file_io, import_names=None,</span>
<span class="gd">-    is_package=None):</span>
<span class="gi">+def _load_python_module(inference_state, file_io,</span>
<span class="gi">+                        import_names=None, is_package=False):</span>
<span class="gi">+    module_node = inference_state.parse(</span>
<span class="gi">+        file_io=file_io,</span>
<span class="gi">+        cache=True,</span>
<span class="gi">+        diff_cache=settings.fast_parser,</span>
<span class="gi">+        cache_path=settings.cache_directory,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    from jedi.inference.value import ModuleValue</span>
<span class="gi">+    return ModuleValue(</span>
<span class="gi">+        inference_state, module_node,</span>
<span class="gi">+        file_io=file_io,</span>
<span class="gi">+        string_names=import_names,</span>
<span class="gi">+        code_lines=get_cached_code_lines(inference_state.grammar, file_io.path),</span>
<span class="gi">+        is_package=is_package,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_builtin_module(inference_state, import_names=None, sys_path=None):</span>
<span class="gi">+    project = inference_state.project</span>
<span class="gi">+    if sys_path is None:</span>
<span class="gi">+        sys_path = inference_state.get_sys_path()</span>
<span class="gi">+    if not project._load_unsafe_extensions:</span>
<span class="gi">+        safe_paths = project._get_base_sys_path(inference_state)</span>
<span class="gi">+        sys_path = [p for p in sys_path if p in safe_paths]</span>
<span class="gi">+</span>
<span class="gi">+    dotted_name = &#39;.&#39;.join(import_names)</span>
<span class="gi">+    assert dotted_name is not None</span>
<span class="gi">+    module = compiled.load_module(inference_state, dotted_name=dotted_name, sys_path=sys_path)</span>
<span class="gi">+    if module is None:</span>
<span class="gi">+        # The file might raise an ImportError e.g. and therefore not be</span>
<span class="gi">+        # importable.</span>
<span class="gi">+        return None</span>
<span class="gi">+    return module</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_module_from_path(inference_state, file_io, import_names=None, is_package=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This should pretty much only be used for get_modules_containing_name. It&#39;s
<span class="w"> </span>    here to ensure that a random path is still properly loaded into the Jedi
<span class="w"> </span>    module structure.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = Path(file_io.path)</span>
<span class="gi">+    if import_names is None:</span>
<span class="gi">+        e_sys_path = inference_state.get_sys_path()</span>
<span class="gi">+        import_names, is_package = sys_path.transform_path_to_dotted(e_sys_path, path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert isinstance(is_package, bool)</span>
<span class="gi">+</span>
<span class="gi">+    is_stub = path.suffix == &#39;.pyi&#39;</span>
<span class="gi">+    if is_stub:</span>
<span class="gi">+        folder_io = file_io.get_parent_folder()</span>
<span class="gi">+        if folder_io.path.endswith(&#39;-stubs&#39;):</span>
<span class="gi">+            folder_io = FolderIO(folder_io.path[:-6])</span>
<span class="gi">+        if path.name == &#39;__init__.pyi&#39;:</span>
<span class="gi">+            python_file_io = folder_io.get_file_io(&#39;__init__.py&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            python_file_io = folder_io.get_file_io(import_names[-1] + &#39;.py&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            v = load_module_from_path(</span>
<span class="gi">+                inference_state, python_file_io,</span>
<span class="gi">+                import_names, is_package=is_package</span>
<span class="gi">+            )</span>
<span class="gi">+            values = ValueSet([v])</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            values = NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        return create_stub_module(</span>
<span class="gi">+            inference_state, inference_state.latest_grammar, values,</span>
<span class="gi">+            parse_stub_module(inference_state, file_io), file_io, import_names</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        module = _load_python_module(</span>
<span class="gi">+            inference_state, file_io,</span>
<span class="gi">+            import_names=import_names,</span>
<span class="gi">+            is_package=is_package,</span>
<span class="gi">+        )</span>
<span class="gi">+        inference_state.module_cache.add(import_names, ValueSet([module]))</span>
<span class="gi">+        return module</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_namespace_from_path(inference_state, folder_io):</span>
<span class="gi">+    import_names, is_package = sys_path.transform_path_to_dotted(</span>
<span class="gi">+        inference_state.get_sys_path(),</span>
<span class="gi">+        Path(folder_io.path)</span>
<span class="gi">+    )</span>
<span class="gi">+    from jedi.inference.value.namespace import ImplicitNamespaceValue</span>
<span class="gi">+    return ImplicitNamespaceValue(inference_state, import_names, [folder_io.path])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def follow_error_node_imports_if_possible(context, name):</span>
<span class="gi">+    error_node = tree.search_ancestor(name, &#39;error_node&#39;)</span>
<span class="gi">+    if error_node is not None:</span>
<span class="gi">+        # Get the first command start of a started simple_stmt. The error</span>
<span class="gi">+        # node is sometimes a small_stmt and sometimes a simple_stmt. Check</span>
<span class="gi">+        # for ; leaves that start a new statements.</span>
<span class="gi">+        start_index = 0</span>
<span class="gi">+        for index, n in enumerate(error_node.children):</span>
<span class="gi">+            if n.start_pos &gt; name.start_pos:</span>
<span class="gi">+                break</span>
<span class="gi">+            if n == &#39;;&#39;:</span>
<span class="gi">+                start_index = index + 1</span>
<span class="gi">+        nodes = error_node.children[start_index:]</span>
<span class="gi">+        first_name = nodes[0].get_first_leaf().value</span>
<span class="gi">+</span>
<span class="gi">+        # Make it possible to infer stuff like `import foo.` or</span>
<span class="gi">+        # `from foo.bar`.</span>
<span class="gi">+        if first_name in (&#39;from&#39;, &#39;import&#39;):</span>
<span class="gi">+            is_import_from = first_name == &#39;from&#39;</span>
<span class="gi">+            level, names = helpers.parse_dotted_names(</span>
<span class="gi">+                nodes,</span>
<span class="gi">+                is_import_from=is_import_from,</span>
<span class="gi">+                until_node=name,</span>
<span class="gi">+            )</span>
<span class="gi">+            return Importer(</span>
<span class="gi">+                context.inference_state, names, context.get_root_context(), level).follow()</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def iter_module_names(inference_state, module_context, search_path,
<span class="gd">-    module_cls=ImportName, add_builtin_modules=True):</span>
<span class="gi">+                      module_cls=ImportName, add_builtin_modules=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the names of all modules in the search_path. This means file names
<span class="w"> </span>    and not names defined in the files.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # add builtin module names</span>
<span class="gi">+    if add_builtin_modules:</span>
<span class="gi">+        for name in inference_state.compiled_subprocess.get_builtin_module_names():</span>
<span class="gi">+            yield module_cls(module_context, name)</span>
<span class="gi">+</span>
<span class="gi">+    for name in inference_state.compiled_subprocess.iter_module_names(search_path):</span>
<span class="gi">+        yield module_cls(module_context, name)</span>
<span class="gh">diff --git a/jedi/inference/lazy_value.py b/jedi/inference/lazy_value.py</span>
<span class="gh">index 81192b15..b149f21e 100644</span>
<span class="gd">--- a/jedi/inference/lazy_value.py</span>
<span class="gi">+++ b/jedi/inference/lazy_value.py</span>
<span class="gu">@@ -3,7 +3,6 @@ from jedi.common import monkeypatch</span>


<span class="w"> </span>class AbstractLazyValue:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, data, min=1, max=1):
<span class="w"> </span>        self.data = data
<span class="w"> </span>        self.min = min
<span class="gu">@@ -12,28 +11,51 @@ class AbstractLazyValue:</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.data)

<span class="gi">+    def infer(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>

<span class="w"> </span>class LazyKnownValue(AbstractLazyValue):
<span class="w"> </span>    &quot;&quot;&quot;data is a Value.&quot;&quot;&quot;
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self.data])</span>


<span class="w"> </span>class LazyKnownValues(AbstractLazyValue):
<span class="w"> </span>    &quot;&quot;&quot;data is a ValueSet.&quot;&quot;&quot;
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return self.data</span>


<span class="w"> </span>class LazyUnknownValue(AbstractLazyValue):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, min=1, max=1):
<span class="w"> </span>        super().__init__(None, min, max)

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return NO_VALUES</span>

<span class="gd">-class LazyTreeValue(AbstractLazyValue):</span>

<span class="gi">+class LazyTreeValue(AbstractLazyValue):</span>
<span class="w"> </span>    def __init__(self, context, node, min=1, max=1):
<span class="w"> </span>        super().__init__(node, min, max)
<span class="w"> </span>        self.context = context
<span class="gi">+        # We need to save the predefined names. It&#39;s an unfortunate side effect</span>
<span class="gi">+        # that needs to be tracked otherwise results will be wrong.</span>
<span class="w"> </span>        self._predefined_names = dict(context.predefined_names)

<span class="gi">+    def infer(self):</span>
<span class="gi">+        with monkeypatch(self.context, &#39;predefined_names&#39;, self._predefined_names):</span>
<span class="gi">+            return self.context.infer_node(self.data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_merged_lazy_value(lazy_values):</span>
<span class="gi">+    if len(lazy_values) &gt; 1:</span>
<span class="gi">+        return MergedLazyValues(lazy_values)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return lazy_values[0]</span>
<span class="gi">+</span>

<span class="w"> </span>class MergedLazyValues(AbstractLazyValue):
<span class="w"> </span>    &quot;&quot;&quot;data is a list of lazy values.&quot;&quot;&quot;
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet.from_sets(l.infer() for l in self.data)</span>
<span class="gh">diff --git a/jedi/inference/names.py b/jedi/inference/names.py</span>
<span class="gh">index 3c2fd660..c3896923 100644</span>
<span class="gd">--- a/jedi/inference/names.py</span>
<span class="gi">+++ b/jedi/inference/names.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>from abc import abstractmethod
<span class="w"> </span>from inspect import Parameter
<span class="w"> </span>from typing import Optional, Tuple
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="gi">+</span>
<span class="w"> </span>from jedi.parser_utils import find_statement_documentation, clean_scope_docstring
<span class="w"> </span>from jedi.inference.utils import unite
<span class="w"> </span>from jedi.inference.base_value import ValueSet, NO_VALUES
<span class="gu">@@ -12,6 +14,17 @@ from jedi.inference.helpers import deep_ast_copy, infer_call_of_leaf</span>
<span class="w"> </span>from jedi.plugins import plugin_manager


<span class="gi">+def _merge_name_docs(names):</span>
<span class="gi">+    doc = &#39;&#39;</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        if doc:</span>
<span class="gi">+            # In case we have multiple values, just return all of them</span>
<span class="gi">+            # separated by a few dashes.</span>
<span class="gi">+            doc += &#39;\n&#39; + &#39;-&#39; * 30 + &#39;\n&#39;</span>
<span class="gi">+        doc += name.py__doc__()</span>
<span class="gi">+    return doc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class AbstractNameDefinition:
<span class="w"> </span>    start_pos: Optional[Tuple[int, int]] = None
<span class="w"> </span>    string_name: str
<span class="gu">@@ -22,19 +35,58 @@ class AbstractNameDefinition:</span>
<span class="w"> </span>    Used for the Jedi API to know if it&#39;s a keyword or an actual name.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def goto(self):</span>
<span class="gi">+        # Typically names are already definitions and therefore a goto on that</span>
<span class="gi">+        # name will always result on itself.</span>
<span class="gi">+        return {self}</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self, include_module_names=False):</span>
<span class="gi">+        qualified_names = self._get_qualified_names()</span>
<span class="gi">+        if qualified_names is None or not include_module_names:</span>
<span class="gi">+            return qualified_names</span>
<span class="gi">+</span>
<span class="gi">+        module_names = self.get_root_context().string_names</span>
<span class="gi">+        if module_names is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return module_names + qualified_names</span>
<span class="gi">+</span>
<span class="gi">+    def _get_qualified_names(self):</span>
<span class="gi">+        # By default, a name has no qualified names.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_root_context(self):</span>
<span class="gi">+        return self.parent_context.get_root_context()</span>
<span class="gi">+</span>
<span class="gi">+    def get_public_name(self):</span>
<span class="gi">+        return self.string_name</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.start_pos is None:
<span class="gd">-            return &#39;&lt;%s: string_name=%s&gt;&#39; % (self.__class__.__name__, self.</span>
<span class="gd">-                string_name)</span>
<span class="gd">-        return &#39;&lt;%s: string_name=%s start_pos=%s&gt;&#39; % (self.__class__.</span>
<span class="gd">-            __name__, self.string_name, self.start_pos)</span>
<span class="gi">+            return &#39;&lt;%s: string_name=%s&gt;&#39; % (self.__class__.__name__, self.string_name)</span>
<span class="gi">+        return &#39;&lt;%s: string_name=%s start_pos=%s&gt;&#39; % (self.__class__.__name__,</span>
<span class="gi">+                                                      self.string_name, self.start_pos)</span>
<span class="gi">+</span>
<span class="gi">+    def is_import(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        return self.parent_context.api_type</span>

<span class="w"> </span>    def get_defining_qualified_value(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns either None or the value that is public and qualified. Won&#39;t
<span class="w"> </span>        return a function, because a name in a function is never public.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class AbstractArbitraryName(AbstractNameDefinition):
<span class="gu">@@ -50,28 +102,194 @@ class AbstractArbitraryName(AbstractNameDefinition):</span>
<span class="w"> </span>        self.string_name = string
<span class="w"> </span>        self.parent_context = inference_state.builtins_module

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return NO_VALUES</span>

<span class="gd">-class AbstractTreeName(AbstractNameDefinition):</span>

<span class="gi">+class AbstractTreeName(AbstractNameDefinition):</span>
<span class="w"> </span>    def __init__(self, parent_context, tree_name):
<span class="w"> </span>        self.parent_context = parent_context
<span class="w"> </span>        self.tree_name = tree_name

<span class="gi">+    def get_qualified_names(self, include_module_names=False):</span>
<span class="gi">+        import_node = search_ancestor(self.tree_name, &#39;import_name&#39;, &#39;import_from&#39;)</span>
<span class="gi">+        # For import nodes we cannot just have names, because it&#39;s very unclear</span>
<span class="gi">+        # how they would look like. For now we just ignore them in most cases.</span>
<span class="gi">+        # In case of level == 1, it works always, because it&#39;s like a submodule</span>
<span class="gi">+        # lookup.</span>
<span class="gi">+        if import_node is not None and not (import_node.level == 1</span>
<span class="gi">+                                            and self.get_root_context().get_value().is_package()):</span>
<span class="gi">+            # TODO improve the situation for when level is present.</span>
<span class="gi">+            if include_module_names and not import_node.level:</span>
<span class="gi">+                return tuple(n.value for n in import_node.get_path_for_name(self.tree_name))</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        return super().get_qualified_names(include_module_names)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_qualified_names(self):</span>
<span class="gi">+        parent_names = self.parent_context.get_qualified_names()</span>
<span class="gi">+        if parent_names is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return parent_names + (self.tree_name.value,)</span>
<span class="gi">+</span>
<span class="gi">+    def get_defining_qualified_value(self):</span>
<span class="gi">+        if self.is_import():</span>
<span class="gi">+            raise NotImplementedError(&quot;Shouldn&#39;t really happen, please report&quot;)</span>
<span class="gi">+        elif self.parent_context:</span>
<span class="gi">+            return self.parent_context.get_value()  # Might be None</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def goto(self):</span>
<span class="gi">+        context = self.parent_context</span>
<span class="gi">+        name = self.tree_name</span>
<span class="gi">+        definition = name.get_definition(import_name_always=True)</span>
<span class="gi">+        if definition is not None:</span>
<span class="gi">+            type_ = definition.type</span>
<span class="gi">+            if type_ == &#39;expr_stmt&#39;:</span>
<span class="gi">+                # Only take the parent, because if it&#39;s more complicated than just</span>
<span class="gi">+                # a name it&#39;s something you can &quot;goto&quot; again.</span>
<span class="gi">+                is_simple_name = name.parent.type not in (&#39;power&#39;, &#39;trailer&#39;)</span>
<span class="gi">+                if is_simple_name:</span>
<span class="gi">+                    return [self]</span>
<span class="gi">+            elif type_ in (&#39;import_from&#39;, &#39;import_name&#39;):</span>
<span class="gi">+                from jedi.inference.imports import goto_import</span>
<span class="gi">+                module_names = goto_import(context, name)</span>
<span class="gi">+                return module_names</span>
<span class="gi">+            else:</span>
<span class="gi">+                return [self]</span>
<span class="gi">+        else:</span>
<span class="gi">+            from jedi.inference.imports import follow_error_node_imports_if_possible</span>
<span class="gi">+            values = follow_error_node_imports_if_possible(context, name)</span>
<span class="gi">+            if values is not None:</span>
<span class="gi">+                return [value.name for value in values]</span>
<span class="gi">+</span>
<span class="gi">+        par = name.parent</span>
<span class="gi">+        node_type = par.type</span>
<span class="gi">+        if node_type == &#39;argument&#39; and par.children[1] == &#39;=&#39; and par.children[0] == name:</span>
<span class="gi">+            # Named param goto.</span>
<span class="gi">+            trailer = par.parent</span>
<span class="gi">+            if trailer.type == &#39;arglist&#39;:</span>
<span class="gi">+                trailer = trailer.parent</span>
<span class="gi">+            if trailer.type != &#39;classdef&#39;:</span>
<span class="gi">+                if trailer.type == &#39;decorator&#39;:</span>
<span class="gi">+                    value_set = context.infer_node(trailer.children[1])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    i = trailer.parent.children.index(trailer)</span>
<span class="gi">+                    to_infer = trailer.parent.children[:i]</span>
<span class="gi">+                    if to_infer[0] == &#39;await&#39;:</span>
<span class="gi">+                        to_infer.pop(0)</span>
<span class="gi">+                    value_set = context.infer_node(to_infer[0])</span>
<span class="gi">+                    from jedi.inference.syntax_tree import infer_trailer</span>
<span class="gi">+                    for trailer in to_infer[1:]:</span>
<span class="gi">+                        value_set = infer_trailer(context, value_set, trailer)</span>
<span class="gi">+                param_names = []</span>
<span class="gi">+                for value in value_set:</span>
<span class="gi">+                    for signature in value.get_signatures():</span>
<span class="gi">+                        for param_name in signature.get_param_names():</span>
<span class="gi">+                            if param_name.string_name == name.value:</span>
<span class="gi">+                                param_names.append(param_name)</span>
<span class="gi">+                return param_names</span>
<span class="gi">+        elif node_type == &#39;dotted_name&#39;:  # Is a decorator.</span>
<span class="gi">+            index = par.children.index(name)</span>
<span class="gi">+            if index &gt; 0:</span>
<span class="gi">+                new_dotted = deep_ast_copy(par)</span>
<span class="gi">+                new_dotted.children[index - 1:] = []</span>
<span class="gi">+                values = context.infer_node(new_dotted)</span>
<span class="gi">+                return unite(</span>
<span class="gi">+                    value.goto(name, name_context=context)</span>
<span class="gi">+                    for value in values</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if node_type == &#39;trailer&#39; and par.children[0] == &#39;.&#39;:</span>
<span class="gi">+            values = infer_call_of_leaf(context, name, cut_own_trailer=True)</span>
<span class="gi">+            return values.goto(name, name_context=context)</span>
<span class="gi">+        else:</span>
<span class="gi">+            stmt = search_ancestor(</span>
<span class="gi">+                name, &#39;expr_stmt&#39;, &#39;lambdef&#39;</span>
<span class="gi">+            ) or name</span>
<span class="gi">+            if stmt.type == &#39;lambdef&#39;:</span>
<span class="gi">+                stmt = name</span>
<span class="gi">+            return context.goto(name, position=stmt.start_pos)</span>
<span class="gi">+</span>
<span class="gi">+    def is_import(self):</span>
<span class="gi">+        imp = search_ancestor(self.tree_name, &#39;import_from&#39;, &#39;import_name&#39;)</span>
<span class="gi">+        return imp is not None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def string_name(self):</span>
<span class="gi">+        return self.tree_name.value</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def start_pos(self):</span>
<span class="gi">+        return self.tree_name.start_pos</span>
<span class="gi">+</span>

<span class="w"> </span>class ValueNameMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self._value])</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        doc = self._value.py__doc__()</span>
<span class="gi">+        if not doc and self._value.is_stub():</span>
<span class="gi">+            from jedi.inference.gradual.conversion import convert_names</span>
<span class="gi">+            names = convert_names([self], prefer_stub_to_compiled=False)</span>
<span class="gi">+            if self not in names:</span>
<span class="gi">+                return _merge_name_docs(names)</span>
<span class="gi">+        return doc</span>
<span class="gi">+</span>
<span class="gi">+    def _get_qualified_names(self):</span>
<span class="gi">+        return self._value.get_qualified_names()</span>
<span class="gi">+</span>
<span class="gi">+    def get_root_context(self):</span>
<span class="gi">+        if self.parent_context is None:  # A module</span>
<span class="gi">+            return self._value.as_context()</span>
<span class="gi">+        return super().get_root_context()</span>

<span class="gi">+    def get_defining_qualified_value(self):</span>
<span class="gi">+        context = self.parent_context</span>
<span class="gi">+        if context is not None and (context.is_module() or context.is_class()):</span>
<span class="gi">+            return self.parent_context.get_value()  # Might be None</span>
<span class="gi">+        return None</span>

<span class="gd">-class ValueName(ValueNameMixin, AbstractTreeName):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        return self._value.api_type</span>

<span class="gi">+</span>
<span class="gi">+class ValueName(ValueNameMixin, AbstractTreeName):</span>
<span class="w"> </span>    def __init__(self, value, tree_name):
<span class="w"> </span>        super().__init__(value.parent_context, tree_name)
<span class="w"> </span>        self._value = value

<span class="gi">+    def goto(self):</span>
<span class="gi">+        return ValueSet([self._value.name])</span>
<span class="gi">+</span>

<span class="w"> </span>class TreeNameDefinition(AbstractTreeName):
<span class="gd">-    _API_TYPES = dict(import_name=&#39;module&#39;, import_from=&#39;module&#39;, funcdef=</span>
<span class="gd">-        &#39;function&#39;, param=&#39;param&#39;, classdef=&#39;class&#39;)</span>
<span class="gi">+    _API_TYPES = dict(</span>
<span class="gi">+        import_name=&#39;module&#39;,</span>
<span class="gi">+        import_from=&#39;module&#39;,</span>
<span class="gi">+        funcdef=&#39;function&#39;,</span>
<span class="gi">+        param=&#39;param&#39;,</span>
<span class="gi">+        classdef=&#39;class&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        # Refactor this, should probably be here.</span>
<span class="gi">+        from jedi.inference.syntax_tree import tree_name_to_values</span>
<span class="gi">+        return tree_name_to_values(</span>
<span class="gi">+            self.parent_context.inference_state,</span>
<span class="gi">+            self.parent_context,</span>
<span class="gi">+            self.tree_name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        definition = self.tree_name.get_definition(import_name_always=True)</span>
<span class="gi">+        if definition is None:</span>
<span class="gi">+            return &#39;statement&#39;</span>
<span class="gi">+        return self._API_TYPES.get(definition.type, &#39;statement&#39;)</span>

<span class="w"> </span>    def assignment_indexes(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -88,16 +306,94 @@ class TreeNameDefinition(AbstractTreeName):</span>

<span class="w"> </span>            [(slice(1, -1), abc_node)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indexes = []</span>
<span class="gi">+        is_star_expr = False</span>
<span class="gi">+        node = self.tree_name.parent</span>
<span class="gi">+        compare = self.tree_name</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            if node.type in (&#39;testlist&#39;, &#39;testlist_comp&#39;, &#39;testlist_star_expr&#39;, &#39;exprlist&#39;):</span>
<span class="gi">+                for i, child in enumerate(node.children):</span>
<span class="gi">+                    if child == compare:</span>
<span class="gi">+                        index = int(i / 2)</span>
<span class="gi">+                        if is_star_expr:</span>
<span class="gi">+                            from_end = int((len(node.children) - i) / 2)</span>
<span class="gi">+                            index = slice(index, -from_end)</span>
<span class="gi">+                        indexes.insert(0, (index, node))</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise LookupError(&quot;Couldn&#39;t find the assignment.&quot;)</span>
<span class="gi">+                is_star_expr = False</span>
<span class="gi">+            elif node.type == &#39;star_expr&#39;:</span>
<span class="gi">+                is_star_expr = True</span>
<span class="gi">+            elif node.type in (&#39;expr_stmt&#39;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            compare = node</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+        return indexes</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def inference_state(self):</span>
<span class="gi">+        # Used by the cache function below</span>
<span class="gi">+        return self.parent_context.inference_state</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=&#39;&#39;)</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        api_type = self.api_type</span>
<span class="gi">+        if api_type in (&#39;function&#39;, &#39;class&#39;, &#39;property&#39;):</span>
<span class="gi">+            if self.parent_context.get_root_context().is_stub():</span>
<span class="gi">+                from jedi.inference.gradual.conversion import convert_names</span>
<span class="gi">+                names = convert_names([self], prefer_stub_to_compiled=False)</span>
<span class="gi">+                if self not in names:</span>
<span class="gi">+                    return _merge_name_docs(names)</span>
<span class="gi">+</span>
<span class="gi">+            # Make sure the names are not TreeNameDefinitions anymore.</span>
<span class="gi">+            return clean_scope_docstring(self.tree_name.get_definition())</span>
<span class="gi">+</span>
<span class="gi">+        if api_type == &#39;module&#39;:</span>
<span class="gi">+            names = self.goto()</span>
<span class="gi">+            if self not in names:</span>
<span class="gi">+                return _merge_name_docs(names)</span>
<span class="gi">+</span>
<span class="gi">+        if api_type == &#39;statement&#39; and self.tree_name.is_definition():</span>
<span class="gi">+            return find_statement_documentation(self.tree_name.get_definition())</span>
<span class="gi">+        return &#39;&#39;</span>


<span class="w"> </span>class _ParamMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def maybe_positional_argument(self, include_star=True):</span>
<span class="gi">+        options = [Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD]</span>
<span class="gi">+        if include_star:</span>
<span class="gi">+            options.append(Parameter.VAR_POSITIONAL)</span>
<span class="gi">+        return self.get_kind() in options</span>
<span class="gi">+</span>
<span class="gi">+    def maybe_keyword_argument(self, include_stars=True):</span>
<span class="gi">+        options = [Parameter.KEYWORD_ONLY, Parameter.POSITIONAL_OR_KEYWORD]</span>
<span class="gi">+        if include_stars:</span>
<span class="gi">+            options.append(Parameter.VAR_KEYWORD)</span>
<span class="gi">+        return self.get_kind() in options</span>
<span class="gi">+</span>
<span class="gi">+    def _kind_string(self):</span>
<span class="gi">+        kind = self.get_kind()</span>
<span class="gi">+        if kind == Parameter.VAR_POSITIONAL:  # *args</span>
<span class="gi">+            return &#39;*&#39;</span>
<span class="gi">+        if kind == Parameter.VAR_KEYWORD:  # **kwargs</span>
<span class="gi">+            return &#39;**&#39;</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self, include_module_names=False):</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class ParamNameInterface(_ParamMixin):
<span class="w"> </span>    api_type = &#39;param&#39;

<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def to_string(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_executed_param_name(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For dealing with type inference and working around the graph, we
<span class="gu">@@ -107,34 +403,164 @@ class ParamNameInterface(_ParamMixin):</span>
<span class="w"> </span>        For now however it exists to avoid infering params when we don&#39;t really
<span class="w"> </span>        need them (e.g. when we can just instead use annotations.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def star_count(self):</span>
<span class="gi">+        kind = self.get_kind()</span>
<span class="gi">+        if kind == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        if kind == Parameter.VAR_KEYWORD:</span>
<span class="gi">+            return 2</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def infer_default(self):</span>
<span class="gi">+        return NO_VALUES</span>


<span class="w"> </span>class BaseTreeParamName(ParamNameInterface, AbstractTreeName):
<span class="w"> </span>    annotation_node = None
<span class="w"> </span>    default_node = None

<span class="gi">+    def to_string(self):</span>
<span class="gi">+        output = self._kind_string() + self.get_public_name()</span>
<span class="gi">+        annotation = self.annotation_node</span>
<span class="gi">+        default = self.default_node</span>
<span class="gi">+        if annotation is not None:</span>
<span class="gi">+            output += &#39;: &#39; + annotation.get_code(include_prefix=False)</span>
<span class="gi">+        if default is not None:</span>
<span class="gi">+            output += &#39;=&#39; + default.get_code(include_prefix=False)</span>
<span class="gi">+        return output</span>

<span class="gd">-class _ActualTreeParamName(BaseTreeParamName):</span>
<span class="gi">+    def get_public_name(self):</span>
<span class="gi">+        name = self.string_name</span>
<span class="gi">+        if name.startswith(&#39;__&#39;):</span>
<span class="gi">+            # Params starting with __ are an equivalent to positional only</span>
<span class="gi">+            # variables in typeshed.</span>
<span class="gi">+            name = name[2:]</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def goto(self, **kwargs):</span>
<span class="gi">+        return [self]</span>

<span class="gi">+</span>
<span class="gi">+class _ActualTreeParamName(BaseTreeParamName):</span>
<span class="w"> </span>    def __init__(self, function_value, tree_name):
<span class="gd">-        super().__init__(function_value.get_default_param_context(), tree_name)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            function_value.get_default_param_context(), tree_name)</span>
<span class="w"> </span>        self.function_value = function_value

<span class="gi">+    def _get_param_node(self):</span>
<span class="gi">+        return search_ancestor(self.tree_name, &#39;param&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def annotation_node(self):</span>
<span class="gi">+        return self._get_param_node().annotation</span>
<span class="gi">+</span>
<span class="gi">+    def infer_annotation(self, execute_annotation=True, ignore_stars=False):</span>
<span class="gi">+        from jedi.inference.gradual.annotation import infer_param</span>
<span class="gi">+        values = infer_param(</span>
<span class="gi">+            self.function_value, self._get_param_node(),</span>
<span class="gi">+            ignore_stars=ignore_stars)</span>
<span class="gi">+        if execute_annotation:</span>
<span class="gi">+            values = values.execute_annotation()</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def infer_default(self):</span>
<span class="gi">+        node = self.default_node</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        return self.parent_context.infer_node(node)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def default_node(self):</span>
<span class="gi">+        return self._get_param_node().default</span>
<span class="gi">+</span>
<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        tree_param = self._get_param_node()</span>
<span class="gi">+        if tree_param.star_count == 1:  # *args</span>
<span class="gi">+            return Parameter.VAR_POSITIONAL</span>
<span class="gi">+        if tree_param.star_count == 2:  # **kwargs</span>
<span class="gi">+            return Parameter.VAR_KEYWORD</span>
<span class="gi">+</span>
<span class="gi">+        # Params starting with __ are an equivalent to positional only</span>
<span class="gi">+        # variables in typeshed.</span>
<span class="gi">+        if tree_param.name.value.startswith(&#39;__&#39;):</span>
<span class="gi">+            return Parameter.POSITIONAL_ONLY</span>
<span class="gi">+</span>
<span class="gi">+        parent = tree_param.parent</span>
<span class="gi">+        param_appeared = False</span>
<span class="gi">+        for p in parent.children:</span>
<span class="gi">+            if param_appeared:</span>
<span class="gi">+                if p == &#39;/&#39;:</span>
<span class="gi">+                    return Parameter.POSITIONAL_ONLY</span>
<span class="gi">+            else:</span>
<span class="gi">+                if p == &#39;*&#39;:</span>
<span class="gi">+                    return Parameter.KEYWORD_ONLY</span>
<span class="gi">+                if p.type == &#39;param&#39;:</span>
<span class="gi">+                    if p.star_count:</span>
<span class="gi">+                        return Parameter.KEYWORD_ONLY</span>
<span class="gi">+                    if p == tree_param:</span>
<span class="gi">+                        param_appeared = True</span>
<span class="gi">+        return Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        values = self.infer_annotation()</span>
<span class="gi">+        if values:</span>
<span class="gi">+            return values</span>
<span class="gi">+</span>
<span class="gi">+        doc_params = docstrings.infer_param(self.function_value, self._get_param_node())</span>
<span class="gi">+        return doc_params</span>
<span class="gi">+</span>

<span class="w"> </span>class AnonymousParamName(_ActualTreeParamName):
<span class="gd">-    pass</span>
<span class="gi">+    @plugin_manager.decorate(name=&#39;goto_anonymous_param&#39;)</span>
<span class="gi">+    def goto(self):</span>
<span class="gi">+        return super().goto()</span>
<span class="gi">+</span>
<span class="gi">+    @plugin_manager.decorate(name=&#39;infer_anonymous_param&#39;)</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        values = super().infer()</span>
<span class="gi">+        if values:</span>
<span class="gi">+            return values</span>
<span class="gi">+        from jedi.inference.dynamic_params import dynamic_param_lookup</span>
<span class="gi">+        param = self._get_param_node()</span>
<span class="gi">+        values = dynamic_param_lookup(self.function_value, param.position_index)</span>
<span class="gi">+        if values:</span>
<span class="gi">+            return values</span>
<span class="gi">+</span>
<span class="gi">+        if param.star_count == 1:</span>
<span class="gi">+            from jedi.inference.value.iterable import FakeTuple</span>
<span class="gi">+            value = FakeTuple(self.function_value.inference_state, [])</span>
<span class="gi">+        elif param.star_count == 2:</span>
<span class="gi">+            from jedi.inference.value.iterable import FakeDict</span>
<span class="gi">+            value = FakeDict(self.function_value.inference_state, {})</span>
<span class="gi">+        elif param.default is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.function_value.parent_context.infer_node(param.default)</span>
<span class="gi">+        return ValueSet({value})</span>


<span class="w"> </span>class ParamName(_ActualTreeParamName):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, function_value, tree_name, arguments):
<span class="w"> </span>        super().__init__(function_value, tree_name)
<span class="w"> </span>        self.arguments = arguments

<span class="gi">+    def infer(self):</span>
<span class="gi">+        values = super().infer()</span>
<span class="gi">+        if values:</span>
<span class="gi">+            return values</span>

<span class="gd">-class ParamNameWrapper(_ParamMixin):</span>
<span class="gi">+        return self.get_executed_param_name().infer()</span>

<span class="gi">+    def get_executed_param_name(self):</span>
<span class="gi">+        from jedi.inference.param import get_executed_param_names</span>
<span class="gi">+        params_names = get_executed_param_names(self.function_value, self.arguments)</span>
<span class="gi">+        return params_names[self._get_param_node().position_index]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ParamNameWrapper(_ParamMixin):</span>
<span class="w"> </span>    def __init__(self, param_name):
<span class="w"> </span>        self._wrapped_param_name = param_name

<span class="gu">@@ -146,20 +572,56 @@ class ParamNameWrapper(_ParamMixin):</span>


<span class="w"> </span>class ImportName(AbstractNameDefinition):
<span class="gd">-    start_pos = 1, 0</span>
<span class="gi">+    start_pos = (1, 0)</span>
<span class="w"> </span>    _level = 0

<span class="w"> </span>    def __init__(self, parent_context, string_name):
<span class="w"> </span>        self._from_module_context = parent_context
<span class="w"> </span>        self.string_name = string_name

<span class="gi">+    def get_qualified_names(self, include_module_names=False):</span>
<span class="gi">+        if include_module_names:</span>
<span class="gi">+            if self._level:</span>
<span class="gi">+                assert self._level == 1, &quot;Everything else is not supported for now&quot;</span>
<span class="gi">+                module_names = self._from_module_context.string_names</span>
<span class="gi">+                if module_names is None:</span>
<span class="gi">+                    return module_names</span>
<span class="gi">+                return module_names + (self.string_name,)</span>
<span class="gi">+            return (self.string_name,)</span>
<span class="gi">+        return ()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def parent_context(self):</span>
<span class="gi">+        m = self._from_module_context</span>
<span class="gi">+        import_values = self.infer()</span>
<span class="gi">+        if not import_values:</span>
<span class="gi">+            return m</span>
<span class="gi">+        # It&#39;s almost always possible to find the import or to not find it. The</span>
<span class="gi">+        # importing returns only one value, pretty much always.</span>
<span class="gi">+        return next(iter(import_values)).as_context()</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        from jedi.inference.imports import Importer</span>
<span class="gi">+        m = self._from_module_context</span>
<span class="gi">+        return Importer(m.inference_state, [self.string_name], m, level=self._level).follow()</span>
<span class="gi">+</span>
<span class="gi">+    def goto(self):</span>
<span class="gi">+        return [m.name for m in self.infer()]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        return &#39;module&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return _merge_name_docs(self.goto())</span>
<span class="gi">+</span>

<span class="w"> </span>class SubModuleName(ImportName):
<span class="w"> </span>    _level = 1


<span class="w"> </span>class NameWrapper:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, wrapped_name):
<span class="w"> </span>        self._wrapped_name = wrapped_name

<span class="gu">@@ -171,11 +633,32 @@ class NameWrapper:</span>


<span class="w"> </span>class StubNameMixin:
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        from jedi.inference.gradual.conversion import convert_names</span>
<span class="gi">+        # Stubs are not complicated and we can just follow simple statements</span>
<span class="gi">+        # that have an equals in them, because they typically make something</span>
<span class="gi">+        # else public. See e.g. stubs for `requests`.</span>
<span class="gi">+        names = [self]</span>
<span class="gi">+        if self.api_type == &#39;statement&#39; and &#39;=&#39; in self.tree_name.get_definition().children:</span>
<span class="gi">+            names = [v.name for v in self.infer()]</span>
<span class="gi">+</span>
<span class="gi">+        names = convert_names(names, prefer_stub_to_compiled=False)</span>
<span class="gi">+        if self in names:</span>
<span class="gi">+            return super().py__doc__()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # We have signatures ourselves in stubs, so don&#39;t use signatures</span>
<span class="gi">+            # from the implementation.</span>
<span class="gi">+            return _merge_name_docs(names)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# From here on down we make looking up the sys.version_info fast.</span>
<span class="w"> </span>class StubName(StubNameMixin, TreeNameDefinition):
<span class="gd">-    pass</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        inferred = super().infer()</span>
<span class="gi">+        if self.string_name == &#39;version_info&#39; and self.get_root_context().py__name__() == &#39;sys&#39;:</span>
<span class="gi">+            from jedi.inference.gradual.stub_value import VersionInfo</span>
<span class="gi">+            return ValueSet(VersionInfo(c) for c in inferred)</span>
<span class="gi">+        return inferred</span>


<span class="w"> </span>class ModuleName(ValueNameMixin, AbstractNameDefinition):
<span class="gu">@@ -185,6 +668,10 @@ class ModuleName(ValueNameMixin, AbstractNameDefinition):</span>
<span class="w"> </span>        self._value = value
<span class="w"> </span>        self._name = name

<span class="gi">+    @property</span>
<span class="gi">+    def string_name(self):</span>
<span class="gi">+        return self._name</span>
<span class="gi">+</span>

<span class="w"> </span>class StubModuleName(StubNameMixin, ModuleName):
<span class="w"> </span>    pass
<span class="gh">diff --git a/jedi/inference/param.py b/jedi/inference/param.py</span>
<span class="gh">index 3880af71..1f296215 100644</span>
<span class="gd">--- a/jedi/inference/param.py</span>
<span class="gi">+++ b/jedi/inference/param.py</span>
<span class="gu">@@ -1,21 +1,50 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.utils import PushBackIterator
<span class="w"> </span>from jedi.inference import analysis
<span class="gd">-from jedi.inference.lazy_value import LazyKnownValue, LazyTreeValue, LazyUnknownValue</span>
<span class="gi">+from jedi.inference.lazy_value import LazyKnownValue, \</span>
<span class="gi">+    LazyTreeValue, LazyUnknownValue</span>
<span class="w"> </span>from jedi.inference.value import iterable
<span class="w"> </span>from jedi.inference.names import ParamName


<span class="gd">-class ExecutedParamName(ParamName):</span>
<span class="gi">+def _add_argument_issue(error_name, lazy_value, message):</span>
<span class="gi">+    if isinstance(lazy_value, LazyTreeValue):</span>
<span class="gi">+        node = lazy_value.data</span>
<span class="gi">+        if node.parent.type == &#39;argument&#39;:</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+        return analysis.add(lazy_value.context, error_name, node, message)</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, function_value, arguments, param_node, lazy_value,</span>
<span class="gd">-        is_default=False):</span>
<span class="gi">+class ExecutedParamName(ParamName):</span>
<span class="gi">+    def __init__(self, function_value, arguments, param_node, lazy_value, is_default=False):</span>
<span class="w"> </span>        super().__init__(function_value, param_node.name, arguments=arguments)
<span class="w"> </span>        self._lazy_value = lazy_value
<span class="w"> </span>        self._is_default = is_default

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return self._lazy_value.infer()</span>
<span class="gi">+</span>
<span class="gi">+    def matches_signature(self):</span>
<span class="gi">+        if self._is_default:</span>
<span class="gi">+            return True</span>
<span class="gi">+        argument_values = self.infer().py__class__()</span>
<span class="gi">+        if self.get_kind() in (Parameter.VAR_POSITIONAL, Parameter.VAR_KEYWORD):</span>
<span class="gi">+            return True</span>
<span class="gi">+        annotations = self.infer_annotation(execute_annotation=False)</span>
<span class="gi">+        if not annotations:</span>
<span class="gi">+            # If we cannot infer annotations - or there aren&#39;t any - pretend</span>
<span class="gi">+            # that the signature matches.</span>
<span class="gi">+            return True</span>
<span class="gi">+        matches = any(c1.is_sub_class_of(c2)</span>
<span class="gi">+                      for c1 in argument_values</span>
<span class="gi">+                      for c2 in annotations.gather_annotation_classes())</span>
<span class="gi">+        debug.dbg(&quot;param compare %s: %s &lt;=&gt; %s&quot;,</span>
<span class="gi">+                  matches, argument_values, annotations, color=&#39;BLUE&#39;)</span>
<span class="gi">+        return matches</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.string_name)

<span class="gu">@@ -40,7 +69,159 @@ def get_executed_param_names_and_issues(function_value, arguments):</span>
<span class="w"> </span>        c, &amp; d will have their values (42, &#39;c&#39; and &#39;d&#39; respectively) included.
<span class="w"> </span>      - a list with a single entry about the lack of a value for `b`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def too_many_args(argument):</span>
<span class="gi">+        m = _error_argument_count(funcdef, len(unpacked_va))</span>
<span class="gi">+        # Just report an error for the first param that is not needed (like</span>
<span class="gi">+        # cPython).</span>
<span class="gi">+        if arguments.get_calling_nodes():</span>
<span class="gi">+            # There might not be a valid calling node so check for that first.</span>
<span class="gi">+            issues.append(</span>
<span class="gi">+                _add_argument_issue(</span>
<span class="gi">+                    &#39;type-error-too-many-arguments&#39;,</span>
<span class="gi">+                    argument,</span>
<span class="gi">+                    message=m</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            issues.append(None)</span>
<span class="gi">+            debug.warning(&#39;non-public warning: %s&#39;, m)</span>
<span class="gi">+</span>
<span class="gi">+    issues = []  # List[Optional[analysis issue]]</span>
<span class="gi">+    result_params = []</span>
<span class="gi">+    param_dict = {}</span>
<span class="gi">+    funcdef = function_value.tree_node</span>
<span class="gi">+    # Default params are part of the value where the function was defined.</span>
<span class="gi">+    # This means that they might have access on class variables that the</span>
<span class="gi">+    # function itself doesn&#39;t have.</span>
<span class="gi">+    default_param_context = function_value.get_default_param_context()</span>
<span class="gi">+</span>
<span class="gi">+    for param in funcdef.get_params():</span>
<span class="gi">+        param_dict[param.name.value] = param</span>
<span class="gi">+    unpacked_va = list(arguments.unpack(funcdef))</span>
<span class="gi">+    var_arg_iterator = PushBackIterator(iter(unpacked_va))</span>
<span class="gi">+</span>
<span class="gi">+    non_matching_keys = defaultdict(lambda: [])</span>
<span class="gi">+    keys_used = {}</span>
<span class="gi">+    keys_only = False</span>
<span class="gi">+    had_multiple_value_error = False</span>
<span class="gi">+    for param in funcdef.get_params():</span>
<span class="gi">+        # The value and key can both be null. There, the defaults apply.</span>
<span class="gi">+        # args / kwargs will just be empty arrays / dicts, respectively.</span>
<span class="gi">+        # Wrong value count is just ignored. If you try to test cases that are</span>
<span class="gi">+        # not allowed in Python, Jedi will maybe not show any completions.</span>
<span class="gi">+        is_default = False</span>
<span class="gi">+        key, argument = next(var_arg_iterator, (None, None))</span>
<span class="gi">+        while key is not None:</span>
<span class="gi">+            keys_only = True</span>
<span class="gi">+            try:</span>
<span class="gi">+                key_param = param_dict[key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                non_matching_keys[key] = argument</span>
<span class="gi">+            else:</span>
<span class="gi">+                if key in keys_used:</span>
<span class="gi">+                    had_multiple_value_error = True</span>
<span class="gi">+                    m = (&quot;TypeError: %s() got multiple values for keyword argument &#39;%s&#39;.&quot;</span>
<span class="gi">+                         % (funcdef.name, key))</span>
<span class="gi">+                    for contextualized_node in arguments.get_calling_nodes():</span>
<span class="gi">+                        issues.append(</span>
<span class="gi">+                            analysis.add(contextualized_node.context,</span>
<span class="gi">+                                         &#39;type-error-multiple-values&#39;,</span>
<span class="gi">+                                         contextualized_node.node, message=m)</span>
<span class="gi">+                        )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    keys_used[key] = ExecutedParamName(</span>
<span class="gi">+                        function_value, arguments, key_param, argument)</span>
<span class="gi">+            key, argument = next(var_arg_iterator, (None, None))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            result_params.append(keys_used[param.name.value])</span>
<span class="gi">+            continue</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        if param.star_count == 1:</span>
<span class="gi">+            # *args param</span>
<span class="gi">+            lazy_value_list = []</span>
<span class="gi">+            if argument is not None:</span>
<span class="gi">+                lazy_value_list.append(argument)</span>
<span class="gi">+                for key, argument in var_arg_iterator:</span>
<span class="gi">+                    # Iterate until a key argument is found.</span>
<span class="gi">+                    if key:</span>
<span class="gi">+                        var_arg_iterator.push_back((key, argument))</span>
<span class="gi">+                        break</span>
<span class="gi">+                    lazy_value_list.append(argument)</span>
<span class="gi">+            seq = iterable.FakeTuple(function_value.inference_state, lazy_value_list)</span>
<span class="gi">+            result_arg = LazyKnownValue(seq)</span>
<span class="gi">+        elif param.star_count == 2:</span>
<span class="gi">+            if argument is not None:</span>
<span class="gi">+                too_many_args(argument)</span>
<span class="gi">+            # **kwargs param</span>
<span class="gi">+            dct = iterable.FakeDict(function_value.inference_state, dict(non_matching_keys))</span>
<span class="gi">+            result_arg = LazyKnownValue(dct)</span>
<span class="gi">+            non_matching_keys = {}</span>
<span class="gi">+        else:</span>
<span class="gi">+            # normal param</span>
<span class="gi">+            if argument is None:</span>
<span class="gi">+                # No value: Return an empty container</span>
<span class="gi">+                if param.default is None:</span>
<span class="gi">+                    result_arg = LazyUnknownValue()</span>
<span class="gi">+                    if not keys_only:</span>
<span class="gi">+                        for contextualized_node in arguments.get_calling_nodes():</span>
<span class="gi">+                            m = _error_argument_count(funcdef, len(unpacked_va))</span>
<span class="gi">+                            issues.append(</span>
<span class="gi">+                                analysis.add(</span>
<span class="gi">+                                    contextualized_node.context,</span>
<span class="gi">+                                    &#39;type-error-too-few-arguments&#39;,</span>
<span class="gi">+                                    contextualized_node.node,</span>
<span class="gi">+                                    message=m,</span>
<span class="gi">+                                )</span>
<span class="gi">+                            )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result_arg = LazyTreeValue(default_param_context, param.default)</span>
<span class="gi">+                    is_default = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                result_arg = argument</span>
<span class="gi">+</span>
<span class="gi">+        result_params.append(ExecutedParamName(</span>
<span class="gi">+            function_value, arguments, param, result_arg, is_default=is_default</span>
<span class="gi">+        ))</span>
<span class="gi">+        if not isinstance(result_arg, LazyUnknownValue):</span>
<span class="gi">+            keys_used[param.name.value] = result_params[-1]</span>
<span class="gi">+</span>
<span class="gi">+    if keys_only:</span>
<span class="gi">+        # All arguments should be handed over to the next function. It&#39;s not</span>
<span class="gi">+        # about the values inside, it&#39;s about the names. Jedi needs to now that</span>
<span class="gi">+        # there&#39;s nothing to find for certain names.</span>
<span class="gi">+        for k in set(param_dict) - set(keys_used):</span>
<span class="gi">+            param = param_dict[k]</span>
<span class="gi">+</span>
<span class="gi">+            if not (non_matching_keys or had_multiple_value_error</span>
<span class="gi">+                    or param.star_count or param.default):</span>
<span class="gi">+                # add a warning only if there&#39;s not another one.</span>
<span class="gi">+                for contextualized_node in arguments.get_calling_nodes():</span>
<span class="gi">+                    m = _error_argument_count(funcdef, len(unpacked_va))</span>
<span class="gi">+                    issues.append(</span>
<span class="gi">+                        analysis.add(contextualized_node.context,</span>
<span class="gi">+                                     &#39;type-error-too-few-arguments&#39;,</span>
<span class="gi">+                                     contextualized_node.node, message=m)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    for key, lazy_value in non_matching_keys.items():</span>
<span class="gi">+        m = &quot;TypeError: %s() got an unexpected keyword argument &#39;%s&#39;.&quot; \</span>
<span class="gi">+            % (funcdef.name, key)</span>
<span class="gi">+        issues.append(</span>
<span class="gi">+            _add_argument_issue(</span>
<span class="gi">+                &#39;type-error-keyword-argument&#39;,</span>
<span class="gi">+                lazy_value,</span>
<span class="gi">+                message=m</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    remaining_arguments = list(var_arg_iterator)</span>
<span class="gi">+    if remaining_arguments:</span>
<span class="gi">+        first_key, lazy_value = remaining_arguments[0]</span>
<span class="gi">+        too_many_args(lazy_value)</span>
<span class="gi">+    return result_params, issues</span>


<span class="w"> </span>def get_executed_param_names(function_value, arguments):
<span class="gu">@@ -61,4 +242,16 @@ def get_executed_param_names(function_value, arguments):</span>
<span class="w"> </span>    for each parameter a, b, c &amp; d; the entries for a, c, &amp; d will have their
<span class="w"> </span>    values (42, &#39;c&#39; and &#39;d&#39; respectively) included.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_executed_param_names_and_issues(function_value, arguments)[0]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _error_argument_count(funcdef, actual_count):</span>
<span class="gi">+    params = funcdef.get_params()</span>
<span class="gi">+    default_arguments = sum(1 for p in params if p.default or p.star_count)</span>
<span class="gi">+</span>
<span class="gi">+    if default_arguments == 0:</span>
<span class="gi">+        before = &#39;exactly &#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        before = &#39;from %s to &#39; % (len(params) - default_arguments)</span>
<span class="gi">+    return (&#39;TypeError: %s() takes %s%s arguments (%s given).&#39;</span>
<span class="gi">+            % (funcdef.name, before, len(params), actual_count))</span>
<span class="gh">diff --git a/jedi/inference/parser_cache.py b/jedi/inference/parser_cache.py</span>
<span class="gh">index 83db87aa..c9b9b2bd 100644</span>
<span class="gd">--- a/jedi/inference/parser_cache.py</span>
<span class="gi">+++ b/jedi/inference/parser_cache.py</span>
<span class="gu">@@ -1 +1,6 @@</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_function_cache
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_function_cache()</span>
<span class="gi">+def get_yield_exprs(inference_state, funcdef):</span>
<span class="gi">+    return list(funcdef.iter_yield_exprs())</span>
<span class="gh">diff --git a/jedi/inference/recursion.py b/jedi/inference/recursion.py</span>
<span class="gh">index 69b2848b..cc241873 100644</span>
<span class="gd">--- a/jedi/inference/recursion.py</span>
<span class="gi">+++ b/jedi/inference/recursion.py</span>
<span class="gu">@@ -25,9 +25,13 @@ therefore the quality might not always be maximal.</span>
<span class="w"> </span>.. autodata:: per_function_execution_limit
<span class="w"> </span>.. autodata:: per_function_recursion_limit
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.base_value import NO_VALUES
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>recursion_limit = 15
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Like :func:`sys.getrecursionlimit()`, just for |jedi|.
<span class="gu">@@ -47,7 +51,6 @@ A function may not be executed more than this number of times recursively.</span>


<span class="w"> </span>class RecursionDetector:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.pushed_nodes = []

<span class="gu">@@ -58,17 +61,93 @@ def execution_allowed(inference_state, node):</span>
<span class="w"> </span>    A decorator to detect recursions in statements. In a recursion a statement
<span class="w"> </span>    at the same place, in the same module may not be executed two times.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pushed_nodes = inference_state.recursion_detector.pushed_nodes</span>
<span class="gi">+</span>
<span class="gi">+    if node in pushed_nodes:</span>
<span class="gi">+        debug.warning(&#39;catched stmt recursion: %s @%s&#39;, node,</span>
<span class="gi">+                      getattr(node, &#39;start_pos&#39;, None))</span>
<span class="gi">+        yield False</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            pushed_nodes.append(node)</span>
<span class="gi">+            yield True</span>
<span class="gi">+        finally:</span>
<span class="gi">+            pushed_nodes.pop()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def execution_recursion_decorator(default=NO_VALUES):</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        def wrapper(self, **kwargs):</span>
<span class="gi">+            detector = self.inference_state.execution_recursion_detector</span>
<span class="gi">+            limit_reached = detector.push_execution(self)</span>
<span class="gi">+            try:</span>
<span class="gi">+                if limit_reached:</span>
<span class="gi">+                    result = default</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result = func(self, **kwargs)</span>
<span class="gi">+            finally:</span>
<span class="gi">+                detector.pop_execution()</span>
<span class="gi">+            return result</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>class ExecutionRecursionDetector:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Catches recursions of executions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state):
<span class="w"> </span>        self._inference_state = inference_state
<span class="gi">+</span>
<span class="w"> </span>        self._recursion_level = 0
<span class="w"> </span>        self._parent_execution_funcs = []
<span class="w"> </span>        self._funcdef_execution_counts = {}
<span class="w"> </span>        self._execution_count = 0
<span class="gi">+</span>
<span class="gi">+    def pop_execution(self):</span>
<span class="gi">+        self._parent_execution_funcs.pop()</span>
<span class="gi">+        self._recursion_level -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def push_execution(self, execution):</span>
<span class="gi">+        funcdef = execution.tree_node</span>
<span class="gi">+</span>
<span class="gi">+        # These two will be undone in pop_execution.</span>
<span class="gi">+        self._recursion_level += 1</span>
<span class="gi">+        self._parent_execution_funcs.append(funcdef)</span>
<span class="gi">+</span>
<span class="gi">+        module_context = execution.get_root_context()</span>
<span class="gi">+</span>
<span class="gi">+        if module_context.is_builtins_module():</span>
<span class="gi">+            # We have control over builtins so we know they are not recursing</span>
<span class="gi">+            # like crazy. Therefore we just let them execute always, because</span>
<span class="gi">+            # they usually just help a lot with getting good results.</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if self._recursion_level &gt; recursion_limit:</span>
<span class="gi">+            debug.warning(&#39;Recursion limit (%s) reached&#39;, recursion_limit)</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if self._execution_count &gt;= total_function_execution_limit:</span>
<span class="gi">+            debug.warning(&#39;Function execution limit (%s) reached&#39;, total_function_execution_limit)</span>
<span class="gi">+            return True</span>
<span class="gi">+        self._execution_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if self._funcdef_execution_counts.setdefault(funcdef, 0) &gt;= per_function_execution_limit:</span>
<span class="gi">+            if module_context.py__name__() == &#39;typing&#39;:</span>
<span class="gi">+                return False</span>
<span class="gi">+            debug.warning(</span>
<span class="gi">+                &#39;Per function execution limit (%s) reached: %s&#39;,</span>
<span class="gi">+                per_function_execution_limit,</span>
<span class="gi">+                funcdef</span>
<span class="gi">+            )</span>
<span class="gi">+            return True</span>
<span class="gi">+        self._funcdef_execution_counts[funcdef] += 1</span>
<span class="gi">+</span>
<span class="gi">+        if self._parent_execution_funcs.count(funcdef) &gt; per_function_recursion_limit:</span>
<span class="gi">+            debug.warning(</span>
<span class="gi">+                &#39;Per function recursion limit (%s) reached: %s&#39;,</span>
<span class="gi">+                per_function_recursion_limit,</span>
<span class="gi">+                funcdef</span>
<span class="gi">+            )</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/jedi/inference/references.py b/jedi/inference/references.py</span>
<span class="gh">index d77bb44e..d01890bd 100644</span>
<span class="gd">--- a/jedi/inference/references.py</span>
<span class="gi">+++ b/jedi/inference/references.py</span>
<span class="gu">@@ -1,13 +1,17 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from parso import python_bytes_to_unicode
<span class="gi">+</span>
<span class="w"> </span>from jedi.debug import dbg
<span class="w"> </span>from jedi.file_io import KnownContentFileIO, FolderIO
<span class="w"> </span>from jedi.inference.names import SubModuleName
<span class="w"> </span>from jedi.inference.imports import load_module_from_path
<span class="w"> </span>from jedi.inference.filters import ParserTreeFilter
<span class="w"> </span>from jedi.inference.gradual.conversion import convert_names
<span class="gd">-_IGNORE_FOLDERS = &#39;.tox&#39;, &#39;.venv&#39;, &#39;.mypy_cache&#39;, &#39;venv&#39;, &#39;__pycache__&#39;</span>
<span class="gi">+</span>
<span class="gi">+_IGNORE_FOLDERS = (&#39;.tox&#39;, &#39;.venv&#39;, &#39;.mypy_cache&#39;, &#39;venv&#39;, &#39;__pycache__&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>_OPENED_FILE_LIMIT = 2000
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Stats from a 2016 Lenovo Notebook running Linux:
<span class="gu">@@ -22,12 +26,294 @@ easily 100ms for bigger files.</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def get_module_contexts_containing_name(inference_state, module_contexts,</span>
<span class="gd">-    name, limit_reduction=1):</span>
<span class="gi">+def _resolve_names(definition_names, avoid_names=()):</span>
<span class="gi">+    for name in definition_names:</span>
<span class="gi">+        if name in avoid_names:</span>
<span class="gi">+            # Avoiding recursions here, because goto on a module name lands</span>
<span class="gi">+            # on the same module.</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(name, SubModuleName):</span>
<span class="gi">+            # SubModuleNames are not actually existing names but created</span>
<span class="gi">+            # names when importing something like `import foo.bar.baz`.</span>
<span class="gi">+            yield name</span>
<span class="gi">+</span>
<span class="gi">+        if name.api_type == &#39;module&#39;:</span>
<span class="gi">+            yield from _resolve_names(name.goto(), definition_names)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dictionarize(names):</span>
<span class="gi">+    return dict(</span>
<span class="gi">+        (n if n.tree_name is None else n.tree_name, n)</span>
<span class="gi">+        for n in names</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_defining_names(module_context, tree_name):</span>
<span class="gi">+    found_names = _find_names(module_context, tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    for name in list(found_names):</span>
<span class="gi">+        # Convert from/to stubs, because those might also be usages.</span>
<span class="gi">+        found_names |= set(convert_names(</span>
<span class="gi">+            [name],</span>
<span class="gi">+            only_stubs=not name.get_root_context().is_stub(),</span>
<span class="gi">+            prefer_stub_to_compiled=False</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    found_names |= set(_find_global_variables(found_names, tree_name.value))</span>
<span class="gi">+    for name in list(found_names):</span>
<span class="gi">+        if name.api_type == &#39;param&#39; or name.tree_name is None \</span>
<span class="gi">+                or name.tree_name.parent.type == &#39;trailer&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        found_names |= set(_add_names_in_same_context(name.parent_context, name.string_name))</span>
<span class="gi">+    return set(_resolve_names(found_names))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_names(module_context, tree_name):</span>
<span class="gi">+    name = module_context.create_name(tree_name)</span>
<span class="gi">+    found_names = set(name.goto())</span>
<span class="gi">+    found_names.add(name)</span>
<span class="gi">+</span>
<span class="gi">+    return set(_resolve_names(found_names))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_names_in_same_context(context, string_name):</span>
<span class="gi">+    if context.tree_node is None:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    until_position = None</span>
<span class="gi">+    while True:</span>
<span class="gi">+        filter_ = ParserTreeFilter(</span>
<span class="gi">+            parent_context=context,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+        )</span>
<span class="gi">+        names = set(filter_.get(string_name))</span>
<span class="gi">+        if not names:</span>
<span class="gi">+            break</span>
<span class="gi">+        yield from names</span>
<span class="gi">+        ordered = sorted(names, key=lambda x: x.start_pos)</span>
<span class="gi">+        until_position = ordered[0].start_pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_global_variables(names, search_name):</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        if name.tree_name is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        module_context = name.get_root_context()</span>
<span class="gi">+        try:</span>
<span class="gi">+            method = module_context.get_global_filter</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            for global_name in method().get(search_name):</span>
<span class="gi">+                yield global_name</span>
<span class="gi">+                c = module_context.create_context(global_name.tree_name)</span>
<span class="gi">+                yield from _add_names_in_same_context(c, global_name.string_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_references(module_context, tree_name, only_in_module=False):</span>
<span class="gi">+    inf = module_context.inference_state</span>
<span class="gi">+    search_name = tree_name.value</span>
<span class="gi">+</span>
<span class="gi">+    # We disable flow analysis, because if we have ifs that are only true in</span>
<span class="gi">+    # certain cases, we want both sides.</span>
<span class="gi">+    try:</span>
<span class="gi">+        inf.flow_analysis_enabled = False</span>
<span class="gi">+        found_names = _find_defining_names(module_context, tree_name)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        inf.flow_analysis_enabled = True</span>
<span class="gi">+</span>
<span class="gi">+    found_names_dct = _dictionarize(found_names)</span>
<span class="gi">+</span>
<span class="gi">+    module_contexts = [module_context]</span>
<span class="gi">+    if not only_in_module:</span>
<span class="gi">+        for m in set(d.get_root_context() for d in found_names):</span>
<span class="gi">+            if m != module_context and m.tree_node is not None \</span>
<span class="gi">+                    and inf.project.path in m.py__file__().parents:</span>
<span class="gi">+                module_contexts.append(m)</span>
<span class="gi">+    # For param no search for other modules is necessary.</span>
<span class="gi">+    if only_in_module or any(n.api_type == &#39;param&#39; for n in found_names):</span>
<span class="gi">+        potential_modules = module_contexts</span>
<span class="gi">+    else:</span>
<span class="gi">+        potential_modules = get_module_contexts_containing_name(</span>
<span class="gi">+            inf,</span>
<span class="gi">+            module_contexts,</span>
<span class="gi">+            search_name,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    non_matching_reference_maps = {}</span>
<span class="gi">+    for module_context in potential_modules:</span>
<span class="gi">+        for name_leaf in module_context.tree_node.get_used_names().get(search_name, []):</span>
<span class="gi">+            new = _dictionarize(_find_names(module_context, name_leaf))</span>
<span class="gi">+            if any(tree_name in found_names_dct for tree_name in new):</span>
<span class="gi">+                found_names_dct.update(new)</span>
<span class="gi">+                for tree_name in new:</span>
<span class="gi">+                    for dct in non_matching_reference_maps.get(tree_name, []):</span>
<span class="gi">+                        # A reference that was previously searched for matches</span>
<span class="gi">+                        # with a now found name. Merge.</span>
<span class="gi">+                        found_names_dct.update(dct)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        del non_matching_reference_maps[tree_name]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                for name in new:</span>
<span class="gi">+                    non_matching_reference_maps.setdefault(name, []).append(new)</span>
<span class="gi">+    result = found_names_dct.values()</span>
<span class="gi">+    if only_in_module:</span>
<span class="gi">+        return [n for n in result if n.get_root_context() == module_context]</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_fs(inference_state, file_io, regex):</span>
<span class="gi">+    try:</span>
<span class="gi">+        code = file_io.read()</span>
<span class="gi">+    except FileNotFoundError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    code = python_bytes_to_unicode(code, errors=&#39;replace&#39;)</span>
<span class="gi">+    if not regex.search(code):</span>
<span class="gi">+        return None</span>
<span class="gi">+    new_file_io = KnownContentFileIO(file_io.path, code)</span>
<span class="gi">+    m = load_module_from_path(inference_state, new_file_io)</span>
<span class="gi">+    if m.is_compiled():</span>
<span class="gi">+        return None</span>
<span class="gi">+    return m.as_context()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def gitignored_paths(folder_io, file_io):</span>
<span class="gi">+    ignored_paths_abs = set()</span>
<span class="gi">+    ignored_paths_rel = set()</span>
<span class="gi">+</span>
<span class="gi">+    for l in file_io.read().splitlines():</span>
<span class="gi">+        if not l or l.startswith(b&#39;#&#39;) or l.startswith(b&#39;!&#39;) or b&#39;*&#39; in l:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        p = l.decode(&#39;utf-8&#39;, &#39;ignore&#39;).rstrip(&#39;/&#39;)</span>
<span class="gi">+        if &#39;/&#39; in p:</span>
<span class="gi">+            name = p.lstrip(&#39;/&#39;)</span>
<span class="gi">+            ignored_paths_abs.add(os.path.join(folder_io.path, name))</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = p</span>
<span class="gi">+            ignored_paths_rel.add((folder_io.path, name))</span>
<span class="gi">+</span>
<span class="gi">+    return ignored_paths_abs, ignored_paths_rel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def expand_relative_ignore_paths(folder_io, relative_paths):</span>
<span class="gi">+    curr_path = folder_io.path</span>
<span class="gi">+    return {os.path.join(curr_path, p[1]) for p in relative_paths if curr_path.startswith(p[0])}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def recurse_find_python_folders_and_files(folder_io, except_paths=()):</span>
<span class="gi">+    except_paths = set(except_paths)</span>
<span class="gi">+    except_paths_relative = set()</span>
<span class="gi">+</span>
<span class="gi">+    for root_folder_io, folder_ios, file_ios in folder_io.walk():</span>
<span class="gi">+        # Delete folders that we don&#39;t want to iterate over.</span>
<span class="gi">+        for file_io in file_ios:</span>
<span class="gi">+            path = file_io.path</span>
<span class="gi">+            if path.suffix in (&#39;.py&#39;, &#39;.pyi&#39;):</span>
<span class="gi">+                if path not in except_paths:</span>
<span class="gi">+                    yield None, file_io</span>
<span class="gi">+</span>
<span class="gi">+            if path.name == &#39;.gitignore&#39;:</span>
<span class="gi">+                ignored_paths_abs, ignored_paths_rel = gitignored_paths(</span>
<span class="gi">+                    root_folder_io, file_io</span>
<span class="gi">+                )</span>
<span class="gi">+                except_paths |= ignored_paths_abs</span>
<span class="gi">+                except_paths_relative |= ignored_paths_rel</span>
<span class="gi">+</span>
<span class="gi">+        except_paths_relative_expanded = expand_relative_ignore_paths(</span>
<span class="gi">+            root_folder_io, except_paths_relative</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        folder_ios[:] = [</span>
<span class="gi">+            folder_io</span>
<span class="gi">+            for folder_io in folder_ios</span>
<span class="gi">+            if folder_io.path not in except_paths</span>
<span class="gi">+            and folder_io.path not in except_paths_relative_expanded</span>
<span class="gi">+            and folder_io.get_base_name() not in _IGNORE_FOLDERS</span>
<span class="gi">+        ]</span>
<span class="gi">+        for folder_io in folder_ios:</span>
<span class="gi">+            yield folder_io, None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def recurse_find_python_files(folder_io, except_paths=()):</span>
<span class="gi">+    for folder_io, file_io in recurse_find_python_folders_and_files(folder_io, except_paths):</span>
<span class="gi">+        if file_io is not None:</span>
<span class="gi">+            yield file_io</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_python_files_in_sys_path(inference_state, module_contexts):</span>
<span class="gi">+    sys_path = inference_state.get_sys_path()</span>
<span class="gi">+    except_paths = set()</span>
<span class="gi">+    yielded_paths = [m.py__file__() for m in module_contexts]</span>
<span class="gi">+    for module_context in module_contexts:</span>
<span class="gi">+        file_io = module_context.get_value().file_io</span>
<span class="gi">+        if file_io is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        folder_io = file_io.get_parent_folder()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            path = folder_io.path</span>
<span class="gi">+            if not any(path.startswith(p) for p in sys_path) or path in except_paths:</span>
<span class="gi">+                break</span>
<span class="gi">+            for file_io in recurse_find_python_files(folder_io, except_paths):</span>
<span class="gi">+                if file_io.path not in yielded_paths:</span>
<span class="gi">+                    yield file_io</span>
<span class="gi">+            except_paths.add(path)</span>
<span class="gi">+            folder_io = folder_io.get_parent_folder()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_project_modules(inference_state, module_contexts):</span>
<span class="gi">+    except_ = [m.py__file__() for m in module_contexts]</span>
<span class="gi">+    yield from recurse_find_python_files(FolderIO(inference_state.project.path), except_)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_module_contexts_containing_name(inference_state, module_contexts, name,</span>
<span class="gi">+                                        limit_reduction=1):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Search a name in the directories of modules.

<span class="w"> </span>    :param limit_reduction: Divides the limits on opening/parsing files by this
<span class="w"> </span>        factor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Skip non python modules</span>
<span class="gi">+    for module_context in module_contexts:</span>
<span class="gi">+        if module_context.is_compiled():</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield module_context</span>
<span class="gi">+</span>
<span class="gi">+    # Very short names are not searched in other modules for now to avoid lots</span>
<span class="gi">+    # of file lookups.</span>
<span class="gi">+    if len(name) &lt;= 2:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Currently not used, because there&#39;s only `scope=project` and `scope=file`</span>
<span class="gi">+    # At the moment there is no such thing as `scope=sys.path`.</span>
<span class="gi">+    # file_io_iterator = _find_python_files_in_sys_path(inference_state, module_contexts)</span>
<span class="gi">+    file_io_iterator = _find_project_modules(inference_state, module_contexts)</span>
<span class="gi">+    yield from search_in_file_ios(inference_state, file_io_iterator, name,</span>
<span class="gi">+                                  limit_reduction=limit_reduction)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def search_in_file_ios(inference_state, file_io_iterator, name,</span>
<span class="gi">+                       limit_reduction=1, complete=False):</span>
<span class="gi">+    parse_limit = _PARSED_FILE_LIMIT / limit_reduction</span>
<span class="gi">+    open_limit = _OPENED_FILE_LIMIT / limit_reduction</span>
<span class="gi">+    file_io_count = 0</span>
<span class="gi">+    parsed_file_count = 0</span>
<span class="gi">+    regex = re.compile(r&#39;\b&#39; + re.escape(name) + (r&#39;&#39; if complete else r&#39;\b&#39;))</span>
<span class="gi">+    for file_io in file_io_iterator:</span>
<span class="gi">+        file_io_count += 1</span>
<span class="gi">+        m = _check_fs(inference_state, file_io, regex)</span>
<span class="gi">+        if m is not None:</span>
<span class="gi">+            parsed_file_count += 1</span>
<span class="gi">+            yield m</span>
<span class="gi">+            if parsed_file_count &gt;= parse_limit:</span>
<span class="gi">+                dbg(&#39;Hit limit of parsed files: %s&#39;, parse_limit)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if file_io_count &gt;= open_limit:</span>
<span class="gi">+            dbg(&#39;Hit limit of opened files: %s&#39;, open_limit)</span>
<span class="gi">+            break</span>
<span class="gh">diff --git a/jedi/inference/signature.py b/jedi/inference/signature.py</span>
<span class="gh">index eb8704ba..565a269b 100644</span>
<span class="gd">--- a/jedi/inference/signature.py</span>
<span class="gi">+++ b/jedi/inference/signature.py</span>
<span class="gu">@@ -1,44 +1,150 @@</span>
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from jedi.cache import memoize_method
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import parser_utils


<span class="w"> </span>class _SignatureMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def to_string(self):</span>
<span class="gi">+        def param_strings():</span>
<span class="gi">+            is_positional = False</span>
<span class="gi">+            is_kw_only = False</span>
<span class="gi">+            for n in self.get_param_names(resolve_stars=True):</span>
<span class="gi">+                kind = n.get_kind()</span>
<span class="gi">+                is_positional |= kind == Parameter.POSITIONAL_ONLY</span>
<span class="gi">+                if is_positional and kind != Parameter.POSITIONAL_ONLY:</span>
<span class="gi">+                    yield &#39;/&#39;</span>
<span class="gi">+                    is_positional = False</span>
<span class="gi">+</span>
<span class="gi">+                if kind == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+                    is_kw_only = True</span>
<span class="gi">+                elif kind == Parameter.KEYWORD_ONLY and not is_kw_only:</span>
<span class="gi">+                    yield &#39;*&#39;</span>
<span class="gi">+                    is_kw_only = True</span>
<span class="gi">+</span>
<span class="gi">+                yield n.to_string()</span>
<span class="gi">+</span>
<span class="gi">+            if is_positional:</span>
<span class="gi">+                yield &#39;/&#39;</span>
<span class="gi">+</span>
<span class="gi">+        s = self.name.string_name + &#39;(&#39; + &#39;, &#39;.join(param_strings()) + &#39;)&#39;</span>
<span class="gi">+        annotation = self.annotation_string</span>
<span class="gi">+        if annotation:</span>
<span class="gi">+            s += &#39; -&gt; &#39; + annotation</span>
<span class="gi">+        return s</span>


<span class="w"> </span>class AbstractSignature(_SignatureMixin):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value, is_bound=False):
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.is_bound = is_bound

<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return self.value.name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def annotation_string(self):</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_names(self, resolve_stars=False):</span>
<span class="gi">+        param_names = self._function_value.get_param_names()</span>
<span class="gi">+        if self.is_bound:</span>
<span class="gi">+            return param_names[1:]</span>
<span class="gi">+        return param_names</span>
<span class="gi">+</span>
<span class="gi">+    def bind(self, value):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def matches_signature(self, arguments):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.value is self._function_value:
<span class="w"> </span>            return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.value)
<span class="gd">-        return &#39;&lt;%s: %s, %s&gt;&#39; % (self.__class__.__name__, self.value, self.</span>
<span class="gd">-            _function_value)</span>
<span class="gi">+        return &#39;&lt;%s: %s, %s&gt;&#39; % (self.__class__.__name__, self.value, self._function_value)</span>


<span class="w"> </span>class TreeSignature(AbstractSignature):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value, function_value=None, is_bound=False):
<span class="w"> </span>        super().__init__(value, is_bound)
<span class="w"> </span>        self._function_value = function_value or value

<span class="gi">+    def bind(self, value):</span>
<span class="gi">+        return TreeSignature(value, self._function_value, is_bound=True)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _annotation(self):</span>
<span class="gi">+        # Classes don&#39;t need annotations, even if __init__ has one. They always</span>
<span class="gi">+        # return themselves.</span>
<span class="gi">+        if self.value.is_class():</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self._function_value.tree_node.annotation</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def annotation_string(self):</span>
<span class="gi">+        a = self._annotation</span>
<span class="gi">+        if a is None:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        return a.get_code(include_prefix=False)</span>
<span class="gi">+</span>
<span class="gi">+    @memoize_method</span>
<span class="gi">+    def get_param_names(self, resolve_stars=False):</span>
<span class="gi">+        params = self._function_value.get_param_names()</span>
<span class="gi">+        if resolve_stars:</span>
<span class="gi">+            from jedi.inference.star_args import process_params</span>
<span class="gi">+            params = process_params(params)</span>
<span class="gi">+        if self.is_bound:</span>
<span class="gi">+            return params[1:]</span>
<span class="gi">+        return params</span>
<span class="gi">+</span>
<span class="gi">+    def matches_signature(self, arguments):</span>
<span class="gi">+        from jedi.inference.param import get_executed_param_names_and_issues</span>
<span class="gi">+        executed_param_names, issues = \</span>
<span class="gi">+            get_executed_param_names_and_issues(self._function_value, arguments)</span>
<span class="gi">+        if issues:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        matches = all(executed_param_name.matches_signature()</span>
<span class="gi">+                      for executed_param_name in executed_param_names)</span>
<span class="gi">+        if debug.enable_notice:</span>
<span class="gi">+            tree_node = self._function_value.tree_node</span>
<span class="gi">+            signature = parser_utils.get_signature(tree_node)</span>
<span class="gi">+            if matches:</span>
<span class="gi">+                debug.dbg(&quot;Overloading match: %s@%s (%s)&quot;,</span>
<span class="gi">+                          signature, tree_node.start_pos[0], arguments, color=&#39;BLUE&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                debug.dbg(&quot;Overloading no match: %s@%s (%s)&quot;,</span>
<span class="gi">+                          signature, tree_node.start_pos[0], arguments, color=&#39;BLUE&#39;)</span>
<span class="gi">+        return matches</span>

<span class="gd">-class BuiltinSignature(AbstractSignature):</span>

<span class="gd">-    def __init__(self, value, return_string, function_value=None, is_bound=</span>
<span class="gd">-        False):</span>
<span class="gi">+class BuiltinSignature(AbstractSignature):</span>
<span class="gi">+    def __init__(self, value, return_string, function_value=None, is_bound=False):</span>
<span class="w"> </span>        super().__init__(value, is_bound)
<span class="w"> </span>        self._return_string = return_string
<span class="w"> </span>        self.__function_value = function_value

<span class="gi">+    @property</span>
<span class="gi">+    def annotation_string(self):</span>
<span class="gi">+        return self._return_string</span>

<span class="gd">-class SignatureWrapper(_SignatureMixin):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _function_value(self):</span>
<span class="gi">+        if self.__function_value is None:</span>
<span class="gi">+            return self.value</span>
<span class="gi">+        return self.__function_value</span>

<span class="gi">+    def bind(self, value):</span>
<span class="gi">+        return BuiltinSignature(</span>
<span class="gi">+            value, self._return_string,</span>
<span class="gi">+            function_value=self.value,</span>
<span class="gi">+            is_bound=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class SignatureWrapper(_SignatureMixin):</span>
<span class="w"> </span>    def __init__(self, wrapped_signature):
<span class="w"> </span>        self._wrapped_signature = wrapped_signature

<span class="gh">diff --git a/jedi/inference/star_args.py b/jedi/inference/star_args.py</span>
<span class="gh">index 4000bc5a..71ea7093 100644</span>
<span class="gd">--- a/jedi/inference/star_args.py</span>
<span class="gi">+++ b/jedi/inference/star_args.py</span>
<span class="gu">@@ -11,14 +11,210 @@ This means for example in this case::</span>
<span class="w"> </span>The signature here for bar should be `bar(b, c)` instead of bar(*args).
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from parso import tree
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.utils import to_list
<span class="w"> </span>from jedi.inference.names import ParamNameWrapper
<span class="w"> </span>from jedi.inference.helpers import is_big_annoying_library


<span class="gd">-class ParamNameFixedKind(ParamNameWrapper):</span>
<span class="gi">+def _iter_nodes_for_param(param_name):</span>
<span class="gi">+    from parso.python.tree import search_ancestor</span>
<span class="gi">+    from jedi.inference.arguments import TreeArguments</span>
<span class="gi">+</span>
<span class="gi">+    execution_context = param_name.parent_context</span>
<span class="gi">+    # Walk up the parso tree to get the FunctionNode we want. We use the parso</span>
<span class="gi">+    # tree rather than going via the execution context so that we&#39;re agnostic of</span>
<span class="gi">+    # the specific scope we&#39;re evaluating within (i.e: module or function,</span>
<span class="gi">+    # etc.).</span>
<span class="gi">+    function_node = tree.search_ancestor(param_name.tree_name, &#39;funcdef&#39;, &#39;lambdef&#39;)</span>
<span class="gi">+    module_node = function_node.get_root_node()</span>
<span class="gi">+    start = function_node.children[-1].start_pos</span>
<span class="gi">+    end = function_node.children[-1].end_pos</span>
<span class="gi">+    for name in module_node.get_used_names().get(param_name.string_name):</span>
<span class="gi">+        if start &lt;= name.start_pos &lt; end:</span>
<span class="gi">+            # Is used in the function</span>
<span class="gi">+            argument = name.parent</span>
<span class="gi">+            if argument.type == &#39;argument&#39; \</span>
<span class="gi">+                    and argument.children[0] == &#39;*&#39; * param_name.star_count:</span>
<span class="gi">+                trailer = search_ancestor(argument, &#39;trailer&#39;)</span>
<span class="gi">+                if trailer is not None:  # Make sure we&#39;re in a function</span>
<span class="gi">+                    context = execution_context.create_context(trailer)</span>
<span class="gi">+                    if _goes_to_param_name(param_name, context, name):</span>
<span class="gi">+                        values = _to_callables(context, trailer)</span>
<span class="gi">+</span>
<span class="gi">+                        args = TreeArguments.create_cached(</span>
<span class="gi">+                            execution_context.inference_state,</span>
<span class="gi">+                            context=context,</span>
<span class="gi">+                            argument_node=trailer.children[1],</span>
<span class="gi">+                            trailer=trailer,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        for c in values:</span>
<span class="gi">+                            yield c, args</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _goes_to_param_name(param_name, context, potential_name):</span>
<span class="gi">+    if potential_name.type != &#39;name&#39;:</span>
<span class="gi">+        return False</span>
<span class="gi">+    from jedi.inference.names import TreeNameDefinition</span>
<span class="gi">+    found = TreeNameDefinition(context, potential_name).goto()</span>
<span class="gi">+    return any(param_name.parent_context == p.parent_context</span>
<span class="gi">+               and param_name.start_pos == p.start_pos</span>
<span class="gi">+               for p in found)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _to_callables(context, trailer):</span>
<span class="gi">+    from jedi.inference.syntax_tree import infer_trailer</span>
<span class="gi">+</span>
<span class="gi">+    atom_expr = trailer.parent</span>
<span class="gi">+    index = atom_expr.children[0] == &#39;await&#39;</span>
<span class="gi">+    # Infer atom first</span>
<span class="gi">+    values = context.infer_node(atom_expr.children[index])</span>
<span class="gi">+    for trailer2 in atom_expr.children[index + 1:]:</span>
<span class="gi">+        if trailer == trailer2:</span>
<span class="gi">+            break</span>
<span class="gi">+        values = infer_trailer(context, values, trailer2)</span>
<span class="gi">+    return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_given_params(arguments, param_names):</span>
<span class="gi">+    count = 0</span>
<span class="gi">+    used_keys = set()</span>
<span class="gi">+    for key, _ in arguments.unpack():</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            count += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            used_keys.add(key)</span>
<span class="gi">+</span>
<span class="gi">+    for p in param_names:</span>
<span class="gi">+        if count and p.maybe_positional_argument():</span>
<span class="gi">+            count -= 1</span>
<span class="gi">+            continue</span>
<span class="gi">+        if p.string_name in used_keys and p.maybe_keyword_argument():</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield p</span>
<span class="gi">+</span>

<span class="gi">+@to_list</span>
<span class="gi">+def process_params(param_names, star_count=3):  # default means both * and **</span>
<span class="gi">+    if param_names:</span>
<span class="gi">+        if is_big_annoying_library(param_names[0].parent_context):</span>
<span class="gi">+            # At first this feature can look innocent, but it does a lot of</span>
<span class="gi">+            # type inference in some cases, so we just ditch it.</span>
<span class="gi">+            yield from param_names</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    used_names = set()</span>
<span class="gi">+    arg_callables = []</span>
<span class="gi">+    kwarg_callables = []</span>
<span class="gi">+</span>
<span class="gi">+    kw_only_names = []</span>
<span class="gi">+    kwarg_names = []</span>
<span class="gi">+    arg_names = []</span>
<span class="gi">+    original_arg_name = None</span>
<span class="gi">+    original_kwarg_name = None</span>
<span class="gi">+    for p in param_names:</span>
<span class="gi">+        kind = p.get_kind()</span>
<span class="gi">+        if kind == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+            if star_count &amp; 1:</span>
<span class="gi">+                arg_callables = _iter_nodes_for_param(p)</span>
<span class="gi">+                original_arg_name = p</span>
<span class="gi">+        elif p.get_kind() == Parameter.VAR_KEYWORD:</span>
<span class="gi">+            if star_count &amp; 2:</span>
<span class="gi">+                kwarg_callables = list(_iter_nodes_for_param(p))</span>
<span class="gi">+                original_kwarg_name = p</span>
<span class="gi">+        elif kind == Parameter.KEYWORD_ONLY:</span>
<span class="gi">+            if star_count &amp; 2:</span>
<span class="gi">+                kw_only_names.append(p)</span>
<span class="gi">+        elif kind == Parameter.POSITIONAL_ONLY:</span>
<span class="gi">+            if star_count &amp; 1:</span>
<span class="gi">+                yield p</span>
<span class="gi">+        else:</span>
<span class="gi">+            if star_count == 1:</span>
<span class="gi">+                yield ParamNameFixedKind(p, Parameter.POSITIONAL_ONLY)</span>
<span class="gi">+            elif star_count == 2:</span>
<span class="gi">+                kw_only_names.append(ParamNameFixedKind(p, Parameter.KEYWORD_ONLY))</span>
<span class="gi">+            else:</span>
<span class="gi">+                used_names.add(p.string_name)</span>
<span class="gi">+                yield p</span>
<span class="gi">+</span>
<span class="gi">+    # First process *args</span>
<span class="gi">+    longest_param_names = ()</span>
<span class="gi">+    found_arg_signature = False</span>
<span class="gi">+    found_kwarg_signature = False</span>
<span class="gi">+    for func_and_argument in arg_callables:</span>
<span class="gi">+        func, arguments = func_and_argument</span>
<span class="gi">+        new_star_count = star_count</span>
<span class="gi">+        if func_and_argument in kwarg_callables:</span>
<span class="gi">+            kwarg_callables.remove(func_and_argument)</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_star_count = 1</span>
<span class="gi">+</span>
<span class="gi">+        for signature in func.get_signatures():</span>
<span class="gi">+            found_arg_signature = True</span>
<span class="gi">+            if new_star_count == 3:</span>
<span class="gi">+                found_kwarg_signature = True</span>
<span class="gi">+            args_for_this_func = []</span>
<span class="gi">+            for p in process_params(</span>
<span class="gi">+                    list(_remove_given_params(</span>
<span class="gi">+                        arguments,</span>
<span class="gi">+                        signature.get_param_names(resolve_stars=False)</span>
<span class="gi">+                    )), new_star_count):</span>
<span class="gi">+                if p.get_kind() == Parameter.VAR_KEYWORD:</span>
<span class="gi">+                    kwarg_names.append(p)</span>
<span class="gi">+                elif p.get_kind() == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+                    arg_names.append(p)</span>
<span class="gi">+                elif p.get_kind() == Parameter.KEYWORD_ONLY:</span>
<span class="gi">+                    kw_only_names.append(p)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    args_for_this_func.append(p)</span>
<span class="gi">+            if len(args_for_this_func) &gt; len(longest_param_names):</span>
<span class="gi">+                longest_param_names = args_for_this_func</span>
<span class="gi">+</span>
<span class="gi">+    for p in longest_param_names:</span>
<span class="gi">+        if star_count == 1 and p.get_kind() != Parameter.VAR_POSITIONAL:</span>
<span class="gi">+            yield ParamNameFixedKind(p, Parameter.POSITIONAL_ONLY)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if p.get_kind() == Parameter.POSITIONAL_OR_KEYWORD:</span>
<span class="gi">+                used_names.add(p.string_name)</span>
<span class="gi">+            yield p</span>
<span class="gi">+</span>
<span class="gi">+    if not found_arg_signature and original_arg_name is not None:</span>
<span class="gi">+        yield original_arg_name</span>
<span class="gi">+    elif arg_names:</span>
<span class="gi">+        yield arg_names[0]</span>
<span class="gi">+</span>
<span class="gi">+    # Then process **kwargs</span>
<span class="gi">+    for func, arguments in kwarg_callables:</span>
<span class="gi">+        for signature in func.get_signatures():</span>
<span class="gi">+            found_kwarg_signature = True</span>
<span class="gi">+            for p in process_params(</span>
<span class="gi">+                    list(_remove_given_params(</span>
<span class="gi">+                        arguments,</span>
<span class="gi">+                        signature.get_param_names(resolve_stars=False)</span>
<span class="gi">+                    )), star_count=2):</span>
<span class="gi">+                if p.get_kind() == Parameter.VAR_KEYWORD:</span>
<span class="gi">+                    kwarg_names.append(p)</span>
<span class="gi">+                elif p.get_kind() == Parameter.KEYWORD_ONLY:</span>
<span class="gi">+                    kw_only_names.append(p)</span>
<span class="gi">+</span>
<span class="gi">+    for p in kw_only_names:</span>
<span class="gi">+        if p.string_name in used_names:</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield p</span>
<span class="gi">+        used_names.add(p.string_name)</span>
<span class="gi">+</span>
<span class="gi">+    if not found_kwarg_signature and original_kwarg_name is not None:</span>
<span class="gi">+        yield original_kwarg_name</span>
<span class="gi">+    elif kwarg_names:</span>
<span class="gi">+        yield kwarg_names[0]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ParamNameFixedKind(ParamNameWrapper):</span>
<span class="w"> </span>    def __init__(self, param_name, new_kind):
<span class="w"> </span>        super().__init__(param_name)
<span class="w"> </span>        self._new_kind = new_kind
<span class="gi">+</span>
<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        return self._new_kind</span>
<span class="gh">diff --git a/jedi/inference/syntax_tree.py b/jedi/inference/syntax_tree.py</span>
<span class="gh">index 6868286f..2cd2a140 100644</span>
<span class="gd">--- a/jedi/inference/syntax_tree.py</span>
<span class="gi">+++ b/jedi/inference/syntax_tree.py</span>
<span class="gu">@@ -3,10 +3,13 @@ Functions inferring the syntax tree.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import copy
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>from parso.python import tree
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import parser_utils
<span class="gd">-from jedi.inference.base_value import ValueSet, NO_VALUES, ContextualizedNode, iterator_to_value_set, iterate_values</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, NO_VALUES, ContextualizedNode, \</span>
<span class="gi">+    iterator_to_value_set, iterate_values</span>
<span class="w"> </span>from jedi.inference.lazy_value import LazyTreeValue
<span class="w"> </span>from jedi.inference import compiled
<span class="w"> </span>from jedi.inference import recursion
<span class="gu">@@ -17,7 +20,8 @@ from jedi.inference.value import ClassValue, FunctionValue</span>
<span class="w"> </span>from jedi.inference.value import iterable
<span class="w"> </span>from jedi.inference.value.dynamic_arrays import ListModification, DictModification
<span class="w"> </span>from jedi.inference.value import TreeInstance
<span class="gd">-from jedi.inference.helpers import is_string, is_literal, is_number, get_names_of_node, is_big_annoying_library</span>
<span class="gi">+from jedi.inference.helpers import is_string, is_literal, is_number, \</span>
<span class="gi">+    get_names_of_node, is_big_annoying_library</span>
<span class="w"> </span>from jedi.inference.compiled.access import COMPARISON_OPERATORS
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.gradual.stub_value import VersionInfo
<span class="gu">@@ -26,12 +30,26 @@ from jedi.inference.names import TreeNameDefinition</span>
<span class="w"> </span>from jedi.inference.context import CompForContext
<span class="w"> </span>from jedi.inference.value.decorator import Decoratee
<span class="w"> </span>from jedi.plugins import plugin_manager
<span class="gd">-operator_to_magic_method = {&#39;+&#39;: &#39;__add__&#39;, &#39;-&#39;: &#39;__sub__&#39;, &#39;*&#39;: &#39;__mul__&#39;,</span>
<span class="gd">-    &#39;@&#39;: &#39;__matmul__&#39;, &#39;/&#39;: &#39;__truediv__&#39;, &#39;//&#39;: &#39;__floordiv__&#39;, &#39;%&#39;:</span>
<span class="gd">-    &#39;__mod__&#39;, &#39;**&#39;: &#39;__pow__&#39;, &#39;&lt;&lt;&#39;: &#39;__lshift__&#39;, &#39;&gt;&gt;&#39;: &#39;__rshift__&#39;, &#39;&amp;&#39;:</span>
<span class="gd">-    &#39;__and__&#39;, &#39;|&#39;: &#39;__or__&#39;, &#39;^&#39;: &#39;__xor__&#39;}</span>
<span class="gd">-reverse_operator_to_magic_method = {k: (&#39;__r&#39; + v[2:]) for k, v in</span>
<span class="gd">-    operator_to_magic_method.items()}</span>
<span class="gi">+</span>
<span class="gi">+operator_to_magic_method = {</span>
<span class="gi">+    &#39;+&#39;: &#39;__add__&#39;,</span>
<span class="gi">+    &#39;-&#39;: &#39;__sub__&#39;,</span>
<span class="gi">+    &#39;*&#39;: &#39;__mul__&#39;,</span>
<span class="gi">+    &#39;@&#39;: &#39;__matmul__&#39;,</span>
<span class="gi">+    &#39;/&#39;: &#39;__truediv__&#39;,</span>
<span class="gi">+    &#39;//&#39;: &#39;__floordiv__&#39;,</span>
<span class="gi">+    &#39;%&#39;: &#39;__mod__&#39;,</span>
<span class="gi">+    &#39;**&#39;: &#39;__pow__&#39;,</span>
<span class="gi">+    &#39;&lt;&lt;&#39;: &#39;__lshift__&#39;,</span>
<span class="gi">+    &#39;&gt;&gt;&#39;: &#39;__rshift__&#39;,</span>
<span class="gi">+    &#39;&amp;&#39;: &#39;__and__&#39;,</span>
<span class="gi">+    &#39;|&#39;: &#39;__or__&#39;,</span>
<span class="gi">+    &#39;^&#39;: &#39;__xor__&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+reverse_operator_to_magic_method = {</span>
<span class="gi">+    k: &#39;__r&#39; + v[2:] for k, v in operator_to_magic_method.items()</span>
<span class="gi">+}</span>


<span class="w"> </span>def _limit_value_infers(func):
<span class="gu">@@ -43,14 +61,222 @@ def _limit_value_infers(func):</span>
<span class="w"> </span>    I&#39;m still not sure this is the way to go, but it looks okay for now and we
<span class="w"> </span>    can still go anther way in the future. Tests are there. ~ dave
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(context, *args, **kwargs):</span>
<span class="gi">+        n = context.tree_node</span>
<span class="gi">+        inference_state = context.inference_state</span>
<span class="gi">+        try:</span>
<span class="gi">+            inference_state.inferred_element_counts[n] += 1</span>
<span class="gi">+            maximum = 300</span>
<span class="gi">+            if context.parent_context is None \</span>
<span class="gi">+                    and context.get_value() is inference_state.builtins_module:</span>
<span class="gi">+                # Builtins should have a more generous inference limit.</span>
<span class="gi">+                # It is important that builtins can be executed, otherwise some</span>
<span class="gi">+                # functions that depend on certain builtins features would be</span>
<span class="gi">+                # broken, see e.g. GH #1432</span>
<span class="gi">+                maximum *= 100</span>
<span class="gi">+</span>
<span class="gi">+            if inference_state.inferred_element_counts[n] &gt; maximum:</span>
<span class="gi">+                debug.warning(&#39;In value %s there were too many inferences.&#39;, n)</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            inference_state.inferred_element_counts[n] = 1</span>
<span class="gi">+        return func(context, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer_node(context, element):</span>
<span class="gi">+    if isinstance(context, CompForContext):</span>
<span class="gi">+        return _infer_node(context, element)</span>
<span class="gi">+</span>
<span class="gi">+    if_stmt = element</span>
<span class="gi">+    while if_stmt is not None:</span>
<span class="gi">+        if_stmt = if_stmt.parent</span>
<span class="gi">+        if if_stmt.type in (&#39;if_stmt&#39;, &#39;for_stmt&#39;):</span>
<span class="gi">+            break</span>
<span class="gi">+        if parser_utils.is_scope(if_stmt):</span>
<span class="gi">+            if_stmt = None</span>
<span class="gi">+            break</span>
<span class="gi">+    predefined_if_name_dict = context.predefined_names.get(if_stmt)</span>
<span class="gi">+    # TODO there&#39;s a lot of issues with this one. We actually should do</span>
<span class="gi">+    # this in a different way. Caching should only be active in certain</span>
<span class="gi">+    # cases and this all sucks.</span>
<span class="gi">+    if predefined_if_name_dict is None and if_stmt \</span>
<span class="gi">+            and if_stmt.type == &#39;if_stmt&#39; and context.inference_state.is_analysis:</span>
<span class="gi">+        if_stmt_test = if_stmt.children[1]</span>
<span class="gi">+        name_dicts = [{}]</span>
<span class="gi">+        # If we already did a check, we don&#39;t want to do it again -&gt; If</span>
<span class="gi">+        # value.predefined_names is filled, we stop.</span>
<span class="gi">+        # We don&#39;t want to check the if stmt itself, it&#39;s just about</span>
<span class="gi">+        # the content.</span>
<span class="gi">+        if element.start_pos &gt; if_stmt_test.end_pos:</span>
<span class="gi">+            # Now we need to check if the names in the if_stmt match the</span>
<span class="gi">+            # names in the suite.</span>
<span class="gi">+            if_names = get_names_of_node(if_stmt_test)</span>
<span class="gi">+            element_names = get_names_of_node(element)</span>
<span class="gi">+            str_element_names = [e.value for e in element_names]</span>
<span class="gi">+            if any(i.value in str_element_names for i in if_names):</span>
<span class="gi">+                for if_name in if_names:</span>
<span class="gi">+                    definitions = context.inference_state.infer(context, if_name)</span>
<span class="gi">+                    # Every name that has multiple different definitions</span>
<span class="gi">+                    # causes the complexity to rise. The complexity should</span>
<span class="gi">+                    # never fall below 1.</span>
<span class="gi">+                    if len(definitions) &gt; 1:</span>
<span class="gi">+                        if len(name_dicts) * len(definitions) &gt; 16:</span>
<span class="gi">+                            debug.dbg(&#39;Too many options for if branch inference %s.&#39;, if_stmt)</span>
<span class="gi">+                            # There&#39;s only a certain amount of branches</span>
<span class="gi">+                            # Jedi can infer, otherwise it will take to</span>
<span class="gi">+                            # long.</span>
<span class="gi">+                            name_dicts = [{}]</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                        original_name_dicts = list(name_dicts)</span>
<span class="gi">+                        name_dicts = []</span>
<span class="gi">+                        for definition in definitions:</span>
<span class="gi">+                            new_name_dicts = list(original_name_dicts)</span>
<span class="gi">+                            for i, name_dict in enumerate(new_name_dicts):</span>
<span class="gi">+                                new_name_dicts[i] = name_dict.copy()</span>
<span class="gi">+                                new_name_dicts[i][if_name.value] = ValueSet([definition])</span>
<span class="gi">+</span>
<span class="gi">+                            name_dicts += new_name_dicts</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        for name_dict in name_dicts:</span>
<span class="gi">+                            name_dict[if_name.value] = definitions</span>
<span class="gi">+        if len(name_dicts) &gt; 1:</span>
<span class="gi">+            result = NO_VALUES</span>
<span class="gi">+            for name_dict in name_dicts:</span>
<span class="gi">+                with context.predefine_names(if_stmt, name_dict):</span>
<span class="gi">+                    result |= _infer_node(context, element)</span>
<span class="gi">+            return result</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _infer_node_if_inferred(context, element)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if predefined_if_name_dict:</span>
<span class="gi">+            return _infer_node(context, element)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _infer_node_if_inferred(context, element)</span>


<span class="w"> </span>def _infer_node_if_inferred(context, element):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    TODO This function is temporary: Merge with infer_node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = element</span>
<span class="gi">+    while parent is not None:</span>
<span class="gi">+        parent = parent.parent</span>
<span class="gi">+        predefined_if_name_dict = context.predefined_names.get(parent)</span>
<span class="gi">+        if predefined_if_name_dict is not None:</span>
<span class="gi">+            return _infer_node(context, element)</span>
<span class="gi">+    return _infer_node_cached(context, element)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_method_cache(default=NO_VALUES)</span>
<span class="gi">+def _infer_node_cached(context, element):</span>
<span class="gi">+    return _infer_node(context, element)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@debug.increase_indent</span>
<span class="gi">+@_limit_value_infers</span>
<span class="gi">+def _infer_node(context, element):</span>
<span class="gi">+    debug.dbg(&#39;infer_node %s@%s in %s&#39;, element, element.start_pos, context)</span>
<span class="gi">+    inference_state = context.inference_state</span>
<span class="gi">+    typ = element.type</span>
<span class="gi">+    if typ in (&#39;name&#39;, &#39;number&#39;, &#39;string&#39;, &#39;atom&#39;, &#39;strings&#39;, &#39;keyword&#39;, &#39;fstring&#39;):</span>
<span class="gi">+        return infer_atom(context, element)</span>
<span class="gi">+    elif typ == &#39;lambdef&#39;:</span>
<span class="gi">+        return ValueSet([FunctionValue.from_context(context, element)])</span>
<span class="gi">+    elif typ == &#39;expr_stmt&#39;:</span>
<span class="gi">+        return infer_expr_stmt(context, element)</span>
<span class="gi">+    elif typ in (&#39;power&#39;, &#39;atom_expr&#39;):</span>
<span class="gi">+        first_child = element.children[0]</span>
<span class="gi">+        children = element.children[1:]</span>
<span class="gi">+        had_await = False</span>
<span class="gi">+        if first_child.type == &#39;keyword&#39; and first_child.value == &#39;await&#39;:</span>
<span class="gi">+            had_await = True</span>
<span class="gi">+            first_child = children.pop(0)</span>
<span class="gi">+</span>
<span class="gi">+        value_set = context.infer_node(first_child)</span>
<span class="gi">+        for (i, trailer) in enumerate(children):</span>
<span class="gi">+            if trailer == &#39;**&#39;:  # has a power operation.</span>
<span class="gi">+                right = context.infer_node(children[i + 1])</span>
<span class="gi">+                value_set = _infer_comparison(</span>
<span class="gi">+                    context,</span>
<span class="gi">+                    value_set,</span>
<span class="gi">+                    trailer,</span>
<span class="gi">+                    right</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+            value_set = infer_trailer(context, value_set, trailer)</span>
<span class="gi">+</span>
<span class="gi">+        if had_await:</span>
<span class="gi">+            return value_set.py__await__().py__stop_iteration_returns()</span>
<span class="gi">+        return value_set</span>
<span class="gi">+    elif typ in (&#39;testlist_star_expr&#39;, &#39;testlist&#39;,):</span>
<span class="gi">+        # The implicit tuple in statements.</span>
<span class="gi">+        return ValueSet([iterable.SequenceLiteralValue(inference_state, context, element)])</span>
<span class="gi">+    elif typ in (&#39;not_test&#39;, &#39;factor&#39;):</span>
<span class="gi">+        value_set = context.infer_node(element.children[-1])</span>
<span class="gi">+        for operator in element.children[:-1]:</span>
<span class="gi">+            value_set = infer_factor(value_set, operator)</span>
<span class="gi">+        return value_set</span>
<span class="gi">+    elif typ == &#39;test&#39;:</span>
<span class="gi">+        # `x if foo else y` case.</span>
<span class="gi">+        return (context.infer_node(element.children[0])</span>
<span class="gi">+                | context.infer_node(element.children[-1]))</span>
<span class="gi">+    elif typ == &#39;operator&#39;:</span>
<span class="gi">+        # Must be an ellipsis, other operators are not inferred.</span>
<span class="gi">+        if element.value != &#39;...&#39;:</span>
<span class="gi">+            origin = element.parent</span>
<span class="gi">+            raise AssertionError(&quot;unhandled operator %s in %s &quot; % (repr(element.value), origin))</span>
<span class="gi">+        return ValueSet([compiled.builtin_from_name(inference_state, &#39;Ellipsis&#39;)])</span>
<span class="gi">+    elif typ == &#39;dotted_name&#39;:</span>
<span class="gi">+        value_set = infer_atom(context, element.children[0])</span>
<span class="gi">+        for next_name in element.children[2::2]:</span>
<span class="gi">+            value_set = value_set.py__getattribute__(next_name, name_context=context)</span>
<span class="gi">+        return value_set</span>
<span class="gi">+    elif typ == &#39;eval_input&#39;:</span>
<span class="gi">+        return context.infer_node(element.children[0])</span>
<span class="gi">+    elif typ == &#39;annassign&#39;:</span>
<span class="gi">+        return annotation.infer_annotation(context, element.children[1]) \</span>
<span class="gi">+            .execute_annotation()</span>
<span class="gi">+    elif typ == &#39;yield_expr&#39;:</span>
<span class="gi">+        if len(element.children) and element.children[1].type == &#39;yield_arg&#39;:</span>
<span class="gi">+            # Implies that it&#39;s a yield from.</span>
<span class="gi">+            element = element.children[1].children[1]</span>
<span class="gi">+            generators = context.infer_node(element) \</span>
<span class="gi">+                .py__getattribute__(&#39;__iter__&#39;).execute_with_values()</span>
<span class="gi">+            return generators.py__stop_iteration_returns()</span>
<span class="gi">+</span>
<span class="gi">+        # Generator.send() is not implemented.</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+    elif typ == &#39;namedexpr_test&#39;:</span>
<span class="gi">+        return context.infer_node(element.children[2])</span>
<span class="gi">+    else:</span>
<span class="gi">+        return infer_or_test(context, element)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer_trailer(context, atom_values, trailer):</span>
<span class="gi">+    trailer_op, node = trailer.children[:2]</span>
<span class="gi">+    if node == &#39;)&#39;:  # `arglist` is optional.</span>
<span class="gi">+        node = None</span>
<span class="gi">+</span>
<span class="gi">+    if trailer_op == &#39;[&#39;:</span>
<span class="gi">+        trailer_op, node, _ = trailer.children</span>
<span class="gi">+        return atom_values.get_item(</span>
<span class="gi">+            _infer_subscript_list(context, node),</span>
<span class="gi">+            ContextualizedNode(context, trailer)</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        debug.dbg(&#39;infer_trailer: %s in %s&#39;, trailer, atom_values)</span>
<span class="gi">+        if trailer_op == &#39;.&#39;:</span>
<span class="gi">+            return atom_values.py__getattribute__(</span>
<span class="gi">+                name_context=context,</span>
<span class="gi">+                name_or_str=node</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert trailer_op == &#39;(&#39;, &#39;trailer_op is actually %s&#39; % trailer_op</span>
<span class="gi">+            args = arguments.TreeArguments(context.inference_state, context, node, trailer)</span>
<span class="gi">+            return atom_values.execute(args)</span>


<span class="w"> </span>def infer_atom(context, atom):
<span class="gu">@@ -59,7 +285,97 @@ def infer_atom(context, atom):</span>
<span class="w"> </span>    generate the node (because it has just one child). In that case an atom
<span class="w"> </span>    might be a name or a literal as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    state = context.inference_state</span>
<span class="gi">+    if atom.type == &#39;name&#39;:</span>
<span class="gi">+        # This is the first global lookup.</span>
<span class="gi">+        stmt = tree.search_ancestor(atom, &#39;expr_stmt&#39;, &#39;lambdef&#39;, &#39;if_stmt&#39;) or atom</span>
<span class="gi">+        if stmt.type == &#39;if_stmt&#39;:</span>
<span class="gi">+            if not any(n.start_pos &lt;= atom.start_pos &lt; n.end_pos for n in stmt.get_test_nodes()):</span>
<span class="gi">+                stmt = atom</span>
<span class="gi">+        elif stmt.type == &#39;lambdef&#39;:</span>
<span class="gi">+            stmt = atom</span>
<span class="gi">+        position = stmt.start_pos</span>
<span class="gi">+        if _is_annotation_name(atom):</span>
<span class="gi">+            # Since Python 3.7 (with from __future__ import annotations),</span>
<span class="gi">+            # annotations are essentially strings and can reference objects</span>
<span class="gi">+            # that are defined further down in code. Therefore just set the</span>
<span class="gi">+            # position to None, so the finder will not try to stop at a certain</span>
<span class="gi">+            # position in the module.</span>
<span class="gi">+            position = None</span>
<span class="gi">+        return context.py__getattribute__(atom, position=position)</span>
<span class="gi">+    elif atom.type == &#39;keyword&#39;:</span>
<span class="gi">+        # For False/True/None</span>
<span class="gi">+        if atom.value in (&#39;False&#39;, &#39;True&#39;, &#39;None&#39;):</span>
<span class="gi">+            return ValueSet([compiled.builtin_from_name(state, atom.value)])</span>
<span class="gi">+        elif atom.value == &#39;yield&#39;:</span>
<span class="gi">+            # Contrary to yield from, yield can just appear alone to return a</span>
<span class="gi">+            # value when used with `.send()`.</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        assert False, &#39;Cannot infer the keyword %s&#39; % atom</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(atom, tree.Literal):</span>
<span class="gi">+        string = state.compiled_subprocess.safe_literal_eval(atom.value)</span>
<span class="gi">+        return ValueSet([compiled.create_simple_object(state, string)])</span>
<span class="gi">+    elif atom.type == &#39;strings&#39;:</span>
<span class="gi">+        # Will be multiple string.</span>
<span class="gi">+        value_set = infer_atom(context, atom.children[0])</span>
<span class="gi">+        for string in atom.children[1:]:</span>
<span class="gi">+            right = infer_atom(context, string)</span>
<span class="gi">+            value_set = _infer_comparison(context, value_set, &#39;+&#39;, right)</span>
<span class="gi">+        return value_set</span>
<span class="gi">+    elif atom.type == &#39;fstring&#39;:</span>
<span class="gi">+        return compiled.get_string_value_set(state)</span>
<span class="gi">+    else:</span>
<span class="gi">+        c = atom.children</span>
<span class="gi">+        # Parentheses without commas are not tuples.</span>
<span class="gi">+        if c[0] == &#39;(&#39; and not len(c) == 2 \</span>
<span class="gi">+                and not (c[1].type == &#39;testlist_comp&#39;</span>
<span class="gi">+                         and len(c[1].children) &gt; 1):</span>
<span class="gi">+            return context.infer_node(c[1])</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            comp_for = c[1].children[1]</span>
<span class="gi">+        except (IndexError, AttributeError):</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if comp_for == &#39;:&#39;:</span>
<span class="gi">+                # Dict comprehensions have a colon at the 3rd index.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    comp_for = c[1].children[3]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+            if comp_for.type in (&#39;comp_for&#39;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+                return ValueSet([iterable.comprehension_from_atom(</span>
<span class="gi">+                    state, context, atom</span>
<span class="gi">+                )])</span>
<span class="gi">+</span>
<span class="gi">+        # It&#39;s a dict/list/tuple literal.</span>
<span class="gi">+        array_node = c[1]</span>
<span class="gi">+        try:</span>
<span class="gi">+            array_node_c = array_node.children</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            array_node_c = []</span>
<span class="gi">+        if c[0] == &#39;{&#39; and (array_node == &#39;}&#39; or &#39;:&#39; in array_node_c</span>
<span class="gi">+                            or &#39;**&#39; in array_node_c):</span>
<span class="gi">+            new_value = iterable.DictLiteralValue(state, context, atom)</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_value = iterable.SequenceLiteralValue(state, context, atom)</span>
<span class="gi">+        return ValueSet([new_value])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@_limit_value_infers</span>
<span class="gi">+def infer_expr_stmt(context, stmt, seek_name=None):</span>
<span class="gi">+    with recursion.execution_allowed(context.inference_state, stmt) as allowed:</span>
<span class="gi">+        if allowed:</span>
<span class="gi">+            if seek_name is not None:</span>
<span class="gi">+                pep0484_values = \</span>
<span class="gi">+                    annotation.find_type_from_comment_hint_assign(context, stmt, seek_name)</span>
<span class="gi">+                if pep0484_values:</span>
<span class="gi">+                    return pep0484_values</span>
<span class="gi">+</span>
<span class="gi">+            return _infer_expr_stmt(context, stmt, seek_name)</span>
<span class="gi">+    return NO_VALUES</span>


<span class="w"> </span>@debug.increase_indent
<span class="gu">@@ -78,7 +394,91 @@ def _infer_expr_stmt(context, stmt, seek_name=None):</span>

<span class="w"> </span>    :param stmt: A `tree.ExprStmt`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def check_setitem(stmt):</span>
<span class="gi">+        atom_expr = stmt.children[0]</span>
<span class="gi">+        if atom_expr.type not in (&#39;atom_expr&#39;, &#39;power&#39;):</span>
<span class="gi">+            return False, None</span>
<span class="gi">+        name = atom_expr.children[0]</span>
<span class="gi">+        if name.type != &#39;name&#39; or len(atom_expr.children) != 2:</span>
<span class="gi">+            return False, None</span>
<span class="gi">+        trailer = atom_expr.children[-1]</span>
<span class="gi">+        return trailer.children[0] == &#39;[&#39;, trailer.children[1]</span>
<span class="gi">+</span>
<span class="gi">+    debug.dbg(&#39;infer_expr_stmt %s (%s)&#39;, stmt, seek_name)</span>
<span class="gi">+    rhs = stmt.get_rhs()</span>
<span class="gi">+</span>
<span class="gi">+    value_set = context.infer_node(rhs)</span>
<span class="gi">+</span>
<span class="gi">+    if seek_name:</span>
<span class="gi">+        n = TreeNameDefinition(context, seek_name)</span>
<span class="gi">+        value_set = check_tuple_assignments(n, value_set)</span>
<span class="gi">+</span>
<span class="gi">+    first_operator = next(stmt.yield_operators(), None)</span>
<span class="gi">+    is_setitem, subscriptlist = check_setitem(stmt)</span>
<span class="gi">+    is_annassign = first_operator not in (&#39;=&#39;, None) and first_operator.type == &#39;operator&#39;</span>
<span class="gi">+    if is_annassign or is_setitem:</span>
<span class="gi">+        # `=` is always the last character in aug assignments -&gt; -1</span>
<span class="gi">+        name = stmt.get_defined_names(include_setitem=True)[0].value</span>
<span class="gi">+        left_values = context.py__getattribute__(name, position=stmt.start_pos)</span>
<span class="gi">+</span>
<span class="gi">+        if is_setitem:</span>
<span class="gi">+            def to_mod(v):</span>
<span class="gi">+                c = ContextualizedSubscriptListNode(context, subscriptlist)</span>
<span class="gi">+                if v.array_type == &#39;dict&#39;:</span>
<span class="gi">+                    return DictModification(v, value_set, c)</span>
<span class="gi">+                elif v.array_type == &#39;list&#39;:</span>
<span class="gi">+                    return ListModification(v, value_set, c)</span>
<span class="gi">+                return v</span>
<span class="gi">+</span>
<span class="gi">+            value_set = ValueSet(to_mod(v) for v in left_values)</span>
<span class="gi">+        else:</span>
<span class="gi">+            operator = copy.copy(first_operator)</span>
<span class="gi">+            operator.value = operator.value[:-1]</span>
<span class="gi">+            for_stmt = tree.search_ancestor(stmt, &#39;for_stmt&#39;)</span>
<span class="gi">+            if for_stmt is not None and for_stmt.type == &#39;for_stmt&#39; and value_set \</span>
<span class="gi">+                    and parser_utils.for_stmt_defines_one_name(for_stmt):</span>
<span class="gi">+                # Iterate through result and add the values, that&#39;s possible</span>
<span class="gi">+                # only in for loops without clutter, because they are</span>
<span class="gi">+                # predictable. Also only do it, if the variable is not a tuple.</span>
<span class="gi">+                node = for_stmt.get_testlist()</span>
<span class="gi">+                cn = ContextualizedNode(context, node)</span>
<span class="gi">+                ordered = list(cn.infer().iterate(cn))</span>
<span class="gi">+</span>
<span class="gi">+                for lazy_value in ordered:</span>
<span class="gi">+                    dct = {for_stmt.children[1].value: lazy_value.infer()}</span>
<span class="gi">+                    with context.predefine_names(for_stmt, dct):</span>
<span class="gi">+                        t = context.infer_node(rhs)</span>
<span class="gi">+                        left_values = _infer_comparison(context, left_values, operator, t)</span>
<span class="gi">+                value_set = left_values</span>
<span class="gi">+            else:</span>
<span class="gi">+                value_set = _infer_comparison(context, left_values, operator, value_set)</span>
<span class="gi">+    debug.dbg(&#39;infer_expr_stmt result %s&#39;, value_set)</span>
<span class="gi">+    return value_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer_or_test(context, or_test):</span>
<span class="gi">+    iterator = iter(or_test.children)</span>
<span class="gi">+    types = context.infer_node(next(iterator))</span>
<span class="gi">+    for operator in iterator:</span>
<span class="gi">+        right = next(iterator)</span>
<span class="gi">+        if operator.type == &#39;comp_op&#39;:  # not in / is not</span>
<span class="gi">+            operator = &#39; &#39;.join(c.value for c in operator.children)</span>
<span class="gi">+</span>
<span class="gi">+        # handle type inference of and/or here.</span>
<span class="gi">+        if operator in (&#39;and&#39;, &#39;or&#39;):</span>
<span class="gi">+            left_bools = set(left.py__bool__() for left in types)</span>
<span class="gi">+            if left_bools == {True}:</span>
<span class="gi">+                if operator == &#39;and&#39;:</span>
<span class="gi">+                    types = context.infer_node(right)</span>
<span class="gi">+            elif left_bools == {False}:</span>
<span class="gi">+                if operator != &#39;and&#39;:</span>
<span class="gi">+                    types = context.infer_node(right)</span>
<span class="gi">+            # Otherwise continue, because of uncertainty.</span>
<span class="gi">+        else:</span>
<span class="gi">+            types = _infer_comparison(context, types, operator,</span>
<span class="gi">+                                      context.infer_node(right))</span>
<span class="gi">+    debug.dbg(&#39;infer_or_test types %s&#39;, types)</span>
<span class="gi">+    return types</span>


<span class="w"> </span>@iterator_to_value_set
<span class="gu">@@ -86,31 +486,409 @@ def infer_factor(value_set, operator):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Calculates `+`, `-`, `~` and `not` prefixes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for value in value_set:</span>
<span class="gi">+        if operator == &#39;-&#39;:</span>
<span class="gi">+            if is_number(value):</span>
<span class="gi">+                yield value.negate()</span>
<span class="gi">+        elif operator == &#39;not&#39;:</span>
<span class="gi">+            b = value.py__bool__()</span>
<span class="gi">+            if b is None:  # Uncertainty.</span>
<span class="gi">+                return</span>
<span class="gi">+            yield compiled.create_simple_object(value.inference_state, not b)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield value</span>
<span class="gi">+</span>

<span class="gi">+def _literals_to_types(inference_state, result):</span>
<span class="gi">+    # Changes literals (&#39;a&#39;, 1, 1.0, etc) to its type instances (str(),</span>
<span class="gi">+    # int(), float(), etc).</span>
<span class="gi">+    new_result = NO_VALUES</span>
<span class="gi">+    for typ in result:</span>
<span class="gi">+        if is_literal(typ):</span>
<span class="gi">+            # Literals are only valid as long as the operations are</span>
<span class="gi">+            # correct. Otherwise add a value-free instance.</span>
<span class="gi">+            cls = compiled.builtin_from_name(inference_state, typ.name.string_name)</span>
<span class="gi">+            new_result |= cls.execute_with_values()</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_result |= ValueSet([typ])</span>
<span class="gi">+    return new_result</span>

<span class="gi">+</span>
<span class="gi">+def _infer_comparison(context, left_values, operator, right_values):</span>
<span class="gi">+    state = context.inference_state</span>
<span class="gi">+    if isinstance(operator, str):</span>
<span class="gi">+        operator_str = operator</span>
<span class="gi">+    else:</span>
<span class="gi">+        operator_str = str(operator.value)</span>
<span class="gi">+    if not left_values or not right_values:</span>
<span class="gi">+        # illegal slices e.g. cause left/right_result to be None</span>
<span class="gi">+        result = (left_values or NO_VALUES) | (right_values or NO_VALUES)</span>
<span class="gi">+        return _literals_to_types(state, result)</span>
<span class="gi">+    elif operator_str == &quot;|&quot; and all(</span>
<span class="gi">+        value.is_class() or value.is_compiled()</span>
<span class="gi">+        for value in itertools.chain(left_values, right_values)</span>
<span class="gi">+    ):</span>
<span class="gi">+        # ^^^ A naive hack for PEP 604</span>
<span class="gi">+        return ValueSet.from_sets((left_values, right_values))</span>
<span class="gi">+    else:</span>
<span class="gi">+        # I don&#39;t think there&#39;s a reasonable chance that a string</span>
<span class="gi">+        # operation is still correct, once we pass something like six</span>
<span class="gi">+        # objects.</span>
<span class="gi">+        if len(left_values) * len(right_values) &gt; 6:</span>
<span class="gi">+            return _literals_to_types(state, left_values | right_values)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ValueSet.from_sets(</span>
<span class="gi">+                _infer_comparison_part(state, context, left, operator, right)</span>
<span class="gi">+                for left in left_values</span>
<span class="gi">+                for right in right_values</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_annotation_name(name):</span>
<span class="gi">+    ancestor = tree.search_ancestor(name, &#39;param&#39;, &#39;funcdef&#39;, &#39;expr_stmt&#39;)</span>
<span class="gi">+    if ancestor is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if ancestor.type in (&#39;param&#39;, &#39;funcdef&#39;):</span>
<span class="gi">+        ann = ancestor.annotation</span>
<span class="gi">+        if ann is not None:</span>
<span class="gi">+            return ann.start_pos &lt;= name.start_pos &lt; ann.end_pos</span>
<span class="gi">+    elif ancestor.type == &#39;expr_stmt&#39;:</span>
<span class="gi">+        c = ancestor.children</span>
<span class="gi">+        if len(c) &gt; 1 and c[1].type == &#39;annassign&#39;:</span>
<span class="gi">+            return c[1].start_pos &lt;= name.start_pos &lt; c[1].end_pos</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_list(value):</span>
<span class="gi">+    return value.array_type == &#39;list&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_tuple(value):</span>
<span class="gi">+    return value.array_type == &#39;tuple&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _bool_to_value(inference_state, bool_):</span>
<span class="gi">+    return compiled.builtin_from_name(inference_state, str(bool_))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_tuple_ints(value):</span>
<span class="gi">+    if not isinstance(value, iterable.SequenceLiteralValue):</span>
<span class="gi">+        return None</span>
<span class="gi">+    numbers = []</span>
<span class="gi">+    for lazy_value in value.py__iter__():</span>
<span class="gi">+        if not isinstance(lazy_value, LazyTreeValue):</span>
<span class="gi">+            return None</span>
<span class="gi">+        node = lazy_value.data</span>
<span class="gi">+        if node.type != &#39;number&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        try:</span>
<span class="gi">+            numbers.append(int(node.value))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return None</span>
<span class="gi">+    return numbers</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_comparison_part(inference_state, context, left, operator, right):</span>
<span class="gi">+    l_is_num = is_number(left)</span>
<span class="gi">+    r_is_num = is_number(right)</span>
<span class="gi">+    if isinstance(operator, str):</span>
<span class="gi">+        str_operator = operator</span>
<span class="gi">+    else:</span>
<span class="gi">+        str_operator = str(operator.value)</span>
<span class="gi">+</span>
<span class="gi">+    if str_operator == &#39;*&#39;:</span>
<span class="gi">+        # for iterables, ignore * operations</span>
<span class="gi">+        if isinstance(left, iterable.Sequence) or is_string(left):</span>
<span class="gi">+            return ValueSet([left])</span>
<span class="gi">+        elif isinstance(right, iterable.Sequence) or is_string(right):</span>
<span class="gi">+            return ValueSet([right])</span>
<span class="gi">+    elif str_operator == &#39;+&#39;:</span>
<span class="gi">+        if l_is_num and r_is_num or is_string(left) and is_string(right):</span>
<span class="gi">+            return left.execute_operation(right, str_operator)</span>
<span class="gi">+        elif _is_list(left) and _is_list(right) or _is_tuple(left) and _is_tuple(right):</span>
<span class="gi">+            return ValueSet([iterable.MergedArray(inference_state, (left, right))])</span>
<span class="gi">+    elif str_operator == &#39;-&#39;:</span>
<span class="gi">+        if l_is_num and r_is_num:</span>
<span class="gi">+            return left.execute_operation(right, str_operator)</span>
<span class="gi">+    elif str_operator == &#39;%&#39;:</span>
<span class="gi">+        # With strings and numbers the left type typically remains. Except for</span>
<span class="gi">+        # `int() % float()`.</span>
<span class="gi">+        return ValueSet([left])</span>
<span class="gi">+    elif str_operator in COMPARISON_OPERATORS:</span>
<span class="gi">+        if left.is_compiled() and right.is_compiled():</span>
<span class="gi">+            # Possible, because the return is not an option. Just compare.</span>
<span class="gi">+            result = left.execute_operation(right, str_operator)</span>
<span class="gi">+            if result:</span>
<span class="gi">+                return result</span>
<span class="gi">+        else:</span>
<span class="gi">+            if str_operator in (&#39;is&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;is not&#39;):</span>
<span class="gi">+                operation = COMPARISON_OPERATORS[str_operator]</span>
<span class="gi">+                bool_ = operation(left, right)</span>
<span class="gi">+                # Only if == returns True or != returns False, we can continue.</span>
<span class="gi">+                # There&#39;s no guarantee that they are not equal. This can help</span>
<span class="gi">+                # in some cases, but does not cover everything.</span>
<span class="gi">+                if (str_operator in (&#39;is&#39;, &#39;==&#39;)) == bool_:</span>
<span class="gi">+                    return ValueSet([_bool_to_value(inference_state, bool_)])</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(left, VersionInfo):</span>
<span class="gi">+                version_info = _get_tuple_ints(right)</span>
<span class="gi">+                if version_info is not None:</span>
<span class="gi">+                    bool_result = compiled.access.COMPARISON_OPERATORS[operator](</span>
<span class="gi">+                        inference_state.environment.version_info,</span>
<span class="gi">+                        tuple(version_info)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return ValueSet([_bool_to_value(inference_state, bool_result)])</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([</span>
<span class="gi">+            _bool_to_value(inference_state, True),</span>
<span class="gi">+            _bool_to_value(inference_state, False)</span>
<span class="gi">+        ])</span>
<span class="gi">+    elif str_operator in (&#39;in&#39;, &#39;not in&#39;):</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def check(obj):</span>
<span class="gi">+        &quot;&quot;&quot;Checks if a Jedi object is either a float or an int.&quot;&quot;&quot;</span>
<span class="gi">+        return isinstance(obj, TreeInstance) and \</span>
<span class="gi">+            obj.name.string_name in (&#39;int&#39;, &#39;float&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Static analysis, one is a number, the other one is not.</span>
<span class="gi">+    if str_operator in (&#39;+&#39;, &#39;-&#39;) and l_is_num != r_is_num \</span>
<span class="gi">+            and not (check(left) or check(right)):</span>
<span class="gi">+        message = &quot;TypeError: unsupported operand type(s) for +: %s and %s&quot;</span>
<span class="gi">+        analysis.add(context, &#39;type-error-operation&#39;, operator,</span>
<span class="gi">+                     message % (left, right))</span>
<span class="gi">+</span>
<span class="gi">+    if left.is_class() or right.is_class():</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    method_name = operator_to_magic_method[str_operator]</span>
<span class="gi">+    magic_methods = left.py__getattribute__(method_name)</span>
<span class="gi">+    if magic_methods:</span>
<span class="gi">+        result = magic_methods.execute_with_values(right)</span>
<span class="gi">+        if result:</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+    if not magic_methods:</span>
<span class="gi">+        reverse_method_name = reverse_operator_to_magic_method[str_operator]</span>
<span class="gi">+        magic_methods = right.py__getattribute__(reverse_method_name)</span>
<span class="gi">+</span>
<span class="gi">+        result = magic_methods.execute_with_values(left)</span>
<span class="gi">+        if result:</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+    result = ValueSet([left, right])</span>
<span class="gi">+    debug.dbg(&#39;Used operator %s resulting in %s&#39;, operator, result)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@plugin_manager.decorate()</span>
<span class="gi">+def tree_name_to_values(inference_state, context, tree_name):</span>
<span class="gi">+    value_set = NO_VALUES</span>
<span class="gi">+    module_node = context.get_root_context().tree_node</span>
<span class="gi">+    # First check for annotations, like: `foo: int = 3`</span>
<span class="gi">+    if module_node is not None:</span>
<span class="gi">+        names = module_node.get_used_names().get(tree_name.value, [])</span>
<span class="gi">+        found_annotation = False</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            expr_stmt = name.parent</span>
<span class="gi">+</span>
<span class="gi">+            if expr_stmt.type == &quot;expr_stmt&quot; and expr_stmt.children[1].type == &quot;annassign&quot;:</span>
<span class="gi">+                correct_scope = parser_utils.get_parent_scope(name) == context.tree_node</span>
<span class="gi">+                if correct_scope:</span>
<span class="gi">+                    found_annotation = True</span>
<span class="gi">+                    value_set |= annotation.infer_annotation(</span>
<span class="gi">+                        context, expr_stmt.children[1].children[1]</span>
<span class="gi">+                    ).execute_annotation()</span>
<span class="gi">+        if found_annotation:</span>
<span class="gi">+            return value_set</span>
<span class="gi">+</span>
<span class="gi">+    types = []</span>
<span class="gi">+    node = tree_name.get_definition(import_name_always=True, include_setitem=True)</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        node = tree_name.parent</span>
<span class="gi">+        if node.type == &#39;global_stmt&#39;:</span>
<span class="gi">+            c = context.create_context(tree_name)</span>
<span class="gi">+            if c.is_module():</span>
<span class="gi">+                # In case we are already part of the module, there is no point</span>
<span class="gi">+                # in looking up the global statement anymore, because it&#39;s not</span>
<span class="gi">+                # valid at that point anyway.</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            # For global_stmt lookups, we only need the first possible scope,</span>
<span class="gi">+            # which means the function itself.</span>
<span class="gi">+            filter = next(c.get_filters())</span>
<span class="gi">+            names = filter.get(tree_name.value)</span>
<span class="gi">+            return ValueSet.from_sets(name.infer() for name in names)</span>
<span class="gi">+        elif node.type not in (&#39;import_from&#39;, &#39;import_name&#39;):</span>
<span class="gi">+            c = context.create_context(tree_name)</span>
<span class="gi">+            return infer_atom(c, tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    typ = node.type</span>
<span class="gi">+    if typ == &#39;for_stmt&#39;:</span>
<span class="gi">+        types = annotation.find_type_from_comment_hint_for(context, node, tree_name)</span>
<span class="gi">+        if types:</span>
<span class="gi">+            return types</span>
<span class="gi">+    if typ == &#39;with_stmt&#39;:</span>
<span class="gi">+        types = annotation.find_type_from_comment_hint_with(context, node, tree_name)</span>
<span class="gi">+        if types:</span>
<span class="gi">+            return types</span>
<span class="gi">+</span>
<span class="gi">+    if typ in (&#39;for_stmt&#39;, &#39;comp_for&#39;, &#39;sync_comp_for&#39;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            types = context.predefined_names[node][tree_name.value]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            cn = ContextualizedNode(context, node.children[3])</span>
<span class="gi">+            for_types = iterate_values(</span>
<span class="gi">+                cn.infer(),</span>
<span class="gi">+                contextualized_node=cn,</span>
<span class="gi">+                is_async=node.parent.type == &#39;async_stmt&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+            n = TreeNameDefinition(context, tree_name)</span>
<span class="gi">+            types = check_tuple_assignments(n, for_types)</span>
<span class="gi">+    elif typ == &#39;expr_stmt&#39;:</span>
<span class="gi">+        types = infer_expr_stmt(context, node, tree_name)</span>
<span class="gi">+    elif typ == &#39;with_stmt&#39;:</span>
<span class="gi">+        value_managers = context.infer_node(node.get_test_node_from_name(tree_name))</span>
<span class="gi">+        if node.parent.type == &#39;async_stmt&#39;:</span>
<span class="gi">+            # In the case of `async with` statements, we need to</span>
<span class="gi">+            # first get the coroutine from the `__aenter__` method,</span>
<span class="gi">+            # then &quot;unwrap&quot; via the `__await__` method</span>
<span class="gi">+            enter_methods = value_managers.py__getattribute__(&#39;__aenter__&#39;)</span>
<span class="gi">+            coro = enter_methods.execute_with_values()</span>
<span class="gi">+            return coro.py__await__().py__stop_iteration_returns()</span>
<span class="gi">+        enter_methods = value_managers.py__getattribute__(&#39;__enter__&#39;)</span>
<span class="gi">+        return enter_methods.execute_with_values()</span>
<span class="gi">+    elif typ in (&#39;import_from&#39;, &#39;import_name&#39;):</span>
<span class="gi">+        types = imports.infer_import(context, tree_name)</span>
<span class="gi">+    elif typ in (&#39;funcdef&#39;, &#39;classdef&#39;):</span>
<span class="gi">+        types = _apply_decorators(context, node)</span>
<span class="gi">+    elif typ == &#39;try_stmt&#39;:</span>
<span class="gi">+        # TODO an exception can also be a tuple. Check for those.</span>
<span class="gi">+        # TODO check for types that are not classes and add it to</span>
<span class="gi">+        # the static analysis report.</span>
<span class="gi">+        exceptions = context.infer_node(tree_name.get_previous_sibling().get_previous_sibling())</span>
<span class="gi">+        types = exceptions.execute_with_values()</span>
<span class="gi">+    elif typ == &#39;param&#39;:</span>
<span class="gi">+        types = NO_VALUES</span>
<span class="gi">+    elif typ == &#39;del_stmt&#39;:</span>
<span class="gi">+        types = NO_VALUES</span>
<span class="gi">+    elif typ == &#39;namedexpr_test&#39;:</span>
<span class="gi">+        types = infer_node(context, node)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Should not happen. type: %s&quot; % typ)</span>
<span class="gi">+    return types</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# We don&#39;t want to have functions/classes that are created by the same</span>
<span class="gi">+# tree_node.</span>
<span class="w"> </span>@inference_state_method_cache()
<span class="w"> </span>def _apply_decorators(context, node):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the function, that should to be executed in the end.
<span class="w"> </span>    This is also the places where the decorators are processed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.type == &#39;classdef&#39;:</span>
<span class="gi">+        decoratee_value = ClassValue(</span>
<span class="gi">+            context.inference_state,</span>
<span class="gi">+            parent_context=context,</span>
<span class="gi">+            tree_node=node</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        decoratee_value = FunctionValue.from_context(context, node)</span>
<span class="gi">+    initial = values = ValueSet([decoratee_value])</span>
<span class="gi">+</span>
<span class="gi">+    if is_big_annoying_library(context):</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    for dec in reversed(node.get_decorators()):</span>
<span class="gi">+        debug.dbg(&#39;decorator: %s %s&#39;, dec, values, color=&quot;MAGENTA&quot;)</span>
<span class="gi">+        with debug.increase_indent_cm():</span>
<span class="gi">+            dec_values = context.infer_node(dec.children[1])</span>
<span class="gi">+            trailer_nodes = dec.children[2:-1]</span>
<span class="gi">+            if trailer_nodes:</span>
<span class="gi">+                # Create a trailer and infer it.</span>
<span class="gi">+                trailer = tree.PythonNode(&#39;trailer&#39;, trailer_nodes)</span>
<span class="gi">+                trailer.parent = dec</span>
<span class="gi">+                dec_values = infer_trailer(context, dec_values, trailer)</span>
<span class="gi">+</span>
<span class="gi">+            if not len(dec_values):</span>
<span class="gi">+                code = dec.get_code(include_prefix=False)</span>
<span class="gi">+                # For the short future, we don&#39;t want to hear about the runtime</span>
<span class="gi">+                # decorator in typing that was intentionally omitted. This is not</span>
<span class="gi">+                # &quot;correct&quot;, but helps with debugging.</span>
<span class="gi">+                if code != &#39;@runtime\n&#39;:</span>
<span class="gi">+                    debug.warning(&#39;decorator not found: %s on %s&#39;, dec, node)</span>
<span class="gi">+                return initial</span>
<span class="gi">+</span>
<span class="gi">+            values = dec_values.execute(arguments.ValuesArguments([values]))</span>
<span class="gi">+            if not len(values):</span>
<span class="gi">+                debug.warning(&#39;not possible to resolve wrappers found %s&#39;, node)</span>
<span class="gi">+                return initial</span>
<span class="gi">+</span>
<span class="gi">+        debug.dbg(&#39;decorator end %s&#39;, values, color=&quot;MAGENTA&quot;)</span>
<span class="gi">+    if values != initial:</span>
<span class="gi">+        return ValueSet([Decoratee(c, decoratee_value) for c in values])</span>
<span class="gi">+    return values</span>


<span class="w"> </span>def check_tuple_assignments(name, value_set):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks if tuples are assigned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lazy_value = None</span>
<span class="gi">+    for index, node in name.assignment_indexes():</span>
<span class="gi">+        cn = ContextualizedNode(name.parent_context, node)</span>
<span class="gi">+        iterated = value_set.iterate(cn)</span>
<span class="gi">+        if isinstance(index, slice):</span>
<span class="gi">+            # For no star unpacking is not possible.</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while i &lt;= index:</span>
<span class="gi">+            try:</span>
<span class="gi">+                lazy_value = next(iterated)</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                # We could do this with the default param in next. But this</span>
<span class="gi">+                # would allow this loop to run for a very long time if the</span>
<span class="gi">+                # index number is high. Therefore break if the loop is</span>
<span class="gi">+                # finished.</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            else:</span>
<span class="gi">+                i += lazy_value.max</span>
<span class="gi">+        value_set = lazy_value.infer()</span>
<span class="gi">+    return value_set</span>


<span class="w"> </span>class ContextualizedSubscriptListNode(ContextualizedNode):
<span class="gd">-    pass</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return _infer_subscript_list(self.context, self.node)</span>


<span class="w"> </span>def _infer_subscript_list(context, index):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Handles slices in subscript nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if index == &#39;:&#39;:</span>
<span class="gi">+        # Like array[:]</span>
<span class="gi">+        return ValueSet([iterable.Slice(context, None, None, None)])</span>
<span class="gi">+</span>
<span class="gi">+    elif index.type == &#39;subscript&#39; and not index.children[0] == &#39;.&#39;:</span>
<span class="gi">+        # subscript basically implies a slice operation</span>
<span class="gi">+        # e.g. array[:3]</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for el in index.children:</span>
<span class="gi">+            if el == &#39;:&#39;:</span>
<span class="gi">+                if not result:</span>
<span class="gi">+                    result.append(None)</span>
<span class="gi">+            elif el.type == &#39;sliceop&#39;:</span>
<span class="gi">+                if len(el.children) == 2:</span>
<span class="gi">+                    result.append(el.children[1])</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(el)</span>
<span class="gi">+        result += [None] * (3 - len(result))</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([iterable.Slice(context, *result)])</span>
<span class="gi">+    elif index.type == &#39;subscriptlist&#39;:</span>
<span class="gi">+        return ValueSet([iterable.SequenceLiteralValue(context.inference_state, context, index)])</span>
<span class="gi">+</span>
<span class="gi">+    # No slices</span>
<span class="gi">+    return context.infer_node(index)</span>
<span class="gh">diff --git a/jedi/inference/sys_path.py b/jedi/inference/sys_path.py</span>
<span class="gh">index a8e35f04..062a0aa3 100644</span>
<span class="gd">--- a/jedi/inference/sys_path.py</span>
<span class="gi">+++ b/jedi/inference/sys_path.py</span>
<span class="gu">@@ -2,6 +2,7 @@ import os</span>
<span class="w"> </span>import re
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from importlib.machinery import all_suffixes
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.base_value import ContextualizedNode
<span class="w"> </span>from jedi.inference.helpers import is_string, get_str_or_none
<span class="gu">@@ -9,9 +10,25 @@ from jedi.parser_utils import get_cached_code_lines</span>
<span class="w"> </span>from jedi.file_io import FileIO
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi import debug
<span class="gi">+</span>
<span class="w"> </span>_BUILDOUT_PATH_INSERTION_LIMIT = 10


<span class="gi">+def _abs_path(module_context, str_path: str):</span>
<span class="gi">+    path = Path(str_path)</span>
<span class="gi">+    if path.is_absolute():</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    module_path = module_context.py__file__()</span>
<span class="gi">+    if module_path is None:</span>
<span class="gi">+        # In this case we have no idea where we actually are in the file</span>
<span class="gi">+        # system.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    base_dir = module_path.parent</span>
<span class="gi">+    return base_dir.joinpath(path).absolute()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def _paths_from_assignment(module_context, expr_stmt):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Extracts the assigned strings from an assignment that looks as follows::
<span class="gu">@@ -23,12 +40,61 @@ def _paths_from_assignment(module_context, expr_stmt):</span>
<span class="w"> </span>    because it will only affect Jedi in very random situations and by adding
<span class="w"> </span>    more paths than necessary, it usually benefits the general user.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for assignee, operator in zip(expr_stmt.children[::2], expr_stmt.children[1::2]):</span>
<span class="gi">+        try:</span>
<span class="gi">+            assert operator in [&#39;=&#39;, &#39;+=&#39;]</span>
<span class="gi">+            assert assignee.type in (&#39;power&#39;, &#39;atom_expr&#39;) and \</span>
<span class="gi">+                len(assignee.children) &gt; 1</span>
<span class="gi">+            c = assignee.children</span>
<span class="gi">+            assert c[0].type == &#39;name&#39; and c[0].value == &#39;sys&#39;</span>
<span class="gi">+            trailer = c[1]</span>
<span class="gi">+            assert trailer.children[0] == &#39;.&#39; and trailer.children[1].value == &#39;path&#39;</span>
<span class="gi">+            # TODO Essentially we&#39;re not checking details on sys.path</span>
<span class="gi">+            # manipulation. Both assigment of the sys.path and changing/adding</span>
<span class="gi">+            # parts of the sys.path are the same: They get added to the end of</span>
<span class="gi">+            # the current sys.path.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            execution = c[2]</span>
<span class="gi">+            assert execution.children[0] == &#39;[&#39;</span>
<span class="gi">+            subscript = execution.children[1]</span>
<span class="gi">+            assert subscript.type == &#39;subscript&#39;</span>
<span class="gi">+            assert &#39;:&#39; in subscript.children</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+        except AssertionError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        cn = ContextualizedNode(module_context.create_context(expr_stmt), expr_stmt)</span>
<span class="gi">+        for lazy_value in cn.infer().iterate(cn):</span>
<span class="gi">+            for value in lazy_value.infer():</span>
<span class="gi">+                if is_string(value):</span>
<span class="gi">+                    abs_path = _abs_path(module_context, value.get_safe_value())</span>
<span class="gi">+                    if abs_path is not None:</span>
<span class="gi">+                        yield abs_path</span>


<span class="w"> </span>def _paths_from_list_modifications(module_context, trailer1, trailer2):
<span class="w"> </span>    &quot;&quot;&quot; extract the path from either &quot;sys.path.append&quot; or &quot;sys.path.insert&quot; &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Guarantee that both are trailers, the first one a name and the second one</span>
<span class="gi">+    # a function execution with at least one param.</span>
<span class="gi">+    if not (trailer1.type == &#39;trailer&#39; and trailer1.children[0] == &#39;.&#39;</span>
<span class="gi">+            and trailer2.type == &#39;trailer&#39; and trailer2.children[0] == &#39;(&#39;</span>
<span class="gi">+            and len(trailer2.children) == 3):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    name = trailer1.children[1].value</span>
<span class="gi">+    if name not in [&#39;insert&#39;, &#39;append&#39;]:</span>
<span class="gi">+        return</span>
<span class="gi">+    arg = trailer2.children[1]</span>
<span class="gi">+    if name == &#39;insert&#39; and len(arg.children) in (3, 4):  # Possible trailing comma.</span>
<span class="gi">+        arg = arg.children[2]</span>
<span class="gi">+</span>
<span class="gi">+    for value in module_context.create_context(arg).infer_node(arg):</span>
<span class="gi">+        p = get_str_or_none(value)</span>
<span class="gi">+        if p is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        abs_path = _abs_path(module_context, p)</span>
<span class="gi">+        if abs_path is not None:</span>
<span class="gi">+            yield abs_path</span>


<span class="w"> </span>@inference_state_method_cache(default=[])
<span class="gu">@@ -36,7 +102,81 @@ def check_sys_path_modifications(module_context):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Detect sys.path modifications within module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def get_sys_path_powers(names):</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            power = name.parent.parent</span>
<span class="gi">+            if power is not None and power.type in (&#39;power&#39;, &#39;atom_expr&#39;):</span>
<span class="gi">+                c = power.children</span>
<span class="gi">+                if c[0].type == &#39;name&#39; and c[0].value == &#39;sys&#39; \</span>
<span class="gi">+                        and c[1].type == &#39;trailer&#39;:</span>
<span class="gi">+                    n = c[1].children[1]</span>
<span class="gi">+                    if n.type == &#39;name&#39; and n.value == &#39;path&#39;:</span>
<span class="gi">+                        yield name, power</span>
<span class="gi">+</span>
<span class="gi">+    if module_context.tree_node is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    added = []</span>
<span class="gi">+    try:</span>
<span class="gi">+        possible_names = module_context.tree_node.get_used_names()[&#39;path&#39;]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        for name, power in get_sys_path_powers(possible_names):</span>
<span class="gi">+            expr_stmt = power.parent</span>
<span class="gi">+            if len(power.children) &gt;= 4:</span>
<span class="gi">+                added.extend(</span>
<span class="gi">+                    _paths_from_list_modifications(</span>
<span class="gi">+                        module_context, *power.children[2:4]</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            elif expr_stmt is not None and expr_stmt.type == &#39;expr_stmt&#39;:</span>
<span class="gi">+                added.extend(_paths_from_assignment(module_context, expr_stmt))</span>
<span class="gi">+    return added</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def discover_buildout_paths(inference_state, script_path):</span>
<span class="gi">+    buildout_script_paths = set()</span>
<span class="gi">+</span>
<span class="gi">+    for buildout_script_path in _get_buildout_script_paths(script_path):</span>
<span class="gi">+        for path in _get_paths_from_buildout_script(inference_state, buildout_script_path):</span>
<span class="gi">+            buildout_script_paths.add(path)</span>
<span class="gi">+            if len(buildout_script_paths) &gt;= _BUILDOUT_PATH_INSERTION_LIMIT:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    return buildout_script_paths</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_paths_from_buildout_script(inference_state, buildout_script_path):</span>
<span class="gi">+    file_io = FileIO(str(buildout_script_path))</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_node = inference_state.parse(</span>
<span class="gi">+            file_io=file_io,</span>
<span class="gi">+            cache=True,</span>
<span class="gi">+            cache_path=settings.cache_directory</span>
<span class="gi">+        )</span>
<span class="gi">+    except IOError:</span>
<span class="gi">+        debug.warning(&#39;Error trying to read buildout_script: %s&#39;, buildout_script_path)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    from jedi.inference.value import ModuleValue</span>
<span class="gi">+    module_context = ModuleValue(</span>
<span class="gi">+        inference_state, module_node,</span>
<span class="gi">+        file_io=file_io,</span>
<span class="gi">+        string_names=None,</span>
<span class="gi">+        code_lines=get_cached_code_lines(inference_state.grammar, buildout_script_path),</span>
<span class="gi">+    ).as_context()</span>
<span class="gi">+    yield from check_sys_path_modifications(module_context)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_parent_dir_with_file(path: Path, filename):</span>
<span class="gi">+    for parent in path.parents:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if parent.joinpath(filename).is_file():</span>
<span class="gi">+                return parent</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def _get_buildout_script_paths(search_path: Path):
<span class="gu">@@ -47,7 +187,33 @@ def _get_buildout_script_paths(search_path: Path):</span>

<span class="w"> </span>    :param search_path: absolute path to the module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    project_root = _get_parent_dir_with_file(search_path, &#39;buildout.cfg&#39;)</span>
<span class="gi">+    if not project_root:</span>
<span class="gi">+        return</span>
<span class="gi">+    bin_path = project_root.joinpath(&#39;bin&#39;)</span>
<span class="gi">+    if not bin_path.exists():</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for filename in os.listdir(bin_path):</span>
<span class="gi">+        try:</span>
<span class="gi">+            filepath = bin_path.joinpath(filename)</span>
<span class="gi">+            with open(filepath, &#39;r&#39;) as f:</span>
<span class="gi">+                firstline = f.readline()</span>
<span class="gi">+                if firstline.startswith(&#39;#!&#39;) and &#39;python&#39; in firstline:</span>
<span class="gi">+                    yield filepath</span>
<span class="gi">+        except (UnicodeDecodeError, IOError) as e:</span>
<span class="gi">+            # Probably a binary file; permission error or race cond. because</span>
<span class="gi">+            # file got deleted. Ignore it.</span>
<span class="gi">+            debug.warning(str(e))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def remove_python_path_suffix(path):</span>
<span class="gi">+    for suffix in all_suffixes() + [&#39;.pyi&#39;]:</span>
<span class="gi">+        if path.suffix == suffix:</span>
<span class="gi">+            path = path.with_name(path.stem)</span>
<span class="gi">+            break</span>
<span class="gi">+    return path</span>


<span class="w"> </span>def transform_path_to_dotted(sys_path, module_path):
<span class="gu">@@ -60,4 +226,47 @@ def transform_path_to_dotted(sys_path, module_path):</span>
<span class="w"> </span>    Returns (None, False) if the path doesn&#39;t really resolve to anything.
<span class="w"> </span>    The second return part is if it is a package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # First remove the suffix.</span>
<span class="gi">+    module_path = remove_python_path_suffix(module_path)</span>
<span class="gi">+    if module_path.name.startswith(&#39;.&#39;):</span>
<span class="gi">+        return None, False</span>
<span class="gi">+</span>
<span class="gi">+    # Once the suffix was removed we are using the files as we know them. This</span>
<span class="gi">+    # means that if someone uses an ending like .vim for a Python file, .vim</span>
<span class="gi">+    # will be part of the returned dotted part.</span>
<span class="gi">+</span>
<span class="gi">+    is_package = module_path.name == &#39;__init__&#39;</span>
<span class="gi">+    if is_package:</span>
<span class="gi">+        module_path = module_path.parent</span>
<span class="gi">+</span>
<span class="gi">+    def iter_potential_solutions():</span>
<span class="gi">+        for p in sys_path:</span>
<span class="gi">+            if str(module_path).startswith(p):</span>
<span class="gi">+                # Strip the trailing slash/backslash</span>
<span class="gi">+                rest = str(module_path)[len(p):]</span>
<span class="gi">+                # On Windows a path can also use a slash.</span>
<span class="gi">+                if rest.startswith(os.path.sep) or rest.startswith(&#39;/&#39;):</span>
<span class="gi">+                    # Remove a slash in cases it&#39;s still there.</span>
<span class="gi">+                    rest = rest[1:]</span>
<span class="gi">+</span>
<span class="gi">+                if rest:</span>
<span class="gi">+                    split = rest.split(os.path.sep)</span>
<span class="gi">+                    if not all(split):</span>
<span class="gi">+                        # This means that part of the file path was empty, this</span>
<span class="gi">+                        # is very strange and is probably a file that is called</span>
<span class="gi">+                        # `.py`.</span>
<span class="gi">+                        return</span>
<span class="gi">+                    # Stub folders for foo can end with foo-stubs. Just remove</span>
<span class="gi">+                    # it.</span>
<span class="gi">+                    yield tuple(re.sub(r&#39;-stubs$&#39;, &#39;&#39;, s) for s in split)</span>
<span class="gi">+</span>
<span class="gi">+    potential_solutions = tuple(iter_potential_solutions())</span>
<span class="gi">+    if not potential_solutions:</span>
<span class="gi">+        return None, False</span>
<span class="gi">+    # Try to find the shortest path, this makes more sense usually, because the</span>
<span class="gi">+    # user usually has venvs somewhere. This means that a path like</span>
<span class="gi">+    # .tox/py37/lib/python3.7/os.py can be normal for a file. However in that</span>
<span class="gi">+    # case we definitely want to return [&#39;os&#39;] as a path and not a crazy</span>
<span class="gi">+    # [&#39;.tox&#39;, &#39;py37&#39;, &#39;lib&#39;, &#39;python3.7&#39;, &#39;os&#39;]. Keep in mind that this is a</span>
<span class="gi">+    # heuristic and there&#39;s now ay to &quot;always&quot; do it right.</span>
<span class="gi">+    return sorted(potential_solutions, key=lambda p: len(p))[0], is_package</span>
<span class="gh">diff --git a/jedi/inference/utils.py b/jedi/inference/utils.py</span>
<span class="gh">index 9e8c4321..ab10bcd9 100644</span>
<span class="gd">--- a/jedi/inference/utils.py</span>
<span class="gi">+++ b/jedi/inference/utils.py</span>
<span class="gu">@@ -2,17 +2,30 @@</span>
<span class="w"> </span>import functools
<span class="w"> </span>import re
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_sep = os.path.sep
<span class="w"> </span>if os.path.altsep is not None:
<span class="w"> </span>    _sep += os.path.altsep
<span class="gd">-_path_re = re.compile(&#39;(?:\\.[^{0}]+|[{0}]__init__\\.py)$&#39;.format(re.escape</span>
<span class="gd">-    (_sep)))</span>
<span class="gi">+_path_re = re.compile(r&#39;(?:\.[^{0}]+|[{0}]__init__\.py)$&#39;.format(re.escape(_sep)))</span>
<span class="w"> </span>del _sep


<span class="gi">+def to_list(func):</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        return list(func(*args, **kwargs))</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_tuple(func):</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        return tuple(func(*args, **kwargs))</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def unite(iterable):
<span class="w"> </span>    &quot;&quot;&quot;Turns a two dimensional array into a one dimensional.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set(typ for types in iterable for typ in types)</span>


<span class="w"> </span>class UncaughtAttributeError(Exception):
<span class="gu">@@ -27,6 +40,10 @@ class UncaughtAttributeError(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gi">+def safe_property(func):</span>
<span class="gi">+    return property(reraise_uncaught(func))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def reraise_uncaught(func):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Re-throw uncaught `AttributeError`.
<span class="gu">@@ -44,16 +61,24 @@ def reraise_uncaught(func):</span>
<span class="w"> </span>    `AttributeError` to `UncaughtAttributeError` to avoid unexpected catch.
<span class="w"> </span>    This helps us noticing bugs earlier and facilitates debugging.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @functools.wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwds):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwds)</span>
<span class="gi">+        except AttributeError as e:</span>
<span class="gi">+            raise UncaughtAttributeError(e) from e</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class PushBackIterator:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, iterator):
<span class="w"> </span>        self.pushes = []
<span class="w"> </span>        self.iterator = iterator
<span class="w"> </span>        self.current = None

<span class="gi">+    def push_back(self, value):</span>
<span class="gi">+        self.pushes.append(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return self

<span class="gh">diff --git a/jedi/inference/value/decorator.py b/jedi/inference/value/decorator.py</span>
<span class="gh">index be2e0d4c..69c4cb6a 100644</span>
<span class="gd">--- a/jedi/inference/value/decorator.py</span>
<span class="gi">+++ b/jedi/inference/value/decorator.py</span>
<span class="gu">@@ -1,12 +1,34 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="w"> </span>Decorators are not really values, however we need some wrappers to improve
<span class="w"> </span>docstrings and other things around decorators.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.base_value import ValueWrapper, ValueSet


<span class="w"> </span>class Decoratee(ValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, wrapped_value, original_value):
<span class="w"> </span>        super().__init__(wrapped_value)
<span class="w"> </span>        self._original_value = original_value
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return self._original_value.py__doc__()</span>
<span class="gi">+</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            Decoratee(v, self._original_value)</span>
<span class="gi">+            for v in self._wrapped_value.py__get__(instance, class_value)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        signatures = self._wrapped_value.get_signatures()</span>
<span class="gi">+        if signatures:</span>
<span class="gi">+            return signatures</span>
<span class="gi">+        # Fallback to signatures of the original function/class if the</span>
<span class="gi">+        # decorator has no signature or it is not inferrable.</span>
<span class="gi">+        #</span>
<span class="gi">+        # __get__ means that it&#39;s a descriptor. In that case we don&#39;t return</span>
<span class="gi">+        # signatures, because they are usually properties.</span>
<span class="gi">+        if not self._wrapped_value.py__getattribute__(&#39;__get__&#39;):</span>
<span class="gi">+            return self._original_value.get_signatures()</span>
<span class="gi">+        return []</span>
<span class="gh">diff --git a/jedi/inference/value/dynamic_arrays.py b/jedi/inference/value/dynamic_arrays.py</span>
<span class="gh">index 419cd8a5..c451612d 100644</span>
<span class="gd">--- a/jedi/inference/value/dynamic_arrays.py</span>
<span class="gi">+++ b/jedi/inference/value/dynamic_arrays.py</span>
<span class="gu">@@ -22,16 +22,22 @@ It is important to note that:</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.inference import recursion
<span class="gd">-from jedi.inference.base_value import ValueSet, NO_VALUES, HelperValueMixin, ValueWrapper</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, NO_VALUES, HelperValueMixin, \</span>
<span class="gi">+    ValueWrapper</span>
<span class="w"> </span>from jedi.inference.lazy_value import LazyKnownValues
<span class="w"> </span>from jedi.inference.helpers import infer_call_of_leaf
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="gi">+</span>
<span class="w"> </span>_sentinel = object()


<span class="w"> </span>def check_array_additions(context, sequence):
<span class="w"> </span>    &quot;&quot;&quot; Just a mapper function for the internal _internal_check_array_additions &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sequence.array_type not in (&#39;list&#39;, &#39;set&#39;):</span>
<span class="gi">+        # TODO also check for dict updates</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    return _internal_check_array_additions(context, sequence)</span>


<span class="w"> </span>@inference_state_method_cache(default=NO_VALUES)
<span class="gu">@@ -43,12 +49,85 @@ def _internal_check_array_additions(context, sequence):</span>
<span class="w"> </span>    &gt;&gt;&gt; a = [&quot;&quot;]
<span class="w"> </span>    &gt;&gt;&gt; a.append(1)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from jedi.inference import arguments</span>
<span class="gi">+</span>
<span class="gi">+    debug.dbg(&#39;Dynamic array search for %s&#39; % sequence, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+    module_context = context.get_root_context()</span>
<span class="gi">+    if not settings.dynamic_array_additions or module_context.is_compiled():</span>
<span class="gi">+        debug.dbg(&#39;Dynamic array search aborted.&#39;, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def find_additions(context, arglist, add_name):</span>
<span class="gi">+        params = list(arguments.TreeArguments(context.inference_state, context, arglist).unpack())</span>
<span class="gi">+        result = set()</span>
<span class="gi">+        if add_name in [&#39;insert&#39;]:</span>
<span class="gi">+            params = params[1:]</span>
<span class="gi">+        if add_name in [&#39;append&#39;, &#39;add&#39;, &#39;insert&#39;]:</span>
<span class="gi">+            for key, lazy_value in params:</span>
<span class="gi">+                result.add(lazy_value)</span>
<span class="gi">+        elif add_name in [&#39;extend&#39;, &#39;update&#39;]:</span>
<span class="gi">+            for key, lazy_value in params:</span>
<span class="gi">+                result |= set(lazy_value.infer().iterate())</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    temp_param_add, settings.dynamic_params_for_other_modules = \</span>
<span class="gi">+        settings.dynamic_params_for_other_modules, False</span>
<span class="gi">+</span>
<span class="gi">+    is_list = sequence.name.string_name == &#39;list&#39;</span>
<span class="gi">+    search_names = ([&#39;append&#39;, &#39;extend&#39;, &#39;insert&#39;] if is_list else [&#39;add&#39;, &#39;update&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    added_types = set()</span>
<span class="gi">+    for add_name in search_names:</span>
<span class="gi">+        try:</span>
<span class="gi">+            possible_names = module_context.tree_node.get_used_names()[add_name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            for name in possible_names:</span>
<span class="gi">+                value_node = context.tree_node</span>
<span class="gi">+                if not (value_node.start_pos &lt; name.start_pos &lt; value_node.end_pos):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                trailer = name.parent</span>
<span class="gi">+                power = trailer.parent</span>
<span class="gi">+                trailer_pos = power.children.index(trailer)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    execution_trailer = power.children[trailer_pos + 1]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if execution_trailer.type != &#39;trailer&#39; \</span>
<span class="gi">+                            or execution_trailer.children[0] != &#39;(&#39; \</span>
<span class="gi">+                            or execution_trailer.children[1] == &#39;)&#39;:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                random_context = context.create_context(name)</span>
<span class="gi">+</span>
<span class="gi">+                with recursion.execution_allowed(context.inference_state, power) as allowed:</span>
<span class="gi">+                    if allowed:</span>
<span class="gi">+                        found = infer_call_of_leaf(</span>
<span class="gi">+                            random_context,</span>
<span class="gi">+                            name,</span>
<span class="gi">+                            cut_own_trailer=True</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if sequence in found:</span>
<span class="gi">+                            # The arrays match. Now add the results</span>
<span class="gi">+                            added_types |= find_additions(</span>
<span class="gi">+                                random_context,</span>
<span class="gi">+                                execution_trailer.children[1],</span>
<span class="gi">+                                add_name</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+    # reset settings</span>
<span class="gi">+    settings.dynamic_params_for_other_modules = temp_param_add</span>
<span class="gi">+    debug.dbg(&#39;Dynamic array result %s&#39;, added_types, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+    return added_types</span>


<span class="w"> </span>def get_dynamic_array_instance(instance, arguments):
<span class="w"> </span>    &quot;&quot;&quot;Used for set() and list() instances.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ai = _DynamicArrayAdditions(instance, arguments)</span>
<span class="gi">+    from jedi.inference import arguments</span>
<span class="gi">+    return arguments.ValuesArguments([ValueSet([ai])])</span>


<span class="w"> </span>class _DynamicArrayAdditions(HelperValueMixin):
<span class="gu">@@ -61,23 +140,61 @@ class _DynamicArrayAdditions(HelperValueMixin):</span>
<span class="w"> </span>    in the wild, it&#39;s just used within typeshed as an argument to `__init__`
<span class="w"> </span>    for set/list and never used in any other place.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, instance, arguments):
<span class="w"> </span>        self._instance = instance
<span class="w"> </span>        self._arguments = arguments

<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        tuple_, = self._instance.inference_state.builtins_module.py__getattribute__(&#39;tuple&#39;)</span>
<span class="gi">+        return tuple_</span>

<span class="gd">-class _Modification(ValueWrapper):</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        arguments = self._arguments</span>
<span class="gi">+        try:</span>
<span class="gi">+            _, lazy_value = next(arguments.unpack())</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from lazy_value.infer().iterate()</span>
<span class="gi">+</span>
<span class="gi">+        from jedi.inference.arguments import TreeArguments</span>
<span class="gi">+        if isinstance(arguments, TreeArguments):</span>
<span class="gi">+            additions = _internal_check_array_additions(arguments.context, self._instance)</span>
<span class="gi">+            yield from additions</span>
<span class="gi">+</span>
<span class="gi">+    def iterate(self, contextualized_node=None, is_async=False):</span>
<span class="gi">+        return self.py__iter__(contextualized_node)</span>

<span class="gi">+</span>
<span class="gi">+class _Modification(ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, wrapped_value, assigned_values, contextualized_key):
<span class="w"> </span>        super().__init__(wrapped_value)
<span class="w"> </span>        self._assigned_values = assigned_values
<span class="w"> </span>        self._contextualized_key = contextualized_key

<span class="gi">+    def py__getitem__(self, *args, **kwargs):</span>
<span class="gi">+        return self._wrapped_value.py__getitem__(*args, **kwargs) | self._assigned_values</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        actual = [</span>
<span class="gi">+            v.get_safe_value(_sentinel)</span>
<span class="gi">+            for v in self._contextualized_key.infer()</span>
<span class="gi">+        ]</span>
<span class="gi">+        if index in actual:</span>
<span class="gi">+            return self._assigned_values</span>
<span class="gi">+        return self._wrapped_value.py__simple_getitem__(index)</span>
<span class="gi">+</span>

<span class="w"> </span>class DictModification(_Modification):
<span class="gd">-    pass</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        yield from self._wrapped_value.py__iter__(contextualized_node)</span>
<span class="gi">+        yield self._contextualized_key</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        return self._wrapped_value.get_key_values() | self._contextualized_key.infer()</span>


<span class="w"> </span>class ListModification(_Modification):
<span class="gd">-    pass</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        yield from self._wrapped_value.py__iter__(contextualized_node)</span>
<span class="gi">+        yield LazyKnownValues(self._assigned_values)</span>
<span class="gh">diff --git a/jedi/inference/value/function.py b/jedi/inference/value/function.py</span>
<span class="gh">index 7ee96aa8..a89e9c88 100644</span>
<span class="gd">--- a/jedi/inference/value/function.py</span>
<span class="gi">+++ b/jedi/inference/value/function.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from parso.python import tree
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache, CachedMetaClass
<span class="w"> </span>from jedi.inference import compiled
<span class="gu">@@ -6,10 +7,14 @@ from jedi.inference import recursion</span>
<span class="w"> </span>from jedi.inference import docstrings
<span class="w"> </span>from jedi.inference import flow_analysis
<span class="w"> </span>from jedi.inference.signature import TreeSignature
<span class="gd">-from jedi.inference.filters import ParserTreeFilter, FunctionExecutionFilter, AnonymousFunctionExecutionFilter</span>
<span class="gd">-from jedi.inference.names import ValueName, AbstractNameDefinition, AnonymousParamName, ParamName, NameWrapper</span>
<span class="gd">-from jedi.inference.base_value import ContextualizedNode, NO_VALUES, ValueSet, TreeValue, ValueWrapper</span>
<span class="gd">-from jedi.inference.lazy_value import LazyKnownValues, LazyKnownValue, LazyTreeValue</span>
<span class="gi">+from jedi.inference.filters import ParserTreeFilter, FunctionExecutionFilter, \</span>
<span class="gi">+    AnonymousFunctionExecutionFilter</span>
<span class="gi">+from jedi.inference.names import ValueName, AbstractNameDefinition, \</span>
<span class="gi">+    AnonymousParamName, ParamName, NameWrapper</span>
<span class="gi">+from jedi.inference.base_value import ContextualizedNode, NO_VALUES, \</span>
<span class="gi">+    ValueSet, TreeValue, ValueWrapper</span>
<span class="gi">+from jedi.inference.lazy_value import LazyKnownValues, LazyKnownValue, \</span>
<span class="gi">+    LazyTreeValue</span>
<span class="w"> </span>from jedi.inference.context import ValueContext, TreeContextMixin
<span class="w"> </span>from jedi.inference.value import iterable
<span class="w"> </span>from jedi import parser_utils
<span class="gu">@@ -26,56 +31,431 @@ class LambdaName(AbstractNameDefinition):</span>
<span class="w"> </span>        self._lambda_value = lambda_value
<span class="w"> </span>        self.parent_context = lambda_value.parent_context

<span class="gi">+    @property</span>
<span class="gi">+    def start_pos(self):</span>
<span class="gi">+        return self._lambda_value.tree_node.start_pos</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self._lambda_value])</span>
<span class="gi">+</span>

<span class="w"> </span>class FunctionAndClassBase(TreeValue):
<span class="gd">-    pass</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        if self.parent_context.is_class():</span>
<span class="gi">+            n = self.parent_context.get_qualified_names()</span>
<span class="gi">+            if n is None:</span>
<span class="gi">+                # This means that the parent class lives within a function.</span>
<span class="gi">+                return None</span>
<span class="gi">+            return n + (self.py__name__(),)</span>
<span class="gi">+        elif self.parent_context.is_module():</span>
<span class="gi">+            return (self.py__name__(),)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>class FunctionMixin:
<span class="w"> </span>    api_type = &#39;function&#39;

<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        cls = self.py__class__()</span>
<span class="gi">+        for instance in cls.execute_with_values():</span>
<span class="gi">+            yield from instance.get_filters(origin_scope=origin_scope)</span>

<span class="gd">-class FunctionValue(FunctionMixin, FunctionAndClassBase, metaclass=</span>
<span class="gd">-    CachedMetaClass):</span>
<span class="gd">-    pass</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        from jedi.inference.value.instance import BoundMethod</span>
<span class="gi">+        if instance is None:</span>
<span class="gi">+            # Calling the Foo.bar results in the original bar function.</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+        return ValueSet([BoundMethod(instance, class_value.as_context(), self)])</span>

<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return [AnonymousParamName(self, param.name)</span>
<span class="gi">+                for param in self.tree_node.get_params()]</span>

<span class="gd">-class FunctionNameInClass(NameWrapper):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        if self.tree_node.type == &#39;lambdef&#39;:</span>
<span class="gi">+            return LambdaName(self)</span>
<span class="gi">+        return ValueName(self, self.tree_node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def is_function(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.name.string_name</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        return_annotation = self.tree_node.annotation</span>
<span class="gi">+        if return_annotation is None:</span>
<span class="gi">+            def param_name_to_str(n):</span>
<span class="gi">+                s = n.string_name</span>
<span class="gi">+                annotation = n.infer().get_type_hint()</span>
<span class="gi">+                if annotation is not None:</span>
<span class="gi">+                    s += &#39;: &#39; + annotation</span>
<span class="gi">+                if n.default_node is not None:</span>
<span class="gi">+                    s += &#39;=&#39; + n.default_node.get_code(include_prefix=False)</span>
<span class="gi">+                return s</span>
<span class="gi">+</span>
<span class="gi">+            function_execution = self.as_context()</span>
<span class="gi">+            result = function_execution.infer()</span>
<span class="gi">+            return_hint = result.get_type_hint()</span>
<span class="gi">+            body = self.py__name__() + &#39;(%s)&#39; % &#39;, &#39;.join([</span>
<span class="gi">+                param_name_to_str(n)</span>
<span class="gi">+                for n in function_execution.get_param_names()</span>
<span class="gi">+            ])</span>
<span class="gi">+            if return_hint is None:</span>
<span class="gi">+                return body</span>
<span class="gi">+        else:</span>
<span class="gi">+            return_hint = return_annotation.get_code(include_prefix=False)</span>
<span class="gi">+            body = self.py__name__() + self.tree_node.children[2].get_code(include_prefix=False)</span>
<span class="gi">+</span>
<span class="gi">+        return body + &#39; -&gt; &#39; + return_hint</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        function_execution = self.as_context(arguments)</span>
<span class="gi">+        return function_execution.infer()</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self, arguments=None):</span>
<span class="gi">+        if arguments is None:</span>
<span class="gi">+            return AnonymousFunctionExecution(self)</span>
<span class="gi">+        return FunctionExecutionContext(self, arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [TreeSignature(f) for f in self.get_signature_functions()]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class FunctionValue(FunctionMixin, FunctionAndClassBase, metaclass=CachedMetaClass):</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_context(cls, context, tree_node):</span>
<span class="gi">+        def create(tree_node):</span>
<span class="gi">+            if context.is_class():</span>
<span class="gi">+                return MethodValue(</span>
<span class="gi">+                    context.inference_state,</span>
<span class="gi">+                    context,</span>
<span class="gi">+                    parent_context=parent_context,</span>
<span class="gi">+                    tree_node=tree_node</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                return cls(</span>
<span class="gi">+                    context.inference_state,</span>
<span class="gi">+                    parent_context=parent_context,</span>
<span class="gi">+                    tree_node=tree_node</span>
<span class="gi">+                )</span>

<span class="gi">+        overloaded_funcs = list(_find_overload_functions(context, tree_node))</span>
<span class="gi">+</span>
<span class="gi">+        parent_context = context</span>
<span class="gi">+        while parent_context.is_class() or parent_context.is_instance():</span>
<span class="gi">+            parent_context = parent_context.parent_context</span>
<span class="gi">+</span>
<span class="gi">+        function = create(tree_node)</span>
<span class="gi">+</span>
<span class="gi">+        if overloaded_funcs:</span>
<span class="gi">+            return OverloadedFunctionValue(</span>
<span class="gi">+                function,</span>
<span class="gi">+                # Get them into the correct order: lower line first.</span>
<span class="gi">+                list(reversed([create(f) for f in overloaded_funcs]))</span>
<span class="gi">+            )</span>
<span class="gi">+        return function</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        c, = values_from_qualified_names(self.inference_state, &#39;types&#39;, &#39;FunctionType&#39;)</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def get_default_param_context(self):</span>
<span class="gi">+        return self.parent_context</span>
<span class="gi">+</span>
<span class="gi">+    def get_signature_functions(self):</span>
<span class="gi">+        return [self]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class FunctionNameInClass(NameWrapper):</span>
<span class="w"> </span>    def __init__(self, class_context, name):
<span class="w"> </span>        super().__init__(name)
<span class="w"> </span>        self._class_context = class_context

<span class="gi">+    def get_defining_qualified_value(self):</span>
<span class="gi">+        return self._class_context.get_value()  # Might be None.</span>

<span class="gd">-class MethodValue(FunctionValue):</span>

<span class="gi">+class MethodValue(FunctionValue):</span>
<span class="w"> </span>    def __init__(self, inference_state, class_context, *args, **kwargs):
<span class="w"> </span>        super().__init__(inference_state, *args, **kwargs)
<span class="w"> </span>        self.class_context = class_context

<span class="gi">+    def get_default_param_context(self):</span>
<span class="gi">+        return self.class_context</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        # Need to implement this, because the parent value of a method</span>
<span class="gi">+        # value is not the class value but the module.</span>
<span class="gi">+        names = self.class_context.get_qualified_names()</span>
<span class="gi">+        if names is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return names + (self.py__name__(),)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return FunctionNameInClass(self.class_context, super().name)</span>
<span class="gi">+</span>

<span class="w"> </span>class BaseFunctionExecutionContext(ValueContext, TreeContextMixin):
<span class="gi">+    def infer_annotations(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=NO_VALUES)</span>
<span class="gi">+    @recursion.execution_recursion_decorator()</span>
<span class="gi">+    def get_return_values(self, check_yields=False):</span>
<span class="gi">+        funcdef = self.tree_node</span>
<span class="gi">+        if funcdef.type == &#39;lambdef&#39;:</span>
<span class="gi">+            return self.infer_node(funcdef.children[-1])</span>
<span class="gi">+</span>
<span class="gi">+        if check_yields:</span>
<span class="gi">+            value_set = NO_VALUES</span>
<span class="gi">+            returns = get_yield_exprs(self.inference_state, funcdef)</span>
<span class="gi">+        else:</span>
<span class="gi">+            value_set = self.infer_annotations()</span>
<span class="gi">+            if value_set:</span>
<span class="gi">+                # If there are annotations, prefer them over anything else.</span>
<span class="gi">+                # This will make it faster.</span>
<span class="gi">+                return value_set</span>
<span class="gi">+            value_set |= docstrings.infer_return_types(self._value)</span>
<span class="gi">+            returns = funcdef.iter_return_stmts()</span>
<span class="gi">+</span>
<span class="gi">+        for r in returns:</span>
<span class="gi">+            if check_yields:</span>
<span class="gi">+                value_set |= ValueSet.from_sets(</span>
<span class="gi">+                    lazy_value.infer()</span>
<span class="gi">+                    for lazy_value in self._get_yield_lazy_value(r)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                check = flow_analysis.reachability_check(self, funcdef, r)</span>
<span class="gi">+                if check is flow_analysis.UNREACHABLE:</span>
<span class="gi">+                    debug.dbg(&#39;Return unreachable: %s&#39;, r)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        children = r.children</span>
<span class="gi">+                    except AttributeError:</span>
<span class="gi">+                        ctx = compiled.builtin_from_name(self.inference_state, &#39;None&#39;)</span>
<span class="gi">+                        value_set |= ValueSet([ctx])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        value_set |= self.infer_node(children[1])</span>
<span class="gi">+                if check is flow_analysis.REACHABLE:</span>
<span class="gi">+                    debug.dbg(&#39;Return reachable: %s&#39;, r)</span>
<span class="gi">+                    break</span>
<span class="gi">+        return value_set</span>
<span class="gi">+</span>
<span class="gi">+    def _get_yield_lazy_value(self, yield_expr):</span>
<span class="gi">+        if yield_expr.type == &#39;keyword&#39;:</span>
<span class="gi">+            # `yield` just yields None.</span>
<span class="gi">+            ctx = compiled.builtin_from_name(self.inference_state, &#39;None&#39;)</span>
<span class="gi">+            yield LazyKnownValue(ctx)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        node = yield_expr.children[1]</span>
<span class="gi">+        if node.type == &#39;yield_arg&#39;:  # It must be a yield from.</span>
<span class="gi">+            cn = ContextualizedNode(self, node.children[1])</span>
<span class="gi">+            yield from cn.infer().iterate(cn)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield LazyTreeValue(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    @recursion.execution_recursion_decorator(default=iter([]))</span>
<span class="gi">+    def get_yield_lazy_values(self, is_async=False):</span>
<span class="gi">+        # TODO: if is_async, wrap yield statements in Awaitable/async_generator_asend</span>
<span class="gi">+        for_parents = [(y, tree.search_ancestor(y, &#39;for_stmt&#39;, &#39;funcdef&#39;,</span>
<span class="gi">+                                                &#39;while_stmt&#39;, &#39;if_stmt&#39;))</span>
<span class="gi">+                       for y in get_yield_exprs(self.inference_state, self.tree_node)]</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate if the yields are placed within the same for loop.</span>
<span class="gi">+        yields_order = []</span>
<span class="gi">+        last_for_stmt = None</span>
<span class="gi">+        for yield_, for_stmt in for_parents:</span>
<span class="gi">+            # For really simple for loops we can predict the order. Otherwise</span>
<span class="gi">+            # we just ignore it.</span>
<span class="gi">+            parent = for_stmt.parent</span>
<span class="gi">+            if parent.type == &#39;suite&#39;:</span>
<span class="gi">+                parent = parent.parent</span>
<span class="gi">+            if for_stmt.type == &#39;for_stmt&#39; and parent == self.tree_node \</span>
<span class="gi">+                    and parser_utils.for_stmt_defines_one_name(for_stmt):  # Simplicity for now.</span>
<span class="gi">+                if for_stmt == last_for_stmt:</span>
<span class="gi">+                    yields_order[-1][1].append(yield_)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yields_order.append((for_stmt, [yield_]))</span>
<span class="gi">+            elif for_stmt == self.tree_node:</span>
<span class="gi">+                yields_order.append((None, [yield_]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                types = self.get_return_values(check_yields=True)</span>
<span class="gi">+                if types:</span>
<span class="gi">+                    yield LazyKnownValues(types, min=0, max=float(&#39;inf&#39;))</span>
<span class="gi">+                return</span>
<span class="gi">+            last_for_stmt = for_stmt</span>
<span class="gi">+</span>
<span class="gi">+        for for_stmt, yields in yields_order:</span>
<span class="gi">+            if for_stmt is None:</span>
<span class="gi">+                # No for_stmt, just normal yields.</span>
<span class="gi">+                for yield_ in yields:</span>
<span class="gi">+                    yield from self._get_yield_lazy_value(yield_)</span>
<span class="gi">+            else:</span>
<span class="gi">+                input_node = for_stmt.get_testlist()</span>
<span class="gi">+                cn = ContextualizedNode(self, input_node)</span>
<span class="gi">+                ordered = cn.infer().iterate(cn)</span>
<span class="gi">+                ordered = list(ordered)</span>
<span class="gi">+                for lazy_value in ordered:</span>
<span class="gi">+                    dct = {str(for_stmt.children[1].value): lazy_value.infer()}</span>
<span class="gi">+                    with self.predefine_names(for_stmt, dct):</span>
<span class="gi">+                        for yield_in_same_for_stmt in yields:</span>
<span class="gi">+                            yield from self._get_yield_lazy_value(yield_in_same_for_stmt)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_yield_values(self, is_async=False):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            lazy_value.infer()</span>
<span class="gi">+            for lazy_value in self.get_yield_lazy_values()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def is_generator(self):</span>
<span class="gi">+        return bool(get_yield_exprs(self.inference_state, self.tree_node))</span>

<span class="w"> </span>    def infer(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Created to be used by inheritance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inference_state = self.inference_state</span>
<span class="gi">+        is_coroutine = self.tree_node.parent.type in (&#39;async_stmt&#39;, &#39;async_funcdef&#39;)</span>
<span class="gi">+        from jedi.inference.gradual.base import GenericClass</span>

<span class="gi">+        if is_coroutine:</span>
<span class="gi">+            if self.is_generator():</span>
<span class="gi">+                async_generator_classes = inference_state.typing_module \</span>
<span class="gi">+                    .py__getattribute__(&#39;AsyncGenerator&#39;)</span>

<span class="gd">-class FunctionExecutionContext(BaseFunctionExecutionContext):</span>
<span class="gi">+                yield_values = self.merge_yield_values(is_async=True)</span>
<span class="gi">+                # The contravariant doesn&#39;t seem to be defined.</span>
<span class="gi">+                generics = (yield_values.py__class__(), NO_VALUES)</span>
<span class="gi">+                return ValueSet(</span>
<span class="gi">+                    GenericClass(c, TupleGenericManager(generics))</span>
<span class="gi">+                    for c in async_generator_classes</span>
<span class="gi">+                ).execute_annotation()</span>
<span class="gi">+            else:</span>
<span class="gi">+                async_classes = inference_state.typing_module.py__getattribute__(&#39;Coroutine&#39;)</span>
<span class="gi">+                return_values = self.get_return_values()</span>
<span class="gi">+                # Only the first generic is relevant.</span>
<span class="gi">+                generics = (return_values.py__class__(), NO_VALUES, NO_VALUES)</span>
<span class="gi">+                return ValueSet(</span>
<span class="gi">+                    GenericClass(c, TupleGenericManager(generics)) for c in async_classes</span>
<span class="gi">+                ).execute_annotation()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If there are annotations, prefer them over anything else.</span>
<span class="gi">+            if self.is_generator() and not self.infer_annotations():</span>
<span class="gi">+                return ValueSet([iterable.Generator(inference_state, self)])</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.get_return_values()</span>

<span class="gi">+</span>
<span class="gi">+class FunctionExecutionContext(BaseFunctionExecutionContext):</span>
<span class="w"> </span>    def __init__(self, function_value, arguments):
<span class="w"> </span>        super().__init__(function_value)
<span class="w"> </span>        self._arguments = arguments

<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield FunctionExecutionFilter(</span>
<span class="gi">+            self, self._value,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+            arguments=self._arguments</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def infer_annotations(self):</span>
<span class="gi">+        from jedi.inference.gradual.annotation import infer_return_types</span>
<span class="gi">+        return infer_return_types(self._value, self._arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return [</span>
<span class="gi">+            ParamName(self._value, param.name, self._arguments)</span>
<span class="gi">+            for param in self._value.tree_node.get_params()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>

<span class="w"> </span>class AnonymousFunctionExecution(BaseFunctionExecutionContext):
<span class="gd">-    pass</span>
<span class="gi">+    def infer_annotations(self):</span>
<span class="gi">+        # I don&#39;t think inferring anonymous executions is a big thing.</span>
<span class="gi">+        # Anonymous contexts are mostly there for the user to work in. ~ dave</span>
<span class="gi">+        return NO_VALUES</span>

<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield AnonymousFunctionExecutionFilter(</span>
<span class="gi">+            self, self._value,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return self._value.get_param_names()</span>

<span class="gd">-class OverloadedFunctionValue(FunctionMixin, ValueWrapper):</span>

<span class="gi">+class OverloadedFunctionValue(FunctionMixin, ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, function, overloaded_functions):
<span class="w"> </span>        super().__init__(function)
<span class="w"> </span>        self._overloaded_functions = overloaded_functions
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        debug.dbg(&quot;Execute overloaded function %s&quot;, self._wrapped_value, color=&#39;BLUE&#39;)</span>
<span class="gi">+        function_executions = []</span>
<span class="gi">+        for signature in self.get_signatures():</span>
<span class="gi">+            function_execution = signature.value.as_context(arguments)</span>
<span class="gi">+            function_executions.append(function_execution)</span>
<span class="gi">+            if signature.matches_signature(arguments):</span>
<span class="gi">+                return function_execution.infer()</span>
<span class="gi">+</span>
<span class="gi">+        if self.inference_state.is_analysis:</span>
<span class="gi">+            # In this case we want precision.</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        return ValueSet.from_sets(fe.infer() for fe in function_executions)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signature_functions(self):</span>
<span class="gi">+        return self._overloaded_functions</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        return &#39;Union[%s]&#39; % &#39;, &#39;.join(f.get_type_hint() for f in self._overloaded_functions)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_overload_functions(context, tree_node):</span>
<span class="gi">+    def _is_overload_decorated(funcdef):</span>
<span class="gi">+        if funcdef.parent.type == &#39;decorated&#39;:</span>
<span class="gi">+            decorators = funcdef.parent.children[0]</span>
<span class="gi">+            if decorators.type == &#39;decorator&#39;:</span>
<span class="gi">+                decorators = [decorators]</span>
<span class="gi">+            else:</span>
<span class="gi">+                decorators = decorators.children</span>
<span class="gi">+            for decorator in decorators:</span>
<span class="gi">+                dotted_name = decorator.children[1]</span>
<span class="gi">+                if dotted_name.type == &#39;name&#39; and dotted_name.value == &#39;overload&#39;:</span>
<span class="gi">+                    # TODO check with values if it&#39;s the right overload</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if tree_node.type == &#39;lambdef&#39;:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if _is_overload_decorated(tree_node):</span>
<span class="gi">+        yield tree_node</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        filter = ParserTreeFilter(</span>
<span class="gi">+            context,</span>
<span class="gi">+            until_position=tree_node.start_pos</span>
<span class="gi">+        )</span>
<span class="gi">+        names = filter.get(tree_node.name.value)</span>
<span class="gi">+        assert isinstance(names, list)</span>
<span class="gi">+        if not names:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        found = False</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            funcdef = name.tree_name.parent</span>
<span class="gi">+            if funcdef.type == &#39;funcdef&#39; and _is_overload_decorated(funcdef):</span>
<span class="gi">+                tree_node = funcdef</span>
<span class="gi">+                found = True</span>
<span class="gi">+                yield funcdef</span>
<span class="gi">+</span>
<span class="gi">+        if not found:</span>
<span class="gi">+            break</span>
<span class="gh">diff --git a/jedi/inference/value/instance.py b/jedi/inference/value/instance.py</span>
<span class="gh">index f61454ad..63f220e0 100644</span>
<span class="gd">--- a/jedi/inference/value/instance.py</span>
<span class="gi">+++ b/jedi/inference/value/instance.py</span>
<span class="gu">@@ -1,45 +1,87 @@</span>
<span class="w"> </span>from abc import abstractproperty
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi import settings
<span class="w"> </span>from jedi.inference import compiled
<span class="w"> </span>from jedi.inference.compiled.value import CompiledValueFilter
<span class="w"> </span>from jedi.inference.helpers import values_from_qualified_names, is_big_annoying_library
<span class="w"> </span>from jedi.inference.filters import AbstractFilter, AnonymousFunctionExecutionFilter
<span class="gd">-from jedi.inference.names import ValueName, TreeNameDefinition, ParamName, NameWrapper</span>
<span class="gd">-from jedi.inference.base_value import Value, NO_VALUES, ValueSet, iterator_to_value_set, ValueWrapper</span>
<span class="gi">+from jedi.inference.names import ValueName, TreeNameDefinition, ParamName, \</span>
<span class="gi">+    NameWrapper</span>
<span class="gi">+from jedi.inference.base_value import Value, NO_VALUES, ValueSet, \</span>
<span class="gi">+    iterator_to_value_set, ValueWrapper</span>
<span class="w"> </span>from jedi.inference.lazy_value import LazyKnownValue, LazyKnownValues
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.arguments import ValuesArguments, TreeArgumentsWrapper
<span class="gd">-from jedi.inference.value.function import FunctionValue, FunctionMixin, OverloadedFunctionValue, BaseFunctionExecutionContext, FunctionExecutionContext, FunctionNameInClass</span>
<span class="gi">+from jedi.inference.value.function import \</span>
<span class="gi">+    FunctionValue, FunctionMixin, OverloadedFunctionValue, \</span>
<span class="gi">+    BaseFunctionExecutionContext, FunctionExecutionContext, FunctionNameInClass</span>
<span class="w"> </span>from jedi.inference.value.klass import ClassFilter
<span class="w"> </span>from jedi.inference.value.dynamic_arrays import get_dynamic_array_instance
<span class="w"> </span>from jedi.parser_utils import function_is_staticmethod, function_is_classmethod


<span class="w"> </span>class InstanceExecutedParamName(ParamName):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, instance, function_value, tree_name):
<span class="gd">-        super().__init__(function_value, tree_name, arguments=None)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            function_value, tree_name, arguments=None)</span>
<span class="w"> </span>        self._instance = instance

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self._instance])</span>

<span class="gd">-class AnonymousMethodExecutionFilter(AnonymousFunctionExecutionFilter):</span>
<span class="gi">+    def matches_signature(self):</span>
<span class="gi">+        return True</span>

<span class="gi">+</span>
<span class="gi">+class AnonymousMethodExecutionFilter(AnonymousFunctionExecutionFilter):</span>
<span class="w"> </span>    def __init__(self, instance, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self._instance = instance

<span class="gi">+    def _convert_param(self, param, name):</span>
<span class="gi">+        if param.position_index == 0:</span>
<span class="gi">+            if function_is_classmethod(self._function_value.tree_node):</span>
<span class="gi">+                return InstanceExecutedParamName(</span>
<span class="gi">+                    self._instance.py__class__(),</span>
<span class="gi">+                    self._function_value,</span>
<span class="gi">+                    name</span>
<span class="gi">+                )</span>
<span class="gi">+            elif not function_is_staticmethod(self._function_value.tree_node):</span>
<span class="gi">+                return InstanceExecutedParamName(</span>
<span class="gi">+                    self._instance,</span>
<span class="gi">+                    self._function_value,</span>
<span class="gi">+                    name</span>
<span class="gi">+                )</span>
<span class="gi">+        return super()._convert_param(param, name)</span>

<span class="gd">-class AnonymousMethodExecutionContext(BaseFunctionExecutionContext):</span>

<span class="gi">+class AnonymousMethodExecutionContext(BaseFunctionExecutionContext):</span>
<span class="w"> </span>    def __init__(self, instance, value):
<span class="w"> </span>        super().__init__(value)
<span class="w"> </span>        self.instance = instance

<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        yield AnonymousMethodExecutionFilter(</span>
<span class="gi">+            self.instance, self, self._value,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+        )</span>

<span class="gd">-class MethodExecutionContext(FunctionExecutionContext):</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        param_names = list(self._value.get_param_names())</span>
<span class="gi">+        # set the self name</span>
<span class="gi">+        param_names[0] = InstanceExecutedParamName(</span>
<span class="gi">+            self.instance,</span>
<span class="gi">+            self._value,</span>
<span class="gi">+            param_names[0].tree_name</span>
<span class="gi">+        )</span>
<span class="gi">+        return param_names</span>

<span class="gi">+</span>
<span class="gi">+class MethodExecutionContext(FunctionExecutionContext):</span>
<span class="w"> </span>    def __init__(self, instance, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.instance = instance
<span class="gu">@@ -50,52 +92,305 @@ class AbstractInstanceValue(Value):</span>

<span class="w"> </span>    def __init__(self, inference_state, parent_context, class_value):
<span class="w"> </span>        super().__init__(inference_state, parent_context)
<span class="gi">+        # Generated instances are classes that are just generated by self</span>
<span class="gi">+        # (No arguments) used.</span>
<span class="w"> </span>        self.class_value = class_value

<span class="gi">+    def is_instance(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return self.class_value.get_qualified_names()</span>
<span class="gi">+</span>
<span class="gi">+    def get_annotated_class_object(self):</span>
<span class="gi">+        return self.class_value  # This is the default.</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return self.class_value</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        # Signalize that we don&#39;t know about the bool type.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @abstractproperty</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        call_funcs = self.py__getattribute__(&#39;__call__&#39;).py__get__(self, self.class_value)</span>
<span class="gi">+        return [s.bind(self) for s in call_funcs.get_signatures()]</span>
<span class="gi">+</span>
<span class="gi">+    def get_function_slot_names(self, name):</span>
<span class="gi">+        # Python classes don&#39;t look at the dictionary of the instance when</span>
<span class="gi">+        # looking up `__call__`. This is something that has to do with Python&#39;s</span>
<span class="gi">+        # internal slot system (note: not __slots__, but C slots).</span>
<span class="gi">+        for filter in self.get_filters(include_self_names=False):</span>
<span class="gi">+            names = filter.get(name)</span>
<span class="gi">+            if names:</span>
<span class="gi">+                return names</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def execute_function_slots(self, names, *inferred_args):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            name.infer().execute_with_values(*inferred_args)</span>
<span class="gi">+            for name in names</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        return self.py__name__()</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        names = self.get_function_slot_names(&#39;__getitem__&#39;)</span>
<span class="gi">+        if not names:</span>
<span class="gi">+            return super().py__getitem__(</span>
<span class="gi">+                index_value_set,</span>
<span class="gi">+                contextualized_node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        args = ValuesArguments([index_value_set])</span>
<span class="gi">+        return ValueSet.from_sets(name.infer().execute(args) for name in names)</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        iter_slot_names = self.get_function_slot_names(&#39;__iter__&#39;)</span>
<span class="gi">+        if not iter_slot_names:</span>
<span class="gi">+            return super().py__iter__(contextualized_node)</span>
<span class="gi">+</span>
<span class="gi">+        def iterate():</span>
<span class="gi">+            for generator in self.execute_function_slots(iter_slot_names):</span>
<span class="gi">+                yield from generator.py__next__(contextualized_node)</span>
<span class="gi">+        return iterate()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s of %s&gt;&#39; % (self.__class__.__name__, self.class_value)</span>
<span class="gi">+        return &quot;&lt;%s of %s&gt;&quot; % (self.__class__.__name__, self.class_value)</span>


<span class="w"> </span>class CompiledInstance(AbstractInstanceValue):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, inference_state, parent_context, class_value, arguments</span>
<span class="gd">-        ):</span>
<span class="gi">+    # This is not really a compiled class, it&#39;s just an instance from a</span>
<span class="gi">+    # compiled class.</span>
<span class="gi">+    def __init__(self, inference_state, parent_context, class_value, arguments):</span>
<span class="w"> </span>        super().__init__(inference_state, parent_context, class_value)
<span class="w"> </span>        self._arguments = arguments

<span class="gi">+    def get_filters(self, origin_scope=None, include_self_names=True):</span>
<span class="gi">+        class_value = self.get_annotated_class_object()</span>
<span class="gi">+        class_filters = class_value.get_filters(</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+            is_instance=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        for f in class_filters:</span>
<span class="gi">+            yield CompiledInstanceClassFilter(self, f)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return compiled.CompiledValueName(self, self.class_value.name.string_name)</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>

<span class="w"> </span>class _BaseTreeInstance(AbstractInstanceValue):
<span class="gi">+    @property</span>
<span class="gi">+    def array_type(self):</span>
<span class="gi">+        name = self.class_value.py__name__()</span>
<span class="gi">+        if name in [&#39;list&#39;, &#39;set&#39;, &#39;dict&#39;] \</span>
<span class="gi">+                and self.parent_context.get_root_context().is_builtins_module():</span>
<span class="gi">+            return name</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self.class_value.name.tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, origin_scope=None, include_self_names=True):</span>
<span class="gi">+        class_value = self.get_annotated_class_object()</span>
<span class="gi">+        if include_self_names:</span>
<span class="gi">+            for cls in class_value.py__mro__():</span>
<span class="gi">+                if not cls.is_compiled():</span>
<span class="gi">+                    # In this case we&#39;re excluding compiled objects that are</span>
<span class="gi">+                    # not fake objects. It doesn&#39;t make sense for normal</span>
<span class="gi">+                    # compiled objects to search for self variables.</span>
<span class="gi">+                    yield SelfAttributeFilter(self, class_value, cls.as_context(), origin_scope)</span>
<span class="gi">+</span>
<span class="gi">+        class_filters = class_value.get_filters(</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+            is_instance=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        for f in class_filters:</span>
<span class="gi">+            if isinstance(f, ClassFilter):</span>
<span class="gi">+                yield InstanceClassFilter(self, f)</span>
<span class="gi">+            elif isinstance(f, CompiledValueFilter):</span>
<span class="gi">+                yield CompiledInstanceClassFilter(self, f)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Propably from the metaclass.</span>
<span class="gi">+                yield f</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def create_instance_context(self, class_context, node):</span>
<span class="gi">+        new = node</span>
<span class="gi">+        while True:</span>
<span class="gi">+            func_node = new</span>
<span class="gi">+            new = search_ancestor(new, &#39;funcdef&#39;, &#39;classdef&#39;)</span>
<span class="gi">+            if class_context.tree_node is new:</span>
<span class="gi">+                func = FunctionValue.from_context(class_context, func_node)</span>
<span class="gi">+                bound_method = BoundMethod(self, class_context, func)</span>
<span class="gi">+                if func_node.name.value == &#39;__init__&#39;:</span>
<span class="gi">+                    context = bound_method.as_context(self._arguments)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    context = bound_method.as_context()</span>
<span class="gi">+                break</span>
<span class="gi">+        return context.create_context(node)</span>

<span class="w"> </span>    def py__getattribute__alternatives(self, string_name):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Since nothing was inferred, now check the __getattr__ and
<span class="w"> </span>        __getattribute__ methods. Stubs don&#39;t need to be checked, because
<span class="w"> </span>        they don&#39;t contain any logic.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if self.is_stub():</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        name = compiled.create_simple_object(self.inference_state, string_name)</span>
<span class="gi">+</span>
<span class="gi">+        # This is a little bit special. `__getattribute__` is in Python</span>
<span class="gi">+        # executed before `__getattr__`. But: I know no use case, where</span>
<span class="gi">+        # this could be practical and where Jedi would return wrong types.</span>
<span class="gi">+        # If you ever find something, let me know!</span>
<span class="gi">+        # We are inversing this, because a hand-crafted `__getattribute__`</span>
<span class="gi">+        # could still call another hand-crafted `__getattr__`, but not the</span>
<span class="gi">+        # other way around.</span>
<span class="gi">+        if is_big_annoying_library(self.parent_context):</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        names = (self.get_function_slot_names(&#39;__getattr__&#39;)</span>
<span class="gi">+                 or self.get_function_slot_names(&#39;__getattribute__&#39;))</span>
<span class="gi">+        return self.execute_function_slots(names, name)</span>
<span class="gi">+</span>
<span class="gi">+    def py__next__(self, contextualized_node=None):</span>
<span class="gi">+        name = u&#39;__next__&#39;</span>
<span class="gi">+        next_slot_names = self.get_function_slot_names(name)</span>
<span class="gi">+        if next_slot_names:</span>
<span class="gi">+            yield LazyKnownValues(</span>
<span class="gi">+                self.execute_function_slots(next_slot_names)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            debug.warning(&#39;Instance has no __next__ function in %s.&#39;, self)</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        names = self.get_function_slot_names(&#39;__call__&#39;)</span>
<span class="gi">+        if not names:</span>
<span class="gi">+            # Means the Instance is not callable.</span>
<span class="gi">+            return super().py__call__(arguments)</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet.from_sets(name.infer().execute(arguments) for name in names)</span>

<span class="w"> </span>    def py__get__(self, instance, class_value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        obj may be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Arguments in __get__ descriptors are obj, class.</span>
<span class="gi">+        # `method` is the new parent of the array, don&#39;t know if that&#39;s good.</span>
<span class="gi">+        for cls in self.class_value.py__mro__():</span>
<span class="gi">+            result = cls.py__get__on_class(self, instance, class_value)</span>
<span class="gi">+            if result is not NotImplemented:</span>
<span class="gi">+                return result</span>
<span class="gi">+</span>
<span class="gi">+        names = self.get_function_slot_names(&#39;__get__&#39;)</span>
<span class="gi">+        if names:</span>
<span class="gi">+            if instance is None:</span>
<span class="gi">+                instance = compiled.builtin_from_name(self.inference_state, &#39;None&#39;)</span>
<span class="gi">+            return self.execute_function_slots(names, instance, class_value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ValueSet([self])</span>


<span class="w"> </span>class TreeInstance(_BaseTreeInstance):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, inference_state, parent_context, class_value, arguments</span>
<span class="gd">-        ):</span>
<span class="gd">-        if class_value.py__name__() in [&#39;list&#39;, &#39;set&#39;</span>
<span class="gd">-            ] and parent_context.get_root_context().is_builtins_module():</span>
<span class="gi">+    def __init__(self, inference_state, parent_context, class_value, arguments):</span>
<span class="gi">+        # I don&#39;t think that dynamic append lookups should happen here. That</span>
<span class="gi">+        # sounds more like something that should go to py__iter__.</span>
<span class="gi">+        if class_value.py__name__() in [&#39;list&#39;, &#39;set&#39;] \</span>
<span class="gi">+                and parent_context.get_root_context().is_builtins_module():</span>
<span class="gi">+            # compare the module path with the builtin name.</span>
<span class="w"> </span>            if settings.dynamic_array_additions:
<span class="w"> </span>                arguments = get_dynamic_array_instance(self, arguments)
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(inference_state, parent_context, class_value)
<span class="w"> </span>        self._arguments = arguments
<span class="w"> </span>        self.tree_node = class_value.tree_node

<span class="gi">+    # This can recurse, if the initialization of the class includes a reference</span>
<span class="gi">+    # to itself.</span>
<span class="gi">+    @inference_state_method_cache(default=None)</span>
<span class="gi">+    def _get_annotated_class_object(self):</span>
<span class="gi">+        from jedi.inference.gradual.annotation import py__annotations__, \</span>
<span class="gi">+            infer_type_vars_for_execution</span>
<span class="gi">+</span>
<span class="gi">+        args = InstanceArguments(self, self._arguments)</span>
<span class="gi">+        for signature in self.class_value.py__getattribute__(&#39;__init__&#39;).get_signatures():</span>
<span class="gi">+            # Just take the first result, it should always be one, because we</span>
<span class="gi">+            # control the typeshed code.</span>
<span class="gi">+            funcdef = signature.value.tree_node</span>
<span class="gi">+            if funcdef is None or funcdef.type != &#39;funcdef&#39; \</span>
<span class="gi">+                    or not signature.matches_signature(args):</span>
<span class="gi">+                # First check if the signature even matches, if not we don&#39;t</span>
<span class="gi">+                # need to infer anything.</span>
<span class="gi">+                continue</span>
<span class="gi">+            bound_method = BoundMethod(self, self.class_value.as_context(), signature.value)</span>
<span class="gi">+            all_annotations = py__annotations__(funcdef)</span>
<span class="gi">+            type_var_dict = infer_type_vars_for_execution(bound_method, args, all_annotations)</span>
<span class="gi">+            if type_var_dict:</span>
<span class="gi">+                defined, = self.class_value.define_generics(</span>
<span class="gi">+                    infer_type_vars_for_execution(signature.value, args, all_annotations),</span>
<span class="gi">+                )</span>
<span class="gi">+                debug.dbg(&#39;Inferred instance value as %s&#39;, defined, color=&#39;BLUE&#39;)</span>
<span class="gi">+                return defined</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_annotated_class_object(self):</span>
<span class="gi">+        return self._get_annotated_class_object() or self.class_value</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        values = NO_VALUES</span>
<span class="gi">+        if self.array_type == &#39;dict&#39;:</span>
<span class="gi">+            for i, (key, instance) in enumerate(self._arguments.unpack()):</span>
<span class="gi">+                if key is None and i == 0:</span>
<span class="gi">+                    values |= ValueSet.from_sets(</span>
<span class="gi">+                        v.get_key_values()</span>
<span class="gi">+                        for v in instance.infer()</span>
<span class="gi">+                        if v.array_type == &#39;dict&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+                if key:</span>
<span class="gi">+                    values |= ValueSet([compiled.create_simple_object(</span>
<span class="gi">+                        self.inference_state,</span>
<span class="gi">+                        key,</span>
<span class="gi">+                    )])</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        if self.array_type == &#39;dict&#39;:</span>
<span class="gi">+            # Logic for dict({&#39;foo&#39;: bar}) and dict(foo=bar)</span>
<span class="gi">+            # reversed, because:</span>
<span class="gi">+            # &gt;&gt;&gt; dict({&#39;a&#39;: 1}, a=3)</span>
<span class="gi">+            # {&#39;a&#39;: 3}</span>
<span class="gi">+            # TODO tuple initializations</span>
<span class="gi">+            # &gt;&gt;&gt; dict([(&#39;a&#39;, 4)])</span>
<span class="gi">+            # {&#39;a&#39;: 4}</span>
<span class="gi">+            for key, lazy_context in reversed(list(self._arguments.unpack())):</span>
<span class="gi">+                if key is None:</span>
<span class="gi">+                    values = ValueSet.from_sets(</span>
<span class="gi">+                        dct_value.py__simple_getitem__(index)</span>
<span class="gi">+                        for dct_value in lazy_context.infer()</span>
<span class="gi">+                        if dct_value.array_type == &#39;dict&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if values:</span>
<span class="gi">+                        return values</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if key == index:</span>
<span class="gi">+                        return lazy_context.infer()</span>
<span class="gi">+        return super().py__simple_getitem__(index)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s of %s(%s)&gt;&#39; % (self.__class__.__name__, self.</span>
<span class="gd">-            class_value, self._arguments)</span>
<span class="gi">+        return &quot;&lt;%s of %s(%s)&gt;&quot; % (self.__class__.__name__, self.class_value,</span>
<span class="gi">+                                   self._arguments)</span>


<span class="w"> </span>class AnonymousInstance(_BaseTreeInstance):
<span class="gu">@@ -103,48 +398,134 @@ class AnonymousInstance(_BaseTreeInstance):</span>


<span class="w"> </span>class CompiledInstanceName(NameWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    @iterator_to_value_set</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        for result_value in self._wrapped_name.infer():</span>
<span class="gi">+            if result_value.api_type == &#39;function&#39;:</span>
<span class="gi">+                yield CompiledBoundMethod(result_value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield result_value</span>


<span class="w"> </span>class CompiledInstanceClassFilter(AbstractFilter):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, instance, f):
<span class="w"> </span>        self._instance = instance
<span class="w"> </span>        self._class_filter = f

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return self._convert(self._class_filter.get(name))</span>

<span class="gd">-class BoundMethod(FunctionMixin, ValueWrapper):</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._convert(self._class_filter.values())</span>
<span class="gi">+</span>
<span class="gi">+    def _convert(self, names):</span>
<span class="gi">+        return [CompiledInstanceName(n) for n in names]</span>

<span class="gi">+</span>
<span class="gi">+class BoundMethod(FunctionMixin, ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, instance, class_context, function):
<span class="w"> </span>        super().__init__(function)
<span class="w"> </span>        self.instance = instance
<span class="w"> </span>        self._class_context = class_context

<span class="gi">+    def is_bound_method(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return FunctionNameInClass(</span>
<span class="gi">+            self._class_context,</span>
<span class="gi">+            super().name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        c, = values_from_qualified_names(self.inference_state, &#39;types&#39;, &#39;MethodType&#39;)</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def _get_arguments(self, arguments):</span>
<span class="gi">+        assert arguments is not None</span>
<span class="gi">+        return InstanceArguments(self.instance, arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self, arguments=None):</span>
<span class="gi">+        if arguments is None:</span>
<span class="gi">+            return AnonymousMethodExecutionContext(self.instance, self)</span>
<span class="gi">+</span>
<span class="gi">+        arguments = self._get_arguments(arguments)</span>
<span class="gi">+        return MethodExecutionContext(self.instance, self, arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        if isinstance(self._wrapped_value, OverloadedFunctionValue):</span>
<span class="gi">+            return self._wrapped_value.py__call__(self._get_arguments(arguments))</span>
<span class="gi">+</span>
<span class="gi">+        function_execution = self.as_context(arguments)</span>
<span class="gi">+        return function_execution.infer()</span>
<span class="gi">+</span>
<span class="gi">+    def get_signature_functions(self):</span>
<span class="gi">+        return [</span>
<span class="gi">+            BoundMethod(self.instance, self._class_context, f)</span>
<span class="gi">+            for f in self._wrapped_value.get_signature_functions()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [sig.bind(self) for sig in super().get_signatures()]</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._wrapped_value)


<span class="w"> </span>class CompiledBoundMethod(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def is_bound_method(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [sig.bind(self) for sig in self._wrapped_value.get_signatures()]</span>


<span class="w"> </span>class SelfName(TreeNameDefinition):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This name calculates the parent_context lazily.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, instance, class_context, tree_name):
<span class="w"> </span>        self._instance = instance
<span class="w"> </span>        self.class_context = class_context
<span class="w"> </span>        self.tree_name = tree_name

<span class="gi">+    @property</span>
<span class="gi">+    def parent_context(self):</span>
<span class="gi">+        return self._instance.create_instance_context(self.class_context, self.tree_name)</span>

<span class="gd">-class LazyInstanceClassName(NameWrapper):</span>
<span class="gi">+    def get_defining_qualified_value(self):</span>
<span class="gi">+        return self._instance</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        stmt = search_ancestor(self.tree_name, &#39;expr_stmt&#39;)</span>
<span class="gi">+        if stmt is not None:</span>
<span class="gi">+            if stmt.children[1].type == &quot;annassign&quot;:</span>
<span class="gi">+                from jedi.inference.gradual.annotation import infer_annotation</span>
<span class="gi">+                values = infer_annotation(</span>
<span class="gi">+                    self.parent_context, stmt.children[1].children[1]</span>
<span class="gi">+                ).execute_annotation()</span>
<span class="gi">+                if values:</span>
<span class="gi">+                    return values</span>
<span class="gi">+        return super().infer()</span>

<span class="gi">+</span>
<span class="gi">+class LazyInstanceClassName(NameWrapper):</span>
<span class="w"> </span>    def __init__(self, instance, class_member_name):
<span class="w"> </span>        super().__init__(class_member_name)
<span class="w"> </span>        self._instance = instance

<span class="gi">+    @iterator_to_value_set</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        for result_value in self._wrapped_name.infer():</span>
<span class="gi">+            yield from result_value.py__get__(self._instance, self._instance.py__class__())</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return self.infer().get_signatures()</span>
<span class="gi">+</span>
<span class="gi">+    def get_defining_qualified_value(self):</span>
<span class="gi">+        return self._instance</span>
<span class="gi">+</span>

<span class="w"> </span>class InstanceClassFilter(AbstractFilter):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -152,11 +533,22 @@ class InstanceClassFilter(AbstractFilter):</span>
<span class="w"> </span>    resulting names in LazyInstanceClassName. The idea is that the class name
<span class="w"> </span>    filtering can be very flexible and always be reflected in instances.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, instance, class_filter):
<span class="w"> </span>        self._instance = instance
<span class="w"> </span>        self._class_filter = class_filter

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return self._convert(self._class_filter.get(name))</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._convert(self._class_filter.values())</span>
<span class="gi">+</span>
<span class="gi">+    def _convert(self, names):</span>
<span class="gi">+        return [</span>
<span class="gi">+            LazyInstanceClassName(self._instance, n)</span>
<span class="gi">+            for n in names</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s for %s&gt;&#39; % (self.__class__.__name__, self._class_filter)

<span class="gu">@@ -165,15 +557,54 @@ class SelfAttributeFilter(ClassFilter):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This class basically filters all the use cases where `self.*` was assigned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, instance, instance_class, node_context, origin_scope):
<span class="gd">-        super().__init__(class_value=instance_class, node_context=</span>
<span class="gd">-            node_context, origin_scope=origin_scope, is_instance=True)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            class_value=instance_class,</span>
<span class="gi">+            node_context=node_context,</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+            is_instance=True,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._instance = instance

<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        start, end = self._parser_scope.start_pos, self._parser_scope.end_pos</span>
<span class="gi">+        names = [n for n in names if start &lt; n.start_pos &lt; end]</span>
<span class="gi">+        return self._filter_self_names(names)</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_self_names(self, names):</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            trailer = name.parent</span>
<span class="gi">+            if trailer.type == &#39;trailer&#39; \</span>
<span class="gi">+                    and len(trailer.parent.children) == 2 \</span>
<span class="gi">+                    and trailer.children[0] == &#39;.&#39;:</span>
<span class="gi">+                if name.is_definition() and self._access_possible(name):</span>
<span class="gi">+                    # TODO filter non-self assignments instead of this bad</span>
<span class="gi">+                    #      filter.</span>
<span class="gi">+                    if self._is_in_right_scope(trailer.parent.children[0], name):</span>
<span class="gi">+                        yield name</span>
<span class="gi">+</span>
<span class="gi">+    def _is_in_right_scope(self, self_name, name):</span>
<span class="gi">+        self_context = self._node_context.create_context(self_name)</span>
<span class="gi">+        names = self_context.goto(self_name, position=self_name.start_pos)</span>
<span class="gi">+        return any(</span>
<span class="gi">+            n.api_type == &#39;param&#39;</span>
<span class="gi">+            and n.tree_name.get_definition().position_index == 0</span>
<span class="gi">+            and n.parent_context.tree_node is self._parser_scope</span>
<span class="gi">+            for n in names</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_names(self, names):</span>
<span class="gi">+        return [SelfName(self._instance, self._node_context, name) for name in names]</span>
<span class="gi">+</span>
<span class="gi">+    def _check_flows(self, names):</span>
<span class="gi">+        return names</span>

<span class="gd">-class InstanceArguments(TreeArgumentsWrapper):</span>

<span class="gi">+class InstanceArguments(TreeArgumentsWrapper):</span>
<span class="w"> </span>    def __init__(self, instance, arguments):
<span class="w"> </span>        super().__init__(arguments)
<span class="w"> </span>        self.instance = instance
<span class="gi">+</span>
<span class="gi">+    def unpack(self, func=None):</span>
<span class="gi">+        yield None, LazyKnownValue(self.instance)</span>
<span class="gi">+        yield from self._wrapped_arguments.unpack(func)</span>
<span class="gh">diff --git a/jedi/inference/value/iterable.py b/jedi/inference/value/iterable.py</span>
<span class="gh">index 6b4bb3e8..7cc37173 100644</span>
<span class="gd">--- a/jedi/inference/value/iterable.py</span>
<span class="gi">+++ b/jedi/inference/value/iterable.py</span>
<span class="gu">@@ -4,55 +4,221 @@ iterators in general.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from jedi.inference import compiled
<span class="w"> </span>from jedi.inference import analysis
<span class="gd">-from jedi.inference.lazy_value import LazyKnownValue, LazyKnownValues, LazyTreeValue</span>
<span class="gd">-from jedi.inference.helpers import get_int_or_none, is_string, reraise_getitem_errors, SimpleGetItemNotFound</span>
<span class="gi">+from jedi.inference.lazy_value import LazyKnownValue, LazyKnownValues, \</span>
<span class="gi">+    LazyTreeValue</span>
<span class="gi">+from jedi.inference.helpers import get_int_or_none, is_string, \</span>
<span class="gi">+    reraise_getitem_errors, SimpleGetItemNotFound</span>
<span class="w"> </span>from jedi.inference.utils import safe_property, to_list
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.filters import LazyAttributeOverwrite, publish_method
<span class="gd">-from jedi.inference.base_value import ValueSet, Value, NO_VALUES, ContextualizedNode, iterate_values, sentinel, LazyValueWrapper</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, Value, NO_VALUES, \</span>
<span class="gi">+    ContextualizedNode, iterate_values, sentinel, \</span>
<span class="gi">+    LazyValueWrapper</span>
<span class="w"> </span>from jedi.parser_utils import get_sync_comp_fors
<span class="w"> </span>from jedi.inference.context import CompForContext
<span class="w"> </span>from jedi.inference.value.dynamic_arrays import check_array_additions


<span class="w"> </span>class IterableMixin:
<span class="gi">+    def py__next__(self, contextualized_node=None):</span>
<span class="gi">+        return self.py__iter__(contextualized_node)</span>
<span class="gi">+</span>
<span class="gi">+    def py__stop_iteration_returns(self):</span>
<span class="gi">+        return ValueSet([compiled.builtin_from_name(self.inference_state, &#39;None&#39;)])</span>
<span class="gi">+</span>
<span class="gi">+    # At the moment, safe values are simple values like &quot;foo&quot;, 1 and not</span>
<span class="gi">+    # lists/dicts. Therefore as a small speed optimization we can just do the</span>
<span class="gi">+    # default instead of resolving the lazy wrapped values, that are just</span>
<span class="gi">+    # doing this in the end as well.</span>
<span class="gi">+    # This mostly speeds up patterns like `sys.version_info &gt;= (3, 0)` in</span>
<span class="gi">+    # typeshed.</span>
<span class="w"> </span>    get_safe_value = Value.get_safe_value


<span class="w"> </span>class GeneratorBase(LazyAttributeOverwrite, IterableMixin):
<span class="w"> </span>    array_type = None

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        instance, = self._get_cls().execute_annotation()</span>
<span class="gi">+        return instance</span>
<span class="gi">+</span>
<span class="gi">+    def _get_cls(self):</span>
<span class="gi">+        generator, = self.inference_state.typing_module.py__getattribute__(&#39;Generator&#39;)</span>
<span class="gi">+        return generator</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;__iter__&#39;)</span>
<span class="gi">+    def _iter(self, arguments):</span>
<span class="gi">+        return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;send&#39;)</span>
<span class="gi">+    @publish_method(&#39;__next__&#39;)</span>
<span class="gi">+    def _next(self, arguments):</span>
<span class="gi">+        return ValueSet.from_sets(lazy_value.infer() for lazy_value in self.py__iter__())</span>
<span class="gi">+</span>
<span class="gi">+    def py__stop_iteration_returns(self):</span>
<span class="gi">+        return ValueSet([compiled.builtin_from_name(self.inference_state, &#39;None&#39;)])</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return compiled.CompiledValueName(self, &#39;Generator&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_annotated_class_object(self):</span>
<span class="gi">+        from jedi.inference.gradual.generics import TupleGenericManager</span>
<span class="gi">+        gen_values = self.merge_types_of_iterate().py__class__()</span>
<span class="gi">+        gm = TupleGenericManager((gen_values, NO_VALUES, NO_VALUES))</span>
<span class="gi">+        return self._get_cls().with_generics(gm)</span>
<span class="gi">+</span>

<span class="w"> </span>class Generator(GeneratorBase):
<span class="w"> </span>    &quot;&quot;&quot;Handling of `yield` functions.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, func_execution_context):
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self._func_execution_context = func_execution_context

<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        iterators = self._func_execution_context.infer_annotations()</span>
<span class="gi">+        if iterators:</span>
<span class="gi">+            return iterators.iterate(contextualized_node)</span>
<span class="gi">+        return self._func_execution_context.get_yield_lazy_values()</span>
<span class="gi">+</span>
<span class="gi">+    def py__stop_iteration_returns(self):</span>
<span class="gi">+        return self._func_execution_context.get_return_values()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s of %s&gt;&#39; % (type(self).__name__, self.</span>
<span class="gd">-            _func_execution_context)</span>
<span class="gi">+        return &quot;&lt;%s of %s&gt;&quot; % (type(self).__name__, self._func_execution_context)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def comprehension_from_atom(inference_state, value, atom):</span>
<span class="gi">+    bracket = atom.children[0]</span>
<span class="gi">+    test_list_comp = atom.children[1]</span>
<span class="gi">+</span>
<span class="gi">+    if bracket == &#39;{&#39;:</span>
<span class="gi">+        if atom.children[1].children[1] == &#39;:&#39;:</span>
<span class="gi">+            sync_comp_for = test_list_comp.children[3]</span>
<span class="gi">+            if sync_comp_for.type == &#39;comp_for&#39;:</span>
<span class="gi">+                sync_comp_for = sync_comp_for.children[1]</span>
<span class="gi">+</span>
<span class="gi">+            return DictComprehension(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                value,</span>
<span class="gi">+                sync_comp_for_node=sync_comp_for,</span>
<span class="gi">+                key_node=test_list_comp.children[0],</span>
<span class="gi">+                value_node=test_list_comp.children[2],</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            cls = SetComprehension</span>
<span class="gi">+    elif bracket == &#39;(&#39;:</span>
<span class="gi">+        cls = GeneratorComprehension</span>
<span class="gi">+    elif bracket == &#39;[&#39;:</span>
<span class="gi">+        cls = ListComprehension</span>
<span class="gi">+</span>
<span class="gi">+    sync_comp_for = test_list_comp.children[1]</span>
<span class="gi">+    if sync_comp_for.type == &#39;comp_for&#39;:</span>
<span class="gi">+        sync_comp_for = sync_comp_for.children[1]</span>
<span class="gi">+</span>
<span class="gi">+    return cls(</span>
<span class="gi">+        inference_state,</span>
<span class="gi">+        defining_context=value,</span>
<span class="gi">+        sync_comp_for_node=sync_comp_for,</span>
<span class="gi">+        entry_node=test_list_comp.children[0],</span>
<span class="gi">+    )</span>


<span class="w"> </span>class ComprehensionMixin:
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def _get_comp_for_context(self, parent_context, comp_for):</span>
<span class="gi">+        return CompForContext(parent_context, comp_for)</span>
<span class="gi">+</span>
<span class="gi">+    def _nested(self, comp_fors, parent_context=None):</span>
<span class="gi">+        comp_for = comp_fors[0]</span>
<span class="gi">+</span>
<span class="gi">+        is_async = comp_for.parent.type == &#39;comp_for&#39;</span>
<span class="gi">+</span>
<span class="gi">+        input_node = comp_for.children[3]</span>
<span class="gi">+        parent_context = parent_context or self._defining_context</span>
<span class="gi">+        input_types = parent_context.infer_node(input_node)</span>
<span class="gi">+</span>
<span class="gi">+        cn = ContextualizedNode(parent_context, input_node)</span>
<span class="gi">+        iterated = input_types.iterate(cn, is_async=is_async)</span>
<span class="gi">+        exprlist = comp_for.children[1]</span>
<span class="gi">+        for i, lazy_value in enumerate(iterated):</span>
<span class="gi">+            types = lazy_value.infer()</span>
<span class="gi">+            dct = unpack_tuple_to_dict(parent_context, types, exprlist)</span>
<span class="gi">+            context = self._get_comp_for_context(</span>
<span class="gi">+                parent_context,</span>
<span class="gi">+                comp_for,</span>
<span class="gi">+            )</span>
<span class="gi">+            with context.predefine_names(comp_for, dct):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield from self._nested(comp_fors[1:], context)</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    iterated = context.infer_node(self._entry_node)</span>
<span class="gi">+                    if self.array_type == &#39;dict&#39;:</span>
<span class="gi">+                        yield iterated, context.infer_node(self._value_node)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield iterated</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=[])</span>
<span class="gi">+    @to_list</span>
<span class="gi">+    def _iterate(self):</span>
<span class="gi">+        comp_fors = tuple(get_sync_comp_fors(self._sync_comp_for_node))</span>
<span class="gi">+        yield from self._nested(comp_fors)</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        for set_ in self._iterate():</span>
<span class="gi">+            yield LazyKnownValues(set_)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s of %s&gt;&#39; % (type(self).__name__, self._sync_comp_for_node)</span>
<span class="gi">+        return &quot;&lt;%s of %s&gt;&quot; % (type(self).__name__, self._sync_comp_for_node)</span>


<span class="w"> </span>class _DictMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def _get_generics(self):</span>
<span class="gi">+        return tuple(c_set.py__class__() for c_set in self.get_mapping_item_values())</span>


<span class="w"> </span>class Sequence(LazyAttributeOverwrite, IterableMixin):
<span class="w"> </span>    api_type = &#39;instance&#39;

<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return compiled.CompiledValueName(self, self.array_type)</span>

<span class="gd">-class _BaseComprehension(ComprehensionMixin):</span>
<span class="gi">+    def _get_generics(self):</span>
<span class="gi">+        return (self.merge_types_of_iterate().py__class__(),)</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=())</span>
<span class="gi">+    def _cached_generics(self):</span>
<span class="gi">+        return self._get_generics()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        from jedi.inference.gradual.base import GenericClass</span>
<span class="gi">+        from jedi.inference.gradual.generics import TupleGenericManager</span>
<span class="gi">+        klass = compiled.builtin_from_name(self.inference_state, self.array_type)</span>
<span class="gi">+        c, = GenericClass(</span>
<span class="gi">+            klass,</span>
<span class="gi">+            TupleGenericManager(self._cached_generics())</span>
<span class="gi">+        ).execute_annotation()</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        return None  # We don&#39;t know the length, because of appends.</span>
<span class="gi">+</span>
<span class="gi">+    @safe_property</span>
<span class="gi">+    def parent(self):</span>
<span class="gi">+        return self.inference_state.builtins_module</span>

<span class="gd">-    def __init__(self, inference_state, defining_context,</span>
<span class="gd">-        sync_comp_for_node, entry_node):</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        if self.array_type == &#39;dict&#39;:</span>
<span class="gi">+            return self._dict_values()</span>
<span class="gi">+        return iterate_values(ValueSet([self]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _BaseComprehension(ComprehensionMixin):</span>
<span class="gi">+    def __init__(self, inference_state, defining_context, sync_comp_for_node, entry_node):</span>
<span class="w"> </span>        assert sync_comp_for_node.type == &#39;sync_comp_for&#39;
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self._defining_context = defining_context
<span class="gu">@@ -63,6 +229,15 @@ class _BaseComprehension(ComprehensionMixin):</span>
<span class="w"> </span>class ListComprehension(_BaseComprehension, Sequence):
<span class="w"> </span>    array_type = &#39;list&#39;

<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        if isinstance(index, slice):</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+        all_types = list(self.py__iter__())</span>
<span class="gi">+        with reraise_getitem_errors(IndexError, TypeError):</span>
<span class="gi">+            lazy_value = all_types[index]</span>
<span class="gi">+        return lazy_value.infer()</span>
<span class="gi">+</span>

<span class="w"> </span>class SetComprehension(_BaseComprehension, Sequence):
<span class="w"> </span>    array_type = &#39;set&#39;
<span class="gu">@@ -73,14 +248,19 @@ class GeneratorComprehension(_BaseComprehension, GeneratorBase):</span>


<span class="w"> </span>class _DictKeyMixin:
<span class="gd">-    pass</span>
<span class="gi">+    # TODO merge with _DictMixin?</span>
<span class="gi">+    def get_mapping_item_values(self):</span>
<span class="gi">+        return self._dict_keys(), self._dict_values()</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        # TODO merge with _dict_keys?</span>
<span class="gi">+        return self._dict_keys()</span>


<span class="w"> </span>class DictComprehension(ComprehensionMixin, Sequence, _DictKeyMixin):
<span class="w"> </span>    array_type = &#39;dict&#39;

<span class="gd">-    def __init__(self, inference_state, defining_context,</span>
<span class="gd">-        sync_comp_for_node, key_node, value_node):</span>
<span class="gi">+    def __init__(self, inference_state, defining_context, sync_comp_for_node, key_node, value_node):</span>
<span class="w"> </span>        assert sync_comp_for_node.type == &#39;sync_comp_for&#39;
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self._defining_context = defining_context
<span class="gu">@@ -88,65 +268,226 @@ class DictComprehension(ComprehensionMixin, Sequence, _DictKeyMixin):</span>
<span class="w"> </span>        self._entry_node = key_node
<span class="w"> </span>        self._value_node = value_node

<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        for keys, values in self._iterate():</span>
<span class="gi">+            yield LazyKnownValues(keys)</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        for keys, values in self._iterate():</span>
<span class="gi">+            for k in keys:</span>
<span class="gi">+                # Be careful in the future if refactoring, index could be a</span>
<span class="gi">+                # slice object.</span>
<span class="gi">+                if k.get_safe_value(default=object()) == index:</span>
<span class="gi">+                    return values</span>
<span class="gi">+        raise SimpleGetItemNotFound()</span>
<span class="gi">+</span>
<span class="gi">+    def _dict_keys(self):</span>
<span class="gi">+        return ValueSet.from_sets(keys for keys, values in self._iterate())</span>
<span class="gi">+</span>
<span class="gi">+    def _dict_values(self):</span>
<span class="gi">+        return ValueSet.from_sets(values for keys, values in self._iterate())</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;values&#39;)</span>
<span class="gi">+    def _imitate_values(self, arguments):</span>
<span class="gi">+        lazy_value = LazyKnownValues(self._dict_values())</span>
<span class="gi">+        return ValueSet([FakeList(self.inference_state, [lazy_value])])</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;items&#39;)</span>
<span class="gi">+    def _imitate_items(self, arguments):</span>
<span class="gi">+        lazy_values = [</span>
<span class="gi">+            LazyKnownValue(</span>
<span class="gi">+                FakeTuple(</span>
<span class="gi">+                    self.inference_state,</span>
<span class="gi">+                    [LazyKnownValues(key),</span>
<span class="gi">+                     LazyKnownValues(value)]</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            for key, value in self._iterate()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([FakeList(self.inference_state, lazy_values)])</span>
<span class="gi">+</span>
<span class="gi">+    def exact_key_items(self):</span>
<span class="gi">+        # NOTE: A smarter thing can probably done here to achieve better</span>
<span class="gi">+        # completions, but at least like this jedi doesn&#39;t crash</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>

<span class="w"> </span>class SequenceLiteralValue(Sequence):
<span class="w"> </span>    _TUPLE_LIKE = &#39;testlist_star_expr&#39;, &#39;testlist&#39;, &#39;subscriptlist&#39;
<span class="gd">-    mapping = {&#39;(&#39;: &#39;tuple&#39;, &#39;[&#39;: &#39;list&#39;, &#39;{&#39;: &#39;set&#39;}</span>
<span class="gi">+    mapping = {&#39;(&#39;: &#39;tuple&#39;,</span>
<span class="gi">+               &#39;[&#39;: &#39;list&#39;,</span>
<span class="gi">+               &#39;{&#39;: &#39;set&#39;}</span>

<span class="w"> </span>    def __init__(self, inference_state, defining_context, atom):
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self.atom = atom
<span class="w"> </span>        self._defining_context = defining_context
<span class="gi">+</span>
<span class="w"> </span>        if self.atom.type in self._TUPLE_LIKE:
<span class="w"> </span>            self.array_type = &#39;tuple&#39;
<span class="w"> </span>        else:
<span class="w"> </span>            self.array_type = SequenceLiteralValue.mapping[atom.children[0]]
<span class="w"> </span>            &quot;&quot;&quot;The builtin name of the array (list, set, tuple or dict).&quot;&quot;&quot;

<span class="gi">+    def _get_generics(self):</span>
<span class="gi">+        if self.array_type == &#39;tuple&#39;:</span>
<span class="gi">+            return tuple(x.infer().py__class__() for x in self.py__iter__())</span>
<span class="gi">+        return super()._get_generics()</span>
<span class="gi">+</span>
<span class="w"> </span>    def py__simple_getitem__(self, index):
<span class="w"> </span>        &quot;&quot;&quot;Here the index is an int/str. Raises IndexError/KeyError.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(index, slice):</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+        else:</span>
<span class="gi">+            with reraise_getitem_errors(TypeError, KeyError, IndexError):</span>
<span class="gi">+                node = self.get_tree_entries()[index]</span>
<span class="gi">+            if node == &#39;:&#39; or node.type == &#39;subscript&#39;:</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            return self._defining_context.infer_node(node)</span>

<span class="w"> </span>    def py__iter__(self, contextualized_node=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        While values returns the possible values for any array field, this
<span class="w"> </span>        function returns the value for a certain index.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in self.get_tree_entries():</span>
<span class="gi">+            if node == &#39;:&#39; or node.type == &#39;subscript&#39;:</span>
<span class="gi">+                # TODO this should probably use at least part of the code</span>
<span class="gi">+                #      of infer_subscript_list.</span>
<span class="gi">+                yield LazyKnownValue(Slice(self._defining_context, None, None, None))</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield LazyTreeValue(self._defining_context, node)</span>
<span class="gi">+        yield from check_array_additions(self._defining_context, self)</span>
<span class="gi">+</span>
<span class="gi">+    def py__len__(self):</span>
<span class="gi">+        # This function is not really used often. It&#39;s more of a try.</span>
<span class="gi">+        return len(self.get_tree_entries())</span>
<span class="gi">+</span>
<span class="gi">+    def get_tree_entries(self):</span>
<span class="gi">+        c = self.atom.children</span>
<span class="gi">+</span>
<span class="gi">+        if self.atom.type in self._TUPLE_LIKE:</span>
<span class="gi">+            return c[::2]</span>
<span class="gi">+</span>
<span class="gi">+        array_node = c[1]</span>
<span class="gi">+        if array_node in (&#39;]&#39;, &#39;}&#39;, &#39;)&#39;):</span>
<span class="gi">+            return []  # Direct closing bracket, doesn&#39;t contain items.</span>
<span class="gi">+</span>
<span class="gi">+        if array_node.type == &#39;testlist_comp&#39;:</span>
<span class="gi">+            # filter out (for now) pep 448 single-star unpacking</span>
<span class="gi">+            return [value for value in array_node.children[::2]</span>
<span class="gi">+                    if value.type != &quot;star_expr&quot;]</span>
<span class="gi">+        elif array_node.type == &#39;dictorsetmaker&#39;:</span>
<span class="gi">+            kv = []</span>
<span class="gi">+            iterator = iter(array_node.children)</span>
<span class="gi">+            for key in iterator:</span>
<span class="gi">+                if key == &quot;**&quot;:</span>
<span class="gi">+                    # dict with pep 448 double-star unpacking</span>
<span class="gi">+                    # for now ignoring the values imported by **</span>
<span class="gi">+                    next(iterator)</span>
<span class="gi">+                    next(iterator, None)  # Possible comma.</span>
<span class="gi">+                else:</span>
<span class="gi">+                    op = next(iterator, None)</span>
<span class="gi">+                    if op is None or op == &#39;,&#39;:</span>
<span class="gi">+                        if key.type == &quot;star_expr&quot;:</span>
<span class="gi">+                            # pep 448 single-star unpacking</span>
<span class="gi">+                            # for now ignoring values imported by *</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            kv.append(key)  # A set.</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        assert op == &#39;:&#39;  # A dict.</span>
<span class="gi">+                        kv.append((key, next(iterator)))</span>
<span class="gi">+                        next(iterator, None)  # Possible comma.</span>
<span class="gi">+            return kv</span>
<span class="gi">+        else:</span>
<span class="gi">+            if array_node.type == &quot;star_expr&quot;:</span>
<span class="gi">+                # pep 448 single-star unpacking</span>
<span class="gi">+                # for now ignoring values imported by *</span>
<span class="gi">+                return []</span>
<span class="gi">+            else:</span>
<span class="gi">+                return [array_node]</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s of %s&gt;&#39; % (self.__class__.__name__, self.atom)</span>
<span class="gi">+        return &quot;&lt;%s of %s&gt;&quot; % (self.__class__.__name__, self.atom)</span>


<span class="w"> </span>class DictLiteralValue(_DictMixin, SequenceLiteralValue, _DictKeyMixin):
<span class="w"> </span>    array_type = &#39;dict&#39;

<span class="w"> </span>    def __init__(self, inference_state, defining_context, atom):
<span class="gi">+        # Intentionally don&#39;t call the super class. This is definitely a sign</span>
<span class="gi">+        # that the architecture is bad and we should refactor.</span>
<span class="w"> </span>        Sequence.__init__(self, inference_state)
<span class="w"> </span>        self._defining_context = defining_context
<span class="w"> </span>        self.atom = atom

<span class="w"> </span>    def py__simple_getitem__(self, index):
<span class="w"> </span>        &quot;&quot;&quot;Here the index is an int/str. Raises IndexError/KeyError.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        compiled_value_index = compiled.create_simple_object(self.inference_state, index)</span>
<span class="gi">+        for key, value in self.get_tree_entries():</span>
<span class="gi">+            for k in self._defining_context.infer_node(key):</span>
<span class="gi">+                for key_v in k.execute_operation(compiled_value_index, &#39;==&#39;):</span>
<span class="gi">+                    if key_v.get_safe_value():</span>
<span class="gi">+                        return self._defining_context.infer_node(value)</span>
<span class="gi">+        raise SimpleGetItemNotFound(&#39;No key found in dictionary %s.&#39; % self)</span>

<span class="w"> </span>    def py__iter__(self, contextualized_node=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        While values returns the possible values for any array field, this
<span class="w"> </span>        function returns the value for a certain index.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get keys.</span>
<span class="gi">+        types = NO_VALUES</span>
<span class="gi">+        for k, _ in self.get_tree_entries():</span>
<span class="gi">+            types |= self._defining_context.infer_node(k)</span>
<span class="gi">+        # We don&#39;t know which dict index comes first, therefore always</span>
<span class="gi">+        # yield all the types.</span>
<span class="gi">+        for _ in types:</span>
<span class="gi">+            yield LazyKnownValues(types)</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;values&#39;)</span>
<span class="gi">+    def _imitate_values(self, arguments):</span>
<span class="gi">+        lazy_value = LazyKnownValues(self._dict_values())</span>
<span class="gi">+        return ValueSet([FakeList(self.inference_state, [lazy_value])])</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;items&#39;)</span>
<span class="gi">+    def _imitate_items(self, arguments):</span>
<span class="gi">+        lazy_values = [</span>
<span class="gi">+            LazyKnownValue(FakeTuple(</span>
<span class="gi">+                self.inference_state,</span>
<span class="gi">+                (LazyTreeValue(self._defining_context, key_node),</span>
<span class="gi">+                 LazyTreeValue(self._defining_context, value_node))</span>
<span class="gi">+            )) for key_node, value_node in self.get_tree_entries()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        return ValueSet([FakeList(self.inference_state, lazy_values)])</span>

<span class="w"> </span>    def exact_key_items(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a generator of tuples like dict.items(), where the key is
<span class="w"> </span>        resolved (as a string) and the values are still lazy values.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key_node, value in self.get_tree_entries():</span>
<span class="gi">+            for key in self._defining_context.infer_node(key_node):</span>
<span class="gi">+                if is_string(key):</span>
<span class="gi">+                    yield key.get_safe_value(), LazyTreeValue(self._defining_context, value)</span>

<span class="gi">+    def _dict_values(self):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            self._defining_context.infer_node(v)</span>
<span class="gi">+            for k, v in self.get_tree_entries()</span>
<span class="gi">+        )</span>

<span class="gd">-class _FakeSequence(Sequence):</span>
<span class="gi">+    def _dict_keys(self):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            self._defining_context.infer_node(k)</span>
<span class="gi">+            for k, v in self.get_tree_entries()</span>
<span class="gi">+        )</span>

<span class="gi">+</span>
<span class="gi">+class _FakeSequence(Sequence):</span>
<span class="w"> </span>    def __init__(self, inference_state, lazy_value_list):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        type should be one of &quot;tuple&quot;, &quot;list&quot;
<span class="gu">@@ -154,8 +495,22 @@ class _FakeSequence(Sequence):</span>
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self._lazy_value_list = lazy_value_list

<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        if isinstance(index, slice):</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+        with reraise_getitem_errors(IndexError, TypeError):</span>
<span class="gi">+            lazy_value = self._lazy_value_list[index]</span>
<span class="gi">+        return lazy_value.infer()</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        return self._lazy_value_list</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        return bool(len(self._lazy_value_list))</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s of %s&gt;&#39; % (type(self).__name__, self._lazy_value_list)</span>
<span class="gi">+        return &quot;&lt;%s of %s&gt;&quot; % (type(self).__name__, self._lazy_value_list)</span>


<span class="w"> </span>class FakeTuple(_FakeSequence):
<span class="gu">@@ -173,37 +528,120 @@ class FakeDict(_DictMixin, Sequence, _DictKeyMixin):</span>
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self._dct = dct

<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        for key in self._dct:</span>
<span class="gi">+            yield LazyKnownValue(compiled.create_simple_object(self.inference_state, key))</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        with reraise_getitem_errors(KeyError, TypeError):</span>
<span class="gi">+            lazy_value = self._dct[index]</span>
<span class="gi">+        return lazy_value.infer()</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;values&#39;)</span>
<span class="gi">+    def _values(self, arguments):</span>
<span class="gi">+        return ValueSet([FakeTuple(</span>
<span class="gi">+            self.inference_state,</span>
<span class="gi">+            [LazyKnownValues(self._dict_values())]</span>
<span class="gi">+        )])</span>
<span class="gi">+</span>
<span class="gi">+    def _dict_values(self):</span>
<span class="gi">+        return ValueSet.from_sets(lazy_value.infer() for lazy_value in self._dct.values())</span>
<span class="gi">+</span>
<span class="gi">+    def _dict_keys(self):</span>
<span class="gi">+        return ValueSet.from_sets(lazy_value.infer() for lazy_value in self.py__iter__())</span>
<span class="gi">+</span>
<span class="gi">+    def exact_key_items(self):</span>
<span class="gi">+        return self._dct.items()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._dct)


<span class="w"> </span>class MergedArray(Sequence):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, arrays):
<span class="w"> </span>        super().__init__(inference_state)
<span class="w"> </span>        self.array_type = arrays[-1].array_type
<span class="w"> </span>        self._arrays = arrays

<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        for array in self._arrays:</span>
<span class="gi">+            yield from array.py__iter__()</span>
<span class="gi">+</span>
<span class="gi">+    def py__simple_getitem__(self, index):</span>
<span class="gi">+        return ValueSet.from_sets(lazy_value.infer() for lazy_value in self.py__iter__())</span>
<span class="gi">+</span>

<span class="w"> </span>def unpack_tuple_to_dict(context, types, exprlist):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Unpacking tuple assignments in for statements and expr_stmts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if exprlist.type == &#39;name&#39;:</span>
<span class="gi">+        return {exprlist.value: types}</span>
<span class="gi">+    elif exprlist.type == &#39;atom&#39; and exprlist.children[0] in (&#39;(&#39;, &#39;[&#39;):</span>
<span class="gi">+        return unpack_tuple_to_dict(context, types, exprlist.children[1])</span>
<span class="gi">+    elif exprlist.type in (&#39;testlist&#39;, &#39;testlist_comp&#39;, &#39;exprlist&#39;,</span>
<span class="gi">+                           &#39;testlist_star_expr&#39;):</span>
<span class="gi">+        dct = {}</span>
<span class="gi">+        parts = iter(exprlist.children[::2])</span>
<span class="gi">+        n = 0</span>
<span class="gi">+        for lazy_value in types.iterate(ContextualizedNode(context, exprlist)):</span>
<span class="gi">+            n += 1</span>
<span class="gi">+            try:</span>
<span class="gi">+                part = next(parts)</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                analysis.add(context, &#39;value-error-too-many-values&#39;, part,</span>
<span class="gi">+                             message=&quot;ValueError: too many values to unpack (expected %s)&quot; % n)</span>
<span class="gi">+            else:</span>
<span class="gi">+                dct.update(unpack_tuple_to_dict(context, lazy_value.infer(), part))</span>
<span class="gi">+        has_parts = next(parts, None)</span>
<span class="gi">+        if types and has_parts is not None:</span>
<span class="gi">+            analysis.add(context, &#39;value-error-too-few-values&#39;, has_parts,</span>
<span class="gi">+                         message=&quot;ValueError: need more than %s values to unpack&quot; % n)</span>
<span class="gi">+        return dct</span>
<span class="gi">+    elif exprlist.type == &#39;power&#39; or exprlist.type == &#39;atom_expr&#39;:</span>
<span class="gi">+        # Something like ``arr[x], var = ...``.</span>
<span class="gi">+        # This is something that is not yet supported, would also be difficult</span>
<span class="gi">+        # to write into a dict.</span>
<span class="gi">+        return {}</span>
<span class="gi">+    elif exprlist.type == &#39;star_expr&#39;:  # `a, *b, c = x` type unpackings</span>
<span class="gi">+        # Currently we&#39;re not supporting them.</span>
<span class="gi">+        return {}</span>
<span class="gi">+    raise NotImplementedError</span>


<span class="w"> </span>class Slice(LazyValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, python_context, start, stop, step):
<span class="w"> </span>        self.inference_state = python_context.inference_state
<span class="w"> </span>        self._context = python_context
<span class="gi">+        # All of them are either a Precedence or None.</span>
<span class="w"> </span>        self._start = start
<span class="w"> </span>        self._stop = stop
<span class="w"> </span>        self._step = step

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        value = compiled.builtin_from_name(self._context.inference_state, &#39;slice&#39;)</span>
<span class="gi">+        slice_value, = value.execute_with_values()</span>
<span class="gi">+        return slice_value</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_safe_value(self, default=sentinel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Imitate CompiledValue.obj behavior and return a ``builtin.slice()``
<span class="w"> </span>        object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def get(element):</span>
<span class="gi">+            if element is None:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            result = self._context.infer_node(element)</span>
<span class="gi">+            if len(result) != 1:</span>
<span class="gi">+                # For simplicity, we want slices to be clear defined with just</span>
<span class="gi">+                # one type.  Otherwise we will return an empty slice object.</span>
<span class="gi">+                raise IndexError</span>
<span class="gi">+</span>
<span class="gi">+            value, = result</span>
<span class="gi">+            return get_int_or_none(value)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return slice(get(self._start), get(self._stop), get(self._step))</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return slice(None, None, None)</span>
<span class="gh">diff --git a/jedi/inference/value/klass.py b/jedi/inference/value/klass.py</span>
<span class="gh">index b88b0996..d4074f36 100644</span>
<span class="gd">--- a/jedi/inference/value/klass.py</span>
<span class="gi">+++ b/jedi/inference/value/klass.py</span>
<span class="gu">@@ -37,14 +37,17 @@ py__doc__()                            Returns the docstring for a value.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from jedi import debug
<span class="gd">-from jedi.parser_utils import get_cached_parent_scope, expr_is_dotted, function_is_property</span>
<span class="gd">-from jedi.inference.cache import inference_state_method_cache, CachedMetaClass, inference_state_method_generator_cache</span>
<span class="gi">+from jedi.parser_utils import get_cached_parent_scope, expr_is_dotted, \</span>
<span class="gi">+    function_is_property</span>
<span class="gi">+from jedi.inference.cache import inference_state_method_cache, CachedMetaClass, \</span>
<span class="gi">+    inference_state_method_generator_cache</span>
<span class="w"> </span>from jedi.inference import compiled
<span class="w"> </span>from jedi.inference.lazy_value import LazyKnownValues, LazyTreeValue
<span class="w"> </span>from jedi.inference.filters import ParserTreeFilter
<span class="w"> </span>from jedi.inference.names import TreeNameDefinition, ValueName
<span class="w"> </span>from jedi.inference.arguments import unpack_arglist, ValuesArguments
<span class="gd">-from jedi.inference.base_value import ValueSet, iterator_to_value_set, NO_VALUES</span>
<span class="gi">+from jedi.inference.base_value import ValueSet, iterator_to_value_set, \</span>
<span class="gi">+    NO_VALUES</span>
<span class="w"> </span>from jedi.inference.context import ClassContext
<span class="w"> </span>from jedi.inference.value.function import FunctionAndClassBase
<span class="w"> </span>from jedi.inference.gradual.generics import LazyGenericManager, TupleGenericManager
<span class="gu">@@ -52,26 +55,336 @@ from jedi.plugins import plugin_manager</span>


<span class="w"> </span>class ClassName(TreeNameDefinition):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, class_value, tree_name, name_context, apply_decorators):
<span class="w"> </span>        super().__init__(name_context, tree_name)
<span class="w"> </span>        self._apply_decorators = apply_decorators
<span class="w"> </span>        self._class_value = class_value

<span class="gi">+    @iterator_to_value_set</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        # We&#39;re using a different value to infer, so we cannot call super().</span>
<span class="gi">+        from jedi.inference.syntax_tree import tree_name_to_values</span>
<span class="gi">+        inferred = tree_name_to_values(</span>
<span class="gi">+            self.parent_context.inference_state, self.parent_context, self.tree_name)</span>

<span class="gd">-class ClassFilter(ParserTreeFilter):</span>
<span class="gi">+        for result_value in inferred:</span>
<span class="gi">+            if self._apply_decorators:</span>
<span class="gi">+                yield from result_value.py__get__(instance=None, class_value=self._class_value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield result_value</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def api_type(self):</span>
<span class="gi">+        type_ = super().api_type</span>
<span class="gi">+        if type_ == &#39;function&#39;:</span>
<span class="gi">+            definition = self.tree_name.get_definition()</span>
<span class="gi">+            if definition is None:</span>
<span class="gi">+                return type_</span>
<span class="gi">+            if function_is_property(definition):</span>
<span class="gi">+                # This essentially checks if there is an @property before</span>
<span class="gi">+                # the function. @property could be something different, but</span>
<span class="gi">+                # any programmer that redefines property as something that</span>
<span class="gi">+                # is not really a property anymore, should be shot. (i.e.</span>
<span class="gi">+                # this is a heuristic).</span>
<span class="gi">+                return &#39;property&#39;</span>
<span class="gi">+        return type_</span>

<span class="gi">+</span>
<span class="gi">+class ClassFilter(ParserTreeFilter):</span>
<span class="w"> </span>    def __init__(self, class_value, node_context=None, until_position=None,
<span class="gd">-        origin_scope=None, is_instance=False):</span>
<span class="gd">-        super().__init__(class_value.as_context(), node_context,</span>
<span class="gd">-            until_position=until_position, origin_scope=origin_scope)</span>
<span class="gi">+                 origin_scope=None, is_instance=False):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            class_value.as_context(), node_context,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._class_value = class_value
<span class="w"> </span>        self._is_instance = is_instance

<span class="gi">+    def _convert_names(self, names):</span>
<span class="gi">+        return [</span>
<span class="gi">+            ClassName(</span>
<span class="gi">+                class_value=self._class_value,</span>
<span class="gi">+                tree_name=name,</span>
<span class="gi">+                name_context=self._node_context,</span>
<span class="gi">+                apply_decorators=not self._is_instance,</span>
<span class="gi">+            ) for name in names</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _equals_origin_scope(self):</span>
<span class="gi">+        node = self._origin_scope</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            if node == self._parser_scope or node == self.parent_context:</span>
<span class="gi">+                return True</span>
<span class="gi">+            node = get_cached_parent_scope(self._parso_cache_node, node)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _access_possible(self, name):</span>
<span class="gi">+        # Filter for name mangling of private variables like __foo</span>
<span class="gi">+        return not name.value.startswith(&#39;__&#39;) or name.value.endswith(&#39;__&#39;) \</span>
<span class="gi">+            or self._equals_origin_scope()</span>
<span class="gi">+</span>
<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        names = super()._filter(names)</span>
<span class="gi">+        return [name for name in names if self._access_possible(name)]</span>
<span class="gi">+</span>

<span class="w"> </span>class ClassMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def is_class_mixin(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        from jedi.inference.value import TreeInstance</span>
<span class="gi">+</span>
<span class="gi">+        from jedi.inference.gradual.typing import TypedDict</span>
<span class="gi">+        if self.is_typeddict():</span>
<span class="gi">+            return ValueSet([TypedDict(self)])</span>
<span class="gi">+        return ValueSet([TreeInstance(self.inference_state, self.parent_context, self, arguments)])</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return compiled.builtin_from_name(self.inference_state, &#39;type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self.tree_node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.name.string_name</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_generator_cache()</span>
<span class="gi">+    def py__mro__(self):</span>
<span class="gi">+        mro = [self]</span>
<span class="gi">+        yield self</span>
<span class="gi">+        # TODO Do a proper mro resolution. Currently we are just listing</span>
<span class="gi">+        # classes. However, it&#39;s a complicated algorithm.</span>
<span class="gi">+        for lazy_cls in self.py__bases__():</span>
<span class="gi">+            # TODO there&#39;s multiple different mro paths possible if this yields</span>
<span class="gi">+            # multiple possibilities. Could be changed to be more correct.</span>
<span class="gi">+            for cls in lazy_cls.infer():</span>
<span class="gi">+                # TODO detect for TypeError: duplicate base class str,</span>
<span class="gi">+                # e.g.  `class X(str, str): pass`</span>
<span class="gi">+                try:</span>
<span class="gi">+                    mro_method = cls.py__mro__</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    # TODO add a TypeError like:</span>
<span class="gi">+                    &quot;&quot;&quot;</span>
<span class="gi">+                    &gt;&gt;&gt; class Y(lambda: test): pass</span>
<span class="gi">+                    Traceback (most recent call last):</span>
<span class="gi">+                      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="gi">+                    TypeError: function() argument 1 must be code, not str</span>
<span class="gi">+                    &gt;&gt;&gt; class Y(1): pass</span>
<span class="gi">+                    Traceback (most recent call last):</span>
<span class="gi">+                      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="gi">+                    TypeError: int() takes at most 2 arguments (3 given)</span>
<span class="gi">+                    &quot;&quot;&quot;</span>
<span class="gi">+                    debug.warning(&#39;Super class of %s is not a class: %s&#39;, self, cls)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    for cls_new in mro_method():</span>
<span class="gi">+                        if cls_new not in mro:</span>
<span class="gi">+                            mro.append(cls_new)</span>
<span class="gi">+                            yield cls_new</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, origin_scope=None, is_instance=False,</span>
<span class="gi">+                    include_metaclasses=True, include_type_when_class=True):</span>
<span class="gi">+        if include_metaclasses:</span>
<span class="gi">+            metaclasses = self.get_metaclasses()</span>
<span class="gi">+            if metaclasses:</span>
<span class="gi">+                yield from self.get_metaclass_filters(metaclasses, is_instance)</span>
<span class="gi">+</span>
<span class="gi">+        for cls in self.py__mro__():</span>
<span class="gi">+            if cls.is_compiled():</span>
<span class="gi">+                yield from cls.get_filters(is_instance=is_instance)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield ClassFilter(</span>
<span class="gi">+                    self, node_context=cls.as_context(),</span>
<span class="gi">+                    origin_scope=origin_scope,</span>
<span class="gi">+                    is_instance=is_instance</span>
<span class="gi">+                )</span>
<span class="gi">+        if not is_instance and include_type_when_class:</span>
<span class="gi">+            from jedi.inference.compiled import builtin_from_name</span>
<span class="gi">+            type_ = builtin_from_name(self.inference_state, &#39;type&#39;)</span>
<span class="gi">+            assert isinstance(type_, ClassValue)</span>
<span class="gi">+            if type_ != self:</span>
<span class="gi">+                # We are not using execute_with_values here, because the</span>
<span class="gi">+                # plugin function for type would get executed instead of an</span>
<span class="gi">+                # instance creation.</span>
<span class="gi">+                args = ValuesArguments([])</span>
<span class="gi">+                for instance in type_.py__call__(args):</span>
<span class="gi">+                    instance_filters = instance.get_filters()</span>
<span class="gi">+                    # Filter out self filters</span>
<span class="gi">+                    next(instance_filters, None)</span>
<span class="gi">+                    next(instance_filters, None)</span>
<span class="gi">+                    x = next(instance_filters, None)</span>
<span class="gi">+                    assert x is not None</span>
<span class="gi">+                    yield x</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        # Since calling staticmethod without a function is illegal, the Jedi</span>
<span class="gi">+        # plugin doesn&#39;t return anything. Therefore call directly and get what</span>
<span class="gi">+        # we want: An instance of staticmethod.</span>
<span class="gi">+        metaclasses = self.get_metaclasses()</span>
<span class="gi">+        if metaclasses:</span>
<span class="gi">+            sigs = self.get_metaclass_signatures(metaclasses)</span>
<span class="gi">+            if sigs:</span>
<span class="gi">+                return sigs</span>
<span class="gi">+        args = ValuesArguments([])</span>
<span class="gi">+        init_funcs = self.py__call__(args).py__getattribute__(&#39;__init__&#39;)</span>
<span class="gi">+        return [sig.bind(self) for sig in init_funcs.get_signatures()]</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return ClassContext(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        if add_class_info:</span>
<span class="gi">+            return &#39;Type[%s]&#39; % self.py__name__()</span>
<span class="gi">+        return self.py__name__()</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=False)</span>
<span class="gi">+    def is_typeddict(self):</span>
<span class="gi">+        # TODO Do a proper mro resolution. Currently we are just listing</span>
<span class="gi">+        # classes. However, it&#39;s a complicated algorithm.</span>
<span class="gi">+        from jedi.inference.gradual.typing import TypedDictClass</span>
<span class="gi">+        for lazy_cls in self.py__bases__():</span>
<span class="gi">+            if not isinstance(lazy_cls, LazyTreeValue):</span>
<span class="gi">+                return False</span>
<span class="gi">+            tree_node = lazy_cls.data</span>
<span class="gi">+            # Only resolve simple classes, stuff like Iterable[str] are more</span>
<span class="gi">+            # intensive to resolve and if generics are involved, we know it&#39;s</span>
<span class="gi">+            # not a TypedDict.</span>
<span class="gi">+            if not expr_is_dotted(tree_node):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            for cls in lazy_cls.infer():</span>
<span class="gi">+                if isinstance(cls, TypedDictClass):</span>
<span class="gi">+                    return True</span>
<span class="gi">+                try:</span>
<span class="gi">+                    method = cls.is_typeddict</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    # We&#39;re only dealing with simple classes, so just returning</span>
<span class="gi">+                    # here should be fine. This only happens with e.g. compiled</span>
<span class="gi">+                    # classes.</span>
<span class="gi">+                    return False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if method():</span>
<span class="gi">+                        return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        from jedi.inference.gradual.base import GenericClass</span>
<span class="gi">+        if not index_value_set:</span>
<span class="gi">+            debug.warning(&#39;Class indexes inferred to nothing. Returning class instead&#39;)</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            GenericClass(</span>
<span class="gi">+                self,</span>
<span class="gi">+                LazyGenericManager(</span>
<span class="gi">+                    context_of_index=contextualized_node.context,</span>
<span class="gi">+                    index_value=index_value,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            for index_value in index_value_set</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def with_generics(self, generics_tuple):</span>
<span class="gi">+        from jedi.inference.gradual.base import GenericClass</span>
<span class="gi">+        return GenericClass(</span>
<span class="gi">+            self,</span>
<span class="gi">+            TupleGenericManager(generics_tuple)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def define_generics(self, type_var_dict):</span>
<span class="gi">+        from jedi.inference.gradual.base import GenericClass</span>
<span class="gi">+</span>
<span class="gi">+        def remap_type_vars():</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            The TypeVars in the resulting classes have sometimes different names</span>
<span class="gi">+            and we need to check for that, e.g. a signature can be:</span>
<span class="gi">+</span>
<span class="gi">+            def iter(iterable: Iterable[_T]) -&gt; Iterator[_T]: ...</span>
<span class="gi">+</span>
<span class="gi">+            However, the iterator is defined as Iterator[_T_co], which means it has</span>
<span class="gi">+            a different type var name.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            for type_var in self.list_type_vars():</span>
<span class="gi">+                yield type_var_dict.get(type_var.py__name__(), NO_VALUES)</span>
<span class="gi">+</span>
<span class="gi">+        if type_var_dict:</span>
<span class="gi">+            return ValueSet([GenericClass(</span>
<span class="gi">+                self,</span>
<span class="gi">+                TupleGenericManager(tuple(remap_type_vars()))</span>
<span class="gi">+            )])</span>
<span class="gi">+        return ValueSet({self})</span>


<span class="w"> </span>class ClassValue(ClassMixin, FunctionAndClassBase, metaclass=CachedMetaClass):
<span class="w"> </span>    api_type = &#39;class&#39;
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def list_type_vars(self):</span>
<span class="gi">+        found = []</span>
<span class="gi">+        arglist = self.tree_node.get_super_arglist()</span>
<span class="gi">+        if arglist is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        for stars, node in unpack_arglist(arglist):</span>
<span class="gi">+            if stars:</span>
<span class="gi">+                continue  # These are not relevant for this search.</span>
<span class="gi">+</span>
<span class="gi">+            from jedi.inference.gradual.annotation import find_unknown_type_vars</span>
<span class="gi">+            for type_var in find_unknown_type_vars(self.parent_context, node):</span>
<span class="gi">+                if type_var not in found:</span>
<span class="gi">+                    # The order matters and it&#39;s therefore a list.</span>
<span class="gi">+                    found.append(type_var)</span>
<span class="gi">+        return found</span>
<span class="gi">+</span>
<span class="gi">+    def _get_bases_arguments(self):</span>
<span class="gi">+        arglist = self.tree_node.get_super_arglist()</span>
<span class="gi">+        if arglist:</span>
<span class="gi">+            from jedi.inference import arguments</span>
<span class="gi">+            return arguments.TreeArguments(self.inference_state, self.parent_context, arglist)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=())</span>
<span class="gi">+    def py__bases__(self):</span>
<span class="gi">+        args = self._get_bases_arguments()</span>
<span class="gi">+        if args is not None:</span>
<span class="gi">+            lst = [value for key, value in args.unpack() if key is None]</span>
<span class="gi">+            if lst:</span>
<span class="gi">+                return lst</span>
<span class="gi">+</span>
<span class="gi">+        if self.py__name__() == &#39;object&#39; \</span>
<span class="gi">+                and self.parent_context.is_builtins_module():</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [LazyKnownValues(</span>
<span class="gi">+            self.inference_state.builtins_module.py__getattribute__(&#39;object&#39;)</span>
<span class="gi">+        )]</span>
<span class="gi">+</span>
<span class="gi">+    @plugin_manager.decorate()</span>
<span class="gi">+    def get_metaclass_filters(self, metaclasses, is_instance):</span>
<span class="gi">+        debug.warning(&#39;Unprocessed metaclass %s&#39;, metaclasses)</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache(default=NO_VALUES)</span>
<span class="gi">+    def get_metaclasses(self):</span>
<span class="gi">+        args = self._get_bases_arguments()</span>
<span class="gi">+        if args is not None:</span>
<span class="gi">+            m = [value for key, value in args.unpack() if key == &#39;metaclass&#39;]</span>
<span class="gi">+            metaclasses = ValueSet.from_sets(lazy_value.infer() for lazy_value in m)</span>
<span class="gi">+            metaclasses = ValueSet(m for m in metaclasses if m.is_class())</span>
<span class="gi">+            if metaclasses:</span>
<span class="gi">+                return metaclasses</span>
<span class="gi">+</span>
<span class="gi">+        for lazy_base in self.py__bases__():</span>
<span class="gi">+            for value in lazy_base.infer():</span>
<span class="gi">+                if value.is_class():</span>
<span class="gi">+                    values = value.get_metaclasses()</span>
<span class="gi">+                    if values:</span>
<span class="gi">+                        return values</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    @plugin_manager.decorate()</span>
<span class="gi">+    def get_metaclass_signatures(self, metaclasses):</span>
<span class="gi">+        return []</span>
<span class="gh">diff --git a/jedi/inference/value/module.py b/jedi/inference/value/module.py</span>
<span class="gh">index c79b2dda..6461cb4b 100644</span>
<span class="gd">--- a/jedi/inference/value/module.py</span>
<span class="gi">+++ b/jedi/inference/value/module.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Optional
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.names import AbstractNameDefinition, ModuleName
<span class="w"> </span>from jedi.inference.filters import GlobalNameFilter, ParserTreeFilter, DictFilter, MergedFilter
<span class="gu">@@ -24,51 +25,166 @@ class _ModuleAttributeName(AbstractNameDefinition):</span>
<span class="w"> </span>        self.string_name = string_name
<span class="w"> </span>        self._string_value = string_value

<span class="gi">+    def infer(self):</span>
<span class="gi">+        if self._string_value is not None:</span>
<span class="gi">+            s = self._string_value</span>
<span class="gi">+            return ValueSet([</span>
<span class="gi">+                create_simple_object(self.parent_context.inference_state, s)</span>
<span class="gi">+            ])</span>
<span class="gi">+        return compiled.get_string_value_set(self.parent_context.inference_state)</span>

<span class="gd">-class SubModuleDictMixin:</span>

<span class="gi">+class SubModuleDictMixin:</span>
<span class="w"> </span>    @inference_state_method_cache()
<span class="w"> </span>    def sub_modules_dict(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Lists modules in the directory of this module (if this module is a
<span class="w"> </span>        package).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        names = {}</span>
<span class="gi">+        if self.is_package():</span>
<span class="gi">+            mods = self.inference_state.compiled_subprocess.iter_module_names(</span>
<span class="gi">+                self.py__path__()</span>
<span class="gi">+            )</span>
<span class="gi">+            for name in mods:</span>
<span class="gi">+                # It&#39;s obviously a relative import to the current module.</span>
<span class="gi">+                names[name] = SubModuleName(self.as_context(), name)</span>
<span class="gi">+</span>
<span class="gi">+        # In the case of an import like `from x.` we don&#39;t need to</span>
<span class="gi">+        # add all the variables, this is only about submodules.</span>
<span class="gi">+        return names</span>


<span class="w"> </span>class ModuleMixin(SubModuleDictMixin):
<span class="w"> </span>    _module_name_class = ModuleName

<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        yield MergedFilter(</span>
<span class="gi">+            ParserTreeFilter(</span>
<span class="gi">+                parent_context=self.as_context(),</span>
<span class="gi">+                origin_scope=origin_scope</span>
<span class="gi">+            ),</span>
<span class="gi">+            GlobalNameFilter(self.as_context()),</span>
<span class="gi">+        )</span>
<span class="gi">+        yield DictFilter(self.sub_modules_dict())</span>
<span class="gi">+        yield DictFilter(self._module_attributes_dict())</span>
<span class="gi">+        yield from self.iter_star_filters()</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        c, = values_from_qualified_names(self.inference_state, &#39;types&#39;, &#39;ModuleType&#39;)</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def is_module(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @property  # type: ignore[misc]</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return self._module_name_class(self, self.string_names[-1])</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def _module_attributes_dict(self):</span>
<span class="gi">+        names = [&#39;__package__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;]</span>
<span class="gi">+        # All the additional module attributes are strings.</span>
<span class="gi">+        dct = dict((n, _ModuleAttributeName(self, n)) for n in names)</span>
<span class="gi">+        path = self.py__file__()</span>
<span class="gi">+        if path is not None:</span>
<span class="gi">+            dct[&#39;__file__&#39;] = _ModuleAttributeName(self, &#39;__file__&#39;, str(path))</span>
<span class="gi">+        return dct</span>
<span class="gi">+</span>
<span class="gi">+    def iter_star_filters(self):</span>
<span class="gi">+        for star_module in self.star_imports():</span>
<span class="gi">+            f = next(star_module.get_filters(), None)</span>
<span class="gi">+            assert f is not None</span>
<span class="gi">+            yield f</span>
<span class="gi">+</span>
<span class="gi">+    # I&#39;m not sure if the star import cache is really that effective anymore</span>
<span class="gi">+    # with all the other really fast import caches. Recheck. Also we would need</span>
<span class="gi">+    # to push the star imports into InferenceState.module_cache, if we reenable this.</span>
<span class="gi">+    @inference_state_method_cache([])</span>
<span class="gi">+    def star_imports(self):</span>
<span class="gi">+        from jedi.inference.imports import Importer</span>
<span class="gi">+</span>
<span class="gi">+        modules = []</span>
<span class="gi">+        module_context = self.as_context()</span>
<span class="gi">+        for i in self.tree_node.iter_imports():</span>
<span class="gi">+            if i.is_star_import():</span>
<span class="gi">+                new = Importer(</span>
<span class="gi">+                    self.inference_state,</span>
<span class="gi">+                    import_path=i.get_paths()[-1],</span>
<span class="gi">+                    module_context=module_context,</span>
<span class="gi">+                    level=i.level</span>
<span class="gi">+                ).follow()</span>
<span class="gi">+</span>
<span class="gi">+                for module in new:</span>
<span class="gi">+                    if isinstance(module, ModuleValue):</span>
<span class="gi">+                        modules += module.star_imports()</span>
<span class="gi">+                modules += new</span>
<span class="gi">+        return modules</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_qualified_names(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        A module doesn&#39;t have a qualified name, but it&#39;s important to note that
<span class="w"> </span>        it&#39;s reachable and not `None`. With this information we can add
<span class="w"> </span>        qualified names on top for all value children.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ()</span>


<span class="w"> </span>class ModuleValue(ModuleMixin, TreeValue):
<span class="w"> </span>    api_type = &#39;module&#39;

<span class="gd">-    def __init__(self, inference_state, module_node, code_lines, file_io=</span>
<span class="gd">-        None, string_names=None, is_package=False):</span>
<span class="gd">-        super().__init__(inference_state, parent_context=None, tree_node=</span>
<span class="gd">-            module_node)</span>
<span class="gi">+    def __init__(self, inference_state, module_node, code_lines, file_io=None,</span>
<span class="gi">+                 string_names=None, is_package=False):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            inference_state,</span>
<span class="gi">+            parent_context=None,</span>
<span class="gi">+            tree_node=module_node</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.file_io = file_io
<span class="w"> </span>        if file_io is None:
<span class="w"> </span>            self._path: Optional[Path] = None
<span class="w"> </span>        else:
<span class="w"> </span>            self._path = file_io.path
<span class="gd">-        self.string_names = string_names</span>
<span class="gi">+        self.string_names = string_names  # Optional[Tuple[str, ...]]</span>
<span class="w"> </span>        self.code_lines = code_lines
<span class="w"> </span>        self._is_package = is_package

<span class="gd">-    def py__file__(self) -&gt;Optional[Path]:</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        if self._path is not None and self._path.suffix == &#39;.pyi&#39;:</span>
<span class="gi">+            # Currently this is the way how we identify stubs when e.g. goto is</span>
<span class="gi">+            # used in them. This could be changed if stubs would be identified</span>
<span class="gi">+            # sooner and used as StubModuleValue.</span>
<span class="gi">+            return True</span>
<span class="gi">+        return super().is_stub()</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        if self.string_names is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return &#39;.&#39;.join(self.string_names)</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        In contrast to Python&#39;s __file__ can be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._path is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return self._path.absolute()</span>
<span class="gi">+</span>
<span class="gi">+    def is_package(self):</span>
<span class="gi">+        return self._is_package</span>
<span class="gi">+</span>
<span class="gi">+    def py__package__(self):</span>
<span class="gi">+        if self.string_names is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        if self._is_package:</span>
<span class="gi">+            return self.string_names</span>
<span class="gi">+        return self.string_names[:-1]</span>

<span class="w"> </span>    def py__path__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,9 +192,39 @@ class ModuleValue(ModuleMixin, TreeValue):</span>
<span class="w"> </span>        is a list of paths (strings).
<span class="w"> </span>        Returns None if the module is not a package.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._is_package:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # A namespace package is typically auto generated and ~10 lines long.</span>
<span class="gi">+        first_few_lines = &#39;&#39;.join(self.code_lines[:50])</span>
<span class="gi">+        # these are strings that need to be used for namespace packages,</span>
<span class="gi">+        # the first one is ``pkgutil``, the second ``pkg_resources``.</span>
<span class="gi">+        options = (&#39;declare_namespace(__name__)&#39;, &#39;extend_path(__path__&#39;)</span>
<span class="gi">+        if options[0] in first_few_lines or options[1] in first_few_lines:</span>
<span class="gi">+            # It is a namespace, now try to find the rest of the</span>
<span class="gi">+            # modules on sys_path or whatever the search_path is.</span>
<span class="gi">+            paths = set()</span>
<span class="gi">+            for s in self.inference_state.get_sys_path():</span>
<span class="gi">+                other = os.path.join(s, self.name.string_name)</span>
<span class="gi">+                if os.path.isdir(other):</span>
<span class="gi">+                    paths.add(other)</span>
<span class="gi">+            if paths:</span>
<span class="gi">+                return list(paths)</span>
<span class="gi">+            # Nested namespace packages will not be supported. Nobody ever</span>
<span class="gi">+            # asked for it and in Python 3 they are there without using all the</span>
<span class="gi">+            # crap above.</span>
<span class="gi">+</span>
<span class="gi">+        # Default to the of this file.</span>
<span class="gi">+        file = self.py__file__()</span>
<span class="gi">+        assert file is not None  # Shouldn&#39;t be a package in the first place.</span>
<span class="gi">+        return [os.path.dirname(file)]</span>
<span class="gi">+</span>
<span class="gi">+    def _as_context(self):</span>
<span class="gi">+        return ModuleContext(self)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;%s: %s@%s-%s is_stub=%s&gt;&#39; % (self.__class__.__name__, self</span>
<span class="gd">-            .py__name__(), self.tree_node.start_pos[0], self.tree_node.</span>
<span class="gd">-            end_pos[0], self.is_stub())</span>
<span class="gi">+        return &quot;&lt;%s: %s@%s-%s is_stub=%s&gt;&quot; % (</span>
<span class="gi">+            self.__class__.__name__, self.py__name__(),</span>
<span class="gi">+            self.tree_node.start_pos[0], self.tree_node.end_pos[0],</span>
<span class="gi">+            self.is_stub()</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/jedi/inference/value/namespace.py b/jedi/inference/value/namespace.py</span>
<span class="gh">index 33eb07fc..11737cc9 100644</span>
<span class="gd">--- a/jedi/inference/value/namespace.py</span>
<span class="gi">+++ b/jedi/inference/value/namespace.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Optional
<span class="gi">+</span>
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.filters import DictFilter
<span class="w"> </span>from jedi.inference.names import ValueNameMixin, AbstractNameDefinition
<span class="gu">@@ -13,7 +14,6 @@ class ImplicitNSName(ValueNameMixin, AbstractNameDefinition):</span>
<span class="w"> </span>    Accessing names for implicit namespace packages should infer to nothing.
<span class="w"> </span>    This object will prevent Jedi from raising exceptions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, implicit_ns_value, string_name):
<span class="w"> </span>        self._value = implicit_ns_value
<span class="w"> </span>        self.string_name = string_name
<span class="gu">@@ -32,10 +32,43 @@ class ImplicitNamespaceValue(Value, SubModuleDictMixin):</span>
<span class="w"> </span>        self.string_names = string_names
<span class="w"> </span>        self._paths = paths

<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        yield DictFilter(self.sub_modules_dict())</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return ()</span>
<span class="gi">+</span>
<span class="gi">+    @property  # type: ignore[misc]</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        string_name = self.py__package__()[-1]</span>
<span class="gi">+        return ImplicitNSName(self, string_name)</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>    def py__package__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the fullname
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.string_names</span>
<span class="gi">+</span>
<span class="gi">+    def py__path__(self):</span>
<span class="gi">+        return self._paths</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return &#39;.&#39;.join(self.string_names)</span>
<span class="gi">+</span>
<span class="gi">+    def is_namespace(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_package(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def as_context(self):</span>
<span class="gi">+        return NamespaceContext(self)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.py__name__())
<span class="gh">diff --git a/jedi/parser_utils.py b/jedi/parser_utils.py</span>
<span class="gh">index 75857eda..3c7fa151 100644</span>
<span class="gd">--- a/jedi/parser_utils.py</span>
<span class="gi">+++ b/jedi/parser_utils.py</span>
<span class="gu">@@ -3,22 +3,69 @@ import textwrap</span>
<span class="w"> </span>from ast import literal_eval
<span class="w"> </span>from inspect import cleandoc
<span class="w"> </span>from weakref import WeakKeyDictionary
<span class="gi">+</span>
<span class="w"> </span>from parso.python import tree
<span class="w"> </span>from parso.cache import parser_cache
<span class="w"> </span>from parso import split_lines
<span class="gd">-_EXECUTE_NODES = {&#39;funcdef&#39;, &#39;classdef&#39;, &#39;import_from&#39;, &#39;import_name&#39;,</span>
<span class="gd">-    &#39;test&#39;, &#39;or_test&#39;, &#39;and_test&#39;, &#39;not_test&#39;, &#39;comparison&#39;, &#39;expr&#39;,</span>
<span class="gd">-    &#39;xor_expr&#39;, &#39;and_expr&#39;, &#39;shift_expr&#39;, &#39;arith_expr&#39;, &#39;atom_expr&#39;, &#39;term&#39;,</span>
<span class="gd">-    &#39;factor&#39;, &#39;power&#39;, &#39;atom&#39;}</span>
<span class="gd">-_FLOW_KEYWORDS = (&#39;try&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;else&#39;, &#39;if&#39;, &#39;elif&#39;, &#39;with&#39;,</span>
<span class="gd">-    &#39;for&#39;, &#39;while&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_EXECUTE_NODES = {&#39;funcdef&#39;, &#39;classdef&#39;, &#39;import_from&#39;, &#39;import_name&#39;, &#39;test&#39;,</span>
<span class="gi">+                  &#39;or_test&#39;, &#39;and_test&#39;, &#39;not_test&#39;, &#39;comparison&#39;, &#39;expr&#39;,</span>
<span class="gi">+                  &#39;xor_expr&#39;, &#39;and_expr&#39;, &#39;shift_expr&#39;, &#39;arith_expr&#39;,</span>
<span class="gi">+                  &#39;atom_expr&#39;, &#39;term&#39;, &#39;factor&#39;, &#39;power&#39;, &#39;atom&#39;}</span>
<span class="gi">+</span>
<span class="gi">+_FLOW_KEYWORDS = (</span>
<span class="gi">+    &#39;try&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;else&#39;, &#39;if&#39;, &#39;elif&#39;, &#39;with&#39;, &#39;for&#39;, &#39;while&#39;</span>
<span class="gi">+)</span>


<span class="w"> </span>def get_executable_nodes(node, last_added=False):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    For static analysis.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    typ = node.type</span>
<span class="gi">+    if typ == &#39;name&#39;:</span>
<span class="gi">+        next_leaf = node.get_next_leaf()</span>
<span class="gi">+        if last_added is False and node.parent.type != &#39;param&#39; and next_leaf != &#39;=&#39;:</span>
<span class="gi">+            result.append(node)</span>
<span class="gi">+    elif typ == &#39;expr_stmt&#39;:</span>
<span class="gi">+        # I think inferring the statement (and possibly returned arrays),</span>
<span class="gi">+        # should be enough for static analysis.</span>
<span class="gi">+        result.append(node)</span>
<span class="gi">+        for child in node.children:</span>
<span class="gi">+            result += get_executable_nodes(child, last_added=True)</span>
<span class="gi">+    elif typ == &#39;decorator&#39;:</span>
<span class="gi">+        # decorator</span>
<span class="gi">+        if node.children[-2] == &#39;)&#39;:</span>
<span class="gi">+            node = node.children[-3]</span>
<span class="gi">+            if node != &#39;(&#39;:</span>
<span class="gi">+                result += get_executable_nodes(node)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            children = node.children</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if node.type in _EXECUTE_NODES and not last_added:</span>
<span class="gi">+                result.append(node)</span>
<span class="gi">+</span>
<span class="gi">+            for child in children:</span>
<span class="gi">+                result += get_executable_nodes(child, last_added)</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_sync_comp_fors(comp_for):</span>
<span class="gi">+    yield comp_for</span>
<span class="gi">+    last = comp_for.children[-1]</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if last.type == &#39;comp_for&#39;:</span>
<span class="gi">+            yield last.children[1]  # Ignore the async.</span>
<span class="gi">+        elif last.type == &#39;sync_comp_for&#39;:</span>
<span class="gi">+            yield last</span>
<span class="gi">+        elif not last.type == &#39;comp_if&#39;:</span>
<span class="gi">+            break</span>
<span class="gi">+        last = last.children[-1]</span>


<span class="w"> </span>def for_stmt_defines_one_name(for_stmt):
<span class="gu">@@ -28,16 +75,60 @@ def for_stmt_defines_one_name(for_stmt):</span>

<span class="w"> </span>    :returns: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return for_stmt.children[1].type == &#39;name&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_flow_branch_keyword(flow_node, node):</span>
<span class="gi">+    start_pos = node.start_pos</span>
<span class="gi">+    if not (flow_node.start_pos &lt; start_pos &lt;= flow_node.end_pos):</span>
<span class="gi">+        raise ValueError(&#39;The node is not part of the flow.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    keyword = None</span>
<span class="gi">+    for i, child in enumerate(flow_node.children):</span>
<span class="gi">+        if start_pos &lt; child.start_pos:</span>
<span class="gi">+            return keyword</span>
<span class="gi">+        first_leaf = child.get_first_leaf()</span>
<span class="gi">+        if first_leaf in _FLOW_KEYWORDS:</span>
<span class="gi">+            keyword = first_leaf</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def clean_scope_docstring(scope_node):
<span class="w"> </span>    &quot;&quot;&quot; Returns a cleaned version of the docstring token. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node = scope_node.get_doc_node()</span>
<span class="gi">+    if node is not None:</span>
<span class="gi">+        # TODO We have to check next leaves until there are no new</span>
<span class="gi">+        # leaves anymore that might be part of the docstring. A</span>
<span class="gi">+        # docstring can also look like this: ``&#39;foo&#39; &#39;bar&#39;</span>
<span class="gi">+        # Returns a literal cleaned version of the ``Token``.</span>
<span class="gi">+        return cleandoc(safe_literal_eval(node.value))</span>
<span class="gi">+    return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_statement_documentation(tree_node):</span>
<span class="gi">+    if tree_node.type == &#39;expr_stmt&#39;:</span>
<span class="gi">+        tree_node = tree_node.parent  # simple_stmt</span>
<span class="gi">+        maybe_string = tree_node.get_next_sibling()</span>
<span class="gi">+        if maybe_string is not None:</span>
<span class="gi">+            if maybe_string.type == &#39;simple_stmt&#39;:</span>
<span class="gi">+                maybe_string = maybe_string.children[0]</span>
<span class="gi">+                if maybe_string.type == &#39;string&#39;:</span>
<span class="gi">+                    return cleandoc(safe_literal_eval(maybe_string.value))</span>
<span class="gi">+    return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safe_literal_eval(value):</span>
<span class="gi">+    first_two = value[:2].lower()</span>
<span class="gi">+    if first_two[0] == &#39;f&#39; or first_two in (&#39;fr&#39;, &#39;rf&#39;):</span>
<span class="gi">+        # literal_eval is not able to resovle f literals. We have to do that</span>
<span class="gi">+        # manually, but that&#39;s right now not implemented.</span>
<span class="gi">+        return &#39;&#39;</span>

<span class="gi">+    return literal_eval(value)</span>

<span class="gd">-def get_signature(funcdef, width=72, call_string=None, omit_first_param=</span>
<span class="gd">-    False, omit_return_annotation=False):</span>
<span class="gi">+</span>
<span class="gi">+def get_signature(funcdef, width=72, call_string=None,</span>
<span class="gi">+                  omit_first_param=False, omit_return_annotation=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generate a string signature of a function.

<span class="gu">@@ -48,14 +139,38 @@ def get_signature(funcdef, width=72, call_string=None, omit_first_param=</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Lambdas have no name.</span>
<span class="gi">+    if call_string is None:</span>
<span class="gi">+        if funcdef.type == &#39;lambdef&#39;:</span>
<span class="gi">+            call_string = &#39;&lt;lambda&gt;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            call_string = funcdef.name.value</span>
<span class="gi">+    params = funcdef.get_params()</span>
<span class="gi">+    if omit_first_param:</span>
<span class="gi">+        params = params[1:]</span>
<span class="gi">+    p = &#39;(&#39; + &#39;&#39;.join(param.get_code() for param in params).strip() + &#39;)&#39;</span>
<span class="gi">+    # TODO this is pretty bad, we should probably just normalize.</span>
<span class="gi">+    p = re.sub(r&#39;\s+&#39;, &#39; &#39;, p)</span>
<span class="gi">+    if funcdef.annotation and not omit_return_annotation:</span>
<span class="gi">+        rtype = &quot; -&gt;&quot; + funcdef.annotation.get_code()</span>
<span class="gi">+    else:</span>
<span class="gi">+        rtype = &quot;&quot;</span>
<span class="gi">+    code = call_string + p + rtype</span>
<span class="gi">+</span>
<span class="gi">+    return &#39;\n&#39;.join(textwrap.wrap(code, width))</span>


<span class="w"> </span>def move(node, line_offset):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move the `Node` start_pos.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        children = node.children</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        node.line += line_offset</span>
<span class="gi">+    else:</span>
<span class="gi">+        for c in children:</span>
<span class="gi">+            move(c, line_offset)</span>


<span class="w"> </span>def get_following_comment_same_line(node):
<span class="gu">@@ -63,14 +178,91 @@ def get_following_comment_same_line(node):</span>
<span class="w"> </span>    returns (as string) any comment that appears on the same line,
<span class="w"> </span>    after the node, including the #
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if node.type == &#39;for_stmt&#39;:</span>
<span class="gi">+            whitespace = node.children[5].get_first_leaf().prefix</span>
<span class="gi">+        elif node.type == &#39;with_stmt&#39;:</span>
<span class="gi">+            whitespace = node.children[3].get_first_leaf().prefix</span>
<span class="gi">+        elif node.type == &#39;funcdef&#39;:</span>
<span class="gi">+            # actually on the next line</span>
<span class="gi">+            whitespace = node.children[4].get_first_leaf().get_next_leaf().prefix</span>
<span class="gi">+        else:</span>
<span class="gi">+            whitespace = node.get_last_leaf().get_next_leaf().prefix</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # TODO in some particular cases, the tree doesn&#39;t seem to be linked</span>
<span class="gi">+        # correctly</span>
<span class="gi">+        return None</span>
<span class="gi">+    if &quot;#&quot; not in whitespace:</span>
<span class="gi">+        return None</span>
<span class="gi">+    comment = whitespace[whitespace.index(&quot;#&quot;):]</span>
<span class="gi">+    if &quot;\r&quot; in comment:</span>
<span class="gi">+        comment = comment[:comment.index(&quot;\r&quot;)]</span>
<span class="gi">+    if &quot;\n&quot; in comment:</span>
<span class="gi">+        comment = comment[:comment.index(&quot;\n&quot;)]</span>
<span class="gi">+    return comment</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_scope(node):</span>
<span class="gi">+    t = node.type</span>
<span class="gi">+    if t == &#39;comp_for&#39;:</span>
<span class="gi">+        # Starting with Python 3.8, async is outside of the statement.</span>
<span class="gi">+        return node.children[1].type != &#39;sync_comp_for&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return t in (&#39;file_input&#39;, &#39;classdef&#39;, &#39;funcdef&#39;, &#39;lambdef&#39;, &#39;sync_comp_for&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_parent_scope_cache(func):</span>
<span class="gi">+    cache = WeakKeyDictionary()</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper(parso_cache_node, node, include_flows=False):</span>
<span class="gi">+        if parso_cache_node is None:</span>
<span class="gi">+            return func(node, include_flows)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for_module = cache[parso_cache_node]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            for_module = cache[parso_cache_node] = {}</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return for_module[node]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            result = for_module[node] = func(node, include_flows)</span>
<span class="gi">+            return result</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def get_parent_scope(node, include_flows=False):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the underlying scope.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scope = node.parent</span>
<span class="gi">+    if scope is None:</span>
<span class="gi">+        return None  # It&#39;s a module already.</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if is_scope(scope):</span>
<span class="gi">+            if scope.type in (&#39;classdef&#39;, &#39;funcdef&#39;, &#39;lambdef&#39;):</span>
<span class="gi">+                index = scope.children.index(&#39;:&#39;)</span>
<span class="gi">+                if scope.children[index].start_pos &gt;= node.start_pos:</span>
<span class="gi">+                    if node.parent.type == &#39;param&#39; and node.parent.name == node:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    elif node.parent.type == &#39;tfpdef&#39; and node.parent.children[0] == node:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        scope = scope.parent</span>
<span class="gi">+                        continue</span>
<span class="gi">+            return scope</span>
<span class="gi">+        elif include_flows and isinstance(scope, tree.Flow):</span>
<span class="gi">+            # The cursor might be on `if foo`, so the parent scope will not be</span>
<span class="gi">+            # the if, but the parent of the if.</span>
<span class="gi">+            if not (scope.type == &#39;if_stmt&#39;</span>
<span class="gi">+                    and any(n.start_pos &lt;= node.start_pos &lt; n.end_pos</span>
<span class="gi">+                            for n in scope.get_test_nodes())):</span>
<span class="gi">+                return scope</span>
<span class="gi">+</span>
<span class="gi">+        scope = scope.parent</span>


<span class="w"> </span>get_cached_parent_scope = _get_parent_scope_cache(get_parent_scope)
<span class="gu">@@ -81,7 +273,7 @@ def get_cached_code_lines(grammar, path):</span>
<span class="w"> </span>    Basically access the cached code lines in parso. This is not the nicest way
<span class="w"> </span>    to do this, but we avoid splitting all the lines again.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_parso_cache_node(grammar, path).lines</span>


<span class="w"> </span>def get_parso_cache_node(grammar, path):
<span class="gu">@@ -92,21 +284,56 @@ def get_parso_cache_node(grammar, path):</span>
<span class="w"> </span>    The reason for this is mostly caching. This is obviously also a sign of a
<span class="w"> </span>    broken caching architecture.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return parser_cache[grammar._hashed][path]</span>


<span class="w"> </span>def cut_value_at_position(leaf, position):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Cuts of the value of the leaf at position
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = split_lines(leaf.value, keepends=True)[:position[0] - leaf.line + 1]</span>
<span class="gi">+    column = position[1]</span>
<span class="gi">+    if leaf.line == position[0]:</span>
<span class="gi">+        column -= leaf.column</span>
<span class="gi">+    if not lines:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    lines[-1] = lines[-1][:column]</span>
<span class="gi">+    return &#39;&#39;.join(lines)</span>


<span class="w"> </span>def expr_is_dotted(node):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks if a path looks like `name` or `name.foo.bar` and not `name()`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.type == &#39;atom&#39;:</span>
<span class="gi">+        if len(node.children) == 3 and node.children[0] == &#39;(&#39;:</span>
<span class="gi">+            return expr_is_dotted(node.children[1])</span>
<span class="gi">+        return False</span>
<span class="gi">+    if node.type == &#39;atom_expr&#39;:</span>
<span class="gi">+        children = node.children</span>
<span class="gi">+        if children[0] == &#39;await&#39;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not expr_is_dotted(children[0]):</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Check trailers</span>
<span class="gi">+        return all(c.children[0] == &#39;.&#39; for c in children[1:])</span>
<span class="gi">+    return node.type == &#39;name&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _function_is_x_method(*method_names):</span>
<span class="gi">+    def wrapper(function_node):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        This is a heuristic. It will not hold ALL the times, but it will be</span>
<span class="gi">+        correct pretty much for anyone that doesn&#39;t try to beat it.</span>
<span class="gi">+        staticmethod/classmethod are builtins and unless overwritten, this will</span>
<span class="gi">+        be correct.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        for decorator in function_node.get_decorators():</span>
<span class="gi">+            dotted_name = decorator.children[1]</span>
<span class="gi">+            if dotted_name.get_code() in method_names:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>function_is_staticmethod = _function_is_x_method(&#39;staticmethod&#39;)
<span class="gh">diff --git a/jedi/plugins/django.py b/jedi/plugins/django.py</span>
<span class="gh">index b9ceb2ec..cd443bbd 100644</span>
<span class="gd">--- a/jedi/plugins/django.py</span>
<span class="gi">+++ b/jedi/plugins/django.py</span>
<span class="gu">@@ -2,6 +2,7 @@</span>
<span class="w"> </span>Module is used to infer Django model fields.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.cache import inference_state_function_cache
<span class="w"> </span>from jedi.inference.base_value import ValueSet, iterator_to_value_set, ValueWrapper
<span class="gu">@@ -13,67 +14,283 @@ from jedi.inference.value.klass import ClassMixin</span>
<span class="w"> </span>from jedi.inference.gradual.base import GenericClass
<span class="w"> </span>from jedi.inference.gradual.generics import TupleGenericManager
<span class="w"> </span>from jedi.inference.signature import AbstractSignature
<span class="gd">-mapping = {&#39;IntegerField&#39;: (None, &#39;int&#39;), &#39;BigIntegerField&#39;: (None, &#39;int&#39;),</span>
<span class="gd">-    &#39;PositiveIntegerField&#39;: (None, &#39;int&#39;), &#39;SmallIntegerField&#39;: (None,</span>
<span class="gd">-    &#39;int&#39;), &#39;CharField&#39;: (None, &#39;str&#39;), &#39;TextField&#39;: (None, &#39;str&#39;),</span>
<span class="gd">-    &#39;EmailField&#39;: (None, &#39;str&#39;), &#39;GenericIPAddressField&#39;: (None, &#39;str&#39;),</span>
<span class="gd">-    &#39;URLField&#39;: (None, &#39;str&#39;), &#39;FloatField&#39;: (None, &#39;float&#39;), &#39;BinaryField&#39;:</span>
<span class="gd">-    (None, &#39;bytes&#39;), &#39;BooleanField&#39;: (None, &#39;bool&#39;), &#39;DecimalField&#39;: (</span>
<span class="gd">-    &#39;decimal&#39;, &#39;Decimal&#39;), &#39;TimeField&#39;: (&#39;datetime&#39;, &#39;time&#39;),</span>
<span class="gd">-    &#39;DurationField&#39;: (&#39;datetime&#39;, &#39;timedelta&#39;), &#39;DateField&#39;: (&#39;datetime&#39;,</span>
<span class="gd">-    &#39;date&#39;), &#39;DateTimeField&#39;: (&#39;datetime&#39;, &#39;datetime&#39;), &#39;UUIDField&#39;: (</span>
<span class="gd">-    &#39;uuid&#39;, &#39;UUID&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+mapping = {</span>
<span class="gi">+    &#39;IntegerField&#39;: (None, &#39;int&#39;),</span>
<span class="gi">+    &#39;BigIntegerField&#39;: (None, &#39;int&#39;),</span>
<span class="gi">+    &#39;PositiveIntegerField&#39;: (None, &#39;int&#39;),</span>
<span class="gi">+    &#39;SmallIntegerField&#39;: (None, &#39;int&#39;),</span>
<span class="gi">+    &#39;CharField&#39;: (None, &#39;str&#39;),</span>
<span class="gi">+    &#39;TextField&#39;: (None, &#39;str&#39;),</span>
<span class="gi">+    &#39;EmailField&#39;: (None, &#39;str&#39;),</span>
<span class="gi">+    &#39;GenericIPAddressField&#39;: (None, &#39;str&#39;),</span>
<span class="gi">+    &#39;URLField&#39;: (None, &#39;str&#39;),</span>
<span class="gi">+    &#39;FloatField&#39;: (None, &#39;float&#39;),</span>
<span class="gi">+    &#39;BinaryField&#39;: (None, &#39;bytes&#39;),</span>
<span class="gi">+    &#39;BooleanField&#39;: (None, &#39;bool&#39;),</span>
<span class="gi">+    &#39;DecimalField&#39;: (&#39;decimal&#39;, &#39;Decimal&#39;),</span>
<span class="gi">+    &#39;TimeField&#39;: (&#39;datetime&#39;, &#39;time&#39;),</span>
<span class="gi">+    &#39;DurationField&#39;: (&#39;datetime&#39;, &#39;timedelta&#39;),</span>
<span class="gi">+    &#39;DateField&#39;: (&#39;datetime&#39;, &#39;date&#39;),</span>
<span class="gi">+    &#39;DateTimeField&#39;: (&#39;datetime&#39;, &#39;datetime&#39;),</span>
<span class="gi">+    &#39;UUIDField&#39;: (&#39;uuid&#39;, &#39;UUID&#39;),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>_FILTER_LIKE_METHODS = (&#39;create&#39;, &#39;filter&#39;, &#39;exclude&#39;, &#39;update&#39;, &#39;get&#39;,
<span class="gd">-    &#39;get_or_create&#39;, &#39;update_or_create&#39;)</span>
<span class="gi">+                        &#39;get_or_create&#39;, &#39;update_or_create&#39;)</span>


<span class="gd">-class DjangoModelName(NameWrapper):</span>
<span class="gi">+@inference_state_function_cache()</span>
<span class="gi">+def _get_deferred_attributes(inference_state):</span>
<span class="gi">+    return inference_state.import_module(</span>
<span class="gi">+        (&#39;django&#39;, &#39;db&#39;, &#39;models&#39;, &#39;query_utils&#39;)</span>
<span class="gi">+    ).py__getattribute__(&#39;DeferredAttribute&#39;).execute_annotation()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_scalar_field(inference_state, field_name, field_tree_instance, is_instance):</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_name, attribute_name = mapping[field_tree_instance.py__name__()]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if not is_instance:</span>
<span class="gi">+        return _get_deferred_attributes(inference_state)</span>
<span class="gi">+</span>
<span class="gi">+    if module_name is None:</span>
<span class="gi">+        module = inference_state.builtins_module</span>
<span class="gi">+    else:</span>
<span class="gi">+        module = inference_state.import_module((module_name,))</span>
<span class="gi">+</span>
<span class="gi">+    for attribute in module.py__getattribute__(attribute_name):</span>
<span class="gi">+        return attribute.execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@iterator_to_value_set</span>
<span class="gi">+def _get_foreign_key_values(cls, field_tree_instance):</span>
<span class="gi">+    if isinstance(field_tree_instance, TreeInstance):</span>
<span class="gi">+        # TODO private access..</span>
<span class="gi">+        argument_iterator = field_tree_instance._arguments.unpack()</span>
<span class="gi">+        key, lazy_values = next(argument_iterator, (None, None))</span>
<span class="gi">+        if key is None and lazy_values is not None:</span>
<span class="gi">+            for value in lazy_values.infer():</span>
<span class="gi">+                if value.py__name__() == &#39;str&#39;:</span>
<span class="gi">+                    foreign_key_class_name = value.get_safe_value()</span>
<span class="gi">+                    module = cls.get_root_context()</span>
<span class="gi">+                    for v in module.py__getattribute__(foreign_key_class_name):</span>
<span class="gi">+                        if v.is_class():</span>
<span class="gi">+                            yield v</span>
<span class="gi">+                elif value.is_class():</span>
<span class="gi">+                    yield value</span>
<span class="gi">+</span>

<span class="gi">+def _infer_field(cls, field_name, is_instance):</span>
<span class="gi">+    inference_state = cls.inference_state</span>
<span class="gi">+    result = field_name.infer()</span>
<span class="gi">+    for field_tree_instance in result:</span>
<span class="gi">+        scalar_field = _infer_scalar_field(</span>
<span class="gi">+            inference_state, field_name, field_tree_instance, is_instance)</span>
<span class="gi">+        if scalar_field is not None:</span>
<span class="gi">+            return scalar_field</span>
<span class="gi">+</span>
<span class="gi">+        name = field_tree_instance.py__name__()</span>
<span class="gi">+        is_many_to_many = name == &#39;ManyToManyField&#39;</span>
<span class="gi">+        if name in (&#39;ForeignKey&#39;, &#39;OneToOneField&#39;) or is_many_to_many:</span>
<span class="gi">+            if not is_instance:</span>
<span class="gi">+                return _get_deferred_attributes(inference_state)</span>
<span class="gi">+</span>
<span class="gi">+            values = _get_foreign_key_values(cls, field_tree_instance)</span>
<span class="gi">+            if is_many_to_many:</span>
<span class="gi">+                return ValueSet(filter(None, [</span>
<span class="gi">+                    _create_manager_for(v, &#39;RelatedManager&#39;) for v in values</span>
<span class="gi">+                ]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                return values.execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+    debug.dbg(&#39;django plugin: fail to infer `%s` from class `%s`&#39;,</span>
<span class="gi">+              field_name.string_name, cls.py__name__())</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class DjangoModelName(NameWrapper):</span>
<span class="w"> </span>    def __init__(self, cls, name, is_instance):
<span class="w"> </span>        super().__init__(name)
<span class="w"> </span>        self._cls = cls
<span class="w"> </span>        self._is_instance = is_instance

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return _infer_field(self._cls, self._wrapped_name, self._is_instance)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_manager_for(cls, manager_cls=&#39;BaseManager&#39;):</span>
<span class="gi">+    managers = cls.inference_state.import_module(</span>
<span class="gi">+        (&#39;django&#39;, &#39;db&#39;, &#39;models&#39;, &#39;manager&#39;)</span>
<span class="gi">+    ).py__getattribute__(manager_cls)</span>
<span class="gi">+    for m in managers:</span>
<span class="gi">+        if m.is_class_mixin():</span>
<span class="gi">+            generics_manager = TupleGenericManager((ValueSet([cls]),))</span>
<span class="gi">+            for c in GenericClass(m, generics_manager).execute_annotation():</span>
<span class="gi">+                return c</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _new_dict_filter(cls, is_instance):</span>
<span class="gi">+    filters = list(cls.get_filters(</span>
<span class="gi">+        is_instance=is_instance,</span>
<span class="gi">+        include_metaclasses=False,</span>
<span class="gi">+        include_type_when_class=False)</span>
<span class="gi">+    )</span>
<span class="gi">+    dct = {</span>
<span class="gi">+        name.string_name: DjangoModelName(cls, name, is_instance)</span>
<span class="gi">+        for filter_ in reversed(filters)</span>
<span class="gi">+        for name in filter_.values()</span>
<span class="gi">+    }</span>
<span class="gi">+    if is_instance:</span>
<span class="gi">+        # Replace the objects with a name that amounts to nothing when accessed</span>
<span class="gi">+        # in an instance. This is not perfect and still completes &quot;objects&quot; in</span>
<span class="gi">+        # that case, but it at least not inferes stuff like `.objects.filter`.</span>
<span class="gi">+        # It would be nicer to do that in a better way, so that it also doesn&#39;t</span>
<span class="gi">+        # show up in completions, but it&#39;s probably just not worth doing that</span>
<span class="gi">+        # for the extra amount of work.</span>
<span class="gi">+        dct[&#39;objects&#39;] = EmptyCompiledName(cls.inference_state, &#39;objects&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return DictFilter(dct)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_django_model_base(value):</span>
<span class="gi">+    return value.py__name__() == &#39;ModelBase&#39; \</span>
<span class="gi">+        and value.get_root_context().py__name__() == &#39;django.db.models.base&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_metaclass_filters(func):</span>
<span class="gi">+    def wrapper(cls, metaclasses, is_instance):</span>
<span class="gi">+        for metaclass in metaclasses:</span>
<span class="gi">+            if is_django_model_base(metaclass):</span>
<span class="gi">+                return [_new_dict_filter(cls, is_instance)]</span>
<span class="gi">+</span>
<span class="gi">+        return func(cls, metaclasses, is_instance)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tree_name_to_values(func):</span>
<span class="gi">+    def wrapper(inference_state, context, tree_name):</span>
<span class="gi">+        result = func(inference_state, context, tree_name)</span>
<span class="gi">+        if tree_name.value in _FILTER_LIKE_METHODS:</span>
<span class="gi">+            # Here we try to overwrite stuff like User.objects.filter. We need</span>
<span class="gi">+            # this to make sure that keyword param completion works on these</span>
<span class="gi">+            # kind of methods.</span>
<span class="gi">+            for v in result:</span>
<span class="gi">+                if v.get_qualified_names() == (&#39;_BaseQuerySet&#39;, tree_name.value) \</span>
<span class="gi">+                        and v.parent_context.is_module() \</span>
<span class="gi">+                        and v.parent_context.py__name__() == &#39;django.db.models.query&#39;:</span>
<span class="gi">+                    qs = context.get_value()</span>
<span class="gi">+                    generics = qs.get_generics()</span>
<span class="gi">+                    if len(generics) &gt;= 1:</span>
<span class="gi">+                        return ValueSet(QuerySetMethodWrapper(v, model)</span>
<span class="gi">+                                        for model in generics[0])</span>
<span class="gi">+</span>
<span class="gi">+        elif tree_name.value == &#39;BaseManager&#39; and context.is_module() \</span>
<span class="gi">+                and context.py__name__() == &#39;django.db.models.manager&#39;:</span>
<span class="gi">+            return ValueSet(ManagerWrapper(r) for r in result)</span>
<span class="gi">+</span>
<span class="gi">+        elif tree_name.value == &#39;Field&#39; and context.is_module() \</span>
<span class="gi">+                and context.py__name__() == &#39;django.db.models.fields&#39;:</span>
<span class="gi">+            return ValueSet(FieldWrapper(r) for r in result)</span>
<span class="gi">+        return result</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_fields(cls):</span>
<span class="gi">+    for name in _new_dict_filter(cls, is_instance=False).values():</span>
<span class="gi">+        for value in name.infer():</span>
<span class="gi">+            if value.name.get_qualified_names(include_module_names=True) \</span>
<span class="gi">+                    == (&#39;django&#39;, &#39;db&#39;, &#39;models&#39;, &#39;query_utils&#39;, &#39;DeferredAttribute&#39;):</span>
<span class="gi">+                yield name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_signatures(cls):</span>
<span class="gi">+    return [DjangoModelSignature(cls, field_names=list(_find_fields(cls)))]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_metaclass_signatures(func):</span>
<span class="gi">+    def wrapper(cls, metaclasses):</span>
<span class="gi">+        for metaclass in metaclasses:</span>
<span class="gi">+            if is_django_model_base(metaclass):</span>
<span class="gi">+                return _get_signatures(cls)</span>
<span class="gi">+        return func(cls, metaclass)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>

<span class="w"> </span>class ManagerWrapper(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            GenericManagerWrapper(generic)</span>
<span class="gi">+            for generic in self._wrapped_value.py__getitem__(</span>
<span class="gi">+                index_value_set, contextualized_node)</span>
<span class="gi">+        )</span>


<span class="w"> </span>class GenericManagerWrapper(AttributeOverwrite, ClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def py__get__on_class(self, calling_instance, instance, class_value):</span>
<span class="gi">+        return calling_instance.class_value.with_generics(</span>
<span class="gi">+            (ValueSet({class_value}),)</span>
<span class="gi">+        ).py__call__(calling_instance._arguments)</span>
<span class="gi">+</span>
<span class="gi">+    def with_generics(self, generics_tuple):</span>
<span class="gi">+        return self._wrapped_value.with_generics(generics_tuple)</span>


<span class="w"> </span>class FieldWrapper(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        return ValueSet(</span>
<span class="gi">+            GenericFieldWrapper(generic)</span>
<span class="gi">+            for generic in self._wrapped_value.py__getitem__(</span>
<span class="gi">+                index_value_set, contextualized_node)</span>
<span class="gi">+        )</span>


<span class="w"> </span>class GenericFieldWrapper(AttributeOverwrite, ClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def py__get__on_class(self, calling_instance, instance, class_value):</span>
<span class="gi">+        # This is mostly an optimization to avoid Jedi aborting inference,</span>
<span class="gi">+        # because of too many function executions of Field.__get__.</span>
<span class="gi">+        return ValueSet({calling_instance})</span>


<span class="w"> </span>class DjangoModelSignature(AbstractSignature):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value, field_names):
<span class="w"> </span>        super().__init__(value)
<span class="w"> </span>        self._field_names = field_names

<span class="gi">+    def get_param_names(self, resolve_stars=False):</span>
<span class="gi">+        return [DjangoParamName(name) for name in self._field_names]</span>

<span class="gd">-class DjangoParamName(BaseTreeParamName):</span>

<span class="gi">+class DjangoParamName(BaseTreeParamName):</span>
<span class="w"> </span>    def __init__(self, field_name):
<span class="w"> </span>        super().__init__(field_name.parent_context, field_name.tree_name)
<span class="w"> </span>        self._field_name = field_name

<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        return Parameter.KEYWORD_ONLY</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return self._field_name.infer()</span>

<span class="gd">-class QuerySetMethodWrapper(ValueWrapper):</span>

<span class="gi">+class QuerySetMethodWrapper(ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, method, model_cls):
<span class="w"> </span>        super().__init__(method)
<span class="w"> </span>        self._model_cls = model_cls

<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        return ValueSet({QuerySetBoundMethodWrapper(v, self._model_cls)</span>
<span class="gi">+                         for v in self._wrapped_value.py__get__(instance, class_value)})</span>

<span class="gd">-class QuerySetBoundMethodWrapper(ValueWrapper):</span>

<span class="gi">+class QuerySetBoundMethodWrapper(ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, method, model_cls):
<span class="w"> </span>        super().__init__(method)
<span class="w"> </span>        self._model_cls = model_cls
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return _get_signatures(self._model_cls)</span>
<span class="gh">diff --git a/jedi/plugins/flask.py b/jedi/plugins/flask.py</span>
<span class="gh">index d3c813ea..8d67b839 100644</span>
<span class="gd">--- a/jedi/plugins/flask.py</span>
<span class="gi">+++ b/jedi/plugins/flask.py</span>
<span class="gu">@@ -3,4 +3,19 @@ def import_module(callback):</span>
<span class="w"> </span>    Handle &quot;magic&quot; Flask extension imports:
<span class="w"> </span>    ``flask.ext.foo`` is really ``flask_foo`` or ``flaskext.foo``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(inference_state, import_names, module_context, *args, **kwargs):</span>
<span class="gi">+        if len(import_names) == 3 and import_names[:2] == (&#39;flask&#39;, &#39;ext&#39;):</span>
<span class="gi">+            # New style.</span>
<span class="gi">+            ipath = (&#39;flask_&#39; + import_names[2]),</span>
<span class="gi">+            value_set = callback(inference_state, ipath, None, *args, **kwargs)</span>
<span class="gi">+            if value_set:</span>
<span class="gi">+                return value_set</span>
<span class="gi">+            value_set = callback(inference_state, (&#39;flaskext&#39;,), None, *args, **kwargs)</span>
<span class="gi">+            return callback(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                (&#39;flaskext&#39;, import_names[2]),</span>
<span class="gi">+                next(iter(value_set)),</span>
<span class="gi">+                *args, **kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+        return callback(inference_state, import_names, module_context, *args, **kwargs)</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/plugins/pytest.py b/jedi/plugins/pytest.py</span>
<span class="gh">index 5295fd78..06adda44 100644</span>
<span class="gd">--- a/jedi/plugins/pytest.py</span>
<span class="gi">+++ b/jedi/plugins/pytest.py</span>
<span class="gu">@@ -1,15 +1,116 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import List
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from parso.tree import search_ancestor
<span class="w"> </span>from jedi.inference.cache import inference_state_method_cache
<span class="w"> </span>from jedi.inference.imports import goto_import, load_module_from_path
<span class="w"> </span>from jedi.inference.filters import ParserTreeFilter
<span class="w"> </span>from jedi.inference.base_value import NO_VALUES, ValueSet
<span class="w"> </span>from jedi.inference.helpers import infer_call_of_leaf
<span class="gd">-_PYTEST_FIXTURE_MODULES = [(&#39;_pytest&#39;, &#39;monkeypatch&#39;), (&#39;_pytest&#39;,</span>
<span class="gd">-    &#39;capture&#39;), (&#39;_pytest&#39;, &#39;logging&#39;), (&#39;_pytest&#39;, &#39;tmpdir&#39;), (&#39;_pytest&#39;,</span>
<span class="gd">-    &#39;pytester&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+_PYTEST_FIXTURE_MODULES = [</span>
<span class="gi">+    (&#39;_pytest&#39;, &#39;monkeypatch&#39;),</span>
<span class="gi">+    (&#39;_pytest&#39;, &#39;capture&#39;),</span>
<span class="gi">+    (&#39;_pytest&#39;, &#39;logging&#39;),</span>
<span class="gi">+    (&#39;_pytest&#39;, &#39;tmpdir&#39;),</span>
<span class="gi">+    (&#39;_pytest&#39;, &#39;pytester&#39;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def execute(callback):</span>
<span class="gi">+    def wrapper(value, arguments):</span>
<span class="gi">+        # This might not be necessary anymore in pytest 4/5, definitely needed</span>
<span class="gi">+        # for pytest 3.</span>
<span class="gi">+        if value.py__name__() == &#39;fixture&#39; \</span>
<span class="gi">+                and value.parent_context.py__name__() == &#39;_pytest.fixtures&#39;:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        return callback(value, arguments)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer_anonymous_param(func):</span>
<span class="gi">+    def get_returns(value):</span>
<span class="gi">+        if value.tree_node.annotation is not None:</span>
<span class="gi">+            result = value.execute_with_values()</span>
<span class="gi">+            if any(v.name.get_qualified_names(include_module_names=True)</span>
<span class="gi">+                   == (&#39;typing&#39;, &#39;Generator&#39;)</span>
<span class="gi">+                   for v in result):</span>
<span class="gi">+                return ValueSet.from_sets(</span>
<span class="gi">+                    v.py__getattribute__(&#39;__next__&#39;).execute_annotation()</span>
<span class="gi">+                    for v in result</span>
<span class="gi">+                )</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        # In pytest we need to differentiate between generators and normal</span>
<span class="gi">+        # returns.</span>
<span class="gi">+        # Parameters still need to be anonymous, .as_context() ensures that.</span>
<span class="gi">+        function_context = value.as_context()</span>
<span class="gi">+        if function_context.is_generator():</span>
<span class="gi">+            return function_context.merge_yield_values()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return function_context.get_return_values()</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper(param_name):</span>
<span class="gi">+        # parameters with an annotation do not need special handling</span>
<span class="gi">+        if param_name.annotation_node:</span>
<span class="gi">+            return func(param_name)</span>
<span class="gi">+        is_pytest_param, param_name_is_function_name = \</span>
<span class="gi">+            _is_a_pytest_param_and_inherited(param_name)</span>
<span class="gi">+        if is_pytest_param:</span>
<span class="gi">+            module = param_name.get_root_context()</span>
<span class="gi">+            fixtures = _goto_pytest_fixture(</span>
<span class="gi">+                module,</span>
<span class="gi">+                param_name.string_name,</span>
<span class="gi">+                # This skips the current module, because we are basically</span>
<span class="gi">+                # inheriting a fixture from somewhere else.</span>
<span class="gi">+                skip_own_module=param_name_is_function_name,</span>
<span class="gi">+            )</span>
<span class="gi">+            if fixtures:</span>
<span class="gi">+                return ValueSet.from_sets(</span>
<span class="gi">+                    get_returns(value)</span>
<span class="gi">+                    for fixture in fixtures</span>
<span class="gi">+                    for value in fixture.infer()</span>
<span class="gi">+                )</span>
<span class="gi">+        return func(param_name)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def goto_anonymous_param(func):</span>
<span class="gi">+    def wrapper(param_name):</span>
<span class="gi">+        is_pytest_param, param_name_is_function_name = \</span>
<span class="gi">+            _is_a_pytest_param_and_inherited(param_name)</span>
<span class="gi">+        if is_pytest_param:</span>
<span class="gi">+            names = _goto_pytest_fixture(</span>
<span class="gi">+                param_name.get_root_context(),</span>
<span class="gi">+                param_name.string_name,</span>
<span class="gi">+                skip_own_module=param_name_is_function_name,</span>
<span class="gi">+            )</span>
<span class="gi">+            if names:</span>
<span class="gi">+                return names</span>
<span class="gi">+        return func(param_name)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def complete_param_names(func):</span>
<span class="gi">+    def wrapper(context, func_name, decorator_nodes):</span>
<span class="gi">+        module_context = context.get_root_context()</span>
<span class="gi">+        if _is_pytest_func(func_name, decorator_nodes):</span>
<span class="gi">+            names = []</span>
<span class="gi">+            for module_context in _iter_pytest_modules(module_context):</span>
<span class="gi">+                names += FixtureFilter(module_context).values()</span>
<span class="gi">+            if names:</span>
<span class="gi">+                return names</span>
<span class="gi">+        return func(context, func_name, decorator_nodes)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _goto_pytest_fixture(module_context, name, skip_own_module):</span>
<span class="gi">+    for module_context in _iter_pytest_modules(module_context, skip_own_module=skip_own_module):</span>
<span class="gi">+        names = FixtureFilter(module_context).get(name)</span>
<span class="gi">+        if names:</span>
<span class="gi">+            return names</span>


<span class="w"> </span>def _is_a_pytest_param_and_inherited(param_name):
<span class="gu">@@ -19,17 +120,131 @@ def _is_a_pytest_param_and_inherited(param_name):</span>

<span class="w"> </span>    This is a heuristic and will work in most cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    funcdef = search_ancestor(param_name.tree_name, &#39;funcdef&#39;)</span>
<span class="gi">+    if funcdef is None:  # A lambda</span>
<span class="gi">+        return False, False</span>
<span class="gi">+    decorators = funcdef.get_decorators()</span>
<span class="gi">+    return _is_pytest_func(funcdef.name.value, decorators), \</span>
<span class="gi">+        funcdef.name.value == param_name.string_name</span>


<span class="gd">-def _find_pytest_plugin_modules() -&gt;List[List[str]]:</span>
<span class="gi">+def _is_pytest_func(func_name, decorator_nodes):</span>
<span class="gi">+    return func_name.startswith(&#39;test&#39;) \</span>
<span class="gi">+        or any(&#39;fixture&#39; in n.get_code() for n in decorator_nodes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_pytest_plugin_modules() -&gt; List[List[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Finds pytest plugin modules hooked by setuptools entry points

<span class="w"> </span>    See https://docs.pytest.org/en/stable/how-to/writing_plugins.html#setuptools-entry-points
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.version_info &gt;= (3, 8):</span>
<span class="gi">+        from importlib.metadata import entry_points</span>
<span class="gi">+</span>
<span class="gi">+        if sys.version_info &gt;= (3, 10):</span>
<span class="gi">+            pytest_entry_points = entry_points(group=&quot;pytest11&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            pytest_entry_points = entry_points().get(&quot;pytest11&quot;, ())</span>
<span class="gi">+</span>
<span class="gi">+        if sys.version_info &gt;= (3, 9):</span>
<span class="gi">+            return [ep.module.split(&quot;.&quot;) for ep in pytest_entry_points]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Python 3.8 doesn&#39;t have `EntryPoint.module`. Implement equivalent</span>
<span class="gi">+            # to what Python 3.9 does (with additional None check to placate `mypy`)</span>
<span class="gi">+            matches = [</span>
<span class="gi">+                ep.pattern.match(ep.value)</span>
<span class="gi">+                for ep in pytest_entry_points</span>
<span class="gi">+            ]</span>
<span class="gi">+            return [x.group(&#39;module&#39;).split(&quot;.&quot;) for x in matches if x]</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        from pkg_resources import iter_entry_points</span>
<span class="gi">+        return [ep.module_name.split(&quot;.&quot;) for ep in iter_entry_points(group=&quot;pytest11&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@inference_state_method_cache()</span>
<span class="gi">+def _iter_pytest_modules(module_context, skip_own_module=False):</span>
<span class="gi">+    if not skip_own_module:</span>
<span class="gi">+        yield module_context</span>
<span class="gi">+</span>
<span class="gi">+    file_io = module_context.get_value().file_io</span>
<span class="gi">+    if file_io is not None:</span>
<span class="gi">+        folder = file_io.get_parent_folder()</span>
<span class="gi">+        sys_path = module_context.inference_state.get_sys_path()</span>
<span class="gi">+</span>
<span class="gi">+        # prevent an infinite loop when reaching the root of the current drive</span>
<span class="gi">+        last_folder = None</span>
<span class="gi">+</span>
<span class="gi">+        while any(folder.path.startswith(p) for p in sys_path):</span>
<span class="gi">+            file_io = folder.get_file_io(&#39;conftest.py&#39;)</span>
<span class="gi">+            if Path(file_io.path) != module_context.py__file__():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    m = load_module_from_path(module_context.inference_state, file_io)</span>
<span class="gi">+                    yield m.as_context()</span>
<span class="gi">+                except FileNotFoundError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            folder = folder.get_parent_folder()</span>
<span class="gi">+</span>
<span class="gi">+            # prevent an infinite for loop if the same parent folder is return twice</span>
<span class="gi">+            if last_folder is not None and folder.path == last_folder.path:</span>
<span class="gi">+                break</span>
<span class="gi">+            last_folder = folder  # keep track of the last found parent name</span>
<span class="gi">+</span>
<span class="gi">+    for names in _PYTEST_FIXTURE_MODULES + _find_pytest_plugin_modules():</span>
<span class="gi">+        for module_value in module_context.inference_state.import_module(names):</span>
<span class="gi">+            yield module_value.as_context()</span>


<span class="w"> </span>class FixtureFilter(ParserTreeFilter):
<span class="gd">-    pass</span>
<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        for name in super()._filter(names):</span>
<span class="gi">+            # look for fixture definitions of imported names</span>
<span class="gi">+            if name.parent.type == &quot;import_from&quot;:</span>
<span class="gi">+                imported_names = goto_import(self.parent_context, name)</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    self._is_fixture(iname.parent_context, iname.tree_name)</span>
<span class="gi">+                    for iname in imported_names</span>
<span class="gi">+                    # discard imports of whole modules, that have no tree_name</span>
<span class="gi">+                    if iname.tree_name</span>
<span class="gi">+                ):</span>
<span class="gi">+                    yield name</span>
<span class="gi">+</span>
<span class="gi">+            elif self._is_fixture(self.parent_context, name):</span>
<span class="gi">+                yield name</span>
<span class="gi">+</span>
<span class="gi">+    def _is_fixture(self, context, name):</span>
<span class="gi">+        funcdef = name.parent</span>
<span class="gi">+        # Class fixtures are not supported</span>
<span class="gi">+        if funcdef.type != &quot;funcdef&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        decorated = funcdef.parent</span>
<span class="gi">+        if decorated.type != &quot;decorated&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        decorators = decorated.children[0]</span>
<span class="gi">+        if decorators.type == &#39;decorators&#39;:</span>
<span class="gi">+            decorators = decorators.children</span>
<span class="gi">+        else:</span>
<span class="gi">+            decorators = [decorators]</span>
<span class="gi">+        for decorator in decorators:</span>
<span class="gi">+            dotted_name = decorator.children[1]</span>
<span class="gi">+            # A heuristic, this makes it faster.</span>
<span class="gi">+            if &#39;fixture&#39; in dotted_name.get_code():</span>
<span class="gi">+                if dotted_name.type == &#39;atom_expr&#39;:</span>
<span class="gi">+                    # Since Python3.9 a decorator does not have dotted names</span>
<span class="gi">+                    # anymore.</span>
<span class="gi">+                    last_trailer = dotted_name.children[-1]</span>
<span class="gi">+                    last_leaf = last_trailer.get_last_leaf()</span>
<span class="gi">+                    if last_leaf == &#39;)&#39;:</span>
<span class="gi">+                        values = infer_call_of_leaf(</span>
<span class="gi">+                            context, last_leaf, cut_own_trailer=True</span>
<span class="gi">+                        )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        values = context.infer_node(dotted_name)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    values = context.infer_node(dotted_name)</span>
<span class="gi">+                for value in values:</span>
<span class="gi">+                    if value.name.get_qualified_names(include_module_names=True) \</span>
<span class="gi">+                            == (&#39;_pytest&#39;, &#39;fixtures&#39;, &#39;fixture&#39;):</span>
<span class="gi">+                        return True</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/jedi/plugins/registry.py b/jedi/plugins/registry.py</span>
<span class="gh">index 0d06a5e6..c1a0b749 100644</span>
<span class="gd">--- a/jedi/plugins/registry.py</span>
<span class="gi">+++ b/jedi/plugins/registry.py</span>
<span class="gu">@@ -1,9 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This is not a plugin, this is just the place were plugins are registered.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from jedi.plugins import stdlib
<span class="w"> </span>from jedi.plugins import flask
<span class="w"> </span>from jedi.plugins import pytest
<span class="w"> </span>from jedi.plugins import django
<span class="w"> </span>from jedi.plugins import plugin_manager
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>plugin_manager.register(stdlib, flask, pytest, django)
<span class="gh">diff --git a/jedi/plugins/stdlib.py b/jedi/plugins/stdlib.py</span>
<span class="gh">index 3c1eb074..e1004ec8 100644</span>
<span class="gd">--- a/jedi/plugins/stdlib.py</span>
<span class="gi">+++ b/jedi/plugins/stdlib.py</span>
<span class="gu">@@ -12,23 +12,33 @@ compiled module that returns the types for C-builtins.</span>
<span class="w"> </span>import parso
<span class="w"> </span>import os
<span class="w"> </span>from inspect import Parameter
<span class="gi">+</span>
<span class="w"> </span>from jedi import debug
<span class="w"> </span>from jedi.inference.utils import safe_property
<span class="w"> </span>from jedi.inference.helpers import get_str_or_none
<span class="gd">-from jedi.inference.arguments import iterate_argument_clinic, ParamIssue, repack_with_argument_clinic, AbstractArguments, TreeArgumentsWrapper</span>
<span class="gi">+from jedi.inference.arguments import iterate_argument_clinic, ParamIssue, \</span>
<span class="gi">+    repack_with_argument_clinic, AbstractArguments, TreeArgumentsWrapper</span>
<span class="w"> </span>from jedi.inference import analysis
<span class="w"> </span>from jedi.inference import compiled
<span class="gd">-from jedi.inference.value.instance import AnonymousMethodExecutionContext, MethodExecutionContext</span>
<span class="gd">-from jedi.inference.base_value import ContextualizedNode, NO_VALUES, ValueSet, ValueWrapper, LazyValueWrapper</span>
<span class="gi">+from jedi.inference.value.instance import \</span>
<span class="gi">+    AnonymousMethodExecutionContext, MethodExecutionContext</span>
<span class="gi">+from jedi.inference.base_value import ContextualizedNode, \</span>
<span class="gi">+    NO_VALUES, ValueSet, ValueWrapper, LazyValueWrapper</span>
<span class="w"> </span>from jedi.inference.value import ClassValue, ModuleValue
<span class="w"> </span>from jedi.inference.value.klass import ClassMixin
<span class="w"> </span>from jedi.inference.value.function import FunctionMixin
<span class="w"> </span>from jedi.inference.value import iterable
<span class="gd">-from jedi.inference.lazy_value import LazyTreeValue, LazyKnownValue, LazyKnownValues</span>
<span class="gi">+from jedi.inference.lazy_value import LazyTreeValue, LazyKnownValue, \</span>
<span class="gi">+    LazyKnownValues</span>
<span class="w"> </span>from jedi.inference.names import ValueName, BaseTreeParamName
<span class="gd">-from jedi.inference.filters import AttributeOverwrite, publish_method, ParserTreeFilter, DictFilter</span>
<span class="gi">+from jedi.inference.filters import AttributeOverwrite, publish_method, \</span>
<span class="gi">+    ParserTreeFilter, DictFilter</span>
<span class="w"> </span>from jedi.inference.signature import AbstractSignature, SignatureWrapper
<span class="gd">-_NAMEDTUPLE_CLASS_TEMPLATE = &quot;&quot;&quot;_property = property</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Copied from Python 3.6&#39;s stdlib.</span>
<span class="gi">+_NAMEDTUPLE_CLASS_TEMPLATE = &quot;&quot;&quot;\</span>
<span class="gi">+_property = property</span>
<span class="w"> </span>_tuple = tuple
<span class="w"> </span>from operator import itemgetter as _itemgetter
<span class="w"> </span>from collections import OrderedDict
<span class="gu">@@ -85,58 +95,293 @@ class {typename}(tuple):</span>

<span class="w"> </span>{field_defs}
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-_NAMEDTUPLE_FIELD_TEMPLATE = &quot;&quot;&quot;    {name} = _property(_itemgetter({index:d}), doc=&#39;Alias for field number {index:d}&#39;)</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+_NAMEDTUPLE_FIELD_TEMPLATE = &#39;&#39;&#39;\</span>
<span class="gi">+    {name} = _property(_itemgetter({index:d}), doc=&#39;Alias for field number {index:d}&#39;)</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def execute(callback):</span>
<span class="gi">+    def wrapper(value, arguments):</span>
<span class="gi">+        def call():</span>
<span class="gi">+            return callback(value, arguments=arguments)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj_name = value.name.string_name</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            p = value.parent_context</span>
<span class="gi">+            if p is not None and p.is_builtins_module():</span>
<span class="gi">+                module_name = &#39;builtins&#39;</span>
<span class="gi">+            elif p is not None and p.is_module():</span>
<span class="gi">+                module_name = p.py__name__()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return call()</span>
<span class="gi">+</span>
<span class="gi">+            if value.is_bound_method() or value.is_instance():</span>
<span class="gi">+                # value can be an instance for example if it is a partial</span>
<span class="gi">+                # object.</span>
<span class="gi">+                return call()</span>
<span class="gi">+</span>
<span class="gi">+            # for now we just support builtin functions.</span>
<span class="gi">+            try:</span>
<span class="gi">+                func = _implemented[module_name][obj_name]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                return func(value, arguments=arguments, callback=call)</span>
<span class="gi">+        return call()</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _follow_param(inference_state, arguments, index):</span>
<span class="gi">+    try:</span>
<span class="gi">+        key, lazy_value = list(arguments.unpack())[index]</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+    else:</span>
<span class="gi">+        return lazy_value.infer()</span>


<span class="w"> </span>def argument_clinic(clinic_string, want_value=False, want_context=False,
<span class="gd">-    want_arguments=False, want_inference_state=False, want_callback=False):</span>
<span class="gi">+                    want_arguments=False, want_inference_state=False,</span>
<span class="gi">+                    want_callback=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Works like Argument Clinic (PEP 436), to validate function params.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def f(func):</span>
<span class="gi">+        def wrapper(value, arguments, callback):</span>
<span class="gi">+            try:</span>
<span class="gi">+                args = tuple(iterate_argument_clinic(</span>
<span class="gi">+                    value.inference_state, arguments, clinic_string))</span>
<span class="gi">+            except ParamIssue:</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+            debug.dbg(&#39;builtin start %s&#39; % value, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+            if want_context:</span>
<span class="gi">+                kwargs[&#39;context&#39;] = arguments.context</span>
<span class="gi">+            if want_value:</span>
<span class="gi">+                kwargs[&#39;value&#39;] = value</span>
<span class="gi">+            if want_inference_state:</span>
<span class="gi">+                kwargs[&#39;inference_state&#39;] = value.inference_state</span>
<span class="gi">+            if want_arguments:</span>
<span class="gi">+                kwargs[&#39;arguments&#39;] = arguments</span>
<span class="gi">+            if want_callback:</span>
<span class="gi">+                kwargs[&#39;callback&#39;] = callback</span>
<span class="gi">+            result = func(*args, **kwargs)</span>
<span class="gi">+            debug.dbg(&#39;builtin end: %s&#39;, result, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return f</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;iterator[, default], /&#39;, want_inference_state=True)</span>
<span class="gi">+def builtins_next(iterators, defaults, inference_state):</span>
<span class="gi">+    # TODO theoretically we have to check here if something is an iterator.</span>
<span class="gi">+    # That is probably done by checking if it&#39;s not a class.</span>
<span class="gi">+    return defaults | iterators.py__getattribute__(&#39;__next__&#39;).execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;iterator[, default], /&#39;)</span>
<span class="gi">+def builtins_iter(iterators_or_callables, defaults):</span>
<span class="gi">+    # TODO implement this if it&#39;s a callable.</span>
<span class="gi">+    return iterators_or_callables.py__getattribute__(&#39;__iter__&#39;).execute_with_values()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;object, name[, default], /&#39;)</span>
<span class="gi">+def builtins_getattr(objects, names, defaults=None):</span>
<span class="gi">+    # follow the first param</span>
<span class="gi">+    for value in objects:</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            string = get_str_or_none(name)</span>
<span class="gi">+            if string is None:</span>
<span class="gi">+                debug.warning(&#39;getattr called without str&#39;)</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                return value.py__getattribute__(string)</span>
<span class="gi">+    return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;object[, bases, dict], /&#39;)</span>
<span class="gi">+def builtins_type(objects, bases, dicts):</span>
<span class="gi">+    if bases or dicts:</span>
<span class="gi">+        # It&#39;s a type creation... maybe someday...</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+    else:</span>
<span class="gi">+        return objects.py__class__()</span>


<span class="w"> </span>class SuperInstance(LazyValueWrapper):
<span class="w"> </span>    &quot;&quot;&quot;To be used like the object ``super`` returns.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, inference_state, instance):
<span class="w"> </span>        self.inference_state = inference_state
<span class="gd">-        self._instance = instance</span>
<span class="gi">+        self._instance = instance  # Corresponds to super().__self__</span>
<span class="gi">+</span>
<span class="gi">+    def _get_bases(self):</span>
<span class="gi">+        return self._instance.py__class__().py__bases__()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        objs = self._get_bases()[0].infer().execute_with_values()</span>
<span class="gi">+        if not objs:</span>
<span class="gi">+            # This is just a fallback and will only be used, if it&#39;s not</span>
<span class="gi">+            # possible to find a class</span>
<span class="gi">+            return self._instance</span>
<span class="gi">+        return next(iter(objs))</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        for b in self._get_bases():</span>
<span class="gi">+            for value in b.infer().execute_with_values():</span>
<span class="gi">+                for f in value.get_filters():</span>
<span class="gi">+                    yield f</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;[type[, value]], /&#39;, want_context=True)</span>
<span class="gi">+def builtins_super(types, objects, context):</span>
<span class="gi">+    instance = None</span>
<span class="gi">+    if isinstance(context, AnonymousMethodExecutionContext):</span>
<span class="gi">+        instance = context.instance</span>
<span class="gi">+    elif isinstance(context, MethodExecutionContext):</span>
<span class="gi">+        instance = context.instance</span>
<span class="gi">+    if instance is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+    return ValueSet({SuperInstance(instance.inference_state, instance)})</span>


<span class="w"> </span>class ReversedObject(AttributeOverwrite):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, reversed_obj, iter_list):
<span class="w"> </span>        super().__init__(reversed_obj)
<span class="w"> </span>        self._iter_list = iter_list

<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        return self._iter_list</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;__next__&#39;)</span>
<span class="gi">+    def _next(self, arguments):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            lazy_value.infer() for lazy_value in self._iter_list</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;sequence, /&#39;, want_value=True, want_arguments=True)</span>
<span class="gi">+def builtins_reversed(sequences, value, arguments):</span>
<span class="gi">+    # While we could do without this variable (just by using sequences), we</span>
<span class="gi">+    # want static analysis to work well. Therefore we need to generated the</span>
<span class="gi">+    # values again.</span>
<span class="gi">+    key, lazy_value = next(arguments.unpack())</span>
<span class="gi">+    cn = None</span>
<span class="gi">+    if isinstance(lazy_value, LazyTreeValue):</span>
<span class="gi">+        cn = ContextualizedNode(lazy_value.context, lazy_value.data)</span>
<span class="gi">+    ordered = list(sequences.iterate(cn))</span>
<span class="gi">+</span>
<span class="gi">+    # Repack iterator values and then run it the normal way. This is</span>
<span class="gi">+    # necessary, because `reversed` is a function and autocompletion</span>
<span class="gi">+    # would fail in certain cases like `reversed(x).__iter__` if we</span>
<span class="gi">+    # just returned the result directly.</span>
<span class="gi">+    seq, = value.inference_state.typing_module.py__getattribute__(&#39;Iterator&#39;).execute_with_values()</span>
<span class="gi">+    return ValueSet([ReversedObject(seq, list(reversed(ordered)))])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;value, type, /&#39;, want_arguments=True, want_inference_state=True)</span>
<span class="gi">+def builtins_isinstance(objects, types, arguments, inference_state):</span>
<span class="gi">+    bool_results = set()</span>
<span class="gi">+    for o in objects:</span>
<span class="gi">+        cls = o.py__class__()</span>
<span class="gi">+        try:</span>
<span class="gi">+            cls.py__bases__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # This is temporary. Everything should have a class attribute in</span>
<span class="gi">+            # Python?! Maybe we&#39;ll leave it here, because some numpy objects or</span>
<span class="gi">+            # whatever might not.</span>
<span class="gi">+            bool_results = set([True, False])</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        mro = list(cls.py__mro__())</span>
<span class="gi">+</span>
<span class="gi">+        for cls_or_tup in types:</span>
<span class="gi">+            if cls_or_tup.is_class():</span>
<span class="gi">+                bool_results.add(cls_or_tup in mro)</span>
<span class="gi">+            elif cls_or_tup.name.string_name == &#39;tuple&#39; \</span>
<span class="gi">+                    and cls_or_tup.get_root_context().is_builtins_module():</span>
<span class="gi">+                # Check for tuples.</span>
<span class="gi">+                classes = ValueSet.from_sets(</span>
<span class="gi">+                    lazy_value.infer()</span>
<span class="gi">+                    for lazy_value in cls_or_tup.iterate()</span>
<span class="gi">+                )</span>
<span class="gi">+                bool_results.add(any(cls in mro for cls in classes))</span>
<span class="gi">+            else:</span>
<span class="gi">+                _, lazy_value = list(arguments.unpack())[1]</span>
<span class="gi">+                if isinstance(lazy_value, LazyTreeValue):</span>
<span class="gi">+                    node = lazy_value.data</span>
<span class="gi">+                    message = &#39;TypeError: isinstance() arg 2 must be a &#39; \</span>
<span class="gi">+                              &#39;class, type, or tuple of classes and types, &#39; \</span>
<span class="gi">+                              &#39;not %s.&#39; % cls_or_tup</span>
<span class="gi">+                    analysis.add(lazy_value.context, &#39;type-error-isinstance&#39;, node, message)</span>
<span class="gi">+</span>
<span class="gi">+    return ValueSet(</span>
<span class="gi">+        compiled.builtin_from_name(inference_state, str(b))</span>
<span class="gi">+        for b in bool_results</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="w"> </span>class StaticMethodObject(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        return ValueSet([self._wrapped_value])</span>


<span class="gd">-class ClassMethodObject(ValueWrapper):</span>
<span class="gi">+@argument_clinic(&#39;sequence, /&#39;)</span>
<span class="gi">+def builtins_staticmethod(functions):</span>
<span class="gi">+    return ValueSet(StaticMethodObject(f) for f in functions)</span>

<span class="gi">+</span>
<span class="gi">+class ClassMethodObject(ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, class_method_obj, function):
<span class="w"> </span>        super().__init__(class_method_obj)
<span class="w"> </span>        self._function = function

<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        return ValueSet([</span>
<span class="gi">+            ClassMethodGet(__get__, class_value, self._function)</span>
<span class="gi">+            for __get__ in self._wrapped_value.py__getattribute__(&#39;__get__&#39;)</span>
<span class="gi">+        ])</span>

<span class="gd">-class ClassMethodGet(ValueWrapper):</span>

<span class="gi">+class ClassMethodGet(ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, get_method, klass, function):
<span class="w"> </span>        super().__init__(get_method)
<span class="w"> </span>        self._class = klass
<span class="w"> </span>        self._function = function

<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [sig.bind(self._function) for sig in self._function.get_signatures()]</span>

<span class="gd">-class ClassMethodArguments(TreeArgumentsWrapper):</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        return self._function.execute(ClassMethodArguments(self._class, arguments))</span>

<span class="gi">+</span>
<span class="gi">+class ClassMethodArguments(TreeArgumentsWrapper):</span>
<span class="w"> </span>    def __init__(self, klass, arguments):
<span class="w"> </span>        super().__init__(arguments)
<span class="w"> </span>        self._class = klass

<span class="gi">+    def unpack(self, func=None):</span>
<span class="gi">+        yield None, LazyKnownValue(self._class)</span>
<span class="gi">+        for values in self._wrapped_arguments.unpack(func):</span>
<span class="gi">+            yield values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;sequence, /&#39;, want_value=True, want_arguments=True)</span>
<span class="gi">+def builtins_classmethod(functions, value, arguments):</span>
<span class="gi">+    return ValueSet(</span>
<span class="gi">+        ClassMethodObject(class_method_object, function)</span>
<span class="gi">+        for class_method_object in value.py__call__(arguments=arguments)</span>
<span class="gi">+        for function in functions</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="w"> </span>class PropertyObject(AttributeOverwrite, ValueWrapper):
<span class="w"> </span>    api_type = &#39;property&#39;
<span class="gu">@@ -145,6 +390,26 @@ class PropertyObject(AttributeOverwrite, ValueWrapper):</span>
<span class="w"> </span>        super().__init__(property_obj)
<span class="w"> </span>        self._function = function

<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        if instance is None:</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+        return self._function.execute_with_values(instance)</span>
<span class="gi">+</span>
<span class="gi">+    @publish_method(&#39;deleter&#39;)</span>
<span class="gi">+    @publish_method(&#39;getter&#39;)</span>
<span class="gi">+    @publish_method(&#39;setter&#39;)</span>
<span class="gi">+    def _return_self(self, arguments):</span>
<span class="gi">+        return ValueSet({self})</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;func, /&#39;, want_callback=True)</span>
<span class="gi">+def builtins_property(functions, callback):</span>
<span class="gi">+    return ValueSet(</span>
<span class="gi">+        PropertyObject(property_value, function)</span>
<span class="gi">+        for property_value in callback()</span>
<span class="gi">+        for function in functions</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="w"> </span>def collections_namedtuple(value, arguments, callback):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -154,109 +419,461 @@ def collections_namedtuple(value, arguments, callback):</span>
<span class="w"> </span>    inferring the result.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    inference_state = value.inference_state</span>
<span class="gi">+</span>
<span class="gi">+    # Process arguments</span>
<span class="gi">+    name = &#39;jedi_unknown_namedtuple&#39;</span>
<span class="gi">+    for c in _follow_param(inference_state, arguments, 0):</span>
<span class="gi">+        x = get_str_or_none(c)</span>
<span class="gi">+        if x is not None:</span>
<span class="gi">+            name = x</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    # TODO here we only use one of the types, we should use all.</span>
<span class="gi">+    param_values = _follow_param(inference_state, arguments, 1)</span>
<span class="gi">+    if not param_values:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+    _fields = list(param_values)[0]</span>
<span class="gi">+    string = get_str_or_none(_fields)</span>
<span class="gi">+    if string is not None:</span>
<span class="gi">+        fields = string.replace(&#39;,&#39;, &#39; &#39;).split()</span>
<span class="gi">+    elif isinstance(_fields, iterable.Sequence):</span>
<span class="gi">+        fields = [</span>
<span class="gi">+            get_str_or_none(v)</span>
<span class="gi">+            for lazy_value in _fields.py__iter__()</span>
<span class="gi">+            for v in lazy_value.infer()</span>
<span class="gi">+        ]</span>
<span class="gi">+        fields = [f for f in fields if f is not None]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    # Build source code</span>
<span class="gi">+    code = _NAMEDTUPLE_CLASS_TEMPLATE.format(</span>
<span class="gi">+        typename=name,</span>
<span class="gi">+        field_names=tuple(fields),</span>
<span class="gi">+        num_fields=len(fields),</span>
<span class="gi">+        arg_list=repr(tuple(fields)).replace(&quot;&#39;&quot;, &quot;&quot;)[1:-1],</span>
<span class="gi">+        repr_fmt=&#39;&#39;,</span>
<span class="gi">+        field_defs=&#39;\n&#39;.join(_NAMEDTUPLE_FIELD_TEMPLATE.format(index=index, name=name)</span>
<span class="gi">+                             for index, name in enumerate(fields))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Parse source code</span>
<span class="gi">+    module = inference_state.grammar.parse(code)</span>
<span class="gi">+    generated_class = next(module.iter_classdefs())</span>
<span class="gi">+    parent_context = ModuleValue(</span>
<span class="gi">+        inference_state, module,</span>
<span class="gi">+        code_lines=parso.split_lines(code, keepends=True),</span>
<span class="gi">+    ).as_context()</span>
<span class="gi">+</span>
<span class="gi">+    return ValueSet([ClassValue(inference_state, parent_context, generated_class)])</span>


<span class="w"> </span>class PartialObject(ValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, actual_value, arguments, instance=None):
<span class="w"> </span>        super().__init__(actual_value)
<span class="w"> </span>        self._arguments = arguments
<span class="w"> </span>        self._instance = instance

<span class="gi">+    def _get_functions(self, unpacked_arguments):</span>
<span class="gi">+        key, lazy_value = next(unpacked_arguments, (None, None))</span>
<span class="gi">+        if key is not None or lazy_value is None:</span>
<span class="gi">+            debug.warning(&quot;Partial should have a proper function %s&quot;, self._arguments)</span>
<span class="gi">+            return None</span>
<span class="gi">+        return lazy_value.infer()</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        unpacked_arguments = self._arguments.unpack()</span>
<span class="gi">+        funcs = self._get_functions(unpacked_arguments)</span>
<span class="gi">+        if funcs is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        arg_count = 0</span>
<span class="gi">+        if self._instance is not None:</span>
<span class="gi">+            arg_count = 1</span>
<span class="gi">+        keys = set()</span>
<span class="gi">+        for key, _ in unpacked_arguments:</span>
<span class="gi">+            if key is None:</span>
<span class="gi">+                arg_count += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                keys.add(key)</span>
<span class="gi">+        return [PartialSignature(s, arg_count, keys) for s in funcs.get_signatures()]</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        funcs = self._get_functions(self._arguments.unpack())</span>
<span class="gi">+        if funcs is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        return funcs.execute(</span>
<span class="gi">+            MergedPartialArguments(self._arguments, arguments, self._instance)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def py__doc__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        In CPython partial does not replace the docstring. However we are still
<span class="w"> </span>        imitating it here, because we want this docstring to be worth something
<span class="w"> </span>        for the user.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        callables = self._get_functions(self._arguments.unpack())</span>
<span class="gi">+        if callables is None:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        for callable_ in callables:</span>
<span class="gi">+            return callable_.py__doc__()</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        return ValueSet([self])</span>


<span class="w"> </span>class PartialMethodObject(PartialObject):
<span class="gd">-    pass</span>
<span class="gi">+    def py__get__(self, instance, class_value):</span>
<span class="gi">+        if instance is None:</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+        return ValueSet([PartialObject(self._wrapped_value, self._arguments, instance)])</span>


<span class="w"> </span>class PartialSignature(SignatureWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, wrapped_signature, skipped_arg_count, skipped_arg_set):
<span class="w"> </span>        super().__init__(wrapped_signature)
<span class="w"> </span>        self._skipped_arg_count = skipped_arg_count
<span class="w"> </span>        self._skipped_arg_set = skipped_arg_set

<span class="gi">+    def get_param_names(self, resolve_stars=False):</span>
<span class="gi">+        names = self._wrapped_signature.get_param_names()[self._skipped_arg_count:]</span>
<span class="gi">+        return [n for n in names if n.string_name not in self._skipped_arg_set]</span>

<span class="gd">-class MergedPartialArguments(AbstractArguments):</span>

<span class="gi">+class MergedPartialArguments(AbstractArguments):</span>
<span class="w"> </span>    def __init__(self, partial_arguments, call_arguments, instance=None):
<span class="w"> </span>        self._partial_arguments = partial_arguments
<span class="w"> </span>        self._call_arguments = call_arguments
<span class="w"> </span>        self._instance = instance

<span class="gi">+    def unpack(self, funcdef=None):</span>
<span class="gi">+        unpacked = self._partial_arguments.unpack(funcdef)</span>
<span class="gi">+        # Ignore this one, it&#39;s the function. It was checked before that it&#39;s</span>
<span class="gi">+        # there.</span>
<span class="gi">+        next(unpacked, None)</span>
<span class="gi">+        if self._instance is not None:</span>
<span class="gi">+            yield None, LazyKnownValue(self._instance)</span>
<span class="gi">+        for key_lazy_value in unpacked:</span>
<span class="gi">+            yield key_lazy_value</span>
<span class="gi">+        for key_lazy_value in self._call_arguments.unpack(funcdef):</span>
<span class="gi">+            yield key_lazy_value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def functools_partial(value, arguments, callback):</span>
<span class="gi">+    return ValueSet(</span>
<span class="gi">+        PartialObject(instance, arguments)</span>
<span class="gi">+        for instance in value.py__call__(arguments)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def functools_partialmethod(value, arguments, callback):</span>
<span class="gi">+    return ValueSet(</span>
<span class="gi">+        PartialMethodObject(instance, arguments)</span>
<span class="gi">+        for instance in value.py__call__(arguments)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;first, /&#39;)</span>
<span class="gi">+def _return_first_param(firsts):</span>
<span class="gi">+    return firsts</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;seq&#39;)</span>
<span class="gi">+def _random_choice(sequences):</span>
<span class="gi">+    return ValueSet.from_sets(</span>
<span class="gi">+        lazy_value.infer()</span>
<span class="gi">+        for sequence in sequences</span>
<span class="gi">+        for lazy_value in sequence.py__iter__()</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dataclass(value, arguments, callback):</span>
<span class="gi">+    for c in _follow_param(value.inference_state, arguments, 0):</span>
<span class="gi">+        if c.is_class():</span>
<span class="gi">+            return ValueSet([DataclassWrapper(c)])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ValueSet([value])</span>
<span class="gi">+    return NO_VALUES</span>
<span class="gi">+</span>

<span class="w"> </span>class DataclassWrapper(ValueWrapper, ClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        param_names = []</span>
<span class="gi">+        for cls in reversed(list(self.py__mro__())):</span>
<span class="gi">+            if isinstance(cls, DataclassWrapper):</span>
<span class="gi">+                filter_ = cls.as_context().get_global_filter()</span>
<span class="gi">+                # .values ordering is not guaranteed, at least not in</span>
<span class="gi">+                # Python &lt; 3.6, when dicts where not ordered, which is an</span>
<span class="gi">+                # implementation detail anyway.</span>
<span class="gi">+                for name in sorted(filter_.values(), key=lambda name: name.start_pos):</span>
<span class="gi">+                    d = name.tree_name.get_definition()</span>
<span class="gi">+                    annassign = d.children[1]</span>
<span class="gi">+                    if d.type == &#39;expr_stmt&#39; and annassign.type == &#39;annassign&#39;:</span>
<span class="gi">+                        if len(annassign.children) &lt; 4:</span>
<span class="gi">+                            default = None</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            default = annassign.children[3]</span>
<span class="gi">+                        param_names.append(DataclassParamName(</span>
<span class="gi">+                            parent_context=cls.parent_context,</span>
<span class="gi">+                            tree_name=name.tree_name,</span>
<span class="gi">+                            annotation_node=annassign.children[1],</span>
<span class="gi">+                            default_node=default,</span>
<span class="gi">+                        ))</span>
<span class="gi">+        return [DataclassSignature(cls, param_names)]</span>


<span class="w"> </span>class DataclassSignature(AbstractSignature):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value, param_names):
<span class="w"> </span>        super().__init__(value)
<span class="w"> </span>        self._param_names = param_names

<span class="gi">+    def get_param_names(self, resolve_stars=False):</span>
<span class="gi">+        return self._param_names</span>

<span class="gd">-class DataclassParamName(BaseTreeParamName):</span>

<span class="gd">-    def __init__(self, parent_context, tree_name, annotation_node, default_node</span>
<span class="gd">-        ):</span>
<span class="gi">+class DataclassParamName(BaseTreeParamName):</span>
<span class="gi">+    def __init__(self, parent_context, tree_name, annotation_node, default_node):</span>
<span class="w"> </span>        super().__init__(parent_context, tree_name)
<span class="w"> </span>        self.annotation_node = annotation_node
<span class="w"> </span>        self.default_node = default_node

<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        return Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        if self.annotation_node is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.parent_context.infer_node(self.annotation_node)</span>

<span class="gd">-class ItemGetterCallable(ValueWrapper):</span>

<span class="gi">+class ItemGetterCallable(ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, instance, args_value_set):
<span class="w"> </span>        super().__init__(instance)
<span class="w"> </span>        self._args_value_set = args_value_set

<span class="gi">+    @repack_with_argument_clinic(&#39;item, /&#39;)</span>
<span class="gi">+    def py__call__(self, item_value_set):</span>
<span class="gi">+        value_set = NO_VALUES</span>
<span class="gi">+        for args_value in self._args_value_set:</span>
<span class="gi">+            lazy_values = list(args_value.py__iter__())</span>
<span class="gi">+            if len(lazy_values) == 1:</span>
<span class="gi">+                # TODO we need to add the contextualized value.</span>
<span class="gi">+                value_set |= item_value_set.get_item(lazy_values[0].infer(), None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value_set |= ValueSet([iterable.FakeList(</span>
<span class="gi">+                    self._wrapped_value.inference_state,</span>
<span class="gi">+                    [</span>
<span class="gi">+                        LazyKnownValues(item_value_set.get_item(lazy_value.infer(), None))</span>
<span class="gi">+                        for lazy_value in lazy_values</span>
<span class="gi">+                    ],</span>
<span class="gi">+                )])</span>
<span class="gi">+        return value_set</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;func, /&#39;)</span>
<span class="gi">+def _functools_wraps(funcs):</span>
<span class="gi">+    return ValueSet(WrapsCallable(func) for func in funcs)</span>
<span class="gi">+</span>

<span class="w"> </span>class WrapsCallable(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    # XXX this is not the correct wrapped value, it should be a weird</span>
<span class="gi">+    #     partials object, but it doesn&#39;t matter, because it&#39;s always used as a</span>
<span class="gi">+    #     decorator anyway.</span>
<span class="gi">+    @repack_with_argument_clinic(&#39;func, /&#39;)</span>
<span class="gi">+    def py__call__(self, funcs):</span>
<span class="gi">+        return ValueSet({Wrapped(func, self._wrapped_value) for func in funcs})</span>


<span class="w"> </span>class Wrapped(ValueWrapper, FunctionMixin):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, func, original_function):
<span class="w"> </span>        super().__init__(func)
<span class="w"> </span>        self._original_function = original_function

<span class="gd">-</span>
<span class="gd">-_implemented = {&#39;builtins&#39;: {&#39;getattr&#39;: builtins_getattr, &#39;type&#39;:</span>
<span class="gd">-    builtins_type, &#39;super&#39;: builtins_super, &#39;reversed&#39;: builtins_reversed,</span>
<span class="gd">-    &#39;isinstance&#39;: builtins_isinstance, &#39;next&#39;: builtins_next, &#39;iter&#39;:</span>
<span class="gd">-    builtins_iter, &#39;staticmethod&#39;: builtins_staticmethod, &#39;classmethod&#39;:</span>
<span class="gd">-    builtins_classmethod, &#39;property&#39;: builtins_property}, &#39;copy&#39;: {&#39;copy&#39;:</span>
<span class="gd">-    _return_first_param, &#39;deepcopy&#39;: _return_first_param}, &#39;json&#39;: {&#39;load&#39;:</span>
<span class="gd">-    lambda value, arguments, callback: NO_VALUES, &#39;loads&#39;: lambda value,</span>
<span class="gd">-    arguments, callback: NO_VALUES}, &#39;collections&#39;: {&#39;namedtuple&#39;:</span>
<span class="gd">-    collections_namedtuple}, &#39;functools&#39;: {&#39;partial&#39;: functools_partial,</span>
<span class="gd">-    &#39;partialmethod&#39;: functools_partialmethod, &#39;wraps&#39;: _functools_wraps},</span>
<span class="gd">-    &#39;_weakref&#39;: {&#39;proxy&#39;: _return_first_param}, &#39;random&#39;: {&#39;choice&#39;:</span>
<span class="gd">-    _random_choice}, &#39;operator&#39;: {&#39;itemgetter&#39;: _operator_itemgetter},</span>
<span class="gd">-    &#39;abc&#39;: {&#39;abstractmethod&#39;: _return_first_param}, &#39;typing&#39;: {&#39;_alias&#39;: lambda</span>
<span class="gd">-    value, arguments, callback: NO_VALUES, &#39;runtime_checkable&#39;: lambda</span>
<span class="gd">-    value, arguments, callback: NO_VALUES}, &#39;dataclasses&#39;: {&#39;dataclass&#39;:</span>
<span class="gd">-    _dataclass}, &#39;attr&#39;: {&#39;define&#39;: _dataclass, &#39;frozen&#39;: _dataclass},</span>
<span class="gd">-    &#39;attrs&#39;: {&#39;define&#39;: _dataclass, &#39;frozen&#39;: _dataclass}, &#39;os.path&#39;: {</span>
<span class="gd">-    &#39;dirname&#39;: _create_string_input_function(os.path.dirname), &#39;abspath&#39;:</span>
<span class="gd">-    _create_string_input_function(os.path.abspath), &#39;relpath&#39;:</span>
<span class="gd">-    _create_string_input_function(os.path.relpath), &#39;join&#39;: _os_path_join}}</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return self._original_function.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_signature_functions(self):</span>
<span class="gi">+        return [self]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;*args, /&#39;, want_value=True, want_arguments=True)</span>
<span class="gi">+def _operator_itemgetter(args_value_set, value, arguments):</span>
<span class="gi">+    return ValueSet([</span>
<span class="gi">+        ItemGetterCallable(instance, args_value_set)</span>
<span class="gi">+        for instance in value.py__call__(arguments)</span>
<span class="gi">+    ])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_string_input_function(func):</span>
<span class="gi">+    @argument_clinic(&#39;string, /&#39;, want_value=True, want_arguments=True)</span>
<span class="gi">+    def wrapper(strings, value, arguments):</span>
<span class="gi">+        def iterate():</span>
<span class="gi">+            for value in strings:</span>
<span class="gi">+                s = get_str_or_none(value)</span>
<span class="gi">+                if s is not None:</span>
<span class="gi">+                    s = func(s)</span>
<span class="gi">+                    yield compiled.create_simple_object(value.inference_state, s)</span>
<span class="gi">+        values = ValueSet(iterate())</span>
<span class="gi">+        if values:</span>
<span class="gi">+            return values</span>
<span class="gi">+        return value.py__call__(arguments)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@argument_clinic(&#39;*args, /&#39;, want_callback=True)</span>
<span class="gi">+def _os_path_join(args_set, callback):</span>
<span class="gi">+    if len(args_set) == 1:</span>
<span class="gi">+        string = &#39;&#39;</span>
<span class="gi">+        sequence, = args_set</span>
<span class="gi">+        is_first = True</span>
<span class="gi">+        for lazy_value in sequence.py__iter__():</span>
<span class="gi">+            string_values = lazy_value.infer()</span>
<span class="gi">+            if len(string_values) != 1:</span>
<span class="gi">+                break</span>
<span class="gi">+            s = get_str_or_none(next(iter(string_values)))</span>
<span class="gi">+            if s is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            if not is_first:</span>
<span class="gi">+                string += os.path.sep</span>
<span class="gi">+            string += s</span>
<span class="gi">+            is_first = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ValueSet([compiled.create_simple_object(sequence.inference_state, string)])</span>
<span class="gi">+    return callback()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_implemented = {</span>
<span class="gi">+    &#39;builtins&#39;: {</span>
<span class="gi">+        &#39;getattr&#39;: builtins_getattr,</span>
<span class="gi">+        &#39;type&#39;: builtins_type,</span>
<span class="gi">+        &#39;super&#39;: builtins_super,</span>
<span class="gi">+        &#39;reversed&#39;: builtins_reversed,</span>
<span class="gi">+        &#39;isinstance&#39;: builtins_isinstance,</span>
<span class="gi">+        &#39;next&#39;: builtins_next,</span>
<span class="gi">+        &#39;iter&#39;: builtins_iter,</span>
<span class="gi">+        &#39;staticmethod&#39;: builtins_staticmethod,</span>
<span class="gi">+        &#39;classmethod&#39;: builtins_classmethod,</span>
<span class="gi">+        &#39;property&#39;: builtins_property,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;copy&#39;: {</span>
<span class="gi">+        &#39;copy&#39;: _return_first_param,</span>
<span class="gi">+        &#39;deepcopy&#39;: _return_first_param,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;json&#39;: {</span>
<span class="gi">+        &#39;load&#39;: lambda value, arguments, callback: NO_VALUES,</span>
<span class="gi">+        &#39;loads&#39;: lambda value, arguments, callback: NO_VALUES,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;collections&#39;: {</span>
<span class="gi">+        &#39;namedtuple&#39;: collections_namedtuple,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;functools&#39;: {</span>
<span class="gi">+        &#39;partial&#39;: functools_partial,</span>
<span class="gi">+        &#39;partialmethod&#39;: functools_partialmethod,</span>
<span class="gi">+        &#39;wraps&#39;: _functools_wraps,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;_weakref&#39;: {</span>
<span class="gi">+        &#39;proxy&#39;: _return_first_param,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;random&#39;: {</span>
<span class="gi">+        &#39;choice&#39;: _random_choice,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;operator&#39;: {</span>
<span class="gi">+        &#39;itemgetter&#39;: _operator_itemgetter,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;abc&#39;: {</span>
<span class="gi">+        # Not sure if this is necessary, but it&#39;s used a lot in typeshed and</span>
<span class="gi">+        # it&#39;s for now easier to just pass the function.</span>
<span class="gi">+        &#39;abstractmethod&#39;: _return_first_param,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;typing&#39;: {</span>
<span class="gi">+        # The _alias function just leads to some annoying type inference.</span>
<span class="gi">+        # Therefore, just make it return nothing, which leads to the stubs</span>
<span class="gi">+        # being used instead. This only matters for 3.7+.</span>
<span class="gi">+        &#39;_alias&#39;: lambda value, arguments, callback: NO_VALUES,</span>
<span class="gi">+        # runtime_checkable doesn&#39;t really change anything and is just</span>
<span class="gi">+        # adding logs for infering stuff, so we can safely ignore it.</span>
<span class="gi">+        &#39;runtime_checkable&#39;: lambda value, arguments, callback: NO_VALUES,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;dataclasses&#39;: {</span>
<span class="gi">+        # For now this works at least better than Jedi trying to understand it.</span>
<span class="gi">+        &#39;dataclass&#39;: _dataclass</span>
<span class="gi">+    },</span>
<span class="gi">+    # attrs exposes declaration interface roughly compatible with dataclasses</span>
<span class="gi">+    # via attrs.define, attrs.frozen and attrs.mutable</span>
<span class="gi">+    # https://www.attrs.org/en/stable/names.html</span>
<span class="gi">+    &#39;attr&#39;: {</span>
<span class="gi">+        &#39;define&#39;: _dataclass,</span>
<span class="gi">+        &#39;frozen&#39;: _dataclass,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;attrs&#39;: {</span>
<span class="gi">+        &#39;define&#39;: _dataclass,</span>
<span class="gi">+        &#39;frozen&#39;: _dataclass,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;os.path&#39;: {</span>
<span class="gi">+        &#39;dirname&#39;: _create_string_input_function(os.path.dirname),</span>
<span class="gi">+        &#39;abspath&#39;: _create_string_input_function(os.path.abspath),</span>
<span class="gi">+        &#39;relpath&#39;: _create_string_input_function(os.path.relpath),</span>
<span class="gi">+        &#39;join&#39;: _os_path_join,</span>
<span class="gi">+    }</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_metaclass_filters(func):</span>
<span class="gi">+    def wrapper(cls, metaclasses, is_instance):</span>
<span class="gi">+        for metaclass in metaclasses:</span>
<span class="gi">+            if metaclass.py__name__() == &#39;EnumMeta&#39; \</span>
<span class="gi">+                    and metaclass.get_root_context().py__name__() == &#39;enum&#39;:</span>
<span class="gi">+                filter_ = ParserTreeFilter(parent_context=cls.as_context())</span>
<span class="gi">+                return [DictFilter({</span>
<span class="gi">+                    name.string_name: EnumInstance(cls, name).name</span>
<span class="gi">+                    for name in filter_.values()</span>
<span class="gi">+                })]</span>
<span class="gi">+        return func(cls, metaclasses, is_instance)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class EnumInstance(LazyValueWrapper):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, cls, name):
<span class="w"> </span>        self.inference_state = cls.inference_state
<span class="gd">-        self._cls = cls</span>
<span class="gi">+        self._cls = cls  # Corresponds to super().__self__</span>
<span class="w"> </span>        self._name = name
<span class="w"> </span>        self.tree_node = self._name.tree_name
<span class="gi">+</span>
<span class="gi">+    @safe_property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self._name.tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        n = self._name.string_name</span>
<span class="gi">+        if n.startswith(&#39;__&#39;) and n.endswith(&#39;__&#39;) or self._name.api_type == &#39;function&#39;:</span>
<span class="gi">+            inferred = self._name.infer()</span>
<span class="gi">+            if inferred:</span>
<span class="gi">+                return next(iter(inferred))</span>
<span class="gi">+            o, = self.inference_state.builtins_module.py__getattribute__(&#39;object&#39;)</span>
<span class="gi">+            return o</span>
<span class="gi">+</span>
<span class="gi">+        value, = self._cls.execute_with_values()</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        yield DictFilter(dict(</span>
<span class="gi">+            name=compiled.create_simple_object(self.inference_state, self._name.string_name).name,</span>
<span class="gi">+            value=self._name,</span>
<span class="gi">+        ))</span>
<span class="gi">+        for f in self._get_wrapped_value().get_filters():</span>
<span class="gi">+            yield f</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tree_name_to_values(func):</span>
<span class="gi">+    def wrapper(inference_state, context, tree_name):</span>
<span class="gi">+        if tree_name.value == &#39;sep&#39; and context.is_module() and context.py__name__() == &#39;os.path&#39;:</span>
<span class="gi">+            return ValueSet({</span>
<span class="gi">+                compiled.create_simple_object(inference_state, os.path.sep),</span>
<span class="gi">+            })</span>
<span class="gi">+        return func(inference_state, context, tree_name)</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/settings.py b/jedi/settings.py</span>
<span class="gh">index 3f9febf2..3a333e01 100644</span>
<span class="gd">--- a/jedi/settings.py</span>
<span class="gi">+++ b/jedi/settings.py</span>
<span class="gu">@@ -49,22 +49,36 @@ Caching</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import os
<span class="w"> </span>import platform
<span class="gi">+</span>
<span class="gi">+# ----------------</span>
<span class="gi">+# Completion Output Settings</span>
<span class="gi">+# ----------------</span>
<span class="gi">+</span>
<span class="w"> </span>case_insensitive_completion = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Completions are by default case insensitive.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>add_bracket_after_function = False
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Adds an opening bracket after a function for completions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# ----------------</span>
<span class="gi">+# Filesystem Cache</span>
<span class="gi">+# ----------------</span>
<span class="gi">+</span>
<span class="w"> </span>if platform.system().lower() == &#39;windows&#39;:
<span class="gd">-    _cache_directory = os.path.join(os.getenv(&#39;LOCALAPPDATA&#39;) or os.path.</span>
<span class="gd">-        expanduser(&#39;~&#39;), &#39;Jedi&#39;, &#39;Jedi&#39;)</span>
<span class="gi">+    _cache_directory = os.path.join(</span>
<span class="gi">+        os.getenv(&#39;LOCALAPPDATA&#39;) or os.path.expanduser(&#39;~&#39;),</span>
<span class="gi">+        &#39;Jedi&#39;,</span>
<span class="gi">+        &#39;Jedi&#39;,</span>
<span class="gi">+    )</span>
<span class="w"> </span>elif platform.system().lower() == &#39;darwin&#39;:
<span class="w"> </span>    _cache_directory = os.path.join(&#39;~&#39;, &#39;Library&#39;, &#39;Caches&#39;, &#39;Jedi&#39;)
<span class="w"> </span>else:
<span class="gd">-    _cache_directory = os.path.join(os.getenv(&#39;XDG_CACHE_HOME&#39;) or</span>
<span class="gd">-        &#39;~/.cache&#39;, &#39;jedi&#39;)</span>
<span class="gi">+    _cache_directory = os.path.join(os.getenv(&#39;XDG_CACHE_HOME&#39;) or &#39;~/.cache&#39;,</span>
<span class="gi">+                                    &#39;jedi&#39;)</span>
<span class="w"> </span>cache_directory = os.path.expanduser(_cache_directory)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>The path where the cache is stored.
<span class="gu">@@ -74,6 +88,11 @@ On Linux, this defaults to ``~/.cache/jedi/``, on OS X to</span>
<span class="w"> </span>On Linux, if the environment variable ``$XDG_CACHE_HOME`` is set,
<span class="w"> </span>``$XDG_CACHE_HOME/jedi`` is used instead of the default one.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# ----------------</span>
<span class="gi">+# Parser</span>
<span class="gi">+# ----------------</span>
<span class="gi">+</span>
<span class="w"> </span>fast_parser = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Uses Parso&#39;s diff parser. If it is enabled, this might cause issues, please
<span class="gu">@@ -81,36 +100,49 @@ read the warning on :class:`.Script`. This feature makes it possible to only</span>
<span class="w"> </span>parse the parts again that have changed, while reusing the rest of the syntax
<span class="w"> </span>tree.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-_cropped_file_size = int(10000000.0)</span>
<span class="gi">+</span>
<span class="gi">+_cropped_file_size = int(10e6)  # 1 Megabyte</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Jedi gets extremely slow if the file size exceed a few thousand lines.
<span class="w"> </span>To avoid getting stuck completely Jedi crops the file at some point.

<span class="w"> </span>One megabyte of typical Python code equals about 20&#39;000 lines of code.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# ----------------</span>
<span class="gi">+# Dynamic Stuff</span>
<span class="gi">+# ----------------</span>
<span class="gi">+</span>
<span class="w"> </span>dynamic_array_additions = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>check for `append`, etc. on arrays: [], {}, () as well as list/set calls.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>dynamic_params = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A dynamic param completion, finds the callees of the function, which define
<span class="w"> </span>the params of a function.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>dynamic_params_for_other_modules = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Do the same for other modules.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>dynamic_flow_information = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Check for `isinstance` and other information to infer a type.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-auto_import_modules = [&#39;gi&#39;]</span>
<span class="gi">+</span>
<span class="gi">+auto_import_modules = [</span>
<span class="gi">+    &#39;gi&#39;,  # This third-party repository (GTK stuff) doesn&#39;t really work with jedi</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Modules that will not be analyzed but imported, if they contain Python code.
<span class="w"> </span>This improves autocompletion for libraries that use ``setattr`` or
<span class="w"> </span>``globals()`` modifications a lot.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>allow_unsafe_interpreter_executions = True
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Controls whether descriptors are evaluated when using an Interpreter. This is
<span class="gu">@@ -119,6 +151,11 @@ something you might want to control when using Jedi from a Repl (e.g. IPython)</span>
<span class="w"> </span>Generally this setting allows Jedi to execute __getitem__ and descriptors like
<span class="w"> </span>`property`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# ----------------</span>
<span class="gi">+# Caching Validity</span>
<span class="gi">+# ----------------</span>
<span class="gi">+</span>
<span class="w"> </span>call_signatures_validity = 3.0
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Finding function calls might be slow (0.1-0.5s). This is not acceptible for
<span class="gh">diff --git a/jedi/utils.py b/jedi/utils.py</span>
<span class="gh">index 0dc90e28..dd529be7 100644</span>
<span class="gd">--- a/jedi/utils.py</span>
<span class="gi">+++ b/jedi/utils.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Utilities for end-users.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import __main__
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>import logging
<span class="gu">@@ -8,7 +9,10 @@ import traceback</span>
<span class="w"> </span>import re
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from jedi import Interpreter
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>READLINE_DEBUG = False


<span class="gu">@@ -54,7 +58,69 @@ def setup_readline(namespace_module=__main__, fuzzy=False):</span>
<span class="w"> </span>    your shell profile (usually ``.bash_profile`` or ``.profile`` if you use
<span class="w"> </span>    bash).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if READLINE_DEBUG:</span>
<span class="gi">+        logging.basicConfig(</span>
<span class="gi">+            filename=&#39;/tmp/jedi.log&#39;,</span>
<span class="gi">+            filemode=&#39;a&#39;,</span>
<span class="gi">+            level=logging.DEBUG</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    class JediRL:</span>
<span class="gi">+        def complete(self, text, state):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            This complete stuff is pretty weird, a generator would make</span>
<span class="gi">+            a lot more sense, but probably due to backwards compatibility</span>
<span class="gi">+            this is still the way how it works.</span>
<span class="gi">+</span>
<span class="gi">+            The only important part is stuff in the ``state == 0`` flow,</span>
<span class="gi">+            everything else has been copied from the ``rlcompleter`` std.</span>
<span class="gi">+            library module.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if state == 0:</span>
<span class="gi">+                sys.path.insert(0, os.getcwd())</span>
<span class="gi">+                # Calling python doesn&#39;t have a path, so add to sys.path.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    logging.debug(&quot;Start REPL completion: &quot; + repr(text))</span>
<span class="gi">+                    interpreter = Interpreter(text, [namespace_module.__dict__])</span>
<span class="gi">+</span>
<span class="gi">+                    completions = interpreter.complete(fuzzy=fuzzy)</span>
<span class="gi">+                    logging.debug(&quot;REPL completions: %s&quot;, completions)</span>
<span class="gi">+</span>
<span class="gi">+                    self.matches = [</span>
<span class="gi">+                        text[:len(text) - c._like_name_length] + c.name_with_symbols</span>
<span class="gi">+                        for c in completions</span>
<span class="gi">+                    ]</span>
<span class="gi">+                except:</span>
<span class="gi">+                    logging.error(&quot;REPL Completion error:\n&quot; + traceback.format_exc())</span>
<span class="gi">+                    raise</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    sys.path.pop(0)</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.matches[state]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Need to import this one as well to make sure it&#39;s executed before</span>
<span class="gi">+        # this code. This didn&#39;t use to be an issue until 3.3. Starting with</span>
<span class="gi">+        # 3.4 this is different, it always overwrites the completer if it&#39;s not</span>
<span class="gi">+        # already imported here.</span>
<span class="gi">+        import rlcompleter  # noqa: F401</span>
<span class="gi">+        import readline</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        print(&quot;Jedi: Module readline not available.&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        readline.set_completer(JediRL().complete)</span>
<span class="gi">+        readline.parse_and_bind(&quot;tab: complete&quot;)</span>
<span class="gi">+        # jedi itself does the case matching</span>
<span class="gi">+        readline.parse_and_bind(&quot;set completion-ignore-case on&quot;)</span>
<span class="gi">+        # because it&#39;s easier to hit the tab just once</span>
<span class="gi">+        readline.parse_and_bind(&quot;set show-all-if-unmodified&quot;)</span>
<span class="gi">+        readline.parse_and_bind(&quot;set show-all-if-ambiguous on&quot;)</span>
<span class="gi">+        # don&#39;t repeat all the things written in the readline all the time</span>
<span class="gi">+        readline.parse_and_bind(&quot;set completion-prefix-display-length 2&quot;)</span>
<span class="gi">+        # No delimiters, Jedi handles that.</span>
<span class="gi">+        readline.set_completer_delims(&#39;&#39;)</span>


<span class="w"> </span>def version_info():
<span class="gu">@@ -62,4 +128,7 @@ def version_info():</span>
<span class="w"> </span>    Returns a namedtuple of Jedi&#39;s version, similar to Python&#39;s
<span class="w"> </span>    ``sys.version_info``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    Version = namedtuple(&#39;Version&#39;, &#39;major, minor, micro&#39;)</span>
<span class="gi">+    from jedi import __version__</span>
<span class="gi">+    tupl = re.findall(r&#39;[a-z]+|\d+&#39;, __version__)</span>
<span class="gi">+    return Version(*[x if i == 3 else int(x) for i, x in enumerate(tupl)])</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>