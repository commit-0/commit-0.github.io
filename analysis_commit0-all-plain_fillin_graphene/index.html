
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin graphene - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-graphene" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin graphene
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-graphene" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test graphene
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_orderedtypepytest_orderedtype" class="md-nav__link">
    <span class="md-ellipsis">
      test_orderedtype.py::test_orderedtype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_orderedtypepytest_orderedtype_eq" class="md-nav__link">
    <span class="md-ellipsis">
      test_orderedtype.py::test_orderedtype_eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_orderedtypepytest_orderedtype_hash" class="md-nav__link">
    <span class="md-ellipsis">
      test_orderedtype.py::test_orderedtype_hash
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_orderedtypepytest_orderedtype_resetcounter" class="md-nav__link">
    <span class="md-ellipsis">
      test_orderedtype.py::test_orderedtype_resetcounter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_orderedtypepytest_orderedtype_non_orderabletypes" class="md-nav__link">
    <span class="md-ellipsis">
      test_orderedtype.py::test_orderedtype_non_orderabletypes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-graphene"><strong>Claude Sonnet 3.5 - Fill-in</strong>: graphene</h1>
<h2 id="pytest-summary-for-test-graphene">Pytest Summary for test <code>graphene</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_orderedtypepytest_orderedtype">test_orderedtype.py::test_orderedtype</h3>
<details><summary> <pre>test_orderedtype.py::test_orderedtype</pre></summary><pre>
name = 'graphene', package = None

    def import_module(name, package=None):
        """Import a module.

        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.

        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/__init__.py:2: in <module>
    from .relay import (
graphene/relay/__init__.py:1: in <module>
    from .node import Node, is_node, GlobalID
graphene/relay/node.py:3: in <module>
    from ..types import Field, Interface, ObjectType
graphene/types/__init__.py:4: in <module>
    from .argument import Argument
graphene/types/argument.py:5: in <module>
    from .structures import NonNull
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .unmountedtype import UnmountedType
>   from .utils import get_type
E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

graphene/types/structures.py:2: ImportError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7f9565cfc9a0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.11/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.11/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:90: in pytest_runtest_setup
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/logging.py:840: in pytest_runtest_setup
    yield from self._runtest_for(item, "setup")
.venv/lib/python3.11/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
.venv/lib/python3.11/site-packages/_pytest/capture.py:875: in pytest_runtest_setup
    return (yield)
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:87: in pytest_runtest_setup
    yield from thread_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/runner.py:160: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv/lib/python3.11/site-packages/_pytest/runner.py:514: in setup
    col.setup()
.venv/lib/python3.11/site-packages/_pytest/python.py:663: in setup
    init_mod = importtestmodule(self.path / "__init__.py", self.config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/testbed/graphene/__init__.py')
config = <_pytest.config.Config object at 0x7f95666cee50>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
            raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
        except ImportPathMismatchError as e:
            raise nodes.Collector.CollectError(
                "import file mismatch:\n"
                "imported module {!r} has this __file__ attribute:\n"
                "  {}\n"
                "which is not the same as the test file we want to collect:\n"
                "  {}\n"
                "HINT: remove __pycache__ / .pyc files and/or use a "
                "unique basename for your test file modules".format(*e.args)
            ) from e
        except ImportError as e:
            exc_info = ExceptionInfo.from_current()
            if config.get_verbosity() < 2:
                exc_info.traceback = exc_info.traceback.filter(filter_traceback)
            exc_repr = (
                exc_info.getrepr(style="short")
                if exc_info.traceback
                else exc_info.exconly()
            )
            formatted_tb = str(exc_repr)
>           raise nodes.Collector.CollectError(
                f"ImportError while importing test module '{path}'.\n"
                "Hint: make sure your test modules/packages have valid Python names.\n"
                "Traceback:\n"
                f"{formatted_tb}"
            ) from e
E           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/graphene/__init__.py'.
E           Hint: make sure your test modules/packages have valid Python names.
E           Traceback:
E           /root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E           graphene/__init__.py:2: in <module>
E               from .relay import (
E           graphene/relay/__init__.py:1: in <module>
E               from .node import Node, is_node, GlobalID
E           graphene/relay/node.py:3: in <module>
E               from ..types import Field, Interface, ObjectType
E           graphene/types/__init__.py:4: in <module>
E               from .argument import Argument
E           graphene/types/argument.py:5: in <module>
E               from .structures import NonNull
E           graphene/types/structures.py:2: in <module>
E               from .utils import get_type
E           E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

.venv/lib/python3.11/site-packages/_pytest/python.py:523: CollectError
</pre>
</details>
<h3 id="test_orderedtypepytest_orderedtype_eq">test_orderedtype.py::test_orderedtype_eq</h3>
<details><summary> <pre>test_orderedtype.py::test_orderedtype_eq</pre></summary><pre>
name = 'graphene', package = None

    def import_module(name, package=None):
        """Import a module.

        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.

        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/__init__.py:2: in <module>
    from .relay import (
graphene/relay/__init__.py:1: in <module>
    from .node import Node, is_node, GlobalID
graphene/relay/node.py:3: in <module>
    from ..types import Field, Interface, ObjectType
graphene/types/__init__.py:4: in <module>
    from .argument import Argument
graphene/types/argument.py:5: in <module>
    from .structures import NonNull
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .unmountedtype import UnmountedType
>   from .utils import get_type
E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

graphene/types/structures.py:2: ImportError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7f9565c61f80>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.11/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.11/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:90: in pytest_runtest_setup
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/logging.py:840: in pytest_runtest_setup
    yield from self._runtest_for(item, "setup")
.venv/lib/python3.11/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
.venv/lib/python3.11/site-packages/_pytest/capture.py:875: in pytest_runtest_setup
    return (yield)
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:87: in pytest_runtest_setup
    yield from thread_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/runner.py:160: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv/lib/python3.11/site-packages/_pytest/runner.py:507: in setup
    raise exc[0].with_traceback(exc[1])
.venv/lib/python3.11/site-packages/_pytest/runner.py:514: in setup
    col.setup()
.venv/lib/python3.11/site-packages/_pytest/python.py:663: in setup
    init_mod = importtestmodule(self.path / "__init__.py", self.config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/testbed/graphene/__init__.py')
config = <_pytest.config.Config object at 0x7f95666cee50>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
            raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
        except ImportPathMismatchError as e:
            raise nodes.Collector.CollectError(
                "import file mismatch:\n"
                "imported module {!r} has this __file__ attribute:\n"
                "  {}\n"
                "which is not the same as the test file we want to collect:\n"
                "  {}\n"
                "HINT: remove __pycache__ / .pyc files and/or use a "
                "unique basename for your test file modules".format(*e.args)
            ) from e
        except ImportError as e:
            exc_info = ExceptionInfo.from_current()
            if config.get_verbosity() < 2:
                exc_info.traceback = exc_info.traceback.filter(filter_traceback)
            exc_repr = (
                exc_info.getrepr(style="short")
                if exc_info.traceback
                else exc_info.exconly()
            )
            formatted_tb = str(exc_repr)
>           raise nodes.Collector.CollectError(
                f"ImportError while importing test module '{path}'.\n"
                "Hint: make sure your test modules/packages have valid Python names.\n"
                "Traceback:\n"
                f"{formatted_tb}"
            ) from e
E           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/graphene/__init__.py'.
E           Hint: make sure your test modules/packages have valid Python names.
E           Traceback:
E           /root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E           graphene/__init__.py:2: in <module>
E               from .relay import (
E           graphene/relay/__init__.py:1: in <module>
E               from .node import Node, is_node, GlobalID
E           graphene/relay/node.py:3: in <module>
E               from ..types import Field, Interface, ObjectType
E           graphene/types/__init__.py:4: in <module>
E               from .argument import Argument
E           graphene/types/argument.py:5: in <module>
E               from .structures import NonNull
E           graphene/types/structures.py:2: in <module>
E               from .utils import get_type
E           E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

.venv/lib/python3.11/site-packages/_pytest/python.py:523: CollectError
</pre>
</details>
<h3 id="test_orderedtypepytest_orderedtype_hash">test_orderedtype.py::test_orderedtype_hash</h3>
<details><summary> <pre>test_orderedtype.py::test_orderedtype_hash</pre></summary><pre>
name = 'graphene', package = None

    def import_module(name, package=None):
        """Import a module.

        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.

        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/__init__.py:2: in <module>
    from .relay import (
graphene/relay/__init__.py:1: in <module>
    from .node import Node, is_node, GlobalID
graphene/relay/node.py:3: in <module>
    from ..types import Field, Interface, ObjectType
graphene/types/__init__.py:4: in <module>
    from .argument import Argument
graphene/types/argument.py:5: in <module>
    from .structures import NonNull
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .unmountedtype import UnmountedType
>   from .utils import get_type
E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

graphene/types/structures.py:2: ImportError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7f9565c63d80>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.11/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.11/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:90: in pytest_runtest_setup
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/logging.py:840: in pytest_runtest_setup
    yield from self._runtest_for(item, "setup")
.venv/lib/python3.11/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
.venv/lib/python3.11/site-packages/_pytest/capture.py:875: in pytest_runtest_setup
    return (yield)
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:87: in pytest_runtest_setup
    yield from thread_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/runner.py:160: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv/lib/python3.11/site-packages/_pytest/runner.py:507: in setup
    raise exc[0].with_traceback(exc[1])
.venv/lib/python3.11/site-packages/_pytest/runner.py:514: in setup
    col.setup()
.venv/lib/python3.11/site-packages/_pytest/python.py:663: in setup
    init_mod = importtestmodule(self.path / "__init__.py", self.config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/testbed/graphene/__init__.py')
config = <_pytest.config.Config object at 0x7f95666cee50>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
            raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
        except ImportPathMismatchError as e:
            raise nodes.Collector.CollectError(
                "import file mismatch:\n"
                "imported module {!r} has this __file__ attribute:\n"
                "  {}\n"
                "which is not the same as the test file we want to collect:\n"
                "  {}\n"
                "HINT: remove __pycache__ / .pyc files and/or use a "
                "unique basename for your test file modules".format(*e.args)
            ) from e
        except ImportError as e:
            exc_info = ExceptionInfo.from_current()
            if config.get_verbosity() < 2:
                exc_info.traceback = exc_info.traceback.filter(filter_traceback)
            exc_repr = (
                exc_info.getrepr(style="short")
                if exc_info.traceback
                else exc_info.exconly()
            )
            formatted_tb = str(exc_repr)
>           raise nodes.Collector.CollectError(
                f"ImportError while importing test module '{path}'.\n"
                "Hint: make sure your test modules/packages have valid Python names.\n"
                "Traceback:\n"
                f"{formatted_tb}"
            ) from e
E           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/graphene/__init__.py'.
E           Hint: make sure your test modules/packages have valid Python names.
E           Traceback:
E           /root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E           graphene/__init__.py:2: in <module>
E               from .relay import (
E           graphene/relay/__init__.py:1: in <module>
E               from .node import Node, is_node, GlobalID
E           graphene/relay/node.py:3: in <module>
E               from ..types import Field, Interface, ObjectType
E           graphene/types/__init__.py:4: in <module>
E               from .argument import Argument
E           graphene/types/argument.py:5: in <module>
E               from .structures import NonNull
E           graphene/types/structures.py:2: in <module>
E               from .utils import get_type
E           E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

.venv/lib/python3.11/site-packages/_pytest/python.py:523: CollectError
</pre>
</details>
<h3 id="test_orderedtypepytest_orderedtype_resetcounter">test_orderedtype.py::test_orderedtype_resetcounter</h3>
<details><summary> <pre>test_orderedtype.py::test_orderedtype_resetcounter</pre></summary><pre>
name = 'graphene', package = None

    def import_module(name, package=None):
        """Import a module.

        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.

        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/__init__.py:2: in <module>
    from .relay import (
graphene/relay/__init__.py:1: in <module>
    from .node import Node, is_node, GlobalID
graphene/relay/node.py:3: in <module>
    from ..types import Field, Interface, ObjectType
graphene/types/__init__.py:4: in <module>
    from .argument import Argument
graphene/types/argument.py:5: in <module>
    from .structures import NonNull
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .unmountedtype import UnmountedType
>   from .utils import get_type
E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

graphene/types/structures.py:2: ImportError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7f9565c63b00>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.11/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.11/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:90: in pytest_runtest_setup
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/logging.py:840: in pytest_runtest_setup
    yield from self._runtest_for(item, "setup")
.venv/lib/python3.11/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
.venv/lib/python3.11/site-packages/_pytest/capture.py:875: in pytest_runtest_setup
    return (yield)
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:87: in pytest_runtest_setup
    yield from thread_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/runner.py:160: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv/lib/python3.11/site-packages/_pytest/runner.py:507: in setup
    raise exc[0].with_traceback(exc[1])
.venv/lib/python3.11/site-packages/_pytest/runner.py:514: in setup
    col.setup()
.venv/lib/python3.11/site-packages/_pytest/python.py:663: in setup
    init_mod = importtestmodule(self.path / "__init__.py", self.config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/testbed/graphene/__init__.py')
config = <_pytest.config.Config object at 0x7f95666cee50>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
            raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
        except ImportPathMismatchError as e:
            raise nodes.Collector.CollectError(
                "import file mismatch:\n"
                "imported module {!r} has this __file__ attribute:\n"
                "  {}\n"
                "which is not the same as the test file we want to collect:\n"
                "  {}\n"
                "HINT: remove __pycache__ / .pyc files and/or use a "
                "unique basename for your test file modules".format(*e.args)
            ) from e
        except ImportError as e:
            exc_info = ExceptionInfo.from_current()
            if config.get_verbosity() < 2:
                exc_info.traceback = exc_info.traceback.filter(filter_traceback)
            exc_repr = (
                exc_info.getrepr(style="short")
                if exc_info.traceback
                else exc_info.exconly()
            )
            formatted_tb = str(exc_repr)
>           raise nodes.Collector.CollectError(
                f"ImportError while importing test module '{path}'.\n"
                "Hint: make sure your test modules/packages have valid Python names.\n"
                "Traceback:\n"
                f"{formatted_tb}"
            ) from e
E           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/graphene/__init__.py'.
E           Hint: make sure your test modules/packages have valid Python names.
E           Traceback:
E           /root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E           graphene/__init__.py:2: in <module>
E               from .relay import (
E           graphene/relay/__init__.py:1: in <module>
E               from .node import Node, is_node, GlobalID
E           graphene/relay/node.py:3: in <module>
E               from ..types import Field, Interface, ObjectType
E           graphene/types/__init__.py:4: in <module>
E               from .argument import Argument
E           graphene/types/argument.py:5: in <module>
E               from .structures import NonNull
E           graphene/types/structures.py:2: in <module>
E               from .utils import get_type
E           E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

.venv/lib/python3.11/site-packages/_pytest/python.py:523: CollectError
</pre>
</details>
<h3 id="test_orderedtypepytest_orderedtype_non_orderabletypes">test_orderedtype.py::test_orderedtype_non_orderabletypes</h3>
<details><summary> <pre>test_orderedtype.py::test_orderedtype_non_orderabletypes</pre></summary><pre>
name = 'graphene', package = None

    def import_module(name, package=None):
        """Import a module.

        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.

        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/__init__.py:2: in <module>
    from .relay import (
graphene/relay/__init__.py:1: in <module>
    from .node import Node, is_node, GlobalID
graphene/relay/node.py:3: in <module>
    from ..types import Field, Interface, ObjectType
graphene/types/__init__.py:4: in <module>
    from .argument import Argument
graphene/types/argument.py:5: in <module>
    from .structures import NonNull
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .unmountedtype import UnmountedType
>   from .utils import get_type
E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

graphene/types/structures.py:2: ImportError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7f9565c60f40>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.11/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.11/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:90: in pytest_runtest_setup
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/logging.py:840: in pytest_runtest_setup
    yield from self._runtest_for(item, "setup")
.venv/lib/python3.11/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
.venv/lib/python3.11/site-packages/_pytest/capture.py:875: in pytest_runtest_setup
    return (yield)
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:87: in pytest_runtest_setup
    yield from thread_exception_runtest_hook()
.venv/lib/python3.11/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.11/site-packages/_pytest/runner.py:160: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv/lib/python3.11/site-packages/_pytest/runner.py:507: in setup
    raise exc[0].with_traceback(exc[1])
.venv/lib/python3.11/site-packages/_pytest/runner.py:514: in setup
    col.setup()
.venv/lib/python3.11/site-packages/_pytest/python.py:663: in setup
    init_mod = importtestmodule(self.path / "__init__.py", self.config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/testbed/graphene/__init__.py')
config = <_pytest.config.Config object at 0x7f95666cee50>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
            raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
        except ImportPathMismatchError as e:
            raise nodes.Collector.CollectError(
                "import file mismatch:\n"
                "imported module {!r} has this __file__ attribute:\n"
                "  {}\n"
                "which is not the same as the test file we want to collect:\n"
                "  {}\n"
                "HINT: remove __pycache__ / .pyc files and/or use a "
                "unique basename for your test file modules".format(*e.args)
            ) from e
        except ImportError as e:
            exc_info = ExceptionInfo.from_current()
            if config.get_verbosity() < 2:
                exc_info.traceback = exc_info.traceback.filter(filter_traceback)
            exc_repr = (
                exc_info.getrepr(style="short")
                if exc_info.traceback
                else exc_info.exconly()
            )
            formatted_tb = str(exc_repr)
>           raise nodes.Collector.CollectError(
                f"ImportError while importing test module '{path}'.\n"
                "Hint: make sure your test modules/packages have valid Python names.\n"
                "Traceback:\n"
                f"{formatted_tb}"
            ) from e
E           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/graphene/__init__.py'.
E           Hint: make sure your test modules/packages have valid Python names.
E           Traceback:
E           /root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/importlib/__init__.py:126: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E           graphene/__init__.py:2: in <module>
E               from .relay import (
E           graphene/relay/__init__.py:1: in <module>
E               from .node import Node, is_node, GlobalID
E           graphene/relay/node.py:3: in <module>
E               from ..types import Field, Interface, ObjectType
E           graphene/types/__init__.py:4: in <module>
E               from .argument import Argument
E           graphene/types/argument.py:5: in <module>
E               from .structures import NonNull
E           graphene/types/structures.py:2: in <module>
E               from .utils import get_type
E           E   ImportError: cannot import name 'get_type' from 'graphene.types.utils' (/testbed/graphene/types/utils.py)

.venv/lib/python3.11/site-packages/_pytest/python.py:523: CollectError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/graphene/pyutils/dataclasses.py b/graphene/pyutils/dataclasses.py</span>
<span class="gh">index f1ec952..9db800a 100644</span>
<span class="gd">--- a/graphene/pyutils/dataclasses.py</span>
<span class="gi">+++ b/graphene/pyutils/dataclasses.py</span>
<span class="gu">@@ -119,7 +119,9 @@ def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,</span>

<span class="w"> </span>    It is an error to specify both default and default_factory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is not MISSING and default_factory is not MISSING:</span>
<span class="gi">+        raise ValueError(&#39;cannot specify both default and default_factory&#39;)</span>
<span class="gi">+    return Field(default, default_factory, init, repr, hash, compare, metadata)</span>


<span class="w"> </span>_hash_action = {(False, False, False, False): None, (False, False, False, 
<span class="gu">@@ -146,7 +148,13 @@ def dataclass(_cls=None, *, init=True, repr=True, eq=True, order=False,</span>
<span class="w"> </span>    __hash__() method function is added. If frozen is true, fields may
<span class="w"> </span>    not be assigned to after instance creation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrap(cls):</span>
<span class="gi">+        return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)</span>
<span class="gi">+</span>
<span class="gi">+    if _cls is None:</span>
<span class="gi">+        return wrap</span>
<span class="gi">+</span>
<span class="gi">+    return wrap(_cls)</span>


<span class="w"> </span>def fields(class_or_instance):
<span class="gu">@@ -155,18 +163,23 @@ def fields(class_or_instance):</span>
<span class="w"> </span>    Accepts a dataclass or an instance of one. Tuple elements are of
<span class="w"> </span>    type Field.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(class_or_instance, type):</span>
<span class="gi">+        return getattr(class_or_instance, _FIELDS).values()</span>
<span class="gi">+    elif isinstance(class_or_instance, object):</span>
<span class="gi">+        return fields(class_or_instance.__class__)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&#39;Argument must be a dataclass type or instance&#39;)</span>


<span class="w"> </span>def _is_dataclass_instance(obj):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if obj is an instance of a dataclass.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(obj, _FIELDS)</span>


<span class="w"> </span>def is_dataclass(obj):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if obj is a dataclass or an instance of a
<span class="w"> </span>    dataclass.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, type) and hasattr(obj, _FIELDS) or _is_dataclass_instance(obj)</span>


<span class="w"> </span>def asdict(obj, *, dict_factory=dict):
<span class="gu">@@ -188,7 +201,23 @@ def asdict(obj, *, dict_factory=dict):</span>
<span class="w"> </span>    dataclass instances. This will also look into built-in containers:
<span class="w"> </span>    tuples, lists, and dicts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _asdict_inner(obj):</span>
<span class="gi">+        if _is_dataclass_instance(obj):</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for f in fields(obj):</span>
<span class="gi">+                value = _asdict_inner(getattr(obj, f.name))</span>
<span class="gi">+                result.append((f.name, value))</span>
<span class="gi">+            return dict_factory(result)</span>
<span class="gi">+        elif isinstance(obj, (list, tuple)):</span>
<span class="gi">+            return type(obj)(_asdict_inner(v) for v in obj)</span>
<span class="gi">+        elif isinstance(obj, dict):</span>
<span class="gi">+            return type(obj)((_asdict_inner(k), _asdict_inner(v)) for k, v in obj.items())</span>
<span class="gi">+        else:</span>
<span class="gi">+            return copy.deepcopy(obj)</span>
<span class="gi">+    </span>
<span class="gi">+    if not _is_dataclass_instance(obj):</span>
<span class="gi">+        raise TypeError(&quot;asdict() should be called on dataclass instances&quot;)</span>
<span class="gi">+    return _asdict_inner(obj)</span>


<span class="w"> </span>def astuple(obj, *, tuple_factory=tuple):
<span class="gu">@@ -209,7 +238,23 @@ def astuple(obj, *, tuple_factory=tuple):</span>
<span class="w"> </span>    dataclass instances. This will also look into built-in containers:
<span class="w"> </span>    tuples, lists, and dicts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _astuple_inner(obj):</span>
<span class="gi">+        if _is_dataclass_instance(obj):</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for f in fields(obj):</span>
<span class="gi">+                value = _astuple_inner(getattr(obj, f.name))</span>
<span class="gi">+                result.append(value)</span>
<span class="gi">+            return tuple_factory(result)</span>
<span class="gi">+        elif isinstance(obj, (list, tuple)):</span>
<span class="gi">+            return type(obj)(_astuple_inner(v) for v in obj)</span>
<span class="gi">+        elif isinstance(obj, dict):</span>
<span class="gi">+            return type(obj)((_astuple_inner(k), _astuple_inner(v)) for k, v in obj.items())</span>
<span class="gi">+        else:</span>
<span class="gi">+            return copy.deepcopy(obj)</span>
<span class="gi">+    </span>
<span class="gi">+    if not _is_dataclass_instance(obj):</span>
<span class="gi">+        raise TypeError(&quot;astuple() should be called on dataclass instances&quot;)</span>
<span class="gi">+    return _astuple_inner(obj)</span>


<span class="w"> </span>def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,
<span class="gu">@@ -236,7 +281,29 @@ def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,</span>
<span class="w"> </span>    The parameters init, repr, eq, order, unsafe_hash, and frozen are passed to
<span class="w"> </span>    dataclass().
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if namespace is None:</span>
<span class="gi">+        namespace = {}</span>
<span class="gi">+    else:</span>
<span class="gi">+        namespace = namespace.copy()</span>
<span class="gi">+</span>
<span class="gi">+    anns = {}</span>
<span class="gi">+    for item in fields:</span>
<span class="gi">+        if isinstance(item, str):</span>
<span class="gi">+            anns[item] = &#39;typing.Any&#39;</span>
<span class="gi">+        elif len(item) == 2:</span>
<span class="gi">+            name, tp = item</span>
<span class="gi">+            anns[name] = tp</span>
<span class="gi">+        elif len(item) == 3:</span>
<span class="gi">+            name, tp, spec = item</span>
<span class="gi">+            anns[name] = tp</span>
<span class="gi">+            namespace[name] = spec</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&#39;Invalid field specification: {item}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    namespace[&#39;__annotations__&#39;] = anns</span>
<span class="gi">+    cls = type(cls_name, bases, namespace)</span>
<span class="gi">+    return dataclass(cls, init=init, repr=repr, eq=eq, order=order,</span>
<span class="gi">+                     unsafe_hash=unsafe_hash, frozen=frozen)</span>


<span class="w"> </span>def replace(obj, **changes):
<span class="gu">@@ -253,4 +320,14 @@ def replace(obj, **changes):</span>
<span class="w"> </span>      c1 = replace(c, x=3)
<span class="w"> </span>      assert c1.x == 3 and c1.y == 2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not _is_dataclass_instance(obj):</span>
<span class="gi">+        raise TypeError(&quot;replace() should be called on dataclass instances&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create a dict of the original values</span>
<span class="gi">+    original_dict = asdict(obj)</span>
<span class="gi">+    </span>
<span class="gi">+    # Update with the new values</span>
<span class="gi">+    original_dict.update(changes)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create a new instance with the updated values</span>
<span class="gi">+    return obj.__class__(**original_dict)</span>
<span class="gh">diff --git a/graphene/pyutils/version.py b/graphene/pyutils/version.py</span>
<span class="gh">index 7f16d40..715025c 100644</span>
<span class="gd">--- a/graphene/pyutils/version.py</span>
<span class="gi">+++ b/graphene/pyutils/version.py</span>
<span class="gu">@@ -6,19 +6,35 @@ import subprocess</span>

<span class="w"> </span>def get_version(version=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a PEP 440-compliant version number from VERSION.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    version = get_complete_version(version)</span>
<span class="gi">+    main = get_main_version(version)</span>
<span class="gi">+    </span>
<span class="gi">+    sub = &#39;&#39;</span>
<span class="gi">+    if version[3] != &#39;final&#39;:</span>
<span class="gi">+        mapping = {&#39;alpha&#39;: &#39;a&#39;, &#39;beta&#39;: &#39;b&#39;, &#39;rc&#39;: &#39;rc&#39;}</span>
<span class="gi">+        sub = mapping[version[3]] + str(version[4])</span>
<span class="gi">+    </span>
<span class="gi">+    return main + sub</span>


<span class="w"> </span>def get_main_version(version=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns main version (X.Y[.Z]) from VERSION.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    version = get_complete_version(version)</span>
<span class="gi">+    parts = 2 if version[2] == 0 else 3</span>
<span class="gi">+    return &#39;.&#39;.join(str(x) for x in version[:parts])</span>


<span class="w"> </span>def get_complete_version(version=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a tuple of the graphene version. If version argument is non-empty,
<span class="w"> </span>    then checks for correctness of the tuple provided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if version is None:</span>
<span class="gi">+        from graphene import VERSION as version</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert len(version) == 5</span>
<span class="gi">+        assert version[3] in (&#39;alpha&#39;, &#39;beta&#39;, &#39;rc&#39;, &#39;final&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return version</span>


<span class="w"> </span>def get_git_changeset():
<span class="gu">@@ -27,4 +43,15 @@ def get_git_changeset():</span>
<span class="w"> </span>    This value isn&#39;t guaranteed to be unique, but collisions are very unlikely,
<span class="w"> </span>    so it&#39;s sufficient for generating the development version numbers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    repo_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span>
<span class="gi">+    git_log = subprocess.Popen(</span>
<span class="gi">+        &#39;git log --pretty=format:%ct --quiet -1 HEAD&#39;,</span>
<span class="gi">+        stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span>
<span class="gi">+        shell=True, cwd=repo_dir, universal_newlines=True,</span>
<span class="gi">+    )</span>
<span class="gi">+    timestamp = git_log.communicate()[0]</span>
<span class="gi">+    try:</span>
<span class="gi">+        timestamp = datetime.datetime.utcfromtimestamp(int(timestamp))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return timestamp.strftime(&#39;%Y%m%d%H%M%S&#39;)</span>
<span class="gh">diff --git a/graphene/relay/connection.py b/graphene/relay/connection.py</span>
<span class="gh">index b1ab0bf..7cdc476 100644</span>
<span class="gd">--- a/graphene/relay/connection.py</span>
<span class="gi">+++ b/graphene/relay/connection.py</span>
<span class="gu">@@ -29,7 +29,12 @@ class PageInfo(ObjectType):</span>

<span class="w"> </span>def page_info_adapter(startCursor, endCursor, hasPreviousPage, hasNextPage):
<span class="w"> </span>    &quot;&quot;&quot;Adapter for creating PageInfo instances&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PageInfo(</span>
<span class="gi">+        start_cursor=startCursor,</span>
<span class="gi">+        end_cursor=endCursor,</span>
<span class="gi">+        has_previous_page=hasPreviousPage,</span>
<span class="gi">+        has_next_page=hasNextPage</span>
<span class="gi">+    )</span>


<span class="w"> </span>class ConnectionOptions(ObjectTypeOptions):
<span class="gu">@@ -75,7 +80,10 @@ class Connection(ObjectType):</span>

<span class="w"> </span>def connection_adapter(cls, edges, pageInfo):
<span class="w"> </span>    &quot;&quot;&quot;Adapter for creating Connection instances&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls(</span>
<span class="gi">+        edges=edges,</span>
<span class="gi">+        page_info=pageInfo</span>
<span class="gi">+    )</span>


<span class="w"> </span>class IterableConnectionField(Field):
<span class="gh">diff --git a/graphene/relay/node.py b/graphene/relay/node.py</span>
<span class="gh">index 138a893..3093ed9 100644</span>
<span class="gd">--- a/graphene/relay/node.py</span>
<span class="gi">+++ b/graphene/relay/node.py</span>
<span class="gu">@@ -10,7 +10,11 @@ def is_node(objecttype):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if the given objecttype has Node as an interface
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return issubclass(objecttype, Node) or (</span>
<span class="gi">+        isclass(objecttype)</span>
<span class="gi">+        and issubclass(objecttype, ObjectType)</span>
<span class="gi">+        and any(issubclass(i, Node) for i in objecttype._meta.interfaces)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class GlobalID(Field):
<span class="gu">@@ -34,6 +38,9 @@ class NodeField(Field):</span>
<span class="w"> </span>            graphene_type(required=True, description=&#39;The ID of the object&#39;
<span class="w"> </span>            ), **kwargs)

<span class="gi">+    def get_resolver(self, parent_resolver):</span>
<span class="gi">+        return partial(self.node_type.node_resolver, get_node=self.node_type.get_node_from_global_id)</span>
<span class="gi">+</span>

<span class="w"> </span>class AbstractNode(Interface):

<span class="gh">diff --git a/graphene/types/definitions.py b/graphene/types/definitions.py</span>
<span class="gh">index 12b2a86..b0e53cb 100644</span>
<span class="gd">--- a/graphene/types/definitions.py</span>
<span class="gi">+++ b/graphene/types/definitions.py</span>
<span class="gu">@@ -19,24 +19,42 @@ class GrapheneGraphQLType:</span>


<span class="w"> </span>class GrapheneInterfaceType(GrapheneGraphQLType, GraphQLInterfaceType):
<span class="gd">-    pass</span>
<span class="gi">+    def __copy__(self):</span>
<span class="gi">+        result = GrapheneInterfaceType(graphene_type=self.graphene_type)</span>
<span class="gi">+        result.__dict__.update(self.__dict__)</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class GrapheneUnionType(GrapheneGraphQLType, GraphQLUnionType):
<span class="gd">-    pass</span>
<span class="gi">+    def __copy__(self):</span>
<span class="gi">+        result = GrapheneUnionType(graphene_type=self.graphene_type)</span>
<span class="gi">+        result.__dict__.update(self.__dict__)</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class GrapheneObjectType(GrapheneGraphQLType, GraphQLObjectType):
<span class="gd">-    pass</span>
<span class="gi">+    def __copy__(self):</span>
<span class="gi">+        result = GrapheneObjectType(graphene_type=self.graphene_type)</span>
<span class="gi">+        result.__dict__.update(self.__dict__)</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class GrapheneScalarType(GrapheneGraphQLType, GraphQLScalarType):
<span class="gd">-    pass</span>
<span class="gi">+    def __copy__(self):</span>
<span class="gi">+        result = GrapheneScalarType(graphene_type=self.graphene_type)</span>
<span class="gi">+        result.__dict__.update(self.__dict__)</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class GrapheneEnumType(GrapheneGraphQLType, GraphQLEnumType):
<span class="gd">-    pass</span>
<span class="gi">+    def __copy__(self):</span>
<span class="gi">+        result = GrapheneEnumType(graphene_type=self.graphene_type)</span>
<span class="gi">+        result.__dict__.update(self.__dict__)</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class GrapheneInputObjectType(GrapheneGraphQLType, GraphQLInputObjectType):
<span class="gd">-    pass</span>
<span class="gi">+    def __copy__(self):</span>
<span class="gi">+        result = GrapheneInputObjectType(graphene_type=self.graphene_type)</span>
<span class="gi">+        result.__dict__.update(self.__dict__)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/graphene/types/enum.py b/graphene/types/enum.py</span>
<span class="gh">index cce1873..db44070 100644</span>
<span class="gd">--- a/graphene/types/enum.py</span>
<span class="gi">+++ b/graphene/types/enum.py</span>
<span class="gu">@@ -80,4 +80,4 @@ class Enum(UnmountedType, BaseType, metaclass=EnumMeta):</span>
<span class="w"> </span>        This function is called when the unmounted type (Enum instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>
<span class="gh">diff --git a/graphene/types/field.py b/graphene/types/field.py</span>
<span class="gh">index a23e927..bde1cbf 100644</span>
<span class="gd">--- a/graphene/types/field.py</span>
<span class="gi">+++ b/graphene/types/field.py</span>
<span class="gu">@@ -88,11 +88,23 @@ class Field(MountedType):</span>
<span class="w"> </span>        Wraps a function resolver, using the ObjectType resolve_{FIELD_NAME}
<span class="w"> </span>        (parent_resolver) if the Field definition has no resolver.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def resolver(obj, info, **args):</span>
<span class="gi">+            if self.resolver:</span>
<span class="gi">+                return self.resolver(obj, info, **args)</span>
<span class="gi">+            elif parent_resolver:</span>
<span class="gi">+                return parent_resolver(obj, info, **args)</span>
<span class="gi">+            return default_resolver(obj, info, **args)</span>
<span class="gi">+        return resolver</span>

<span class="w"> </span>    def wrap_subscribe(self, parent_subscribe):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wraps a function subscribe, using the ObjectType subscribe_{FIELD_NAME}
<span class="w"> </span>        (parent_subscribe) if the Field definition has no subscribe.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def subscriber(obj, info, **args):</span>
<span class="gi">+            if hasattr(self, &#39;subscribe&#39;):</span>
<span class="gi">+                return self.subscribe(obj, info, **args)</span>
<span class="gi">+            elif parent_subscribe:</span>
<span class="gi">+                return parent_subscribe(obj, info, **args)</span>
<span class="gi">+            return None</span>
<span class="gi">+        return subscriber</span>
<span class="gh">diff --git a/graphene/types/inputobjecttype.py b/graphene/types/inputobjecttype.py</span>
<span class="gh">index f99e2c1..c01bbac 100644</span>
<span class="gd">--- a/graphene/types/inputobjecttype.py</span>
<span class="gi">+++ b/graphene/types/inputobjecttype.py</span>
<span class="gu">@@ -24,7 +24,8 @@ def set_input_object_type_default_value(default_value):</span>
<span class="w"> </span>    This function should be called at the beginning of the app or in some other place where it is guaranteed to
<span class="w"> </span>    be called before any InputObjectType is defined.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _INPUT_OBJECT_TYPE_DEFAULT_VALUE</span>
<span class="gi">+    _INPUT_OBJECT_TYPE_DEFAULT_VALUE = default_value</span>


<span class="w"> </span>class InputObjectTypeContainer(dict, BaseType):
<span class="gu">@@ -103,4 +104,4 @@ class InputObjectType(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (InputObjectType instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>
<span class="gh">diff --git a/graphene/types/mountedtype.py b/graphene/types/mountedtype.py</span>
<span class="gh">index ac4f6e7..91e4273 100644</span>
<span class="gd">--- a/graphene/types/mountedtype.py</span>
<span class="gi">+++ b/graphene/types/mountedtype.py</span>
<span class="gu">@@ -9,4 +9,6 @@ class MountedType(OrderedType):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(unmounted, UnmountedType):</span>
<span class="gi">+            return unmounted.get_type()</span>
<span class="gi">+        return unmounted</span>
<span class="gh">diff --git a/graphene/types/mutation.py b/graphene/types/mutation.py</span>
<span class="gh">index 1e5c548..9c42929 100644</span>
<span class="gd">--- a/graphene/types/mutation.py</span>
<span class="gi">+++ b/graphene/types/mutation.py</span>
<span class="gu">@@ -107,4 +107,12 @@ Read more: https://github.com/graphql-python/graphene/blob/v2.0.0/UPGRADE-v2.0.m</span>
<span class="w"> </span>    def Field(cls, name=None, description=None, deprecation_reason=None,
<span class="w"> </span>        required=False):
<span class="w"> </span>        &quot;&quot;&quot;Mount instance of mutation Field.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Field(</span>
<span class="gi">+            cls._meta.output,</span>
<span class="gi">+            args=cls._meta.arguments,</span>
<span class="gi">+            resolver=cls._meta.resolver,</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            description=description or cls._meta.description,</span>
<span class="gi">+            deprecation_reason=deprecation_reason,</span>
<span class="gi">+            required=required</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/graphene/types/scalars.py b/graphene/types/scalars.py</span>
<span class="gh">index b1a7427..adefc0b 100644</span>
<span class="gd">--- a/graphene/types/scalars.py</span>
<span class="gi">+++ b/graphene/types/scalars.py</span>
<span class="gu">@@ -32,23 +32,53 @@ class Scalar(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (Scalar instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from graphql import GraphQLScalarType</span>
<span class="gi">+</span>
<span class="gi">+        return GraphQLScalarType(</span>
<span class="gi">+            name=cls._meta.name,</span>
<span class="gi">+            description=cls._meta.description,</span>
<span class="gi">+            serialize=cls.serialize,</span>
<span class="gi">+            parse_value=cls.parse_value,</span>
<span class="gi">+            parse_literal=cls.parse_literal,</span>
<span class="gi">+        )</span>


<span class="w"> </span>MAX_INT = 2147483647
<span class="w"> </span>MIN_INT = -2147483648


<span class="gi">+def coerce_int(value):</span>
<span class="gi">+    if isinstance(value, bool):</span>
<span class="gi">+        return 1 if value else 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        int_value = int(value)</span>
<span class="gi">+        if MIN_INT &lt;= int_value &lt;= MAX_INT:</span>
<span class="gi">+            return int_value</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        pass</span>
<span class="gi">+    raise ValueError(f&quot;Int cannot represent non 32-bit signed integer value: {value}&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>class Int(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `Int` scalar type represents non-fractional signed whole numeric
<span class="gd">-    values. Int can represent values between -(2^53 - 1) and 2^53 - 1 since</span>
<span class="gi">+    values. Int can represent values between -(2^31) and 2^31 - 1 since</span>
<span class="w"> </span>    represented in JSON as double-precision floating point numbers specified
<span class="w"> </span>    by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    serialize = coerce_int
<span class="w"> </span>    parse_value = coerce_int

<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node):</span>
<span class="gi">+        if isinstance(node, IntValueNode):</span>
<span class="gi">+            return coerce_int(node.value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def coerce_big_int(value):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(value)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        raise ValueError(f&quot;BigInt cannot represent non-integer value: {value}&quot;)</span>

<span class="w"> </span>class BigInt(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -56,9 +86,19 @@ class BigInt(Scalar):</span>
<span class="w"> </span>    `BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
<span class="w"> </span>    compatible type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    serialize = coerce_int</span>
<span class="gd">-    parse_value = coerce_int</span>
<span class="gi">+    serialize = coerce_big_int</span>
<span class="gi">+    parse_value = coerce_big_int</span>

<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node):</span>
<span class="gi">+        if isinstance(node, IntValueNode):</span>
<span class="gi">+            return coerce_big_int(node.value)</span>
<span class="gi">+</span>
<span class="gi">+def coerce_float(value):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return float(value)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        raise ValueError(f&quot;Float cannot represent non numeric value: {value}&quot;)</span>

<span class="w"> </span>class Float(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -69,6 +109,21 @@ class Float(Scalar):</span>
<span class="w"> </span>    serialize = coerce_float
<span class="w"> </span>    parse_value = coerce_float

<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node):</span>
<span class="gi">+        if isinstance(node, (FloatValueNode, IntValueNode)):</span>
<span class="gi">+            return coerce_float(node.value)</span>
<span class="gi">+</span>
<span class="gi">+def coerce_string(value):</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return value</span>
<span class="gi">+    if isinstance(value, bool):</span>
<span class="gi">+        return &quot;true&quot; if value else &quot;false&quot;</span>
<span class="gi">+    if isinstance(value, int) or isinstance(value, float):</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+    if isinstance(value, dict) or isinstance(value, list):</span>
<span class="gi">+        raise ValueError(f&quot;String cannot represent value: {value}&quot;)</span>
<span class="gi">+    return str(value)</span>

<span class="w"> </span>class String(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -79,6 +134,11 @@ class String(Scalar):</span>
<span class="w"> </span>    serialize = coerce_string
<span class="w"> </span>    parse_value = coerce_string

<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node):</span>
<span class="gi">+        if isinstance(node, StringValueNode):</span>
<span class="gi">+            return node.value</span>
<span class="gi">+</span>

<span class="w"> </span>class Boolean(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -87,6 +147,10 @@ class Boolean(Scalar):</span>
<span class="w"> </span>    serialize = bool
<span class="w"> </span>    parse_value = bool

<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node):</span>
<span class="gi">+        if isinstance(node, BooleanValueNode):</span>
<span class="gi">+            return node.value</span>

<span class="w"> </span>class ID(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -98,3 +162,8 @@ class ID(Scalar):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    serialize = str
<span class="w"> </span>    parse_value = str
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_literal(cls, node):</span>
<span class="gi">+        if isinstance(node, (StringValueNode, IntValueNode)):</span>
<span class="gi">+            return node.value</span>
<span class="gh">diff --git a/graphene/types/schema.py b/graphene/types/schema.py</span>
<span class="gh">index 1227a4c..9eed481 100644</span>
<span class="gd">--- a/graphene/types/schema.py</span>
<span class="gi">+++ b/graphene/types/schema.py</span>
<span class="gu">@@ -43,7 +43,15 @@ class TypeMap(dict):</span>
<span class="w"> </span>    def get_function_for_type(self, graphene_type, func_name, name,
<span class="w"> </span>        default_value):
<span class="w"> </span>        &quot;&quot;&quot;Gets a resolve or subscribe function for a given ObjectType&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(graphene_type, ObjectType):</span>
<span class="gi">+            func = getattr(graphene_type, func_name, None)</span>
<span class="gi">+            if func:</span>
<span class="gi">+                return func</span>
<span class="gi">+        if isinstance(graphene_type, type):</span>
<span class="gi">+            func = getattr(graphene_type, func_name, None)</span>
<span class="gi">+            if func:</span>
<span class="gi">+                return get_unbound_function(func)</span>
<span class="gi">+        return default_value</span>


<span class="w"> </span>class Schema:
<span class="gu">@@ -117,19 +125,29 @@ class Schema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            :obj:`ExecutionResult` containing any data and errors for the operation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return graphql_sync(self.graphql_schema, *args, **kwargs)</span>

<span class="w"> </span>    async def execute_async(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL query on the schema asynchronously.
<span class="w"> </span>        Same as `execute`, but uses `graphql` instead of `graphql_sync`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return await graphql(self.graphql_schema, *args, **kwargs)</span>

<span class="w"> </span>    async def subscribe(self, query, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL subscription on the schema asynchronously.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        document = parse(query)</span>
<span class="gi">+        return await subscribe(self.graphql_schema, document, *args, **kwargs)</span>


<span class="w"> </span>def normalize_execute_kwargs(kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Replace alias names in keyword arguments for graphql()&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;request_string&#39; in kwargs:</span>
<span class="gi">+        kwargs[&#39;source&#39;] = kwargs.pop(&#39;request_string&#39;)</span>
<span class="gi">+    if &#39;context_value&#39; in kwargs:</span>
<span class="gi">+        kwargs[&#39;context&#39;] = kwargs.pop(&#39;context_value&#39;)</span>
<span class="gi">+    if &#39;variable_values&#39; in kwargs:</span>
<span class="gi">+        kwargs[&#39;variables&#39;] = kwargs.pop(&#39;variable_values&#39;)</span>
<span class="gi">+    return kwargs</span>
<span class="gh">diff --git a/graphene/types/structures.py b/graphene/types/structures.py</span>
<span class="gh">index 155e1c0..8a3b153 100644</span>
<span class="gd">--- a/graphene/types/structures.py</span>
<span class="gi">+++ b/graphene/types/structures.py</span>
<span class="gu">@@ -24,7 +24,7 @@ class Structure(UnmountedType):</span>
<span class="w"> </span>        This function is called when the unmounted type (List or NonNull instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return get_type(self._of_type)</span>


<span class="w"> </span>class List(Structure):
<span class="gu">@@ -51,6 +51,9 @@ class List(Structure):</span>
<span class="w"> </span>        return isinstance(other, List) and (self.of_type == other.of_type and
<span class="w"> </span>            self.args == other.args and self.kwargs == other.kwargs)

<span class="gi">+    def get_type(self):</span>
<span class="gi">+        return List(get_type(self._of_type))</span>
<span class="gi">+</span>

<span class="w"> </span>class NonNull(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -87,3 +90,6 @@ class NonNull(Structure):</span>
<span class="w"> </span>        return isinstance(other, NonNull) and (self.of_type == other.
<span class="w"> </span>            of_type and self.args == other.args and self.kwargs == other.kwargs
<span class="w"> </span>            )
<span class="gi">+</span>
<span class="gi">+    def get_type(self):</span>
<span class="gi">+        return NonNull(get_type(self._of_type))</span>
<span class="gh">diff --git a/graphene/types/union.py b/graphene/types/union.py</span>
<span class="gh">index cabc8df..9e60ecf 100644</span>
<span class="gd">--- a/graphene/types/union.py</span>
<span class="gi">+++ b/graphene/types/union.py</span>
<span class="gu">@@ -61,4 +61,4 @@ class Union(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (Union instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls</span>
<span class="gh">diff --git a/graphene/types/unmountedtype.py b/graphene/types/unmountedtype.py</span>
<span class="gh">index 5ca42ce..a786f90 100644</span>
<span class="gd">--- a/graphene/types/unmountedtype.py</span>
<span class="gi">+++ b/graphene/types/unmountedtype.py</span>
<span class="gu">@@ -49,25 +49,28 @@ class UnmountedType(OrderedType):</span>
<span class="w"> </span>        This function is called when the UnmountedType instance
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__</span>

<span class="w"> </span>    def Field(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType as Field
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .field import Field</span>
<span class="gi">+        return Field(self.get_type(), *self.args, **self.kwargs)</span>

<span class="w"> </span>    def InputField(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType as InputField
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .inputfield import InputField</span>
<span class="gi">+        return InputField(self.get_type(), *self.args, **self.kwargs)</span>

<span class="w"> </span>    def Argument(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Mount the UnmountedType as Argument
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .argument import Argument</span>
<span class="gi">+        return Argument(self.get_type(), *self.args, **self.kwargs)</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        return self is other or isinstance(other, UnmountedType
<span class="gh">diff --git a/graphene/types/utils.py b/graphene/types/utils.py</span>
<span class="gh">index 4c05498..e38c796 100644</span>
<span class="gd">--- a/graphene/types/utils.py</span>
<span class="gi">+++ b/graphene/types/utils.py</span>
<span class="gu">@@ -9,7 +9,11 @@ def get_field_as(value, _as=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get type mounted
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, MountedType):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, UnmountedType):</span>
<span class="gi">+        return value.mount_as(_as)</span>
<span class="gi">+    return _as(value) if _as else value</span>


<span class="w"> </span>def yank_fields_from_attrs(attrs, _as=None, sort=True):
<span class="gu">@@ -17,9 +21,17 @@ def yank_fields_from_attrs(attrs, _as=None, sort=True):</span>
<span class="w"> </span>    Extract all the fields in given attributes (dict)
<span class="w"> </span>    and return them ordered
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields = []</span>
<span class="gi">+    for key, value in attrs.items():</span>
<span class="gi">+        if isinstance(value, UnmountedType):</span>
<span class="gi">+            fields.append((key, get_field_as(value, _as)))</span>
<span class="gi">+    if sort:</span>
<span class="gi">+        fields = sorted(fields, key=lambda f: f[1])</span>
<span class="gi">+    return fields</span>


<span class="w"> </span>def get_underlying_type(_type):
<span class="w"> </span>    &quot;&quot;&quot;Get the underlying type even if it is wrapped in structures like NonNull&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while hasattr(_type, &#39;of_type&#39;):</span>
<span class="gi">+        _type = _type.of_type</span>
<span class="gi">+    return _type</span>
<span class="gh">diff --git a/graphene/utils/dataloader.py b/graphene/utils/dataloader.py</span>
<span class="gh">index a7136e2..dff0c14 100644</span>
<span class="gd">--- a/graphene/utils/dataloader.py</span>
<span class="gi">+++ b/graphene/utils/dataloader.py</span>
<span class="gu">@@ -33,11 +33,78 @@ class DataLoader(object):</span>
<span class="w"> </span>        self._cache = cache_map if cache_map is not None else {}
<span class="w"> </span>        self._queue = []

<span class="gi">+    def _schedule_dispatch(self):</span>
<span class="gi">+        if not self._queue:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not hasattr(self, &#39;_dispatch_task&#39;) or self._dispatch_task.done():</span>
<span class="gi">+            loop = self._loop or get_event_loop()</span>
<span class="gi">+            self._dispatch_task = loop.call_soon(dispatch_queue, self)</span>
<span class="gi">+</span>
<span class="gi">+    def _dispatch_single(self, key, future):</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = self.batch_load_fn([key])</span>
<span class="gi">+            if iscoroutine(result):</span>
<span class="gi">+                future.add_done_callback(</span>
<span class="gi">+                    partial(self._handle_future_result, key=key)</span>
<span class="gi">+                )</span>
<span class="gi">+                ensure_future(result).add_done_callback(</span>
<span class="gi">+                    partial(self._handle_batch_result, future=future)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._handle_batch_result(result, future)</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            future.set_exception(exc)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_future_result(self, _, key):</span>
<span class="gi">+        if not self.cache:</span>
<span class="gi">+            return</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+        if cache_key in self._cache:</span>
<span class="gi">+            del self._cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_batch_result(self, batch_future, future):</span>
<span class="gi">+        try:</span>
<span class="gi">+            results = batch_future.result() if hasattr(batch_future, &#39;result&#39;) else batch_future</span>
<span class="gi">+            if len(results) != 1:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;DataLoader must be constructed with a function which accepts &quot;</span>
<span class="gi">+                    f&quot;Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but the function did &quot;</span>
<span class="gi">+                    f&quot;not return a list of the same length as the keys.&quot;</span>
<span class="gi">+                    f&quot;\nResults:\n{results}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            future.set_result(results[0])</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            future.set_exception(exc)</span>
<span class="gi">+</span>
<span class="gi">+def iscoroutinefunctionorpartial(obj):</span>
<span class="gi">+    while isinstance(obj, partial):</span>
<span class="gi">+        obj = obj.func</span>
<span class="gi">+    return iscoroutinefunction(obj)</span>
<span class="gi">+</span>
<span class="w"> </span>    def load(self, key=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Loads a key, returning a `Future` for the value represented by that key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            raise ValueError(&quot;The load method must be called with a key, but got None.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+</span>
<span class="gi">+        if self.cache and cache_key in self._cache:</span>
<span class="gi">+            return self._cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+        future = self._loop.create_future() if self._loop else get_event_loop().create_future()</span>
<span class="gi">+        self._queue.append(Loader(key=key, future=future))</span>
<span class="gi">+</span>
<span class="gi">+        if self.batch:</span>
<span class="gi">+            self._schedule_dispatch()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._dispatch_single(key, future)</span>
<span class="gi">+</span>
<span class="gi">+        if self.cache:</span>
<span class="gi">+            self._cache[cache_key] = future</span>
<span class="gi">+</span>
<span class="gi">+        return future</span>

<span class="w"> </span>    def load_many(self, keys):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -52,14 +119,20 @@ class DataLoader(object):</span>
<span class="w"> </span>        &gt;&gt;&gt;    my_loader.load(&#39;b&#39;)
<span class="w"> </span>        &gt;&gt;&gt; )
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(keys, Iterable):</span>
<span class="gi">+            raise TypeError(f&quot;The loader.load_many() method must be called with Iterable&lt;key&gt; but got: {keys}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return gather(*[self.load(key) for key in keys])</span>

<span class="w"> </span>    def clear(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clears the value at `key` from the cache, if it exists. Returns itself for
<span class="w"> </span>        method chaining.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+        if cache_key in self._cache:</span>
<span class="gi">+            del self._cache[cache_key]</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def clear_all(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -67,14 +140,20 @@ class DataLoader(object):</span>
<span class="w"> </span>        invalidations across this particular `DataLoader`. Returns itself for
<span class="w"> </span>        method chaining.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache.clear()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def prime(self, key, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        Adds the provied key and value to the cache. If the key already exists, no</span>
<span class="gi">+        Adds the provided key and value to the cache. If the key already exists, no</span>
<span class="w"> </span>        change is made. Returns itself for method chaining.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cache_key = self.get_cache_key(key)</span>
<span class="gi">+        if cache_key not in self._cache:</span>
<span class="gi">+            future = self._loop.create_future() if self._loop else get_event_loop().create_future()</span>
<span class="gi">+            future.set_result(value)</span>
<span class="gi">+            self._cache[cache_key] = future</span>
<span class="gi">+        return self</span>


<span class="w"> </span>def dispatch_queue(loader):
<span class="gu">@@ -82,12 +161,55 @@ def dispatch_queue(loader):</span>
<span class="w"> </span>    Given the current state of a Loader instance, perform a batch load
<span class="w"> </span>    from its current queue.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    queue = loader._queue</span>
<span class="gi">+    loader._queue = []</span>
<span class="gi">+</span>
<span class="gi">+    max_batch_size = loader.max_batch_size</span>
<span class="gi">+</span>
<span class="gi">+    if max_batch_size and max_batch_size &lt; len(queue):</span>
<span class="gi">+        chunks = [queue[i:i + max_batch_size] for i in range(0, len(queue), max_batch_size)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        chunks = [queue]</span>
<span class="gi">+</span>
<span class="gi">+    for chunk in chunks:</span>
<span class="gi">+        keys = [loader.key for loader in chunk]</span>
<span class="gi">+        futures = [loader.future for loader in chunk]</span>

<span class="gi">+        batch_future = ensure_future(loader.batch_load_fn(keys))</span>
<span class="gi">+        batch_future.add_done_callback(</span>
<span class="gi">+            partial(_batch_load_fn_callback, loader=loader, keys=keys, futures=futures)</span>
<span class="gi">+        )</span>

<span class="gd">-def failed_dispatch(loader, queue, error):</span>
<span class="gi">+def _batch_load_fn_callback(batch_future, loader, keys, futures):</span>
<span class="gi">+    try:</span>
<span class="gi">+        results = batch_future.result()</span>
<span class="gi">+        if len(results) != len(keys):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;DataLoader must be constructed with a function which accepts &quot;</span>
<span class="gi">+                f&quot;Iterable&lt;key&gt; and returns Future&lt;Iterable&lt;value&gt;&gt;, but the function did &quot;</span>
<span class="gi">+                f&quot;not return a list of the same length as the keys.&quot;</span>
<span class="gi">+                f&quot;\nKeys:\n{keys}&quot;</span>
<span class="gi">+                f&quot;\nResults:\n{results}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for future, result in zip(futures, results):</span>
<span class="gi">+            if not future.done():</span>
<span class="gi">+                future.set_result(result)</span>
<span class="gi">+    except Exception as error:</span>
<span class="gi">+        failed_dispatch(loader, keys, error)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def failed_dispatch(loader, keys, error):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Do not cache individual loads if the entire batch dispatch fails,
<span class="w"> </span>    but still reject each request so they do not hang.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for key in keys:</span>
<span class="gi">+        cache_key = loader.get_cache_key(key)</span>
<span class="gi">+        if cache_key in loader._cache:</span>
<span class="gi">+            del loader._cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+        for loader_item in loader._queue:</span>
<span class="gi">+            if loader_item.key == key:</span>
<span class="gi">+                if not loader_item.future.done():</span>
<span class="gi">+                    loader_item.future.set_exception(error)</span>
<span class="gh">diff --git a/graphene/utils/deprecated.py b/graphene/utils/deprecated.py</span>
<span class="gh">index d561393..75bd981 100644</span>
<span class="gd">--- a/graphene/utils/deprecated.py</span>
<span class="gi">+++ b/graphene/utils/deprecated.py</span>
<span class="gu">@@ -10,4 +10,24 @@ def deprecated(reason):</span>
<span class="w"> </span>    as deprecated. It will result in a warning being emitted
<span class="w"> </span>    when the function is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        if isinstance(func, type):</span>
<span class="gi">+            fmt = &quot;Call to deprecated class {name} ({reason}).&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            fmt = &quot;Call to deprecated function {name} ({reason}).&quot;</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                fmt.format(name=func.__name__, reason=reason),</span>
<span class="gi">+                category=DeprecationWarning,</span>
<span class="gi">+                stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(reason, string_types):</span>
<span class="gi">+        return decorator</span>
<span class="gi">+    else:</span>
<span class="gi">+        return decorator(reason)</span>
<span class="gh">diff --git a/graphene/utils/module_loading.py b/graphene/utils/module_loading.py</span>
<span class="gh">index 21e42a9..e9f8af8 100644</span>
<span class="gd">--- a/graphene/utils/module_loading.py</span>
<span class="gi">+++ b/graphene/utils/module_loading.py</span>
<span class="gu">@@ -10,4 +10,29 @@ def import_string(dotted_path, dotted_attributes=None):</span>
<span class="w"> </span>    the first step, and return the corresponding value designated by the
<span class="w"> </span>    attribute path. Raise ImportError if the import failed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_path, class_name = dotted_path.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    except ValueError as err:</span>
<span class="gi">+        raise ImportError(&quot;%s doesn&#39;t look like a module path&quot; % dotted_path) from err</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = import_module(module_path)</span>
<span class="gi">+    except ImportError as err:</span>
<span class="gi">+        raise ImportError(&#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39; % (</span>
<span class="gi">+            module_path, class_name)) from err</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        attr = getattr(module, class_name)</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        raise ImportError(&#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39; % (</span>
<span class="gi">+            module_path, class_name)) from err</span>
<span class="gi">+</span>
<span class="gi">+    if dotted_attributes:</span>
<span class="gi">+        for attribute in dotted_attributes.split(&#39;.&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                attr = getattr(attr, attribute)</span>
<span class="gi">+            except AttributeError as err:</span>
<span class="gi">+                raise ImportError(&#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute&#39; % (</span>
<span class="gi">+                    dotted_path, dotted_attributes)) from err</span>
<span class="gi">+</span>
<span class="gi">+    return attr</span>
<span class="gh">diff --git a/graphene/utils/props.py b/graphene/utils/props.py</span>
<span class="gh">index 114245a..206396d 100644</span>
<span class="gd">--- a/graphene/utils/props.py</span>
<span class="gi">+++ b/graphene/utils/props.py</span>
<span class="gu">@@ -7,3 +7,20 @@ class _NewClass:</span>


<span class="w"> </span>_all_vars = set(dir(_OldClass) + dir(_NewClass))
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def props(x):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Return a list of all properties (including methods) of the given object,</span>
<span class="gi">+    excluding those that are present in both _OldClass and _NewClass.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return [prop for prop in dir(x) if prop not in _all_vars]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_props(x):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Return a dictionary of all properties (including methods) of the given object,</span>
<span class="gi">+    excluding those that are present in both _OldClass and _NewClass.</span>
<span class="gi">+    The keys are the property names, and the values are the property values.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return {prop: getattr(x, prop) for prop in props(x)}</span>
<span class="gh">diff --git a/graphene/utils/tests/test_dataloader.py b/graphene/utils/tests/test_dataloader.py</span>
<span class="gh">index 257f6b4..4438bc0 100644</span>
<span class="gd">--- a/graphene/utils/tests/test_dataloader.py</span>
<span class="gi">+++ b/graphene/utils/tests/test_dataloader.py</span>
<span class="gu">@@ -450,3 +450,50 @@ async def test_dataloader_clear_with_missing_key_works():</span>

<span class="w"> </span>    a_loader, a_load_calls = id_loader(resolve=do_resolve)
<span class="w"> </span>    assert a_loader.clear(&quot;A1&quot;) == a_loader
<span class="gi">+</span>
<span class="gi">+@mark.asyncio</span>
<span class="gi">+async def test_load_many_with_invalid_input():</span>
<span class="gi">+    identity_loader, _ = id_loader()</span>
<span class="gi">+    with raises(TypeError):</span>
<span class="gi">+        await identity_loader.load_many(&quot;not_an_iterable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+@mark.asyncio</span>
<span class="gi">+async def test_load_with_none_key():</span>
<span class="gi">+    identity_loader, _ = id_loader()</span>
<span class="gi">+    with raises(ValueError):</span>
<span class="gi">+        await identity_loader.load(None)</span>
<span class="gi">+</span>
<span class="gi">+@mark.asyncio</span>
<span class="gi">+async def test_prime_and_clear():</span>
<span class="gi">+    identity_loader, load_calls = id_loader()</span>
<span class="gi">+    </span>
<span class="gi">+    identity_loader.prime(&quot;A&quot;, &quot;A_value&quot;)</span>
<span class="gi">+    identity_loader.prime(&quot;B&quot;, &quot;B_value&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    a = await identity_loader.load(&quot;A&quot;)</span>
<span class="gi">+    assert a == &quot;A_value&quot;</span>
<span class="gi">+    assert load_calls == []</span>
<span class="gi">+    </span>
<span class="gi">+    identity_loader.clear(&quot;A&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    a_reloaded = await identity_loader.load(&quot;A&quot;)</span>
<span class="gi">+    b = await identity_loader.load(&quot;B&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    assert a_reloaded == &quot;A&quot;</span>
<span class="gi">+    assert b == &quot;B_value&quot;</span>
<span class="gi">+    assert load_calls == [[&quot;A&quot;]]</span>
<span class="gi">+</span>
<span class="gi">+@mark.asyncio</span>
<span class="gi">+async def test_clear_all():</span>
<span class="gi">+    identity_loader, load_calls = id_loader()</span>
<span class="gi">+    </span>
<span class="gi">+    identity_loader.prime(&quot;A&quot;, &quot;A_value&quot;)</span>
<span class="gi">+    identity_loader.prime(&quot;B&quot;, &quot;B_value&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    identity_loader.clear_all()</span>
<span class="gi">+    </span>
<span class="gi">+    a, b = await gather(identity_loader.load(&quot;A&quot;), identity_loader.load(&quot;B&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    assert a == &quot;A&quot;</span>
<span class="gi">+    assert b == &quot;B&quot;</span>
<span class="gi">+    assert load_calls == [[&quot;A&quot;, &quot;B&quot;]]</span>
<span class="gh">diff --git a/graphene/utils/thenables.py b/graphene/utils/thenables.py</span>
<span class="gh">index 0ad5e44..8513c63 100644</span>
<span class="gd">--- a/graphene/utils/thenables.py</span>
<span class="gi">+++ b/graphene/utils/thenables.py</span>
<span class="gu">@@ -10,4 +10,9 @@ def maybe_thenable(obj, on_resolve):</span>
<span class="w"> </span>    returning the same type of object inputed.
<span class="w"> </span>    If the object is not thenable, it should return on_resolve(obj)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isawaitable(obj):</span>
<span class="gi">+        async def resolve():</span>
<span class="gi">+            resolved = await obj</span>
<span class="gi">+            return on_resolve(resolved)</span>
<span class="gi">+        return resolve()</span>
<span class="gi">+    return on_resolve(obj)</span>
<span class="gh">diff --git a/graphene/validation/disable_introspection.py b/graphene/validation/disable_introspection.py</span>
<span class="gh">index d18720b..4fb6c60 100644</span>
<span class="gd">--- a/graphene/validation/disable_introspection.py</span>
<span class="gi">+++ b/graphene/validation/disable_introspection.py</span>
<span class="gu">@@ -5,4 +5,9 @@ from ..utils.is_introspection_key import is_introspection_key</span>


<span class="w"> </span>class DisableIntrospection(ValidationRule):
<span class="gd">-    pass</span>
<span class="gi">+    def enter_field(self, node: FieldNode, *args):</span>
<span class="gi">+        if is_introspection_key(node.name.value):</span>
<span class="gi">+            raise GraphQLError(</span>
<span class="gi">+                f&quot;GraphQL introspection is not allowed, but the query contained {node.name.value}&quot;,</span>
<span class="gi">+                [node]</span>
<span class="gi">+            )</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>