
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin click - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-click" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin click
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-click"><strong>Claude Sonnet 3.5 - Fill-in</strong>: click</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:3: in &lt;module&gt;
    from click.testing import CliRunner
src/click/__init__.py:7: in &lt;module&gt;
    from .core import Argument as Argument
src/click/core.py:15: in &lt;module&gt;
    from . import types
src/click/types.py:8: in &lt;module&gt;
    from ._compat import _get_argv_encoding
src/click/_compat.py:126: in &lt;module&gt;
    _default_text_stdin = _make_cached_stream_func(lambda : sys.stdin,
E   NameError: name &#39;_make_cached_stream_func&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/click/_compat.py b/src/click/_compat.py</span>
<span class="gh">index 7f5b9af..0cb3f81 100644</span>
<span class="gd">--- a/src/click/_compat.py</span>
<span class="gi">+++ b/src/click/_compat.py</span>
<span class="gu">@@ -13,12 +13,13 @@ _ansi_re = re.compile(&#39;\\033\\[[;?0-9]*[a-zA-Z]&#39;)</span>

<span class="w"> </span>def is_ascii_encoding(encoding: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Checks if a given encoding is ascii.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return encoding.replace(&#39;-&#39;, &#39;&#39;).lower() in {&#39;ascii&#39;, &#39;us_ascii&#39;}</span>


<span class="w"> </span>def get_best_encoding(stream: t.IO[t.Any]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Returns the default stream encoding if not found.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rv = getattr(stream, &#39;encoding&#39;, None) or sys.getdefaultencoding()</span>
<span class="gi">+    return rv if rv != &#39;ascii&#39; else &#39;utf-8&#39;</span>


<span class="w"> </span>class _NonClosingTextIOWrapper(io.TextIOWrapper):
<span class="gu">@@ -59,7 +60,7 @@ class _FixupStream:</span>

<span class="w"> </span>def _stream_is_misconfigured(stream: t.TextIO) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;A stream is misconfigured if its encoding is ASCII.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_ascii_encoding(getattr(stream, &#39;encoding&#39;, None) or &#39;&#39;)</span>


<span class="w"> </span>def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: t.Optional[str]
<span class="gu">@@ -68,7 +69,8 @@ def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: t.Optional[str]</span>
<span class="w"> </span>    desired value or the desired value is unset and the attribute
<span class="w"> </span>    has a value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stream_value = getattr(stream, attr, None)</span>
<span class="gi">+    return stream_value == value or (value is None and stream_value is not None)</span>


<span class="w"> </span>def _is_compatible_text_stream(stream: t.TextIO, encoding: t.Optional[str],
<span class="gu">@@ -76,13 +78,15 @@ def _is_compatible_text_stream(stream: t.TextIO, encoding: t.Optional[str],</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a stream&#39;s encoding and errors attributes are
<span class="w"> </span>    compatible with the desired values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _is_compat_stream_attr(stream, &#39;encoding&#39;, encoding) and _is_compat_stream_attr(stream, &#39;errors&#39;, errors)</span>


<span class="w"> </span>def _wrap_io_open(file: t.Union[str, &#39;os.PathLike[str]&#39;, int], mode: str,
<span class="w"> </span>    encoding: t.Optional[str], errors: t.Optional[str]) -&gt;t.IO[t.Any]:
<span class="w"> </span>    &quot;&quot;&quot;Handles not passing ``encoding`` and ``errors`` in binary mode.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;b&#39; in mode:</span>
<span class="gi">+        return open(file, mode)</span>
<span class="gi">+    return open(file, mode, encoding=encoding, errors=errors)</span>


<span class="w"> </span>class _AtomicFile:
<span class="gh">diff --git a/src/click/_termui_impl.py b/src/click/_termui_impl.py</span>
<span class="gh">index 4ed4097..3419b62 100644</span>
<span class="gd">--- a/src/click/_termui_impl.py</span>
<span class="gi">+++ b/src/click/_termui_impl.py</span>
<span class="gu">@@ -120,19 +120,40 @@ class ProgressBar(t.Generic[V]):</span>
<span class="w"> </span>            Only render when the number of steps meets the
<span class="w"> </span>            ``update_min_steps`` threshold.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pos += n_steps</span>
<span class="gi">+        if current_item is not None:</span>
<span class="gi">+            self.current_item = current_item</span>
<span class="gi">+        </span>
<span class="gi">+        self._completed_intervals += n_steps</span>
<span class="gi">+        if self._completed_intervals &gt;= self.update_min_steps:</span>
<span class="gi">+            self._completed_intervals = 0</span>
<span class="gi">+            self.render_progress()</span>

<span class="w"> </span>    def generator(self) -&gt;t.Iterator[V]:
<span class="w"> </span>        &quot;&quot;&quot;Return a generator which yields the items added to the bar
<span class="w"> </span>        during construction, and updates the progress bar *after* the
<span class="w"> </span>        yielded block returns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in self.iter:</span>
<span class="gi">+            yield item</span>
<span class="gi">+            self.update(1, item)</span>
<span class="gi">+        self.finish()</span>


<span class="w"> </span>def pager(generator: t.Iterable[str], color: t.Optional[bool]=None) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Decide what method to use for paging through text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stdout = _default_text_stdout()</span>
<span class="gi">+    if not isatty(stdout):</span>
<span class="gi">+        return _nullpager(stdout, generator, color)</span>
<span class="gi">+</span>
<span class="gi">+    pager_cmd = os.environ.get(&#39;PAGER&#39;, &#39;more&#39;)</span>
<span class="gi">+    if pager_cmd == &#39;more&#39; and WIN:</span>
<span class="gi">+        return _tempfilepager(generator, &#39;more &lt;&#39;, color)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;less&#39; in pager_cmd and not WIN:</span>
<span class="gi">+        return _pipepager(generator, &#39;less -R&#39;, color)</span>
<span class="gi">+</span>
<span class="gi">+    return _tempfilepager(generator, pager_cmd, color)</span>


<span class="w"> </span>def _pipepager(generator: t.Iterable[str], cmd: str, color: t.Optional[bool]
<span class="gu">@@ -140,19 +161,50 @@ def _pipepager(generator: t.Iterable[str], cmd: str, color: t.Optional[bool]</span>
<span class="w"> </span>    &quot;&quot;&quot;Page through text by feeding it to another program.  Invoking a
<span class="w"> </span>    pager through this might support colors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import subprocess</span>
<span class="gi">+    env = dict(os.environ)</span>
<span class="gi">+    env[&#39;LESS&#39;] = &#39;FRSX&#39;</span>
<span class="gi">+</span>
<span class="gi">+    c = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, env=env)</span>
<span class="gi">+    encoding = get_best_encoding(c.stdin)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for text in generator:</span>
<span class="gi">+            if not color:</span>
<span class="gi">+                text = strip_ansi(text)</span>
<span class="gi">+            c.stdin.write(text.encode(encoding, &#39;replace&#39;))</span>
<span class="gi">+    except (IOError, KeyboardInterrupt):</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        c.stdin.close()</span>
<span class="gi">+    finally:</span>
<span class="gi">+        c.wait()</span>


<span class="w"> </span>def _tempfilepager(generator: t.Iterable[str], cmd: str, color: t.Optional[
<span class="w"> </span>    bool]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Page through text by invoking a program on a temporary file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import tempfile</span>
<span class="gi">+    filename = tempfile.mktemp()</span>
<span class="gi">+    with open_stream(filename, &#39;wb&#39;)[0] as f:</span>
<span class="gi">+        for text in generator:</span>
<span class="gi">+            if not color:</span>
<span class="gi">+                text = strip_ansi(text)</span>
<span class="gi">+            f.write(text.encode(&#39;utf-8&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        os.system(cmd + &#39; &quot;&#39; + filename + &#39;&quot;&#39;)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.unlink(filename)</span>


<span class="w"> </span>def _nullpager(stream: t.TextIO, generator: t.Iterable[str], color: t.
<span class="w"> </span>    Optional[bool]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Simply print unformatted text.  This is the ultimate fallback.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for text in generator:</span>
<span class="gi">+        if not color:</span>
<span class="gi">+            text = strip_ansi(text)</span>
<span class="gi">+        stream.write(text)</span>


<span class="w"> </span>class Editor:
<span class="gh">diff --git a/src/click/_textwrap.py b/src/click/_textwrap.py</span>
<span class="gh">index 681ea25..5fad1c0 100644</span>
<span class="gd">--- a/src/click/_textwrap.py</span>
<span class="gi">+++ b/src/click/_textwrap.py</span>
<span class="gu">@@ -4,4 +4,39 @@ from contextlib import contextmanager</span>


<span class="w"> </span>class TextWrapper(textwrap.TextWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        super().__init__(*args, **kwargs)</span>
<span class="gi">+        self._current_indent = 0</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(self, text: str) -&gt; t.List[str]:</span>
<span class="gi">+        &quot;&quot;&quot;Wraps the single paragraph in text and returns a list of wrapped lines.</span>
<span class="gi">+</span>
<span class="gi">+        This method overrides the base class method to apply the current indent.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        lines = super().wrap(text)</span>
<span class="gi">+        return [self._current_indent * &#39; &#39; + line for line in lines]</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def extra_indent(self, indent: int) -&gt; t.Generator[None, None, None]:</span>
<span class="gi">+        &quot;&quot;&quot;A context manager for temporarily increasing the indentation.&quot;&quot;&quot;</span>
<span class="gi">+        self._current_indent += indent</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._current_indent -= indent</span>
<span class="gi">+</span>
<span class="gi">+    def dedent(self) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Decrease the current indentation by one level.&quot;&quot;&quot;</span>
<span class="gi">+        if self._current_indent &gt; 0:</span>
<span class="gi">+            self._current_indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def indent(self) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Increase the current indentation by one level.&quot;&quot;&quot;</span>
<span class="gi">+        self._current_indent += 1</span>
<span class="gi">+</span>
<span class="gi">+    def fill(self, text: str) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Fill a single paragraph of text, returning a new string.</span>
<span class="gi">+</span>
<span class="gi">+        This method overrides the base class method to apply the current indent.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return &#39;\n&#39;.join(self.wrap(text))</span>
<span class="gh">diff --git a/src/click/_winconsole.py b/src/click/_winconsole.py</span>
<span class="gh">index 514d97e..0b5802c 100644</span>
<span class="gd">--- a/src/click/_winconsole.py</span>
<span class="gi">+++ b/src/click/_winconsole.py</span>
<span class="gu">@@ -69,11 +69,48 @@ class _WindowsConsoleRawIOBase(io.RawIOBase):</span>


<span class="w"> </span>class _WindowsConsoleReader(_WindowsConsoleRawIOBase):
<span class="gd">-    pass</span>
<span class="gi">+    def readable(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def readinto(self, b):</span>
<span class="gi">+        bytes_to_be_read = len(b)</span>
<span class="gi">+        if not bytes_to_be_read:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        </span>
<span class="gi">+        buffer = (c_char * bytes_to_be_read)()</span>
<span class="gi">+        bytes_read = c_ulong(0)</span>
<span class="gi">+        success = ReadConsoleW(self.handle, buffer, bytes_to_be_read, byref(bytes_read), None)</span>
<span class="gi">+        </span>
<span class="gi">+        if not success:</span>
<span class="gi">+            raise IOError(f&quot;Windows error: {GetLastError()}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if bytes_read.value:</span>
<span class="gi">+            b[:bytes_read.value] = buffer.raw[:bytes_read.value]</span>
<span class="gi">+        return bytes_read.value</span>


<span class="w"> </span>class _WindowsConsoleWriter(_WindowsConsoleRawIOBase):
<span class="gd">-    pass</span>
<span class="gi">+    def writable(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, b):</span>
<span class="gi">+        bytes_to_be_written = len(b)</span>
<span class="gi">+        if not bytes_to_be_written:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        </span>
<span class="gi">+        buffer = c_char_p(b)</span>
<span class="gi">+        bytes_written = c_ulong(0)</span>
<span class="gi">+        </span>
<span class="gi">+        while bytes_written.value &lt; bytes_to_be_written:</span>
<span class="gi">+            chunk = min(bytes_to_be_written - bytes_written.value, MAX_BYTES_WRITTEN)</span>
<span class="gi">+            success = WriteConsoleW(self.handle, buffer, chunk, byref(bytes_written), None)</span>
<span class="gi">+            </span>
<span class="gi">+            if not success:</span>
<span class="gi">+                raise IOError(f&quot;Windows error: {GetLastError()}&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            buffer = c_char_p(b[bytes_written.value:])</span>
<span class="gi">+        </span>
<span class="gi">+        return bytes_written.value</span>


<span class="w"> </span>class ConsoleStream:
<span class="gh">diff --git a/src/click/core.py b/src/click/core.py</span>
<span class="gh">index 354452a..8f8ec25 100644</span>
<span class="gd">--- a/src/click/core.py</span>
<span class="gi">+++ b/src/click/core.py</span>
<span class="gu">@@ -50,14 +50,27 @@ def _complete_visible_commands(ctx: &#39;Context&#39;, incomplete: str) -&gt;t.Iterator[t</span>
<span class="w"> </span>    :param ctx: Invocation context for the group.
<span class="w"> </span>    :param incomplete: Value being completed. May be empty.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name, command in ctx.command.commands.items():</span>
<span class="gi">+        if (</span>
<span class="gi">+            not command.hidden</span>
<span class="gi">+            and name.startswith(incomplete)</span>
<span class="gi">+            and not ctx.resilient_parsing</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield name, command</span>


<span class="w"> </span>@contextmanager
<span class="w"> </span>def augment_usage_errors(ctx: &#39;Context&#39;, param: t.Optional[&#39;Parameter&#39;]=None
<span class="w"> </span>    ) -&gt;t.Iterator[None]:
<span class="w"> </span>    &quot;&quot;&quot;Context manager that attaches extra information to exceptions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    except UsageError as e:</span>
<span class="gi">+        if e.ctx is None:</span>
<span class="gi">+            e.ctx = ctx</span>
<span class="gi">+        if param is not None and e.param is None:</span>
<span class="gi">+            e.param = param</span>
<span class="gi">+        raise</span>


<span class="w"> </span>def iter_params_for_processing(invocation_order: t.Sequence[&#39;Parameter&#39;],
<span class="gu">@@ -66,7 +79,13 @@ def iter_params_for_processing(invocation_order: t.Sequence[&#39;Parameter&#39;],</span>
<span class="w"> </span>    for processing and an iterable of parameters that exist, this returns
<span class="w"> </span>    a list in the correct order as they should be processed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def sort_key(param: &#39;Parameter&#39;) -&gt; t.Tuple[bool, int]:</span>
<span class="gi">+        if param not in declaration_order:</span>
<span class="gi">+            return (True, -1)</span>
<span class="gi">+        idx = declaration_order.index(param)</span>
<span class="gi">+        return (False, idx)</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(invocation_order, key=sort_key)</span>


<span class="w"> </span>class ParameterSource(enum.Enum):
<span class="gu">@@ -784,7 +803,9 @@ class Command(BaseCommand):</span>

<span class="w"> </span>        Calls :meth:`format_usage` internally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        formatter = ctx.make_formatter()</span>
<span class="gi">+        self.format_usage(ctx, formatter)</span>
<span class="gi">+        return formatter.getvalue().rstrip(&#39;\n&#39;)</span>

<span class="w"> </span>    def format_usage(self, ctx: Context, formatter: HelpFormatter) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Writes the usage line into the formatter.
<span class="gu">@@ -797,7 +818,15 @@ class Command(BaseCommand):</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns all the pieces that go into the usage line and returns
<span class="w"> </span>        it as a list of strings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pieces = []</span>
<span class="gi">+        for param in self.get_params(ctx):</span>
<span class="gi">+            if param.nargs == -1:</span>
<span class="gi">+                pieces.append(f&#39;[{param.make_metavar()}]...&#39;)</span>
<span class="gi">+            elif param.nargs &gt; 1:</span>
<span class="gi">+                pieces.append(f&#39;{param.make_metavar()}...&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pieces.append(param.make_metavar())</span>
<span class="gi">+        return pieces</span>

<span class="w"> </span>    def get_help_option_names(self, ctx: Context) -&gt;t.List[str]:
<span class="w"> </span>        &quot;&quot;&quot;Returns the names for the help option.&quot;&quot;&quot;
<span class="gh">diff --git a/src/click/decorators.py b/src/click/decorators.py</span>
<span class="gh">index ec1bfc9..9e17579 100644</span>
<span class="gd">--- a/src/click/decorators.py</span>
<span class="gi">+++ b/src/click/decorators.py</span>
<span class="gu">@@ -25,7 +25,10 @@ def pass_context(f: &#39;t.Callable[te.Concatenate[Context, P], R]&#39;</span>
<span class="w"> </span>    &quot;&quot;&quot;Marks a callback as wanting to receive the current context
<span class="w"> </span>    object as first argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @t.wraps(f)</span>
<span class="gi">+    def new_func(*args: P.args, **kwargs: P.kwargs) -&gt; R:</span>
<span class="gi">+        return f(get_current_context(), *args, **kwargs)</span>
<span class="gi">+    return t.cast(&#39;t.Callable[P, R]&#39;, new_func)</span>


<span class="w"> </span>def pass_obj(f: &#39;t.Callable[te.Concatenate[t.Any, P], R]&#39;
<span class="gu">@@ -34,7 +37,10 @@ def pass_obj(f: &#39;t.Callable[te.Concatenate[t.Any, P], R]&#39;</span>
<span class="w"> </span>    context onwards (:attr:`Context.obj`).  This is useful if that object
<span class="w"> </span>    represents the state of a nested system.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @t.wraps(f)</span>
<span class="gi">+    def new_func(*args: P.args, **kwargs: P.kwargs) -&gt; R:</span>
<span class="gi">+        return f(get_current_context().obj, *args, **kwargs)</span>
<span class="gi">+    return t.cast(&#39;t.Callable[P, R]&#39;, new_func)</span>


<span class="w"> </span>def make_pass_decorator(object_type: t.Type[T], ensure: bool=False
<span class="gu">@@ -61,7 +67,19 @@ def make_pass_decorator(object_type: t.Type[T], ensure: bool=False</span>
<span class="w"> </span>    :param ensure: if set to `True`, a new object will be created and
<span class="w"> </span>                   remembered on the context if it&#39;s not there yet.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: &#39;t.Callable[te.Concatenate[T, P], R]&#39;) -&gt; &#39;t.Callable[P, R]&#39;:</span>
<span class="gi">+        @t.wraps(f)</span>
<span class="gi">+        def new_func(*args: P.args, **kwargs: P.kwargs) -&gt; R:</span>
<span class="gi">+            ctx = get_current_context()</span>
<span class="gi">+            obj = ctx.find_object(object_type)</span>
<span class="gi">+            if obj is None and ensure:</span>
<span class="gi">+                obj = object_type()</span>
<span class="gi">+                ctx.ensure_object(object_type)</span>
<span class="gi">+            if obj is None:</span>
<span class="gi">+                raise RuntimeError(f&#39;Managed to invoke callback without a context object of type {object_type.__name__} existing&#39;)</span>
<span class="gi">+            return ctx.invoke(f, obj, *args, **kwargs)</span>
<span class="gi">+        return t.cast(&#39;t.Callable[P, R]&#39;, new_func)</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def pass_meta_key(key: str, *, doc_description: t.Optional[str]=None
<span class="gu">@@ -77,7 +95,21 @@ def pass_meta_key(key: str, *, doc_description: t.Optional[str]=None</span>

<span class="w"> </span>    .. versionadded:: 8.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if doc_description is None:</span>
<span class="gi">+        doc_description = f&quot;the &#39;{key}&#39; key from Context.meta&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(f: t.Callable[te.Concatenate[t.Any, P], R]) -&gt; t.Callable[P, R]:</span>
<span class="gi">+        @t.wraps(f)</span>
<span class="gi">+        def new_func(*args: P.args, **kwargs: P.kwargs) -&gt; R:</span>
<span class="gi">+            ctx = get_current_context()</span>
<span class="gi">+            if key not in ctx.meta:</span>
<span class="gi">+                raise RuntimeError(f&quot;&#39;{key}&#39; not found in Context.meta&quot;)</span>
<span class="gi">+            return f(ctx.meta[key], *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        new_func.__doc__ = f&quot;Decorator that passes {doc_description} as the first argument to the decorated function.\n\n{new_func.__doc__}&quot;</span>
<span class="gi">+        return t.cast(t.Callable[P, R], new_func)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>CmdType = t.TypeVar(&#39;CmdType&#39;, bound=Command)
<span class="gu">@@ -114,7 +146,31 @@ def command(name: t.Union[t.Optional[str], _AnyCallable]=None, cls: t.</span>
<span class="w"> </span>        The ``params`` argument can be used. Decorated params are
<span class="w"> </span>        appended to the end of the list.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: _AnyCallable) -&gt; t.Union[Command, CmdType]:</span>
<span class="gi">+        if isinstance(name, _AnyCallable):</span>
<span class="gi">+            # The decorator was applied without parentheses</span>
<span class="gi">+            cmd_name = name.__name__.replace(&#39;_&#39;, &#39;-&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd_name = name or f.__name__.replace(&#39;_&#39;, &#39;-&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        cmd_cls = cls or Command</span>
<span class="gi">+        cmd_attrs = attrs.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # If &#39;params&#39; is in attrs, we need to append any decorated params</span>
<span class="gi">+        if &#39;params&#39; in cmd_attrs:</span>
<span class="gi">+            cmd_attrs[&#39;params&#39;] = list(cmd_attrs[&#39;params&#39;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd_attrs[&#39;params&#39;] = []</span>
<span class="gi">+        cmd_attrs[&#39;params&#39;].extend(getattr(f, &#39;__click_params__&#39;, []))</span>
<span class="gi">+</span>
<span class="gi">+        cmd = cmd_cls(name=cmd_name, callback=f, **cmd_attrs)</span>
<span class="gi">+        cmd.__doc__ = f.__doc__</span>
<span class="gi">+        return cmd</span>
<span class="gi">+</span>
<span class="gi">+    if callable(name):</span>
<span class="gi">+        # The decorator was applied without parentheses</span>
<span class="gi">+        return decorator(name)</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>GrpType = t.TypeVar(&#39;GrpType&#39;, bound=Group)
<span class="gh">diff --git a/src/click/formatting.py b/src/click/formatting.py</span>
<span class="gh">index 2586652..ec937dd 100644</span>
<span class="gd">--- a/src/click/formatting.py</span>
<span class="gi">+++ b/src/click/formatting.py</span>
<span class="gu">@@ -26,7 +26,25 @@ def wrap_text(text: str, width: int=78, initial_indent: str=&#39;&#39;,</span>
<span class="w"> </span>    :param preserve_paragraphs: if this flag is set then the wrapping will
<span class="w"> </span>                                intelligently handle paragraphs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from textwrap import TextWrapper</span>
<span class="gi">+    </span>
<span class="gi">+    if not preserve_paragraphs:</span>
<span class="gi">+        wrapper = TextWrapper(width=width, initial_indent=initial_indent,</span>
<span class="gi">+                              subsequent_indent=subsequent_indent)</span>
<span class="gi">+        return wrapper.fill(text)</span>
<span class="gi">+    </span>
<span class="gi">+    paragraphs = text.split(&#39;\n\n&#39;)</span>
<span class="gi">+    wrapped_paragraphs = []</span>
<span class="gi">+    </span>
<span class="gi">+    for paragraph in paragraphs:</span>
<span class="gi">+        if paragraph.startswith(&#39;\b&#39;):</span>
<span class="gi">+            wrapped_paragraphs.append(paragraph[1:])</span>
<span class="gi">+        else:</span>
<span class="gi">+            wrapper = TextWrapper(width=width, initial_indent=initial_indent,</span>
<span class="gi">+                                  subsequent_indent=subsequent_indent)</span>
<span class="gi">+            wrapped_paragraphs.append(wrapper.fill(paragraph))</span>
<span class="gi">+    </span>
<span class="gi">+    return &#39;\n\n&#39;.join(wrapped_paragraphs)</span>


<span class="w"> </span>class HelpFormatter:
<span class="gu">@@ -58,15 +76,15 @@ class HelpFormatter:</span>

<span class="w"> </span>    def write(self, string: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Writes a unicode string into the internal buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.buffer.append(string)</span>

<span class="w"> </span>    def indent(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increases the indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.current_indent += self.indent_increment</span>

<span class="w"> </span>    def dedent(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Decreases the indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.current_indent = max(0, self.current_indent - self.indent_increment)</span>

<span class="w"> </span>    def write_usage(self, prog: str, args: str=&#39;&#39;, prefix: t.Optional[str]=None
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -77,21 +95,29 @@ class HelpFormatter:</span>
<span class="w"> </span>        :param prefix: The prefix for the first line. Defaults to
<span class="w"> </span>            ``&quot;Usage: &quot;``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if prefix is None:</span>
<span class="gi">+            prefix = _(&quot;Usage: &quot;)</span>
<span class="gi">+        usage = f&quot;{prefix}{prog} {args}&quot;.rstrip()</span>
<span class="gi">+        self.write(wrap_text(usage, width=self.width, initial_indent=self.current_indent * &quot; &quot;,</span>
<span class="gi">+                             subsequent_indent=self.current_indent * &quot; &quot; + &quot; &quot; * len(prefix)))</span>
<span class="gi">+        self.write(&quot;\n&quot;)</span>

<span class="w"> </span>    def write_heading(self, heading: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Writes a heading into the buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(f&quot;{&#39; &#39; * self.current_indent}{heading}:\n&quot;)</span>

<span class="w"> </span>    def write_paragraph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Writes a paragraph into the buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(&quot;\n&quot;)</span>

<span class="w"> </span>    def write_text(self, text: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Writes re-indented text into the buffer.  This rewraps and
<span class="w"> </span>        preserves paragraphs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indent = &quot; &quot; * self.current_indent</span>
<span class="gi">+        self.write(wrap_text(text, width=self.width, initial_indent=indent,</span>
<span class="gi">+                             subsequent_indent=indent, preserve_paragraphs=True))</span>
<span class="gi">+        self.write(&quot;\n&quot;)</span>

<span class="w"> </span>    def write_dl(self, rows: t.Sequence[t.Tuple[str, str]], col_max: int=30,
<span class="w"> </span>        col_spacing: int=2) -&gt;None:
<span class="gu">@@ -103,7 +129,20 @@ class HelpFormatter:</span>
<span class="w"> </span>        :param col_spacing: the number of spaces between the first and
<span class="w"> </span>                            second column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indent = &quot; &quot; * self.current_indent</span>
<span class="gi">+        for first, second in rows:</span>
<span class="gi">+            first_width = term_len(first)</span>
<span class="gi">+            if first_width &lt;= col_max:</span>
<span class="gi">+                self.write(f&quot;{indent}{first}&quot;)</span>
<span class="gi">+                self.write(&quot; &quot; * (col_max - first_width))</span>
<span class="gi">+                self.write(&quot; &quot; * col_spacing)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(f&quot;{indent}{first}\n&quot;)</span>
<span class="gi">+                self.write(&quot; &quot; * (col_max + col_spacing))</span>
<span class="gi">+            </span>
<span class="gi">+            wrapped_text = wrap_text(second, width=self.width - col_max - col_spacing,</span>
<span class="gi">+                                     initial_indent=&quot;&quot;, subsequent_indent=&quot; &quot; * (col_max + col_spacing))</span>
<span class="gi">+            self.write(f&quot;{wrapped_text}\n&quot;)</span>

<span class="w"> </span>    @contextmanager
<span class="w"> </span>    def section(self, name: str) -&gt;t.Iterator[None]:
<span class="gu">@@ -112,16 +151,26 @@ class HelpFormatter:</span>

<span class="w"> </span>        :param name: the section name that is written as heading.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_paragraph()</span>
<span class="gi">+        self.write_heading(name)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.dedent()</span>

<span class="w"> </span>    @contextmanager
<span class="w"> </span>    def indentation(self) -&gt;t.Iterator[None]:
<span class="w"> </span>        &quot;&quot;&quot;A context manager that increases the indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.dedent()</span>

<span class="w"> </span>    def getvalue(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns the buffer contents.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;&quot;.join(self.buffer)</span>


<span class="w"> </span>def join_options(options: t.Sequence[str]) -&gt;t.Tuple[str, bool]:
<span class="gu">@@ -130,4 +179,17 @@ def join_options(options: t.Sequence[str]) -&gt;t.Tuple[str, bool]:</span>
<span class="w"> </span>    any_prefix_is_slash)`` where the second item in the tuple is a flag that
<span class="w"> </span>    indicates if any of the option prefixes was a slash.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rv = []</span>
<span class="gi">+    any_prefix_is_slash = False</span>
<span class="gi">+    for opt in options:</span>
<span class="gi">+        prefix = split_opt(opt)[0]</span>
<span class="gi">+        if prefix == &#39;/&#39;:</span>
<span class="gi">+            any_prefix_is_slash = True</span>
<span class="gi">+        rv.append((len(prefix), opt))</span>
<span class="gi">+</span>
<span class="gi">+    rv.sort(key=lambda x: x[0])</span>
<span class="gi">+    rv = [x[1] for x in rv]</span>
<span class="gi">+</span>
<span class="gi">+    if len(rv) == 1:</span>
<span class="gi">+        return rv[0], any_prefix_is_slash</span>
<span class="gi">+    return f&quot;{&#39; / &#39;.join(rv)}&quot;, any_prefix_is_slash</span>
<span class="gh">diff --git a/src/click/globals.py b/src/click/globals.py</span>
<span class="gh">index ca86d44..efbf733 100644</span>
<span class="gd">--- a/src/click/globals.py</span>
<span class="gi">+++ b/src/click/globals.py</span>
<span class="gu">@@ -21,17 +21,27 @@ def get_current_context(silent: bool=False) -&gt;t.Optional[&#39;Context&#39;]:</span>
<span class="w"> </span>                   is available.  The default behavior is to raise a
<span class="w"> </span>                   :exc:`RuntimeError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return t.cast(&#39;Context&#39;, _local.stack[-1])</span>
<span class="gi">+    except (AttributeError, IndexError):</span>
<span class="gi">+        if silent:</span>
<span class="gi">+            return None</span>
<span class="gi">+        raise RuntimeError(&#39;There is no active click context.&#39;) from None</span>


<span class="w"> </span>def push_context(ctx: &#39;Context&#39;) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Pushes a new context to the current stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(_local, &#39;stack&#39;):</span>
<span class="gi">+        _local.stack = []</span>
<span class="gi">+    _local.stack.append(ctx)</span>


<span class="w"> </span>def pop_context() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Removes the top level from the stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        _local.stack.pop()</span>
<span class="gi">+    except (AttributeError, IndexError):</span>
<span class="gi">+        raise RuntimeError(&#39;Cannot pop context. There is no active click context.&#39;) from None</span>


<span class="w"> </span>def resolve_color_default(color: t.Optional[bool]=None) -&gt;t.Optional[bool]:
<span class="gu">@@ -39,4 +49,9 @@ def resolve_color_default(color: t.Optional[bool]=None) -&gt;t.Optional[bool]:</span>
<span class="w"> </span>    value is passed it&#39;s returned unchanged, otherwise it&#39;s looked up from
<span class="w"> </span>    the current context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if color is not None:</span>
<span class="gi">+        return color</span>
<span class="gi">+    ctx = get_current_context(silent=True)</span>
<span class="gi">+    if ctx is not None:</span>
<span class="gi">+        return ctx.color</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/src/click/parser.py b/src/click/parser.py</span>
<span class="gh">index 5baffed..f836ae3 100644</span>
<span class="gd">--- a/src/click/parser.py</span>
<span class="gi">+++ b/src/click/parser.py</span>
<span class="gu">@@ -46,7 +46,25 @@ def _unpack_args(args: t.Sequence[str], nargs_spec: t.Sequence[int]) -&gt;t.Tuple[</span>

<span class="w"> </span>    Missing items are filled with `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args = list(args)</span>
<span class="gi">+    nargs_spec = list(nargs_spec)</span>
<span class="gi">+    unpacked = []</span>
<span class="gi">+    remaining = []</span>
<span class="gi">+</span>
<span class="gi">+    for nargs in nargs_spec:</span>
<span class="gi">+        if nargs == -1:</span>
<span class="gi">+            unpacked.append(args)</span>
<span class="gi">+            break</span>
<span class="gi">+        if len(args) &lt; nargs:</span>
<span class="gi">+            unpacked.append(args + [None] * (nargs - len(args)))</span>
<span class="gi">+            break</span>
<span class="gi">+        unpacked.append(args[:nargs])</span>
<span class="gi">+        args = args[nargs:]</span>
<span class="gi">+</span>
<span class="gi">+    if args:</span>
<span class="gi">+        remaining = args</span>
<span class="gi">+</span>
<span class="gi">+    return unpacked, remaining</span>


<span class="w"> </span>def split_arg_string(string: str) -&gt;t.List[str]:
<span class="gu">@@ -64,7 +82,14 @@ def split_arg_string(string: str) -&gt;t.List[str]:</span>

<span class="w"> </span>    :param string: String to split.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import shlex</span>
<span class="gi">+    lex = shlex.shlex(string, posix=True)</span>
<span class="gi">+    lex.whitespace_split = True</span>
<span class="gi">+    lex.commenters = &#39;&#39;</span>
<span class="gi">+    try:</span>
<span class="gi">+        return list(lex)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return string.split()</span>


<span class="w"> </span>class Option:
<span class="gu">@@ -149,7 +174,12 @@ class OptionParser:</span>
<span class="w"> </span>        The `obj` can be used to identify the option in the order list
<span class="w"> </span>        that is returned from the parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        option = Option(obj, opts, dest, action, nargs, const)</span>
<span class="gi">+        self._opt_prefixes.update(option.prefixes)</span>
<span class="gi">+        for opt in option._short_opts:</span>
<span class="gi">+            self._short_opt[opt] = option</span>
<span class="gi">+        for opt in option._long_opts:</span>
<span class="gi">+            self._long_opt[opt] = option</span>

<span class="w"> </span>    def add_argument(self, obj: &#39;CoreArgument&#39;, dest: t.Optional[str],
<span class="w"> </span>        nargs: int=1) -&gt;None:
<span class="gu">@@ -158,7 +188,7 @@ class OptionParser:</span>
<span class="w"> </span>        The `obj` can be used to identify the option in the order list
<span class="w"> </span>        that is returned from the parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._args.append(Argument(obj, dest, nargs))</span>

<span class="w"> </span>    def parse_args(self, args: t.List[str]) -&gt;t.Tuple[t.Dict[str, t.Any], t
<span class="w"> </span>        .List[str], t.List[&#39;CoreParameter&#39;]]:
<span class="gu">@@ -168,4 +198,119 @@ class OptionParser:</span>
<span class="w"> </span>        appear on the command line.  If arguments appear multiple times they
<span class="w"> </span>        will be memorized multiple times as well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        state = ParsingState(args)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._process_args_for_options(state)</span>
<span class="gi">+            self._process_args_for_args(state)</span>
<span class="gi">+        except UsageError:</span>
<span class="gi">+            if self.ctx is None or not self.ctx.resilient_parsing:</span>
<span class="gi">+                raise</span>
<span class="gi">+        return state.opts, state.largs, state.order</span>
<span class="gi">+</span>
<span class="gi">+    def _process_args_for_options(self, state: ParsingState) -&gt;None:</span>
<span class="gi">+        while state.rargs:</span>
<span class="gi">+            arg = state.rargs.pop(0)</span>
<span class="gi">+            arglen = len(arg)</span>
<span class="gi">+            # Double dashes</span>
<span class="gi">+            if arg == &#39;--&#39;:</span>
<span class="gi">+                return</span>
<span class="gi">+            # Long option</span>
<span class="gi">+            elif arg.startswith(&#39;--&#39;):</span>
<span class="gi">+                self._process_long_opt(arg[2:], state)</span>
<span class="gi">+            # Short option</span>
<span class="gi">+            elif arg[:1] in self._opt_prefixes and arglen &gt; 1:</span>
<span class="gi">+                self._process_short_opts(arg, state)</span>
<span class="gi">+            elif self.allow_interspersed_args:</span>
<span class="gi">+                state.largs.append(arg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                state.rargs.insert(0, arg)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    def _process_args_for_args(self, state: ParsingState) -&gt;None:</span>
<span class="gi">+        state.largs.extend(state.rargs)</span>
<span class="gi">+        state.rargs[:] = []</span>
<span class="gi">+        for idx, arg_spec in enumerate(self._args):</span>
<span class="gi">+            nargs = arg_spec.nargs</span>
<span class="gi">+            if len(state.largs) &lt; nargs:</span>
<span class="gi">+                if nargs == -1:</span>
<span class="gi">+                    break</span>
<span class="gi">+                raise BadArgumentUsage(f&#39;Missing argument &quot;{arg_spec.dest}&quot;&#39;)</span>
<span class="gi">+            if nargs == -1:</span>
<span class="gi">+                state.opts[arg_spec.dest] = state.largs[idx:]</span>
<span class="gi">+                state.order.append(arg_spec.obj)</span>
<span class="gi">+                break</span>
<span class="gi">+            state.opts[arg_spec.dest] = state.largs[idx:idx + nargs]</span>
<span class="gi">+            state.order.append(arg_spec.obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_long_opt(self, opt: str, state: ParsingState) -&gt;None:</span>
<span class="gi">+        if &#39;=&#39; in opt:</span>
<span class="gi">+            opt, next_arg = opt.split(&#39;=&#39;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            next_arg = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            option = self._long_opt[opt]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if self.ignore_unknown_options:</span>
<span class="gi">+                return</span>
<span class="gi">+            raise NoSuchOption(opt)</span>
<span class="gi">+</span>
<span class="gi">+        if option.nargs == 0:</span>
<span class="gi">+            if next_arg:</span>
<span class="gi">+                raise BadOptionUsage(f&#39;Option &quot;--{opt}&quot; does not take a value&#39;)</span>
<span class="gi">+        elif option.nargs == 1:</span>
<span class="gi">+            if next_arg is None:</span>
<span class="gi">+                if not state.rargs:</span>
<span class="gi">+                    raise BadOptionUsage(f&#39;Option &quot;--{opt}&quot; requires an argument&#39;)</span>
<span class="gi">+                next_arg = state.rargs.pop(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if next_arg is None:</span>
<span class="gi">+                if not state.rargs:</span>
<span class="gi">+                    raise BadOptionUsage(f&#39;Option &quot;--{opt}&quot; requires {option.nargs} arguments&#39;)</span>
<span class="gi">+                next_arg = state.rargs[:option.nargs]</span>
<span class="gi">+                state.rargs[:] = state.rargs[option.nargs:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                next_arg = [next_arg] + state.rargs[:option.nargs - 1]</span>
<span class="gi">+                state.rargs[:] = state.rargs[option.nargs - 1:]</span>
<span class="gi">+</span>
<span class="gi">+        self._process_option(option, opt, next_arg, state)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_short_opts(self, arg: str, state: ParsingState) -&gt;None:</span>
<span class="gi">+        i = 1</span>
<span class="gi">+        prefix = arg[0]</span>
<span class="gi">+        while i &lt; len(arg):</span>
<span class="gi">+            opt = arg[i]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            try:</span>
<span class="gi">+                option = self._short_opt[f&#39;{prefix}{opt}&#39;]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                if self.ignore_unknown_options:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                raise NoSuchOption(opt)</span>
<span class="gi">+</span>
<span class="gi">+            if option.nargs == 0:</span>
<span class="gi">+                self._process_option(option, opt, None, state)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if i &lt; len(arg):</span>
<span class="gi">+                    next_arg = arg[i:]</span>
<span class="gi">+                    i = len(arg)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not state.rargs:</span>
<span class="gi">+                        raise BadOptionUsage(f&#39;Option &quot;-{opt}&quot; requires an argument&#39;)</span>
<span class="gi">+                    next_arg = state.rargs.pop(0)</span>
<span class="gi">+                self._process_option(option, opt, next_arg, state)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_option(self, option: Option, opt: str, value: t.Any, state: ParsingState) -&gt;None:</span>
<span class="gi">+        state.order.append(option.obj)</span>
<span class="gi">+        if option.action == &#39;store&#39;:</span>
<span class="gi">+            state.opts[option.dest] = value</span>
<span class="gi">+        elif option.action == &#39;store_const&#39;:</span>
<span class="gi">+            state.opts[option.dest] = option.const</span>
<span class="gi">+        elif option.action == &#39;append&#39;:</span>
<span class="gi">+            state.opts.setdefault(option.dest, []).append(value)</span>
<span class="gi">+        elif option.action == &#39;append_const&#39;:</span>
<span class="gi">+            state.opts.setdefault(option.dest, []).append(option.const)</span>
<span class="gi">+        elif option.action == &#39;count&#39;:</span>
<span class="gi">+            state.opts[option.dest] = state.opts.get(option.dest, 0) + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&#39;Unknown action &quot;{option.action}&quot;&#39;)</span>
<span class="gh">diff --git a/src/click/shell_completion.py b/src/click/shell_completion.py</span>
<span class="gh">index 6956829..055be50 100644</span>
<span class="gd">--- a/src/click/shell_completion.py</span>
<span class="gi">+++ b/src/click/shell_completion.py</span>
<span class="gu">@@ -27,7 +27,15 @@ def shell_complete(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.Any],</span>
<span class="w"> </span>        instruction and shell, in the form ``instruction_shell``.
<span class="w"> </span>    :return: Status code to exit with.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    shell, _, _ = instruction.partition(&quot;_&quot;)</span>
<span class="gi">+    comp_cls = get_completion_class(shell)</span>
<span class="gi">+    if comp_cls is None:</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    comp = comp_cls(cli, ctx_args, prog_name, complete_var)</span>
<span class="gi">+    completion = comp.complete()</span>
<span class="gi">+    echo(completion)</span>
<span class="gi">+    return 0</span>


<span class="w"> </span>class CompletionItem:
<span class="gu">@@ -185,7 +193,7 @@ class ShellComplete:</span>
<span class="w"> </span>        &quot;&quot;&quot;The name of the shell function defined by the completion
<span class="w"> </span>        script.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;_{self.prog_name}_completion&quot;</span>

<span class="w"> </span>    def source_vars(self) -&gt;t.Dict[str, t.Any]:
<span class="w"> </span>        &quot;&quot;&quot;Vars for formatting :attr:`source_template`.
<span class="gu">@@ -193,7 +201,11 @@ class ShellComplete:</span>
<span class="w"> </span>        By default this provides ``complete_func``, ``complete_var``,
<span class="w"> </span>        and ``prog_name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;complete_func&quot;: self.func_name,</span>
<span class="gi">+            &quot;complete_var&quot;: self.complete_var,</span>
<span class="gi">+            &quot;prog_name&quot;: self.prog_name,</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def source(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Produce the shell script that defines the completion
<span class="gu">@@ -201,7 +213,7 @@ class ShellComplete:</span>
<span class="w"> </span>        :attr:`source_template` with the dict returned by
<span class="w"> </span>        :meth:`source_vars`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.source_template % self.source_vars()</span>

<span class="w"> </span>    def get_completion_args(self) -&gt;t.Tuple[t.List[str], str]:
<span class="w"> </span>        &quot;&quot;&quot;Use the env vars defined by the shell script to return a
<span class="gu">@@ -273,7 +285,11 @@ def add_completion_class(cls: ShellCompleteType, name: t.Optional[str]=None</span>
<span class="w"> </span>    :param name: Name to register the class under. Defaults to the
<span class="w"> </span>        class&#39;s ``name`` attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name is None:</span>
<span class="gi">+        name = cls.name</span>
<span class="gi">+</span>
<span class="gi">+    _available_shells[name] = cls</span>
<span class="gi">+    return cls</span>


<span class="w"> </span>def get_completion_class(shell: str) -&gt;t.Optional[t.Type[ShellComplete]]:
<span class="gu">@@ -283,7 +299,7 @@ def get_completion_class(shell: str) -&gt;t.Optional[t.Type[ShellComplete]]:</span>

<span class="w"> </span>    :param shell: Name the class is registered under.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _available_shells.get(shell)</span>


<span class="w"> </span>def _is_incomplete_argument(ctx: Context, param: Parameter) -&gt;bool:
<span class="gu">@@ -294,12 +310,20 @@ def _is_incomplete_argument(ctx: Context, param: Parameter) -&gt;bool:</span>
<span class="w"> </span>        parsed complete args.
<span class="w"> </span>    :param param: Argument object being checked.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(param, Argument):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    value = ctx.params.get(param.name)</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isinstance(value, (tuple, list)):</span>
<span class="gi">+        return param.nargs == -1 or len(value) &lt; param.nargs</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _start_of_option(ctx: Context, value: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if the value looks like the start of an option.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value and value[:1] in ctx.command.params.get(&quot;prefix_chars&quot;, &quot;-&quot;)</span>


<span class="w"> </span>def _is_incomplete_option(ctx: Context, args: t.List[str], param: Parameter
<span class="gu">@@ -309,7 +333,25 @@ def _is_incomplete_option(ctx: Context, args: t.List[str], param: Parameter</span>
<span class="w"> </span>    :param args: List of complete args before the incomplete value.
<span class="w"> </span>    :param param: Option object being checked.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(param, Option):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if param.is_flag:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    last_option = None</span>
<span class="gi">+    for index, arg in enumerate(reversed(args)):</span>
<span class="gi">+        if index + 1 &gt; param.nargs:</span>
<span class="gi">+            break</span>
<span class="gi">+        if _start_of_option(ctx, arg):</span>
<span class="gi">+            last_option = arg</span>
<span class="gi">+</span>
<span class="gi">+    if last_option is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if param.opts:</span>
<span class="gi">+        return last_option in param.opts</span>
<span class="gi">+    return last_option in param.secondary_opts</span>


<span class="w"> </span>def _resolve_context(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.
<span class="gu">@@ -322,7 +364,22 @@ def _resolve_context(cli: BaseCommand, ctx_args: t.MutableMapping[str, t.</span>
<span class="w"> </span>    :param prog_name: Name of the executable in the shell.
<span class="w"> </span>    :param args: List of complete args before the incomplete value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ctx = cli.make_context(prog_name, args, **ctx_args)</span>
<span class="gi">+    args = list(args)</span>
<span class="gi">+</span>
<span class="gi">+    while args:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(ctx.command, MultiCommand):</span>
<span class="gi">+                cmd_name, cmd, args = ctx.command.resolve_command(ctx, args)</span>
<span class="gi">+                if cmd is None:</span>
<span class="gi">+                    return ctx</span>
<span class="gi">+                ctx = cmd.make_context(cmd_name, args, parent=ctx)</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return ctx</span>


<span class="w"> </span>def _resolve_incomplete(ctx: Context, args: t.List[str], incomplete: str
<span class="gu">@@ -335,4 +392,17 @@ def _resolve_incomplete(ctx: Context, args: t.List[str], incomplete: str</span>
<span class="w"> </span>    :param args: List of complete args before the incomplete value.
<span class="w"> </span>    :param incomplete: Value being completed. May be empty.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    params = ctx.command.get_params(ctx)</span>
<span class="gi">+</span>
<span class="gi">+    for param in params:</span>
<span class="gi">+        if _is_incomplete_argument(ctx, param):</span>
<span class="gi">+            return param, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    if _start_of_option(ctx, incomplete):</span>
<span class="gi">+        return ctx.command, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    for param in params:</span>
<span class="gi">+        if _is_incomplete_option(ctx, args, param):</span>
<span class="gi">+            return param, incomplete</span>
<span class="gi">+</span>
<span class="gi">+    return ctx.command, incomplete</span>
<span class="gh">diff --git a/src/click/termui.py b/src/click/termui.py</span>
<span class="gh">index 277721a..6582c5b 100644</span>
<span class="gd">--- a/src/click/termui.py</span>
<span class="gi">+++ b/src/click/termui.py</span>
<span class="gu">@@ -71,7 +71,46 @@ def prompt(text: str, default: t.Optional[t.Any]=None, hide_input: bool=</span>
<span class="w"> </span>        Added the `err` parameter.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    prompt_text = text</span>
<span class="gi">+    if show_choices and isinstance(type, Choice):</span>
<span class="gi">+        prompt_text += f&quot; ({&#39;, &#39;.join(type.choices)})&quot;</span>
<span class="gi">+    if default is not None and show_default:</span>
<span class="gi">+        prompt_text += f&quot; [{default}]&quot;</span>
<span class="gi">+    prompt_text += prompt_suffix</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if hide_input:</span>
<span class="gi">+                value = visible_prompt_func(prompt_text)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = input(prompt_text)</span>
<span class="gi">+        except (KeyboardInterrupt, EOFError):</span>
<span class="gi">+            raise Abort()</span>
<span class="gi">+</span>
<span class="gi">+        if value == &quot;&quot; and default is not None:</span>
<span class="gi">+            value = default</span>
<span class="gi">+</span>
<span class="gi">+        if value_proc is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = value_proc(value)</span>
<span class="gi">+            except UsageError as e:</span>
<span class="gi">+                echo(f&quot;Error: {e.message}&quot;, err=err)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        if type is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = type(value)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                echo(f&quot;Error: Invalid input type. Expected {type.__name__}.&quot;, err=err)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        if confirmation_prompt:</span>
<span class="gi">+            confirm_text = &quot;Repeat for confirmation: &quot; if confirmation_prompt is True else confirmation_prompt</span>
<span class="gi">+            if value != prompt(confirm_text, type=type, value_proc=value_proc, hide_input=hide_input, err=err):</span>
<span class="gi">+                echo(&quot;Error: The two entered values do not match&quot;, err=err)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>


<span class="w"> </span>def confirm(text: str, default: t.Optional[bool]=False, abort: bool=False,
<span class="gu">@@ -97,7 +136,35 @@ def confirm(text: str, default: t.Optional[bool]=False, abort: bool=False,</span>
<span class="w"> </span>    .. versionadded:: 4.0
<span class="w"> </span>        Added the ``err`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    prompt_text = text</span>
<span class="gi">+    if show_default:</span>
<span class="gi">+        if default is None:</span>
<span class="gi">+            prompt_text += &quot; (y/n)&quot;</span>
<span class="gi">+        elif default:</span>
<span class="gi">+            prompt_text += &quot; [Y/n]&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            prompt_text += &quot; [y/N]&quot;</span>
<span class="gi">+    prompt_text += prompt_suffix</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = prompt(prompt_text, err=err).lower().strip()</span>
<span class="gi">+        except Abort:</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+        if value in (&#39;y&#39;, &#39;yes&#39;):</span>
<span class="gi">+            rv = True</span>
<span class="gi">+        elif value in (&#39;n&#39;, &#39;no&#39;):</span>
<span class="gi">+            rv = False</span>
<span class="gi">+        elif value == &#39;&#39; and default is not None:</span>
<span class="gi">+            rv = default</span>
<span class="gi">+        else:</span>
<span class="gi">+            echo(&quot;Error: invalid input&quot;, err=err)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if abort and not rv:</span>
<span class="gi">+            raise Abort()</span>
<span class="gi">+        return rv</span>


<span class="w"> </span>def echo_via_pager(text_or_generator: t.Union[t.Iterable[str], t.Callable[[
<span class="gu">@@ -113,7 +180,8 @@ def echo_via_pager(text_or_generator: t.Union[t.Iterable[str], t.Callable[[</span>
<span class="w"> </span>    :param color: controls if the pager supports ANSI colors or not.  The
<span class="w"> </span>                  default is autodetection.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ._termui_impl import pager</span>
<span class="gi">+    pager(text_or_generator, color)</span>


<span class="w"> </span>def progressbar(iterable: t.Optional[t.Iterable[V]]=None, length: t.
<span class="gu">@@ -237,7 +305,24 @@ def progressbar(iterable: t.Optional[t.Iterable[V]]=None, length: t.</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ._termui_impl import ProgressBar</span>
<span class="gi">+    return ProgressBar(</span>
<span class="gi">+        iterable=iterable,</span>
<span class="gi">+        length=length,</span>
<span class="gi">+        show_eta=show_eta,</span>
<span class="gi">+        show_percent=show_percent,</span>
<span class="gi">+        show_pos=show_pos,</span>
<span class="gi">+        item_show_func=item_show_func,</span>
<span class="gi">+        fill_char=fill_char,</span>
<span class="gi">+        empty_char=empty_char,</span>
<span class="gi">+        bar_template=bar_template,</span>
<span class="gi">+        info_sep=info_sep,</span>
<span class="gi">+        file=file,</span>
<span class="gi">+        label=label,</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        update_min_steps=update_min_steps,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def clear() -&gt;None:
<span class="gu">@@ -247,7 +332,15 @@ def clear() -&gt;None:</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isatty(sys.stdout):</span>
<span class="gi">+        return</span>
<span class="gi">+    # If we&#39;re on Windows, use os.system()</span>
<span class="gi">+    if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+        os.system(&#39;cls&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Otherwise, assume POSIX-like system</span>
<span class="gi">+        sys.stdout.write(&#39;\033[2J\033[1;1H&#39;)</span>
<span class="gi">+    sys.stdout.flush()</span>


<span class="w"> </span>def style(text: t.Any, fg: t.Optional[t.Union[int, t.Tuple[int, int, int],
<span class="gu">@@ -333,7 +426,47 @@ def style(text: t.Any, fg: t.Optional[t.Union[int, t.Tuple[int, int, int],</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        text = str(text)</span>
<span class="gi">+</span>
<span class="gi">+    bits = []</span>
<span class="gi">+</span>
<span class="gi">+    if fg:</span>
<span class="gi">+        try:</span>
<span class="gi">+            bits.append(f&#39;\033[38;5;{_ansi_colors[fg]}m&#39;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if isinstance(fg, int):</span>
<span class="gi">+                bits.append(f&#39;\033[38;5;{fg}m&#39;)</span>
<span class="gi">+            elif isinstance(fg, tuple):</span>
<span class="gi">+                bits.append(f&#39;\033[38;2;{fg[0]};{fg[1]};{fg[2]}m&#39;)</span>
<span class="gi">+    if bg:</span>
<span class="gi">+        try:</span>
<span class="gi">+            bits.append(f&#39;\033[48;5;{_ansi_colors[bg]}m&#39;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if isinstance(bg, int):</span>
<span class="gi">+                bits.append(f&#39;\033[48;5;{bg}m&#39;)</span>
<span class="gi">+            elif isinstance(bg, tuple):</span>
<span class="gi">+                bits.append(f&#39;\033[48;2;{bg[0]};{bg[1]};{bg[2]}m&#39;)</span>
<span class="gi">+    if bold is not None:</span>
<span class="gi">+        bits.append(&#39;\033[1m&#39; if bold else &#39;\033[22m&#39;)</span>
<span class="gi">+    if dim is not None:</span>
<span class="gi">+        bits.append(&#39;\033[2m&#39; if dim else &#39;\033[22m&#39;)</span>
<span class="gi">+    if underline is not None:</span>
<span class="gi">+        bits.append(&#39;\033[4m&#39; if underline else &#39;\033[24m&#39;)</span>
<span class="gi">+    if overline is not None:</span>
<span class="gi">+        bits.append(&#39;\033[53m&#39; if overline else &#39;\033[55m&#39;)</span>
<span class="gi">+    if italic is not None:</span>
<span class="gi">+        bits.append(&#39;\033[3m&#39; if italic else &#39;\033[23m&#39;)</span>
<span class="gi">+    if blink is not None:</span>
<span class="gi">+        bits.append(&#39;\033[5m&#39; if blink else &#39;\033[25m&#39;)</span>
<span class="gi">+    if reverse is not None:</span>
<span class="gi">+        bits.append(&#39;\033[7m&#39; if reverse else &#39;\033[27m&#39;)</span>
<span class="gi">+    if strikethrough is not None:</span>
<span class="gi">+        bits.append(&#39;\033[9m&#39; if strikethrough else &#39;\033[29m&#39;)</span>
<span class="gi">+    bits.append(text)</span>
<span class="gi">+    if reset:</span>
<span class="gi">+        bits.append(_ansi_reset_all)</span>
<span class="gi">+    return &#39;&#39;.join(bits)</span>


<span class="w"> </span>def unstyle(text: str) -&gt;str:
<span class="gu">@@ -345,7 +478,7 @@ def unstyle(text: str) -&gt;str:</span>

<span class="w"> </span>    :param text: the text to remove style information from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return strip_ansi(text)</span>


<span class="w"> </span>def secho(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.AnyStr]]
<span class="gu">@@ -371,7 +504,14 @@ def secho(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.AnyStr]]</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if message is not None:</span>
<span class="gi">+        if isinstance(message, bytes):</span>
<span class="gi">+            echo(message, file, nl, err, color)</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            message = style(message, **styles)</span>
<span class="gi">+</span>
<span class="gi">+    echo(message, file, nl, err, color)</span>


<span class="w"> </span>def edit(text: t.Optional[t.AnyStr]=None, editor: t.Optional[str]=None, env:
<span class="gu">@@ -405,7 +545,42 @@ def edit(text: t.Optional[t.AnyStr]=None, editor: t.Optional[str]=None, env:</span>
<span class="w"> </span>                     provided text contents.  It will not use a temporary
<span class="w"> </span>                     file as an indirection in that case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import tempfile</span>
<span class="gi">+    import subprocess</span>
<span class="gi">+</span>
<span class="gi">+    if filename is None:</span>
<span class="gi">+        if text is None:</span>
<span class="gi">+            raise UsageError(&quot;Either &#39;text&#39; or &#39;filename&#39; must be provided.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as f:</span>
<span class="gi">+            if isinstance(text, bytes):</span>
<span class="gi">+                f.write(text)</span>
<span class="gi">+            else:</span>
<span class="gi">+                f.write(text.encode(&#39;utf-8&#39;))</span>
<span class="gi">+            filename = f.name</span>
<span class="gi">+</span>
<span class="gi">+    if editor is None:</span>
<span class="gi">+        editor = os.environ.get(&#39;EDITOR&#39;, &#39;vim&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if env is None:</span>
<span class="gi">+        env = {}</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        c = subprocess.Popen([editor, filename], env=env)</span>
<span class="gi">+        exit_code = c.wait()</span>
<span class="gi">+        if exit_code != 0:</span>
<span class="gi">+            raise UsageError(f&quot;{editor}: Editing failed!&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if require_save and os.path.getsize(filename) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+            rv = f.read()</span>
<span class="gi">+</span>
<span class="gi">+        return rv.decode(&#39;utf-8&#39;)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if filename and text is not None:</span>
<span class="gi">+            os.unlink(filename)</span>


<span class="w"> </span>def launch(url: str, wait: bool=False, locate: bool=False) -&gt;int:
<span class="gu">@@ -432,7 +607,45 @@ def launch(url: str, wait: bool=False, locate: bool=False) -&gt;int:</span>
<span class="w"> </span>                   might have weird effects if the URL does not point to
<span class="w"> </span>                   the filesystem.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import subprocess</span>
<span class="gi">+</span>
<span class="gi">+    def _launch_windows(url, wait=False, locate=False):</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            cmd = &#39;explorer /select,&quot;{}&quot;&#39;.format(os.path.normpath(url))</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd = &#39;start &quot;&quot; &quot;{}&quot;&#39;.format(url)</span>
<span class="gi">+        exit_code = os.system(cmd)</span>
<span class="gi">+        if wait:</span>
<span class="gi">+            os.system(&#39;pause&#39;)</span>
<span class="gi">+        return exit_code</span>
<span class="gi">+</span>
<span class="gi">+    def _launch_macos(url, wait=False, locate=False):</span>
<span class="gi">+        cmd = [&#39;open&#39;]</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            cmd.append(&#39;-R&#39;)</span>
<span class="gi">+        cmd.append(url)</span>
<span class="gi">+        c = subprocess.Popen(cmd)</span>
<span class="gi">+        if wait:</span>
<span class="gi">+            return c.wait()</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def _launch_linux(url, wait=False, locate=False):</span>
<span class="gi">+        cmd = [&#39;xdg-open&#39;]</span>
<span class="gi">+        if locate:</span>
<span class="gi">+            cmd.append(os.path.dirname(url))</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd.append(url)</span>
<span class="gi">+        c = subprocess.Popen(cmd)</span>
<span class="gi">+        if wait:</span>
<span class="gi">+            return c.wait()</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+        return _launch_windows(url, wait, locate)</span>
<span class="gi">+    elif sys.platform == &#39;darwin&#39;:</span>
<span class="gi">+        return _launch_macos(url, wait, locate)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _launch_linux(url, wait, locate)</span>


<span class="w"> </span>_getchar: t.Optional[t.Callable[[bool], str]] = None
<span class="gu">@@ -458,7 +671,37 @@ def getchar(echo: bool=False) -&gt;str:</span>
<span class="w"> </span>    :param echo: if set to `True`, the character read will also show up on
<span class="w"> </span>                 the terminal.  The default is to not show it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _getchar</span>
<span class="gi">+    if _getchar is None:</span>
<span class="gi">+        if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+            import msvcrt</span>
<span class="gi">+</span>
<span class="gi">+            def _getchar_windows(echo):</span>
<span class="gi">+                char = msvcrt.getwch()</span>
<span class="gi">+                if echo:</span>
<span class="gi">+                    msvcrt.putwch(char)</span>
<span class="gi">+                return char</span>
<span class="gi">+</span>
<span class="gi">+            _getchar = _getchar_windows</span>
<span class="gi">+        else:</span>
<span class="gi">+            import tty</span>
<span class="gi">+            import termios</span>
<span class="gi">+</span>
<span class="gi">+            def _getchar_unix(echo):</span>
<span class="gi">+                fd = sys.stdin.fileno()</span>
<span class="gi">+                old_settings = termios.tcgetattr(fd)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    tty.setraw(fd)</span>
<span class="gi">+                    ch = sys.stdin.read(1)</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)</span>
<span class="gi">+                if echo:</span>
<span class="gi">+                    sys.stdout.write(ch)</span>
<span class="gi">+                return ch</span>
<span class="gi">+</span>
<span class="gi">+            _getchar = _getchar_unix</span>
<span class="gi">+</span>
<span class="gi">+    return _getchar(echo)</span>


<span class="w"> </span>def pause(info: t.Optional[str]=None, err: bool=False) -&gt;None:
<span class="gu">@@ -477,4 +720,19 @@ def pause(info: t.Optional[str]=None, err: bool=False) -&gt;None:</span>
<span class="w"> </span>    :param err: if set to message goes to ``stderr`` instead of
<span class="w"> </span>                ``stdout``, the same as with echo.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if info is None:</span>
<span class="gi">+        info = &quot;Press any key to continue...&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if not isatty(sys.stdin):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if info:</span>
<span class="gi">+            echo(info, nl=False, err=err)</span>
<span class="gi">+        try:</span>
<span class="gi">+            getchar()</span>
<span class="gi">+        except (KeyboardInterrupt, EOFError):</span>
<span class="gi">+            pass</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if info:</span>
<span class="gi">+            echo(err=err)</span>
<span class="gh">diff --git a/src/click/testing.py b/src/click/testing.py</span>
<span class="gh">index 320d223..b588f84 100644</span>
<span class="gd">--- a/src/click/testing.py</span>
<span class="gi">+++ b/src/click/testing.py</span>
<span class="gu">@@ -59,17 +59,19 @@ class Result:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def output(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The (standard) output as unicode string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stdout</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def stdout(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The standard output as unicode string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stdout_bytes.decode(self.runner.charset, &#39;replace&#39;)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def stderr(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The standard error as unicode string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stderr_bytes is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.stderr_bytes.decode(self.runner.charset, &#39;replace&#39;)</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        exc_str = repr(self.exception) if self.exception else &#39;okay&#39;
<span class="gu">@@ -108,12 +110,15 @@ class CliRunner:</span>
<span class="w"> </span>        for it.  The default is the `name` attribute or ``&quot;root&quot;`` if not
<span class="w"> </span>        set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cli.name or &quot;root&quot;</span>

<span class="w"> </span>    def make_env(self, overrides: t.Optional[t.Mapping[str, t.Optional[str]
<span class="w"> </span>        ]]=None) -&gt;t.Mapping[str, t.Optional[str]]:
<span class="w"> </span>        &quot;&quot;&quot;Returns the environment overrides for invoking a script.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        env = dict(self.env)</span>
<span class="gi">+        if overrides:</span>
<span class="gi">+            env.update(overrides)</span>
<span class="gi">+        return env</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="w"> </span>    def isolation(self, input: t.Optional[t.Union[str, bytes, t.IO[t.Any]]]
<span class="gu">@@ -139,7 +144,71 @@ class CliRunner:</span>
<span class="w"> </span>        .. versionchanged:: 4.0
<span class="w"> </span>            Added the ``color`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        old_env = {}</span>
<span class="gi">+        try:</span>
<span class="gi">+            for key, value in self.make_env(env).items():</span>
<span class="gi">+                old_env[key] = os.environ.get(key)</span>
<span class="gi">+                if value is None:</span>
<span class="gi">+                    os.environ.pop(key, None)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    os.environ[key] = value</span>
<span class="gi">+</span>
<span class="gi">+            old_stdin = sys.stdin</span>
<span class="gi">+            old_stdout = sys.stdout</span>
<span class="gi">+            old_stderr = sys.stderr</span>
<span class="gi">+            old_testing = termui.isatty</span>
<span class="gi">+            old_color = utils.should_strip_ansi</span>
<span class="gi">+</span>
<span class="gi">+            bytes_input = None</span>
<span class="gi">+            if input is not None:</span>
<span class="gi">+                if isinstance(input, str):</span>
<span class="gi">+                    bytes_input = input.encode(self.charset)</span>
<span class="gi">+                elif isinstance(input, bytes):</span>
<span class="gi">+                    bytes_input = input</span>
<span class="gi">+                elif hasattr(input, &quot;read&quot;):</span>
<span class="gi">+                    bytes_input = input.read()</span>
<span class="gi">+                    if isinstance(bytes_input, str):</span>
<span class="gi">+                        bytes_input = bytes_input.encode(self.charset)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise TypeError(&quot;Invalid input type&quot;)</span>
<span class="gi">+                sys.stdin = io.BytesIO(bytes_input)</span>
<span class="gi">+            else:</span>
<span class="gi">+                sys.stdin = io.BytesIO(b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            stdout = io.BytesIO()</span>
<span class="gi">+            stderr = io.BytesIO() if not self.mix_stderr else None</span>
<span class="gi">+</span>
<span class="gi">+            if self.echo_stdin:</span>
<span class="gi">+                input = EchoingStdin(input, stdout)</span>
<span class="gi">+</span>
<span class="gi">+            sys.stdout = _NamedTextIOWrapper(</span>
<span class="gi">+                stdout, &quot;stdout&quot;, &quot;w&quot;, encoding=self.charset, errors=&quot;backslashreplace&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            if stderr is not None:</span>
<span class="gi">+                sys.stderr = _NamedTextIOWrapper(</span>
<span class="gi">+                    stderr, &quot;stderr&quot;, &quot;w&quot;, encoding=self.charset, errors=&quot;backslashreplace&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                sys.stderr = sys.stdout</span>
<span class="gi">+</span>
<span class="gi">+            def is_testing():</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+            termui.isatty = is_testing</span>
<span class="gi">+            utils.should_strip_ansi = lambda *args, **kwargs: not color</span>
<span class="gi">+</span>
<span class="gi">+            yield stdout, stderr</span>
<span class="gi">+        finally:</span>
<span class="gi">+            for key, value in old_env.items():</span>
<span class="gi">+                if value is None:</span>
<span class="gi">+                    os.environ.pop(key, None)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    os.environ[key] = value</span>
<span class="gi">+            sys.stdin = old_stdin</span>
<span class="gi">+            sys.stdout = old_stdout</span>
<span class="gi">+            sys.stderr = old_stderr</span>
<span class="gi">+            termui.isatty = old_testing</span>
<span class="gi">+            utils.should_strip_ansi = old_color</span>

<span class="w"> </span>    def invoke(self, cli: &#39;BaseCommand&#39;, args: t.Optional[t.Union[str, t.
<span class="w"> </span>        Sequence[str]]]=None, input: t.Optional[t.Union[str, bytes, t.IO[t.
<span class="gu">@@ -180,7 +249,59 @@ class CliRunner:</span>
<span class="w"> </span>            The result object has the ``exc_info`` attribute with the
<span class="w"> </span>            traceback if available.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        exc_info = None</span>
<span class="gi">+        with self.isolation(input=input, env=env, color=color) as outstreams:</span>
<span class="gi">+            return_value = None</span>
<span class="gi">+            exception = None</span>
<span class="gi">+            exit_code = 0</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(args, str):</span>
<span class="gi">+                args = shlex.split(args)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                prog_name = extra.pop(&quot;prog_name&quot;, None)</span>
<span class="gi">+                if prog_name is None:</span>
<span class="gi">+                    prog_name = self.get_default_prog_name(cli)</span>
<span class="gi">+</span>
<span class="gi">+                return_value = cli.main(</span>
<span class="gi">+                    args=args or (),</span>
<span class="gi">+                    prog_name=prog_name,</span>
<span class="gi">+                    standalone_mode=False,</span>
<span class="gi">+                    **extra</span>
<span class="gi">+                )</span>
<span class="gi">+            except SystemExit as e:</span>
<span class="gi">+                exc_info = sys.exc_info()</span>
<span class="gi">+                exit_code = e.code</span>
<span class="gi">+                if exit_code is None:</span>
<span class="gi">+                    exit_code = 0</span>
<span class="gi">+</span>
<span class="gi">+                if exit_code != 0:</span>
<span class="gi">+                    exception = e</span>
<span class="gi">+</span>
<span class="gi">+                if not isinstance(exit_code, int):</span>
<span class="gi">+                    sys.stdout.write(str(exit_code))</span>
<span class="gi">+                    sys.stdout.write(&quot;\n&quot;)</span>
<span class="gi">+                    exit_code = 1</span>
<span class="gi">+</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                if not catch_exceptions:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                exception = e</span>
<span class="gi">+                exit_code = 1</span>
<span class="gi">+                exc_info = sys.exc_info()</span>
<span class="gi">+</span>
<span class="gi">+            stdout_bytes = outstreams[0].getvalue()</span>
<span class="gi">+            stderr_bytes = outstreams[1].getvalue() if outstreams[1] else None</span>
<span class="gi">+</span>
<span class="gi">+        return Result(</span>
<span class="gi">+            runner=self,</span>
<span class="gi">+            stdout_bytes=stdout_bytes,</span>
<span class="gi">+            stderr_bytes=stderr_bytes,</span>
<span class="gi">+            return_value=return_value,</span>
<span class="gi">+            exit_code=exit_code,</span>
<span class="gi">+            exception=exception,</span>
<span class="gi">+            exc_info=exc_info,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="w"> </span>    def isolated_filesystem(self, temp_dir: t.Optional[t.Union[str,
<span class="gu">@@ -197,4 +318,20 @@ class CliRunner:</span>
<span class="w"> </span>        .. versionchanged:: 8.0
<span class="w"> </span>            Added the ``temp_dir`` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cwd = os.getcwd()</span>
<span class="gi">+        if temp_dir is not None:</span>
<span class="gi">+            temp_dir = os.path.abspath(temp_dir)</span>
<span class="gi">+            fs = tempfile.mkdtemp(dir=temp_dir)</span>
<span class="gi">+            os.chdir(fs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fs = tempfile.mkdtemp()</span>
<span class="gi">+            os.chdir(fs)</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield fs</span>
<span class="gi">+        finally:</span>
<span class="gi">+            os.chdir(cwd)</span>
<span class="gi">+            if temp_dir is None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    shutil.rmtree(fs)</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    pass</span>
<span class="gh">diff --git a/src/click/types.py b/src/click/types.py</span>
<span class="gh">index 4527388..f33a2a0 100644</span>
<span class="gd">--- a/src/click/types.py</span>
<span class="gi">+++ b/src/click/types.py</span>
<span class="gu">@@ -49,7 +49,10 @@ class ParamType:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;name&quot;: self.name,</span>
<span class="gi">+            &quot;param_type&quot;: self.__class__.__name__,</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def __call__(self, value: t.Any, param: t.Optional[&#39;Parameter&#39;]=None,
<span class="w"> </span>        ctx: t.Optional[&#39;Context&#39;]=None) -&gt;t.Any:
<span class="gu">@@ -58,7 +61,7 @@ class ParamType:</span>

<span class="w"> </span>    def get_metavar(self, param: &#39;Parameter&#39;) -&gt;t.Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;Returns the metavar default for this param if it provides one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.name.upper()</span>

<span class="w"> </span>    def get_missing_message(self, param: &#39;Parameter&#39;) -&gt;t.Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;Optionally might return extra information about a missing
<span class="gu">@@ -66,7 +69,7 @@ class ParamType:</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;Missing {self.name} value.&quot;</span>

<span class="w"> </span>    def convert(self, value: t.Any, param: t.Optional[&#39;Parameter&#39;], ctx: t.
<span class="w"> </span>        Optional[&#39;Context&#39;]) -&gt;t.Any:
<span class="gu">@@ -89,7 +92,7 @@ class ParamType:</span>
<span class="w"> </span>        :param ctx: The current context that arrived at this value. May
<span class="w"> </span>            be ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return value  # Default implementation: no conversion</span>

<span class="w"> </span>    def split_envvar_value(self, rv: str) -&gt;t.Sequence[str]:
<span class="w"> </span>        &quot;&quot;&quot;Given a value from an environment variable this splits it up
<span class="gu">@@ -99,12 +102,14 @@ class ParamType:</span>
<span class="w"> </span>        then leading and trailing whitespace is ignored.  Otherwise, leading
<span class="w"> </span>        and trailing splitters usually lead to empty items being included.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.envvar_list_splitter is None:</span>
<span class="gi">+            return [rv.strip()]</span>
<span class="gi">+        return [x for x in rv.split(self.envvar_list_splitter) if x]</span>

<span class="w"> </span>    def fail(self, message: str, param: t.Optional[&#39;Parameter&#39;]=None, ctx:
<span class="w"> </span>        t.Optional[&#39;Context&#39;]=None) -&gt;&#39;t.NoReturn&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Helper method to fail with an invalid value message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise BadParameter(message, ctx=ctx, param=param)</span>

<span class="w"> </span>    def shell_complete(self, ctx: &#39;Context&#39;, param: &#39;Parameter&#39;, incomplete:
<span class="w"> </span>        str) -&gt;t.List[&#39;CompletionItem&#39;]:
<span class="gu">@@ -120,7 +125,7 @@ class ParamType:</span>

<span class="w"> </span>        .. versionadded:: 8.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Default implementation: no completions</span>


<span class="w"> </span>class CompositeParamType(ParamType):
<span class="gh">diff --git a/src/click/utils.py b/src/click/utils.py</span>
<span class="gh">index 0b2575c..7602f67 100644</span>
<span class="gd">--- a/src/click/utils.py</span>
<span class="gi">+++ b/src/click/utils.py</span>
<span class="gu">@@ -24,17 +24,35 @@ R = t.TypeVar(&#39;R&#39;)</span>

<span class="w"> </span>def safecall(func: &#39;t.Callable[P, R]&#39;) -&gt;&#39;t.Callable[P, t.Optional[R]]&#39;:
<span class="w"> </span>    &quot;&quot;&quot;Wraps a function so that it swallows exceptions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; t.Optional[R]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return None</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def make_str(value: t.Any) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Converts a value into a valid string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return value.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            return value.decode(&#39;utf-8&#39;, &#39;replace&#39;)</span>
<span class="gi">+    return str(value)</span>


<span class="w"> </span>def make_default_short_help(help: str, max_length: int=45) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Returns a condensed version of help string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    words = help.split()</span>
<span class="gi">+    total_length = 0</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for word in words:</span>
<span class="gi">+        if total_length + len(word) + 1 &gt; max_length:</span>
<span class="gi">+            break</span>
<span class="gi">+        result.append(word)</span>
<span class="gi">+        total_length += len(word) + 1</span>
<span class="gi">+    return &#39; &#39;.join(result) + (&#39;...&#39; if len(result) &lt; len(words) else &#39;&#39;)</span>


<span class="w"> </span>class LazyFile:
<span class="gu">@@ -76,17 +94,35 @@ class LazyFile:</span>
<span class="w"> </span>        a :exc:`FileError`.  Not handling this error will produce an error
<span class="w"> </span>        that Click shows.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._f is not None:</span>
<span class="gi">+            return self._f</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.atomic:</span>
<span class="gi">+                import tempfile</span>
<span class="gi">+                f = tempfile.NamedTemporaryFile(</span>
<span class="gi">+                    mode=self.mode, encoding=self.encoding,</span>
<span class="gi">+                    errors=self.errors, delete=False</span>
<span class="gi">+                )</span>
<span class="gi">+                self._f = f</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._f = open(self.name, self.mode, encoding=self.encoding, errors=self.errors)</span>
<span class="gi">+            return self._f</span>
<span class="gi">+        except (IOError, OSError) as e:</span>
<span class="gi">+            from click import FileError</span>
<span class="gi">+            raise FileError(self.name, hint=str(e))</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Closes the underlying file, no matter what.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._f is not None:</span>
<span class="gi">+            self._f.close()</span>
<span class="gi">+            self._f = None</span>

<span class="w"> </span>    def close_intelligently(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This function only closes the file if it was opened by the lazy
<span class="w"> </span>        file wrapper.  For instance this will never close stdin.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.should_close:</span>
<span class="gi">+            self.close()</span>

<span class="w"> </span>    def __enter__(self) -&gt;&#39;LazyFile&#39;:
<span class="w"> </span>        return self
<span class="gu">@@ -164,7 +200,30 @@ def echo(message: t.Optional[t.Any]=None, file: t.Optional[t.IO[t.Any]]=</span>
<span class="w"> </span>    .. versionchanged:: 2.0
<span class="w"> </span>        Support colors on Windows if colorama is installed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if file is None:</span>
<span class="gi">+        file = _default_text_stderr() if err else _default_text_stdout()</span>
<span class="gi">+</span>
<span class="gi">+    if message is not None:</span>
<span class="gi">+        if not isinstance(message, (str, bytes, bytearray)):</span>
<span class="gi">+            message = str(message)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(file, binary_streams):</span>
<span class="gi">+            if isinstance(message, str):</span>
<span class="gi">+                message = message.encode(file.encoding or &#39;utf-8&#39;, &#39;replace&#39;)</span>
<span class="gi">+        elif isinstance(message, (bytes, bytearray)):</span>
<span class="gi">+            message = message.decode(&#39;utf-8&#39;, &#39;replace&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        color = resolve_color_default()</span>
<span class="gi">+</span>
<span class="gi">+    if should_strip_ansi(file, color):</span>
<span class="gi">+        message = strip_ansi(message)</span>
<span class="gi">+</span>
<span class="gi">+    if nl:</span>
<span class="gi">+        message = message + &#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+    file.write(message)</span>
<span class="gi">+    file.flush()</span>


<span class="w"> </span>def get_binary_stream(name: &quot;te.Literal[&#39;stdin&#39;, &#39;stdout&#39;, &#39;stderr&#39;]&quot;
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>