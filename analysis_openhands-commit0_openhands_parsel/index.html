
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands parsel - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-parsel" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands parsel
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_boolean_result" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_boolean_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_deep_nesting" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_deep_nesting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_differences_parsing_xml_vs_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_differences_parsing_xml_vs_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_etree_root_invalid_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_etree_root_invalid_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_http_header_encoding_precedence" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_http_header_encoding_precedence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_invalid_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_invalid_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_invalid_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_invalid_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_invalid_xpath_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_invalid_xpath_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_json_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_json_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_json_root" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_json_root
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_json_selector_representation" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_json_selector_representation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_json_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_json_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_mixed_nested_selectors" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_mixed_nested_selectors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_namespaces_adhoc" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_namespaces_adhoc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_namespaces_adhoc_variables" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_namespaces_adhoc_variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_namespaces_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_namespaces_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_namespaces_multiple_adhoc" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_namespaces_multiple_adhoc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_namespaces_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_namespaces_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_re_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_re_first
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_re_intl" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_re_intl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_re_replace_entities" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_re_replace_entities
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_remove_namespaces" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_remove_namespaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_remove_namespaces_embedded" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_remove_namespaces_embedded
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_remove_pseudo_element_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_remove_pseudo_element_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_remove_pseudo_element_selector_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_remove_pseudo_element_selector_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_remove_root_element_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_remove_root_element_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_remove_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_remove_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_replacement_null_char_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_replacement_null_char_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_representation_unicode_query" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_representation_unicode_query
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_select_unicode_query" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_select_unicode_query
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_simple_selection_with_variables" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_simple_selection_with_variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_simple_selection_with_variables_escape_friendly" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_simple_selection_with_variables_escape_friendly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_boolean_result" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_boolean_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_deep_nesting" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_deep_nesting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_differences_parsing_xml_vs_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_differences_parsing_xml_vs_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_etree_root_invalid_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_etree_root_invalid_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_http_header_encoding_precedence" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_http_header_encoding_precedence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_invalid_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_invalid_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_invalid_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_invalid_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_invalid_xpath_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_invalid_xpath_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_json_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_json_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_json_root" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_json_root
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_json_selector_representation" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_json_selector_representation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_json_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_json_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_mixed_nested_selectors" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_mixed_nested_selectors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_namespaces_adhoc" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_namespaces_adhoc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_namespaces_adhoc_variables" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_namespaces_adhoc_variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_namespaces_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_namespaces_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_namespaces_multiple_adhoc" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_namespaces_multiple_adhoc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_namespaces_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_namespaces_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_re_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_re_first
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_re_intl" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_re_intl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_re_replace_entities" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_re_replace_entities
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_remove_namespaces" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_remove_namespaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_remove_namespaces_embedded" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_remove_namespaces_embedded
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_remove_pseudo_element_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_remove_pseudo_element_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_remove_pseudo_element_selector_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_remove_pseudo_element_selector_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_remove_root_element_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_remove_root_element_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_remove_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_remove_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_replacement_null_char_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_replacement_null_char_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_select_unicode_query" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_select_unicode_query
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_simple_selection_with_variables" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_simple_selection_with_variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasebytestest_simple_selection_with_variables_escape_friendly" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCaseBytes::test_simple_selection_with_variables_escape_friendly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpyhtmltranslatortesttest_attr_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::HTMLTranslatorTest::test_attr_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpyhtmltranslatortesttest_attr_function_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::HTMLTranslatorTest::test_attr_function_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpyhtmltranslatortesttest_text_pseudo_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::HTMLTranslatorTest::test_text_pseudo_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpyhtmltranslatortesttest_unknown_pseudo_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::HTMLTranslatorTest::test_unknown_pseudo_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpygenerictranslatortesttest_attr_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::GenericTranslatorTest::test_attr_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpygenerictranslatortesttest_attr_function_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::GenericTranslatorTest::test_attr_function_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpygenerictranslatortesttest_text_pseudo_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::GenericTranslatorTest::test_text_pseudo_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpygenerictranslatortesttest_unknown_pseudo_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::GenericTranslatorTest::test_unknown_pseudo_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortesttest_attribute_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTest::test_attribute_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortesttest_nested_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTest::test_nested_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortesttest_pseudoclass_has" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTest::test_pseudoclass_has
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortesttest_text_pseudo_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTest::test_text_pseudo_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortestbytestest_attribute_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTestBytes::test_attribute_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortestbytestest_nested_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTestBytes::test_nested_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortestbytestest_pseudoclass_has" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTestBytes::test_pseudoclass_has
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_csstranslatorpycssselectortestbytestest_text_pseudo_element" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_csstranslator.py::CSSSelectorTestBytes::test_text_pseudo_element
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_jmespathpyjmespathtestcasetest_html_has_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_jmespath.py::JMESPathTestCase::test_html_has_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_jmespathpyjmespathtestcasetest_jmestpath_with_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_jmespath.py::JMESPathTestCase::test_jmestpath_with_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_jmespathpyjmespathtestcasetest_json_has_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_jmespath.py::JMESPathTestCase::test_json_has_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selector_jmespathpyjmespathtestcasetest_json_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector_jmespath.py::JMESPathTestCase::test_json_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_shorten0-" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_shorten[0-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_shorten1-" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_shorten[1-.]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_shorten2-" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_shorten[2-..]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_shorten3-" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_shorten[3-...]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_extract_regexpwspdsspd-october-25-2019-true-expected0" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_extract_regex[(?P\w+)\s(?P\d+)\s\,?\s*(?P\d+)-October 25, 2019-True-expected0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_extract_regexpwspdsspd-october-25-2019-true-expected1" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_extract_regex[(?P\w+)\s(?P\d+)\s\,?\s*(?P\d+)-October 25 2019-True-expected1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_extract_regexpwspdsspd-october-25-2019-true-expected2" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_extract_regex[(?P\w+)\s(?P\d+)\s\,?\s*(?P\d+)-October 25 2019-True-expected2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_extract_regexwsdssd-october-25-2019-true-expected3" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_extract_regex[\w+\s\d+\s\,?\s*\d+-October 25 2019-True-expected3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_extract_regex-sometext-moretext-true-expected4" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_extract_regex[^.*$-&quot;sometext&quot; &amp; &quot;moretext&quot;-True-expected4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_xml_attackspyxmlattacktestcasetest_billion_laughs" class="md-nav__link">
    <span class="md-ellipsis">
      test_xml_attacks.py::XMLAttackTestCase::test_billion_laughs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_xpathfuncspyxpathfuncstestcasetest_has_class_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_xpathfuncs.py::XPathFuncsTestCase::test_has_class_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_xpathfuncspyxpathfuncstestcasetest_set_xpathfunc" class="md-nav__link">
    <span class="md-ellipsis">
      test_xpathfuncs.py::XPathFuncsTestCase::test_set_xpathfunc
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-parsel"><strong>OpenHands</strong>: parsel</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">109</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">97</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">208</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">208</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_selectorpyselectortestcasetest_boolean_result">test_selector.py::SelectorTestCase::test_boolean_result</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_boolean_result</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_boolean_result>

    def test_boolean_result(self) -> None:
        body = "<p><input name='a'value='1'/><input name='b'value='2'/></p>"
        xs = self.sscls(text=body)
>       self.assertEqual(xs.xpath("//input[@name='a']/@name='a'").extract(), ["1"])
E       AssertionError: Lists differ: ['True'] != ['1']
E       
E       First differing element 0:
E       'True'
E       '1'
E       
E       - ['True']
E       + ['1']

tests/test_selector.py:369: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_deep_nesting">test_selector.py::SelectorTestCase::test_deep_nesting</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_deep_nesting</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_deep_nesting>

    def test_deep_nesting(self) -> None:
        lxml_version = Version(etree.__version__)
        lxml_huge_tree_version = Version("4.2")

        content = """
        <html>
        <body>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span>
        hello world
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span>
        <table>
         <tr><td>some test</td></tr>
        </table>
        </body>
        </html>
        """

        # If lxml doesn't support huge trees expect wrong results and a warning
        if lxml_version < lxml_huge_tree_version:
            with warnings.catch_warnings(record=True) as w:
                sel = Selector(text=content)
                self.assertIn("huge_tree", str(w[0].message))
                self.assertLessEqual(len(sel.css("span")), 256)
                self.assertEqual(len(sel.css("td")), 0)
            return

        # Same goes for explicitly disabling huge trees
        with warnings.catch_warnings(record=True) as w:
            sel = Selector(text=content, huge_tree=False)
>           self.assertIn("huge_tree", str(w[0].message))
E           IndexError: list index out of range

tests/test_selector.py:1113: IndexError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_differences_parsing_xml_vs_html">test_selector.py::SelectorTestCase::test_differences_parsing_xml_vs_html</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_differences_parsing_xml_vs_html</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_differences_parsing_xml_vs_html>

    def test_differences_parsing_xml_vs_html(self) -> None:
        """Test that XML and HTML Selector's behave differently"""
        # some text which is parsed differently by XML and HTML flavors
        text = '<div><img src="a.jpg"><p>Hello</div>'
        hs = self.sscls(text=text, type="html")
>       self.assertEqual(
            hs.xpath("//div").extract(),
            ['<div><img src="a.jpg"><p>Hello</p></div>'],
        )
E       AssertionError: Lists differ: ['<div><img src="a.jpg"/><p>Hello</p></div>'] != ['<div><img src="a.jpg"><p>Hello</p></div>']
E       
E       First differing element 0:
E       '<div><img src="a.jpg"/><p>Hello</p></div>'
E       '<div><img src="a.jpg"><p>Hello</p></div>'
E       
E       - ['<div><img src="a.jpg"/><p>Hello</p></div>']
E       ?                        -
E       
E       + ['<div><img src="a.jpg"><p>Hello</p></div>']

tests/test_selector.py:377: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_etree_root_invalid_type">test_selector.py::SelectorTestCase::test_etree_root_invalid_type</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_etree_root_invalid_type</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_etree_root_invalid_type>

    def test_etree_root_invalid_type(self) -> None:
        selector = Selector("<html></html>")
>       self.assertRaisesRegex(
            ValueError,
            "object as root",
            Selector,
            root=selector.root,
            type="text",
        )
E       AssertionError: ValueError not raised by Selector

tests/test_selector.py:1175: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_http_header_encoding_precedence">test_selector.py::SelectorTestCase::test_http_header_encoding_precedence</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_http_header_encoding_precedence</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_http_header_encoding_precedence>

    def test_http_header_encoding_precedence(self) -> None:
        # '\xa3'     = pound symbol in unicode
        # '\xc2\xa3' = pound symbol in utf-8
        # '\xa3'     = pound symbol in latin-1 (iso-8859-1)

        text = """<html>
        <head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head>
        <body><span id="blank">\xa3</span></body></html>"""
        x = self.sscls(text=text)
>       self.assertEqual(x.xpath("//span[@id='blank']/text()").extract(), ["\xa3"])
E       AssertionError: Lists differ: ['Â£'] != ['£']
E       
E       First differing element 0:
E       'Â£'
E       '£'
E       
E       - ['Â£']
E       ?   -
E       
E       + ['£']

tests/test_selector.py:790: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_invalid_json">test_selector.py::SelectorTestCase::test_invalid_json</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_invalid_json</pre></summary><pre>
text = '<html/>', input_type = 'json', base_url = None, huge_tree = True

    def _get_root_and_type_from_text(text: str, input_type: Optional[str]=None, base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE) -> Tuple[Any, str]:
        """Get root node and type from text input."""
        if input_type == 'json':
            try:
>               return json.loads(text), 'json'

parsel/selector.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7edc5e720e60>, s = '<html/>'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_selector.SelectorTestCase testMethod=test_invalid_json>

    def test_invalid_json(self) -> None:
        text = "<html/>"
>       selector = self.sscls(text, type="json")

tests/test_selector.py:1164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:281: in __init__
    root, type = _get_root_and_type_from_text(text, input_type=type, base_url=base_url, huge_tree=huge_tree)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = '<html/>', input_type = 'json', base_url = None, huge_tree = True

    def _get_root_and_type_from_text(text: str, input_type: Optional[str]=None, base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE) -> Tuple[Any, str]:
        """Get root node and type from text input."""
        if input_type == 'json':
            try:
                return json.loads(text), 'json'
            except json.JSONDecodeError as e:
>               raise ValueError(f"Invalid JSON: {str(e)}")
E               ValueError: Invalid JSON: Expecting value: line 1 column 1 (char 0)

parsel/selector.py:61: ValueError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_invalid_xpath">test_selector.py::SelectorTestCase::test_invalid_xpath</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_invalid_xpath</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_invalid_xpath>

    def test_invalid_xpath(self) -> None:
        "Test invalid xpath raises ValueError with the invalid xpath"
        x = self.sscls(text="<html></html>")
        xpath = "//test[@foo='bar]"
>       self.assertRaisesRegex(ValueError, re.escape(xpath), x.xpath, xpath)

tests/test_selector.py:773: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Unfinished literal

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_invalid_xpath_unicode">test_selector.py::SelectorTestCase::test_invalid_xpath_unicode</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_invalid_xpath_unicode</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_invalid_xpath_unicode>

    def test_invalid_xpath_unicode(self) -> None:
        "Test *Unicode* invalid xpath raises ValueError with the invalid xpath"
        x = self.sscls(text="<html></html>")
        xpath = "//test[@foo='\\u0431ar]"
>       self.assertRaisesRegex(ValueError, re.escape(xpath), x.xpath, xpath)

tests/test_selector.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Unfinished literal

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_json_css">test_selector.py::SelectorTestCase::test_json_css</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_json_css</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_json_css>

    def test_json_css(self) -> None:
        obj = 1
        selector = self.sscls(root=obj)
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_selector.py:1159: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_json_root">test_selector.py::SelectorTestCase::test_json_root</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_json_root</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_json_root>

    def test_json_root(self) -> None:
        obj = 1
        selector = self.sscls(root=obj)
        self.assertEqual(selector.root, obj)
>       self.assertEqual(selector.type, "json")
E       AssertionError: 'html' != 'json'
E       - html
E       + json

tests/test_selector.py:1148: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_json_selector_representation">test_selector.py::SelectorTestCase::test_json_selector_representation</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_json_selector_representation</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_json_selector_representation>

    def test_json_selector_representation(self) -> None:
        selector = Selector(text="true")
>       assert repr(selector) == "<Selector query=None data='True'>"
E       AssertionError

tests/test_selector.py:1192: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_json_xpath">test_selector.py::SelectorTestCase::test_json_xpath</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_json_xpath</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_json_xpath>

    def test_json_xpath(self) -> None:
        obj = 1
        selector = self.sscls(root=obj)
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_selector.py:1153: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_mixed_nested_selectors">test_selector.py::SelectorTestCase::test_mixed_nested_selectors</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_mixed_nested_selectors</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_mixed_nested_selectors>

    def test_mixed_nested_selectors(self) -> None:
        body = """<body>
                    <div id=1>not<span>me</span></div>
                    <div class="dos"><p>text</p><a href='#'>foo</a></div>
               </body>"""
        sel = self.sscls(text=body)
        self.assertEqual(
>           sel.xpath('//div[@id="1"]').css("span::text").extract(), ["me"]
        )

tests/test_selector.py:498: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:163: in css
    return self.__class__(flatten([x.css(query) for x in self]))
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.GenericTranslator object at 0x7edc5e0205c0>
xpath = XPathExpr[span], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:81: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_namespaces_adhoc">test_selector.py::SelectorTestCase::test_namespaces_adhoc</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_namespaces_adhoc</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_namespaces_adhoc>

    def test_namespaces_adhoc(self) -> None:
        body = """
        <test xmlns:somens="http://scrapy.org">
           <somens:a id="foo">take this</a>
           <a id="bar">found</a>
        </test>
        """

>       x = self.sscls(text=body, type="xml")

tests/test_selector.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:281: in __init__
    root, type = _get_root_and_type_from_text(text, input_type=type, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:66: in _get_root_and_type_from_text
    root = create_root_node(text, parser_cls, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:92: in create_root_node
    root = etree.fromstring(text.encode(encoding), parser=parser, base_url=base_url)
src/lxml/etree.pyx:3306: in lxml.etree.fromstring
    ???
src/lxml/parser.pxi:1995: in lxml.etree._parseMemoryDocument
    ???
src/lxml/parser.pxi:1882: in lxml.etree._parseDoc
    ???
src/lxml/parser.pxi:1164: in lxml.etree._BaseParser._parseDoc
    ???
src/lxml/parser.pxi:633: in lxml.etree._ParserContext._handleParseResultDoc
    ???
src/lxml/parser.pxi:743: in lxml.etree._handleParseResult
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E     File "<string>", line 3
E   lxml.etree.XMLSyntaxError: Opening and ending tag mismatch: a line 3 and a, line 3, column 44

src/lxml/parser.pxi:672: XMLSyntaxError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_namespaces_adhoc_variables">test_selector.py::SelectorTestCase::test_namespaces_adhoc_variables</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_namespaces_adhoc_variables</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_namespaces_adhoc_variables>

    def test_namespaces_adhoc_variables(self) -> None:
        body = """
        <test xmlns:somens="http://scrapy.org">
           <somens:a id="foo">take this</a>
           <a id="bar">found</a>
        </test>
        """

>       x = self.sscls(text=body, type="xml")

tests/test_selector.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:281: in __init__
    root, type = _get_root_and_type_from_text(text, input_type=type, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:66: in _get_root_and_type_from_text
    root = create_root_node(text, parser_cls, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:92: in create_root_node
    root = etree.fromstring(text.encode(encoding), parser=parser, base_url=base_url)
src/lxml/etree.pyx:3306: in lxml.etree.fromstring
    ???
src/lxml/parser.pxi:1995: in lxml.etree._parseMemoryDocument
    ???
src/lxml/parser.pxi:1882: in lxml.etree._parseDoc
    ???
src/lxml/parser.pxi:1164: in lxml.etree._BaseParser._parseDoc
    ???
src/lxml/parser.pxi:633: in lxml.etree._ParserContext._handleParseResultDoc
    ???
src/lxml/parser.pxi:743: in lxml.etree._handleParseResult
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E     File "<string>", line 3
E   lxml.etree.XMLSyntaxError: Opening and ending tag mismatch: a line 3 and a, line 3, column 44

src/lxml/parser.pxi:672: XMLSyntaxError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_namespaces_multiple">test_selector.py::SelectorTestCase::test_namespaces_multiple</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_namespaces_multiple</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_namespaces_multiple>

        def test_namespaces_multiple(self) -> None:
            body = """<?xml version="1.0" encoding="UTF-8"?>
    <BrowseNode xmlns="http://webservices.amazon.com/AWSECommerceService/2005-10-05"
                xmlns:b="http://somens.com"
                xmlns:p="http://www.scrapy.org/product" >
        <b:Operation>hello</b:Operation>
        <TestTag b:att="value"><Other>value</Other></TestTag>
        <p:SecondTestTag><material>iron</material><price>90</price><p:name>Dried Rose</p:name></p:SecondTestTag>
    </BrowseNode>
            """
            x = self.sscls(text=body, type="xml")
            x.register_namespace(
                "xmlns",
                "http://webservices.amazon.com/AWSECommerceService/2005-10-05",
            )
            x.register_namespace("p", "http://www.scrapy.org/product")
            x.register_namespace("b", "http://somens.com")
            self.assertEqual(len(x.xpath("//xmlns:TestTag")), 1)
            self.assertEqual(x.xpath("//b:Operation/text()").extract()[0], "hello")
            self.assertEqual(x.xpath("//xmlns:TestTag/@b:att").extract()[0], "value")
            self.assertEqual(
                x.xpath("//p:SecondTestTag/xmlns:price/text()").extract()[0], "90"
            )
            self.assertEqual(
>               x.xpath("//p:SecondTestTag").xpath("./xmlns:price/text()")[0].extract(),
                "90",
            )

tests/test_selector.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:154: in xpath
    return self.__class__(flatten([x.xpath(xpath, namespaces=namespaces, **kwargs) for x in self]))
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Undefined namespace prefix

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_namespaces_multiple_adhoc">test_selector.py::SelectorTestCase::test_namespaces_multiple_adhoc</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_namespaces_multiple_adhoc</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_namespaces_multiple_adhoc>

        def test_namespaces_multiple_adhoc(self) -> None:
            body = """<?xml version="1.0" encoding="UTF-8"?>
    <BrowseNode xmlns="http://webservices.amazon.com/AWSECommerceService/2005-10-05"
                xmlns:b="http://somens.com"
                xmlns:p="http://www.scrapy.org/product" >
        <b:Operation>hello</b:Operation>
        <TestTag b:att="value"><Other>value</Other></TestTag>
        <p:SecondTestTag><material>iron</material><price>90</price><p:name>Dried Rose</p:name></p:SecondTestTag>
    </BrowseNode>
            """
            x = self.sscls(text=body, type="xml")
            x.register_namespace(
                "xmlns",
                "http://webservices.amazon.com/AWSECommerceService/2005-10-05",
            )
            self.assertEqual(len(x.xpath("//xmlns:TestTag")), 1)

            # "b" namespace is not declared yet
>           self.assertRaises(ValueError, x.xpath, "//xmlns:TestTag/@b:att")

tests/test_selector.py:606: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Undefined namespace prefix

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_namespaces_simple">test_selector.py::SelectorTestCase::test_namespaces_simple</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_namespaces_simple</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_namespaces_simple>

    def test_namespaces_simple(self) -> None:
        body = """
        <test xmlns:somens="http://scrapy.org">
           <somens:a id="foo">take this</a>
           <a id="bar">found</a>
        </test>
        """

>       x = self.sscls(text=body, type="xml")

tests/test_selector.py:514: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:281: in __init__
    root, type = _get_root_and_type_from_text(text, input_type=type, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:66: in _get_root_and_type_from_text
    root = create_root_node(text, parser_cls, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:92: in create_root_node
    root = etree.fromstring(text.encode(encoding), parser=parser, base_url=base_url)
src/lxml/etree.pyx:3306: in lxml.etree.fromstring
    ???
src/lxml/parser.pxi:1995: in lxml.etree._parseMemoryDocument
    ???
src/lxml/parser.pxi:1882: in lxml.etree._parseDoc
    ???
src/lxml/parser.pxi:1164: in lxml.etree._BaseParser._parseDoc
    ???
src/lxml/parser.pxi:633: in lxml.etree._ParserContext._handleParseResultDoc
    ???
src/lxml/parser.pxi:743: in lxml.etree._handleParseResult
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E     File "<string>", line 3
E   lxml.etree.XMLSyntaxError: Opening and ending tag mismatch: a line 3 and a, line 3, column 44

src/lxml/parser.pxi:672: XMLSyntaxError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_re">test_selector.py::SelectorTestCase::test_re</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_re</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_re>

    def test_re(self) -> None:
        body = """<div>Name: Mary
                    <ul>
                      <li>Name: John</li>
                      <li>Age: 10</li>
                      <li>Name: Paul</li>
                      <li>Age: 20</li>
                    </ul>
                    Age: 20
                  </div>"""
        x = self.sscls(text=body)

        name_re = re.compile(r"Name: (\w+)")
>       self.assertEqual(x.xpath("//ul/li").re(name_re), ["John", "Paul"])

tests/test_selector.py:707: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:175: in re
    return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = re.compile('Name: (\\w+)'), text = '<li>Name: John</li>'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_re_first">test_selector.py::SelectorTestCase::test_re_first</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_re_first</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_re_first>

    def test_re_first(self) -> None:
        """Test if re_first() returns first matched element"""
        body = '<ul><li id="1">1</li><li id="2">2</li></ul>'
        sel = self.sscls(text=body)

        self.assertEqual(
>           sel.xpath("//ul/li/text()").re_first(r"\d"),
            sel.xpath("//ul/li/text()").re(r"\d")[0],
        )

tests/test_selector.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:189: in re_first
    for el in iflatten(x.re(regex, replace_entities=replace_entities) for x in self):
parsel/utils.py:25: in iflatten
    for el in x:
parsel/selector.py:189: in <genexpr>
    for el in iflatten(x.re(regex, replace_entities=replace_entities) for x in self):
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '\\d', text = '1', replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_re_intl">test_selector.py::SelectorTestCase::test_re_intl</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_re_intl</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_re_intl>

    def test_re_intl(self) -> None:
        body = "<div>Evento: cumplea\xf1os</div>"
        x = self.sscls(text=body)
>       self.assertEqual(x.xpath("//div").re(r"Evento: (\w+)"), ["cumplea\xf1os"])

tests/test_selector.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:175: in re
    return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = 'Evento: (\\w+)', text = '<div>Evento: cumpleaÃ±os</div>'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_re_replace_entities">test_selector.py::SelectorTestCase::test_re_replace_entities</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_re_replace_entities</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_re_replace_entities>

    def test_re_replace_entities(self) -> None:
        body = """<script>{"foo":"bar &amp; &quot;baz&quot;"}</script>"""
        x = self.sscls(text=body)

        name_re = re.compile('{"foo":(.*)}')

        # by default, only &amp; and &lt; are preserved ;
        # other entities are converted
        expected = '"bar &amp; "baz""'
>       self.assertEqual(x.xpath("//script/text()").re(name_re), [expected])

tests/test_selector.py:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:175: in re
    return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = re.compile('{"foo":(.*)}'), text = '{"foo":"bar &amp; &quot;baz&quot;"}'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_remove_namespaces">test_selector.py::SelectorTestCase::test_remove_namespaces</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_remove_namespaces</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_remove_namespaces>

        def test_remove_namespaces(self) -> None:
            xml = """<?xml version="1.0" encoding="UTF-8"?>
    <feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US" xmlns:media="http://search.yahoo.com/mrss/">
      <link type="text/html"/>
      <entry>
        <link type="text/html"/>
      </entry>
      <link type="application/atom+xml"/>
    </feed>
    """
            sel = self.sscls(text=xml, type="xml")
            self.assertEqual(len(sel.xpath("//link")), 0)
            self.assertEqual(len(sel.xpath("./namespace::*")), 3)
            sel.remove_namespaces()
            self.assertEqual(len(sel.xpath("//link")), 3)
>           self.assertEqual(len(sel.xpath("./namespace::*")), 1)
E           AssertionError: 3 != 1

tests/test_selector.py:864: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_remove_namespaces_embedded">test_selector.py::SelectorTestCase::test_remove_namespaces_embedded</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_remove_namespaces_embedded</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_remove_namespaces_embedded>

    def test_remove_namespaces_embedded(self) -> None:
        xml = """
        <feed xmlns="http://www.w3.org/2005/Atom">
          <link type="text/html"/>
          <entry>
            <link type="text/html"/>
          </entry>
          <svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100">
            <linearGradient id="gradient">
              <stop class="begin" offset="0%" style="stop-color:yellow;"/>
              <stop class="end" offset="80%" style="stop-color:green;"/>
            </linearGradient>
            <circle cx="50" cy="50" r="30" style="fill:url(#gradient)" />
          </svg>
        </feed>
        """
        sel = self.sscls(text=xml, type="xml")
        self.assertEqual(len(sel.xpath("//link")), 0)
        self.assertEqual(len(sel.xpath("//stop")), 0)
        self.assertEqual(len(sel.xpath("./namespace::*")), 2)
        self.assertEqual(
            len(
                sel.xpath(
                    "//f:link",
                    namespaces={"f": "http://www.w3.org/2005/Atom"},
                )
            ),
            2,
        )
        self.assertEqual(
            len(sel.xpath("//s:stop", namespaces={"s": "http://www.w3.org/2000/svg"})),
            2,
        )
        sel.remove_namespaces()
        self.assertEqual(len(sel.xpath("//link")), 2)
        self.assertEqual(len(sel.xpath("//stop")), 2)
>       self.assertEqual(len(sel.xpath("./namespace::*")), 1)
E       AssertionError: 2 != 1

tests/test_selector.py:902: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_remove_pseudo_element_selector">test_selector.py::SelectorTestCase::test_remove_pseudo_element_selector</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_remove_pseudo_element_selector</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_remove_pseudo_element_selector>

    def test_remove_pseudo_element_selector(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
>       sel_list = sel.css("li::text")

tests/test_selector.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_remove_pseudo_element_selector_list">test_selector.py::SelectorTestCase::test_remove_pseudo_element_selector_list</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_remove_pseudo_element_selector_list</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_remove_pseudo_element_selector_list>

    def test_remove_pseudo_element_selector_list(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
>       sel_list = sel.css("li::text")

tests/test_selector.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_remove_root_element_selector">test_selector.py::SelectorTestCase::test_remove_root_element_selector</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_remove_root_element_selector</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_remove_root_element_selector>

    def test_remove_root_element_selector(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
>       sel_list = sel.css("li::text")

tests/test_selector.py:1038: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_remove_selector">test_selector.py::SelectorTestCase::test_remove_selector</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_remove_selector</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_remove_selector>

    def test_remove_selector(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
        sel_list = sel.css("li")
        sel_list[0].drop()
        self.assertIsSelectorList(sel.css("li"))
>       self.assertEqual(sel.css("li::text").getall(), ["2", "3"])

tests/test_selector.py:1008: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_replacement_null_char_from_body">test_selector.py::SelectorTestCase::test_replacement_null_char_from_body</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_replacement_null_char_from_body</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_replacement_null_char_from_body>

    def test_replacement_null_char_from_body(self) -> None:
        text = "<html>\x00<body><p>Grainy</p></body></html>"
>       self.assertEqual(
            "<html><body><p>Grainy</p></body></html>",
            self.sscls(text).extract(),
        )
E       AssertionError: '<html><body><p>Grainy</p></body></html>' != '<html></html>'
E       - <html><body><p>Grainy</p></body></html>
E       + <html></html>

tests/test_selector.py:987: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_representation_unicode_query">test_selector.py::SelectorTestCase::test_representation_unicode_query</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_representation_unicode_query</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_representation_unicode_query>

    def test_representation_unicode_query(self) -> None:
        body = f"<p><input name='{50 * 'b'}' value='\xa9'/></p>"

        representation = "<Selector query='//input[@value=\"©\"]/@value' data='©'>"

        sel = self.sscls(text=body)
>       self.assertEqual(
            [repr(it) for it in sel.xpath('//input[@value="\xa9"]/@value')],
            [representation],
        )
E       AssertionError: Lists differ: [] != ['<Selector query=\'//input[@value="©"]/@value\' data=\'©\'>']
E       
E       Second list contains 1 additional elements.
E       First extra element 0:
E       '<Selector query=\'//input[@value="©"]/@value\' data=\'©\'>'
E       
E       - []
E       + ['<Selector query=\'//input[@value="©"]/@value\' data=\'©\'>']

tests/test_selector.py:226: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_select_unicode_query">test_selector.py::SelectorTestCase::test_select_unicode_query</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_select_unicode_query</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_select_unicode_query>

    def test_select_unicode_query(self) -> None:
        body = "<p><input name='\xa9' value='1'/></p>"
        sel = self.sscls(text=body)
>       self.assertEqual(sel.xpath('//input[@name="\xa9"]/@value').extract(), ["1"])
E       AssertionError: Lists differ: [] != ['1']
E       
E       Second list contains 1 additional elements.
E       First extra element 0:
E       '1'
E       
E       - []
E       + ['1']

tests/test_selector.py:352: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_simple_selection_with_variables">test_selector.py::SelectorTestCase::test_simple_selection_with_variables</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_simple_selection_with_variables</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_simple_selection_with_variables>

    def test_simple_selection_with_variables(self) -> None:
        """Using XPath variables"""
        body = "<p><input name='a' value='1'/><input name='b' value='2'/></p>"
        sel = self.sscls(text=body)

        self.assertEqual(
            [x.extract() for x in sel.xpath("//input[@value=$number]/@name", number=1)],
            ["a"],
        )
        self.assertEqual(
            [
                x.extract()
                for x in sel.xpath("//input[@name=$letter]/@value", letter="b")
            ],
            ["2"],
        )

        self.assertEqual(
            sel.xpath(
                "count(//input[@value=$number or @name=$letter])",
                number=2,
                letter="a",
            ).extract(),
            ["2.0"],
        )

        # you can also pass booleans
>       self.assertEqual(
            sel.xpath("boolean(count(//input)=$cnt)=$test", cnt=2, test=True).extract(),
            ["1"],
        )
E       AssertionError: Lists differ: ['True'] != ['1']
E       
E       First differing element 0:
E       'True'
E       '1'
E       
E       - ['True']
E       + ['1']

tests/test_selector.py:118: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_simple_selection_with_variables_escape_friendly">test_selector.py::SelectorTestCase::test_simple_selection_with_variables_escape_friendly</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_simple_selection_with_variables_escape_friendly</pre></summary><pre>
self = <test_selector.SelectorTestCase testMethod=test_simple_selection_with_variables_escape_friendly>

    def test_simple_selection_with_variables_escape_friendly(self) -> None:
        """Using XPath variables with quotes that would need escaping with string formatting"""
        body = """<p>I'm mixing single and <input name='a' value='I say "Yeah!"'/>
        "double quotes" and I don't care :)</p>"""
        sel = self.sscls(text=body)

        t = 'I say "Yeah!"'
        # naive string formatting with give something like:
        # ValueError: XPath error: Invalid predicate in //input[@value="I say "Yeah!""]/@name
>       self.assertRaises(ValueError, sel.xpath, f'//input[@value="{t}"]/@name')

tests/test_selector.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Invalid predicate

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_boolean_result">test_selector.py::SelectorTestCaseBytes::test_boolean_result</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_boolean_result</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_boolean_result>

    def test_boolean_result(self) -> None:
        body = "<p><input name='a'value='1'/><input name='b'value='2'/></p>"
        xs = self.sscls(text=body)
>       self.assertEqual(xs.xpath("//input[@name='a']/@name='a'").extract(), ["1"])
E       AssertionError: Lists differ: ['True'] != ['1']
E       
E       First differing element 0:
E       'True'
E       '1'
E       
E       - ['True']
E       + ['1']

tests/test_selector.py:369: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_deep_nesting">test_selector.py::SelectorTestCaseBytes::test_deep_nesting</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_deep_nesting</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_deep_nesting>

    def test_deep_nesting(self) -> None:
        lxml_version = Version(etree.__version__)
        lxml_huge_tree_version = Version("4.2")

        content = """
        <html>
        <body>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>
        <span><span><span><span><span><span><span><span><span><span><span><span>
        hello world
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
        </span></span></span></span></span></span></span></span></span></span>
        <table>
         <tr><td>some test</td></tr>
        </table>
        </body>
        </html>
        """

        # If lxml doesn't support huge trees expect wrong results and a warning
        if lxml_version < lxml_huge_tree_version:
            with warnings.catch_warnings(record=True) as w:
                sel = Selector(text=content)
                self.assertIn("huge_tree", str(w[0].message))
                self.assertLessEqual(len(sel.css("span")), 256)
                self.assertEqual(len(sel.css("td")), 0)
            return

        # Same goes for explicitly disabling huge trees
        with warnings.catch_warnings(record=True) as w:
            sel = Selector(text=content, huge_tree=False)
>           self.assertIn("huge_tree", str(w[0].message))
E           IndexError: list index out of range

tests/test_selector.py:1113: IndexError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_differences_parsing_xml_vs_html">test_selector.py::SelectorTestCaseBytes::test_differences_parsing_xml_vs_html</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_differences_parsing_xml_vs_html</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_differences_parsing_xml_vs_html>

    def test_differences_parsing_xml_vs_html(self) -> None:
        """Test that XML and HTML Selector's behave differently"""
        # some text which is parsed differently by XML and HTML flavors
        text = '<div><img src="a.jpg"><p>Hello</div>'
        hs = self.sscls(text=text, type="html")
>       self.assertEqual(
            hs.xpath("//div").extract(),
            ['<div><img src="a.jpg"><p>Hello</p></div>'],
        )
E       AssertionError: Lists differ: ['<div><img src="a.jpg"/><p>Hello</p></div>'] != ['<div><img src="a.jpg"><p>Hello</p></div>']
E       
E       First differing element 0:
E       '<div><img src="a.jpg"/><p>Hello</p></div>'
E       '<div><img src="a.jpg"><p>Hello</p></div>'
E       
E       - ['<div><img src="a.jpg"/><p>Hello</p></div>']
E       ?                        -
E       
E       + ['<div><img src="a.jpg"><p>Hello</p></div>']

tests/test_selector.py:377: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_etree_root_invalid_type">test_selector.py::SelectorTestCaseBytes::test_etree_root_invalid_type</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_etree_root_invalid_type</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_etree_root_invalid_type>

    def test_etree_root_invalid_type(self) -> None:
        selector = Selector("<html></html>")
>       self.assertRaisesRegex(
            ValueError,
            "object as root",
            Selector,
            root=selector.root,
            type="text",
        )
E       AssertionError: ValueError not raised by Selector

tests/test_selector.py:1175: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_http_header_encoding_precedence">test_selector.py::SelectorTestCaseBytes::test_http_header_encoding_precedence</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_http_header_encoding_precedence</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_http_header_encoding_precedence>

    def test_http_header_encoding_precedence(self) -> None:
        # '\xa3'     = pound symbol in unicode
        # '\xc2\xa3' = pound symbol in utf-8
        # '\xa3'     = pound symbol in latin-1 (iso-8859-1)

        text = """<html>
        <head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head>
        <body><span id="blank">\xa3</span></body></html>"""
        x = self.sscls(text=text)
>       self.assertEqual(x.xpath("//span[@id='blank']/text()").extract(), ["\xa3"])
E       AssertionError: Lists differ: ['Â£'] != ['£']
E       
E       First differing element 0:
E       'Â£'
E       '£'
E       
E       - ['Â£']
E       ?   -
E       
E       + ['£']

tests/test_selector.py:790: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_invalid_json">test_selector.py::SelectorTestCaseBytes::test_invalid_json</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_invalid_json</pre></summary><pre>
body = b'<html/>', encoding = 'utf8', input_type = 'json', base_url = None
huge_tree = True

    def _get_root_and_type_from_bytes(body: bytes, encoding: str='utf8', input_type: Optional[str]=None, base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE) -> Tuple[Any, str]:
        """Get root node and type from bytes input."""
        if input_type == 'json':
            try:
>               return json.loads(body.decode(encoding)), 'json'

parsel/selector.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7edc5e720e60>, s = '<html/>'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_selector.SelectorTestCaseBytes testMethod=test_invalid_json>

    def test_invalid_json(self) -> None:
        text = "<html/>"
>       selector = self.sscls(text, type="json")

tests/test_selector.py:1164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector.py:1359: in __init__
    super().__init__(
parsel/selector.py:288: in __init__
    root, type = _get_root_and_type_from_bytes(body=body, encoding=encoding, input_type=type, base_url=base_url, huge_tree=huge_tree)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

body = b'<html/>', encoding = 'utf8', input_type = 'json', base_url = None
huge_tree = True

    def _get_root_and_type_from_bytes(body: bytes, encoding: str='utf8', input_type: Optional[str]=None, base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE) -> Tuple[Any, str]:
        """Get root node and type from bytes input."""
        if input_type == 'json':
            try:
                return json.loads(body.decode(encoding)), 'json'
            except json.JSONDecodeError as e:
>               raise ValueError(f"Invalid JSON: {str(e)}")
E               ValueError: Invalid JSON: Expecting value: line 1 column 1 (char 0)

parsel/selector.py:75: ValueError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_invalid_xpath">test_selector.py::SelectorTestCaseBytes::test_invalid_xpath</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_invalid_xpath</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_invalid_xpath>

    def test_invalid_xpath(self) -> None:
        "Test invalid xpath raises ValueError with the invalid xpath"
        x = self.sscls(text="<html></html>")
        xpath = "//test[@foo='bar]"
>       self.assertRaisesRegex(ValueError, re.escape(xpath), x.xpath, xpath)

tests/test_selector.py:773: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Unfinished literal

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_invalid_xpath_unicode">test_selector.py::SelectorTestCaseBytes::test_invalid_xpath_unicode</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_invalid_xpath_unicode</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_invalid_xpath_unicode>

    def test_invalid_xpath_unicode(self) -> None:
        "Test *Unicode* invalid xpath raises ValueError with the invalid xpath"
        x = self.sscls(text="<html></html>")
        xpath = "//test[@foo='\\u0431ar]"
>       self.assertRaisesRegex(ValueError, re.escape(xpath), x.xpath, xpath)

tests/test_selector.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Unfinished literal

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_json_css">test_selector.py::SelectorTestCaseBytes::test_json_css</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_json_css</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_json_css>

    def test_json_css(self) -> None:
        obj = 1
        selector = self.sscls(root=obj)
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_selector.py:1159: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_json_root">test_selector.py::SelectorTestCaseBytes::test_json_root</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_json_root</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_json_root>

    def test_json_root(self) -> None:
        obj = 1
        selector = self.sscls(root=obj)
        self.assertEqual(selector.root, obj)
>       self.assertEqual(selector.type, "json")
E       AssertionError: 'html' != 'json'
E       - html
E       + json

tests/test_selector.py:1148: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_json_selector_representation">test_selector.py::SelectorTestCaseBytes::test_json_selector_representation</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_json_selector_representation</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_json_selector_representation>

    def test_json_selector_representation(self) -> None:
        selector = Selector(text="true")
>       assert repr(selector) == "<Selector query=None data='True'>"
E       AssertionError

tests/test_selector.py:1192: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_json_xpath">test_selector.py::SelectorTestCaseBytes::test_json_xpath</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_json_xpath</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_json_xpath>

    def test_json_xpath(self) -> None:
        obj = 1
        selector = self.sscls(root=obj)
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

tests/test_selector.py:1153: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_mixed_nested_selectors">test_selector.py::SelectorTestCaseBytes::test_mixed_nested_selectors</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_mixed_nested_selectors</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_mixed_nested_selectors>

    def test_mixed_nested_selectors(self) -> None:
        body = """<body>
                    <div id=1>not<span>me</span></div>
                    <div class="dos"><p>text</p><a href='#'>foo</a></div>
               </body>"""
        sel = self.sscls(text=body)
        self.assertEqual(
>           sel.xpath('//div[@id="1"]').css("span::text").extract(), ["me"]
        )

tests/test_selector.py:498: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:163: in css
    return self.__class__(flatten([x.css(query) for x in self]))
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.GenericTranslator object at 0x7edc5e0205c0>
xpath = XPathExpr[span], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:81: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_namespaces_adhoc">test_selector.py::SelectorTestCaseBytes::test_namespaces_adhoc</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_namespaces_adhoc</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_namespaces_adhoc>

    def test_namespaces_adhoc(self) -> None:
        body = """
        <test xmlns:somens="http://scrapy.org">
           <somens:a id="foo">take this</a>
           <a id="bar">found</a>
        </test>
        """

>       x = self.sscls(text=body, type="xml")

tests/test_selector.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector.py:1359: in __init__
    super().__init__(
parsel/selector.py:288: in __init__
    root, type = _get_root_and_type_from_bytes(body=body, encoding=encoding, input_type=type, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:80: in _get_root_and_type_from_bytes
    root = create_root_node('', parser_cls, base_url=base_url, huge_tree=huge_tree, body=body, encoding=encoding)
parsel/selector.py:90: in create_root_node
    root = etree.fromstring(body, parser=parser, base_url=base_url)
src/lxml/etree.pyx:3306: in lxml.etree.fromstring
    ???
src/lxml/parser.pxi:1995: in lxml.etree._parseMemoryDocument
    ???
src/lxml/parser.pxi:1882: in lxml.etree._parseDoc
    ???
src/lxml/parser.pxi:1164: in lxml.etree._BaseParser._parseDoc
    ???
src/lxml/parser.pxi:633: in lxml.etree._ParserContext._handleParseResultDoc
    ???
src/lxml/parser.pxi:743: in lxml.etree._handleParseResult
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E     File "<string>", line 3
E   lxml.etree.XMLSyntaxError: Opening and ending tag mismatch: a line 3 and a, line 3, column 44

src/lxml/parser.pxi:672: XMLSyntaxError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_namespaces_adhoc_variables">test_selector.py::SelectorTestCaseBytes::test_namespaces_adhoc_variables</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_namespaces_adhoc_variables</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_namespaces_adhoc_variables>

    def test_namespaces_adhoc_variables(self) -> None:
        body = """
        <test xmlns:somens="http://scrapy.org">
           <somens:a id="foo">take this</a>
           <a id="bar">found</a>
        </test>
        """

>       x = self.sscls(text=body, type="xml")

tests/test_selector.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector.py:1359: in __init__
    super().__init__(
parsel/selector.py:288: in __init__
    root, type = _get_root_and_type_from_bytes(body=body, encoding=encoding, input_type=type, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:80: in _get_root_and_type_from_bytes
    root = create_root_node('', parser_cls, base_url=base_url, huge_tree=huge_tree, body=body, encoding=encoding)
parsel/selector.py:90: in create_root_node
    root = etree.fromstring(body, parser=parser, base_url=base_url)
src/lxml/etree.pyx:3306: in lxml.etree.fromstring
    ???
src/lxml/parser.pxi:1995: in lxml.etree._parseMemoryDocument
    ???
src/lxml/parser.pxi:1882: in lxml.etree._parseDoc
    ???
src/lxml/parser.pxi:1164: in lxml.etree._BaseParser._parseDoc
    ???
src/lxml/parser.pxi:633: in lxml.etree._ParserContext._handleParseResultDoc
    ???
src/lxml/parser.pxi:743: in lxml.etree._handleParseResult
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E     File "<string>", line 3
E   lxml.etree.XMLSyntaxError: Opening and ending tag mismatch: a line 3 and a, line 3, column 44

src/lxml/parser.pxi:672: XMLSyntaxError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_namespaces_multiple">test_selector.py::SelectorTestCaseBytes::test_namespaces_multiple</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_namespaces_multiple</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_namespaces_multiple>

        def test_namespaces_multiple(self) -> None:
            body = """<?xml version="1.0" encoding="UTF-8"?>
    <BrowseNode xmlns="http://webservices.amazon.com/AWSECommerceService/2005-10-05"
                xmlns:b="http://somens.com"
                xmlns:p="http://www.scrapy.org/product" >
        <b:Operation>hello</b:Operation>
        <TestTag b:att="value"><Other>value</Other></TestTag>
        <p:SecondTestTag><material>iron</material><price>90</price><p:name>Dried Rose</p:name></p:SecondTestTag>
    </BrowseNode>
            """
            x = self.sscls(text=body, type="xml")
            x.register_namespace(
                "xmlns",
                "http://webservices.amazon.com/AWSECommerceService/2005-10-05",
            )
            x.register_namespace("p", "http://www.scrapy.org/product")
            x.register_namespace("b", "http://somens.com")
            self.assertEqual(len(x.xpath("//xmlns:TestTag")), 1)
            self.assertEqual(x.xpath("//b:Operation/text()").extract()[0], "hello")
            self.assertEqual(x.xpath("//xmlns:TestTag/@b:att").extract()[0], "value")
            self.assertEqual(
                x.xpath("//p:SecondTestTag/xmlns:price/text()").extract()[0], "90"
            )
            self.assertEqual(
>               x.xpath("//p:SecondTestTag").xpath("./xmlns:price/text()")[0].extract(),
                "90",
            )

tests/test_selector.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:154: in xpath
    return self.__class__(flatten([x.xpath(xpath, namespaces=namespaces, **kwargs) for x in self]))
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Undefined namespace prefix

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_namespaces_multiple_adhoc">test_selector.py::SelectorTestCaseBytes::test_namespaces_multiple_adhoc</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_namespaces_multiple_adhoc</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_namespaces_multiple_adhoc>

        def test_namespaces_multiple_adhoc(self) -> None:
            body = """<?xml version="1.0" encoding="UTF-8"?>
    <BrowseNode xmlns="http://webservices.amazon.com/AWSECommerceService/2005-10-05"
                xmlns:b="http://somens.com"
                xmlns:p="http://www.scrapy.org/product" >
        <b:Operation>hello</b:Operation>
        <TestTag b:att="value"><Other>value</Other></TestTag>
        <p:SecondTestTag><material>iron</material><price>90</price><p:name>Dried Rose</p:name></p:SecondTestTag>
    </BrowseNode>
            """
            x = self.sscls(text=body, type="xml")
            x.register_namespace(
                "xmlns",
                "http://webservices.amazon.com/AWSECommerceService/2005-10-05",
            )
            self.assertEqual(len(x.xpath("//xmlns:TestTag")), 1)

            # "b" namespace is not declared yet
>           self.assertRaises(ValueError, x.xpath, "//xmlns:TestTag/@b:att")

tests/test_selector.py:606: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Undefined namespace prefix

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_namespaces_simple">test_selector.py::SelectorTestCaseBytes::test_namespaces_simple</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_namespaces_simple</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_namespaces_simple>

    def test_namespaces_simple(self) -> None:
        body = """
        <test xmlns:somens="http://scrapy.org">
           <somens:a id="foo">take this</a>
           <a id="bar">found</a>
        </test>
        """

>       x = self.sscls(text=body, type="xml")

tests/test_selector.py:514: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector.py:1359: in __init__
    super().__init__(
parsel/selector.py:288: in __init__
    root, type = _get_root_and_type_from_bytes(body=body, encoding=encoding, input_type=type, base_url=base_url, huge_tree=huge_tree)
parsel/selector.py:80: in _get_root_and_type_from_bytes
    root = create_root_node('', parser_cls, base_url=base_url, huge_tree=huge_tree, body=body, encoding=encoding)
parsel/selector.py:90: in create_root_node
    root = etree.fromstring(body, parser=parser, base_url=base_url)
src/lxml/etree.pyx:3306: in lxml.etree.fromstring
    ???
src/lxml/parser.pxi:1995: in lxml.etree._parseMemoryDocument
    ???
src/lxml/parser.pxi:1882: in lxml.etree._parseDoc
    ???
src/lxml/parser.pxi:1164: in lxml.etree._BaseParser._parseDoc
    ???
src/lxml/parser.pxi:633: in lxml.etree._ParserContext._handleParseResultDoc
    ???
src/lxml/parser.pxi:743: in lxml.etree._handleParseResult
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E     File "<string>", line 3
E   lxml.etree.XMLSyntaxError: Opening and ending tag mismatch: a line 3 and a, line 3, column 44

src/lxml/parser.pxi:672: XMLSyntaxError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_re">test_selector.py::SelectorTestCaseBytes::test_re</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_re</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_re>

    def test_re(self) -> None:
        body = """<div>Name: Mary
                    <ul>
                      <li>Name: John</li>
                      <li>Age: 10</li>
                      <li>Name: Paul</li>
                      <li>Age: 20</li>
                    </ul>
                    Age: 20
                  </div>"""
        x = self.sscls(text=body)

        name_re = re.compile(r"Name: (\w+)")
>       self.assertEqual(x.xpath("//ul/li").re(name_re), ["John", "Paul"])

tests/test_selector.py:707: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:175: in re
    return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = re.compile('Name: (\\w+)'), text = '<li>Name: John</li>'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_re_first">test_selector.py::SelectorTestCaseBytes::test_re_first</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_re_first</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_re_first>

    def test_re_first(self) -> None:
        """Test if re_first() returns first matched element"""
        body = '<ul><li id="1">1</li><li id="2">2</li></ul>'
        sel = self.sscls(text=body)

        self.assertEqual(
>           sel.xpath("//ul/li/text()").re_first(r"\d"),
            sel.xpath("//ul/li/text()").re(r"\d")[0],
        )

tests/test_selector.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:189: in re_first
    for el in iflatten(x.re(regex, replace_entities=replace_entities) for x in self):
parsel/utils.py:25: in iflatten
    for el in x:
parsel/selector.py:189: in <genexpr>
    for el in iflatten(x.re(regex, replace_entities=replace_entities) for x in self):
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '\\d', text = '1', replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_re_intl">test_selector.py::SelectorTestCaseBytes::test_re_intl</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_re_intl</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_re_intl>

    def test_re_intl(self) -> None:
        body = "<div>Evento: cumplea\xf1os</div>"
        x = self.sscls(text=body)
>       self.assertEqual(x.xpath("//div").re(r"Evento: (\w+)"), ["cumplea\xf1os"])

tests/test_selector.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:175: in re
    return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = 'Evento: (\\w+)', text = '<div>Evento: cumpleaÃ±os</div>'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_re_replace_entities">test_selector.py::SelectorTestCaseBytes::test_re_replace_entities</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_re_replace_entities</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_re_replace_entities>

    def test_re_replace_entities(self) -> None:
        body = """<script>{"foo":"bar &amp; &quot;baz&quot;"}</script>"""
        x = self.sscls(text=body)

        name_re = re.compile('{"foo":(.*)}')

        # by default, only &amp; and &lt; are preserved ;
        # other entities are converted
        expected = '"bar &amp; "baz""'
>       self.assertEqual(x.xpath("//script/text()").re(name_re), [expected])

tests/test_selector.py:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:175: in re
    return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))
parsel/selector.py:391: in re
    return extract_regex(regex, self.get(), replace_entities=replace_entities)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = re.compile('{"foo":(.*)}'), text = '{"foo":"bar &amp; &quot;baz&quot;"}'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_remove_namespaces">test_selector.py::SelectorTestCaseBytes::test_remove_namespaces</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_remove_namespaces</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_remove_namespaces>

        def test_remove_namespaces(self) -> None:
            xml = """<?xml version="1.0" encoding="UTF-8"?>
    <feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US" xmlns:media="http://search.yahoo.com/mrss/">
      <link type="text/html"/>
      <entry>
        <link type="text/html"/>
      </entry>
      <link type="application/atom+xml"/>
    </feed>
    """
            sel = self.sscls(text=xml, type="xml")
            self.assertEqual(len(sel.xpath("//link")), 0)
            self.assertEqual(len(sel.xpath("./namespace::*")), 3)
            sel.remove_namespaces()
            self.assertEqual(len(sel.xpath("//link")), 3)
>           self.assertEqual(len(sel.xpath("./namespace::*")), 1)
E           AssertionError: 3 != 1

tests/test_selector.py:864: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_remove_namespaces_embedded">test_selector.py::SelectorTestCaseBytes::test_remove_namespaces_embedded</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_remove_namespaces_embedded</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_remove_namespaces_embedded>

    def test_remove_namespaces_embedded(self) -> None:
        xml = """
        <feed xmlns="http://www.w3.org/2005/Atom">
          <link type="text/html"/>
          <entry>
            <link type="text/html"/>
          </entry>
          <svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100">
            <linearGradient id="gradient">
              <stop class="begin" offset="0%" style="stop-color:yellow;"/>
              <stop class="end" offset="80%" style="stop-color:green;"/>
            </linearGradient>
            <circle cx="50" cy="50" r="30" style="fill:url(#gradient)" />
          </svg>
        </feed>
        """
        sel = self.sscls(text=xml, type="xml")
        self.assertEqual(len(sel.xpath("//link")), 0)
        self.assertEqual(len(sel.xpath("//stop")), 0)
        self.assertEqual(len(sel.xpath("./namespace::*")), 2)
        self.assertEqual(
            len(
                sel.xpath(
                    "//f:link",
                    namespaces={"f": "http://www.w3.org/2005/Atom"},
                )
            ),
            2,
        )
        self.assertEqual(
            len(sel.xpath("//s:stop", namespaces={"s": "http://www.w3.org/2000/svg"})),
            2,
        )
        sel.remove_namespaces()
        self.assertEqual(len(sel.xpath("//link")), 2)
        self.assertEqual(len(sel.xpath("//stop")), 2)
>       self.assertEqual(len(sel.xpath("./namespace::*")), 1)
E       AssertionError: 2 != 1

tests/test_selector.py:902: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_remove_pseudo_element_selector">test_selector.py::SelectorTestCaseBytes::test_remove_pseudo_element_selector</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_remove_pseudo_element_selector</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_remove_pseudo_element_selector>

    def test_remove_pseudo_element_selector(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
>       sel_list = sel.css("li::text")

tests/test_selector.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_remove_pseudo_element_selector_list">test_selector.py::SelectorTestCaseBytes::test_remove_pseudo_element_selector_list</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_remove_pseudo_element_selector_list</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_remove_pseudo_element_selector_list>

    def test_remove_pseudo_element_selector_list(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
>       sel_list = sel.css("li::text")

tests/test_selector.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_remove_root_element_selector">test_selector.py::SelectorTestCaseBytes::test_remove_root_element_selector</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_remove_root_element_selector</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_remove_root_element_selector>

    def test_remove_root_element_selector(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
>       sel_list = sel.css("li::text")

tests/test_selector.py:1038: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_remove_selector">test_selector.py::SelectorTestCaseBytes::test_remove_selector</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_remove_selector</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_remove_selector>

    def test_remove_selector(self) -> None:
        sel = self.sscls(
            text="<html><body><ul><li>1</li><li>2</li><li>3</li></ul></body></html>"
        )
        sel_list = sel.css("li")
        sel_list[0].drop()
        self.assertIsSelectorList(sel.css("li"))
>       self.assertEqual(sel.css("li::text").getall(), ["2", "3"])

tests/test_selector.py:1008: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[li], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_replacement_null_char_from_body">test_selector.py::SelectorTestCaseBytes::test_replacement_null_char_from_body</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_replacement_null_char_from_body</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_replacement_null_char_from_body>

    def test_replacement_null_char_from_body(self) -> None:
        text = "<html>\x00<body><p>Grainy</p></body></html>"
>       self.assertEqual(
            "<html><body><p>Grainy</p></body></html>",
            self.sscls(text).extract(),
        )
E       AssertionError: '<html><body><p>Grainy</p></body></html>' != '<html></html>'
E       - <html><body><p>Grainy</p></body></html>
E       + <html></html>

tests/test_selector.py:987: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_select_unicode_query">test_selector.py::SelectorTestCaseBytes::test_select_unicode_query</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_select_unicode_query</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_select_unicode_query>

    def test_select_unicode_query(self) -> None:
        body = "<p><input name='\xa9' value='1'/></p>"
        sel = self.sscls(text=body)
>       self.assertEqual(sel.xpath('//input[@name="\xa9"]/@value').extract(), ["1"])
E       AssertionError: Lists differ: [] != ['1']
E       
E       Second list contains 1 additional elements.
E       First extra element 0:
E       '1'
E       
E       - []
E       + ['1']

tests/test_selector.py:352: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_simple_selection_with_variables">test_selector.py::SelectorTestCaseBytes::test_simple_selection_with_variables</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_simple_selection_with_variables</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_simple_selection_with_variables>

    def test_simple_selection_with_variables(self) -> None:
        """Using XPath variables"""
        body = "<p><input name='a' value='1'/><input name='b' value='2'/></p>"
        sel = self.sscls(text=body)

        self.assertEqual(
            [x.extract() for x in sel.xpath("//input[@value=$number]/@name", number=1)],
            ["a"],
        )
        self.assertEqual(
            [
                x.extract()
                for x in sel.xpath("//input[@name=$letter]/@value", letter="b")
            ],
            ["2"],
        )

        self.assertEqual(
            sel.xpath(
                "count(//input[@value=$number or @name=$letter])",
                number=2,
                letter="a",
            ).extract(),
            ["2.0"],
        )

        # you can also pass booleans
>       self.assertEqual(
            sel.xpath("boolean(count(//input)=$cnt)=$test", cnt=2, test=True).extract(),
            ["1"],
        )
E       AssertionError: Lists differ: ['True'] != ['1']
E       
E       First differing element 0:
E       'True'
E       '1'
E       
E       - ['True']
E       + ['1']

tests/test_selector.py:118: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasebytestest_simple_selection_with_variables_escape_friendly">test_selector.py::SelectorTestCaseBytes::test_simple_selection_with_variables_escape_friendly</h3>
<details><summary> <pre>test_selector.py::SelectorTestCaseBytes::test_simple_selection_with_variables_escape_friendly</pre></summary><pre>
self = <test_selector.SelectorTestCaseBytes testMethod=test_simple_selection_with_variables_escape_friendly>

    def test_simple_selection_with_variables_escape_friendly(self) -> None:
        """Using XPath variables with quotes that would need escaping with string formatting"""
        body = """<p>I'm mixing single and <input name='a' value='I say "Yeah!"'/>
        "double quotes" and I don't care :)</p>"""
        sel = self.sscls(text=body)

        t = 'I say "Yeah!"'
        # naive string formatting with give something like:
        # ValueError: XPath error: Invalid predicate in //input[@value="I say "Yeah!""]/@name
>       self.assertRaises(ValueError, sel.xpath, f'//input[@value="{t}"]/@name')

tests/test_selector.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Invalid predicate

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>
<h3 id="test_selector_csstranslatorpyhtmltranslatortesttest_attr_function">test_selector_csstranslator.py::HTMLTranslatorTest::test_attr_function</h3>
<details><summary> <pre>test_selector_csstranslator.py::HTMLTranslatorTest::test_attr_function</pre></summary><pre>
self = <test_selector_csstranslator.HTMLTranslatorTest testMethod=test_attr_function>

    def test_attr_function(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::attr(name)", "descendant-or-self::*/@name"),
            ("a::attr(href)", "descendant-or-self::a/@href"),
            (
                "a ::attr(img)",
                "descendant-or-self::a/descendant-or-self::*/@img",
            ),
            ("a > ::attr(class)", "descendant-or-self::a/*/@class"),
        ]
        for css, xpath in cases:
>           self.assertEqual(self.c2x(css), xpath, css)

tests/test_selector_csstranslator.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
parsel/csstranslator.py:94: in xpath_pseudo_element
    return method(xpath, pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5d6fd940>
xpath = XPathExpr[*], function = FunctionalPseudoElement[::attr(['name'])]

    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -> XPathExpr:
        """Support selecting attribute values using ::attr() pseudo-element"""
        if not function.arguments:
            raise ExpressionError("Expected at least 1 argument for ::attr(), got 0")
        if not isinstance(function.arguments[0], str):
>           raise ExpressionError("Expected a string value for ::attr(), got %r" % function.arguments[0])
E           TypeError: not all arguments converted during string formatting

parsel/csstranslator.py:61: TypeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpyhtmltranslatortesttest_attr_function_exception">test_selector_csstranslator.py::HTMLTranslatorTest::test_attr_function_exception</h3>
<details><summary> <pre>test_selector_csstranslator.py::HTMLTranslatorTest::test_attr_function_exception</pre></summary><pre>
self = <test_selector_csstranslator.HTMLTranslatorTest testMethod=test_attr_function_exception>

    def test_attr_function_exception(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::attr(12)", ExpressionError),
            ("::attr(34test)", ExpressionError),
            ("::attr(@href)", SelectorSyntaxError),
        ]
        for css, exc in cases:
>           self.assertRaises(exc, self.c2x, css)

tests/test_selector_csstranslator.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
parsel/csstranslator.py:94: in xpath_pseudo_element
    return method(xpath, pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -> XPathExpr:
        """Support selecting attribute values using ::attr() pseudo-element"""
        if not function.arguments:
            raise ExpressionError("Expected at least 1 argument for ::attr(), got 0")
        if not isinstance(function.arguments[0], str):
>           raise ExpressionError("Expected a string value for ::attr(), got %r" % function.arguments[0])
E           TypeError: not all arguments converted during string formatting

parsel/csstranslator.py:61: TypeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpyhtmltranslatortesttest_text_pseudo_element">test_selector_csstranslator.py::HTMLTranslatorTest::test_text_pseudo_element</h3>
<details><summary> <pre>test_selector_csstranslator.py::HTMLTranslatorTest::test_text_pseudo_element</pre></summary><pre>
self = <test_selector_csstranslator.HTMLTranslatorTest testMethod=test_text_pseudo_element>

    def test_text_pseudo_element(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::text", "descendant-or-self::text()"),
            ("p::text", "descendant-or-self::p/text()"),
            ("p ::text", "descendant-or-self::p/descendant-or-self::text()"),
            ("#id::text", "descendant-or-self::*[@id = 'id']/text()"),
            ("p#id::text", "descendant-or-self::p[@id = 'id']/text()"),
            (
                "p#id ::text",
                "descendant-or-self::p[@id = 'id']/descendant-or-self::text()",
            ),
            ("p#id > ::text", "descendant-or-self::p[@id = 'id']/*/text()"),
            (
                "p#id ~ ::text",
                "descendant-or-self::p[@id = 'id']/following-sibling::*/text()",
            ),
            ("a[href]::text", "descendant-or-self::a[@href]/text()"),
            (
                "a[href] ::text",
                "descendant-or-self::a[@href]/descendant-or-self::text()",
            ),
            (
                "p::text, a::text",
                "descendant-or-self::p/text() | descendant-or-self::a/text()",
            ),
        ]
        for css, xpath in cases:
>           self.assertEqual(self.c2x(css), xpath, css)

tests/test_selector_csstranslator.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5d6fede0>
xpath = XPathExpr[*], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpyhtmltranslatortesttest_unknown_pseudo_element">test_selector_csstranslator.py::HTMLTranslatorTest::test_unknown_pseudo_element</h3>
<details><summary> <pre>test_selector_csstranslator.py::HTMLTranslatorTest::test_unknown_pseudo_element</pre></summary><pre>
self = <test_selector_csstranslator.HTMLTranslatorTest testMethod=test_unknown_pseudo_element>

    def test_unknown_pseudo_element(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::text-node", ExpressionError),
        ]
        for css, exc in cases:
>           self.assertRaises(exc, self.c2x, css)

tests/test_selector_csstranslator.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpygenerictranslatortesttest_attr_function">test_selector_csstranslator.py::GenericTranslatorTest::test_attr_function</h3>
<details><summary> <pre>test_selector_csstranslator.py::GenericTranslatorTest::test_attr_function</pre></summary><pre>
self = <test_selector_csstranslator.GenericTranslatorTest testMethod=test_attr_function>

    def test_attr_function(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::attr(name)", "descendant-or-self::*/@name"),
            ("a::attr(href)", "descendant-or-self::a/@href"),
            (
                "a ::attr(img)",
                "descendant-or-self::a/descendant-or-self::*/@img",
            ),
            ("a > ::attr(class)", "descendant-or-self::a/*/@class"),
        ]
        for css, xpath in cases:
>           self.assertEqual(self.c2x(css), xpath, css)

tests/test_selector_csstranslator.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
parsel/csstranslator.py:80: in xpath_pseudo_element
    return method(xpath, pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.GenericTranslator object at 0x7edc5d6fca70>
xpath = XPathExpr[*], function = FunctionalPseudoElement[::attr(['name'])]

    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -> XPathExpr:
        """Support selecting attribute values using ::attr() pseudo-element"""
        if not function.arguments:
            raise ExpressionError("Expected at least 1 argument for ::attr(), got 0")
        if not isinstance(function.arguments[0], str):
>           raise ExpressionError("Expected a string value for ::attr(), got %r" % function.arguments[0])
E           TypeError: not all arguments converted during string formatting

parsel/csstranslator.py:61: TypeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpygenerictranslatortesttest_attr_function_exception">test_selector_csstranslator.py::GenericTranslatorTest::test_attr_function_exception</h3>
<details><summary> <pre>test_selector_csstranslator.py::GenericTranslatorTest::test_attr_function_exception</pre></summary><pre>
self = <test_selector_csstranslator.GenericTranslatorTest testMethod=test_attr_function_exception>

    def test_attr_function_exception(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::attr(12)", ExpressionError),
            ("::attr(34test)", ExpressionError),
            ("::attr(@href)", SelectorSyntaxError),
        ]
        for css, exc in cases:
>           self.assertRaises(exc, self.c2x, css)

tests/test_selector_csstranslator.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
parsel/csstranslator.py:80: in xpath_pseudo_element
    return method(xpath, pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -> XPathExpr:
        """Support selecting attribute values using ::attr() pseudo-element"""
        if not function.arguments:
            raise ExpressionError("Expected at least 1 argument for ::attr(), got 0")
        if not isinstance(function.arguments[0], str):
>           raise ExpressionError("Expected a string value for ::attr(), got %r" % function.arguments[0])
E           TypeError: not all arguments converted during string formatting

parsel/csstranslator.py:61: TypeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpygenerictranslatortesttest_text_pseudo_element">test_selector_csstranslator.py::GenericTranslatorTest::test_text_pseudo_element</h3>
<details><summary> <pre>test_selector_csstranslator.py::GenericTranslatorTest::test_text_pseudo_element</pre></summary><pre>
self = <test_selector_csstranslator.GenericTranslatorTest testMethod=test_text_pseudo_element>

    def test_text_pseudo_element(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::text", "descendant-or-self::text()"),
            ("p::text", "descendant-or-self::p/text()"),
            ("p ::text", "descendant-or-self::p/descendant-or-self::text()"),
            ("#id::text", "descendant-or-self::*[@id = 'id']/text()"),
            ("p#id::text", "descendant-or-self::p[@id = 'id']/text()"),
            (
                "p#id ::text",
                "descendant-or-self::p[@id = 'id']/descendant-or-self::text()",
            ),
            ("p#id > ::text", "descendant-or-self::p[@id = 'id']/*/text()"),
            (
                "p#id ~ ::text",
                "descendant-or-self::p[@id = 'id']/following-sibling::*/text()",
            ),
            ("a[href]::text", "descendant-or-self::a[@href]/text()"),
            (
                "a[href] ::text",
                "descendant-or-self::a[@href]/descendant-or-self::text()",
            ),
            (
                "p::text, a::text",
                "descendant-or-self::p/text() | descendant-or-self::a/text()",
            ),
        ]
        for css, xpath in cases:
>           self.assertEqual(self.c2x(css), xpath, css)

tests/test_selector_csstranslator.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.GenericTranslator object at 0x7edc5d6fed50>
xpath = XPathExpr[*], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:81: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpygenerictranslatortesttest_unknown_pseudo_element">test_selector_csstranslator.py::GenericTranslatorTest::test_unknown_pseudo_element</h3>
<details><summary> <pre>test_selector_csstranslator.py::GenericTranslatorTest::test_unknown_pseudo_element</pre></summary><pre>
self = <test_selector_csstranslator.GenericTranslatorTest testMethod=test_unknown_pseudo_element>

    def test_unknown_pseudo_element(self: TranslatorTestProtocol) -> None:
        cases = [
            ("::text-node", ExpressionError),
        ]
        for css, exc in cases:
>           self.assertRaises(exc, self.c2x, css)

tests/test_selector_csstranslator.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:81: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortesttest_attribute_function">test_selector_csstranslator.py::CSSSelectorTest::test_attribute_function</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTest::test_attribute_function</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTest testMethod=test_attribute_function>

    def test_attribute_function(self) -> None:
>       self.assertEqual(self.x("#p-b2::attr(id)"), ["p-b2"])

tests/test_selector_csstranslator.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector_csstranslator.py:181: in x
    return [v.strip() for v in self.sel.css(*a, **kw).extract() if v.strip()]
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
parsel/csstranslator.py:94: in xpath_pseudo_element
    return method(xpath, pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[*[@id = 'p-b2']]
function = FunctionalPseudoElement[::attr(['id'])]

    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -> XPathExpr:
        """Support selecting attribute values using ::attr() pseudo-element"""
        if not function.arguments:
            raise ExpressionError("Expected at least 1 argument for ::attr(), got 0")
        if not isinstance(function.arguments[0], str):
>           raise ExpressionError("Expected a string value for ::attr(), got %r" % function.arguments[0])
E           TypeError: not all arguments converted during string formatting

parsel/csstranslator.py:61: TypeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortesttest_nested_selector">test_selector_csstranslator.py::CSSSelectorTest::test_nested_selector</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTest::test_nested_selector</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTest testMethod=test_nested_selector>

    def test_nested_selector(self) -> None:
>       self.assertEqual(self.sel.css("p").css("b::text").extract(), ["hi", "guy"])

tests/test_selector_csstranslator.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:163: in css
    return self.__class__(flatten([x.css(query) for x in self]))
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.GenericTranslator object at 0x7edc5e0205c0>
xpath = XPathExpr[b], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:81: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortesttest_pseudoclass_has">test_selector_csstranslator.py::CSSSelectorTest::test_pseudoclass_has</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTest::test_pseudoclass_has</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTest testMethod=test_pseudoclass_has>

    @pytest.mark.xfail(
        Version(cssselect.__version__) < Version("1.2.0"),
        reason="Support added in cssselect 1.2.0",
    )
    def test_pseudoclass_has(self) -> None:
>       self.assertEqual(self.x("p:has(b)::text"), ["lorem ipsum text"])

tests/test_selector_csstranslator.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector_csstranslator.py:181: in x
    return [v.strip() for v in self.sel.css(*a, **kw).extract() if v.strip()]
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[p[descendant::b]], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortesttest_text_pseudo_element">test_selector_csstranslator.py::CSSSelectorTest::test_text_pseudo_element</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTest::test_text_pseudo_element</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTest testMethod=test_text_pseudo_element>

    def test_text_pseudo_element(self) -> None:
        self.assertEqual(self.x("#p-b2"), ['<b id="p-b2">guy</b>'])
>       self.assertEqual(self.x("#p-b2::text"), ["guy"])

tests/test_selector_csstranslator.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector_csstranslator.py:181: in x
    return [v.strip() for v in self.sel.css(*a, **kw).extract() if v.strip()]
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[*[@id = 'p-b2']], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortestbytestest_attribute_function">test_selector_csstranslator.py::CSSSelectorTestBytes::test_attribute_function</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTestBytes::test_attribute_function</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTestBytes testMethod=test_attribute_function>

    def test_attribute_function(self) -> None:
>       self.assertEqual(self.x("#p-b2::attr(id)"), ["p-b2"])

tests/test_selector_csstranslator.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector_csstranslator.py:181: in x
    return [v.strip() for v in self.sel.css(*a, **kw).extract() if v.strip()]
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
parsel/csstranslator.py:94: in xpath_pseudo_element
    return method(xpath, pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[*[@id = 'p-b2']]
function = FunctionalPseudoElement[::attr(['id'])]

    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -> XPathExpr:
        """Support selecting attribute values using ::attr() pseudo-element"""
        if not function.arguments:
            raise ExpressionError("Expected at least 1 argument for ::attr(), got 0")
        if not isinstance(function.arguments[0], str):
>           raise ExpressionError("Expected a string value for ::attr(), got %r" % function.arguments[0])
E           TypeError: not all arguments converted during string formatting

parsel/csstranslator.py:61: TypeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortestbytestest_nested_selector">test_selector_csstranslator.py::CSSSelectorTestBytes::test_nested_selector</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTestBytes::test_nested_selector</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTestBytes testMethod=test_nested_selector>

    def test_nested_selector(self) -> None:
>       self.assertEqual(self.sel.css("p").css("b::text").extract(), ["hi", "guy"])

tests/test_selector_csstranslator.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:163: in css
    return self.__class__(flatten([x.css(query) for x in self]))
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.GenericTranslator object at 0x7edc5e0205c0>
xpath = XPathExpr[b], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:81: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortestbytestest_pseudoclass_has">test_selector_csstranslator.py::CSSSelectorTestBytes::test_pseudoclass_has</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTestBytes::test_pseudoclass_has</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTestBytes testMethod=test_pseudoclass_has>

    @pytest.mark.xfail(
        Version(cssselect.__version__) < Version("1.2.0"),
        reason="Support added in cssselect 1.2.0",
    )
    def test_pseudoclass_has(self) -> None:
>       self.assertEqual(self.x("p:has(b)::text"), ["lorem ipsum text"])

tests/test_selector_csstranslator.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector_csstranslator.py:181: in x
    return [v.strip() for v in self.sel.css(*a, **kw).extract() if v.strip()]
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[p[descendant::b]], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selector_csstranslatorpycssselectortestbytestest_text_pseudo_element">test_selector_csstranslator.py::CSSSelectorTestBytes::test_text_pseudo_element</h3>
<details><summary> <pre>test_selector_csstranslator.py::CSSSelectorTestBytes::test_text_pseudo_element</pre></summary><pre>
self = <test_selector_csstranslator.CSSSelectorTestBytes testMethod=test_text_pseudo_element>

    def test_text_pseudo_element(self) -> None:
        self.assertEqual(self.x("#p-b2"), ['<b id="p-b2">guy</b>'])
>       self.assertEqual(self.x("#p-b2::text"), ["guy"])

tests/test_selector_csstranslator.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_selector_csstranslator.py:181: in x
    return [v.strip() for v in self.sel.css(*a, **kw).extract() if v.strip()]
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[*[@id = 'p-b2']], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_selector_jmespathpyjmespathtestcasetest_html_has_json">test_selector_jmespath.py::JMESPathTestCase::test_html_has_json</h3>
<details><summary> <pre>test_selector_jmespath.py::JMESPathTestCase::test_html_has_json</pre></summary><pre>
self = <test_selector_jmespath.JMESPathTestCase testMethod=test_html_has_json>

    def test_html_has_json(self) -> None:
        html_text = """
        <div>
            <h1>Information</h1>
            <content>
            {
              "user": [
                        {
                                  "name": "A",
                                  "age": 18
                        },
                        {
                                  "name": "B",
                                  "age": 32
                        },
                        {
                                  "name": "C",
                                  "age": 22
                        },
                        {
                                  "name": "D",
                                  "age": 25
                        }
              ],
              "total": 4,
              "status": "ok"
            }
            </content>
        </div>
        """
        sel = Selector(text=html_text)
        self.assertEqual(
>           sel.xpath("//div/content/text()").jmespath("user[*].name").getall(),
            ["A", "B", "C", "D"],
        )

tests/test_selector_jmespath.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:135: in jmespath
    return self.__class__(flatten([x.jmespath(query, **kwargs) for x in self]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Selector query='//div/content/text()' data='\n            {\n              "user": ...'>
query = 'user[*].name', kwargs = {}

    def jmespath(self: _SelectorType, query: str, **kwargs: Any) -> SelectorList[_SelectorType]:
        """
        Find objects matching the JMESPath ``query`` and return the result as a
        :class:`SelectorList` instance with all elements flattened. List
        elements implement :class:`Selector` interface too.

        ``query`` is a string containing the `JMESPath
        <https://jmespath.org/>`_ query to apply.

        Any additional named arguments are passed to the underlying
        ``jmespath.search`` call, e.g.::

            selector.jmespath('author.name', options=jmespath.Options(dict_cls=collections.OrderedDict))
        """
        if self.type != 'json':
>           raise ValueError('JMESPath expressions can only be applied to JSON data')
E           ValueError: JMESPath expressions can only be applied to JSON data

parsel/selector.py:321: ValueError
</pre>
</details>
<h3 id="test_selector_jmespathpyjmespathtestcasetest_jmestpath_with_re">test_selector_jmespath.py::JMESPathTestCase::test_jmestpath_with_re</h3>
<details><summary> <pre>test_selector_jmespath.py::JMESPathTestCase::test_jmestpath_with_re</pre></summary><pre>
self = <test_selector_jmespath.JMESPathTestCase testMethod=test_jmestpath_with_re>

    def test_jmestpath_with_re(self) -> None:
        html_text = """
            <div>
                <h1>Information</h1>
                <content>
                {
                  "user": [
                            {
                                      "name": "A",
                                      "age": 18
                            },
                            {
                                      "name": "B",
                                      "age": 32
                            },
                            {
                                      "name": "C",
                                      "age": 22
                            },
                            {
                                      "name": "D",
                                      "age": 25
                            }
                  ],
                  "total": 4,
                  "status": "ok"
                }
                </content>
            </div>
            """
        sel = Selector(text=html_text)
        self.assertEqual(
>           sel.xpath("//div/content/text()").jmespath("user[*].name").re(r"(\w+)"),
            ["A", "B", "C", "D"],
        )

tests/test_selector_jmespath.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:135: in jmespath
    return self.__class__(flatten([x.jmespath(query, **kwargs) for x in self]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Selector query='//div/content/text()' data='\n                {\n                  ...'>
query = 'user[*].name', kwargs = {}

    def jmespath(self: _SelectorType, query: str, **kwargs: Any) -> SelectorList[_SelectorType]:
        """
        Find objects matching the JMESPath ``query`` and return the result as a
        :class:`SelectorList` instance with all elements flattened. List
        elements implement :class:`Selector` interface too.

        ``query`` is a string containing the `JMESPath
        <https://jmespath.org/>`_ query to apply.

        Any additional named arguments are passed to the underlying
        ``jmespath.search`` call, e.g.::

            selector.jmespath('author.name', options=jmespath.Options(dict_cls=collections.OrderedDict))
        """
        if self.type != 'json':
>           raise ValueError('JMESPath expressions can only be applied to JSON data')
E           ValueError: JMESPath expressions can only be applied to JSON data

parsel/selector.py:321: ValueError
</pre>
</details>
<h3 id="test_selector_jmespathpyjmespathtestcasetest_json_has_html">test_selector_jmespath.py::JMESPathTestCase::test_json_has_html</h3>
<details><summary> <pre>test_selector_jmespath.py::JMESPathTestCase::test_json_has_html</pre></summary><pre>
self = <test_selector_jmespath.JMESPathTestCase testMethod=test_json_has_html>

    def test_json_has_html(self) -> None:
        """Sometimes the information is returned in a json wrapper"""
        data = """
        {
            "content": [
                {
                    "name": "A",
                    "value": "a"
                },
                {
                    "name": {
                        "age": 18
                    },
                    "value": "b"
                },
                {
                    "name": "C",
                    "value": "c"
                },
                {
                    "name": "<a>D</a>",
                    "value": "<div>d</div>"
                }
            ],
            "html": "<div><a>a<br>b</a>c</div><div><a>d</a>e<b>f</b></div>"
        }
        """
        sel = Selector(text=data)
        self.assertEqual(
>           sel.jmespath("html").get(),
            "<div><a>a<br>b</a>c</div><div><a>d</a>e<b>f</b></div>",
        )

tests/test_selector_jmespath.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Selector query=None data='<html><body><p>{\n            "content...'>
query = 'html', kwargs = {}

    def jmespath(self: _SelectorType, query: str, **kwargs: Any) -> SelectorList[_SelectorType]:
        """
        Find objects matching the JMESPath ``query`` and return the result as a
        :class:`SelectorList` instance with all elements flattened. List
        elements implement :class:`Selector` interface too.

        ``query`` is a string containing the `JMESPath
        <https://jmespath.org/>`_ query to apply.

        Any additional named arguments are passed to the underlying
        ``jmespath.search`` call, e.g.::

            selector.jmespath('author.name', options=jmespath.Options(dict_cls=collections.OrderedDict))
        """
        if self.type != 'json':
>           raise ValueError('JMESPath expressions can only be applied to JSON data')
E           ValueError: JMESPath expressions can only be applied to JSON data

parsel/selector.py:321: ValueError
</pre>
</details>
<h3 id="test_selector_jmespathpyjmespathtestcasetest_json_types">test_selector_jmespath.py::JMESPathTestCase::test_json_types</h3>
<details><summary> <pre>test_selector_jmespath.py::JMESPathTestCase::test_json_types</pre></summary><pre>
self = <test_selector_jmespath.JMESPathTestCase testMethod=test_json_types>

    def test_json_types(self) -> None:
        for text, root in (
            ("{}", {}),
            ('{"a": "b"}', {"a": "b"}),
            ("[]", []),
            ('["a"]', ["a"]),
            ('""', ""),
            ("0", 0),
            ("1", 1),
            ("true", True),
            ("false", False),
            ("null", None),
        ):
            selector = Selector(text=text, root=_NOT_SET)
>           self.assertEqual(selector.type, "json")
E           AssertionError: 'html' != 'json'
E           - html
E           + json

tests/test_selector_jmespath.py:163: AssertionError
</pre>
</details>
<h3 id="test_utilspytest_shorten0-">test_utils.py::test_shorten[0-]</h3>
<details><summary> <pre>test_utils.py::test_shorten[0-]</pre></summary><pre>
width = 0, expected = ''

    @mark.parametrize(
        "width,expected",
        (
            (-1, ValueError),
            (0, ""),
            (1, "."),
            (2, ".."),
            (3, "..."),
            (4, "f..."),
            (5, "fo..."),
            (6, "foobar"),
            (7, "foobar"),
        ),
    )
    def test_shorten(width: int, expected: Union[str, Type[Exception]]) -> None:
        if isinstance(expected, str):
>           assert shorten("foobar", width) == expected

tests/test_utils.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = 'foobar', width = 0, suffix = '...'

    def shorten(text: str, width: int, suffix: str='...') -> str:
        """Truncate the given text to fit in the given width."""
        if width <= 0:
>           raise ValueError('Width must be greater than 0')
E           ValueError: Width must be greater than 0

parsel/utils.py:79: ValueError
</pre>
</details>
<h3 id="test_utilspytest_shorten1-">test_utils.py::test_shorten[1-.]</h3>
<details><summary> <pre>test_utils.py::test_shorten[1-.]</pre></summary><pre>
width = 1, expected = '.'

    @mark.parametrize(
        "width,expected",
        (
            (-1, ValueError),
            (0, ""),
            (1, "."),
            (2, ".."),
            (3, "..."),
            (4, "f..."),
            (5, "fo..."),
            (6, "foobar"),
            (7, "foobar"),
        ),
    )
    def test_shorten(width: int, expected: Union[str, Type[Exception]]) -> None:
        if isinstance(expected, str):
>           assert shorten("foobar", width) == expected
E           AssertionError

tests/test_utils.py:24: AssertionError
</pre>
</details>
<h3 id="test_utilspytest_shorten2-">test_utils.py::test_shorten[2-..]</h3>
<details><summary> <pre>test_utils.py::test_shorten[2-..]</pre></summary><pre>
width = 2, expected = '..'

    @mark.parametrize(
        "width,expected",
        (
            (-1, ValueError),
            (0, ""),
            (1, "."),
            (2, ".."),
            (3, "..."),
            (4, "f..."),
            (5, "fo..."),
            (6, "foobar"),
            (7, "foobar"),
        ),
    )
    def test_shorten(width: int, expected: Union[str, Type[Exception]]) -> None:
        if isinstance(expected, str):
>           assert shorten("foobar", width) == expected
E           AssertionError

tests/test_utils.py:24: AssertionError
</pre>
</details>
<h3 id="test_utilspytest_shorten3-">test_utils.py::test_shorten[3-...]</h3>
<details><summary> <pre>test_utils.py::test_shorten[3-...]</pre></summary><pre>
width = 3, expected = '...'

    @mark.parametrize(
        "width,expected",
        (
            (-1, ValueError),
            (0, ""),
            (1, "."),
            (2, ".."),
            (3, "..."),
            (4, "f..."),
            (5, "fo..."),
            (6, "foobar"),
            (7, "foobar"),
        ),
    )
    def test_shorten(width: int, expected: Union[str, Type[Exception]]) -> None:
        if isinstance(expected, str):
>           assert shorten("foobar", width) == expected
E           AssertionError

tests/test_utils.py:24: AssertionError
</pre>
</details>
<h3 id="test_utilspytest_extract_regexpwspdsspd-october-25-2019-true-expected0">test_utils.py::test_extract_regex[(?P<month>\w+)\s<em>(?P<day>\d+)\s</em>\,?\s*(?P<year>\d+)-October  25, 2019-True-expected0]</h3>
<details><summary> <pre>test_utils.py::test_extract_regex[(?P<month>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)-October  25, 2019-True-expected0]</pre></summary><pre>
regex = '(?P<month>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)'
text = 'October  25, 2019', replace_entities = True
expected = ['October', '25', '2019']

    @mark.parametrize(
        "regex, text, replace_entities, expected",
        (
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25, 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<extract>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October"],
            ],
            [
                r"\w+\s*\d+\s*\,?\s*\d+",
                "October  25 2019",
                True,
                ["October  25 2019"],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                True,
                ['"sometext" &amp; "moretext"'],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                False,
                ["&quot;sometext&quot; &amp; &quot;moretext&quot;"],
            ],
        ),
    )
    def test_extract_regex(
        regex: Union[str, Pattern[str]],
        text: str,
        replace_entities: bool,
        expected: List[str],
    ) -> None:
>       assert extract_regex(regex, text, replace_entities) == expected

tests/test_utils.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '(?P<month>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)'
text = 'October  25, 2019', replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_utilspytest_extract_regexpwspdsspd-october-25-2019-true-expected1">test_utils.py::test_extract_regex[(?P<month>\w+)\s<em>(?P<day>\d+)\s</em>\,?\s*(?P<year>\d+)-October  25 2019-True-expected1]</h3>
<details><summary> <pre>test_utils.py::test_extract_regex[(?P<month>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)-October  25 2019-True-expected1]</pre></summary><pre>
regex = '(?P<month>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)'
text = 'October  25 2019', replace_entities = True
expected = ['October', '25', '2019']

    @mark.parametrize(
        "regex, text, replace_entities, expected",
        (
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25, 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<extract>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October"],
            ],
            [
                r"\w+\s*\d+\s*\,?\s*\d+",
                "October  25 2019",
                True,
                ["October  25 2019"],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                True,
                ['"sometext" &amp; "moretext"'],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                False,
                ["&quot;sometext&quot; &amp; &quot;moretext&quot;"],
            ],
        ),
    )
    def test_extract_regex(
        regex: Union[str, Pattern[str]],
        text: str,
        replace_entities: bool,
        expected: List[str],
    ) -> None:
>       assert extract_regex(regex, text, replace_entities) == expected

tests/test_utils.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '(?P<month>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)'
text = 'October  25 2019', replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_utilspytest_extract_regexpwspdsspd-october-25-2019-true-expected2">test_utils.py::test_extract_regex[(?P<extract>\w+)\s<em>(?P<day>\d+)\s</em>\,?\s*(?P<year>\d+)-October  25 2019-True-expected2]</h3>
<details><summary> <pre>test_utils.py::test_extract_regex[(?P<extract>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)-October  25 2019-True-expected2]</pre></summary><pre>
regex = '(?P<extract>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)'
text = 'October  25 2019', replace_entities = True, expected = ['October']

    @mark.parametrize(
        "regex, text, replace_entities, expected",
        (
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25, 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<extract>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October"],
            ],
            [
                r"\w+\s*\d+\s*\,?\s*\d+",
                "October  25 2019",
                True,
                ["October  25 2019"],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                True,
                ['"sometext" &amp; "moretext"'],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                False,
                ["&quot;sometext&quot; &amp; &quot;moretext&quot;"],
            ],
        ),
    )
    def test_extract_regex(
        regex: Union[str, Pattern[str]],
        text: str,
        replace_entities: bool,
        expected: List[str],
    ) -> None:
>       assert extract_regex(regex, text, replace_entities) == expected

tests/test_utils.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '(?P<extract>\\w+)\\s*(?P<day>\\d+)\\s*\\,?\\s*(?P<year>\\d+)'
text = 'October  25 2019', replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_utilspytest_extract_regexwsdssd-october-25-2019-true-expected3">test_utils.py::test_extract_regex[\w+\s<em>\d+\s</em>\,?\s*\d+-October  25 2019-True-expected3]</h3>
<details><summary> <pre>test_utils.py::test_extract_regex[\\w+\\s*\\d+\\s*\\,?\\s*\\d+-October  25 2019-True-expected3]</pre></summary><pre>
regex = '\\w+\\s*\\d+\\s*\\,?\\s*\\d+', text = 'October  25 2019'
replace_entities = True, expected = ['October  25 2019']

    @mark.parametrize(
        "regex, text, replace_entities, expected",
        (
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25, 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<extract>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October"],
            ],
            [
                r"\w+\s*\d+\s*\,?\s*\d+",
                "October  25 2019",
                True,
                ["October  25 2019"],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                True,
                ['"sometext" &amp; "moretext"'],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                False,
                ["&quot;sometext&quot; &amp; &quot;moretext&quot;"],
            ],
        ),
    )
    def test_extract_regex(
        regex: Union[str, Pattern[str]],
        text: str,
        replace_entities: bool,
        expected: List[str],
    ) -> None:
>       assert extract_regex(regex, text, replace_entities) == expected

tests/test_utils.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '\\w+\\s*\\d+\\s*\\,?\\s*\\d+', text = 'October  25 2019'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_utilspytest_extract_regex-sometext-moretext-true-expected4">test_utils.py::test_extract_regex[^.*$-&quot;sometext&quot; &amp; &quot;moretext&quot;-True-expected4]</h3>
<details><summary> <pre>test_utils.py::test_extract_regex[^.*$-&quot;sometext&quot; &amp; &quot;moretext&quot;-True-expected4]</pre></summary><pre>
regex = '^.*$', text = '&quot;sometext&quot; &amp; &quot;moretext&quot;'
replace_entities = True, expected = ['"sometext" &amp; "moretext"']

    @mark.parametrize(
        "regex, text, replace_entities, expected",
        (
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25, 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<month>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October", "25", "2019"],
            ],
            [
                r"(?P<extract>\w+)\s*(?P<day>\d+)\s*\,?\s*(?P<year>\d+)",
                "October  25 2019",
                True,
                ["October"],
            ],
            [
                r"\w+\s*\d+\s*\,?\s*\d+",
                "October  25 2019",
                True,
                ["October  25 2019"],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                True,
                ['"sometext" &amp; "moretext"'],
            ],
            [
                r"^.*$",
                "&quot;sometext&quot; &amp; &quot;moretext&quot;",
                False,
                ["&quot;sometext&quot; &amp; &quot;moretext&quot;"],
            ],
        ),
    )
    def test_extract_regex(
        regex: Union[str, Pattern[str]],
        text: str,
        replace_entities: bool,
        expected: List[str],
    ) -> None:
>       assert extract_regex(regex, text, replace_entities) == expected

tests/test_utils.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regex = '^.*$', text = '&quot;sometext&quot; &amp; &quot;moretext&quot;'
replace_entities = True

    def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -> List[str]:
        """Extract a list of strings from the given text/encoding using the following policies:
        * if the regex contains a named group called "extract" that will be returned
        * if the regex contains multiple numbered groups, all those will be returned (flattened)
        * if the regex doesn't contain any group the entire regex matching is returned
        """
        if not text:
            return []
        if replace_entities:
>           text = w3lib_replace_entities(text, keep_entities=True)
E           TypeError: replace_entities() got an unexpected keyword argument 'keep_entities'

parsel/utils.py:63: TypeError
</pre>
</details>
<h3 id="test_xml_attackspyxmlattacktestcasetest_billion_laughs">test_xml_attacks.py::XMLAttackTestCase::test_billion_laughs</h3>
<details><summary> <pre>test_xml_attacks.py::XMLAttackTestCase::test_billion_laughs</pre></summary><pre>
self = <test_xml_attacks.XMLAttackTestCase testMethod=test_billion_laughs>

    def test_billion_laughs(self) -> None:
        process = Process()
        memory_usage_before = process.memory_info().rss
        selector = Selector(text=_load("billion_laughs"))
>       lolz = selector.css("lolz::text").get()

tests/test_xml_attacks.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:375: in css
    xpath = _ctgroup[self.type or 'html']['_csstranslator'].css_to_xpath(query)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:222: in css_to_xpath
    return " | ".join(
.venv/lib/python3.12/site-packages/cssselect/xpath.py:223: in <genexpr>
    self.selector_to_xpath(selector, prefix, translate_pseudo_elements=True)
.venv/lib/python3.12/site-packages/cssselect/xpath.py:259: in selector_to_xpath
    xpath = self.xpath_pseudo_element(xpath, selector.pseudo_element)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <parsel.csstranslator.HTMLTranslator object at 0x7edc5e4e4a40>
xpath = XPathExpr[lolz], pseudo_element = 'text'

    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -> OriginalXPathExpr:
        if isinstance(pseudo_element, FunctionalPseudoElement):
            method = f'xpath_{pseudo_element.name}_functional_pseudo_element'
            if not hasattr(self, method):
                raise ExpressionError(f'Unknown pseudo-element ::{pseudo_element.name}()')
            method = getattr(self, method)
            return method(xpath, pseudo_element)
>       method = f'xpath_{pseudo_element.name}_simple_pseudo_element'
E       AttributeError: 'str' object has no attribute 'name'

parsel/csstranslator.py:95: AttributeError
</pre>
</details>
<h3 id="test_xpathfuncspyxpathfuncstestcasetest_has_class_unicode">test_xpathfuncs.py::XPathFuncsTestCase::test_has_class_unicode</h3>
<details><summary> <pre>test_xpathfuncs.py::XPathFuncsTestCase::test_has_class_unicode</pre></summary><pre>
context = <lxml.etree._XPathContext object at 0x7edc5d5b9260>
classes = ('fóó',), class_ = 'fóó'

    def has_class(context: Any, *classes: str) -> bool:
        """has-class function.

        Return True if all ``classes`` are present in element's class attr.

        """
        if not classes:
            raise ValueError("has-class must have at least 1 argument")

        for class_ in classes:
            if not isinstance(class_, str):
                raise ValueError("has-class arguments must be strings")
            try:
>               class_.encode('ascii')
E               UnicodeEncodeError: 'ascii' codec can't encode characters in position 1-2: ordinal not in range(128)

parsel/xpathfuncs.py:45: UnicodeEncodeError

During handling of the above exception, another exception occurred:

self = <test_xpathfuncs.XPathFuncsTestCase testMethod=test_has_class_unicode>

    def test_has_class_unicode(self) -> None:
        body = """
        <p CLASS="fóó">First</p>
        """
        sel = Selector(text=body)
        self.assertEqual(
>           [x.extract() for x in sel.xpath('//p[has-class("fóó")]/text()')],
            ["First"],
        )

tests/test_xpathfuncs.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
src/lxml/xpath.pxi:206: in lxml.etree._XPathEvaluatorBase._handle_result
    ???
src/lxml/etree.pyx:351: in lxml.etree._ExceptionContext._raise_if_stored
    ???
src/lxml/extensions.pxi:801: in lxml.etree._extension_function_call
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

context = <lxml.etree._XPathContext object at 0x7edc5d5b9260>
classes = ('fóó',), class_ = 'fóó'

    def has_class(context: Any, *classes: str) -> bool:
        """has-class function.

        Return True if all ``classes`` are present in element's class attr.

        """
        if not classes:
            raise ValueError("has-class must have at least 1 argument")

        for class_ in classes:
            if not isinstance(class_, str):
                raise ValueError("has-class arguments must be strings")
            try:
                class_.encode('ascii')
            except UnicodeEncodeError:
>               raise ValueError("All strings must be XML compatible")
E               ValueError: All strings must be XML compatible

parsel/xpathfuncs.py:47: ValueError
</pre>
</details>
<h3 id="test_xpathfuncspyxpathfuncstestcasetest_set_xpathfunc">test_xpathfuncs.py::XPathFuncsTestCase::test_set_xpathfunc</h3>
<details><summary> <pre>test_xpathfuncs.py::XPathFuncsTestCase::test_set_xpathfunc</pre></summary><pre>
self = <test_xpathfuncs.XPathFuncsTestCase testMethod=test_set_xpathfunc>

    def test_set_xpathfunc(self) -> None:
        def myfunc(ctx: Any) -> None:
            myfunc.call_count += 1  # type: ignore[attr-defined]

        myfunc.call_count = 0  # type: ignore[attr-defined]

        body = """
        <p CLASS="foo">First</p>
        """
        sel = Selector(text=body)
>       self.assertRaisesRegex(
            ValueError,
            "Unregistered function in myfunc",
            sel.xpath,
            "myfunc()",
        )

tests/test_xpathfuncs.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
parsel/selector.py:357: in xpath
    result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)
src/lxml/etree.pyx:1623: in lxml.etree._Element.xpath
    ???
src/lxml/xpath.pxi:290: in lxml.etree.XPathElementEvaluator.__call__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   lxml.etree.XPathEvalError: Unregistered function

src/lxml/xpath.pxi:210: XPathEvalError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/parsel/__init__.py b/parsel/__init__.py</span>
<span class="gh">index 5fdbf35..22c7938 100644</span>
<span class="gd">--- a/parsel/__init__.py</span>
<span class="gi">+++ b/parsel/__init__.py</span>
<span class="gu">@@ -13,8 +13,8 @@ __all__ = [</span>
<span class="w"> </span>    &quot;xpathfuncs&quot;,
<span class="w"> </span>]

<span class="gd">-from parsel import xpathfuncs  # NOQA</span>
<span class="gi">+from parsel.xpathfuncs import setup  # NOQA</span>
<span class="w"> </span>from parsel.csstranslator import css2xpath  # NOQA
<span class="w"> </span>from parsel.selector import Selector, SelectorList  # NOQA

<span class="gd">-xpathfuncs.setup()</span>
<span class="gi">+setup()</span>
<span class="gh">diff --git a/parsel/csstranslator.py b/parsel/csstranslator.py</span>
<span class="gh">index b617836..d574226 100644</span>
<span class="gd">--- a/parsel/csstranslator.py</span>
<span class="gi">+++ b/parsel/csstranslator.py</span>
<span class="gu">@@ -28,7 +28,8 @@ class XPathExpr(OriginalXPathExpr):</span>
<span class="w"> </span>        return path

<span class="w"> </span>class TranslatorProtocol(Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    def css_to_xpath(self, css: str) -&gt; str:</span>
<span class="gi">+        ...</span>

<span class="w"> </span>class TranslatorMixin:
<span class="w"> </span>    &quot;&quot;&quot;This mixin adds support to CSS pseudo elements via dynamic dispatch.
<span class="gu">@@ -40,23 +41,65 @@ class TranslatorMixin:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Dispatch method that transforms XPath to support pseudo-element
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(pseudo_element, FunctionalPseudoElement):</span>
<span class="gi">+            method = f&#39;xpath_{pseudo_element.name}_functional_pseudo_element&#39;</span>
<span class="gi">+            if not hasattr(self, method):</span>
<span class="gi">+                raise ExpressionError(f&#39;Unknown pseudo-element ::{pseudo_element.name}()&#39;)</span>
<span class="gi">+            method = getattr(self, method)</span>
<span class="gi">+            return method(xpath, pseudo_element)</span>
<span class="gi">+        method = f&#39;xpath_{pseudo_element.name}_simple_pseudo_element&#39;</span>
<span class="gi">+        if not hasattr(self, method):</span>
<span class="gi">+            raise ExpressionError(f&#39;Unknown pseudo-element ::{pseudo_element.name}&#39;)</span>
<span class="gi">+        method = getattr(self, method)</span>
<span class="gi">+        return method(xpath)</span>

<span class="w"> </span>    def xpath_attr_functional_pseudo_element(self, xpath: OriginalXPathExpr, function: FunctionalPseudoElement) -&gt; XPathExpr:
<span class="w"> </span>        &quot;&quot;&quot;Support selecting attribute values using ::attr() pseudo-element&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not function.arguments:</span>
<span class="gi">+            raise ExpressionError(&quot;Expected at least 1 argument for ::attr(), got 0&quot;)</span>
<span class="gi">+        if not isinstance(function.arguments[0], str):</span>
<span class="gi">+            raise ExpressionError(&quot;Expected a string value for ::attr(), got %r&quot; % function.arguments[0])</span>
<span class="gi">+        xpath = XPathExpr.from_xpath(xpath)</span>
<span class="gi">+        xpath.attribute = function.arguments[0]</span>
<span class="gi">+        xpath.textnode = False</span>
<span class="gi">+        return xpath</span>

<span class="w"> </span>    def xpath_text_simple_pseudo_element(self, xpath: OriginalXPathExpr) -&gt; XPathExpr:
<span class="w"> </span>        &quot;&quot;&quot;Support selecting text nodes using ::text pseudo-element&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        xpath = XPathExpr.from_xpath(xpath)</span>
<span class="gi">+        xpath.textnode = True</span>
<span class="gi">+        return xpath</span>

<span class="w"> </span>class GenericTranslator(TranslatorMixin, OriginalGenericTranslator):
<span class="gd">-    pass</span>
<span class="gi">+    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -&gt; OriginalXPathExpr:</span>
<span class="gi">+        if isinstance(pseudo_element, FunctionalPseudoElement):</span>
<span class="gi">+            method = f&#39;xpath_{pseudo_element.name}_functional_pseudo_element&#39;</span>
<span class="gi">+            if not hasattr(self, method):</span>
<span class="gi">+                raise ExpressionError(f&#39;Unknown pseudo-element ::{pseudo_element.name}()&#39;)</span>
<span class="gi">+            method = getattr(self, method)</span>
<span class="gi">+            return method(xpath, pseudo_element)</span>
<span class="gi">+        method = f&#39;xpath_{pseudo_element.name}_simple_pseudo_element&#39;</span>
<span class="gi">+        if not hasattr(self, method):</span>
<span class="gi">+            raise ExpressionError(f&#39;Unknown pseudo-element ::{pseudo_element.name}&#39;)</span>
<span class="gi">+        method = getattr(self, method)</span>
<span class="gi">+        return method(xpath)</span>

<span class="w"> </span>class HTMLTranslator(TranslatorMixin, OriginalHTMLTranslator):
<span class="gd">-    pass</span>
<span class="gi">+    def xpath_pseudo_element(self, xpath: OriginalXPathExpr, pseudo_element: PseudoElement) -&gt; OriginalXPathExpr:</span>
<span class="gi">+        if isinstance(pseudo_element, FunctionalPseudoElement):</span>
<span class="gi">+            method = f&#39;xpath_{pseudo_element.name}_functional_pseudo_element&#39;</span>
<span class="gi">+            if not hasattr(self, method):</span>
<span class="gi">+                raise ExpressionError(f&#39;Unknown pseudo-element ::{pseudo_element.name}()&#39;)</span>
<span class="gi">+            method = getattr(self, method)</span>
<span class="gi">+            return method(xpath, pseudo_element)</span>
<span class="gi">+        method = f&#39;xpath_{pseudo_element.name}_simple_pseudo_element&#39;</span>
<span class="gi">+        if not hasattr(self, method):</span>
<span class="gi">+            raise ExpressionError(f&#39;Unknown pseudo-element ::{pseudo_element.name}&#39;)</span>
<span class="gi">+        method = getattr(self, method)</span>
<span class="gi">+        return method(xpath)</span>
<span class="w"> </span>_translator = HTMLTranslator()

<span class="gi">+@lru_cache(maxsize=5000)</span>
<span class="w"> </span>def css2xpath(query: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return translated XPath version of a given CSS query&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    return _translator.css_to_xpath(query)</span>
\ No newline at end of file
<span class="gh">diff --git a/parsel/selector.py b/parsel/selector.py</span>
<span class="gh">index a36cfa5..75ca173 100644</span>
<span class="gd">--- a/parsel/selector.py</span>
<span class="gi">+++ b/parsel/selector.py</span>
<span class="gu">@@ -39,9 +39,62 @@ class CTGroupValue(TypedDict):</span>
<span class="w"> </span>    _tostring_method: str
<span class="w"> </span>_ctgroup: Dict[str, CTGroupValue] = {&#39;html&#39;: {&#39;_parser&#39;: html.HTMLParser, &#39;_csstranslator&#39;: HTMLTranslator(), &#39;_tostring_method&#39;: &#39;html&#39;}, &#39;xml&#39;: {&#39;_parser&#39;: SafeXMLParser, &#39;_csstranslator&#39;: GenericTranslator(), &#39;_tostring_method&#39;: &#39;xml&#39;}}

<span class="gi">+def _get_root_type(root: Any, input_type: Optional[str]=None) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Get root type based on root object and input type.&quot;&quot;&quot;</span>
<span class="gi">+    if input_type is not None:</span>
<span class="gi">+        return input_type</span>
<span class="gi">+    elif isinstance(root, (dict, list)):</span>
<span class="gi">+        return &#39;json&#39;</span>
<span class="gi">+    elif isinstance(root, (etree._Element, etree._ElementTree)):</span>
<span class="gi">+        if isinstance(root, etree._Element) and root.tag == &#39;html&#39;:</span>
<span class="gi">+            return &#39;html&#39;</span>
<span class="gi">+        return &#39;xml&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &#39;html&#39;</span>
<span class="gi">+</span>
<span class="gi">+def _get_root_and_type_from_text(text: str, input_type: Optional[str]=None, base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE) -&gt; Tuple[Any, str]:</span>
<span class="gi">+    &quot;&quot;&quot;Get root node and type from text input.&quot;&quot;&quot;</span>
<span class="gi">+    if input_type == &#39;json&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return json.loads(text), &#39;json&#39;</span>
<span class="gi">+        except json.JSONDecodeError as e:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid JSON: {str(e)}&quot;)</span>
<span class="gi">+    elif input_type == &#39;text&#39;:</span>
<span class="gi">+        return text, &#39;text&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        parser_cls = _ctgroup[input_type or &#39;html&#39;][&#39;_parser&#39;]</span>
<span class="gi">+        root = create_root_node(text, parser_cls, base_url=base_url, huge_tree=huge_tree)</span>
<span class="gi">+        return root, input_type or &#39;html&#39;</span>
<span class="gi">+</span>
<span class="gi">+def _get_root_and_type_from_bytes(body: bytes, encoding: str=&#39;utf8&#39;, input_type: Optional[str]=None, base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE) -&gt; Tuple[Any, str]:</span>
<span class="gi">+    &quot;&quot;&quot;Get root node and type from bytes input.&quot;&quot;&quot;</span>
<span class="gi">+    if input_type == &#39;json&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return json.loads(body.decode(encoding)), &#39;json&#39;</span>
<span class="gi">+        except json.JSONDecodeError as e:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid JSON: {str(e)}&quot;)</span>
<span class="gi">+    elif input_type == &#39;text&#39;:</span>
<span class="gi">+        return body.decode(encoding), &#39;text&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        parser_cls = _ctgroup[input_type or &#39;html&#39;][&#39;_parser&#39;]</span>
<span class="gi">+        root = create_root_node(&#39;&#39;, parser_cls, base_url=base_url, huge_tree=huge_tree, body=body, encoding=encoding)</span>
<span class="gi">+        return root, input_type or &#39;html&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>def create_root_node(text: str, parser_cls: Type[_ParserType], base_url: Optional[str]=None, huge_tree: bool=LXML_SUPPORTS_HUGE_TREE, body: bytes=b&#39;&#39;, encoding: str=&#39;utf8&#39;) -&gt; etree._Element:
<span class="w"> </span>    &quot;&quot;&quot;Create root node for text using given parser class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser_kwargs = {}</span>
<span class="gi">+    if huge_tree and LXML_SUPPORTS_HUGE_TREE:</span>
<span class="gi">+        parser_kwargs[&#39;huge_tree&#39;] = True</span>
<span class="gi">+    parser = parser_cls(**parser_kwargs)</span>
<span class="gi">+    if body:</span>
<span class="gi">+        root = etree.fromstring(body, parser=parser, base_url=base_url)</span>
<span class="gi">+    else:</span>
<span class="gi">+        root = etree.fromstring(text.encode(encoding), parser=parser, base_url=base_url)</span>
<span class="gi">+    if root is None:</span>
<span class="gi">+        root = etree.Element(&#39;html&#39;)</span>
<span class="gi">+    if base_url is not None:</span>
<span class="gi">+        root.base = base_url</span>
<span class="gi">+    return root</span>

<span class="w"> </span>class SelectorList(List[_SelectorType]):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -79,7 +132,7 @@ class SelectorList(List[_SelectorType]):</span>

<span class="w"> </span>            selector.jmespath(&#39;author.name&#39;, options=jmespath.Options(dict_cls=collections.OrderedDict))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__(flatten([x.jmespath(query, **kwargs) for x in self]))</span>

<span class="w"> </span>    def xpath(self, xpath: str, namespaces: Optional[Mapping[str, str]]=None, **kwargs: Any) -&gt; &#39;SelectorList[_SelectorType]&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -98,7 +151,7 @@ class SelectorList(List[_SelectorType]):</span>

<span class="w"> </span>            selector.xpath(&#39;//a[href=$url]&#39;, url=&quot;http://www.example.com&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__(flatten([x.xpath(xpath, namespaces=namespaces, **kwargs) for x in self]))</span>

<span class="w"> </span>    def css(self, query: str) -&gt; &#39;SelectorList[_SelectorType]&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -107,7 +160,7 @@ class SelectorList(List[_SelectorType]):</span>

<span class="w"> </span>        ``query`` is the same argument as the one in :meth:`Selector.css`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__(flatten([x.css(query) for x in self]))</span>

<span class="w"> </span>    def re(self, regex: Union[str, Pattern[str]], replace_entities: bool=True) -&gt; List[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -119,7 +172,7 @@ class SelectorList(List[_SelectorType]):</span>
<span class="w"> </span>        Passing ``replace_entities`` as ``False`` switches off these
<span class="w"> </span>        replacements.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(flatten([x.re(regex, replace_entities=replace_entities) for x in self]))</span>

<span class="w"> </span>    def re_first(self, regex: Union[str, Pattern[str]], default: Optional[str]=None, replace_entities: bool=True) -&gt; Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -133,14 +186,16 @@ class SelectorList(List[_SelectorType]):</span>
<span class="w"> </span>        Passing ``replace_entities`` as ``False`` switches off these
<span class="w"> </span>        replacements.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for el in iflatten(x.re(regex, replace_entities=replace_entities) for x in self):</span>
<span class="gi">+            return el</span>
<span class="gi">+        return default</span>

<span class="w"> </span>    def getall(self) -&gt; List[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Call the ``.get()`` method for each element is this list and return
<span class="w"> </span>        their results flattened, as a list of strings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [x.get() for x in self]</span>
<span class="w"> </span>    extract = getall

<span class="w"> </span>    def get(self, default: Optional[str]=None) -&gt; Any:
<span class="gu">@@ -148,7 +203,9 @@ class SelectorList(List[_SelectorType]):</span>
<span class="w"> </span>        Return the result of ``.get()`` for the first element in this list.
<span class="w"> </span>        If the list is empty, return the default value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for x in self:</span>
<span class="gi">+            return x.get()</span>
<span class="gi">+        return default</span>
<span class="w"> </span>    extract_first = get

<span class="w"> </span>    @property
<span class="gu">@@ -156,19 +213,23 @@ class SelectorList(List[_SelectorType]):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the attributes dictionary for the first element.
<span class="w"> </span>        If the list is empty, return an empty dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for x in self:</span>
<span class="gi">+            return x.attrib</span>
<span class="gi">+        return {}</span>

<span class="w"> </span>    def remove(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove matched nodes from the parent for each element in this list.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for x in self:</span>
<span class="gi">+            x.remove()</span>

<span class="w"> </span>    def drop(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Drop matched nodes from the parent for each element in this list.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for x in self:</span>
<span class="gi">+            x.drop()</span>
<span class="w"> </span>_NOT_SET = object()

<span class="w"> </span>class Selector:
<span class="gu">@@ -256,7 +317,14 @@ class Selector:</span>

<span class="w"> </span>            selector.jmespath(&#39;author.name&#39;, options=jmespath.Options(dict_cls=collections.OrderedDict))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type != &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;JMESPath expressions can only be applied to JSON data&#39;)</span>
<span class="gi">+        result = jmespath.search(query, self.root, **kwargs)</span>
<span class="gi">+        if result is None:</span>
<span class="gi">+            return self.selectorlist_cls([])</span>
<span class="gi">+        if not isinstance(result, list):</span>
<span class="gi">+            result = [result]</span>
<span class="gi">+        return self.selectorlist_cls([type(self)(root=r, _expr=query) for r in result])</span>

<span class="w"> </span>    def xpath(self: _SelectorType, query: str, namespaces: Optional[Mapping[str, str]]=None, **kwargs: Any) -&gt; SelectorList[_SelectorType]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -276,7 +344,20 @@ class Selector:</span>

<span class="w"> </span>            selector.xpath(&#39;//a[href=$url]&#39;, url=&quot;http://www.example.com&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;XPath expressions cannot be applied to JSON data&#39;)</span>
<span class="gi">+        if namespaces is not None:</span>
<span class="gi">+            namespaces = dict(self.namespaces, **namespaces)</span>
<span class="gi">+        else:</span>
<span class="gi">+            namespaces = self.namespaces</span>
<span class="gi">+        try:</span>
<span class="gi">+            xpathev = self.root.xpath</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return self.selectorlist_cls([])</span>
<span class="gi">+        result = xpathev(query, namespaces=namespaces, smart_strings=self._lxml_smart_strings, **kwargs)</span>
<span class="gi">+        if not isinstance(result, list):</span>
<span class="gi">+            result = [result]</span>
<span class="gi">+        return self.selectorlist_cls([type(self)(root=r, _expr=query) for r in result])</span>

<span class="w"> </span>    def css(self: _SelectorType, query: str) -&gt; SelectorList[_SelectorType]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -289,7 +370,10 @@ class Selector:</span>

<span class="w"> </span>        .. _cssselect: https://pypi.python.org/pypi/cssselect/
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;CSS expressions cannot be applied to JSON data&#39;)</span>
<span class="gi">+        xpath = _ctgroup[self.type or &#39;html&#39;][&#39;_csstranslator&#39;].css_to_xpath(query)</span>
<span class="gi">+        return self.xpath(xpath)</span>

<span class="w"> </span>    def re(self, regex: Union[str, Pattern[str]], replace_entities: bool=True) -&gt; List[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -304,7 +388,7 @@ class Selector:</span>
<span class="w"> </span>        Passing ``replace_entities`` as ``False`` switches off these
<span class="w"> </span>        replacements.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return extract_regex(regex, self.get(), replace_entities=replace_entities)</span>

<span class="w"> </span>    def re_first(self, regex: Union[str, Pattern[str]], default: Optional[str]=None, replace_entities: bool=True) -&gt; Optional[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -317,7 +401,10 @@ class Selector:</span>
<span class="w"> </span>        Passing ``replace_entities`` as ``False`` switches off these
<span class="w"> </span>        replacements.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = self.re(regex, replace_entities=replace_entities)</span>
<span class="gi">+        if matches:</span>
<span class="gi">+            return matches[0]</span>
<span class="gi">+        return default</span>

<span class="w"> </span>    def get(self) -&gt; Any:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -326,14 +413,36 @@ class Selector:</span>
<span class="w"> </span>        For HTML and XML, the result is always a string, and percent-encoded
<span class="w"> </span>        content is unquoted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            return self.root</span>
<span class="gi">+        elif self.type == &#39;text&#39;:</span>
<span class="gi">+            return str(self.root)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                method = _ctgroup[self.type or &#39;html&#39;][&#39;_tostring_method&#39;]</span>
<span class="gi">+                if isinstance(self.root, etree._Element):</span>
<span class="gi">+                    return etree.tostring(self.root, method=method, encoding=&#39;unicode&#39;, with_tail=False)</span>
<span class="gi">+                elif isinstance(self.root, bool):</span>
<span class="gi">+                    return str(self.root)</span>
<span class="gi">+                elif isinstance(self.root, str):</span>
<span class="gi">+                    return self.root</span>
<span class="gi">+                elif self.root is None:</span>
<span class="gi">+                    return &#39;&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return str(self.root)</span>
<span class="gi">+            except (AttributeError, TypeError):</span>
<span class="gi">+                if self.root is True or self.root is False:</span>
<span class="gi">+                    return str(self.root)</span>
<span class="gi">+                if isinstance(self.root, str):</span>
<span class="gi">+                    return self.root</span>
<span class="gi">+                return &#39;&#39;</span>
<span class="w"> </span>    extract = get

<span class="w"> </span>    def getall(self) -&gt; List[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Serialize and return the matched node in a 1-element list of strings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [self.get()]</span>

<span class="w"> </span>    def register_namespace(self, prefix: str, uri: str) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -341,31 +450,76 @@ class Selector:</span>
<span class="w"> </span>        Without registering namespaces you can&#39;t select or extract data from
<span class="w"> </span>        non-standard namespaces. See :ref:`selector-examples-xml`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.namespaces[prefix] = uri</span>

<span class="w"> </span>    def remove_namespaces(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove all namespaces, allowing to traverse the document using
<span class="w"> </span>        namespace-less xpaths. See :ref:`removing-namespaces`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;Namespaces cannot be removed from JSON data&#39;)</span>
<span class="gi">+        if self.type == &#39;text&#39;:</span>
<span class="gi">+            raise ValueError(&#39;Namespaces cannot be removed from text data&#39;)</span>
<span class="gi">+        if not isinstance(self.root, etree._Element):</span>
<span class="gi">+            raise ValueError(&#39;Cannot remove namespaces from non-XML/HTML data&#39;)</span>
<span class="gi">+        for el in self.root.iter(&#39;*&#39;):</span>
<span class="gi">+            if el.tag.startswith(&#39;{&#39;):</span>
<span class="gi">+                el.tag = el.tag.split(&#39;}&#39;, 1)[1]</span>
<span class="gi">+            for at in list(el.attrib):</span>
<span class="gi">+                if at.startswith(&#39;{&#39;):</span>
<span class="gi">+                    new_at = at.split(&#39;}&#39;, 1)[1]</span>
<span class="gi">+                    el.attrib[new_at] = el.attrib.pop(at)</span>

<span class="w"> </span>    def remove(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove matched nodes from the parent element.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;Cannot remove nodes from JSON data&#39;)</span>
<span class="gi">+        if self.type == &#39;text&#39;:</span>
<span class="gi">+            raise ValueError(&#39;Cannot remove nodes from text data&#39;)</span>
<span class="gi">+        if self.root is None:</span>
<span class="gi">+            raise CannotRemoveElementWithoutRoot(&#39;Element has no root&#39;)</span>
<span class="gi">+        if not isinstance(self.root, etree._Element):</span>
<span class="gi">+            raise CannotRemoveElementWithoutRoot(&#39;Element has no root&#39;)</span>
<span class="gi">+        parent = self.root.getparent()</span>
<span class="gi">+        if parent is None:</span>
<span class="gi">+            raise CannotRemoveElementWithoutParent(&#39;Element has no parent&#39;)</span>
<span class="gi">+        parent.remove(self.root)</span>

<span class="w"> </span>    def drop(self) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Drop matched nodes from the parent element.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;Cannot drop nodes from JSON data&#39;)</span>
<span class="gi">+        if self.type == &#39;text&#39;:</span>
<span class="gi">+            raise ValueError(&#39;Cannot drop nodes from text data&#39;)</span>
<span class="gi">+        if self.root is None:</span>
<span class="gi">+            raise CannotDropElementWithoutParent(&#39;Element has no root&#39;)</span>
<span class="gi">+        if not isinstance(self.root, etree._Element):</span>
<span class="gi">+            raise CannotDropElementWithoutRoot(&#39;Element has no root&#39;)</span>
<span class="gi">+        parent = self.root.getparent()</span>
<span class="gi">+        if parent is None:</span>
<span class="gi">+            raise CannotDropElementWithoutParent(&#39;Element has no parent&#39;)</span>
<span class="gi">+        if self.root.tail is not None:</span>
<span class="gi">+            prev = self.root.getprevious()</span>
<span class="gi">+            if prev is None:</span>
<span class="gi">+                parent.text = (parent.text or &#39;&#39;) + self.root.tail</span>
<span class="gi">+            else:</span>
<span class="gi">+                prev.tail = (prev.tail or &#39;&#39;) + self.root.tail</span>
<span class="gi">+        parent.remove(self.root)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def attrib(self) -&gt; Dict[str, str]:
<span class="w"> </span>        &quot;&quot;&quot;Return the attributes dictionary for underlying element.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type == &#39;json&#39;:</span>
<span class="gi">+            raise ValueError(&#39;JSON objects do not have attributes&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return dict(self.root.attrib)</span>
<span class="gi">+        except (AttributeError, TypeError):</span>
<span class="gi">+            return {}</span>

<span class="w"> </span>    def __bool__(self) -&gt; bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/parsel/utils.py b/parsel/utils.py</span>
<span class="gh">index e0c96da..142e11b 100644</span>
<span class="gd">--- a/parsel/utils.py</span>
<span class="gi">+++ b/parsel/utils.py</span>
<span class="gu">@@ -17,12 +17,16 @@ def flatten(x: Iterable[Any]) -&gt; List[Any]:</span>
<span class="w"> </span>    &gt;&gt;&gt; flatten([&quot;foo&quot;, [&quot;baz&quot;, 42], &quot;bar&quot;])
<span class="w"> </span>    [&#39;foo&#39;, &#39;baz&#39;, 42, &#39;bar&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(iflatten(x))</span>

<span class="w"> </span>def iflatten(x: Iterable[Any]) -&gt; Iterator[Any]:
<span class="w"> </span>    &quot;&quot;&quot;iflatten(sequence) -&gt; Iterator
<span class="w"> </span>    Similar to ``.flatten()``, but returns iterator instead&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for el in x:</span>
<span class="gi">+        if _is_listlike(el):</span>
<span class="gi">+            yield from iflatten(el)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield el</span>

<span class="w"> </span>def _is_listlike(x: Any) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -45,7 +49,7 @@ def _is_listlike(x: Any) -&gt; bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; _is_listlike(range(5))
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(x, &#39;__iter__&#39;) and not isinstance(x, (str, bytes))</span>

<span class="w"> </span>def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities: bool=True) -&gt; List[str]:
<span class="w"> </span>    &quot;&quot;&quot;Extract a list of strings from the given text/encoding using the following policies:
<span class="gu">@@ -53,8 +57,34 @@ def extract_regex(regex: Union[str, Pattern[str]], text: str, replace_entities:</span>
<span class="w"> </span>    * if the regex contains multiple numbered groups, all those will be returned (flattened)
<span class="w"> </span>    * if the regex doesn&#39;t contain any group the entire regex matching is returned
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not text:</span>
<span class="gi">+        return []</span>
<span class="gi">+    if replace_entities:</span>
<span class="gi">+        text = w3lib_replace_entities(text, keep_entities=True)</span>
<span class="gi">+    if isinstance(regex, str):</span>
<span class="gi">+        regex = re.compile(regex)</span>
<span class="gi">+    ret: List[str] = []</span>
<span class="gi">+    for match in regex.finditer(text):</span>
<span class="gi">+        if &#39;extract&#39; in match.groupdict():</span>
<span class="gi">+            ret.append(cast(str, match.group(&#39;extract&#39;)))</span>
<span class="gi">+        elif len(match.groups()) &gt; 0:</span>
<span class="gi">+            ret.extend(filter(None, match.groups()))</span>
<span class="gi">+        else:</span>
<span class="gi">+            ret.append(match.group())</span>
<span class="gi">+    return ret</span>

<span class="w"> </span>def shorten(text: str, width: int, suffix: str=&#39;...&#39;) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Truncate the given text to fit in the given width.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if width &lt;= 0:</span>
<span class="gi">+        raise ValueError(&#39;Width must be greater than 0&#39;)</span>
<span class="gi">+    if len(text) &lt;= width:</span>
<span class="gi">+        return text</span>
<span class="gi">+    if width &lt;= len(suffix):</span>
<span class="gi">+        return text[:width]</span>
<span class="gi">+    if width == 1:</span>
<span class="gi">+        return &#39;.&#39;</span>
<span class="gi">+    if width == 2:</span>
<span class="gi">+        return &#39;..&#39;</span>
<span class="gi">+    if width == 3:</span>
<span class="gi">+        return &#39;...&#39;</span>
<span class="gi">+    return text[:width - len(suffix)] + suffix</span>
\ No newline at end of file
<span class="gh">diff --git a/parsel/xpathfuncs.py b/parsel/xpathfuncs.py</span>
<span class="gh">index 9f5c742..da420c2 100644</span>
<span class="gd">--- a/parsel/xpathfuncs.py</span>
<span class="gi">+++ b/parsel/xpathfuncs.py</span>
<span class="gu">@@ -5,6 +5,10 @@ from w3lib.html import HTML5_WHITESPACE</span>
<span class="w"> </span>regex = f&#39;[{HTML5_WHITESPACE}]+&#39;
<span class="w"> </span>replace_html5_whitespaces = re.compile(regex).sub

<span class="gi">+def setup() -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Register built-in XPath extension functions.&quot;&quot;&quot;</span>
<span class="gi">+    set_xpathfunc(&quot;has-class&quot;, has_class)</span>
<span class="gi">+</span>
<span class="w"> </span>def set_xpathfunc(fname: str, func: Optional[Callable]) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Register a custom extension function to use in XPath expressions.

<span class="gu">@@ -19,7 +23,11 @@ def set_xpathfunc(fname: str, func: Optional[Callable]) -&gt; None:</span>
<span class="w"> </span>    .. _`in lxml documentation`: https://lxml.de/extensions.html#xpath-extension-functions

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ns = etree.FunctionNamespace(None)</span>
<span class="gi">+    if func is None:</span>
<span class="gi">+        del ns[fname]</span>
<span class="gi">+    else:</span>
<span class="gi">+        ns[fname] = func</span>

<span class="w"> </span>def has_class(context: Any, *classes: str) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;has-class function.
<span class="gu">@@ -27,4 +35,21 @@ def has_class(context: Any, *classes: str) -&gt; bool:</span>
<span class="w"> </span>    Return True if all ``classes`` are present in element&#39;s class attr.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if not classes:</span>
<span class="gi">+        raise ValueError(&quot;has-class must have at least 1 argument&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for class_ in classes:</span>
<span class="gi">+        if not isinstance(class_, str):</span>
<span class="gi">+            raise ValueError(&quot;has-class arguments must be strings&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            class_.encode(&#39;ascii&#39;)</span>
<span class="gi">+        except UnicodeEncodeError:</span>
<span class="gi">+            raise ValueError(&quot;All strings must be XML compatible&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    element = context.context_node</span>
<span class="gi">+    class_attr = element.get(&#39;class&#39;, &#39;&#39;).strip()</span>
<span class="gi">+    if not class_attr:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    element_classes = set(replace_html5_whitespaces(&#39; &#39;, class_attr).split())</span>
<span class="gi">+    return all(class_ in element_classes for class_ in classes)</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>