
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference dnspython - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-dnspython" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference dnspython
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-dnspython"><strong>Reference (Gold)</strong>: dnspython</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1308</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">37</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1345</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1345</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/dns/_asyncbackend.py b/dns/_asyncbackend.py</span>
<span class="gh">index eba0ba6..49f14fe 100644</span>
<span class="gd">--- a/dns/_asyncbackend.py</span>
<span class="gi">+++ b/dns/_asyncbackend.py</span>
<span class="gu">@@ -1,5 +1,10 @@</span>
<span class="gd">-class NullContext:</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# This is a nullcontext for both sync and async.  3.7 has a nullcontext,</span>
<span class="gi">+# but it is only for sync use.</span>

<span class="gi">+</span>
<span class="gi">+class NullContext:</span>
<span class="w"> </span>    def __init__(self, enter_result=None):
<span class="w"> </span>        self.enter_result = enter_result

<span class="gu">@@ -16,7 +21,22 @@ class NullContext:</span>
<span class="w"> </span>        pass


<span class="gd">-class Socket:</span>
<span class="gi">+# These are declared here so backends can import them without creating</span>
<span class="gi">+# circular dependencies with dns.asyncbackend.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Socket:  # pragma: no cover</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeercert(self, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    async def __aenter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -25,19 +45,55 @@ class Socket:</span>
<span class="w"> </span>        await self.close()


<span class="gd">-class DatagramSocket(Socket):</span>
<span class="gd">-</span>
<span class="gi">+class DatagramSocket(Socket):  # pragma: no cover</span>
<span class="w"> </span>    def __init__(self, family: int):
<span class="w"> </span>        self.family = family

<span class="gi">+    async def sendto(self, what, destination, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-class StreamSocket(Socket):</span>
<span class="gd">-    pass</span>
<span class="gi">+    async def recvfrom(self, size, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-class NullTransport:</span>
<span class="gd">-    pass</span>
<span class="gi">+class StreamSocket(Socket):  # pragma: no cover</span>
<span class="gi">+    async def sendall(self, what, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def recv(self, size, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-class Backend:</span>
<span class="gd">-    pass</span>
<span class="gi">+class NullTransport:</span>
<span class="gi">+    async def connect_tcp(self, host, port, timeout, local_address):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Backend:  # pragma: no cover</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return &quot;unknown&quot;</span>
<span class="gi">+</span>
<span class="gi">+    async def make_socket(</span>
<span class="gi">+        self,</span>
<span class="gi">+        af,</span>
<span class="gi">+        socktype,</span>
<span class="gi">+        proto=0,</span>
<span class="gi">+        source=None,</span>
<span class="gi">+        destination=None,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        ssl_context=None,</span>
<span class="gi">+        server_hostname=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def datagram_connection_required(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    async def sleep(self, interval):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def get_transport_class(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def wait_for(self, awaitable, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/dns/_asyncio_backend.py b/dns/_asyncio_backend.py</span>
<span class="gh">index 6b61355..9d9ed36 100644</span>
<span class="gd">--- a/dns/_asyncio_backend.py</span>
<span class="gi">+++ b/dns/_asyncio_backend.py</span>
<span class="gu">@@ -1,49 +1,140 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;asyncio library query support&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import socket
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import dns._asyncbackend
<span class="w"> </span>import dns._features
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="gd">-_is_win32 = sys.platform == &#39;win32&#39;</span>

<span class="gi">+_is_win32 = sys.platform == &quot;win32&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_running_loop():</span>
<span class="gi">+    try:</span>
<span class="gi">+        return asyncio.get_running_loop()</span>
<span class="gi">+    except AttributeError:  # pragma: no cover</span>
<span class="gi">+        return asyncio.get_event_loop()</span>

<span class="gd">-class _DatagramProtocol:</span>

<span class="gi">+class _DatagramProtocol:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.transport = None
<span class="w"> </span>        self.recvfrom = None

<span class="gi">+    def connection_made(self, transport):</span>
<span class="gi">+        self.transport = transport</span>

<span class="gd">-class DatagramSocket(dns._asyncbackend.DatagramSocket):</span>
<span class="gi">+    def datagram_received(self, data, addr):</span>
<span class="gi">+        if self.recvfrom and not self.recvfrom.done():</span>
<span class="gi">+            self.recvfrom.set_result((data, addr))</span>
<span class="gi">+</span>
<span class="gi">+    def error_received(self, exc):  # pragma: no cover</span>
<span class="gi">+        if self.recvfrom and not self.recvfrom.done():</span>
<span class="gi">+            self.recvfrom.set_exception(exc)</span>
<span class="gi">+</span>
<span class="gi">+    def connection_lost(self, exc):</span>
<span class="gi">+        if self.recvfrom and not self.recvfrom.done():</span>
<span class="gi">+            if exc is None:</span>
<span class="gi">+                # EOF we triggered.  Is there a better way to do this?</span>
<span class="gi">+                try:</span>
<span class="gi">+                    raise EOFError</span>
<span class="gi">+                except EOFError as e:</span>
<span class="gi">+                    self.recvfrom.set_exception(e)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.recvfrom.set_exception(exc)</span>

<span class="gi">+    def close(self):</span>
<span class="gi">+        self.transport.close()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def _maybe_wait_for(awaitable, timeout):</span>
<span class="gi">+    if timeout is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return await asyncio.wait_for(awaitable, timeout)</span>
<span class="gi">+        except asyncio.TimeoutError:</span>
<span class="gi">+            raise dns.exception.Timeout(timeout=timeout)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return await awaitable</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class DatagramSocket(dns._asyncbackend.DatagramSocket):</span>
<span class="w"> </span>    def __init__(self, family, transport, protocol):
<span class="w"> </span>        super().__init__(family)
<span class="w"> </span>        self.transport = transport
<span class="w"> </span>        self.protocol = protocol

<span class="gi">+    async def sendto(self, what, destination, timeout):  # pragma: no cover</span>
<span class="gi">+        # no timeout for asyncio sendto</span>
<span class="gi">+        self.transport.sendto(what, destination)</span>
<span class="gi">+        return len(what)</span>
<span class="gi">+</span>
<span class="gi">+    async def recvfrom(self, size, timeout):</span>
<span class="gi">+        # ignore size as there&#39;s no way I know to tell protocol about it</span>
<span class="gi">+        done = _get_running_loop().create_future()</span>
<span class="gi">+        try:</span>
<span class="gi">+            assert self.protocol.recvfrom is None</span>
<span class="gi">+            self.protocol.recvfrom = done</span>
<span class="gi">+            await _maybe_wait_for(done, timeout)</span>
<span class="gi">+            return done.result()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.protocol.recvfrom = None</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self.protocol.close()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        return self.transport.get_extra_info(&quot;peername&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        return self.transport.get_extra_info(&quot;sockname&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeercert(self, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-class StreamSocket(dns._asyncbackend.StreamSocket):</span>

<span class="gi">+class StreamSocket(dns._asyncbackend.StreamSocket):</span>
<span class="w"> </span>    def __init__(self, af, reader, writer):
<span class="w"> </span>        self.family = af
<span class="w"> </span>        self.reader = reader
<span class="w"> </span>        self.writer = writer

<span class="gi">+    async def sendall(self, what, timeout):</span>
<span class="gi">+        self.writer.write(what)</span>
<span class="gi">+        return await _maybe_wait_for(self.writer.drain(), timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def recv(self, size, timeout):</span>
<span class="gi">+        return await _maybe_wait_for(self.reader.read(size), timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self.writer.close()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        return self.writer.get_extra_info(&quot;peername&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        return self.writer.get_extra_info(&quot;sockname&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeercert(self, timeout):</span>
<span class="gi">+        return self.writer.get_extra_info(&quot;peercert&quot;)</span>

<span class="gd">-if dns._features.have(&#39;doh&#39;):</span>
<span class="gi">+</span>
<span class="gi">+if dns._features.have(&quot;doh&quot;):</span>
<span class="w"> </span>    import anyio
<span class="w"> </span>    import httpcore
<span class="w"> </span>    import httpcore._backends.anyio
<span class="w"> </span>    import httpx
<span class="gi">+</span>
<span class="w"> </span>    _CoreAsyncNetworkBackend = httpcore.AsyncNetworkBackend
<span class="w"> </span>    _CoreAnyIOStream = httpcore._backends.anyio.AnyIOStream
<span class="gd">-    from dns.query import _compute_times, _expiration_for_this_attempt, _remaining</span>

<span class="gi">+    from dns.query import _compute_times, _expiration_for_this_attempt, _remaining</span>

<span class="w"> </span>    class _NetworkBackend(_CoreAsyncNetworkBackend):
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self, resolver, local_port, bootstrap_address, family):
<span class="w"> </span>            super().__init__()
<span class="w"> </span>            self._local_port = local_port
<span class="gu">@@ -52,23 +143,133 @@ if dns._features.have(&#39;doh&#39;):</span>
<span class="w"> </span>            self._family = family
<span class="w"> </span>            if local_port != 0:
<span class="w"> </span>                raise NotImplementedError(
<span class="gd">-                    &#39;the asyncio transport for HTTPX cannot set the local port&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    &quot;the asyncio transport for HTTPX cannot set the local port&quot;</span>
<span class="gi">+                )</span>

<span class="gi">+        async def connect_tcp(</span>
<span class="gi">+            self, host, port, timeout, local_address, socket_options=None</span>
<span class="gi">+        ):  # pylint: disable=signature-differs</span>
<span class="gi">+            addresses = []</span>
<span class="gi">+            _, expiration = _compute_times(timeout)</span>
<span class="gi">+            if dns.inet.is_address(host):</span>
<span class="gi">+                addresses.append(host)</span>
<span class="gi">+            elif self._bootstrap_address is not None:</span>
<span class="gi">+                addresses.append(self._bootstrap_address)</span>
<span class="gi">+            else:</span>
<span class="gi">+                timeout = _remaining(expiration)</span>
<span class="gi">+                family = self._family</span>
<span class="gi">+                if local_address:</span>
<span class="gi">+                    family = dns.inet.af_for_address(local_address)</span>
<span class="gi">+                answers = await self._resolver.resolve_name(</span>
<span class="gi">+                    host, family=family, lifetime=timeout</span>
<span class="gi">+                )</span>
<span class="gi">+                addresses = answers.addresses()</span>
<span class="gi">+            for address in addresses:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    attempt_expiration = _expiration_for_this_attempt(2.0, expiration)</span>
<span class="gi">+                    timeout = _remaining(attempt_expiration)</span>
<span class="gi">+                    with anyio.fail_after(timeout):</span>
<span class="gi">+                        stream = await anyio.connect_tcp(</span>
<span class="gi">+                            remote_host=address,</span>
<span class="gi">+                            remote_port=port,</span>
<span class="gi">+                            local_host=local_address,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    return _CoreAnyIOStream(stream)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            raise httpcore.ConnectError</span>

<span class="gd">-    class _HTTPTransport(httpx.AsyncHTTPTransport):</span>
<span class="gi">+        async def connect_unix_socket(</span>
<span class="gi">+            self, path, timeout, socket_options=None</span>
<span class="gi">+        ):  # pylint: disable=signature-differs</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+        async def sleep(self, seconds):  # pylint: disable=signature-differs</span>
<span class="gi">+            await anyio.sleep(seconds)</span>

<span class="gd">-        def __init__(self, *args, local_port=0, bootstrap_address=None,</span>
<span class="gd">-            resolver=None, family=socket.AF_UNSPEC, **kwargs):</span>
<span class="gi">+    class _HTTPTransport(httpx.AsyncHTTPTransport):</span>
<span class="gi">+        def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            local_port=0,</span>
<span class="gi">+            bootstrap_address=None,</span>
<span class="gi">+            resolver=None,</span>
<span class="gi">+            family=socket.AF_UNSPEC,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            if resolver is None:
<span class="gi">+                # pylint: disable=import-outside-toplevel,redefined-outer-name</span>
<span class="w"> </span>                import dns.asyncresolver
<span class="gi">+</span>
<span class="w"> </span>                resolver = dns.asyncresolver.Resolver()
<span class="w"> </span>            super().__init__(*args, **kwargs)
<span class="gd">-            self._pool._network_backend = _NetworkBackend(resolver,</span>
<span class="gd">-                local_port, bootstrap_address, family)</span>
<span class="gi">+            self._pool._network_backend = _NetworkBackend(</span>
<span class="gi">+                resolver, local_port, bootstrap_address, family</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    _HTTPTransport = dns._asyncbackend.NullTransport</span>
<span class="gi">+    _HTTPTransport = dns._asyncbackend.NullTransport  # type: ignore</span>


<span class="w"> </span>class Backend(dns._asyncbackend.Backend):
<span class="gd">-    pass</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return &quot;asyncio&quot;</span>
<span class="gi">+</span>
<span class="gi">+    async def make_socket(</span>
<span class="gi">+        self,</span>
<span class="gi">+        af,</span>
<span class="gi">+        socktype,</span>
<span class="gi">+        proto=0,</span>
<span class="gi">+        source=None,</span>
<span class="gi">+        destination=None,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        ssl_context=None,</span>
<span class="gi">+        server_hostname=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        loop = _get_running_loop()</span>
<span class="gi">+        if socktype == socket.SOCK_DGRAM:</span>
<span class="gi">+            if _is_win32 and source is None:</span>
<span class="gi">+                # Win32 wants explicit binding before recvfrom().  This is the</span>
<span class="gi">+                # proper fix for [#637].</span>
<span class="gi">+                source = (dns.inet.any_for_af(af), 0)</span>
<span class="gi">+            transport, protocol = await loop.create_datagram_endpoint(</span>
<span class="gi">+                _DatagramProtocol,</span>
<span class="gi">+                source,</span>
<span class="gi">+                family=af,</span>
<span class="gi">+                proto=proto,</span>
<span class="gi">+                remote_addr=destination,</span>
<span class="gi">+            )</span>
<span class="gi">+            return DatagramSocket(af, transport, protocol)</span>
<span class="gi">+        elif socktype == socket.SOCK_STREAM:</span>
<span class="gi">+            if destination is None:</span>
<span class="gi">+                # This shouldn&#39;t happen, but we check to make code analysis software</span>
<span class="gi">+                # happier.</span>
<span class="gi">+                raise ValueError(&quot;destination required for stream sockets&quot;)</span>
<span class="gi">+            (r, w) = await _maybe_wait_for(</span>
<span class="gi">+                asyncio.open_connection(</span>
<span class="gi">+                    destination[0],</span>
<span class="gi">+                    destination[1],</span>
<span class="gi">+                    ssl=ssl_context,</span>
<span class="gi">+                    family=af,</span>
<span class="gi">+                    proto=proto,</span>
<span class="gi">+                    local_addr=source,</span>
<span class="gi">+                    server_hostname=server_hostname,</span>
<span class="gi">+                ),</span>
<span class="gi">+                timeout,</span>
<span class="gi">+            )</span>
<span class="gi">+            return StreamSocket(af, r, w)</span>
<span class="gi">+        raise NotImplementedError(</span>
<span class="gi">+            &quot;unsupported socket &quot; + f&quot;type {socktype}&quot;</span>
<span class="gi">+        )  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    async def sleep(self, interval):</span>
<span class="gi">+        await asyncio.sleep(interval)</span>
<span class="gi">+</span>
<span class="gi">+    def datagram_connection_required(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def get_transport_class(self):</span>
<span class="gi">+        return _HTTPTransport</span>
<span class="gi">+</span>
<span class="gi">+    async def wait_for(self, awaitable, timeout):</span>
<span class="gi">+        return await _maybe_wait_for(awaitable, timeout)</span>
<span class="gh">diff --git a/dns/_ddr.py b/dns/_ddr.py</span>
<span class="gh">index f03d10e..bf5c11e 100644</span>
<span class="gd">--- a/dns/_ddr.py</span>
<span class="gi">+++ b/dns/_ddr.py</span>
<span class="gu">@@ -1,17 +1,29 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+#</span>
<span class="gi">+# Support for Discovery of Designated Resolvers</span>
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import time
<span class="w"> </span>from urllib.parse import urlparse
<span class="gi">+</span>
<span class="w"> </span>import dns.asyncbackend
<span class="w"> </span>import dns.inet
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.nameserver
<span class="w"> </span>import dns.query
<span class="w"> </span>import dns.rdtypes.svcbbase
<span class="gd">-_local_resolver_name = dns.name.from_text(&#39;_dns.resolver.arpa&#39;)</span>

<span class="gi">+# The special name of the local resolver when using DDR</span>
<span class="gi">+_local_resolver_name = dns.name.from_text(&quot;_dns.resolver.arpa&quot;)</span>

<span class="gd">-class _SVCBInfo:</span>

<span class="gi">+#</span>
<span class="gi">+# Processing is split up into I/O independent and I/O dependent parts to</span>
<span class="gi">+# make supporting sync and async versions easy.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _SVCBInfo:</span>
<span class="w"> </span>    def __init__(self, bootstrap_address, port, hostname, nameservers):
<span class="w"> </span>        self.bootstrap_address = bootstrap_address
<span class="w"> </span>        self.port = port
<span class="gu">@@ -20,16 +32,123 @@ class _SVCBInfo:</span>

<span class="w"> </span>    def ddr_check_certificate(self, cert):
<span class="w"> </span>        &quot;&quot;&quot;Verify that the _SVCBInfo&#39;s address is in the cert&#39;s subjectAltName (SAN)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, value in cert[&quot;subjectAltName&quot;]:</span>
<span class="gi">+            if name == &quot;IP Address&quot; and value == self.bootstrap_address:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def make_tls_context(self):</span>
<span class="gi">+        ssl = dns.query.ssl</span>
<span class="gi">+        ctx = ssl.create_default_context()</span>
<span class="gi">+        ctx.minimum_version = ssl.TLSVersion.TLSv1_2</span>
<span class="gi">+        return ctx</span>
<span class="gi">+</span>
<span class="gi">+    def ddr_tls_check_sync(self, lifetime):</span>
<span class="gi">+        ctx = self.make_tls_context()</span>
<span class="gi">+        expiration = time.time() + lifetime</span>
<span class="gi">+        with socket.create_connection(</span>
<span class="gi">+            (self.bootstrap_address, self.port), lifetime</span>
<span class="gi">+        ) as s:</span>
<span class="gi">+            with ctx.wrap_socket(s, server_hostname=self.hostname) as ts:</span>
<span class="gi">+                ts.settimeout(dns.query._remaining(expiration))</span>
<span class="gi">+                ts.do_handshake()</span>
<span class="gi">+                cert = ts.getpeercert()</span>
<span class="gi">+                return self.ddr_check_certificate(cert)</span>
<span class="gi">+</span>
<span class="gi">+    async def ddr_tls_check_async(self, lifetime, backend=None):</span>
<span class="gi">+        if backend is None:</span>
<span class="gi">+            backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+        ctx = self.make_tls_context()</span>
<span class="gi">+        expiration = time.time() + lifetime</span>
<span class="gi">+        async with await backend.make_socket(</span>
<span class="gi">+            dns.inet.af_for_address(self.bootstrap_address),</span>
<span class="gi">+            socket.SOCK_STREAM,</span>
<span class="gi">+            0,</span>
<span class="gi">+            None,</span>
<span class="gi">+            (self.bootstrap_address, self.port),</span>
<span class="gi">+            lifetime,</span>
<span class="gi">+            ctx,</span>
<span class="gi">+            self.hostname,</span>
<span class="gi">+        ) as ts:</span>
<span class="gi">+            cert = await ts.getpeercert(dns.query._remaining(expiration))</span>
<span class="gi">+            return self.ddr_check_certificate(cert)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _extract_nameservers_from_svcb(answer):</span>
<span class="gi">+    bootstrap_address = answer.nameserver</span>
<span class="gi">+    if not dns.inet.is_address(bootstrap_address):</span>
<span class="gi">+        return []</span>
<span class="gi">+    infos = []</span>
<span class="gi">+    for rr in answer.rrset.processing_order():</span>
<span class="gi">+        nameservers = []</span>
<span class="gi">+        param = rr.params.get(dns.rdtypes.svcbbase.ParamKey.ALPN)</span>
<span class="gi">+        if param is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        alpns = set(param.ids)</span>
<span class="gi">+        host = rr.target.to_text(omit_final_dot=True)</span>
<span class="gi">+        port = None</span>
<span class="gi">+        param = rr.params.get(dns.rdtypes.svcbbase.ParamKey.PORT)</span>
<span class="gi">+        if param is not None:</span>
<span class="gi">+            port = param.port</span>
<span class="gi">+        # For now we ignore address hints and address resolution and always use the</span>
<span class="gi">+        # bootstrap address</span>
<span class="gi">+        if b&quot;h2&quot; in alpns:</span>
<span class="gi">+            param = rr.params.get(dns.rdtypes.svcbbase.ParamKey.DOHPATH)</span>
<span class="gi">+            if param is None or not param.value.endswith(b&quot;{?dns}&quot;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            path = param.value[:-6].decode()</span>
<span class="gi">+            if not path.startswith(&quot;/&quot;):</span>
<span class="gi">+                path = &quot;/&quot; + path</span>
<span class="gi">+            if port is None:</span>
<span class="gi">+                port = 443</span>
<span class="gi">+            url = f&quot;https://{host}:{port}{path}&quot;</span>
<span class="gi">+            # check the URL</span>
<span class="gi">+            try:</span>
<span class="gi">+                urlparse(url)</span>
<span class="gi">+                nameservers.append(dns.nameserver.DoHNameserver(url, bootstrap_address))</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                # continue processing other ALPN types</span>
<span class="gi">+                pass</span>
<span class="gi">+        if b&quot;dot&quot; in alpns:</span>
<span class="gi">+            if port is None:</span>
<span class="gi">+                port = 853</span>
<span class="gi">+            nameservers.append(</span>
<span class="gi">+                dns.nameserver.DoTNameserver(bootstrap_address, port, host)</span>
<span class="gi">+            )</span>
<span class="gi">+        if b&quot;doq&quot; in alpns:</span>
<span class="gi">+            if port is None:</span>
<span class="gi">+                port = 853</span>
<span class="gi">+            nameservers.append(</span>
<span class="gi">+                dns.nameserver.DoQNameserver(bootstrap_address, port, True, host)</span>
<span class="gi">+            )</span>
<span class="gi">+        if len(nameservers) &gt; 0:</span>
<span class="gi">+            infos.append(_SVCBInfo(bootstrap_address, port, host, nameservers))</span>
<span class="gi">+    return infos</span>


<span class="w"> </span>def _get_nameservers_sync(answer, lifetime):
<span class="w"> </span>    &quot;&quot;&quot;Return a list of TLS-validated resolver nameservers extracted from an SVCB
<span class="w"> </span>    answer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nameservers = []</span>
<span class="gi">+    infos = _extract_nameservers_from_svcb(answer)</span>
<span class="gi">+    for info in infos:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if info.ddr_tls_check_sync(lifetime):</span>
<span class="gi">+                nameservers.extend(info.nameservers)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return nameservers</span>


<span class="w"> </span>async def _get_nameservers_async(answer, lifetime):
<span class="w"> </span>    &quot;&quot;&quot;Return a list of TLS-validated resolver nameservers extracted from an SVCB
<span class="w"> </span>    answer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nameservers = []</span>
<span class="gi">+    infos = _extract_nameservers_from_svcb(answer)</span>
<span class="gi">+    for info in infos:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if await info.ddr_tls_check_async(lifetime):</span>
<span class="gi">+                nameservers.extend(info.nameservers)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return nameservers</span>
<span class="gh">diff --git a/dns/_features.py b/dns/_features.py</span>
<span class="gh">index bb537c8..03ccaa7 100644</span>
<span class="gd">--- a/dns/_features.py</span>
<span class="gi">+++ b/dns/_features.py</span>
<span class="gu">@@ -1,23 +1,50 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import importlib.metadata
<span class="w"> </span>import itertools
<span class="w"> </span>import string
<span class="w"> </span>from typing import Dict, List, Tuple


<span class="gd">-def _version_check(requirement: str) -&gt;bool:</span>
<span class="gi">+def _tuple_from_text(version: str) -&gt; Tuple:</span>
<span class="gi">+    text_parts = version.split(&quot;.&quot;)</span>
<span class="gi">+    int_parts = []</span>
<span class="gi">+    for text_part in text_parts:</span>
<span class="gi">+        digit_prefix = &quot;&quot;.join(</span>
<span class="gi">+            itertools.takewhile(lambda x: x in string.digits, text_part)</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            int_parts.append(int(digit_prefix))</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            break</span>
<span class="gi">+    return tuple(int_parts)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _version_check(</span>
<span class="gi">+    requirement: str,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the requirement fulfilled?

<span class="w"> </span>    The requirement must be of the form

<span class="w"> </span>        package&gt;=version
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    package, minimum = requirement.split(&quot;&gt;=&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        version = importlib.metadata.version(package)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+    t_version = _tuple_from_text(version)</span>
<span class="gi">+    t_minimum = _tuple_from_text(minimum)</span>
<span class="gi">+    if t_version &lt; t_minimum:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>_cache: Dict[str, bool] = {}


<span class="gd">-def have(feature: str) -&gt;bool:</span>
<span class="gi">+def have(feature: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is *feature* available?

<span class="w"> </span>    This tests if all optional packages needed for the
<span class="gu">@@ -27,19 +54,39 @@ def have(feature: str) -&gt;bool:</span>
<span class="w"> </span>    and ``False`` if it is not or if metadata is
<span class="w"> </span>    missing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = _cache.get(feature)</span>
<span class="gi">+    if value is not None:</span>
<span class="gi">+        return value</span>
<span class="gi">+    requirements = _requirements.get(feature)</span>
<span class="gi">+    if requirements is None:</span>
<span class="gi">+        # we make a cache entry here for consistency not performance</span>
<span class="gi">+        _cache[feature] = False</span>
<span class="gi">+        return False</span>
<span class="gi">+    ok = True</span>
<span class="gi">+    for requirement in requirements:</span>
<span class="gi">+        if not _version_check(requirement):</span>
<span class="gi">+            ok = False</span>
<span class="gi">+            break</span>
<span class="gi">+    _cache[feature] = ok</span>
<span class="gi">+    return ok</span>


<span class="gd">-def force(feature: str, enabled: bool) -&gt;None:</span>
<span class="gi">+def force(feature: str, enabled: bool) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Force the status of *feature* to be *enabled*.

<span class="w"> </span>    This method is provided as a workaround for any cases
<span class="w"> </span>    where importlib.metadata is ineffective, or for testing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _cache[feature] = enabled</span>


<span class="gd">-_requirements: Dict[str, List[str]] = {&#39;dnssec&#39;: [&#39;cryptography&gt;=41&#39;],</span>
<span class="gd">-    &#39;doh&#39;: [&#39;httpcore&gt;=1.0.0&#39;, &#39;httpx&gt;=0.26.0&#39;, &#39;h2&gt;=4.1.0&#39;], &#39;doq&#39;: [</span>
<span class="gd">-    &#39;aioquic&gt;=0.9.25&#39;], &#39;idna&#39;: [&#39;idna&gt;=3.6&#39;], &#39;trio&#39;: [&#39;trio&gt;=0.23&#39;],</span>
<span class="gd">-    &#39;wmi&#39;: [&#39;wmi&gt;=1.5.1&#39;]}</span>
<span class="gi">+_requirements: Dict[str, List[str]] = {</span>
<span class="gi">+    ### BEGIN generated requirements</span>
<span class="gi">+    &quot;dnssec&quot;: [&quot;cryptography&gt;=41&quot;],</span>
<span class="gi">+    &quot;doh&quot;: [&quot;httpcore&gt;=1.0.0&quot;, &quot;httpx&gt;=0.26.0&quot;, &quot;h2&gt;=4.1.0&quot;],</span>
<span class="gi">+    &quot;doq&quot;: [&quot;aioquic&gt;=0.9.25&quot;],</span>
<span class="gi">+    &quot;idna&quot;: [&quot;idna&gt;=3.6&quot;],</span>
<span class="gi">+    &quot;trio&quot;: [&quot;trio&gt;=0.23&quot;],</span>
<span class="gi">+    &quot;wmi&quot;: [&quot;wmi&gt;=1.5.1&quot;],</span>
<span class="gi">+    ### END generated requirements</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/dns/_immutable_ctx.py b/dns/_immutable_ctx.py</span>
<span class="gh">index f0ff108..ae7a33b 100644</span>
<span class="gd">--- a/dns/_immutable_ctx.py</span>
<span class="gi">+++ b/dns/_immutable_ctx.py</span>
<span class="gu">@@ -1,10 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# This implementation of the immutable decorator requires python &gt;=</span>
<span class="gi">+# 3.7, and is significantly more storage efficient when making classes</span>
<span class="gi">+# with slots immutable.  It&#39;s also faster.</span>
<span class="gi">+</span>
<span class="w"> </span>import contextvars
<span class="w"> </span>import inspect
<span class="gd">-_in__init__ = contextvars.ContextVar(&#39;_immutable_in__init__&#39;, default=False)</span>
<span class="gi">+</span>
<span class="gi">+_in__init__ = contextvars.ContextVar(&quot;_immutable_in__init__&quot;, default=False)</span>


<span class="w"> </span>class _Immutable:
<span class="w"> </span>    &quot;&quot;&quot;Immutable mixin class&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # We set slots to the empty list to say &quot;we don&#39;t have any attributes&quot;.</span>
<span class="gi">+    # We do this so that if we&#39;re mixed in with a class with __slots__, we</span>
<span class="gi">+    # don&#39;t cause a __dict__ to be added which would waste space.</span>
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __setattr__(self, name, value):
<span class="gu">@@ -18,3 +30,47 @@ class _Immutable:</span>
<span class="w"> </span>            raise TypeError(&quot;object doesn&#39;t support attribute assignment&quot;)
<span class="w"> </span>        else:
<span class="w"> </span>            super().__delattr__(name)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _immutable_init(f):</span>
<span class="gi">+    def nf(*args, **kwargs):</span>
<span class="gi">+        previous = _in__init__.set(args[0])</span>
<span class="gi">+        try:</span>
<span class="gi">+            # call the actual __init__</span>
<span class="gi">+            f(*args, **kwargs)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            _in__init__.reset(previous)</span>
<span class="gi">+</span>
<span class="gi">+    nf.__signature__ = inspect.signature(f)</span>
<span class="gi">+    return nf</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def immutable(cls):</span>
<span class="gi">+    if _Immutable in cls.__mro__:</span>
<span class="gi">+        # Some ancestor already has the mixin, so just make sure we keep</span>
<span class="gi">+        # following the __init__ protocol.</span>
<span class="gi">+        cls.__init__ = _immutable_init(cls.__init__)</span>
<span class="gi">+        if hasattr(cls, &quot;__setstate__&quot;):</span>
<span class="gi">+            cls.__setstate__ = _immutable_init(cls.__setstate__)</span>
<span class="gi">+        ncls = cls</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Mixin the Immutable class and follow the __init__ protocol.</span>
<span class="gi">+        class ncls(_Immutable, cls):</span>
<span class="gi">+            # We have to do the __slots__ declaration here too!</span>
<span class="gi">+            __slots__ = ()</span>
<span class="gi">+</span>
<span class="gi">+            @_immutable_init</span>
<span class="gi">+            def __init__(self, *args, **kwargs):</span>
<span class="gi">+                super().__init__(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            if hasattr(cls, &quot;__setstate__&quot;):</span>
<span class="gi">+</span>
<span class="gi">+                @_immutable_init</span>
<span class="gi">+                def __setstate__(self, *args, **kwargs):</span>
<span class="gi">+                    super().__setstate__(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # make ncls have the same name and module as cls</span>
<span class="gi">+        ncls.__name__ = cls.__name__</span>
<span class="gi">+        ncls.__qualname__ = cls.__qualname__</span>
<span class="gi">+        ncls.__module__ = cls.__module__</span>
<span class="gi">+    return ncls</span>
<span class="gh">diff --git a/dns/_trio_backend.py b/dns/_trio_backend.py</span>
<span class="gh">index 52268ee..398e327 100644</span>
<span class="gd">--- a/dns/_trio_backend.py</span>
<span class="gi">+++ b/dns/_trio_backend.py</span>
<span class="gu">@@ -1,42 +1,115 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;trio async I/O library query support&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="gi">+</span>
<span class="w"> </span>import trio
<span class="gd">-import trio.socket</span>
<span class="gi">+import trio.socket  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>import dns._asyncbackend
<span class="w"> </span>import dns._features
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="gd">-if not dns._features.have(&#39;trio&#39;):</span>
<span class="gd">-    raise ImportError(&#39;trio not found or too old&#39;)</span>
<span class="gi">+</span>
<span class="gi">+if not dns._features.have(&quot;trio&quot;):</span>
<span class="gi">+    raise ImportError(&quot;trio not found or too old&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _maybe_timeout(timeout):</span>
<span class="gi">+    if timeout is not None:</span>
<span class="gi">+        return trio.move_on_after(timeout)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return dns._asyncbackend.NullContext()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# for brevity</span>
<span class="w"> </span>_lltuple = dns.inet.low_level_address_tuple

<span class="gi">+# pylint: disable=redefined-outer-name</span>

<span class="gd">-class DatagramSocket(dns._asyncbackend.DatagramSocket):</span>

<span class="gi">+class DatagramSocket(dns._asyncbackend.DatagramSocket):</span>
<span class="w"> </span>    def __init__(self, socket):
<span class="w"> </span>        super().__init__(socket.family)
<span class="w"> </span>        self.socket = socket

<span class="gi">+    async def sendto(self, what, destination, timeout):</span>
<span class="gi">+        with _maybe_timeout(timeout):</span>
<span class="gi">+            return await self.socket.sendto(what, destination)</span>
<span class="gi">+        raise dns.exception.Timeout(</span>
<span class="gi">+            timeout=timeout</span>
<span class="gi">+        )  # pragma: no cover  lgtm[py/unreachable-statement]</span>

<span class="gd">-class StreamSocket(dns._asyncbackend.StreamSocket):</span>
<span class="gi">+    async def recvfrom(self, size, timeout):</span>
<span class="gi">+        with _maybe_timeout(timeout):</span>
<span class="gi">+            return await self.socket.recvfrom(size)</span>
<span class="gi">+        raise dns.exception.Timeout(timeout=timeout)  # lgtm[py/unreachable-statement]</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self.socket.close()</span>

<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        return self.socket.getpeername()</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        return self.socket.getsockname()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeercert(self, timeout):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class StreamSocket(dns._asyncbackend.StreamSocket):</span>
<span class="w"> </span>    def __init__(self, family, stream, tls=False):
<span class="w"> </span>        self.family = family
<span class="w"> </span>        self.stream = stream
<span class="w"> </span>        self.tls = tls

<span class="gd">-</span>
<span class="gd">-if dns._features.have(&#39;doh&#39;):</span>
<span class="gi">+    async def sendall(self, what, timeout):</span>
<span class="gi">+        with _maybe_timeout(timeout):</span>
<span class="gi">+            return await self.stream.send_all(what)</span>
<span class="gi">+        raise dns.exception.Timeout(timeout=timeout)  # lgtm[py/unreachable-statement]</span>
<span class="gi">+</span>
<span class="gi">+    async def recv(self, size, timeout):</span>
<span class="gi">+        with _maybe_timeout(timeout):</span>
<span class="gi">+            return await self.stream.receive_some(size)</span>
<span class="gi">+        raise dns.exception.Timeout(timeout=timeout)  # lgtm[py/unreachable-statement]</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        await self.stream.aclose()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        if self.tls:</span>
<span class="gi">+            return self.stream.transport_stream.socket.getpeername()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.stream.socket.getpeername()</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        if self.tls:</span>
<span class="gi">+            return self.stream.transport_stream.socket.getsockname()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.stream.socket.getsockname()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeercert(self, timeout):</span>
<span class="gi">+        if self.tls:</span>
<span class="gi">+            with _maybe_timeout(timeout):</span>
<span class="gi">+                await self.stream.do_handshake()</span>
<span class="gi">+            return self.stream.getpeercert()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if dns._features.have(&quot;doh&quot;):</span>
<span class="w"> </span>    import httpcore
<span class="w"> </span>    import httpcore._backends.trio
<span class="w"> </span>    import httpx
<span class="gi">+</span>
<span class="w"> </span>    _CoreAsyncNetworkBackend = httpcore.AsyncNetworkBackend
<span class="w"> </span>    _CoreTrioStream = httpcore._backends.trio.TrioStream
<span class="gd">-    from dns.query import _compute_times, _expiration_for_this_attempt, _remaining</span>

<span class="gi">+    from dns.query import _compute_times, _expiration_for_this_attempt, _remaining</span>

<span class="w"> </span>    class _NetworkBackend(_CoreAsyncNetworkBackend):
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self, resolver, local_port, bootstrap_address, family):
<span class="w"> </span>            super().__init__()
<span class="w"> </span>            self._local_port = local_port
<span class="gu">@@ -44,20 +117,134 @@ if dns._features.have(&#39;doh&#39;):</span>
<span class="w"> </span>            self._bootstrap_address = bootstrap_address
<span class="w"> </span>            self._family = family

<span class="gi">+        async def connect_tcp(</span>
<span class="gi">+            self, host, port, timeout, local_address, socket_options=None</span>
<span class="gi">+        ):  # pylint: disable=signature-differs</span>
<span class="gi">+            addresses = []</span>
<span class="gi">+            _, expiration = _compute_times(timeout)</span>
<span class="gi">+            if dns.inet.is_address(host):</span>
<span class="gi">+                addresses.append(host)</span>
<span class="gi">+            elif self._bootstrap_address is not None:</span>
<span class="gi">+                addresses.append(self._bootstrap_address)</span>
<span class="gi">+            else:</span>
<span class="gi">+                timeout = _remaining(expiration)</span>
<span class="gi">+                family = self._family</span>
<span class="gi">+                if local_address:</span>
<span class="gi">+                    family = dns.inet.af_for_address(local_address)</span>
<span class="gi">+                answers = await self._resolver.resolve_name(</span>
<span class="gi">+                    host, family=family, lifetime=timeout</span>
<span class="gi">+                )</span>
<span class="gi">+                addresses = answers.addresses()</span>
<span class="gi">+            for address in addresses:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    af = dns.inet.af_for_address(address)</span>
<span class="gi">+                    if local_address is not None or self._local_port != 0:</span>
<span class="gi">+                        source = (local_address, self._local_port)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        source = None</span>
<span class="gi">+                    destination = (address, port)</span>
<span class="gi">+                    attempt_expiration = _expiration_for_this_attempt(2.0, expiration)</span>
<span class="gi">+                    timeout = _remaining(attempt_expiration)</span>
<span class="gi">+                    sock = await Backend().make_socket(</span>
<span class="gi">+                        af, socket.SOCK_STREAM, 0, source, destination, timeout</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return _CoreTrioStream(sock.stream)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            raise httpcore.ConnectError</span>
<span class="gi">+</span>
<span class="gi">+        async def connect_unix_socket(</span>
<span class="gi">+            self, path, timeout, socket_options=None</span>
<span class="gi">+        ):  # pylint: disable=signature-differs</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+        async def sleep(self, seconds):  # pylint: disable=signature-differs</span>
<span class="gi">+            await trio.sleep(seconds)</span>

<span class="w"> </span>    class _HTTPTransport(httpx.AsyncHTTPTransport):
<span class="gd">-</span>
<span class="gd">-        def __init__(self, *args, local_port=0, bootstrap_address=None,</span>
<span class="gd">-            resolver=None, family=socket.AF_UNSPEC, **kwargs):</span>
<span class="gi">+        def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            local_port=0,</span>
<span class="gi">+            bootstrap_address=None,</span>
<span class="gi">+            resolver=None,</span>
<span class="gi">+            family=socket.AF_UNSPEC,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            if resolver is None:
<span class="gi">+                # pylint: disable=import-outside-toplevel,redefined-outer-name</span>
<span class="w"> </span>                import dns.asyncresolver
<span class="gi">+</span>
<span class="w"> </span>                resolver = dns.asyncresolver.Resolver()
<span class="w"> </span>            super().__init__(*args, **kwargs)
<span class="gd">-            self._pool._network_backend = _NetworkBackend(resolver,</span>
<span class="gd">-                local_port, bootstrap_address, family)</span>
<span class="gi">+            self._pool._network_backend = _NetworkBackend(</span>
<span class="gi">+                resolver, local_port, bootstrap_address, family</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    _HTTPTransport = dns._asyncbackend.NullTransport</span>
<span class="gi">+    _HTTPTransport = dns._asyncbackend.NullTransport  # type: ignore</span>


<span class="w"> </span>class Backend(dns._asyncbackend.Backend):
<span class="gd">-    pass</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return &quot;trio&quot;</span>
<span class="gi">+</span>
<span class="gi">+    async def make_socket(</span>
<span class="gi">+        self,</span>
<span class="gi">+        af,</span>
<span class="gi">+        socktype,</span>
<span class="gi">+        proto=0,</span>
<span class="gi">+        source=None,</span>
<span class="gi">+        destination=None,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        ssl_context=None,</span>
<span class="gi">+        server_hostname=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        s = trio.socket.socket(af, socktype, proto)</span>
<span class="gi">+        stream = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            if source:</span>
<span class="gi">+                await s.bind(_lltuple(source, af))</span>
<span class="gi">+            if socktype == socket.SOCK_STREAM:</span>
<span class="gi">+                connected = False</span>
<span class="gi">+                with _maybe_timeout(timeout):</span>
<span class="gi">+                    await s.connect(_lltuple(destination, af))</span>
<span class="gi">+                    connected = True</span>
<span class="gi">+                if not connected:</span>
<span class="gi">+                    raise dns.exception.Timeout(</span>
<span class="gi">+                        timeout=timeout</span>
<span class="gi">+                    )  # lgtm[py/unreachable-statement]</span>
<span class="gi">+        except Exception:  # pragma: no cover</span>
<span class="gi">+            s.close()</span>
<span class="gi">+            raise</span>
<span class="gi">+        if socktype == socket.SOCK_DGRAM:</span>
<span class="gi">+            return DatagramSocket(s)</span>
<span class="gi">+        elif socktype == socket.SOCK_STREAM:</span>
<span class="gi">+            stream = trio.SocketStream(s)</span>
<span class="gi">+            tls = False</span>
<span class="gi">+            if ssl_context:</span>
<span class="gi">+                tls = True</span>
<span class="gi">+                try:</span>
<span class="gi">+                    stream = trio.SSLStream(</span>
<span class="gi">+                        stream, ssl_context, server_hostname=server_hostname</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception:  # pragma: no cover</span>
<span class="gi">+                    await stream.aclose()</span>
<span class="gi">+                    raise</span>
<span class="gi">+            return StreamSocket(af, stream, tls)</span>
<span class="gi">+        raise NotImplementedError(</span>
<span class="gi">+            &quot;unsupported socket &quot; + f&quot;type {socktype}&quot;</span>
<span class="gi">+        )  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    async def sleep(self, interval):</span>
<span class="gi">+        await trio.sleep(interval)</span>
<span class="gi">+</span>
<span class="gi">+    def get_transport_class(self):</span>
<span class="gi">+        return _HTTPTransport</span>
<span class="gi">+</span>
<span class="gi">+    async def wait_for(self, awaitable, timeout):</span>
<span class="gi">+        with _maybe_timeout(timeout):</span>
<span class="gi">+            return await awaitable</span>
<span class="gi">+        raise dns.exception.Timeout(</span>
<span class="gi">+            timeout=timeout</span>
<span class="gi">+        )  # pragma: no cover  lgtm[py/unreachable-statement]</span>
<span class="gh">diff --git a/dns/asyncbackend.py b/dns/asyncbackend.py</span>
<span class="gh">index 3e2691b..0ec58b0 100644</span>
<span class="gd">--- a/dns/asyncbackend.py</span>
<span class="gi">+++ b/dns/asyncbackend.py</span>
<span class="gu">@@ -1,8 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="gd">-from dns._asyncbackend import Backend, DatagramSocket, Socket, StreamSocket</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=unused-import</span>
<span class="gi">+from dns._asyncbackend import (  # noqa: F401  lgtm[py/unused-import]</span>
<span class="gi">+    Backend,</span>
<span class="gi">+    DatagramSocket,</span>
<span class="gi">+    Socket,</span>
<span class="gi">+    StreamSocket,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# pylint: enable=unused-import</span>
<span class="gi">+</span>
<span class="w"> </span>_default_backend = None
<span class="gi">+</span>
<span class="w"> </span>_backends: Dict[str, Backend] = {}
<span class="gi">+</span>
<span class="gi">+# Allow sniffio import to be disabled for testing purposes</span>
<span class="w"> </span>_no_sniffio = False


<span class="gu">@@ -10,7 +26,7 @@ class AsyncLibraryNotFoundError(dns.exception.DNSException):</span>
<span class="w"> </span>    pass


<span class="gd">-def get_backend(name: str) -&gt;Backend:</span>
<span class="gi">+def get_backend(name: str) -&gt; Backend:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the specified asynchronous backend.

<span class="w"> </span>    *name*, a ``str``, the name of the backend.  Currently the &quot;trio&quot;
<span class="gu">@@ -18,25 +34,60 @@ def get_backend(name: str) -&gt;Backend:</span>

<span class="w"> </span>    Raises NotImplementedError if an unknown backend name is specified.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # pylint: disable=import-outside-toplevel,redefined-outer-name</span>
<span class="gi">+    backend = _backends.get(name)</span>
<span class="gi">+    if backend:</span>
<span class="gi">+        return backend</span>
<span class="gi">+    if name == &quot;trio&quot;:</span>
<span class="gi">+        import dns._trio_backend</span>

<span class="gi">+        backend = dns._trio_backend.Backend()</span>
<span class="gi">+    elif name == &quot;asyncio&quot;:</span>
<span class="gi">+        import dns._asyncio_backend</span>

<span class="gd">-def sniff() -&gt;str:</span>
<span class="gi">+        backend = dns._asyncio_backend.Backend()</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError(f&quot;unimplemented async backend {name}&quot;)</span>
<span class="gi">+    _backends[name] = backend</span>
<span class="gi">+    return backend</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sniff() -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attempt to determine the in-use asynchronous I/O library by using
<span class="w"> </span>    the ``sniffio`` module if it is available.

<span class="w"> </span>    Returns the name of the library, or raises AsyncLibraryNotFoundError
<span class="w"> </span>    if the library cannot be determined.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # pylint: disable=import-outside-toplevel</span>
<span class="gi">+    try:</span>
<span class="gi">+        if _no_sniffio:</span>
<span class="gi">+            raise ImportError</span>
<span class="gi">+        import sniffio</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return sniffio.current_async_library()</span>
<span class="gi">+        except sniffio.AsyncLibraryNotFoundError:</span>
<span class="gi">+            raise AsyncLibraryNotFoundError(&quot;sniffio cannot determine async library&quot;)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        import asyncio</span>

<span class="gi">+        try:</span>
<span class="gi">+            asyncio.get_running_loop()</span>
<span class="gi">+            return &quot;asyncio&quot;</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            raise AsyncLibraryNotFoundError(&quot;no async library detected&quot;)</span>

<span class="gd">-def get_default_backend() -&gt;Backend:</span>
<span class="gi">+</span>
<span class="gi">+def get_default_backend() -&gt; Backend:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the default backend, initializing it if necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _default_backend:</span>
<span class="gi">+        return _default_backend</span>

<span class="gi">+    return set_default_backend(sniff())</span>

<span class="gd">-def set_default_backend(name: str) -&gt;Backend:</span>
<span class="gi">+</span>
<span class="gi">+def set_default_backend(name: str) -&gt; Backend:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the default backend.

<span class="w"> </span>    It&#39;s not normally necessary to call this method, as
<span class="gu">@@ -45,4 +96,6 @@ def set_default_backend(name: str) -&gt;Backend:</span>
<span class="w"> </span>    in testing situations, this function allows the backend to be set
<span class="w"> </span>    explicitly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _default_backend</span>
<span class="gi">+    _default_backend = get_backend(name)</span>
<span class="gi">+    return _default_backend</span>
<span class="gh">diff --git a/dns/asyncquery.py b/dns/asyncquery.py</span>
<span class="gh">index 5fbfbb5..4d9ab9a 100644</span>
<span class="gd">--- a/dns/asyncquery.py</span>
<span class="gi">+++ b/dns/asyncquery.py</span>
<span class="gu">@@ -1,10 +1,29 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Talk to a DNS server.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import contextlib
<span class="w"> </span>import socket
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="w"> </span>from typing import Any, Dict, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.asyncbackend
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="gu">@@ -16,15 +35,57 @@ import dns.rdataclass</span>
<span class="w"> </span>import dns.rdatatype
<span class="w"> </span>import dns.transaction
<span class="w"> </span>from dns._asyncbackend import NullContext
<span class="gd">-from dns.query import BadResponse, NoDOH, NoDOQ, UDPMode, _compute_times, _make_dot_ssl_context, _matches_destination, _remaining, have_doh, ssl</span>
<span class="gi">+from dns.query import (</span>
<span class="gi">+    BadResponse,</span>
<span class="gi">+    NoDOH,</span>
<span class="gi">+    NoDOQ,</span>
<span class="gi">+    UDPMode,</span>
<span class="gi">+    _compute_times,</span>
<span class="gi">+    _make_dot_ssl_context,</span>
<span class="gi">+    _matches_destination,</span>
<span class="gi">+    _remaining,</span>
<span class="gi">+    have_doh,</span>
<span class="gi">+    ssl,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if have_doh:
<span class="w"> </span>    import httpx
<span class="gi">+</span>
<span class="gi">+# for brevity</span>
<span class="w"> </span>_lltuple = dns.inet.low_level_address_tuple


<span class="gd">-async def send_udp(sock: dns.asyncbackend.DatagramSocket, what: Union[dns.</span>
<span class="gd">-    message.Message, bytes], destination: Any, expiration: Optional[float]=None</span>
<span class="gd">-    ) -&gt;Tuple[int, float]:</span>
<span class="gi">+def _source_tuple(af, address, port):</span>
<span class="gi">+    # Make a high level source tuple, or return None if address and port</span>
<span class="gi">+    # are both None</span>
<span class="gi">+    if address or port:</span>
<span class="gi">+        if address is None:</span>
<span class="gi">+            if af == socket.AF_INET:</span>
<span class="gi">+                address = &quot;0.0.0.0&quot;</span>
<span class="gi">+            elif af == socket.AF_INET6:</span>
<span class="gi">+                address = &quot;::&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise NotImplementedError(f&quot;unknown address family {af}&quot;)</span>
<span class="gi">+        return (address, port)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _timeout(expiration, now=None):</span>
<span class="gi">+    if expiration is not None:</span>
<span class="gi">+        if not now:</span>
<span class="gi">+            now = time.time()</span>
<span class="gi">+        return max(expiration - now, 0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def send_udp(</span>
<span class="gi">+    sock: dns.asyncbackend.DatagramSocket,</span>
<span class="gi">+    what: Union[dns.message.Message, bytes],</span>
<span class="gi">+    destination: Any,</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+) -&gt; Tuple[int, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Send a DNS message to the specified UDP socket.

<span class="w"> </span>    *sock*, a ``dns.asyncbackend.DatagramSocket``.
<span class="gu">@@ -41,16 +102,27 @@ async def send_udp(sock: dns.asyncbackend.DatagramSocket, what: Union[dns.</span>

<span class="w"> </span>    Returns an ``(int, float)`` tuple of bytes sent and the sent time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-async def receive_udp(sock: dns.asyncbackend.DatagramSocket, destination:</span>
<span class="gd">-    Optional[Any]=None, expiration: Optional[float]=None, ignore_unexpected:</span>
<span class="gd">-    bool=False, one_rr_per_rrset: bool=False, keyring: Optional[Dict[dns.</span>
<span class="gd">-    name.Name, dns.tsig.Key]]=None, request_mac: Optional[bytes]=b&#39;&#39;,</span>
<span class="gd">-    ignore_trailing: bool=False, raise_on_truncation: bool=False,</span>
<span class="gd">-    ignore_errors: bool=False, query: Optional[dns.message.Message]=None</span>
<span class="gd">-    ) -&gt;Any:</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        what = what.to_wire()</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    n = await sock.sendto(what, destination, _timeout(expiration, sent_time))</span>
<span class="gi">+    return (n, sent_time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def receive_udp(</span>
<span class="gi">+    sock: dns.asyncbackend.DatagramSocket,</span>
<span class="gi">+    destination: Optional[Any] = None,</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+    ignore_unexpected: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,</span>
<span class="gi">+    request_mac: Optional[bytes] = b&quot;&quot;,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    raise_on_truncation: bool = False,</span>
<span class="gi">+    ignore_errors: bool = False,</span>
<span class="gi">+    query: Optional[dns.message.Message] = None,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a DNS message from a UDP socket.

<span class="w"> </span>    *sock*, a ``dns.asyncbackend.DatagramSocket``.
<span class="gu">@@ -61,16 +133,59 @@ async def receive_udp(sock: dns.asyncbackend.DatagramSocket, destination:</span>
<span class="w"> </span>    Returns a ``(dns.message.Message, float, tuple)`` tuple of the received message, the
<span class="w"> </span>    received time, and the address where the message arrived from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-async def udp(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="gd">-    None, port: int=53, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    ignore_unexpected: bool=False, one_rr_per_rrset: bool=False,</span>
<span class="gd">-    ignore_trailing: bool=False, raise_on_truncation: bool=False, sock:</span>
<span class="gd">-    Optional[dns.asyncbackend.DatagramSocket]=None, backend: Optional[dns.</span>
<span class="gd">-    asyncbackend.Backend]=None, ignore_errors: bool=False</span>
<span class="gd">-    ) -&gt;dns.message.Message:</span>
<span class="gi">+    wire = b&quot;&quot;</span>
<span class="gi">+    while True:</span>
<span class="gi">+        (wire, from_address) = await sock.recvfrom(65535, _timeout(expiration))</span>
<span class="gi">+        if not _matches_destination(</span>
<span class="gi">+            sock.family, from_address, destination, ignore_unexpected</span>
<span class="gi">+        ):</span>
<span class="gi">+            continue</span>
<span class="gi">+        received_time = time.time()</span>
<span class="gi">+        try:</span>
<span class="gi">+            r = dns.message.from_wire(</span>
<span class="gi">+                wire,</span>
<span class="gi">+                keyring=keyring,</span>
<span class="gi">+                request_mac=request_mac,</span>
<span class="gi">+                one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                ignore_trailing=ignore_trailing,</span>
<span class="gi">+                raise_on_truncation=raise_on_truncation,</span>
<span class="gi">+            )</span>
<span class="gi">+        except dns.message.Truncated as e:</span>
<span class="gi">+            # See the comment in query.py for details.</span>
<span class="gi">+            if (</span>
<span class="gi">+                ignore_errors</span>
<span class="gi">+                and query is not None</span>
<span class="gi">+                and not query.is_response(e.message())</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if ignore_errors:</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        if ignore_errors and query is not None and not query.is_response(r):</span>
<span class="gi">+            continue</span>
<span class="gi">+        return (r, received_time, from_address)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def udp(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    ignore_unexpected: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    raise_on_truncation: bool = False,</span>
<span class="gi">+    sock: Optional[dns.asyncbackend.DatagramSocket] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+    ignore_errors: bool = False,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via UDP.

<span class="w"> </span>    *sock*, a ``dns.asyncbackend.DatagramSocket``, or ``None``,
<span class="gu">@@ -84,16 +199,59 @@ async def udp(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="w"> </span>    See :py:func:`dns.query.udp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-async def udp_with_fallback(q: dns.message.Message, where: str, timeout:</span>
<span class="gd">-    Optional[float]=None, port: int=53, source: Optional[str]=None,</span>
<span class="gd">-    source_port: int=0, ignore_unexpected: bool=False, one_rr_per_rrset:</span>
<span class="gd">-    bool=False, ignore_trailing: bool=False, udp_sock: Optional[dns.</span>
<span class="gd">-    asyncbackend.DatagramSocket]=None, tcp_sock: Optional[dns.asyncbackend.</span>
<span class="gd">-    StreamSocket]=None, backend: Optional[dns.asyncbackend.Backend]=None,</span>
<span class="gd">-    ignore_errors: bool=False) -&gt;Tuple[dns.message.Message, bool]:</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    af = dns.inet.af_for_address(where)</span>
<span class="gi">+    destination = _lltuple((where, port), af)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        cm: contextlib.AbstractAsyncContextManager = NullContext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not backend:</span>
<span class="gi">+            backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+        stuple = _source_tuple(af, source, source_port)</span>
<span class="gi">+        if backend.datagram_connection_required():</span>
<span class="gi">+            dtuple = (where, port)</span>
<span class="gi">+        else:</span>
<span class="gi">+            dtuple = None</span>
<span class="gi">+        cm = await backend.make_socket(af, socket.SOCK_DGRAM, 0, stuple, dtuple)</span>
<span class="gi">+    async with cm as s:</span>
<span class="gi">+        await send_udp(s, wire, destination, expiration)</span>
<span class="gi">+        (r, received_time, _) = await receive_udp(</span>
<span class="gi">+            s,</span>
<span class="gi">+            destination,</span>
<span class="gi">+            expiration,</span>
<span class="gi">+            ignore_unexpected,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            q.keyring,</span>
<span class="gi">+            q.mac,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            raise_on_truncation,</span>
<span class="gi">+            ignore_errors,</span>
<span class="gi">+            q,</span>
<span class="gi">+        )</span>
<span class="gi">+        r.time = received_time - begin_time</span>
<span class="gi">+        # We don&#39;t need to check q.is_response() if we are in ignore_errors mode</span>
<span class="gi">+        # as receive_udp() will have checked it.</span>
<span class="gi">+        if not (ignore_errors or q.is_response(r)):</span>
<span class="gi">+            raise BadResponse</span>
<span class="gi">+        return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def udp_with_fallback(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    ignore_unexpected: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    udp_sock: Optional[dns.asyncbackend.DatagramSocket] = None,</span>
<span class="gi">+    tcp_sock: Optional[dns.asyncbackend.StreamSocket] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+    ignore_errors: bool = False,</span>
<span class="gi">+) -&gt; Tuple[dns.message.Message, bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response to the query, trying UDP first and falling back
<span class="w"> </span>    to TCP if UDP results in a truncated response.

<span class="gu">@@ -114,12 +272,44 @@ async def udp_with_fallback(q: dns.message.Message, where: str, timeout:</span>
<span class="w"> </span>    of the other parameters, exceptions, and return type of this
<span class="w"> </span>    method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-async def send_tcp(sock: dns.asyncbackend.StreamSocket, what: Union[dns.</span>
<span class="gd">-    message.Message, bytes], expiration: Optional[float]=None) -&gt;Tuple[int,</span>
<span class="gd">-    float]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        response = await udp(</span>
<span class="gi">+            q,</span>
<span class="gi">+            where,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            port,</span>
<span class="gi">+            source,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            ignore_unexpected,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            True,</span>
<span class="gi">+            udp_sock,</span>
<span class="gi">+            backend,</span>
<span class="gi">+            ignore_errors,</span>
<span class="gi">+        )</span>
<span class="gi">+        return (response, False)</span>
<span class="gi">+    except dns.message.Truncated:</span>
<span class="gi">+        response = await tcp(</span>
<span class="gi">+            q,</span>
<span class="gi">+            where,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            port,</span>
<span class="gi">+            source,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            tcp_sock,</span>
<span class="gi">+            backend,</span>
<span class="gi">+        )</span>
<span class="gi">+        return (response, True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def send_tcp(</span>
<span class="gi">+    sock: dns.asyncbackend.StreamSocket,</span>
<span class="gi">+    what: Union[dns.message.Message, bytes],</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+) -&gt; Tuple[int, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Send a DNS message to the specified TCP socket.

<span class="w"> </span>    *sock*, a ``dns.asyncbackend.StreamSocket``.
<span class="gu">@@ -127,20 +317,41 @@ async def send_tcp(sock: dns.asyncbackend.StreamSocket, what: Union[dns.</span>
<span class="w"> </span>    See :py:func:`dns.query.send_tcp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        tcpmsg = what.to_wire(prepend_length=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # copying the wire into tcpmsg is inefficient, but lets us</span>
<span class="gi">+        # avoid writev() or doing a short write that would get pushed</span>
<span class="gi">+        # onto the net</span>
<span class="gi">+        tcpmsg = len(what).to_bytes(2, &quot;big&quot;) + what</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    await sock.sendall(tcpmsg, _timeout(expiration, sent_time))</span>
<span class="gi">+    return (len(tcpmsg), sent_time)</span>


<span class="w"> </span>async def _read_exactly(sock, count, expiration):
<span class="w"> </span>    &quot;&quot;&quot;Read the specified number of bytes from stream.  Keep trying until we
<span class="w"> </span>    either get the desired amount, or we hit EOF.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-async def receive_tcp(sock: dns.asyncbackend.StreamSocket, expiration:</span>
<span class="gd">-    Optional[float]=None, one_rr_per_rrset: bool=False, keyring: Optional[</span>
<span class="gd">-    Dict[dns.name.Name, dns.tsig.Key]]=None, request_mac: Optional[bytes]=</span>
<span class="gd">-    b&#39;&#39;, ignore_trailing: bool=False) -&gt;Tuple[dns.message.Message, float]:</span>
<span class="gi">+    s = b&quot;&quot;</span>
<span class="gi">+    while count &gt; 0:</span>
<span class="gi">+        n = await sock.recv(count, _timeout(expiration))</span>
<span class="gi">+        if n == b&quot;&quot;:</span>
<span class="gi">+            raise EOFError</span>
<span class="gi">+        count = count - len(n)</span>
<span class="gi">+        s = s + n</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def receive_tcp(</span>
<span class="gi">+    sock: dns.asyncbackend.StreamSocket,</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,</span>
<span class="gi">+    request_mac: Optional[bytes] = b&quot;&quot;,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+) -&gt; Tuple[dns.message.Message, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a DNS message from a TCP socket.

<span class="w"> </span>    *sock*, a ``dns.asyncbackend.StreamSocket``.
<span class="gu">@@ -148,14 +359,33 @@ async def receive_tcp(sock: dns.asyncbackend.StreamSocket, expiration:</span>
<span class="w"> </span>    See :py:func:`dns.query.receive_tcp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-async def tcp(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="gd">-    None, port: int=53, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, sock:</span>
<span class="gd">-    Optional[dns.asyncbackend.StreamSocket]=None, backend: Optional[dns.</span>
<span class="gd">-    asyncbackend.Backend]=None) -&gt;dns.message.Message:</span>
<span class="gi">+    ldata = await _read_exactly(sock, 2, expiration)</span>
<span class="gi">+    (l,) = struct.unpack(&quot;!H&quot;, ldata)</span>
<span class="gi">+    wire = await _read_exactly(sock, l, expiration)</span>
<span class="gi">+    received_time = time.time()</span>
<span class="gi">+    r = dns.message.from_wire(</span>
<span class="gi">+        wire,</span>
<span class="gi">+        keyring=keyring,</span>
<span class="gi">+        request_mac=request_mac,</span>
<span class="gi">+        one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+        ignore_trailing=ignore_trailing,</span>
<span class="gi">+    )</span>
<span class="gi">+    return (r, received_time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def tcp(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    sock: Optional[dns.asyncbackend.StreamSocket] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via TCP.

<span class="w"> </span>    *sock*, a ``dns.asyncbacket.StreamSocket``, or ``None``, the
<span class="gu">@@ -169,16 +399,52 @@ async def tcp(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="w"> </span>    See :py:func:`dns.query.tcp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-async def tls(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="gd">-    None, port: int=853, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, sock:</span>
<span class="gd">-    Optional[dns.asyncbackend.StreamSocket]=None, backend: Optional[dns.</span>
<span class="gd">-    asyncbackend.Backend]=None, ssl_context: Optional[ssl.SSLContext]=None,</span>
<span class="gd">-    server_hostname: Optional[str]=None, verify: Union[bool, str]=True</span>
<span class="gd">-    ) -&gt;dns.message.Message:</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        # Verify that the socket is connected, as if it&#39;s not connected,</span>
<span class="gi">+        # it&#39;s not writable, and the polling in send_tcp() will time out or</span>
<span class="gi">+        # hang forever.</span>
<span class="gi">+        await sock.getpeername()</span>
<span class="gi">+        cm: contextlib.AbstractAsyncContextManager = NullContext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # These are simple (address, port) pairs, not family-dependent tuples</span>
<span class="gi">+        # you pass to low-level socket code.</span>
<span class="gi">+        af = dns.inet.af_for_address(where)</span>
<span class="gi">+        stuple = _source_tuple(af, source, source_port)</span>
<span class="gi">+        dtuple = (where, port)</span>
<span class="gi">+        if not backend:</span>
<span class="gi">+            backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+        cm = await backend.make_socket(</span>
<span class="gi">+            af, socket.SOCK_STREAM, 0, stuple, dtuple, timeout</span>
<span class="gi">+        )</span>
<span class="gi">+    async with cm as s:</span>
<span class="gi">+        await send_tcp(s, wire, expiration)</span>
<span class="gi">+        (r, received_time) = await receive_tcp(</span>
<span class="gi">+            s, expiration, one_rr_per_rrset, q.keyring, q.mac, ignore_trailing</span>
<span class="gi">+        )</span>
<span class="gi">+        r.time = received_time - begin_time</span>
<span class="gi">+        if not q.is_response(r):</span>
<span class="gi">+            raise BadResponse</span>
<span class="gi">+        return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def tls(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 853,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    sock: Optional[dns.asyncbackend.StreamSocket] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+    ssl_context: Optional[ssl.SSLContext] = None,</span>
<span class="gi">+    server_hostname: Optional[str] = None,</span>
<span class="gi">+    verify: Union[bool, str] = True,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via TLS.

<span class="w"> </span>    *sock*, an ``asyncbackend.StreamSocket``, or ``None``, the socket
<span class="gu">@@ -194,16 +460,63 @@ async def tls(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="w"> </span>    See :py:func:`dns.query.tls()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-async def https(q: dns.message.Message, where: str, timeout: Optional[float</span>
<span class="gd">-    ]=None, port: int=443, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, client:</span>
<span class="gd">-    Optional[&#39;httpx.AsyncClient&#39;]=None, path: str=&#39;/dns-query&#39;, post: bool=</span>
<span class="gd">-    True, verify: Union[bool, str]=True, bootstrap_address: Optional[str]=</span>
<span class="gd">-    None, resolver: Optional[&#39;dns.asyncresolver.Resolver&#39;]=None, family:</span>
<span class="gd">-    Optional[int]=socket.AF_UNSPEC) -&gt;dns.message.Message:</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        cm: contextlib.AbstractAsyncContextManager = NullContext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if ssl_context is None:</span>
<span class="gi">+            ssl_context = _make_dot_ssl_context(server_hostname, verify)</span>
<span class="gi">+        af = dns.inet.af_for_address(where)</span>
<span class="gi">+        stuple = _source_tuple(af, source, source_port)</span>
<span class="gi">+        dtuple = (where, port)</span>
<span class="gi">+        if not backend:</span>
<span class="gi">+            backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+        cm = await backend.make_socket(</span>
<span class="gi">+            af,</span>
<span class="gi">+            socket.SOCK_STREAM,</span>
<span class="gi">+            0,</span>
<span class="gi">+            stuple,</span>
<span class="gi">+            dtuple,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            ssl_context,</span>
<span class="gi">+            server_hostname,</span>
<span class="gi">+        )</span>
<span class="gi">+    async with cm as s:</span>
<span class="gi">+        timeout = _timeout(expiration)</span>
<span class="gi">+        response = await tcp(</span>
<span class="gi">+            q,</span>
<span class="gi">+            where,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            port,</span>
<span class="gi">+            source,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            s,</span>
<span class="gi">+            backend,</span>
<span class="gi">+        )</span>
<span class="gi">+        end_time = time.time()</span>
<span class="gi">+        response.time = end_time - begin_time</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def https(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 443,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,  # pylint: disable=W0613</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    client: Optional[&quot;httpx.AsyncClient&quot;] = None,</span>
<span class="gi">+    path: str = &quot;/dns-query&quot;,</span>
<span class="gi">+    post: bool = True,</span>
<span class="gi">+    verify: Union[bool, str] = True,</span>
<span class="gi">+    bootstrap_address: Optional[str] = None,</span>
<span class="gi">+    resolver: Optional[&quot;dns.asyncresolver.Resolver&quot;] = None,</span>
<span class="gi">+    family: Optional[int] = socket.AF_UNSPEC,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via DNS-over-HTTPS.

<span class="w"> </span>    *client*, a ``httpx.AsyncClient``.  If provided, the client to use for
<span class="gu">@@ -215,14 +528,107 @@ async def https(q: dns.message.Message, where: str, timeout: Optional[float</span>
<span class="w"> </span>    See :py:func:`dns.query.https()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-async def inbound_xfr(where: str, txn_manager: dns.transaction.</span>
<span class="gd">-    TransactionManager, query: Optional[dns.message.Message]=None, port:</span>
<span class="gd">-    int=53, timeout: Optional[float]=None, lifetime: Optional[float]=None,</span>
<span class="gd">-    source: Optional[str]=None, source_port: int=0, udp_mode: UDPMode=</span>
<span class="gd">-    UDPMode.NEVER, backend: Optional[dns.asyncbackend.Backend]=None) -&gt;None:</span>
<span class="gi">+    if not have_doh:</span>
<span class="gi">+        raise NoDOH  # pragma: no cover</span>
<span class="gi">+    if client and not isinstance(client, httpx.AsyncClient):</span>
<span class="gi">+        raise ValueError(&quot;session parameter must be an httpx.AsyncClient&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    try:</span>
<span class="gi">+        af = dns.inet.af_for_address(where)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        af = None</span>
<span class="gi">+    transport = None</span>
<span class="gi">+    headers = {&quot;accept&quot;: &quot;application/dns-message&quot;}</span>
<span class="gi">+    if af is not None and dns.inet.is_address(where):</span>
<span class="gi">+        if af == socket.AF_INET:</span>
<span class="gi">+            url = &quot;https://{}:{}{}&quot;.format(where, port, path)</span>
<span class="gi">+        elif af == socket.AF_INET6:</span>
<span class="gi">+            url = &quot;https://[{}]:{}{}&quot;.format(where, port, path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        url = where</span>
<span class="gi">+</span>
<span class="gi">+    backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        local_address = None</span>
<span class="gi">+        local_port = 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        local_address = source</span>
<span class="gi">+        local_port = source_port</span>
<span class="gi">+    transport = backend.get_transport_class()(</span>
<span class="gi">+        local_address=local_address,</span>
<span class="gi">+        http1=True,</span>
<span class="gi">+        http2=True,</span>
<span class="gi">+        verify=verify,</span>
<span class="gi">+        local_port=local_port,</span>
<span class="gi">+        bootstrap_address=bootstrap_address,</span>
<span class="gi">+        resolver=resolver,</span>
<span class="gi">+        family=family,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if client:</span>
<span class="gi">+        cm: contextlib.AbstractAsyncContextManager = NullContext(client)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = httpx.AsyncClient(</span>
<span class="gi">+            http1=True, http2=True, verify=verify, transport=transport</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async with cm as the_client:</span>
<span class="gi">+        # see https://tools.ietf.org/html/rfc8484#section-4.1.1 for DoH</span>
<span class="gi">+        # GET and POST examples</span>
<span class="gi">+        if post:</span>
<span class="gi">+            headers.update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    &quot;content-type&quot;: &quot;application/dns-message&quot;,</span>
<span class="gi">+                    &quot;content-length&quot;: str(len(wire)),</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+            response = await backend.wait_for(</span>
<span class="gi">+                the_client.post(url, headers=headers, content=wire), timeout</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            wire = base64.urlsafe_b64encode(wire).rstrip(b&quot;=&quot;)</span>
<span class="gi">+            twire = wire.decode()  # httpx does a repr() if we give it bytes</span>
<span class="gi">+            response = await backend.wait_for(</span>
<span class="gi">+                the_client.get(url, headers=headers, params={&quot;dns&quot;: twire}), timeout</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # see https://tools.ietf.org/html/rfc8484#section-4.2.1 for info about DoH</span>
<span class="gi">+    # status codes</span>
<span class="gi">+    if response.status_code &lt; 200 or response.status_code &gt; 299:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;{} responded with status code {}&quot;</span>
<span class="gi">+            &quot;\nResponse body: {!r}&quot;.format(</span>
<span class="gi">+                where, response.status_code, response.content</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    r = dns.message.from_wire(</span>
<span class="gi">+        response.content,</span>
<span class="gi">+        keyring=q.keyring,</span>
<span class="gi">+        request_mac=q.request_mac,</span>
<span class="gi">+        one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+        ignore_trailing=ignore_trailing,</span>
<span class="gi">+    )</span>
<span class="gi">+    r.time = response.elapsed.total_seconds()</span>
<span class="gi">+    if not q.is_response(r):</span>
<span class="gi">+        raise BadResponse</span>
<span class="gi">+    return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def inbound_xfr(</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    txn_manager: dns.transaction.TransactionManager,</span>
<span class="gi">+    query: Optional[dns.message.Message] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    udp_mode: UDPMode = UDPMode.NEVER,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Conduct an inbound transfer and apply it via a transaction from the
<span class="w"> </span>    txn_manager.

<span class="gu">@@ -232,15 +638,100 @@ async def inbound_xfr(where: str, txn_manager: dns.transaction.</span>
<span class="w"> </span>    See :py:func:`dns.query.inbound_xfr()` for the documentation of
<span class="w"> </span>    the other parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-async def quic(q: dns.message.Message, where: str, timeout: Optional[float]</span>
<span class="gd">-    =None, port: int=853, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, connection:</span>
<span class="gd">-    Optional[dns.quic.AsyncQuicConnection]=None, verify: Union[bool, str]=</span>
<span class="gd">-    True, backend: Optional[dns.asyncbackend.Backend]=None, server_hostname:</span>
<span class="gd">-    Optional[str]=None) -&gt;dns.message.Message:</span>
<span class="gi">+    if query is None:</span>
<span class="gi">+        (query, serial) = dns.xfr.make_query(txn_manager)</span>
<span class="gi">+    else:</span>
<span class="gi">+        serial = dns.xfr.extract_serial_from_query(query)</span>
<span class="gi">+    rdtype = query.question[0].rdtype</span>
<span class="gi">+    is_ixfr = rdtype == dns.rdatatype.IXFR</span>
<span class="gi">+    origin = txn_manager.from_wire_origin()</span>
<span class="gi">+    wire = query.to_wire()</span>
<span class="gi">+    af = dns.inet.af_for_address(where)</span>
<span class="gi">+    stuple = _source_tuple(af, source, source_port)</span>
<span class="gi">+    dtuple = (where, port)</span>
<span class="gi">+    (_, expiration) = _compute_times(lifetime)</span>
<span class="gi">+    retry = True</span>
<span class="gi">+    while retry:</span>
<span class="gi">+        retry = False</span>
<span class="gi">+        if is_ixfr and udp_mode != UDPMode.NEVER:</span>
<span class="gi">+            sock_type = socket.SOCK_DGRAM</span>
<span class="gi">+            is_udp = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            sock_type = socket.SOCK_STREAM</span>
<span class="gi">+            is_udp = False</span>
<span class="gi">+        if not backend:</span>
<span class="gi">+            backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+        s = await backend.make_socket(</span>
<span class="gi">+            af, sock_type, 0, stuple, dtuple, _timeout(expiration)</span>
<span class="gi">+        )</span>
<span class="gi">+        async with s:</span>
<span class="gi">+            if is_udp:</span>
<span class="gi">+                await s.sendto(wire, dtuple, _timeout(expiration))</span>
<span class="gi">+            else:</span>
<span class="gi">+                tcpmsg = struct.pack(&quot;!H&quot;, len(wire)) + wire</span>
<span class="gi">+                await s.sendall(tcpmsg, expiration)</span>
<span class="gi">+            with dns.xfr.Inbound(txn_manager, rdtype, serial, is_udp) as inbound:</span>
<span class="gi">+                done = False</span>
<span class="gi">+                tsig_ctx = None</span>
<span class="gi">+                while not done:</span>
<span class="gi">+                    (_, mexpiration) = _compute_times(timeout)</span>
<span class="gi">+                    if mexpiration is None or (</span>
<span class="gi">+                        expiration is not None and mexpiration &gt; expiration</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        mexpiration = expiration</span>
<span class="gi">+                    if is_udp:</span>
<span class="gi">+                        destination = _lltuple((where, port), af)</span>
<span class="gi">+                        while True:</span>
<span class="gi">+                            timeout = _timeout(mexpiration)</span>
<span class="gi">+                            (rwire, from_address) = await s.recvfrom(65535, timeout)</span>
<span class="gi">+                            if _matches_destination(</span>
<span class="gi">+                                af, from_address, destination, True</span>
<span class="gi">+                            ):</span>
<span class="gi">+                                break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        ldata = await _read_exactly(s, 2, mexpiration)</span>
<span class="gi">+                        (l,) = struct.unpack(&quot;!H&quot;, ldata)</span>
<span class="gi">+                        rwire = await _read_exactly(s, l, mexpiration)</span>
<span class="gi">+                    is_ixfr = rdtype == dns.rdatatype.IXFR</span>
<span class="gi">+                    r = dns.message.from_wire(</span>
<span class="gi">+                        rwire,</span>
<span class="gi">+                        keyring=query.keyring,</span>
<span class="gi">+                        request_mac=query.mac,</span>
<span class="gi">+                        xfr=True,</span>
<span class="gi">+                        origin=origin,</span>
<span class="gi">+                        tsig_ctx=tsig_ctx,</span>
<span class="gi">+                        multi=(not is_udp),</span>
<span class="gi">+                        one_rr_per_rrset=is_ixfr,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        done = inbound.process_message(r)</span>
<span class="gi">+                    except dns.xfr.UseTCP:</span>
<span class="gi">+                        assert is_udp  # should not happen if we used TCP!</span>
<span class="gi">+                        if udp_mode == UDPMode.ONLY:</span>
<span class="gi">+                            raise</span>
<span class="gi">+                        done = True</span>
<span class="gi">+                        retry = True</span>
<span class="gi">+                        udp_mode = UDPMode.NEVER</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    tsig_ctx = r.tsig_ctx</span>
<span class="gi">+                if not retry and query.keyring and not r.had_tsig:</span>
<span class="gi">+                    raise dns.exception.FormError(&quot;missing TSIG&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def quic(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 853,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    connection: Optional[dns.quic.AsyncQuicConnection] = None,</span>
<span class="gi">+    verify: Union[bool, str] = True,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+    server_hostname: Optional[str] = None,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending an asynchronous query via
<span class="w"> </span>    DNS-over-QUIC.

<span class="gu">@@ -250,4 +741,40 @@ async def quic(q: dns.message.Message, where: str, timeout: Optional[float]</span>
<span class="w"> </span>    See :py:func:`dns.query.quic()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not dns.quic.have_quic:</span>
<span class="gi">+        raise NoDOQ(&quot;DNS-over-QUIC is not available.&quot;)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    q.id = 0</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    the_connection: dns.quic.AsyncQuicConnection</span>
<span class="gi">+    if connection:</span>
<span class="gi">+        cfactory = dns.quic.null_factory</span>
<span class="gi">+        mfactory = dns.quic.null_factory</span>
<span class="gi">+        the_connection = connection</span>
<span class="gi">+    else:</span>
<span class="gi">+        (cfactory, mfactory) = dns.quic.factories_for_backend(backend)</span>
<span class="gi">+</span>
<span class="gi">+    async with cfactory() as context:</span>
<span class="gi">+        async with mfactory(</span>
<span class="gi">+            context, verify_mode=verify, server_name=server_hostname</span>
<span class="gi">+        ) as the_manager:</span>
<span class="gi">+            if not connection:</span>
<span class="gi">+                the_connection = the_manager.connect(where, port, source, source_port)</span>
<span class="gi">+            (start, expiration) = _compute_times(timeout)</span>
<span class="gi">+            stream = await the_connection.make_stream(timeout)</span>
<span class="gi">+            async with stream:</span>
<span class="gi">+                await stream.send(wire, True)</span>
<span class="gi">+                wire = await stream.receive(_remaining(expiration))</span>
<span class="gi">+            finish = time.time()</span>
<span class="gi">+        r = dns.message.from_wire(</span>
<span class="gi">+            wire,</span>
<span class="gi">+            keyring=q.keyring,</span>
<span class="gi">+            request_mac=q.request_mac,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+        )</span>
<span class="gi">+    r.time = max(finish - start, 0.0)</span>
<span class="gi">+    if not q.is_response(r):</span>
<span class="gi">+        raise BadResponse</span>
<span class="gi">+    return r</span>
<span class="gh">diff --git a/dns/asyncresolver.py b/dns/asyncresolver.py</span>
<span class="gh">index e587e04..8f5e062 100644</span>
<span class="gd">--- a/dns/asyncresolver.py</span>
<span class="gi">+++ b/dns/asyncresolver.py</span>
<span class="gu">@@ -1,7 +1,26 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Asynchronous DNS stub resolver.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import time
<span class="w"> </span>from typing import Any, Dict, List, Optional, Union
<span class="gi">+</span>
<span class="w"> </span>import dns._ddr
<span class="w"> </span>import dns.asyncbackend
<span class="w"> </span>import dns.asyncquery
<span class="gu">@@ -10,8 +29,12 @@ import dns.name</span>
<span class="w"> </span>import dns.query
<span class="w"> </span>import dns.rdataclass
<span class="w"> </span>import dns.rdatatype
<span class="gd">-import dns.resolver</span>
<span class="gi">+import dns.resolver  # lgtm[py/import-and-import-from]</span>
<span class="gi">+</span>
<span class="gi">+# import some resolver symbols for brevity</span>
<span class="w"> </span>from dns.resolver import NXDOMAIN, NoAnswer, NoRootSOA, NotAbsolute
<span class="gi">+</span>
<span class="gi">+# for indentation purposes below</span>
<span class="w"> </span>_udp = dns.asyncquery.udp
<span class="w"> </span>_tcp = dns.asyncquery.tcp

<span class="gu">@@ -19,13 +42,19 @@ _tcp = dns.asyncquery.tcp</span>
<span class="w"> </span>class Resolver(dns.resolver.BaseResolver):
<span class="w"> </span>    &quot;&quot;&quot;Asynchronous DNS stub resolver.&quot;&quot;&quot;

<span class="gd">-    async def resolve(self, qname: Union[dns.name.Name, str], rdtype: Union</span>
<span class="gd">-        [dns.rdatatype.RdataType, str]=dns.rdatatype.A, rdclass: Union[dns.</span>
<span class="gd">-        rdataclass.RdataClass, str]=dns.rdataclass.IN, tcp: bool=False,</span>
<span class="gd">-        source: Optional[str]=None, raise_on_no_answer: bool=True,</span>
<span class="gd">-        source_port: int=0, lifetime: Optional[float]=None, search:</span>
<span class="gd">-        Optional[bool]=None, backend: Optional[dns.asyncbackend.Backend]=None</span>
<span class="gd">-        ) -&gt;dns.resolver.Answer:</span>
<span class="gi">+    async def resolve(</span>
<span class="gi">+        self,</span>
<span class="gi">+        qname: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+        rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+        tcp: bool = False,</span>
<span class="gi">+        source: Optional[str] = None,</span>
<span class="gi">+        raise_on_no_answer: bool = True,</span>
<span class="gi">+        source_port: int = 0,</span>
<span class="gi">+        lifetime: Optional[float] = None,</span>
<span class="gi">+        search: Optional[bool] = None,</span>
<span class="gi">+        backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+    ) -&gt; dns.resolver.Answer:</span>
<span class="w"> </span>        &quot;&quot;&quot;Query nameservers asynchronously to find the answer to the question.

<span class="w"> </span>        *backend*, a ``dns.asyncbackend.Backend``, or ``None``.  If ``None``,
<span class="gu">@@ -35,10 +64,52 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        documentation of the other parameters, exceptions, and return
<span class="w"> </span>        type of this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    async def resolve_address(self, ipaddr: str, *args: Any, **kwargs: Any</span>
<span class="gd">-        ) -&gt;dns.resolver.Answer:</span>
<span class="gi">+        resolution = dns.resolver._Resolution(</span>
<span class="gi">+            self, qname, rdtype, rdclass, tcp, raise_on_no_answer, search</span>
<span class="gi">+        )</span>
<span class="gi">+        if not backend:</span>
<span class="gi">+            backend = dns.asyncbackend.get_default_backend()</span>
<span class="gi">+        start = time.time()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            (request, answer) = resolution.next_request()</span>
<span class="gi">+            # Note we need to say &quot;if answer is not None&quot; and not just</span>
<span class="gi">+            # &quot;if answer&quot; because answer implements __len__, and python</span>
<span class="gi">+            # will call that.  We want to return if we have an answer</span>
<span class="gi">+            # object, including in cases where its length is 0.</span>
<span class="gi">+            if answer is not None:</span>
<span class="gi">+                # cache hit!</span>
<span class="gi">+                return answer</span>
<span class="gi">+            assert request is not None  # needed for type checking</span>
<span class="gi">+            done = False</span>
<span class="gi">+            while not done:</span>
<span class="gi">+                (nameserver, tcp, backoff) = resolution.next_nameserver()</span>
<span class="gi">+                if backoff:</span>
<span class="gi">+                    await backend.sleep(backoff)</span>
<span class="gi">+                timeout = self._compute_timeout(start, lifetime, resolution.errors)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    response = await nameserver.async_query(</span>
<span class="gi">+                        request,</span>
<span class="gi">+                        timeout=timeout,</span>
<span class="gi">+                        source=source,</span>
<span class="gi">+                        source_port=source_port,</span>
<span class="gi">+                        max_size=tcp,</span>
<span class="gi">+                        backend=backend,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception as ex:</span>
<span class="gi">+                    (_, done) = resolution.query_result(None, ex)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                (answer, done) = resolution.query_result(response, None)</span>
<span class="gi">+                # Note we need to say &quot;if answer is not None&quot; and not just</span>
<span class="gi">+                # &quot;if answer&quot; because answer implements __len__, and python</span>
<span class="gi">+                # will call that.  We want to return if we have an answer</span>
<span class="gi">+                # object, including in cases where its length is 0.</span>
<span class="gi">+                if answer is not None:</span>
<span class="gi">+                    return answer</span>
<span class="gi">+</span>
<span class="gi">+    async def resolve_address(</span>
<span class="gi">+        self, ipaddr: str, *args: Any, **kwargs: Any</span>
<span class="gi">+    ) -&gt; dns.resolver.Answer:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use an asynchronous resolver to run a reverse query for PTR
<span class="w"> </span>        records.

<span class="gu">@@ -53,10 +124,23 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        function.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def resolve_name(self, name: Union[dns.name.Name, str], family:</span>
<span class="gd">-        int=socket.AF_UNSPEC, **kwargs: Any) -&gt;dns.resolver.HostAnswers:</span>
<span class="gi">+        # We make a modified kwargs for type checking happiness, as otherwise</span>
<span class="gi">+        # we get a legit warning about possibly having rdtype and rdclass</span>
<span class="gi">+        # in the kwargs more than once.</span>
<span class="gi">+        modified_kwargs: Dict[str, Any] = {}</span>
<span class="gi">+        modified_kwargs.update(kwargs)</span>
<span class="gi">+        modified_kwargs[&quot;rdtype&quot;] = dns.rdatatype.PTR</span>
<span class="gi">+        modified_kwargs[&quot;rdclass&quot;] = dns.rdataclass.IN</span>
<span class="gi">+        return await self.resolve(</span>
<span class="gi">+            dns.reversename.from_address(ipaddr), *args, **modified_kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async def resolve_name(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        family: int = socket.AF_UNSPEC,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; dns.resolver.HostAnswers:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use an asynchronous resolver to query for address records.

<span class="w"> </span>        This utilizes the resolve() method to perform A and/or AAAA lookups on
<span class="gu">@@ -71,10 +155,56 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        except for rdtype and rdclass are also supported by this
<span class="w"> </span>        function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def canonical_name(self, name: Union[dns.name.Name, str]</span>
<span class="gd">-        ) -&gt;dns.name.Name:</span>
<span class="gi">+        # We make a modified kwargs for type checking happiness, as otherwise</span>
<span class="gi">+        # we get a legit warning about possibly having rdtype and rdclass</span>
<span class="gi">+        # in the kwargs more than once.</span>
<span class="gi">+        modified_kwargs: Dict[str, Any] = {}</span>
<span class="gi">+        modified_kwargs.update(kwargs)</span>
<span class="gi">+        modified_kwargs.pop(&quot;rdtype&quot;, None)</span>
<span class="gi">+        modified_kwargs[&quot;rdclass&quot;] = dns.rdataclass.IN</span>
<span class="gi">+</span>
<span class="gi">+        if family == socket.AF_INET:</span>
<span class="gi">+            v4 = await self.resolve(name, dns.rdatatype.A, **modified_kwargs)</span>
<span class="gi">+            return dns.resolver.HostAnswers.make(v4=v4)</span>
<span class="gi">+        elif family == socket.AF_INET6:</span>
<span class="gi">+            v6 = await self.resolve(name, dns.rdatatype.AAAA, **modified_kwargs)</span>
<span class="gi">+            return dns.resolver.HostAnswers.make(v6=v6)</span>
<span class="gi">+        elif family != socket.AF_UNSPEC:</span>
<span class="gi">+            raise NotImplementedError(f&quot;unknown address family {family}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        raise_on_no_answer = modified_kwargs.pop(&quot;raise_on_no_answer&quot;, True)</span>
<span class="gi">+        lifetime = modified_kwargs.pop(&quot;lifetime&quot;, None)</span>
<span class="gi">+        start = time.time()</span>
<span class="gi">+        v6 = await self.resolve(</span>
<span class="gi">+            name,</span>
<span class="gi">+            dns.rdatatype.AAAA,</span>
<span class="gi">+            raise_on_no_answer=False,</span>
<span class="gi">+            lifetime=self._compute_timeout(start, lifetime),</span>
<span class="gi">+            **modified_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+        # Note that setting name ensures we query the same name</span>
<span class="gi">+        # for A as we did for AAAA.  (This is just in case search lists</span>
<span class="gi">+        # are active by default in the resolver configuration and</span>
<span class="gi">+        # we might be talking to a server that says NXDOMAIN when it</span>
<span class="gi">+        # wants to say NOERROR no data.</span>
<span class="gi">+        name = v6.qname</span>
<span class="gi">+        v4 = await self.resolve(</span>
<span class="gi">+            name,</span>
<span class="gi">+            dns.rdatatype.A,</span>
<span class="gi">+            raise_on_no_answer=False,</span>
<span class="gi">+            lifetime=self._compute_timeout(start, lifetime),</span>
<span class="gi">+            **modified_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+        answers = dns.resolver.HostAnswers.make(</span>
<span class="gi">+            v6=v6, v4=v4, add_empty=not raise_on_no_answer</span>
<span class="gi">+        )</span>
<span class="gi">+        if not answers:</span>
<span class="gi">+            raise NoAnswer(response=v6.response)</span>
<span class="gi">+        return answers</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=redefined-outer-name</span>
<span class="gi">+</span>
<span class="gi">+    async def canonical_name(self, name: Union[dns.name.Name, str]) -&gt; dns.name.Name:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determine the canonical name of *name*.

<span class="w"> </span>        The canonical name is the name the resolver uses for queries
<span class="gu">@@ -88,9 +218,14 @@ class Resolver(dns.resolver.BaseResolver):</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def try_ddr(self, lifetime: float=5.0) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            answer = await self.resolve(name, raise_on_no_answer=False)</span>
<span class="gi">+            canonical_name = answer.canonical_name</span>
<span class="gi">+        except dns.resolver.NXDOMAIN as e:</span>
<span class="gi">+            canonical_name = e.canonical_name</span>
<span class="gi">+        return canonical_name</span>
<span class="gi">+</span>
<span class="gi">+    async def try_ddr(self, lifetime: float = 5.0) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to update the resolver&#39;s nameservers using Discovery of Designated
<span class="w"> </span>        Resolvers (DDR).  If successful, the resolver will subsequently use
<span class="w"> </span>        DNS-over-HTTPS or DNS-over-TLS for future queries.
<span class="gu">@@ -109,32 +244,53 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        the bootstrap nameserver is in the Subject Alternative Name field of the
<span class="w"> </span>        TLS certficate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            expiration = time.time() + lifetime</span>
<span class="gi">+            answer = await self.resolve(</span>
<span class="gi">+                dns._ddr._local_resolver_name, &quot;svcb&quot;, lifetime=lifetime</span>
<span class="gi">+            )</span>
<span class="gi">+            timeout = dns.query._remaining(expiration)</span>
<span class="gi">+            nameservers = await dns._ddr._get_nameservers_async(answer, timeout)</span>
<span class="gi">+            if len(nameservers) &gt; 0:</span>
<span class="gi">+                self.nameservers = nameservers</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>


<span class="w"> </span>default_resolver = None


<span class="gd">-def get_default_resolver() -&gt;Resolver:</span>
<span class="gi">+def get_default_resolver() -&gt; Resolver:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the default asynchronous resolver, initializing it if necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default_resolver is None:</span>
<span class="gi">+        reset_default_resolver()</span>
<span class="gi">+    assert default_resolver is not None</span>
<span class="gi">+    return default_resolver</span>


<span class="gd">-def reset_default_resolver() -&gt;None:</span>
<span class="gi">+def reset_default_resolver() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Re-initialize default asynchronous resolver.

<span class="w"> </span>    Note that the resolver configuration (i.e. /etc/resolv.conf on UNIX
<span class="w"> </span>    systems) will be re-read immediately.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-async def resolve(qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="gd">-    rdatatype.RdataType, str]=dns.rdatatype.A, rdclass: Union[dns.</span>
<span class="gd">-    rdataclass.RdataClass, str]=dns.rdataclass.IN, tcp: bool=False, source:</span>
<span class="gd">-    Optional[str]=None, raise_on_no_answer: bool=True, source_port: int=0,</span>
<span class="gd">-    lifetime: Optional[float]=None, search: Optional[bool]=None, backend:</span>
<span class="gd">-    Optional[dns.asyncbackend.Backend]=None) -&gt;dns.resolver.Answer:</span>
<span class="gi">+    global default_resolver</span>
<span class="gi">+    default_resolver = Resolver()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def resolve(</span>
<span class="gi">+    qname: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    raise_on_no_answer: bool = True,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    search: Optional[bool] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+) -&gt; dns.resolver.Answer:</span>
<span class="w"> </span>    &quot;&quot;&quot;Query nameservers asynchronously to find the answer to the question.

<span class="w"> </span>    This is a convenience function that uses the default resolver
<span class="gu">@@ -143,63 +299,107 @@ async def resolve(qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="w"> </span>    See :py:func:`dns.asyncresolver.Resolver.resolve` for more
<span class="w"> </span>    information on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-async def resolve_address(ipaddr: str, *args: Any, **kwargs: Any</span>
<span class="gd">-    ) -&gt;dns.resolver.Answer:</span>
<span class="gi">+    return await get_default_resolver().resolve(</span>
<span class="gi">+        qname,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        tcp,</span>
<span class="gi">+        source,</span>
<span class="gi">+        raise_on_no_answer,</span>
<span class="gi">+        source_port,</span>
<span class="gi">+        lifetime,</span>
<span class="gi">+        search,</span>
<span class="gi">+        backend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def resolve_address(</span>
<span class="gi">+    ipaddr: str, *args: Any, **kwargs: Any</span>
<span class="gi">+) -&gt; dns.resolver.Answer:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use a resolver to run a reverse query for PTR records.

<span class="w"> </span>    See :py:func:`dns.asyncresolver.Resolver.resolve_address` for more
<span class="w"> </span>    information on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return await get_default_resolver().resolve_address(ipaddr, *args, **kwargs)</span>

<span class="gd">-async def resolve_name(name: Union[dns.name.Name, str], family: int=socket.</span>
<span class="gd">-    AF_UNSPEC, **kwargs: Any) -&gt;dns.resolver.HostAnswers:</span>
<span class="gi">+</span>
<span class="gi">+async def resolve_name(</span>
<span class="gi">+    name: Union[dns.name.Name, str], family: int = socket.AF_UNSPEC, **kwargs: Any</span>
<span class="gi">+) -&gt; dns.resolver.HostAnswers:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use a resolver to asynchronously query for address records.

<span class="w"> </span>    See :py:func:`dns.asyncresolver.Resolver.resolve_name` for more
<span class="w"> </span>    information on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return await get_default_resolver().resolve_name(name, family, **kwargs)</span>


<span class="gd">-async def canonical_name(name: Union[dns.name.Name, str]) -&gt;dns.name.Name:</span>
<span class="gi">+async def canonical_name(name: Union[dns.name.Name, str]) -&gt; dns.name.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine the canonical name of *name*.

<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.canonical_name` for more
<span class="w"> </span>    information on the parameters and possible exceptions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return await get_default_resolver().canonical_name(name)</span>

<span class="gd">-async def try_ddr(timeout: float=5.0) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+async def try_ddr(timeout: float = 5.0) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to update the default resolver&#39;s nameservers using Discovery of Designated
<span class="w"> </span>    Resolvers (DDR).  If successful, the resolver will subsequently use
<span class="w"> </span>    DNS-over-HTTPS or DNS-over-TLS for future queries.

<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.try_ddr` for more information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return await get_default_resolver().try_ddr(timeout)</span>


<span class="gd">-async def zone_for_name(name: Union[dns.name.Name, str], rdclass: dns.</span>
<span class="gd">-    rdataclass.RdataClass=dns.rdataclass.IN, tcp: bool=False, resolver:</span>
<span class="gd">-    Optional[Resolver]=None, backend: Optional[dns.asyncbackend.Backend]=None</span>
<span class="gd">-    ) -&gt;dns.name.Name:</span>
<span class="gi">+async def zone_for_name(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+) -&gt; dns.name.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the name of the zone which contains the specified name.

<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.zone_for_name` for more
<span class="w"> </span>    information on the parameters and possible exceptions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-async def make_resolver_at(where: Union[dns.name.Name, str], port: int=53,</span>
<span class="gd">-    family: int=socket.AF_UNSPEC, resolver: Optional[Resolver]=None</span>
<span class="gd">-    ) -&gt;Resolver:</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, dns.name.root)</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    if not name.is_absolute():</span>
<span class="gi">+        raise NotAbsolute(name)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            answer = await resolver.resolve(</span>
<span class="gi">+                name, dns.rdatatype.SOA, rdclass, tcp, backend=backend</span>
<span class="gi">+            )</span>
<span class="gi">+            assert answer.rrset is not None</span>
<span class="gi">+            if answer.rrset.name == name:</span>
<span class="gi">+                return name</span>
<span class="gi">+            # otherwise we were CNAMEd or DNAMEd and need to look higher</span>
<span class="gi">+        except (NXDOMAIN, NoAnswer):</span>
<span class="gi">+            pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = name.parent()</span>
<span class="gi">+        except dns.name.NoParent:  # pragma: no cover</span>
<span class="gi">+            raise NoRootSOA</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def make_resolver_at(</span>
<span class="gi">+    where: Union[dns.name.Name, str],</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    family: int = socket.AF_UNSPEC,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+) -&gt; Resolver:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a stub resolver using the specified destination as the full resolver.

<span class="w"> </span>    *where*, a ``dns.name.Name`` or ``str`` the domain name or IP address of the
<span class="gu">@@ -217,17 +417,36 @@ async def make_resolver_at(where: Union[dns.name.Name, str], port: int=53,</span>

<span class="w"> </span>    Returns a ``dns.resolver.Resolver`` or raises an exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-async def resolve_at(where: Union[dns.name.Name, str], qname: Union[dns.</span>
<span class="gd">-    name.Name, str], rdtype: Union[dns.rdatatype.RdataType, str]=dns.</span>
<span class="gd">-    rdatatype.A, rdclass: Union[dns.rdataclass.RdataClass, str]=dns.</span>
<span class="gd">-    rdataclass.IN, tcp: bool=False, source: Optional[str]=None,</span>
<span class="gd">-    raise_on_no_answer: bool=True, source_port: int=0, lifetime: Optional[</span>
<span class="gd">-    float]=None, search: Optional[bool]=None, backend: Optional[dns.</span>
<span class="gd">-    asyncbackend.Backend]=None, port: int=53, family: int=socket.AF_UNSPEC,</span>
<span class="gd">-    resolver: Optional[Resolver]=None) -&gt;dns.resolver.Answer:</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    nameservers: List[Union[str, dns.nameserver.Nameserver]] = []</span>
<span class="gi">+    if isinstance(where, str) and dns.inet.is_address(where):</span>
<span class="gi">+        nameservers.append(dns.nameserver.Do53Nameserver(where, port))</span>
<span class="gi">+    else:</span>
<span class="gi">+        answers = await resolver.resolve_name(where, family)</span>
<span class="gi">+        for address in answers.addresses():</span>
<span class="gi">+            nameservers.append(dns.nameserver.Do53Nameserver(address, port))</span>
<span class="gi">+    res = dns.asyncresolver.Resolver(configure=False)</span>
<span class="gi">+    res.nameservers = nameservers</span>
<span class="gi">+    return res</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def resolve_at(</span>
<span class="gi">+    where: Union[dns.name.Name, str],</span>
<span class="gi">+    qname: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    raise_on_no_answer: bool = True,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    search: Optional[bool] = None,</span>
<span class="gi">+    backend: Optional[dns.asyncbackend.Backend] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    family: int = socket.AF_UNSPEC,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+) -&gt; dns.resolver.Answer:</span>
<span class="w"> </span>    &quot;&quot;&quot;Query nameservers to find the answer to the question.

<span class="w"> </span>    This is a convenience function that calls ``dns.asyncresolver.make_resolver_at()``
<span class="gu">@@ -241,4 +460,16 @@ async def resolve_at(where: Union[dns.name.Name, str], qname: Union[dns.</span>
<span class="w"> </span>    ``dns.asyncresolver.make_resolver_at()`` and then use that resolver for the queries
<span class="w"> </span>    instead of calling ``resolve_at()`` multiple times.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    res = await make_resolver_at(where, port, family, resolver)</span>
<span class="gi">+    return await res.resolve(</span>
<span class="gi">+        qname,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        tcp,</span>
<span class="gi">+        source,</span>
<span class="gi">+        raise_on_no_answer,</span>
<span class="gi">+        source_port,</span>
<span class="gi">+        lifetime,</span>
<span class="gi">+        search,</span>
<span class="gi">+        backend,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/dns/dnssec.py b/dns/dnssec.py</span>
<span class="gh">index 2787e8a..e49c3b7 100644</span>
<span class="gd">--- a/dns/dnssec.py</span>
<span class="gi">+++ b/dns/dnssec.py</span>
<span class="gu">@@ -1,4 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Common DNSSEC-related functions and constants.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import contextlib
<span class="w"> </span>import functools
<span class="gu">@@ -7,6 +26,7 @@ import struct</span>
<span class="w"> </span>import time
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from typing import Callable, Dict, List, Optional, Set, Tuple, Union, cast
<span class="gi">+</span>
<span class="w"> </span>import dns._features
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.name
<span class="gu">@@ -19,7 +39,12 @@ import dns.rrset</span>
<span class="w"> </span>import dns.transaction
<span class="w"> </span>import dns.zone
<span class="w"> </span>from dns.dnssectypes import Algorithm, DSDigest, NSEC3Hash
<span class="gd">-from dns.exception import AlgorithmKeyMismatch, DeniedByPolicy, UnsupportedAlgorithm, ValidationFailure</span>
<span class="gi">+from dns.exception import (  # pylint: disable=W0611</span>
<span class="gi">+    AlgorithmKeyMismatch,</span>
<span class="gi">+    DeniedByPolicy,</span>
<span class="gi">+    UnsupportedAlgorithm,</span>
<span class="gi">+    ValidationFailure,</span>
<span class="gi">+)</span>
<span class="w"> </span>from dns.rdtypes.ANY.CDNSKEY import CDNSKEY
<span class="w"> </span>from dns.rdtypes.ANY.CDS import CDS
<span class="w"> </span>from dns.rdtypes.ANY.DNSKEY import DNSKEY
<span class="gu">@@ -28,78 +53,142 @@ from dns.rdtypes.ANY.NSEC import NSEC, Bitmap</span>
<span class="w"> </span>from dns.rdtypes.ANY.NSEC3PARAM import NSEC3PARAM
<span class="w"> </span>from dns.rdtypes.ANY.RRSIG import RRSIG, sigtime_to_posixtime
<span class="w"> </span>from dns.rdtypes.dnskeybase import Flag
<span class="gd">-PublicKey = Union[&#39;GenericPublicKey&#39;, &#39;rsa.RSAPublicKey&#39;,</span>
<span class="gd">-    &#39;ec.EllipticCurvePublicKey&#39;, &#39;ed25519.Ed25519PublicKey&#39;,</span>
<span class="gd">-    &#39;ed448.Ed448PublicKey&#39;]</span>
<span class="gd">-PrivateKey = Union[&#39;GenericPrivateKey&#39;, &#39;rsa.RSAPrivateKey&#39;,</span>
<span class="gd">-    &#39;ec.EllipticCurvePrivateKey&#39;, &#39;ed25519.Ed25519PrivateKey&#39;,</span>
<span class="gd">-    &#39;ed448.Ed448PrivateKey&#39;]</span>
<span class="gi">+</span>
<span class="gi">+PublicKey = Union[</span>
<span class="gi">+    &quot;GenericPublicKey&quot;,</span>
<span class="gi">+    &quot;rsa.RSAPublicKey&quot;,</span>
<span class="gi">+    &quot;ec.EllipticCurvePublicKey&quot;,</span>
<span class="gi">+    &quot;ed25519.Ed25519PublicKey&quot;,</span>
<span class="gi">+    &quot;ed448.Ed448PublicKey&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+PrivateKey = Union[</span>
<span class="gi">+    &quot;GenericPrivateKey&quot;,</span>
<span class="gi">+    &quot;rsa.RSAPrivateKey&quot;,</span>
<span class="gi">+    &quot;ec.EllipticCurvePrivateKey&quot;,</span>
<span class="gi">+    &quot;ed25519.Ed25519PrivateKey&quot;,</span>
<span class="gi">+    &quot;ed448.Ed448PrivateKey&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>RRsetSigner = Callable[[dns.transaction.Transaction, dns.rrset.RRset], None]


<span class="gd">-def algorithm_from_text(text: str) -&gt;Algorithm:</span>
<span class="gi">+def algorithm_from_text(text: str) -&gt; Algorithm:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert text into a DNSSEC algorithm value.

<span class="w"> </span>    *text*, a ``str``, the text to convert to into an algorithm value.

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return Algorithm.from_text(text)</span>

<span class="gd">-def algorithm_to_text(value: Union[Algorithm, int]) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def algorithm_to_text(value: Union[Algorithm, int]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a DNSSEC algorithm value to text

<span class="w"> </span>    *value*, a ``dns.dnssec.Algorithm``.

<span class="w"> </span>    Returns a ``str``, the name of a DNSSEC algorithm.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def to_timestamp(value: Union[datetime, str, float, int]) -&gt;int:</span>
<span class="gd">-    &quot;&quot;&quot;Convert various format to a timestamp&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    return Algorithm.to_text(value)</span>


<span class="gd">-def key_id(key: Union[DNSKEY, CDNSKEY]) -&gt;int:</span>
<span class="gi">+def to_timestamp(value: Union[datetime, str, float, int]) -&gt; int:</span>
<span class="gi">+    &quot;&quot;&quot;Convert various format to a timestamp&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(value, datetime):</span>
<span class="gi">+        return int(value.timestamp())</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        return sigtime_to_posixtime(value)</span>
<span class="gi">+    elif isinstance(value, float):</span>
<span class="gi">+        return int(value)</span>
<span class="gi">+    elif isinstance(value, int):</span>
<span class="gi">+        return value</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Unsupported timestamp type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def key_id(key: Union[DNSKEY, CDNSKEY]) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the key id (a 16-bit number) for the specified key.

<span class="w"> </span>    *key*, a ``dns.rdtypes.ANY.DNSKEY.DNSKEY``

<span class="w"> </span>    Returns an ``int`` between 0 and 65535
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    rdata = key.to_wire()</span>
<span class="gi">+    if key.algorithm == Algorithm.RSAMD5:</span>
<span class="gi">+        return (rdata[-3] &lt;&lt; 8) + rdata[-2]</span>
<span class="gi">+    else:</span>
<span class="gi">+        total = 0</span>
<span class="gi">+        for i in range(len(rdata) // 2):</span>
<span class="gi">+            total += (rdata[2 * i] &lt;&lt; 8) + rdata[2 * i + 1]</span>
<span class="gi">+        if len(rdata) % 2 != 0:</span>
<span class="gi">+            total += rdata[len(rdata) - 1] &lt;&lt; 8</span>
<span class="gi">+        total += (total &gt;&gt; 16) &amp; 0xFFFF</span>
<span class="gi">+        return total &amp; 0xFFFF</span>

<span class="gd">-class Policy:</span>

<span class="gi">+class Policy:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        pass

<span class="gi">+    def ok_to_sign(self, _: DNSKEY) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+        return False</span>

<span class="gd">-class SimpleDeny(Policy):</span>
<span class="gi">+    def ok_to_validate(self, _: DNSKEY) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def ok_to_create_ds(self, _: DSDigest) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def ok_to_validate_ds(self, _: DSDigest) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+        return False</span>

<span class="gd">-    def __init__(self, deny_sign, deny_validate, deny_create_ds,</span>
<span class="gd">-        deny_validate_ds):</span>
<span class="gi">+</span>
<span class="gi">+class SimpleDeny(Policy):</span>
<span class="gi">+    def __init__(self, deny_sign, deny_validate, deny_create_ds, deny_validate_ds):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._deny_sign = deny_sign
<span class="w"> </span>        self._deny_validate = deny_validate
<span class="w"> </span>        self._deny_create_ds = deny_create_ds
<span class="w"> </span>        self._deny_validate_ds = deny_validate_ds

<span class="gi">+    def ok_to_sign(self, key: DNSKEY) -&gt; bool:</span>
<span class="gi">+        return key.algorithm not in self._deny_sign</span>
<span class="gi">+</span>
<span class="gi">+    def ok_to_validate(self, key: DNSKEY) -&gt; bool:</span>
<span class="gi">+        return key.algorithm not in self._deny_validate</span>
<span class="gi">+</span>
<span class="gi">+    def ok_to_create_ds(self, algorithm: DSDigest) -&gt; bool:</span>
<span class="gi">+        return algorithm not in self._deny_create_ds</span>
<span class="gi">+</span>
<span class="gi">+    def ok_to_validate_ds(self, algorithm: DSDigest) -&gt; bool:</span>
<span class="gi">+        return algorithm not in self._deny_validate_ds</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+rfc_8624_policy = SimpleDeny(</span>
<span class="gi">+    {Algorithm.RSAMD5, Algorithm.DSA, Algorithm.DSANSEC3SHA1, Algorithm.ECCGOST},</span>
<span class="gi">+    {Algorithm.RSAMD5, Algorithm.DSA, Algorithm.DSANSEC3SHA1},</span>
<span class="gi">+    {DSDigest.NULL, DSDigest.SHA1, DSDigest.GOST},</span>
<span class="gi">+    {DSDigest.NULL},</span>
<span class="gi">+)</span>

<span class="gd">-rfc_8624_policy = SimpleDeny({Algorithm.RSAMD5, Algorithm.DSA, Algorithm.</span>
<span class="gd">-    DSANSEC3SHA1, Algorithm.ECCGOST}, {Algorithm.RSAMD5, Algorithm.DSA,</span>
<span class="gd">-    Algorithm.DSANSEC3SHA1}, {DSDigest.NULL, DSDigest.SHA1, DSDigest.GOST},</span>
<span class="gd">-    {DSDigest.NULL})</span>
<span class="w"> </span>allow_all_policy = SimpleDeny(set(), set(), set(), set())
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>default_policy = rfc_8624_policy


<span class="gd">-def make_ds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,</span>
<span class="gd">-    algorithm: Union[DSDigest, str], origin: Optional[dns.name.Name]=None,</span>
<span class="gd">-    policy: Optional[Policy]=None, validating: bool=False) -&gt;DS:</span>
<span class="gi">+def make_ds(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    key: dns.rdata.Rdata,</span>
<span class="gi">+    algorithm: Union[DSDigest, str],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    policy: Optional[Policy] = None,</span>
<span class="gi">+    validating: bool = False,</span>
<span class="gi">+) -&gt; DS:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a DS record for a DNSSEC key.

<span class="w"> </span>    *name*, a ``dns.name.Name`` or ``str``, the owner name of the DS record.
<span class="gu">@@ -128,12 +217,52 @@ def make_ds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,</span>

<span class="w"> </span>    Returns a ``dns.rdtypes.ANY.DS.DS``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def make_cds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,</span>
<span class="gd">-    algorithm: Union[DSDigest, str], origin: Optional[dns.name.Name]=None</span>
<span class="gd">-    ) -&gt;CDS:</span>
<span class="gi">+    if policy is None:</span>
<span class="gi">+        policy = default_policy</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(algorithm, str):</span>
<span class="gi">+            algorithm = DSDigest[algorithm.upper()]</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        raise UnsupportedAlgorithm(&#39;unsupported algorithm &quot;%s&quot;&#39; % algorithm)</span>
<span class="gi">+    if validating:</span>
<span class="gi">+        check = policy.ok_to_validate_ds</span>
<span class="gi">+    else:</span>
<span class="gi">+        check = policy.ok_to_create_ds</span>
<span class="gi">+    if not check(algorithm):</span>
<span class="gi">+        raise DeniedByPolicy</span>
<span class="gi">+    if not isinstance(key, (DNSKEY, CDNSKEY)):</span>
<span class="gi">+        raise ValueError(&quot;key is not a DNSKEY/CDNSKEY&quot;)</span>
<span class="gi">+    if algorithm == DSDigest.SHA1:</span>
<span class="gi">+        dshash = hashlib.sha1()</span>
<span class="gi">+    elif algorithm == DSDigest.SHA256:</span>
<span class="gi">+        dshash = hashlib.sha256()</span>
<span class="gi">+    elif algorithm == DSDigest.SHA384:</span>
<span class="gi">+        dshash = hashlib.sha384()</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise UnsupportedAlgorithm(&#39;unsupported algorithm &quot;%s&quot;&#39; % algorithm)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, origin)</span>
<span class="gi">+    wire = name.canonicalize().to_wire()</span>
<span class="gi">+    assert wire is not None</span>
<span class="gi">+    dshash.update(wire)</span>
<span class="gi">+    dshash.update(key.to_wire(origin=origin))</span>
<span class="gi">+    digest = dshash.digest()</span>
<span class="gi">+</span>
<span class="gi">+    dsrdata = struct.pack(&quot;!HBB&quot;, key_id(key), key.algorithm, algorithm) + digest</span>
<span class="gi">+    ds = dns.rdata.from_wire(</span>
<span class="gi">+        dns.rdataclass.IN, dns.rdatatype.DS, dsrdata, 0, len(dsrdata)</span>
<span class="gi">+    )</span>
<span class="gi">+    return cast(DS, ds)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_cds(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    key: dns.rdata.Rdata,</span>
<span class="gi">+    algorithm: Union[DSDigest, str],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; CDS:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a CDS record for a DNSSEC key.

<span class="w"> </span>    *name*, a ``dns.name.Name`` or ``str``, the owner name of the DS record.
<span class="gu">@@ -152,13 +281,64 @@ def make_cds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,</span>

<span class="w"> </span>    Returns a ``dns.rdtypes.ANY.DS.CDS``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def _validate_rrsig(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.</span>
<span class="gd">-    rdataset.Rdataset]], rrsig: RRSIG, keys: Dict[dns.name.Name, Union[dns.</span>
<span class="gd">-    node.Node, dns.rdataset.Rdataset]], origin: Optional[dns.name.Name]=</span>
<span class="gd">-    None, now: Optional[float]=None, policy: Optional[Policy]=None) -&gt;None:</span>
<span class="gi">+    ds = make_ds(name, key, algorithm, origin)</span>
<span class="gi">+    return CDS(</span>
<span class="gi">+        rdclass=ds.rdclass,</span>
<span class="gi">+        rdtype=dns.rdatatype.CDS,</span>
<span class="gi">+        key_tag=ds.key_tag,</span>
<span class="gi">+        algorithm=ds.algorithm,</span>
<span class="gi">+        digest_type=ds.digest_type,</span>
<span class="gi">+        digest=ds.digest,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_candidate_keys(</span>
<span class="gi">+    keys: Dict[dns.name.Name, Union[dns.rdataset.Rdataset, dns.node.Node]], rrsig: RRSIG</span>
<span class="gi">+) -&gt; Optional[List[DNSKEY]]:</span>
<span class="gi">+    value = keys.get(rrsig.signer)</span>
<span class="gi">+    if isinstance(value, dns.node.Node):</span>
<span class="gi">+        rdataset = value.get_rdataset(dns.rdataclass.IN, dns.rdatatype.DNSKEY)</span>
<span class="gi">+    else:</span>
<span class="gi">+        rdataset = value</span>
<span class="gi">+    if rdataset is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return [</span>
<span class="gi">+        cast(DNSKEY, rd)</span>
<span class="gi">+        for rd in rdataset</span>
<span class="gi">+        if rd.algorithm == rrsig.algorithm</span>
<span class="gi">+        and key_id(rd) == rrsig.key_tag</span>
<span class="gi">+        and (rd.flags &amp; Flag.ZONE) == Flag.ZONE  # RFC 4034 2.1.1</span>
<span class="gi">+        and rd.protocol == 3  # RFC 4034 2.1.2</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_rrname_rdataset(</span>
<span class="gi">+    rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+) -&gt; Tuple[dns.name.Name, dns.rdataset.Rdataset]:</span>
<span class="gi">+    if isinstance(rrset, tuple):</span>
<span class="gi">+        return rrset[0], rrset[1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return rrset.name, rrset</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_signature(sig: bytes, data: bytes, key: DNSKEY) -&gt; None:</span>
<span class="gi">+    public_cls = get_algorithm_cls_from_dnskey(key).public_cls</span>
<span class="gi">+    try:</span>
<span class="gi">+        public_key = public_cls.from_dnskey(key)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ValidationFailure(&quot;invalid public key&quot;)</span>
<span class="gi">+    public_key.verify(sig, data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_rrsig(</span>
<span class="gi">+    rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+    rrsig: RRSIG,</span>
<span class="gi">+    keys: Dict[dns.name.Name, Union[dns.node.Node, dns.rdataset.Rdataset]],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    now: Optional[float] = None,</span>
<span class="gi">+    policy: Optional[Policy] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate an RRset against a single signature rdata, throwing an
<span class="w"> </span>    exception if validation is not successful.

<span class="gu">@@ -190,14 +370,44 @@ def _validate_rrsig(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.</span>
<span class="w"> </span>    Raises ``UnsupportedAlgorithm`` if the algorithm is recognized by
<span class="w"> </span>    dnspython but not implemented.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def _validate(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.</span>
<span class="gd">-    rdataset.Rdataset]], rrsigset: Union[dns.rrset.RRset, Tuple[dns.name.</span>
<span class="gd">-    Name, dns.rdataset.Rdataset]], keys: Dict[dns.name.Name, Union[dns.node</span>
<span class="gd">-    .Node, dns.rdataset.Rdataset]], origin: Optional[dns.name.Name]=None,</span>
<span class="gd">-    now: Optional[float]=None, policy: Optional[Policy]=None) -&gt;None:</span>
<span class="gi">+    if policy is None:</span>
<span class="gi">+        policy = default_policy</span>
<span class="gi">+</span>
<span class="gi">+    candidate_keys = _find_candidate_keys(keys, rrsig)</span>
<span class="gi">+    if candidate_keys is None:</span>
<span class="gi">+        raise ValidationFailure(&quot;unknown key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if now is None:</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+    if rrsig.expiration &lt; now:</span>
<span class="gi">+        raise ValidationFailure(&quot;expired&quot;)</span>
<span class="gi">+    if rrsig.inception &gt; now:</span>
<span class="gi">+        raise ValidationFailure(&quot;not yet valid&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    data = _make_rrsig_signature_data(rrset, rrsig, origin)</span>
<span class="gi">+</span>
<span class="gi">+    for candidate_key in candidate_keys:</span>
<span class="gi">+        if not policy.ok_to_validate(candidate_key):</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            _validate_signature(rrsig.signature, data, candidate_key)</span>
<span class="gi">+            return</span>
<span class="gi">+        except (InvalidSignature, ValidationFailure):</span>
<span class="gi">+            # this happens on an individual validation failure</span>
<span class="gi">+            continue</span>
<span class="gi">+    # nothing verified -- raise failure:</span>
<span class="gi">+    raise ValidationFailure(&quot;verify failure&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate(</span>
<span class="gi">+    rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+    rrsigset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+    keys: Dict[dns.name.Name, Union[dns.node.Node, dns.rdataset.Rdataset]],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    now: Optional[float] = None,</span>
<span class="gi">+    policy: Optional[Policy] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate an RRset against a signature RRset, throwing an exception
<span class="w"> </span>    if none of the signatures validate.

<span class="gu">@@ -228,15 +438,53 @@ def _validate(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.</span>
<span class="w"> </span>    the public key is invalid, the algorithm is unknown, the verification
<span class="w"> </span>    fails, etc.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def _sign(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.</span>
<span class="gd">-    Rdataset]], private_key: PrivateKey, signer: dns.name.Name, dnskey:</span>
<span class="gd">-    DNSKEY, inception: Optional[Union[datetime, str, int, float]]=None,</span>
<span class="gd">-    expiration: Optional[Union[datetime, str, int, float]]=None, lifetime:</span>
<span class="gd">-    Optional[int]=None, verify: bool=False, policy: Optional[Policy]=None,</span>
<span class="gd">-    origin: Optional[dns.name.Name]=None) -&gt;RRSIG:</span>
<span class="gi">+    if policy is None:</span>
<span class="gi">+        policy = default_policy</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(origin, str):</span>
<span class="gi">+        origin = dns.name.from_text(origin, dns.name.root)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(rrset, tuple):</span>
<span class="gi">+        rrname = rrset[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        rrname = rrset.name</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(rrsigset, tuple):</span>
<span class="gi">+        rrsigname = rrsigset[0]</span>
<span class="gi">+        rrsigrdataset = rrsigset[1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        rrsigname = rrsigset.name</span>
<span class="gi">+        rrsigrdataset = rrsigset</span>
<span class="gi">+</span>
<span class="gi">+    rrname = rrname.choose_relativity(origin)</span>
<span class="gi">+    rrsigname = rrsigname.choose_relativity(origin)</span>
<span class="gi">+    if rrname != rrsigname:</span>
<span class="gi">+        raise ValidationFailure(&quot;owner names do not match&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for rrsig in rrsigrdataset:</span>
<span class="gi">+        if not isinstance(rrsig, RRSIG):</span>
<span class="gi">+            raise ValidationFailure(&quot;expected an RRSIG&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            _validate_rrsig(rrset, rrsig, keys, origin, now, policy)</span>
<span class="gi">+            return</span>
<span class="gi">+        except (ValidationFailure, UnsupportedAlgorithm):</span>
<span class="gi">+            pass</span>
<span class="gi">+    raise ValidationFailure(&quot;no RRSIGs validated&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sign(</span>
<span class="gi">+    rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+    private_key: PrivateKey,</span>
<span class="gi">+    signer: dns.name.Name,</span>
<span class="gi">+    dnskey: DNSKEY,</span>
<span class="gi">+    inception: Optional[Union[datetime, str, int, float]] = None,</span>
<span class="gi">+    expiration: Optional[Union[datetime, str, int, float]] = None,</span>
<span class="gi">+    lifetime: Optional[int] = None,</span>
<span class="gi">+    verify: bool = False,</span>
<span class="gi">+    policy: Optional[Policy] = None,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; RRSIG:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sign RRset using private key.

<span class="w"> </span>    *rrset*, the RRset to validate.  This can be a
<span class="gu">@@ -277,12 +525,80 @@ def _sign(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.</span>

<span class="w"> </span>    Raises ``DeniedByPolicy`` if the signature is denied by policy.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def _make_rrsig_signature_data(rrset: Union[dns.rrset.RRset, Tuple[dns.name</span>
<span class="gd">-    .Name, dns.rdataset.Rdataset]], rrsig: RRSIG, origin: Optional[dns.name</span>
<span class="gd">-    .Name]=None) -&gt;bytes:</span>
<span class="gi">+    if policy is None:</span>
<span class="gi">+        policy = default_policy</span>
<span class="gi">+    if not policy.ok_to_sign(dnskey):</span>
<span class="gi">+        raise DeniedByPolicy</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(rrset, tuple):</span>
<span class="gi">+        rdclass = rrset[1].rdclass</span>
<span class="gi">+        rdtype = rrset[1].rdtype</span>
<span class="gi">+        rrname = rrset[0]</span>
<span class="gi">+        original_ttl = rrset[1].ttl</span>
<span class="gi">+    else:</span>
<span class="gi">+        rdclass = rrset.rdclass</span>
<span class="gi">+        rdtype = rrset.rdtype</span>
<span class="gi">+        rrname = rrset.name</span>
<span class="gi">+        original_ttl = rrset.ttl</span>
<span class="gi">+</span>
<span class="gi">+    if inception is not None:</span>
<span class="gi">+        rrsig_inception = to_timestamp(inception)</span>
<span class="gi">+    else:</span>
<span class="gi">+        rrsig_inception = int(time.time())</span>
<span class="gi">+</span>
<span class="gi">+    if expiration is not None:</span>
<span class="gi">+        rrsig_expiration = to_timestamp(expiration)</span>
<span class="gi">+    elif lifetime is not None:</span>
<span class="gi">+        rrsig_expiration = rrsig_inception + lifetime</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;expiration or lifetime must be specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Derelativize now because we need a correct labels length for the</span>
<span class="gi">+    # rrsig_template.</span>
<span class="gi">+    if origin is not None:</span>
<span class="gi">+        rrname = rrname.derelativize(origin)</span>
<span class="gi">+    labels = len(rrname) - 1</span>
<span class="gi">+</span>
<span class="gi">+    # Adjust labels appropriately for wildcards.</span>
<span class="gi">+    if rrname.is_wild():</span>
<span class="gi">+        labels -= 1</span>
<span class="gi">+</span>
<span class="gi">+    rrsig_template = RRSIG(</span>
<span class="gi">+        rdclass=rdclass,</span>
<span class="gi">+        rdtype=dns.rdatatype.RRSIG,</span>
<span class="gi">+        type_covered=rdtype,</span>
<span class="gi">+        algorithm=dnskey.algorithm,</span>
<span class="gi">+        labels=labels,</span>
<span class="gi">+        original_ttl=original_ttl,</span>
<span class="gi">+        expiration=rrsig_expiration,</span>
<span class="gi">+        inception=rrsig_inception,</span>
<span class="gi">+        key_tag=key_id(dnskey),</span>
<span class="gi">+        signer=signer,</span>
<span class="gi">+        signature=b&quot;&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    data = dns.dnssec._make_rrsig_signature_data(rrset, rrsig_template, origin)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(private_key, GenericPrivateKey):</span>
<span class="gi">+        signing_key = private_key</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            private_cls = get_algorithm_cls_from_dnskey(dnskey)</span>
<span class="gi">+            signing_key = private_cls(key=private_key)</span>
<span class="gi">+        except UnsupportedAlgorithm:</span>
<span class="gi">+            raise TypeError(&quot;Unsupported key algorithm&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    signature = signing_key.sign(data, verify)</span>
<span class="gi">+</span>
<span class="gi">+    return cast(RRSIG, rrsig_template.replace(signature=signature))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_rrsig_signature_data(</span>
<span class="gi">+    rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+    rrsig: RRSIG,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create signature rdata.

<span class="w"> </span>    *rrset*, the RRset to sign/validate.  This can be a
<span class="gu">@@ -298,11 +614,57 @@ def _make_rrsig_signature_data(rrset: Union[dns.rrset.RRset, Tuple[dns.name</span>
<span class="w"> </span>    Raises ``UnsupportedAlgorithm`` if the algorithm is recognized by
<span class="w"> </span>    dnspython but not implemented.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def _make_dnskey(public_key: PublicKey, algorithm: Union[int, str], flags:</span>
<span class="gd">-    int=Flag.ZONE, protocol: int=3) -&gt;DNSKEY:</span>
<span class="gi">+    if isinstance(origin, str):</span>
<span class="gi">+        origin = dns.name.from_text(origin, dns.name.root)</span>
<span class="gi">+</span>
<span class="gi">+    signer = rrsig.signer</span>
<span class="gi">+    if not signer.is_absolute():</span>
<span class="gi">+        if origin is None:</span>
<span class="gi">+            raise ValidationFailure(&quot;relative RR name without an origin specified&quot;)</span>
<span class="gi">+        signer = signer.derelativize(origin)</span>
<span class="gi">+</span>
<span class="gi">+    # For convenience, allow the rrset to be specified as a (name,</span>
<span class="gi">+    # rdataset) tuple as well as a proper rrset</span>
<span class="gi">+    rrname, rdataset = _get_rrname_rdataset(rrset)</span>
<span class="gi">+</span>
<span class="gi">+    data = b&quot;&quot;</span>
<span class="gi">+    data += rrsig.to_wire(origin=signer)[:18]</span>
<span class="gi">+    data += rrsig.signer.to_digestable(signer)</span>
<span class="gi">+</span>
<span class="gi">+    # Derelativize the name before considering labels.</span>
<span class="gi">+    if not rrname.is_absolute():</span>
<span class="gi">+        if origin is None:</span>
<span class="gi">+            raise ValidationFailure(&quot;relative RR name without an origin specified&quot;)</span>
<span class="gi">+        rrname = rrname.derelativize(origin)</span>
<span class="gi">+</span>
<span class="gi">+    name_len = len(rrname)</span>
<span class="gi">+    if rrname.is_wild() and rrsig.labels != name_len - 2:</span>
<span class="gi">+        raise ValidationFailure(&quot;wild owner name has wrong label length&quot;)</span>
<span class="gi">+    if name_len - 1 &lt; rrsig.labels:</span>
<span class="gi">+        raise ValidationFailure(&quot;owner name longer than RRSIG labels&quot;)</span>
<span class="gi">+    elif rrsig.labels &lt; name_len - 1:</span>
<span class="gi">+        suffix = rrname.split(rrsig.labels + 1)[1]</span>
<span class="gi">+        rrname = dns.name.from_text(&quot;*&quot;, suffix)</span>
<span class="gi">+    rrnamebuf = rrname.to_digestable()</span>
<span class="gi">+    rrfixed = struct.pack(&quot;!HHI&quot;, rdataset.rdtype, rdataset.rdclass, rrsig.original_ttl)</span>
<span class="gi">+    rdatas = [rdata.to_digestable(origin) for rdata in rdataset]</span>
<span class="gi">+    for rdata in sorted(rdatas):</span>
<span class="gi">+        data += rrnamebuf</span>
<span class="gi">+        data += rrfixed</span>
<span class="gi">+        rrlen = struct.pack(&quot;!H&quot;, len(rdata))</span>
<span class="gi">+        data += rrlen</span>
<span class="gi">+        data += rdata</span>
<span class="gi">+</span>
<span class="gi">+    return data</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_dnskey(</span>
<span class="gi">+    public_key: PublicKey,</span>
<span class="gi">+    algorithm: Union[int, str],</span>
<span class="gi">+    flags: int = Flag.ZONE,</span>
<span class="gi">+    protocol: int = 3,</span>
<span class="gi">+) -&gt; DNSKEY:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a public key to DNSKEY Rdata

<span class="w"> </span>    *public_key*, a ``PublicKey`` (``GenericPublicKey`` or
<span class="gu">@@ -321,11 +683,22 @@ def _make_dnskey(public_key: PublicKey, algorithm: Union[int, str], flags:</span>

<span class="w"> </span>    Return DNSKEY ``Rdata``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    algorithm = Algorithm.make(algorithm)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(public_key, GenericPublicKey):</span>
<span class="gi">+        return public_key.to_dnskey(flags=flags, protocol=protocol)</span>
<span class="gi">+    else:</span>
<span class="gi">+        public_cls = get_algorithm_cls(algorithm).public_cls</span>
<span class="gi">+        return public_cls(key=public_key).to_dnskey(flags=flags, protocol=protocol)</span>


<span class="gd">-def _make_cdnskey(public_key: PublicKey, algorithm: Union[int, str], flags:</span>
<span class="gd">-    int=Flag.ZONE, protocol: int=3) -&gt;CDNSKEY:</span>
<span class="gi">+def _make_cdnskey(</span>
<span class="gi">+    public_key: PublicKey,</span>
<span class="gi">+    algorithm: Union[int, str],</span>
<span class="gi">+    flags: int = Flag.ZONE,</span>
<span class="gi">+    protocol: int = 3,</span>
<span class="gi">+) -&gt; CDNSKEY:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a public key to CDNSKEY Rdata

<span class="w"> </span>    *public_key*, the public key to convert, a
<span class="gu">@@ -345,11 +718,25 @@ def _make_cdnskey(public_key: PublicKey, algorithm: Union[int, str], flags:</span>

<span class="w"> </span>    Return CDNSKEY ``Rdata``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    dnskey = _make_dnskey(public_key, algorithm, flags, protocol)</span>

<span class="gd">-def nsec3_hash(domain: Union[dns.name.Name, str], salt: Optional[Union[str,</span>
<span class="gd">-    bytes]], iterations: int, algorithm: Union[int, str]) -&gt;str:</span>
<span class="gi">+    return CDNSKEY(</span>
<span class="gi">+        rdclass=dnskey.rdclass,</span>
<span class="gi">+        rdtype=dns.rdatatype.CDNSKEY,</span>
<span class="gi">+        flags=dnskey.flags,</span>
<span class="gi">+        protocol=dnskey.protocol,</span>
<span class="gi">+        algorithm=dnskey.algorithm,</span>
<span class="gi">+        key=dnskey.key,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def nsec3_hash(</span>
<span class="gi">+    domain: Union[dns.name.Name, str],</span>
<span class="gi">+    salt: Optional[Union[str, bytes]],</span>
<span class="gi">+    iterations: int,</span>
<span class="gi">+    algorithm: Union[int, str],</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Calculate the NSEC3 hash, according to
<span class="w"> </span>    https://tools.ietf.org/html/rfc5155#section-5
<span class="gu">@@ -366,12 +753,50 @@ def nsec3_hash(domain: Union[dns.name.Name, str], salt: Optional[Union[str,</span>

<span class="w"> </span>    Returns a ``str``, the encoded NSEC3 hash.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def make_ds_rdataset(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns</span>
<span class="gd">-    .rdataset.Rdataset]], algorithms: Set[Union[DSDigest, str]], origin:</span>
<span class="gd">-    Optional[dns.name.Name]=None) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+    b32_conversion = str.maketrans(</span>
<span class="gi">+        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;, &quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(algorithm, str):</span>
<span class="gi">+            algorithm = NSEC3Hash[algorithm.upper()]</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        raise ValueError(&quot;Wrong hash algorithm (only SHA1 is supported)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if algorithm != NSEC3Hash.SHA1:</span>
<span class="gi">+        raise ValueError(&quot;Wrong hash algorithm (only SHA1 is supported)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if salt is None:</span>
<span class="gi">+        salt_encoded = b&quot;&quot;</span>
<span class="gi">+    elif isinstance(salt, str):</span>
<span class="gi">+        if len(salt) % 2 == 0:</span>
<span class="gi">+            salt_encoded = bytes.fromhex(salt)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Invalid salt length&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        salt_encoded = salt</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(domain, dns.name.Name):</span>
<span class="gi">+        domain = dns.name.from_text(domain)</span>
<span class="gi">+    domain_encoded = domain.canonicalize().to_wire()</span>
<span class="gi">+    assert domain_encoded is not None</span>
<span class="gi">+</span>
<span class="gi">+    digest = hashlib.sha1(domain_encoded + salt_encoded).digest()</span>
<span class="gi">+    for _ in range(iterations):</span>
<span class="gi">+        digest = hashlib.sha1(digest + salt_encoded).digest()</span>
<span class="gi">+</span>
<span class="gi">+    output = base64.b32encode(digest).decode(&quot;utf-8&quot;)</span>
<span class="gi">+    output = output.translate(b32_conversion)</span>
<span class="gi">+</span>
<span class="gi">+    return output</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_ds_rdataset(</span>
<span class="gi">+    rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],</span>
<span class="gi">+    algorithms: Set[Union[DSDigest, str]],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a DS record from DNSKEY/CDNSKEY/CDS.

<span class="w"> </span>    *rrset*, the RRset to create DS Rdataset for.  This can be a
<span class="gu">@@ -391,11 +816,43 @@ def make_ds_rdataset(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns</span>

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def cds_rdataset_to_ds_rdataset(rdataset: dns.rdataset.Rdataset</span>
<span class="gd">-    ) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+    rrname, rdataset = _get_rrname_rdataset(rrset)</span>
<span class="gi">+</span>
<span class="gi">+    if rdataset.rdtype not in (</span>
<span class="gi">+        dns.rdatatype.DNSKEY,</span>
<span class="gi">+        dns.rdatatype.CDNSKEY,</span>
<span class="gi">+        dns.rdatatype.CDS,</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise ValueError(&quot;rrset not a DNSKEY/CDNSKEY/CDS&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    _algorithms = set()</span>
<span class="gi">+    for algorithm in algorithms:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(algorithm, str):</span>
<span class="gi">+                algorithm = DSDigest[algorithm.upper()]</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise UnsupportedAlgorithm(&#39;unsupported algorithm &quot;%s&quot;&#39; % algorithm)</span>
<span class="gi">+        _algorithms.add(algorithm)</span>
<span class="gi">+</span>
<span class="gi">+    if rdataset.rdtype == dns.rdatatype.CDS:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        for rdata in cds_rdataset_to_ds_rdataset(rdataset):</span>
<span class="gi">+            if rdata.digest_type in _algorithms:</span>
<span class="gi">+                res.append(rdata)</span>
<span class="gi">+        if len(res) == 0:</span>
<span class="gi">+            raise ValueError(&quot;no acceptable CDS rdata found&quot;)</span>
<span class="gi">+        return dns.rdataset.from_rdata_list(rdataset.ttl, res)</span>
<span class="gi">+</span>
<span class="gi">+    res = []</span>
<span class="gi">+    for algorithm in _algorithms:</span>
<span class="gi">+        res.extend(dnskey_rdataset_to_cds_rdataset(rrname, rdataset, algorithm, origin))</span>
<span class="gi">+    return dns.rdataset.from_rdata_list(rdataset.ttl, res)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cds_rdataset_to_ds_rdataset(</span>
<span class="gi">+    rdataset: dns.rdataset.Rdataset,</span>
<span class="gi">+) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a CDS record from DS.

<span class="w"> </span>    *rdataset*, a ``dns.rdataset.Rdataset``, to create DS Rdataset for.
<span class="gu">@@ -404,12 +861,30 @@ def cds_rdataset_to_ds_rdataset(rdataset: dns.rdataset.Rdataset</span>

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def dnskey_rdataset_to_cds_rdataset(name: Union[dns.name.Name, str],</span>
<span class="gd">-    rdataset: dns.rdataset.Rdataset, algorithm: Union[DSDigest, str],</span>
<span class="gd">-    origin: Optional[dns.name.Name]=None) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+    if rdataset.rdtype != dns.rdatatype.CDS:</span>
<span class="gi">+        raise ValueError(&quot;rdataset not a CDS&quot;)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    for rdata in rdataset:</span>
<span class="gi">+        res.append(</span>
<span class="gi">+            CDS(</span>
<span class="gi">+                rdclass=rdata.rdclass,</span>
<span class="gi">+                rdtype=dns.rdatatype.DS,</span>
<span class="gi">+                key_tag=rdata.key_tag,</span>
<span class="gi">+                algorithm=rdata.algorithm,</span>
<span class="gi">+                digest_type=rdata.digest_type,</span>
<span class="gi">+                digest=rdata.digest,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    return dns.rdataset.from_rdata_list(rdataset.ttl, res)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dnskey_rdataset_to_cds_rdataset(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    rdataset: dns.rdataset.Rdataset,</span>
<span class="gi">+    algorithm: Union[DSDigest, str],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a CDS record from DNSKEY/CDNSKEY.

<span class="w"> </span>    *name*, a ``dns.name.Name`` or ``str``, the owner name of the CDS record.
<span class="gu">@@ -428,37 +903,95 @@ def dnskey_rdataset_to_cds_rdataset(name: Union[dns.name.Name, str],</span>

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if rdataset.rdtype not in (dns.rdatatype.DNSKEY, dns.rdatatype.CDNSKEY):</span>
<span class="gi">+        raise ValueError(&quot;rdataset not a DNSKEY/CDNSKEY&quot;)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    for rdata in rdataset:</span>
<span class="gi">+        res.append(make_cds(name, rdata, algorithm, origin))</span>
<span class="gi">+    return dns.rdataset.from_rdata_list(rdataset.ttl, res)</span>


<span class="gd">-def dnskey_rdataset_to_cdnskey_rdataset(rdataset: dns.rdataset.Rdataset</span>
<span class="gd">-    ) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+def dnskey_rdataset_to_cdnskey_rdataset(</span>
<span class="gi">+    rdataset: dns.rdataset.Rdataset,</span>
<span class="gi">+) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a CDNSKEY record from DNSKEY.

<span class="w"> </span>    *rdataset*, a ``dns.rdataset.Rdataset``, to create CDNSKEY Rdataset for.

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def default_rrset_signer(txn: dns.transaction.Transaction, rrset: dns.rrset</span>
<span class="gd">-    .RRset, signer: dns.name.Name, ksks: List[Tuple[PrivateKey, DNSKEY]],</span>
<span class="gd">-    zsks: List[Tuple[PrivateKey, DNSKEY]], inception: Optional[Union[</span>
<span class="gd">-    datetime, str, int, float]]=None, expiration: Optional[Union[datetime,</span>
<span class="gd">-    str, int, float]]=None, lifetime: Optional[int]=None, policy: Optional[</span>
<span class="gd">-    Policy]=None, origin: Optional[dns.name.Name]=None) -&gt;None:</span>
<span class="gi">+    if rdataset.rdtype != dns.rdatatype.DNSKEY:</span>
<span class="gi">+        raise ValueError(&quot;rdataset not a DNSKEY&quot;)</span>
<span class="gi">+    res = []</span>
<span class="gi">+    for rdata in rdataset:</span>
<span class="gi">+        res.append(</span>
<span class="gi">+            CDNSKEY(</span>
<span class="gi">+                rdclass=rdataset.rdclass,</span>
<span class="gi">+                rdtype=rdataset.rdtype,</span>
<span class="gi">+                flags=rdata.flags,</span>
<span class="gi">+                protocol=rdata.protocol,</span>
<span class="gi">+                algorithm=rdata.algorithm,</span>
<span class="gi">+                key=rdata.key,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    return dns.rdataset.from_rdata_list(rdataset.ttl, res)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_rrset_signer(</span>
<span class="gi">+    txn: dns.transaction.Transaction,</span>
<span class="gi">+    rrset: dns.rrset.RRset,</span>
<span class="gi">+    signer: dns.name.Name,</span>
<span class="gi">+    ksks: List[Tuple[PrivateKey, DNSKEY]],</span>
<span class="gi">+    zsks: List[Tuple[PrivateKey, DNSKEY]],</span>
<span class="gi">+    inception: Optional[Union[datetime, str, int, float]] = None,</span>
<span class="gi">+    expiration: Optional[Union[datetime, str, int, float]] = None,</span>
<span class="gi">+    lifetime: Optional[int] = None,</span>
<span class="gi">+    policy: Optional[Policy] = None,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Default RRset signer&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def sign_zone(zone: dns.zone.Zone, txn: Optional[dns.transaction.</span>
<span class="gd">-    Transaction]=None, keys: Optional[List[Tuple[PrivateKey, DNSKEY]]]=None,</span>
<span class="gd">-    add_dnskey: bool=True, dnskey_ttl: Optional[int]=None, inception:</span>
<span class="gd">-    Optional[Union[datetime, str, int, float]]=None, expiration: Optional[</span>
<span class="gd">-    Union[datetime, str, int, float]]=None, lifetime: Optional[int]=None,</span>
<span class="gd">-    nsec3: Optional[NSEC3PARAM]=None, rrset_signer: Optional[RRsetSigner]=</span>
<span class="gd">-    None, policy: Optional[Policy]=None) -&gt;None:</span>
<span class="gi">+    if rrset.rdtype in set(</span>
<span class="gi">+        [</span>
<span class="gi">+            dns.rdatatype.RdataType.DNSKEY,</span>
<span class="gi">+            dns.rdatatype.RdataType.CDS,</span>
<span class="gi">+            dns.rdatatype.RdataType.CDNSKEY,</span>
<span class="gi">+        ]</span>
<span class="gi">+    ):</span>
<span class="gi">+        keys = ksks</span>
<span class="gi">+    else:</span>
<span class="gi">+        keys = zsks</span>
<span class="gi">+</span>
<span class="gi">+    for private_key, dnskey in keys:</span>
<span class="gi">+        rrsig = dns.dnssec.sign(</span>
<span class="gi">+            rrset=rrset,</span>
<span class="gi">+            private_key=private_key,</span>
<span class="gi">+            dnskey=dnskey,</span>
<span class="gi">+            inception=inception,</span>
<span class="gi">+            expiration=expiration,</span>
<span class="gi">+            lifetime=lifetime,</span>
<span class="gi">+            signer=signer,</span>
<span class="gi">+            policy=policy,</span>
<span class="gi">+            origin=origin,</span>
<span class="gi">+        )</span>
<span class="gi">+        txn.add(rrset.name, rrset.ttl, rrsig)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sign_zone(</span>
<span class="gi">+    zone: dns.zone.Zone,</span>
<span class="gi">+    txn: Optional[dns.transaction.Transaction] = None,</span>
<span class="gi">+    keys: Optional[List[Tuple[PrivateKey, DNSKEY]]] = None,</span>
<span class="gi">+    add_dnskey: bool = True,</span>
<span class="gi">+    dnskey_ttl: Optional[int] = None,</span>
<span class="gi">+    inception: Optional[Union[datetime, str, int, float]] = None,</span>
<span class="gi">+    expiration: Optional[Union[datetime, str, int, float]] = None,</span>
<span class="gi">+    lifetime: Optional[int] = None,</span>
<span class="gi">+    nsec3: Optional[NSEC3PARAM] = None,</span>
<span class="gi">+    rrset_signer: Optional[RRsetSigner] = None,</span>
<span class="gi">+    policy: Optional[Policy] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sign zone.

<span class="w"> </span>    *zone*, a ``dns.zone.Zone``, the zone to sign.
<span class="gu">@@ -499,37 +1032,176 @@ def sign_zone(zone: dns.zone.Zone, txn: Optional[dns.transaction.</span>

<span class="w"> </span>    Returns ``None``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def _sign_zone_nsec(zone: dns.zone.Zone, txn: dns.transaction.Transaction,</span>
<span class="gd">-    rrset_signer: Optional[RRsetSigner]=None) -&gt;None:</span>
<span class="gi">+    ksks = []</span>
<span class="gi">+    zsks = []</span>
<span class="gi">+</span>
<span class="gi">+    # if we have both KSKs and ZSKs, split by SEP flag. if not, sign all</span>
<span class="gi">+    # records with all keys</span>
<span class="gi">+    if keys:</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            if key[1].flags &amp; Flag.SEP:</span>
<span class="gi">+                ksks.append(key)</span>
<span class="gi">+            else:</span>
<span class="gi">+                zsks.append(key)</span>
<span class="gi">+        if not ksks:</span>
<span class="gi">+            ksks = keys</span>
<span class="gi">+        if not zsks:</span>
<span class="gi">+            zsks = keys</span>
<span class="gi">+    else:</span>
<span class="gi">+        keys = []</span>
<span class="gi">+</span>
<span class="gi">+    if txn:</span>
<span class="gi">+        cm: contextlib.AbstractContextManager = contextlib.nullcontext(txn)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = zone.writer()</span>
<span class="gi">+</span>
<span class="gi">+    with cm as _txn:</span>
<span class="gi">+        if add_dnskey:</span>
<span class="gi">+            if dnskey_ttl is None:</span>
<span class="gi">+                dnskey = _txn.get(zone.origin, dns.rdatatype.DNSKEY)</span>
<span class="gi">+                if dnskey:</span>
<span class="gi">+                    dnskey_ttl = dnskey.ttl</span>
<span class="gi">+                else:</span>
<span class="gi">+                    soa = _txn.get(zone.origin, dns.rdatatype.SOA)</span>
<span class="gi">+                    dnskey_ttl = soa.ttl</span>
<span class="gi">+            for _, dnskey in keys:</span>
<span class="gi">+                _txn.add(zone.origin, dnskey_ttl, dnskey)</span>
<span class="gi">+</span>
<span class="gi">+        if nsec3:</span>
<span class="gi">+            raise NotImplementedError(&quot;Signing with NSEC3 not yet implemented&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            _rrset_signer = rrset_signer or functools.partial(</span>
<span class="gi">+                default_rrset_signer,</span>
<span class="gi">+                signer=zone.origin,</span>
<span class="gi">+                ksks=ksks,</span>
<span class="gi">+                zsks=zsks,</span>
<span class="gi">+                inception=inception,</span>
<span class="gi">+                expiration=expiration,</span>
<span class="gi">+                lifetime=lifetime,</span>
<span class="gi">+                policy=policy,</span>
<span class="gi">+                origin=zone.origin,</span>
<span class="gi">+            )</span>
<span class="gi">+            return _sign_zone_nsec(zone, _txn, _rrset_signer)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sign_zone_nsec(</span>
<span class="gi">+    zone: dns.zone.Zone,</span>
<span class="gi">+    txn: dns.transaction.Transaction,</span>
<span class="gi">+    rrset_signer: Optional[RRsetSigner] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;NSEC zone signer&quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-if dns._features.have(&#39;dnssec&#39;):</span>
<span class="gi">+    def _txn_add_nsec(</span>
<span class="gi">+        txn: dns.transaction.Transaction,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        next_secure: Optional[dns.name.Name],</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        ttl: int,</span>
<span class="gi">+        rrset_signer: Optional[RRsetSigner] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;NSEC zone signer helper&quot;&quot;&quot;</span>
<span class="gi">+        mandatory_types = set(</span>
<span class="gi">+            [dns.rdatatype.RdataType.RRSIG, dns.rdatatype.RdataType.NSEC]</span>
<span class="gi">+        )</span>
<span class="gi">+        node = txn.get_node(name)</span>
<span class="gi">+        if node and next_secure:</span>
<span class="gi">+            types = (</span>
<span class="gi">+                set([rdataset.rdtype for rdataset in node.rdatasets]) | mandatory_types</span>
<span class="gi">+            )</span>
<span class="gi">+            windows = Bitmap.from_rdtypes(list(types))</span>
<span class="gi">+            rrset = dns.rrset.from_rdata(</span>
<span class="gi">+                name,</span>
<span class="gi">+                ttl,</span>
<span class="gi">+                NSEC(</span>
<span class="gi">+                    rdclass=rdclass,</span>
<span class="gi">+                    rdtype=dns.rdatatype.RdataType.NSEC,</span>
<span class="gi">+                    next=next_secure,</span>
<span class="gi">+                    windows=windows,</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            txn.add(rrset)</span>
<span class="gi">+            if rrset_signer:</span>
<span class="gi">+                rrset_signer(txn, rrset)</span>
<span class="gi">+</span>
<span class="gi">+    rrsig_ttl = zone.get_soa().minimum</span>
<span class="gi">+    delegation = None</span>
<span class="gi">+    last_secure = None</span>
<span class="gi">+</span>
<span class="gi">+    for name in sorted(txn.iterate_names()):</span>
<span class="gi">+        if delegation and name.is_subdomain(delegation):</span>
<span class="gi">+            # names below delegations are not secure</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif txn.get(name, dns.rdatatype.NS) and name != zone.origin:</span>
<span class="gi">+            # inside delegation</span>
<span class="gi">+            delegation = name</span>
<span class="gi">+        else:</span>
<span class="gi">+            # outside delegation</span>
<span class="gi">+            delegation = None</span>
<span class="gi">+</span>
<span class="gi">+        if rrset_signer:</span>
<span class="gi">+            node = txn.get_node(name)</span>
<span class="gi">+            if node:</span>
<span class="gi">+                for rdataset in node.rdatasets:</span>
<span class="gi">+                    if rdataset.rdtype == dns.rdatatype.RRSIG:</span>
<span class="gi">+                        # do not sign RRSIGs</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    elif delegation and rdataset.rdtype != dns.rdatatype.DS:</span>
<span class="gi">+                        # do not sign delegations except DS records</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        rrset = dns.rrset.from_rdata(name, rdataset.ttl, *rdataset)</span>
<span class="gi">+                        rrset_signer(txn, rrset)</span>
<span class="gi">+</span>
<span class="gi">+        # We need &quot;is not None&quot; as the empty name is False because its length is 0.</span>
<span class="gi">+        if last_secure is not None:</span>
<span class="gi">+            _txn_add_nsec(txn, last_secure, name, zone.rdclass, rrsig_ttl, rrset_signer)</span>
<span class="gi">+        last_secure = name</span>
<span class="gi">+</span>
<span class="gi">+    if last_secure:</span>
<span class="gi">+        _txn_add_nsec(</span>
<span class="gi">+            txn, last_secure, zone.origin, zone.rdclass, rrsig_ttl, rrset_signer</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _need_pyca(*args, **kwargs):</span>
<span class="gi">+    raise ImportError(</span>
<span class="gi">+        &quot;DNSSEC validation requires python cryptography&quot;</span>
<span class="gi">+    )  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if dns._features.have(&quot;dnssec&quot;):</span>
<span class="w"> </span>    from cryptography.exceptions import InvalidSignature
<span class="gd">-    from cryptography.hazmat.primitives.asymmetric import dsa</span>
<span class="gd">-    from cryptography.hazmat.primitives.asymmetric import ec</span>
<span class="gd">-    from cryptography.hazmat.primitives.asymmetric import ed448</span>
<span class="gd">-    from cryptography.hazmat.primitives.asymmetric import rsa</span>
<span class="gd">-    from cryptography.hazmat.primitives.asymmetric import ed25519</span>
<span class="gd">-    from dns.dnssecalgs import get_algorithm_cls, get_algorithm_cls_from_dnskey</span>
<span class="gi">+    from cryptography.hazmat.primitives.asymmetric import dsa  # pylint: disable=W0611</span>
<span class="gi">+    from cryptography.hazmat.primitives.asymmetric import ec  # pylint: disable=W0611</span>
<span class="gi">+    from cryptography.hazmat.primitives.asymmetric import ed448  # pylint: disable=W0611</span>
<span class="gi">+    from cryptography.hazmat.primitives.asymmetric import rsa  # pylint: disable=W0611</span>
<span class="gi">+    from cryptography.hazmat.primitives.asymmetric import (  # pylint: disable=W0611</span>
<span class="gi">+        ed25519,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    from dns.dnssecalgs import (  # pylint: disable=C0412</span>
<span class="gi">+        get_algorithm_cls,</span>
<span class="gi">+        get_algorithm_cls_from_dnskey,</span>
<span class="gi">+    )</span>
<span class="w"> </span>    from dns.dnssecalgs.base import GenericPrivateKey, GenericPublicKey
<span class="gd">-    validate = _validate</span>
<span class="gd">-    validate_rrsig = _validate_rrsig</span>
<span class="gi">+</span>
<span class="gi">+    validate = _validate  # type: ignore</span>
<span class="gi">+    validate_rrsig = _validate_rrsig  # type: ignore</span>
<span class="w"> </span>    sign = _sign
<span class="w"> </span>    make_dnskey = _make_dnskey
<span class="w"> </span>    make_cdnskey = _make_cdnskey
<span class="w"> </span>    _have_pyca = True
<span class="gd">-else:</span>
<span class="gi">+else:  # pragma: no cover</span>
<span class="w"> </span>    validate = _need_pyca
<span class="w"> </span>    validate_rrsig = _need_pyca
<span class="w"> </span>    sign = _need_pyca
<span class="w"> </span>    make_dnskey = _need_pyca
<span class="w"> </span>    make_cdnskey = _need_pyca
<span class="w"> </span>    _have_pyca = False
<span class="gi">+</span>
<span class="gi">+### BEGIN generated Algorithm constants</span>
<span class="gi">+</span>
<span class="w"> </span>RSAMD5 = Algorithm.RSAMD5
<span class="w"> </span>DH = Algorithm.DH
<span class="w"> </span>DSA = Algorithm.DSA
<span class="gu">@@ -547,3 +1219,5 @@ ED448 = Algorithm.ED448</span>
<span class="w"> </span>INDIRECT = Algorithm.INDIRECT
<span class="w"> </span>PRIVATEDNS = Algorithm.PRIVATEDNS
<span class="w"> </span>PRIVATEOID = Algorithm.PRIVATEOID
<span class="gi">+</span>
<span class="gi">+### END generated Algorithm constants</span>
<span class="gh">diff --git a/dns/dnssecalgs/base.py b/dns/dnssecalgs/base.py</span>
<span class="gh">index 9fc70e6..e990575 100644</span>
<span class="gd">--- a/dns/dnssecalgs/base.py</span>
<span class="gi">+++ b/dns/dnssecalgs/base.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="gd">-from abc import ABC, abstractmethod</span>
<span class="gi">+from abc import ABC, abstractmethod  # pylint: disable=no-name-in-module</span>
<span class="w"> </span>from typing import Any, Optional, Type
<span class="gi">+</span>
<span class="w"> </span>import dns.rdataclass
<span class="w"> </span>import dns.rdatatype
<span class="w"> </span>from dns.dnssectypes import Algorithm
<span class="gu">@@ -12,68 +13,72 @@ class GenericPublicKey(ABC):</span>
<span class="w"> </span>    algorithm: Algorithm

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def __init__(self, key: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, key: Any) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def verify(self, signature: bytes, data: bytes) -&gt;None:</span>
<span class="gi">+    def verify(self, signature: bytes, data: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify signed DNSSEC data&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def encode_key_bytes(self) -&gt;bytes:</span>
<span class="gi">+    def encode_key_bytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode key as bytes for DNSKEY&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_dnskey(self, flags: int=Flag.ZONE, protocol: int=3) -&gt;DNSKEY:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _ensure_algorithm_key_combination(cls, key: DNSKEY) -&gt; None:</span>
<span class="gi">+        if key.algorithm != cls.algorithm:</span>
<span class="gi">+            raise AlgorithmKeyMismatch</span>
<span class="gi">+</span>
<span class="gi">+    def to_dnskey(self, flags: int = Flag.ZONE, protocol: int = 3) -&gt; DNSKEY:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return public key as DNSKEY&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DNSKEY(</span>
<span class="gi">+            rdclass=dns.rdataclass.IN,</span>
<span class="gi">+            rdtype=dns.rdatatype.DNSKEY,</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            protocol=protocol,</span>
<span class="gi">+            algorithm=self.algorithm,</span>
<span class="gi">+            key=self.encode_key_bytes(),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    @abstractmethod
<span class="gd">-    def from_dnskey(cls, key: DNSKEY) -&gt;&#39;GenericPublicKey&#39;:</span>
<span class="gi">+    def from_dnskey(cls, key: DNSKEY) -&gt; &quot;GenericPublicKey&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create public key from DNSKEY&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    @abstractmethod
<span class="gd">-    def from_pem(cls, public_pem: bytes) -&gt;&#39;GenericPublicKey&#39;:</span>
<span class="gi">+    def from_pem(cls, public_pem: bytes) -&gt; &quot;GenericPublicKey&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create public key from PEM-encoded SubjectPublicKeyInfo as specified
<span class="w"> </span>        in RFC 5280&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def to_pem(self) -&gt;bytes:</span>
<span class="gi">+    def to_pem(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return public-key as PEM-encoded SubjectPublicKeyInfo as specified
<span class="w"> </span>        in RFC 5280&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class GenericPrivateKey(ABC):
<span class="w"> </span>    public_cls: Type[GenericPublicKey]

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def __init__(self, key: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, key: Any) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:</span>
<span class="gi">+    def sign(self, data: bytes, verify: bool = False) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign DNSSEC data&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def public_key(self) -&gt;&#39;GenericPublicKey&#39;:</span>
<span class="gi">+    def public_key(self) -&gt; &quot;GenericPublicKey&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return public key instance&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    @abstractmethod
<span class="gd">-    def from_pem(cls, private_pem: bytes, password: Optional[bytes]=None</span>
<span class="gd">-        ) -&gt;&#39;GenericPrivateKey&#39;:</span>
<span class="gi">+    def from_pem(</span>
<span class="gi">+        cls, private_pem: bytes, password: Optional[bytes] = None</span>
<span class="gi">+    ) -&gt; &quot;GenericPrivateKey&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create private key from PEM-encoded PKCS#8&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def to_pem(self, password: Optional[bytes]=None) -&gt;bytes:</span>
<span class="gi">+    def to_pem(self, password: Optional[bytes] = None) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return private key as PEM-encoded PKCS#8&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gh">diff --git a/dns/dnssecalgs/cryptography.py b/dns/dnssecalgs/cryptography.py</span>
<span class="gh">index cdc4553..5a31a81 100644</span>
<span class="gd">--- a/dns/dnssecalgs/cryptography.py</span>
<span class="gi">+++ b/dns/dnssecalgs/cryptography.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>from typing import Any, Optional, Type
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.primitives import serialization
<span class="gi">+</span>
<span class="w"> </span>from dns.dnssecalgs.base import GenericPrivateKey, GenericPublicKey
<span class="w"> </span>from dns.exception import AlgorithmKeyMismatch

<span class="gu">@@ -8,22 +10,59 @@ class CryptographyPublicKey(GenericPublicKey):</span>
<span class="w"> </span>    key: Any = None
<span class="w"> </span>    key_cls: Any = None

<span class="gd">-    def __init__(self, key: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, key: Any) -&gt; None:  # pylint: disable=super-init-not-called</span>
<span class="w"> </span>        if self.key_cls is None:
<span class="gd">-            raise TypeError(&#39;Undefined private key class&#39;)</span>
<span class="gd">-        if not isinstance(key, self.key_cls):</span>
<span class="gi">+            raise TypeError(&quot;Undefined private key class&quot;)</span>
<span class="gi">+        if not isinstance(  # pylint: disable=isinstance-second-argument-not-valid-type</span>
<span class="gi">+            key, self.key_cls</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            raise AlgorithmKeyMismatch
<span class="w"> </span>        self.key = key

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_pem(cls, public_pem: bytes) -&gt; &quot;GenericPublicKey&quot;:</span>
<span class="gi">+        key = serialization.load_pem_public_key(public_pem)</span>
<span class="gi">+        return cls(key=key)</span>
<span class="gi">+</span>
<span class="gi">+    def to_pem(self) -&gt; bytes:</span>
<span class="gi">+        return self.key.public_bytes(</span>
<span class="gi">+            encoding=serialization.Encoding.PEM,</span>
<span class="gi">+            format=serialization.PublicFormat.SubjectPublicKeyInfo,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class CryptographyPrivateKey(GenericPrivateKey):
<span class="w"> </span>    key: Any = None
<span class="w"> </span>    key_cls: Any = None
<span class="w"> </span>    public_cls: Type[CryptographyPublicKey]

<span class="gd">-    def __init__(self, key: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, key: Any) -&gt; None:  # pylint: disable=super-init-not-called</span>
<span class="w"> </span>        if self.key_cls is None:
<span class="gd">-            raise TypeError(&#39;Undefined private key class&#39;)</span>
<span class="gd">-        if not isinstance(key, self.key_cls):</span>
<span class="gi">+            raise TypeError(&quot;Undefined private key class&quot;)</span>
<span class="gi">+        if not isinstance(  # pylint: disable=isinstance-second-argument-not-valid-type</span>
<span class="gi">+            key, self.key_cls</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            raise AlgorithmKeyMismatch
<span class="w"> </span>        self.key = key
<span class="gi">+</span>
<span class="gi">+    def public_key(self) -&gt; &quot;CryptographyPublicKey&quot;:</span>
<span class="gi">+        return self.public_cls(key=self.key.public_key())</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_pem(</span>
<span class="gi">+        cls, private_pem: bytes, password: Optional[bytes] = None</span>
<span class="gi">+    ) -&gt; &quot;GenericPrivateKey&quot;:</span>
<span class="gi">+        key = serialization.load_pem_private_key(private_pem, password=password)</span>
<span class="gi">+        return cls(key=key)</span>
<span class="gi">+</span>
<span class="gi">+    def to_pem(self, password: Optional[bytes] = None) -&gt; bytes:</span>
<span class="gi">+        encryption_algorithm: serialization.KeySerializationEncryption</span>
<span class="gi">+        if password:</span>
<span class="gi">+            encryption_algorithm = serialization.BestAvailableEncryption(password)</span>
<span class="gi">+        else:</span>
<span class="gi">+            encryption_algorithm = serialization.NoEncryption()</span>
<span class="gi">+        return self.key.private_bytes(</span>
<span class="gi">+            encoding=serialization.Encoding.PEM,</span>
<span class="gi">+            format=serialization.PrivateFormat.PKCS8,</span>
<span class="gi">+            encryption_algorithm=encryption_algorithm,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/dns/dnssecalgs/dsa.py b/dns/dnssecalgs/dsa.py</span>
<span class="gh">index d09a487..0fe4690 100644</span>
<span class="gd">--- a/dns/dnssecalgs/dsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/dsa.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import hashes
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import dsa, utils
<span class="gi">+</span>
<span class="w"> </span>from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
<span class="w"> </span>from dns.dnssectypes import Algorithm
<span class="w"> </span>from dns.rdtypes.ANY.DNSKEY import DNSKEY
<span class="gu">@@ -13,9 +15,52 @@ class PublicDSA(CryptographyPublicKey):</span>
<span class="w"> </span>    algorithm = Algorithm.DSA
<span class="w"> </span>    chosen_hash = hashes.SHA1()

<span class="gd">-    def encode_key_bytes(self) -&gt;bytes:</span>
<span class="gi">+    def verify(self, signature: bytes, data: bytes) -&gt; None:</span>
<span class="gi">+        sig_r = signature[1:21]</span>
<span class="gi">+        sig_s = signature[21:]</span>
<span class="gi">+        sig = utils.encode_dss_signature(</span>
<span class="gi">+            int.from_bytes(sig_r, &quot;big&quot;), int.from_bytes(sig_s, &quot;big&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        self.key.verify(sig, data, self.chosen_hash)</span>
<span class="gi">+</span>
<span class="gi">+    def encode_key_bytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 2536, section 2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pn = self.key.public_numbers()</span>
<span class="gi">+        dsa_t = (self.key.key_size // 8 - 64) // 8</span>
<span class="gi">+        if dsa_t &gt; 8:</span>
<span class="gi">+            raise ValueError(&quot;unsupported DSA key size&quot;)</span>
<span class="gi">+        octets = 64 + dsa_t * 8</span>
<span class="gi">+        res = struct.pack(&quot;!B&quot;, dsa_t)</span>
<span class="gi">+        res += pn.parameter_numbers.q.to_bytes(20, &quot;big&quot;)</span>
<span class="gi">+        res += pn.parameter_numbers.p.to_bytes(octets, &quot;big&quot;)</span>
<span class="gi">+        res += pn.parameter_numbers.g.to_bytes(octets, &quot;big&quot;)</span>
<span class="gi">+        res += pn.y.to_bytes(octets, &quot;big&quot;)</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dnskey(cls, key: DNSKEY) -&gt; &quot;PublicDSA&quot;:</span>
<span class="gi">+        cls._ensure_algorithm_key_combination(key)</span>
<span class="gi">+        keyptr = key.key</span>
<span class="gi">+        (t,) = struct.unpack(&quot;!B&quot;, keyptr[0:1])</span>
<span class="gi">+        keyptr = keyptr[1:]</span>
<span class="gi">+        octets = 64 + t * 8</span>
<span class="gi">+        dsa_q = keyptr[0:20]</span>
<span class="gi">+        keyptr = keyptr[20:]</span>
<span class="gi">+        dsa_p = keyptr[0:octets]</span>
<span class="gi">+        keyptr = keyptr[octets:]</span>
<span class="gi">+        dsa_g = keyptr[0:octets]</span>
<span class="gi">+        keyptr = keyptr[octets:]</span>
<span class="gi">+        dsa_y = keyptr[0:octets]</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=dsa.DSAPublicNumbers(  # type: ignore</span>
<span class="gi">+                int.from_bytes(dsa_y, &quot;big&quot;),</span>
<span class="gi">+                dsa.DSAParameterNumbers(</span>
<span class="gi">+                    int.from_bytes(dsa_p, &quot;big&quot;),</span>
<span class="gi">+                    int.from_bytes(dsa_q, &quot;big&quot;),</span>
<span class="gi">+                    int.from_bytes(dsa_g, &quot;big&quot;),</span>
<span class="gi">+                ),</span>
<span class="gi">+            ).public_key(default_backend()),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PrivateDSA(CryptographyPrivateKey):
<span class="gu">@@ -23,9 +68,29 @@ class PrivateDSA(CryptographyPrivateKey):</span>
<span class="w"> </span>    key_cls = dsa.DSAPrivateKey
<span class="w"> </span>    public_cls = PublicDSA

<span class="gd">-    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:</span>
<span class="gi">+    def sign(self, data: bytes, verify: bool = False) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 2536, section 3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        public_dsa_key = self.key.public_key()</span>
<span class="gi">+        if public_dsa_key.key_size &gt; 1024:</span>
<span class="gi">+            raise ValueError(&quot;DSA key size overflow&quot;)</span>
<span class="gi">+        der_signature = self.key.sign(data, self.public_cls.chosen_hash)</span>
<span class="gi">+        dsa_r, dsa_s = utils.decode_dss_signature(der_signature)</span>
<span class="gi">+        dsa_t = (public_dsa_key.key_size // 8 - 64) // 8</span>
<span class="gi">+        octets = 20</span>
<span class="gi">+        signature = (</span>
<span class="gi">+            struct.pack(&quot;!B&quot;, dsa_t)</span>
<span class="gi">+            + int.to_bytes(dsa_r, length=octets, byteorder=&quot;big&quot;)</span>
<span class="gi">+            + int.to_bytes(dsa_s, length=octets, byteorder=&quot;big&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.public_key().verify(signature, data)</span>
<span class="gi">+        return signature</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def generate(cls, key_size: int) -&gt; &quot;PrivateDSA&quot;:</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=dsa.generate_private_key(key_size=key_size),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PublicDSANSEC3SHA1(PublicDSA):
<span class="gh">diff --git a/dns/dnssecalgs/ecdsa.py b/dns/dnssecalgs/ecdsa.py</span>
<span class="gh">index f482742..a31d79f 100644</span>
<span class="gd">--- a/dns/dnssecalgs/ecdsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/ecdsa.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import hashes
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import ec, utils
<span class="gi">+</span>
<span class="w"> </span>from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
<span class="w"> </span>from dns.dnssectypes import Algorithm
<span class="w"> </span>from dns.rdtypes.ANY.DNSKEY import DNSKEY
<span class="gu">@@ -14,9 +15,31 @@ class PublicECDSA(CryptographyPublicKey):</span>
<span class="w"> </span>    curve: ec.EllipticCurve
<span class="w"> </span>    octets: int

<span class="gd">-    def encode_key_bytes(self) -&gt;bytes:</span>
<span class="gi">+    def verify(self, signature: bytes, data: bytes) -&gt; None:</span>
<span class="gi">+        sig_r = signature[0 : self.octets]</span>
<span class="gi">+        sig_s = signature[self.octets :]</span>
<span class="gi">+        sig = utils.encode_dss_signature(</span>
<span class="gi">+            int.from_bytes(sig_r, &quot;big&quot;), int.from_bytes(sig_s, &quot;big&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        self.key.verify(sig, data, ec.ECDSA(self.chosen_hash))</span>
<span class="gi">+</span>
<span class="gi">+    def encode_key_bytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 6605, section 4.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pn = self.key.public_numbers()</span>
<span class="gi">+        return pn.x.to_bytes(self.octets, &quot;big&quot;) + pn.y.to_bytes(self.octets, &quot;big&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dnskey(cls, key: DNSKEY) -&gt; &quot;PublicECDSA&quot;:</span>
<span class="gi">+        cls._ensure_algorithm_key_combination(key)</span>
<span class="gi">+        ecdsa_x = key.key[0 : cls.octets]</span>
<span class="gi">+        ecdsa_y = key.key[cls.octets : cls.octets * 2]</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=ec.EllipticCurvePublicNumbers(</span>
<span class="gi">+                curve=cls.curve,</span>
<span class="gi">+                x=int.from_bytes(ecdsa_x, &quot;big&quot;),</span>
<span class="gi">+                y=int.from_bytes(ecdsa_y, &quot;big&quot;),</span>
<span class="gi">+            ).public_key(default_backend()),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PrivateECDSA(CryptographyPrivateKey):
<span class="gu">@@ -24,9 +47,24 @@ class PrivateECDSA(CryptographyPrivateKey):</span>
<span class="w"> </span>    key_cls = ec.EllipticCurvePrivateKey
<span class="w"> </span>    public_cls = PublicECDSA

<span class="gd">-    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:</span>
<span class="gi">+    def sign(self, data: bytes, verify: bool = False) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 6605, section 4.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        der_signature = self.key.sign(data, ec.ECDSA(self.public_cls.chosen_hash))</span>
<span class="gi">+        dsa_r, dsa_s = utils.decode_dss_signature(der_signature)</span>
<span class="gi">+        signature = int.to_bytes(</span>
<span class="gi">+            dsa_r, length=self.public_cls.octets, byteorder=&quot;big&quot;</span>
<span class="gi">+        ) + int.to_bytes(dsa_s, length=self.public_cls.octets, byteorder=&quot;big&quot;)</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.public_key().verify(signature, data)</span>
<span class="gi">+        return signature</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def generate(cls) -&gt; &quot;PrivateECDSA&quot;:</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=ec.generate_private_key(</span>
<span class="gi">+                curve=cls.public_cls.curve, backend=default_backend()</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PublicECDSAP256SHA256(PublicECDSA):
<span class="gh">diff --git a/dns/dnssecalgs/eddsa.py b/dns/dnssecalgs/eddsa.py</span>
<span class="gh">index 7705e31..7050534 100644</span>
<span class="gd">--- a/dns/dnssecalgs/eddsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/eddsa.py</span>
<span class="gu">@@ -1,24 +1,44 @@</span>
<span class="w"> </span>from typing import Type
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.primitives import serialization
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import ed448, ed25519
<span class="gi">+</span>
<span class="w"> </span>from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
<span class="w"> </span>from dns.dnssectypes import Algorithm
<span class="w"> </span>from dns.rdtypes.ANY.DNSKEY import DNSKEY


<span class="w"> </span>class PublicEDDSA(CryptographyPublicKey):
<span class="gi">+    def verify(self, signature: bytes, data: bytes) -&gt; None:</span>
<span class="gi">+        self.key.verify(signature, data)</span>

<span class="gd">-    def encode_key_bytes(self) -&gt;bytes:</span>
<span class="gi">+    def encode_key_bytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 8080, section 3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.key.public_bytes(</span>
<span class="gi">+            encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dnskey(cls, key: DNSKEY) -&gt; &quot;PublicEDDSA&quot;:</span>
<span class="gi">+        cls._ensure_algorithm_key_combination(key)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=cls.key_cls.from_public_bytes(key.key),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PrivateEDDSA(CryptographyPrivateKey):
<span class="w"> </span>    public_cls: Type[PublicEDDSA]

<span class="gd">-    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:</span>
<span class="gi">+    def sign(self, data: bytes, verify: bool = False) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 8080, section 4.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature = self.key.sign(data)</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.public_key().verify(signature, data)</span>
<span class="gi">+        return signature</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def generate(cls) -&gt; &quot;PrivateEDDSA&quot;:</span>
<span class="gi">+        return cls(key=cls.key_cls.generate())</span>


<span class="w"> </span>class PublicED25519(PublicEDDSA):
<span class="gh">diff --git a/dns/dnssecalgs/rsa.py b/dns/dnssecalgs/rsa.py</span>
<span class="gh">index 91f1eaf..e95dcf1 100644</span>
<span class="gd">--- a/dns/dnssecalgs/rsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/rsa.py</span>
<span class="gu">@@ -1,8 +1,10 @@</span>
<span class="w"> </span>import math
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import hashes
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import padding, rsa
<span class="gi">+</span>
<span class="w"> </span>from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
<span class="w"> </span>from dns.dnssectypes import Algorithm
<span class="w"> </span>from dns.rdtypes.ANY.DNSKEY import DNSKEY
<span class="gu">@@ -14,9 +16,38 @@ class PublicRSA(CryptographyPublicKey):</span>
<span class="w"> </span>    algorithm: Algorithm
<span class="w"> </span>    chosen_hash: hashes.HashAlgorithm

<span class="gd">-    def encode_key_bytes(self) -&gt;bytes:</span>
<span class="gi">+    def verify(self, signature: bytes, data: bytes) -&gt; None:</span>
<span class="gi">+        self.key.verify(signature, data, padding.PKCS1v15(), self.chosen_hash)</span>
<span class="gi">+</span>
<span class="gi">+    def encode_key_bytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 3110, section 2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pn = self.key.public_numbers()</span>
<span class="gi">+        _exp_len = math.ceil(int.bit_length(pn.e) / 8)</span>
<span class="gi">+        exp = int.to_bytes(pn.e, length=_exp_len, byteorder=&quot;big&quot;)</span>
<span class="gi">+        if _exp_len &gt; 255:</span>
<span class="gi">+            exp_header = b&quot;\0&quot; + struct.pack(&quot;!H&quot;, _exp_len)</span>
<span class="gi">+        else:</span>
<span class="gi">+            exp_header = struct.pack(&quot;!B&quot;, _exp_len)</span>
<span class="gi">+        if pn.n.bit_length() &lt; 512 or pn.n.bit_length() &gt; 4096:</span>
<span class="gi">+            raise ValueError(&quot;unsupported RSA key length&quot;)</span>
<span class="gi">+        return exp_header + exp + pn.n.to_bytes((pn.n.bit_length() + 7) // 8, &quot;big&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dnskey(cls, key: DNSKEY) -&gt; &quot;PublicRSA&quot;:</span>
<span class="gi">+        cls._ensure_algorithm_key_combination(key)</span>
<span class="gi">+        keyptr = key.key</span>
<span class="gi">+        (bytes_,) = struct.unpack(&quot;!B&quot;, keyptr[0:1])</span>
<span class="gi">+        keyptr = keyptr[1:]</span>
<span class="gi">+        if bytes_ == 0:</span>
<span class="gi">+            (bytes_,) = struct.unpack(&quot;!H&quot;, keyptr[0:2])</span>
<span class="gi">+            keyptr = keyptr[2:]</span>
<span class="gi">+        rsa_e = keyptr[0:bytes_]</span>
<span class="gi">+        rsa_n = keyptr[bytes_:]</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=rsa.RSAPublicNumbers(</span>
<span class="gi">+                int.from_bytes(rsa_e, &quot;big&quot;), int.from_bytes(rsa_n, &quot;big&quot;)</span>
<span class="gi">+            ).public_key(default_backend())</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PrivateRSA(CryptographyPrivateKey):
<span class="gu">@@ -25,9 +56,22 @@ class PrivateRSA(CryptographyPrivateKey):</span>
<span class="w"> </span>    public_cls = PublicRSA
<span class="w"> </span>    default_public_exponent = 65537

<span class="gd">-    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:</span>
<span class="gi">+    def sign(self, data: bytes, verify: bool = False) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 3110, section 3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature = self.key.sign(data, padding.PKCS1v15(), self.public_cls.chosen_hash)</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.public_key().verify(signature, data)</span>
<span class="gi">+        return signature</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def generate(cls, key_size: int) -&gt; &quot;PrivateRSA&quot;:</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            key=rsa.generate_private_key(</span>
<span class="gi">+                public_exponent=cls.default_public_exponent,</span>
<span class="gi">+                key_size=key_size,</span>
<span class="gi">+                backend=default_backend(),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PublicRSAMD5(PublicRSA):
<span class="gh">diff --git a/dns/dnssectypes.py b/dns/dnssectypes.py</span>
<span class="gh">index 1d320c7..02131e0 100644</span>
<span class="gd">--- a/dns/dnssectypes.py</span>
<span class="gi">+++ b/dns/dnssectypes.py</span>
<span class="gu">@@ -1,4 +1,25 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Common DNSSEC-related types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# This is a separate file to avoid import circularity between dns.dnssec and</span>
<span class="gi">+# the implementations of the DS and DNSKEY types.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.enum


<span class="gu">@@ -21,16 +42,30 @@ class Algorithm(dns.enum.IntEnum):</span>
<span class="w"> </span>    PRIVATEDNS = 253
<span class="w"> </span>    PRIVATEOID = 254

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 255</span>
<span class="gi">+</span>

<span class="w"> </span>class DSDigest(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;DNSSEC Delegation Signer Digest Algorithm&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    NULL = 0
<span class="w"> </span>    SHA1 = 1
<span class="w"> </span>    SHA256 = 2
<span class="w"> </span>    GOST = 3
<span class="w"> </span>    SHA384 = 4

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 255</span>
<span class="gi">+</span>

<span class="w"> </span>class NSEC3Hash(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;NSEC3 hash algorithm&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    SHA1 = 1
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 255</span>
<span class="gh">diff --git a/dns/e164.py b/dns/e164.py</span>
<span class="gh">index 94218a3..453736d 100644</span>
<span class="gd">--- a/dns/e164.py</span>
<span class="gi">+++ b/dns/e164.py</span>
<span class="gu">@@ -1,13 +1,35 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS E.164 helpers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterable, Optional, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.resolver
<span class="gd">-public_enum_domain = dns.name.from_text(&#39;e164.arpa.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+#: The public E.164 domain.</span>
<span class="gi">+public_enum_domain = dns.name.from_text(&quot;e164.arpa.&quot;)</span>


<span class="gd">-def from_e164(text: str, origin: Optional[dns.name.Name]=public_enum_domain</span>
<span class="gd">-    ) -&gt;dns.name.Name:</span>
<span class="gi">+def from_e164(</span>
<span class="gi">+    text: str, origin: Optional[dns.name.Name] = public_enum_domain</span>
<span class="gi">+) -&gt; dns.name.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an E.164 number in textual form into a Name object whose
<span class="w"> </span>    value is the ENUM domain name for that number.

<span class="gu">@@ -21,11 +43,17 @@ def from_e164(text: str, origin: Optional[dns.name.Name]=public_enum_domain</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    parts = [d for d in text if d.isdigit()]</span>
<span class="gi">+    parts.reverse()</span>
<span class="gi">+    return dns.name.from_text(&quot;.&quot;.join(parts), origin=origin)</span>

<span class="gd">-def to_e164(name: dns.name.Name, origin: Optional[dns.name.Name]=</span>
<span class="gd">-    public_enum_domain, want_plus_prefix: bool=True) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def to_e164(</span>
<span class="gi">+    name: dns.name.Name,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = public_enum_domain,</span>
<span class="gi">+    want_plus_prefix: bool = True,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an ENUM domain name into an E.164 number.

<span class="w"> </span>    Note that dnspython does not have any information about preferred
<span class="gu">@@ -45,11 +73,23 @@ def to_e164(name: dns.name.Name, origin: Optional[dns.name.Name]=</span>
<span class="w"> </span>    Returns a ``str``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def query(number: str, domains: Iterable[Union[dns.name.Name, str]],</span>
<span class="gd">-    resolver: Optional[dns.resolver.Resolver]=None) -&gt;dns.resolver.Answer:</span>
<span class="gi">+    if origin is not None:</span>
<span class="gi">+        name = name.relativize(origin)</span>
<span class="gi">+    dlabels = [d for d in name.labels if d.isdigit() and len(d) == 1]</span>
<span class="gi">+    if len(dlabels) != len(name.labels):</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;non-digit labels in ENUM domain name&quot;)</span>
<span class="gi">+    dlabels.reverse()</span>
<span class="gi">+    text = b&quot;&quot;.join(dlabels)</span>
<span class="gi">+    if want_plus_prefix:</span>
<span class="gi">+        text = b&quot;+&quot; + text</span>
<span class="gi">+    return text.decode()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def query(</span>
<span class="gi">+    number: str,</span>
<span class="gi">+    domains: Iterable[Union[dns.name.Name, str]],</span>
<span class="gi">+    resolver: Optional[dns.resolver.Resolver] = None,</span>
<span class="gi">+) -&gt; dns.resolver.Answer:</span>
<span class="w"> </span>    &quot;&quot;&quot;Look for NAPTR RRs for the specified number in the specified domains.

<span class="w"> </span>    e.g. lookup(&#39;16505551212&#39;, [&#39;e164.dnspython.org.&#39;, &#39;e164.arpa.&#39;])
<span class="gu">@@ -61,4 +101,16 @@ def query(number: str, domains: Iterable[Union[dns.name.Name, str]],</span>
<span class="w"> </span>    *resolver*, a ``dns.resolver.Resolver``, is the resolver to use.  If
<span class="w"> </span>    ``None``, the default resolver is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = dns.resolver.get_default_resolver()</span>
<span class="gi">+    e_nx = dns.resolver.NXDOMAIN()</span>
<span class="gi">+    for domain in domains:</span>
<span class="gi">+        if isinstance(domain, str):</span>
<span class="gi">+            domain = dns.name.from_text(domain)</span>
<span class="gi">+        qname = dns.e164.from_e164(number, domain)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return resolver.resolve(qname, &quot;NAPTR&quot;)</span>
<span class="gi">+        except dns.resolver.NXDOMAIN as e:</span>
<span class="gi">+            e_nx += e</span>
<span class="gi">+    raise e_nx</span>
<span class="gh">diff --git a/dns/edns.py b/dns/edns.py</span>
<span class="gh">index ac75090..776e5ee 100644</span>
<span class="gd">--- a/dns/edns.py</span>
<span class="gi">+++ b/dns/edns.py</span>
<span class="gu">@@ -1,9 +1,28 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2009-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;EDNS Options&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import math
<span class="w"> </span>import socket
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Any, Dict, Optional, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.inet
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -11,18 +30,33 @@ import dns.wire</span>


<span class="w"> </span>class OptionType(dns.enum.IntEnum):
<span class="gi">+    #: NSID</span>
<span class="w"> </span>    NSID = 3
<span class="gi">+    #: DAU</span>
<span class="w"> </span>    DAU = 5
<span class="gi">+    #: DHU</span>
<span class="w"> </span>    DHU = 6
<span class="gi">+    #: N3U</span>
<span class="w"> </span>    N3U = 7
<span class="gi">+    #: ECS (client-subnet)</span>
<span class="w"> </span>    ECS = 8
<span class="gi">+    #: EXPIRE</span>
<span class="w"> </span>    EXPIRE = 9
<span class="gi">+    #: COOKIE</span>
<span class="w"> </span>    COOKIE = 10
<span class="gi">+    #: KEEPALIVE</span>
<span class="w"> </span>    KEEPALIVE = 11
<span class="gi">+    #: PADDING</span>
<span class="w"> </span>    PADDING = 12
<span class="gi">+    #: CHAIN</span>
<span class="w"> </span>    CHAIN = 13
<span class="gi">+    #: EDE (extended-dns-error)</span>
<span class="w"> </span>    EDE = 15

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 65535</span>
<span class="gi">+</span>

<span class="w"> </span>class Option:
<span class="w"> </span>    &quot;&quot;&quot;Base class for all EDNS option types.&quot;&quot;&quot;
<span class="gu">@@ -34,17 +68,19 @@ class Option:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.otype = OptionType.make(otype)

<span class="gd">-    def to_wire(self, file: Optional[Any]=None) -&gt;Optional[bytes]:</span>
<span class="gi">+    def to_wire(self, file: Optional[Any] = None) -&gt; Optional[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert an option to wire format.

<span class="w"> </span>        Returns a ``bytes`` or ``None``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_wire_parser(cls, otype: OptionType, parser: &#39;dns.wire.Parser&#39;</span>
<span class="gd">-        ) -&gt;&#39;Option&#39;:</span>
<span class="gi">+    def from_wire_parser(cls, otype: OptionType, parser: &quot;dns.wire.Parser&quot;) -&gt; &quot;Option&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build an EDNS option object from wire format.

<span class="w"> </span>        *otype*, a ``dns.edns.OptionType``, is the option type.
<span class="gu">@@ -54,14 +90,20 @@ class Option:</span>

<span class="w"> </span>        Returns a ``dns.edns.Option``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _cmp(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Compare an EDNS option with another option of the same type.

<span class="w"> </span>        Returns &lt; 0 if &lt; *other*, 0 if == *other*, and &gt; 0 if &gt; *other*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        wire = self.to_wire()</span>
<span class="gi">+        owire = other.to_wire()</span>
<span class="gi">+        if wire == owire:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if wire &gt; owire:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        return -1</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Option):
<span class="gu">@@ -101,7 +143,7 @@ class Option:</span>
<span class="w"> </span>        return self.to_text()


<span class="gd">-class GenericOption(Option):</span>
<span class="gi">+class GenericOption(Option):  # lgtm[py/missing-equals]</span>
<span class="w"> </span>    &quot;&quot;&quot;Generic Option Class

<span class="w"> </span>    This class is used for EDNS option types for which we have no better
<span class="gu">@@ -112,12 +154,27 @@ class GenericOption(Option):</span>
<span class="w"> </span>        super().__init__(otype)
<span class="w"> </span>        self.data = dns.rdata.Rdata._as_bytes(data, True)

<span class="gi">+    def to_wire(self, file: Optional[Any] = None) -&gt; Optional[bytes]:</span>
<span class="gi">+        if file:</span>
<span class="gi">+            file.write(self.data)</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.data</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self) -&gt; str:</span>
<span class="gi">+        return &quot;Generic %d&quot; % self.otype</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(</span>
<span class="gi">+        cls, otype: Union[OptionType, str], parser: &quot;dns.wire.Parser&quot;</span>
<span class="gi">+    ) -&gt; Option:</span>
<span class="gi">+        return cls(otype, parser.get_remaining())</span>
<span class="gi">+</span>

<span class="gd">-class ECSOption(Option):</span>
<span class="gi">+class ECSOption(Option):  # lgtm[py/missing-equals]</span>
<span class="w"> </span>    &quot;&quot;&quot;EDNS Client Subnet (ECS, RFC7871)&quot;&quot;&quot;

<span class="gd">-    def __init__(self, address: str, srclen: Optional[int]=None, scopelen:</span>
<span class="gd">-        int=0):</span>
<span class="gi">+    def __init__(self, address: str, srclen: Optional[int] = None, scopelen: int = 0):</span>
<span class="w"> </span>        &quot;&quot;&quot;*address*, a ``str``, is the client address information.

<span class="w"> </span>        *srclen*, an ``int``, the source prefix length, which is the
<span class="gu">@@ -127,8 +184,10 @@ class ECSOption(Option):</span>
<span class="w"> </span>        *scopelen*, an ``int``, the scope prefix length.  This value
<span class="w"> </span>        must be 0 in queries, and should be set in responses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(OptionType.ECS)
<span class="w"> </span>        af = dns.inet.af_for_address(address)
<span class="gi">+</span>
<span class="w"> </span>        if af == socket.AF_INET6:
<span class="w"> </span>            self.family = 2
<span class="w"> </span>            if srclen is None:
<span class="gu">@@ -143,22 +202,30 @@ class ECSOption(Option):</span>
<span class="w"> </span>            address = dns.rdata.Rdata._as_ipv4_address(address)
<span class="w"> </span>            srclen = dns.rdata.Rdata._as_int(srclen, 0, 32)
<span class="w"> </span>            scopelen = dns.rdata.Rdata._as_int(scopelen, 0, 32)
<span class="gd">-        else:</span>
<span class="gd">-            raise ValueError(&#39;Bad address family&#39;)</span>
<span class="gi">+        else:  # pragma: no cover   (this will never happen)</span>
<span class="gi">+            raise ValueError(&quot;Bad address family&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        assert srclen is not None
<span class="w"> </span>        self.address = address
<span class="w"> </span>        self.srclen = srclen
<span class="w"> </span>        self.scopelen = scopelen
<span class="gi">+</span>
<span class="w"> </span>        addrdata = dns.inet.inet_pton(af, address)
<span class="w"> </span>        nbytes = int(math.ceil(srclen / 8.0))
<span class="gi">+</span>
<span class="gi">+        # Truncate to srclen and pad to the end of the last octet needed</span>
<span class="gi">+        # See RFC section 6</span>
<span class="w"> </span>        self.addrdata = addrdata[:nbytes]
<span class="w"> </span>        nbits = srclen % 8
<span class="w"> </span>        if nbits != 0:
<span class="gd">-            last = struct.pack(&#39;B&#39;, ord(self.addrdata[-1:]) &amp; 255 &lt;&lt; 8 - nbits)</span>
<span class="gi">+            last = struct.pack(&quot;B&quot;, ord(self.addrdata[-1:]) &amp; (0xFF &lt;&lt; (8 - nbits)))</span>
<span class="w"> </span>            self.addrdata = self.addrdata[:-1] + last

<span class="gi">+    def to_text(self) -&gt; str:</span>
<span class="gi">+        return &quot;ECS {}/{} scope/{}&quot;.format(self.address, self.srclen, self.scopelen)</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="gd">-    def from_text(text: str) -&gt;Option:</span>
<span class="gi">+    def from_text(text: str) -&gt; Option:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert a string into a `dns.edns.ECSOption`

<span class="w"> </span>        *text*, a `str`, the text form of the option.
<span class="gu">@@ -181,7 +248,66 @@ class ECSOption(Option):</span>
<span class="w"> </span>        &gt;&gt;&gt; # it understands results from `dns.edns.ECSOption.to_text()`
<span class="w"> </span>        &gt;&gt;&gt; dns.edns.ECSOption.from_text(&#39;ECS 1.2.3.4/24/32&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        optional_prefix = &quot;ECS&quot;</span>
<span class="gi">+        tokens = text.split()</span>
<span class="gi">+        ecs_text = None</span>
<span class="gi">+        if len(tokens) == 1:</span>
<span class="gi">+            ecs_text = tokens[0]</span>
<span class="gi">+        elif len(tokens) == 2:</span>
<span class="gi">+            if tokens[0] != optional_prefix:</span>
<span class="gi">+                raise ValueError(&#39;could not parse ECS from &quot;{}&quot;&#39;.format(text))</span>
<span class="gi">+            ecs_text = tokens[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;could not parse ECS from &quot;{}&quot;&#39;.format(text))</span>
<span class="gi">+        n_slashes = ecs_text.count(&quot;/&quot;)</span>
<span class="gi">+        if n_slashes == 1:</span>
<span class="gi">+            address, tsrclen = ecs_text.split(&quot;/&quot;)</span>
<span class="gi">+            tscope = &quot;0&quot;</span>
<span class="gi">+        elif n_slashes == 2:</span>
<span class="gi">+            address, tsrclen, tscope = ecs_text.split(&quot;/&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;could not parse ECS from &quot;{}&quot;&#39;.format(text))</span>
<span class="gi">+        try:</span>
<span class="gi">+            scope = int(tscope)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;invalid scope &quot; + &#39;&quot;{}&quot;: scope must be an integer&#39;.format(tscope)</span>
<span class="gi">+            )</span>
<span class="gi">+        try:</span>
<span class="gi">+            srclen = int(tsrclen)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;invalid srclen &quot; + &#39;&quot;{}&quot;: srclen must be an integer&#39;.format(tsrclen)</span>
<span class="gi">+            )</span>
<span class="gi">+        return ECSOption(address, srclen, scope)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file: Optional[Any] = None) -&gt; Optional[bytes]:</span>
<span class="gi">+        value = (</span>
<span class="gi">+            struct.pack(&quot;!HBB&quot;, self.family, self.srclen, self.scopelen) + self.addrdata</span>
<span class="gi">+        )</span>
<span class="gi">+        if file:</span>
<span class="gi">+            file.write(value)</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(</span>
<span class="gi">+        cls, otype: Union[OptionType, str], parser: &quot;dns.wire.Parser&quot;</span>
<span class="gi">+    ) -&gt; Option:</span>
<span class="gi">+        family, src, scope = parser.get_struct(&quot;!HBB&quot;)</span>
<span class="gi">+        addrlen = int(math.ceil(src / 8.0))</span>
<span class="gi">+        prefix = parser.get_bytes(addrlen)</span>
<span class="gi">+        if family == 1:</span>
<span class="gi">+            pad = 4 - addrlen</span>
<span class="gi">+            addr = dns.ipv4.inet_ntoa(prefix + b&quot;\x00&quot; * pad)</span>
<span class="gi">+        elif family == 2:</span>
<span class="gi">+            pad = 16 - addrlen</span>
<span class="gi">+            addr = dns.ipv6.inet_ntoa(prefix + b&quot;\x00&quot; * pad)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;unsupported family&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(addr, src, scope)</span>


<span class="w"> </span>class EDECode(dns.enum.IntEnum):
<span class="gu">@@ -211,47 +337,122 @@ class EDECode(dns.enum.IntEnum):</span>
<span class="w"> </span>    NETWORK_ERROR = 23
<span class="w"> </span>    INVALID_DATA = 24

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 65535</span>
<span class="gi">+</span>

<span class="gd">-class EDEOption(Option):</span>
<span class="gi">+class EDEOption(Option):  # lgtm[py/missing-equals]</span>
<span class="w"> </span>    &quot;&quot;&quot;Extended DNS Error (EDE, RFC8914)&quot;&quot;&quot;
<span class="gd">-    _preserve_case = {&#39;DNSKEY&#39;, &#39;DS&#39;, &#39;DNSSEC&#39;, &#39;RRSIGs&#39;, &#39;NSEC&#39;, &#39;NXDOMAIN&#39;}</span>

<span class="gd">-    def __init__(self, code: Union[EDECode, str], text: Optional[str]=None):</span>
<span class="gi">+    _preserve_case = {&quot;DNSKEY&quot;, &quot;DS&quot;, &quot;DNSSEC&quot;, &quot;RRSIGs&quot;, &quot;NSEC&quot;, &quot;NXDOMAIN&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, code: Union[EDECode, str], text: Optional[str] = None):</span>
<span class="w"> </span>        &quot;&quot;&quot;*code*, a ``dns.edns.EDECode`` or ``str``, the info code of the
<span class="w"> </span>        extended error.

<span class="w"> </span>        *text*, a ``str`` or ``None``, specifying additional information about
<span class="w"> </span>        the error.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(OptionType.EDE)
<span class="gi">+</span>
<span class="w"> </span>        self.code = EDECode.make(code)
<span class="w"> </span>        if text is not None and not isinstance(text, str):
<span class="gd">-            raise ValueError(&#39;text must be string or None&#39;)</span>
<span class="gi">+            raise ValueError(&quot;text must be string or None&quot;)</span>
<span class="w"> </span>        self.text = text

<span class="gi">+    def to_text(self) -&gt; str:</span>
<span class="gi">+        output = f&quot;EDE {self.code}&quot;</span>
<span class="gi">+        if self.code in EDECode:</span>
<span class="gi">+            desc = EDECode.to_text(self.code)</span>
<span class="gi">+            desc = &quot; &quot;.join(</span>
<span class="gi">+                word if word in self._preserve_case else word.title()</span>
<span class="gi">+                for word in desc.split(&quot;_&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+            output += f&quot; ({desc})&quot;</span>
<span class="gi">+        if self.text is not None:</span>
<span class="gi">+            output += f&quot;: {self.text}&quot;</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file: Optional[Any] = None) -&gt; Optional[bytes]:</span>
<span class="gi">+        value = struct.pack(&quot;!H&quot;, self.code)</span>
<span class="gi">+        if self.text is not None:</span>
<span class="gi">+            value += self.text.encode(&quot;utf8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if file:</span>
<span class="gi">+            file.write(value)</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(</span>
<span class="gi">+        cls, otype: Union[OptionType, str], parser: &quot;dns.wire.Parser&quot;</span>
<span class="gi">+    ) -&gt; Option:</span>
<span class="gi">+        code = EDECode.make(parser.get_uint16())</span>
<span class="gi">+        text = parser.get_remaining()</span>
<span class="gi">+</span>
<span class="gi">+        if text:</span>
<span class="gi">+            if text[-1] == 0:  # text MAY be null-terminated</span>
<span class="gi">+                text = text[:-1]</span>
<span class="gi">+            btext = text.decode(&quot;utf8&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            btext = None</span>
<span class="gi">+</span>
<span class="gi">+        return cls(code, btext)</span>

<span class="gd">-class NSIDOption(Option):</span>

<span class="gi">+class NSIDOption(Option):</span>
<span class="w"> </span>    def __init__(self, nsid: bytes):
<span class="w"> </span>        super().__init__(OptionType.NSID)
<span class="w"> </span>        self.nsid = nsid

<span class="gi">+    def to_wire(self, file: Any = None) -&gt; Optional[bytes]:</span>
<span class="gi">+        if file:</span>
<span class="gi">+            file.write(self.nsid)</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.nsid</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self) -&gt; str:</span>
<span class="gi">+        if all(c &gt;= 0x20 and c &lt;= 0x7E for c in self.nsid):</span>
<span class="gi">+            # All ASCII printable, so it&#39;s probably a string.</span>
<span class="gi">+            value = self.nsid.decode()</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = binascii.hexlify(self.nsid).decode()</span>
<span class="gi">+        return f&quot;NSID {value}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(</span>
<span class="gi">+        cls, otype: Union[OptionType, str], parser: dns.wire.Parser</span>
<span class="gi">+    ) -&gt; Option:</span>
<span class="gi">+        return cls(parser.get_remaining())</span>

<span class="gd">-_type_to_class: Dict[OptionType, Any] = {OptionType.ECS: ECSOption,</span>
<span class="gd">-    OptionType.EDE: EDEOption, OptionType.NSID: NSIDOption}</span>

<span class="gi">+_type_to_class: Dict[OptionType, Any] = {</span>
<span class="gi">+    OptionType.ECS: ECSOption,</span>
<span class="gi">+    OptionType.EDE: EDEOption,</span>
<span class="gi">+    OptionType.NSID: NSIDOption,</span>
<span class="gi">+}</span>

<span class="gd">-def get_option_class(otype: OptionType) -&gt;Any:</span>
<span class="gi">+</span>
<span class="gi">+def get_option_class(otype: OptionType) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the class for the specified option type.

<span class="w"> </span>    The GenericOption class is used if a more specific class is not
<span class="w"> </span>    known.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    cls = _type_to_class.get(otype)</span>
<span class="gi">+    if cls is None:</span>
<span class="gi">+        cls = GenericOption</span>
<span class="gi">+    return cls</span>


<span class="gd">-def option_from_wire_parser(otype: Union[OptionType, str], parser:</span>
<span class="gd">-    &#39;dns.wire.Parser&#39;) -&gt;Option:</span>
<span class="gi">+def option_from_wire_parser(</span>
<span class="gi">+    otype: Union[OptionType, str], parser: &quot;dns.wire.Parser&quot;</span>
<span class="gi">+) -&gt; Option:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build an EDNS option object from wire format.

<span class="w"> </span>    *otype*, an ``int``, is the option type.
<span class="gu">@@ -261,11 +462,14 @@ def option_from_wire_parser(otype: Union[OptionType, str], parser:</span>

<span class="w"> </span>    Returns an instance of a subclass of ``dns.edns.Option``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    otype = OptionType.make(otype)</span>
<span class="gi">+    cls = get_option_class(otype)</span>
<span class="gi">+    return cls.from_wire_parser(otype, parser)</span>


<span class="gd">-def option_from_wire(otype: Union[OptionType, str], wire: bytes, current:</span>
<span class="gd">-    int, olen: int) -&gt;Option:</span>
<span class="gi">+def option_from_wire(</span>
<span class="gi">+    otype: Union[OptionType, str], wire: bytes, current: int, olen: int</span>
<span class="gi">+) -&gt; Option:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build an EDNS option object from wire format.

<span class="w"> </span>    *otype*, an ``int``, is the option type.
<span class="gu">@@ -279,19 +483,24 @@ def option_from_wire(otype: Union[OptionType, str], wire: bytes, current:</span>

<span class="w"> </span>    Returns an instance of a subclass of ``dns.edns.Option``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = dns.wire.Parser(wire, current)</span>
<span class="gi">+    with parser.restrict_to(olen):</span>
<span class="gi">+        return option_from_wire_parser(otype, parser)</span>


<span class="gd">-def register_type(implementation: Any, otype: OptionType) -&gt;None:</span>
<span class="gi">+def register_type(implementation: Any, otype: OptionType) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register the implementation of an option type.

<span class="w"> </span>    *implementation*, a ``class``, is a subclass of ``dns.edns.Option``.

<span class="w"> </span>    *otype*, an ``int``, is the option type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    _type_to_class[otype] = implementation</span>


<span class="gi">+### BEGIN generated OptionType constants</span>
<span class="gi">+</span>
<span class="w"> </span>NSID = OptionType.NSID
<span class="w"> </span>DAU = OptionType.DAU
<span class="w"> </span>DHU = OptionType.DHU
<span class="gu">@@ -303,3 +512,5 @@ KEEPALIVE = OptionType.KEEPALIVE</span>
<span class="w"> </span>PADDING = OptionType.PADDING
<span class="w"> </span>CHAIN = OptionType.CHAIN
<span class="w"> </span>EDE = OptionType.EDE
<span class="gi">+</span>
<span class="gi">+### END generated OptionType constants</span>
<span class="gh">diff --git a/dns/entropy.py b/dns/entropy.py</span>
<span class="gh">index 7e11b03..4dcdc62 100644</span>
<span class="gd">--- a/dns/entropy.py</span>
<span class="gi">+++ b/dns/entropy.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2009-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="w"> </span>import os
<span class="w"> </span>import random
<span class="gu">@@ -7,15 +24,19 @@ from typing import Any, Optional</span>


<span class="w"> </span>class EntropyPool:
<span class="gi">+    # This is an entropy pool for Python implementations that do not</span>
<span class="gi">+    # have a working SystemRandom.  I&#39;m not sure there are any, but</span>
<span class="gi">+    # leaving this code doesn&#39;t hurt anything as the library code</span>
<span class="gi">+    # is used if present.</span>

<span class="gd">-    def __init__(self, seed: Optional[bytes]=None):</span>
<span class="gi">+    def __init__(self, seed: Optional[bytes] = None):</span>
<span class="w"> </span>        self.pool_index = 0
<span class="w"> </span>        self.digest: Optional[bytearray] = None
<span class="w"> </span>        self.next_byte = 0
<span class="w"> </span>        self.lock = threading.Lock()
<span class="w"> </span>        self.hash = hashlib.sha1()
<span class="w"> </span>        self.hash_len = 20
<span class="gd">-        self.pool = bytearray(b&#39;\x00&#39; * self.hash_len)</span>
<span class="gi">+        self.pool = bytearray(b&quot;\0&quot; * self.hash_len)</span>
<span class="w"> </span>        if seed is not None:
<span class="w"> </span>            self._stir(seed)
<span class="w"> </span>            self.seeded = True
<span class="gu">@@ -24,10 +45,86 @@ class EntropyPool:</span>
<span class="w"> </span>            self.seeded = False
<span class="w"> </span>            self.seed_pid = 0

<span class="gi">+    def _stir(self, entropy: bytes) -&gt; None:</span>
<span class="gi">+        for c in entropy:</span>
<span class="gi">+            if self.pool_index == self.hash_len:</span>
<span class="gi">+                self.pool_index = 0</span>
<span class="gi">+            b = c &amp; 0xFF</span>
<span class="gi">+            self.pool[self.pool_index] ^= b</span>
<span class="gi">+            self.pool_index += 1</span>
<span class="gi">+</span>
<span class="gi">+    def stir(self, entropy: bytes) -&gt; None:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self._stir(entropy)</span>
<span class="gi">+</span>
<span class="gi">+    def _maybe_seed(self) -&gt; None:</span>
<span class="gi">+        if not self.seeded or self.seed_pid != os.getpid():</span>
<span class="gi">+            try:</span>
<span class="gi">+                seed = os.urandom(16)</span>
<span class="gi">+            except Exception:  # pragma: no cover</span>
<span class="gi">+                try:</span>
<span class="gi">+                    with open(&quot;/dev/urandom&quot;, &quot;rb&quot;, 0) as r:</span>
<span class="gi">+                        seed = r.read(16)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    seed = str(time.time()).encode()</span>
<span class="gi">+            self.seeded = True</span>
<span class="gi">+            self.seed_pid = os.getpid()</span>
<span class="gi">+            self.digest = None</span>
<span class="gi">+            seed = bytearray(seed)</span>
<span class="gi">+            self._stir(seed)</span>
<span class="gi">+</span>
<span class="gi">+    def random_8(self) -&gt; int:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self._maybe_seed()</span>
<span class="gi">+            if self.digest is None or self.next_byte == self.hash_len:</span>
<span class="gi">+                self.hash.update(bytes(self.pool))</span>
<span class="gi">+                self.digest = bytearray(self.hash.digest())</span>
<span class="gi">+                self._stir(self.digest)</span>
<span class="gi">+                self.next_byte = 0</span>
<span class="gi">+            value = self.digest[self.next_byte]</span>
<span class="gi">+            self.next_byte += 1</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def random_16(self) -&gt; int:</span>
<span class="gi">+        return self.random_8() * 256 + self.random_8()</span>
<span class="gi">+</span>
<span class="gi">+    def random_32(self) -&gt; int:</span>
<span class="gi">+        return self.random_16() * 65536 + self.random_16()</span>
<span class="gi">+</span>
<span class="gi">+    def random_between(self, first: int, last: int) -&gt; int:</span>
<span class="gi">+        size = last - first + 1</span>
<span class="gi">+        if size &gt; 4294967296:</span>
<span class="gi">+            raise ValueError(&quot;too big&quot;)</span>
<span class="gi">+        if size &gt; 65536:</span>
<span class="gi">+            rand = self.random_32</span>
<span class="gi">+            max = 4294967295</span>
<span class="gi">+        elif size &gt; 256:</span>
<span class="gi">+            rand = self.random_16</span>
<span class="gi">+            max = 65535</span>
<span class="gi">+        else:</span>
<span class="gi">+            rand = self.random_8</span>
<span class="gi">+            max = 255</span>
<span class="gi">+        return first + size * rand() // (max + 1)</span>
<span class="gi">+</span>

<span class="w"> </span>pool = EntropyPool()
<span class="gi">+</span>
<span class="w"> </span>system_random: Optional[Any]
<span class="w"> </span>try:
<span class="w"> </span>    system_random = random.SystemRandom()
<span class="gd">-except Exception:</span>
<span class="gi">+except Exception:  # pragma: no cover</span>
<span class="w"> </span>    system_random = None
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def random_16() -&gt; int:</span>
<span class="gi">+    if system_random is not None:</span>
<span class="gi">+        return system_random.randrange(0, 65536)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return pool.random_16()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def between(first: int, last: int) -&gt; int:</span>
<span class="gi">+    if system_random is not None:</span>
<span class="gi">+        return system_random.randrange(first, last + 1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return pool.random_between(first, last)</span>
<span class="gh">diff --git a/dns/enum.py b/dns/enum.py</span>
<span class="gh">index c6d69c6..71461f1 100644</span>
<span class="gd">--- a/dns/enum.py</span>
<span class="gi">+++ b/dns/enum.py</span>
<span class="gu">@@ -1,12 +1,78 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import enum
<span class="w"> </span>from typing import Type, TypeVar, Union
<span class="gd">-TIntEnum = TypeVar(&#39;TIntEnum&#39;, bound=&#39;IntEnum&#39;)</span>
<span class="gi">+</span>
<span class="gi">+TIntEnum = TypeVar(&quot;TIntEnum&quot;, bound=&quot;IntEnum&quot;)</span>


<span class="w"> </span>class IntEnum(enum.IntEnum):
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _missing_(cls, value):</span>
<span class="gi">+        cls._check_value(value)</span>
<span class="gi">+        val = int.__new__(cls, value)</span>
<span class="gi">+        val._name_ = cls._extra_to_text(value, None) or f&quot;{cls._prefix()}{value}&quot;</span>
<span class="gi">+        val._value_ = value</span>
<span class="gi">+        return val</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _check_value(cls, value):</span>
<span class="gi">+        max = cls._maximum()</span>
<span class="gi">+        if not isinstance(value, int):</span>
<span class="gi">+            raise TypeError</span>
<span class="gi">+        if value &lt; 0 or value &gt; max:</span>
<span class="gi">+            name = cls._short_name()</span>
<span class="gi">+            raise ValueError(f&quot;{name} must be an int between &gt;= 0 and &lt;= {max}&quot;)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def make(cls: Type[TIntEnum], value: Union[int, str]) -&gt;TIntEnum:</span>
<span class="gi">+    def from_text(cls: Type[TIntEnum], text: str) -&gt; TIntEnum:</span>
<span class="gi">+        text = text.upper()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return cls[text]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        value = cls._extra_from_text(text)</span>
<span class="gi">+        if value:</span>
<span class="gi">+            return value</span>
<span class="gi">+        prefix = cls._prefix()</span>
<span class="gi">+        if text.startswith(prefix) and text[len(prefix) :].isdigit():</span>
<span class="gi">+            value = int(text[len(prefix) :])</span>
<span class="gi">+            cls._check_value(value)</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls(value)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                return value</span>
<span class="gi">+        raise cls._unknown_exception_class()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def to_text(cls: Type[TIntEnum], value: int) -&gt; str:</span>
<span class="gi">+        cls._check_value(value)</span>
<span class="gi">+        try:</span>
<span class="gi">+            text = cls(value).name</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            text = None</span>
<span class="gi">+        text = cls._extra_to_text(value, text)</span>
<span class="gi">+        if text is None:</span>
<span class="gi">+            text = f&quot;{cls._prefix()}{value}&quot;</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def make(cls: Type[TIntEnum], value: Union[int, str]) -&gt; TIntEnum:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert text or a value into an enumerated type, if possible.

<span class="w"> </span>        *value*, the ``int`` or ``str`` to convert.
<span class="gu">@@ -19,4 +85,32 @@ class IntEnum(enum.IntEnum):</span>
<span class="w"> </span>        Returns an enumeration from the calling class corresponding to the
<span class="w"> </span>        value, if one is defined, or an ``int`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            return cls.from_text(value)</span>
<span class="gi">+        cls._check_value(value)</span>
<span class="gi">+        return cls(value)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _short_name(cls):</span>
<span class="gi">+        return cls.__name__.lower()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _prefix(cls):</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _extra_from_text(cls, text):  # pylint: disable=W0613</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _extra_to_text(cls, value, current_text):  # pylint: disable=W0613</span>
<span class="gi">+        return current_text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _unknown_exception_class(cls):</span>
<span class="gi">+        return ValueError</span>
<span class="gh">diff --git a/dns/exception.py b/dns/exception.py</span>
<span class="gh">index 4f53e7b..6982373 100644</span>
<span class="gd">--- a/dns/exception.py</span>
<span class="gi">+++ b/dns/exception.py</span>
<span class="gu">@@ -1,8 +1,27 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Common DNS Exceptions.

<span class="w"> </span>Dnspython modules may also define their own exceptions, which will
<span class="w"> </span>always be subclasses of ``DNSException``.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Optional, Set


<span class="gu">@@ -28,18 +47,21 @@ class DNSException(Exception):</span>
<span class="w"> </span>    In the simplest case it is enough to override the ``supp_kwargs``
<span class="w"> </span>    and ``fmt`` class variables to get nice parametrized messages.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    msg: Optional[str] = None</span>
<span class="gd">-    supp_kwargs: Set[str] = set()</span>
<span class="gd">-    fmt: Optional[str] = None</span>
<span class="gi">+</span>
<span class="gi">+    msg: Optional[str] = None  # non-parametrized message</span>
<span class="gi">+    supp_kwargs: Set[str] = set()  # accepted parameters for _fmt_kwargs (sanity check)</span>
<span class="gi">+    fmt: Optional[str] = None  # message parametrized with results from _fmt_kwargs</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        self._check_params(*args, **kwargs)
<span class="w"> </span>        if kwargs:
<span class="gd">-            self.kwargs = self._check_kwargs(**kwargs)</span>
<span class="gi">+            # This call to a virtual method from __init__ is ok in our usage</span>
<span class="gi">+            self.kwargs = self._check_kwargs(**kwargs)  # lgtm[py/init-calls-subclass]</span>
<span class="w"> </span>            self.msg = str(self)
<span class="w"> </span>        else:
<span class="gd">-            self.kwargs = dict()</span>
<span class="gi">+            self.kwargs = dict()  # defined but empty for old mode exceptions</span>
<span class="w"> </span>        if self.msg is None:
<span class="gi">+            # doc string is better implicit message than empty string</span>
<span class="w"> </span>            self.msg = self.__doc__
<span class="w"> </span>        if args:
<span class="w"> </span>            super().__init__(*args)
<span class="gu">@@ -50,7 +72,17 @@ class DNSException(Exception):</span>
<span class="w"> </span>        &quot;&quot;&quot;Old exceptions supported only args and not kwargs.

<span class="w"> </span>        For sanity we do not allow to mix old and new behavior.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args or kwargs:</span>
<span class="gi">+            assert bool(args) != bool(</span>
<span class="gi">+                kwargs</span>
<span class="gi">+            ), &quot;keyword arguments are mutually exclusive with positional args&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _check_kwargs(self, **kwargs):</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            assert (</span>
<span class="gi">+                set(kwargs.keys()) == self.supp_kwargs</span>
<span class="gi">+            ), &quot;following set of keyword args is required: %s&quot; % (self.supp_kwargs)</span>
<span class="gi">+        return kwargs</span>

<span class="w"> </span>    def _fmt_kwargs(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Format kwargs before printing them.
<span class="gu">@@ -58,13 +90,25 @@ class DNSException(Exception):</span>
<span class="w"> </span>        Resulting dictionary has to have keys necessary for str.format call
<span class="w"> </span>        on fmt class variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fmtargs = {}</span>
<span class="gi">+        for kw, data in kwargs.items():</span>
<span class="gi">+            if isinstance(data, (list, set)):</span>
<span class="gi">+                # convert list of &lt;someobj&gt; to list of str(&lt;someobj&gt;)</span>
<span class="gi">+                fmtargs[kw] = list(map(str, data))</span>
<span class="gi">+                if len(fmtargs[kw]) == 1:</span>
<span class="gi">+                    # remove list brackets [] from single-item lists</span>
<span class="gi">+                    fmtargs[kw] = fmtargs[kw].pop()</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmtargs[kw] = data</span>
<span class="gi">+        return fmtargs</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        if self.kwargs and self.fmt:
<span class="gi">+            # provide custom message constructed from keyword arguments</span>
<span class="w"> </span>            fmtargs = self._fmt_kwargs(**self.kwargs)
<span class="w"> </span>            return self.fmt.format(**fmtargs)
<span class="w"> </span>        else:
<span class="gi">+            # print *args directly in the same way as old DNSException</span>
<span class="w"> </span>            return super().__str__()


<span class="gu">@@ -86,9 +130,12 @@ class TooBig(DNSException):</span>

<span class="w"> </span>class Timeout(DNSException):
<span class="w"> </span>    &quot;&quot;&quot;The DNS operation timed out.&quot;&quot;&quot;
<span class="gd">-    supp_kwargs = {&#39;timeout&#39;}</span>
<span class="gd">-    fmt = &#39;The DNS operation timed out after {timeout:.3f} seconds&#39;</span>

<span class="gi">+    supp_kwargs = {&quot;timeout&quot;}</span>
<span class="gi">+    fmt = &quot;The DNS operation timed out after {timeout:.3f} seconds&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gu">@@ -110,7 +157,6 @@ class DeniedByPolicy(DNSException):</span>


<span class="w"> </span>class ExceptionWrapper:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, exception_class):
<span class="w"> </span>        self.exception_class = exception_class

<span class="gu">@@ -118,7 +164,6 @@ class ExceptionWrapper:</span>
<span class="w"> </span>        return self

<span class="w"> </span>    def __exit__(self, exc_type, exc_val, exc_tb):
<span class="gd">-        if exc_type is not None and not isinstance(exc_val, self.</span>
<span class="gd">-            exception_class):</span>
<span class="gi">+        if exc_type is not None and not isinstance(exc_val, self.exception_class):</span>
<span class="w"> </span>            raise self.exception_class(str(exc_val)) from exc_val
<span class="w"> </span>        return False
<span class="gh">diff --git a/dns/flags.py b/dns/flags.py</span>
<span class="gh">index f682e9b..4c60be1 100644</span>
<span class="gd">--- a/dns/flags.py</span>
<span class="gi">+++ b/dns/flags.py</span>
<span class="gu">@@ -1,57 +1,110 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Message Flags.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import enum
<span class="w"> </span>from typing import Any

<span class="gi">+# Standard DNS flags</span>
<span class="gi">+</span>

<span class="w"> </span>class Flag(enum.IntFlag):
<span class="gd">-    QR = 32768</span>
<span class="gd">-    AA = 1024</span>
<span class="gd">-    TC = 512</span>
<span class="gd">-    RD = 256</span>
<span class="gd">-    RA = 128</span>
<span class="gd">-    AD = 32</span>
<span class="gd">-    CD = 16</span>
<span class="gi">+    #: Query Response</span>
<span class="gi">+    QR = 0x8000</span>
<span class="gi">+    #: Authoritative Answer</span>
<span class="gi">+    AA = 0x0400</span>
<span class="gi">+    #: Truncated Response</span>
<span class="gi">+    TC = 0x0200</span>
<span class="gi">+    #: Recursion Desired</span>
<span class="gi">+    RD = 0x0100</span>
<span class="gi">+    #: Recursion Available</span>
<span class="gi">+    RA = 0x0080</span>
<span class="gi">+    #: Authentic Data</span>
<span class="gi">+    AD = 0x0020</span>
<span class="gi">+    #: Checking Disabled</span>
<span class="gi">+    CD = 0x0010</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# EDNS flags</span>


<span class="w"> </span>class EDNSFlag(enum.IntFlag):
<span class="gd">-    DO = 32768</span>
<span class="gi">+    #: DNSSEC answer OK</span>
<span class="gi">+    DO = 0x8000</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _from_text(text: str, enum_class: Any) -&gt; int:</span>
<span class="gi">+    flags = 0</span>
<span class="gi">+    tokens = text.split()</span>
<span class="gi">+    for t in tokens:</span>
<span class="gi">+        flags |= enum_class[t.upper()]</span>
<span class="gi">+    return flags</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _to_text(flags: int, enum_class: Any) -&gt; str:</span>
<span class="gi">+    text_flags = []</span>
<span class="gi">+    for k, v in enum_class.__members__.items():</span>
<span class="gi">+        if flags &amp; v != 0:</span>
<span class="gi">+            text_flags.append(k)</span>
<span class="gi">+    return &quot; &quot;.join(text_flags)</span>


<span class="gd">-def from_text(text: str) -&gt;int:</span>
<span class="gi">+def from_text(text: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a space-separated list of flag text values into a flags
<span class="w"> </span>    value.

<span class="w"> </span>    Returns an ``int``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return _from_text(text, Flag)</span>

<span class="gd">-def to_text(flags: int) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def to_text(flags: int) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a flags value into a space-separated list of flag text
<span class="w"> </span>    values.

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return _to_text(flags, Flag)</span>


<span class="gd">-def edns_from_text(text: str) -&gt;int:</span>
<span class="gi">+def edns_from_text(text: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a space-separated list of EDNS flag text values into a EDNS
<span class="w"> </span>    flags value.

<span class="w"> </span>    Returns an ``int``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return _from_text(text, EDNSFlag)</span>


<span class="gd">-def edns_to_text(flags: int) -&gt;str:</span>
<span class="gi">+def edns_to_text(flags: int) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an EDNS flags value into a space-separated list of EDNS flag
<span class="w"> </span>    text values.

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return _to_text(flags, EDNSFlag)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+### BEGIN generated Flag constants</span>

<span class="w"> </span>QR = Flag.QR
<span class="w"> </span>AA = Flag.AA
<span class="gu">@@ -60,4 +113,11 @@ RD = Flag.RD</span>
<span class="w"> </span>RA = Flag.RA
<span class="w"> </span>AD = Flag.AD
<span class="w"> </span>CD = Flag.CD
<span class="gi">+</span>
<span class="gi">+### END generated Flag constants</span>
<span class="gi">+</span>
<span class="gi">+### BEGIN generated EDNSFlag constants</span>
<span class="gi">+</span>
<span class="w"> </span>DO = EDNSFlag.DO
<span class="gi">+</span>
<span class="gi">+### END generated EDNSFlag constants</span>
<span class="gh">diff --git a/dns/grange.py b/dns/grange.py</span>
<span class="gh">index af2c200..3a52278 100644</span>
<span class="gd">--- a/dns/grange.py</span>
<span class="gi">+++ b/dns/grange.py</span>
<span class="gu">@@ -1,9 +1,28 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2012-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS GENERATE range conversion.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Tuple
<span class="gi">+</span>
<span class="w"> </span>import dns


<span class="gd">-def from_text(text: str) -&gt;Tuple[int, int, int]:</span>
<span class="gi">+def from_text(text: str) -&gt; Tuple[int, int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the text form of a range in a ``$GENERATE`` statement to an
<span class="w"> </span>    integer.

<span class="gu">@@ -11,4 +30,43 @@ def from_text(text: str) -&gt;Tuple[int, int, int]:</span>

<span class="w"> </span>    Returns a tuple of three ``int`` values ``(start, stop, step)``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    start = -1</span>
<span class="gi">+    stop = -1</span>
<span class="gi">+    step = 1</span>
<span class="gi">+    cur = &quot;&quot;</span>
<span class="gi">+    state = 0</span>
<span class="gi">+    # state   0   1   2</span>
<span class="gi">+    #         x - y / z</span>
<span class="gi">+</span>
<span class="gi">+    if text and text[0] == &quot;-&quot;:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;Start cannot be a negative number&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for c in text:</span>
<span class="gi">+        if c == &quot;-&quot; and state == 0:</span>
<span class="gi">+            start = int(cur)</span>
<span class="gi">+            cur = &quot;&quot;</span>
<span class="gi">+            state = 1</span>
<span class="gi">+        elif c == &quot;/&quot;:</span>
<span class="gi">+            stop = int(cur)</span>
<span class="gi">+            cur = &quot;&quot;</span>
<span class="gi">+            state = 2</span>
<span class="gi">+        elif c.isdigit():</span>
<span class="gi">+            cur += c</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;Could not parse %s&quot; % (c))</span>
<span class="gi">+</span>
<span class="gi">+    if state == 0:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;no stop value specified&quot;)</span>
<span class="gi">+    elif state == 1:</span>
<span class="gi">+        stop = int(cur)</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert state == 2</span>
<span class="gi">+        step = int(cur)</span>
<span class="gi">+</span>
<span class="gi">+    assert step &gt;= 1</span>
<span class="gi">+    assert start &gt;= 0</span>
<span class="gi">+    if start &gt; stop:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;start must be &lt;= stop&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return (start, stop, step)</span>
<span class="gh">diff --git a/dns/immutable.py b/dns/immutable.py</span>
<span class="gh">index 1170831..36b0362 100644</span>
<span class="gd">--- a/dns/immutable.py</span>
<span class="gi">+++ b/dns/immutable.py</span>
<span class="gu">@@ -1,13 +1,19 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import collections.abc
<span class="w"> </span>from typing import Any, Callable
<span class="gi">+</span>
<span class="w"> </span>from dns._immutable_ctx import immutable


<span class="w"> </span>@immutable
<span class="gd">-class Dict(collections.abc.Mapping):</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, dictionary: Any, no_copy: bool=False, map_factory:</span>
<span class="gd">-        Callable[[], collections.abc.MutableMapping]=dict):</span>
<span class="gi">+class Dict(collections.abc.Mapping):  # lgtm[py/missing-equals]</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        dictionary: Any,</span>
<span class="gi">+        no_copy: bool = False,</span>
<span class="gi">+        map_factory: Callable[[], collections.abc.MutableMapping] = dict,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Make an immutable dictionary from the specified dictionary.

<span class="w"> </span>        If *no_copy* is `True`, then *dictionary* will be wrapped instead
<span class="gu">@@ -24,12 +30,13 @@ class Dict(collections.abc.Mapping):</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        return self._odict.__getitem__(key)

<span class="gd">-    def __hash__(self):</span>
<span class="gi">+    def __hash__(self):  # pylint: disable=invalid-hash-returned</span>
<span class="w"> </span>        if self._hash is None:
<span class="w"> </span>            h = 0
<span class="w"> </span>            for key in sorted(self._odict.keys()):
<span class="w"> </span>                h ^= hash(key)
<span class="gd">-            object.__setattr__(self, &#39;_hash&#39;, h)</span>
<span class="gi">+            object.__setattr__(self, &quot;_hash&quot;, h)</span>
<span class="gi">+        # this does return an int, but pylint doesn&#39;t figure that out</span>
<span class="w"> </span>        return self._hash

<span class="w"> </span>    def __len__(self):
<span class="gu">@@ -39,8 +46,23 @@ class Dict(collections.abc.Mapping):</span>
<span class="w"> </span>        return iter(self._odict)


<span class="gd">-def constify(o: Any) -&gt;Any:</span>
<span class="gi">+def constify(o: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert mutable types to immutable types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(o, bytearray):</span>
<span class="gi">+        return bytes(o)</span>
<span class="gi">+    if isinstance(o, tuple):</span>
<span class="gi">+        try:</span>
<span class="gi">+            hash(o)</span>
<span class="gi">+            return o</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return tuple(constify(elt) for elt in o)</span>
<span class="gi">+    if isinstance(o, list):</span>
<span class="gi">+        return tuple(constify(elt) for elt in o)</span>
<span class="gi">+    if isinstance(o, dict):</span>
<span class="gi">+        cdict = dict()</span>
<span class="gi">+        for k, v in o.items():</span>
<span class="gi">+            cdict[k] = constify(v)</span>
<span class="gi">+        return Dict(cdict, True)</span>
<span class="gi">+    return o</span>
<span class="gh">diff --git a/dns/inet.py b/dns/inet.py</span>
<span class="gh">index 8c49f86..4a03f99 100644</span>
<span class="gd">--- a/dns/inet.py</span>
<span class="gi">+++ b/dns/inet.py</span>
<span class="gu">@@ -1,13 +1,36 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Generic Internet address helper functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>from typing import Any, Optional, Tuple
<span class="gi">+</span>
<span class="w"> </span>import dns.ipv4
<span class="w"> </span>import dns.ipv6
<span class="gi">+</span>
<span class="gi">+# We assume that AF_INET and AF_INET6 are always defined.  We keep</span>
<span class="gi">+# these here for the benefit of any old code (unlikely though that</span>
<span class="gi">+# is!).</span>
<span class="w"> </span>AF_INET = socket.AF_INET
<span class="w"> </span>AF_INET6 = socket.AF_INET6


<span class="gd">-def inet_pton(family: int, text: str) -&gt;bytes:</span>
<span class="gi">+def inet_pton(family: int, text: str) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the textual form of a network address into its binary form.

<span class="w"> </span>    *family* is an ``int``, the address family.
<span class="gu">@@ -19,10 +42,16 @@ def inet_pton(family: int, text: str) -&gt;bytes:</span>

<span class="w"> </span>    Returns a ``bytes``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if family == AF_INET:</span>
<span class="gi">+        return dns.ipv4.inet_aton(text)</span>
<span class="gi">+    elif family == AF_INET6:</span>
<span class="gi">+        return dns.ipv6.inet_aton(text, True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="gd">-def inet_ntop(family: int, address: bytes) -&gt;str:</span>
<span class="gi">+def inet_ntop(family: int, address: bytes) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the binary form of a network address into its textual form.

<span class="w"> </span>    *family* is an ``int``, the address family.
<span class="gu">@@ -34,10 +63,16 @@ def inet_ntop(family: int, address: bytes) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if family == AF_INET:</span>
<span class="gi">+        return dns.ipv4.inet_ntoa(address)</span>
<span class="gi">+    elif family == AF_INET6:</span>
<span class="gi">+        return dns.ipv6.inet_ntoa(address)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-def af_for_address(text: str) -&gt;int:</span>
<span class="gi">+</span>
<span class="gi">+def af_for_address(text: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine the address family of a textual-form network address.

<span class="w"> </span>    *text*, a ``str``, the textual address.
<span class="gu">@@ -47,10 +82,19 @@ def af_for_address(text: str) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        dns.ipv4.inet_aton(text)</span>
<span class="gi">+        return AF_INET</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dns.ipv6.inet_aton(text, True)</span>
<span class="gi">+            return AF_INET6</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise ValueError</span>


<span class="gd">-def is_multicast(text: str) -&gt;bool:</span>
<span class="gi">+def is_multicast(text: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the textual-form network address a multicast address?

<span class="w"> </span>    *text*, a ``str``, the textual address.
<span class="gu">@@ -60,21 +104,40 @@ def is_multicast(text: str) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    try:</span>
<span class="gi">+        first = dns.ipv4.inet_aton(text)[0]</span>
<span class="gi">+        return first &gt;= 224 and first &lt;= 239</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        try:</span>
<span class="gi">+            first = dns.ipv6.inet_aton(text, True)[0]</span>
<span class="gi">+            return first == 255</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise ValueError</span>

<span class="gd">-def is_address(text: str) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_address(text: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the specified string an IPv4 or IPv6 address?

<span class="w"> </span>    *text*, a ``str``, the textual address.

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        dns.ipv4.inet_aton(text)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dns.ipv6.inet_aton(text, True)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return False</span>


<span class="gd">-def low_level_address_tuple(high_tuple: Tuple[str, int], af: Optional[int]=None</span>
<span class="gd">-    ) -&gt;Any:</span>
<span class="gi">+def low_level_address_tuple(</span>
<span class="gi">+    high_tuple: Tuple[str, int], af: Optional[int] = None</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a &quot;high-level&quot; address tuple, i.e.
<span class="w"> </span>    an (address, port) return the appropriate &quot;low-level&quot; address tuple
<span class="w"> </span>    suitable for use in socket calls.
<span class="gu">@@ -83,15 +146,41 @@ def low_level_address_tuple(high_tuple: Tuple[str, int], af: Optional[int]=None</span>
<span class="w"> </span>    address in the high-level tuple is valid and has that af.  If af
<span class="w"> </span>    is ``None``, then af_for_address will be called.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    address, port = high_tuple</span>
<span class="gi">+    if af is None:</span>
<span class="gi">+        af = af_for_address(address)</span>
<span class="gi">+    if af == AF_INET:</span>
<span class="gi">+        return (address, port)</span>
<span class="gi">+    elif af == AF_INET6:</span>
<span class="gi">+        i = address.find(&quot;%&quot;)</span>
<span class="gi">+        if i &lt; 0:</span>
<span class="gi">+            # no scope, shortcut!</span>
<span class="gi">+            return (address, port, 0, 0)</span>
<span class="gi">+        # try to avoid getaddrinfo()</span>
<span class="gi">+        addrpart = address[:i]</span>
<span class="gi">+        scope = address[i + 1 :]</span>
<span class="gi">+        if scope.isdigit():</span>
<span class="gi">+            return (addrpart, port, 0, int(scope))</span>
<span class="gi">+        try:</span>
<span class="gi">+            return (addrpart, port, 0, socket.if_nametoindex(scope))</span>
<span class="gi">+        except AttributeError:  # pragma: no cover  (we can&#39;t really test this)</span>
<span class="gi">+            ai_flags = socket.AI_NUMERICHOST</span>
<span class="gi">+            ((*_, tup), *_) = socket.getaddrinfo(address, port, flags=ai_flags)</span>
<span class="gi">+            return tup</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError(f&quot;unknown address family {af}&quot;)</span>


<span class="w"> </span>def any_for_af(af):
<span class="w"> </span>    &quot;&quot;&quot;Return the &#39;any&#39; address for the specified address family.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if af == socket.AF_INET:</span>
<span class="gi">+        return &quot;0.0.0.0&quot;</span>
<span class="gi">+    elif af == socket.AF_INET6:</span>
<span class="gi">+        return &quot;::&quot;</span>
<span class="gi">+    raise NotImplementedError(f&quot;unknown address family {af}&quot;)</span>


<span class="gd">-def canonicalize(text: str) -&gt;str:</span>
<span class="gi">+def canonicalize(text: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify that *address* is a valid text form IPv4 or IPv6 address and return its
<span class="w"> </span>    canonical text form.  IPv6 addresses with scopes are rejected.

<span class="gu">@@ -99,4 +188,10 @@ def canonicalize(text: str) -&gt;str:</span>

<span class="w"> </span>    Raises ``ValueError`` if the text is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return dns.ipv6.canonicalize(text)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return dns.ipv4.canonicalize(text)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise ValueError</span>
<span class="gh">diff --git a/dns/ipv4.py b/dns/ipv4.py</span>
<span class="gh">index 00864bd..65ee69c 100644</span>
<span class="gd">--- a/dns/ipv4.py</span>
<span class="gi">+++ b/dns/ipv4.py</span>
<span class="gu">@@ -1,30 +1,70 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;IPv4 helper functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception


<span class="gd">-def inet_ntoa(address: bytes) -&gt;str:</span>
<span class="gi">+def inet_ntoa(address: bytes) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an IPv4 address in binary form to text form.

<span class="w"> </span>    *address*, a ``bytes``, the IPv4 address in binary form.

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if len(address) != 4:</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    return &quot;%u.%u.%u.%u&quot; % (address[0], address[1], address[2], address[3])</span>


<span class="gd">-def inet_aton(text: Union[str, bytes]) -&gt;bytes:</span>
<span class="gi">+def inet_aton(text: Union[str, bytes]) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an IPv4 address in text form to binary form.

<span class="w"> </span>    *text*, a ``str`` or ``bytes``, the IPv4 address in textual form.

<span class="w"> </span>    Returns a ``bytes``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(text, bytes):</span>
<span class="gi">+        btext = text.encode()</span>
<span class="gi">+    else:</span>
<span class="gi">+        btext = text</span>
<span class="gi">+    parts = btext.split(b&quot;.&quot;)</span>
<span class="gi">+    if len(parts) != 4:</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    for part in parts:</span>
<span class="gi">+        if not part.isdigit():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        if len(part) &gt; 1 and part[0] == ord(&quot;0&quot;):</span>
<span class="gi">+            # No leading zeros</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+    try:</span>
<span class="gi">+        b = [int(part) for part in parts]</span>
<span class="gi">+        return struct.pack(&quot;BBBB&quot;, *b)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>


<span class="gd">-def canonicalize(text: Union[str, bytes]) -&gt;str:</span>
<span class="gi">+def canonicalize(text: Union[str, bytes]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify that *address* is a valid text form IPv4 address and return its
<span class="w"> </span>    canonical text form.

<span class="gu">@@ -32,4 +72,6 @@ def canonicalize(text: Union[str, bytes]) -&gt;str:</span>

<span class="w"> </span>    Raises ``dns.exception.SyntaxError`` if the text is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Note that inet_aton() only accepts canonial form, but we still run through</span>
<span class="gi">+    # inet_ntoa() to ensure the output is a str.</span>
<span class="gi">+    return dns.ipv4.inet_ntoa(dns.ipv4.inet_aton(text))</span>
<span class="gh">diff --git a/dns/ipv6.py b/dns/ipv6.py</span>
<span class="gh">index 94ddeaa..44a1063 100644</span>
<span class="gd">--- a/dns/ipv6.py</span>
<span class="gi">+++ b/dns/ipv6.py</span>
<span class="gu">@@ -1,13 +1,33 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;IPv6 helper functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import re
<span class="w"> </span>from typing import List, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.ipv4
<span class="gd">-_leading_zero = re.compile(&#39;0+([0-9a-f]+)&#39;)</span>

<span class="gi">+_leading_zero = re.compile(r&quot;0+([0-9a-f]+)&quot;)</span>

<span class="gd">-def inet_ntoa(address: bytes) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def inet_ntoa(address: bytes) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an IPv6 address in binary form to text form.

<span class="w"> </span>    *address*, a ``bytes``, the IPv6 address in binary form.
<span class="gu">@@ -15,15 +35,73 @@ def inet_ntoa(address: bytes) -&gt;str:</span>
<span class="w"> </span>    Raises ``ValueError`` if the address isn&#39;t 16 bytes long.
<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_v4_ending = re.compile(b&#39;(.*):(\\d+\\.\\d+\\.\\d+\\.\\d+)$&#39;)</span>
<span class="gd">-_colon_colon_start = re.compile(b&#39;::.*&#39;)</span>
<span class="gd">-_colon_colon_end = re.compile(b&#39;.*::$&#39;)</span>

<span class="gd">-</span>
<span class="gd">-def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) -&gt;bytes:</span>
<span class="gi">+    if len(address) != 16:</span>
<span class="gi">+        raise ValueError(&quot;IPv6 addresses are 16 bytes long&quot;)</span>
<span class="gi">+    hex = binascii.hexlify(address)</span>
<span class="gi">+    chunks = []</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    l = len(hex)</span>
<span class="gi">+    while i &lt; l:</span>
<span class="gi">+        chunk = hex[i : i + 4].decode()</span>
<span class="gi">+        # strip leading zeros.  we do this with an re instead of</span>
<span class="gi">+        # with lstrip() because lstrip() didn&#39;t support chars until</span>
<span class="gi">+        # python 2.2.2</span>
<span class="gi">+        m = _leading_zero.match(chunk)</span>
<span class="gi">+        if m is not None:</span>
<span class="gi">+            chunk = m.group(1)</span>
<span class="gi">+        chunks.append(chunk)</span>
<span class="gi">+        i += 4</span>
<span class="gi">+    #</span>
<span class="gi">+    # Compress the longest subsequence of 0-value chunks to ::</span>
<span class="gi">+    #</span>
<span class="gi">+    best_start = 0</span>
<span class="gi">+    best_len = 0</span>
<span class="gi">+    start = -1</span>
<span class="gi">+    last_was_zero = False</span>
<span class="gi">+    for i in range(8):</span>
<span class="gi">+        if chunks[i] != &quot;0&quot;:</span>
<span class="gi">+            if last_was_zero:</span>
<span class="gi">+                end = i</span>
<span class="gi">+                current_len = end - start</span>
<span class="gi">+                if current_len &gt; best_len:</span>
<span class="gi">+                    best_start = start</span>
<span class="gi">+                    best_len = current_len</span>
<span class="gi">+                last_was_zero = False</span>
<span class="gi">+        elif not last_was_zero:</span>
<span class="gi">+            start = i</span>
<span class="gi">+            last_was_zero = True</span>
<span class="gi">+    if last_was_zero:</span>
<span class="gi">+        end = 8</span>
<span class="gi">+        current_len = end - start</span>
<span class="gi">+        if current_len &gt; best_len:</span>
<span class="gi">+            best_start = start</span>
<span class="gi">+            best_len = current_len</span>
<span class="gi">+    if best_len &gt; 1:</span>
<span class="gi">+        if best_start == 0 and (best_len == 6 or best_len == 5 and chunks[5] == &quot;ffff&quot;):</span>
<span class="gi">+            # We have an embedded IPv4 address</span>
<span class="gi">+            if best_len == 6:</span>
<span class="gi">+                prefix = &quot;::&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                prefix = &quot;::ffff:&quot;</span>
<span class="gi">+            thex = prefix + dns.ipv4.inet_ntoa(address[12:])</span>
<span class="gi">+        else:</span>
<span class="gi">+            thex = (</span>
<span class="gi">+                &quot;:&quot;.join(chunks[:best_start])</span>
<span class="gi">+                + &quot;::&quot;</span>
<span class="gi">+                + &quot;:&quot;.join(chunks[best_start + best_len :])</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        thex = &quot;:&quot;.join(chunks)</span>
<span class="gi">+    return thex</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_v4_ending = re.compile(rb&quot;(.*):(\d+\.\d+\.\d+\.\d+)$&quot;)</span>
<span class="gi">+_colon_colon_start = re.compile(rb&quot;::.*&quot;)</span>
<span class="gi">+_colon_colon_end = re.compile(rb&quot;.*::$&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inet_aton(text: Union[str, bytes], ignore_scope: bool = False) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an IPv6 address in text form to binary form.

<span class="w"> </span>    *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.
<span class="gu">@@ -33,23 +111,104 @@ def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) -&gt;bytes:</span>

<span class="w"> </span>    Returns a ``bytes``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_mapped_prefix = b&#39;\x00&#39; * 10 + b&#39;\xff\xff&#39;</span>

<span class="gd">-</span>
<span class="gd">-def is_mapped(address: bytes) -&gt;bool:</span>
<span class="gi">+    #</span>
<span class="gi">+    # Our aim here is not something fast; we just want something that works.</span>
<span class="gi">+    #</span>
<span class="gi">+    if not isinstance(text, bytes):</span>
<span class="gi">+        btext = text.encode()</span>
<span class="gi">+    else:</span>
<span class="gi">+        btext = text</span>
<span class="gi">+</span>
<span class="gi">+    if ignore_scope:</span>
<span class="gi">+        parts = btext.split(b&quot;%&quot;)</span>
<span class="gi">+        l = len(parts)</span>
<span class="gi">+        if l == 2:</span>
<span class="gi">+            btext = parts[0]</span>
<span class="gi">+        elif l &gt; 2:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+</span>
<span class="gi">+    if btext == b&quot;&quot;:</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    elif btext.endswith(b&quot;:&quot;) and not btext.endswith(b&quot;::&quot;):</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    elif btext.startswith(b&quot;:&quot;) and not btext.startswith(b&quot;::&quot;):</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    elif btext == b&quot;::&quot;:</span>
<span class="gi">+        btext = b&quot;0::&quot;</span>
<span class="gi">+    #</span>
<span class="gi">+    # Get rid of the icky dot-quad syntax if we have it.</span>
<span class="gi">+    #</span>
<span class="gi">+    m = _v4_ending.match(btext)</span>
<span class="gi">+    if m is not None:</span>
<span class="gi">+        b = dns.ipv4.inet_aton(m.group(2))</span>
<span class="gi">+        btext = (</span>
<span class="gi">+            &quot;{}:{:02x}{:02x}:{:02x}{:02x}&quot;.format(</span>
<span class="gi">+                m.group(1).decode(), b[0], b[1], b[2], b[3]</span>
<span class="gi">+            )</span>
<span class="gi">+        ).encode()</span>
<span class="gi">+    #</span>
<span class="gi">+    # Try to turn &#39;::&lt;whatever&gt;&#39; into &#39;:&lt;whatever&gt;&#39;; if no match try to</span>
<span class="gi">+    # turn &#39;&lt;whatever&gt;::&#39; into &#39;&lt;whatever&gt;:&#39;</span>
<span class="gi">+    #</span>
<span class="gi">+    m = _colon_colon_start.match(btext)</span>
<span class="gi">+    if m is not None:</span>
<span class="gi">+        btext = btext[1:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        m = _colon_colon_end.match(btext)</span>
<span class="gi">+        if m is not None:</span>
<span class="gi">+            btext = btext[:-1]</span>
<span class="gi">+    #</span>
<span class="gi">+    # Now canonicalize into 8 chunks of 4 hex digits each</span>
<span class="gi">+    #</span>
<span class="gi">+    chunks = btext.split(b&quot;:&quot;)</span>
<span class="gi">+    l = len(chunks)</span>
<span class="gi">+    if l &gt; 8:</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    seen_empty = False</span>
<span class="gi">+    canonical: List[bytes] = []</span>
<span class="gi">+    for c in chunks:</span>
<span class="gi">+        if c == b&quot;&quot;:</span>
<span class="gi">+            if seen_empty:</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+            seen_empty = True</span>
<span class="gi">+            for _ in range(0, 8 - l + 1):</span>
<span class="gi">+                canonical.append(b&quot;0000&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            lc = len(c)</span>
<span class="gi">+            if lc &gt; 4:</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+            if lc != 4:</span>
<span class="gi">+                c = (b&quot;0&quot; * (4 - lc)) + c</span>
<span class="gi">+            canonical.append(c)</span>
<span class="gi">+    if l &lt; 8 and not seen_empty:</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+    btext = b&quot;&quot;.join(canonical)</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # Finally we can go to binary.</span>
<span class="gi">+    #</span>
<span class="gi">+    try:</span>
<span class="gi">+        return binascii.unhexlify(btext)</span>
<span class="gi">+    except (binascii.Error, TypeError):</span>
<span class="gi">+        raise dns.exception.SyntaxError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_mapped_prefix = b&quot;\x00&quot; * 10 + b&quot;\xff\xff&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_mapped(address: bytes) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the specified address a mapped IPv4 address?

<span class="w"> </span>    *address*, a ``bytes`` is an IPv6 address in binary form.

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return address.startswith(_mapped_prefix)</span>


<span class="gd">-def canonicalize(text: Union[str, bytes]) -&gt;str:</span>
<span class="gi">+def canonicalize(text: Union[str, bytes]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify that *address* is a valid text form IPv6 address and return its
<span class="w"> </span>    canonical text form.  Addresses with scopes are rejected.

<span class="gu">@@ -57,4 +216,4 @@ def canonicalize(text: Union[str, bytes]) -&gt;str:</span>

<span class="w"> </span>    Raises ``dns.exception.SyntaxError`` if the text is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return dns.ipv6.inet_ntoa(dns.ipv6.inet_aton(text))</span>
<span class="gh">diff --git a/dns/message.py b/dns/message.py</span>
<span class="gh">index 657451c..44cacbd 100644</span>
<span class="gd">--- a/dns/message.py</span>
<span class="gi">+++ b/dns/message.py</span>
<span class="gu">@@ -1,8 +1,27 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Messages&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import io
<span class="w"> </span>import time
<span class="w"> </span>from typing import Any, Dict, List, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.edns
<span class="w"> </span>import dns.entropy
<span class="w"> </span>import dns.enum
<span class="gu">@@ -52,8 +71,11 @@ class UnknownTSIGKey(dns.exception.DNSException):</span>

<span class="w"> </span>class Truncated(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;The truncated flag is set.&quot;&quot;&quot;
<span class="gd">-    supp_kwargs = {&#39;message&#39;}</span>

<span class="gi">+    supp_kwargs = {&quot;message&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gu">@@ -62,7 +84,7 @@ class Truncated(dns.exception.DNSException):</span>

<span class="w"> </span>        Returns a ``dns.message.Message``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.kwargs[&quot;message&quot;]</span>


<span class="w"> </span>class NotQueryResponse(dns.exception.DNSException):
<span class="gu">@@ -83,14 +105,18 @@ class NoPreviousName(dns.exception.SyntaxError):</span>

<span class="w"> </span>class MessageSection(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;Message sections&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    QUESTION = 0
<span class="w"> </span>    ANSWER = 1
<span class="w"> </span>    AUTHORITY = 2
<span class="w"> </span>    ADDITIONAL = 3

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 3</span>

<span class="gd">-class MessageError:</span>

<span class="gi">+class MessageError:</span>
<span class="w"> </span>    def __init__(self, exception: Exception, offset: int):
<span class="w"> </span>        self.exception = exception
<span class="w"> </span>        self.offset = offset
<span class="gu">@@ -98,18 +124,25 @@ class MessageError:</span>

<span class="w"> </span>DEFAULT_EDNS_PAYLOAD = 1232
<span class="w"> </span>MAX_CHAIN = 16
<span class="gd">-IndexKeyType = Tuple[int, dns.name.Name, dns.rdataclass.RdataClass, dns.</span>
<span class="gd">-    rdatatype.RdataType, Optional[dns.rdatatype.RdataType], Optional[dns.</span>
<span class="gd">-    rdataclass.RdataClass]]</span>
<span class="gi">+</span>
<span class="gi">+IndexKeyType = Tuple[</span>
<span class="gi">+    int,</span>
<span class="gi">+    dns.name.Name,</span>
<span class="gi">+    dns.rdataclass.RdataClass,</span>
<span class="gi">+    dns.rdatatype.RdataType,</span>
<span class="gi">+    Optional[dns.rdatatype.RdataType],</span>
<span class="gi">+    Optional[dns.rdataclass.RdataClass],</span>
<span class="gi">+]</span>
<span class="w"> </span>IndexType = Dict[IndexKeyType, dns.rrset.RRset]
<span class="w"> </span>SectionType = Union[int, str, List[dns.rrset.RRset]]


<span class="w"> </span>class Message:
<span class="w"> </span>    &quot;&quot;&quot;A DNS message.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _section_enum = MessageSection

<span class="gd">-    def __init__(self, id: Optional[int]=None):</span>
<span class="gi">+    def __init__(self, id: Optional[int] = None):</span>
<span class="w"> </span>        if id is None:
<span class="w"> </span>            self.id = dns.entropy.random_16()
<span class="w"> </span>        else:
<span class="gu">@@ -121,7 +154,7 @@ class Message:</span>
<span class="w"> </span>        self.pad = 0
<span class="w"> </span>        self.keyring: Any = None
<span class="w"> </span>        self.tsig: Optional[dns.rrset.RRset] = None
<span class="gd">-        self.request_mac = b&#39;&#39;</span>
<span class="gi">+        self.request_mac = b&quot;&quot;</span>
<span class="w"> </span>        self.xfr = False
<span class="w"> </span>        self.origin: Optional[dns.name.Name] = None
<span class="w"> </span>        self.tsig_ctx: Optional[Any] = None
<span class="gu">@@ -130,33 +163,53 @@ class Message:</span>
<span class="w"> </span>        self.time = 0.0

<span class="w"> </span>    @property
<span class="gd">-    def question(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def question(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The question section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[0]</span>
<span class="gi">+</span>
<span class="gi">+    @question.setter</span>
<span class="gi">+    def question(self, v):</span>
<span class="gi">+        self.sections[0] = v</span>

<span class="w"> </span>    @property
<span class="gd">-    def answer(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def answer(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The answer section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[1]</span>
<span class="gi">+</span>
<span class="gi">+    @answer.setter</span>
<span class="gi">+    def answer(self, v):</span>
<span class="gi">+        self.sections[1] = v</span>

<span class="w"> </span>    @property
<span class="gd">-    def authority(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def authority(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The authority section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[2]</span>
<span class="gi">+</span>
<span class="gi">+    @authority.setter</span>
<span class="gi">+    def authority(self, v):</span>
<span class="gi">+        self.sections[2] = v</span>

<span class="w"> </span>    @property
<span class="gd">-    def additional(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def additional(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The additional data section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[3]</span>
<span class="gi">+</span>
<span class="gi">+    @additional.setter</span>
<span class="gi">+    def additional(self, v):</span>
<span class="gi">+        self.sections[3] = v</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;DNS message, ID &#39; + repr(self.id) + &#39;&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;DNS message, ID &quot; + repr(self.id) + &quot;&gt;&quot;</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.to_text()

<span class="gd">-    def to_text(self, origin: Optional[dns.name.Name]=None, relativize:</span>
<span class="gd">-        bool=True, **kw: Dict[str, Any]) -&gt;str:</span>
<span class="gi">+    def to_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the message to text.

<span class="w"> </span>        The *origin*, *relativize*, and any other keyword
<span class="gu">@@ -164,7 +217,30 @@ class Message:</span>

<span class="w"> </span>        Returns a ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        s = io.StringIO()</span>
<span class="gi">+        s.write(&quot;id %d\n&quot; % self.id)</span>
<span class="gi">+        s.write(&quot;opcode %s\n&quot; % dns.opcode.to_text(self.opcode()))</span>
<span class="gi">+        s.write(&quot;rcode %s\n&quot; % dns.rcode.to_text(self.rcode()))</span>
<span class="gi">+        s.write(&quot;flags %s\n&quot; % dns.flags.to_text(self.flags))</span>
<span class="gi">+        if self.edns &gt;= 0:</span>
<span class="gi">+            s.write(&quot;edns %s\n&quot; % self.edns)</span>
<span class="gi">+            if self.ednsflags != 0:</span>
<span class="gi">+                s.write(&quot;eflags %s\n&quot; % dns.flags.edns_to_text(self.ednsflags))</span>
<span class="gi">+            s.write(&quot;payload %d\n&quot; % self.payload)</span>
<span class="gi">+        for opt in self.options:</span>
<span class="gi">+            s.write(&quot;option %s\n&quot; % opt.to_text())</span>
<span class="gi">+        for name, which in self._section_enum.__members__.items():</span>
<span class="gi">+            s.write(f&quot;;{name}\n&quot;)</span>
<span class="gi">+            for rrset in self.section_from_number(which):</span>
<span class="gi">+                s.write(rrset.to_text(origin, relativize, **kw))</span>
<span class="gi">+                s.write(&quot;\n&quot;)</span>
<span class="gi">+        #</span>
<span class="gi">+        # We strip off the final \n so the caller can print the result without</span>
<span class="gi">+        # doing weird things to get around eccentricities in Python print</span>
<span class="gi">+        # formatting</span>
<span class="gi">+        #</span>
<span class="gi">+        return s.getvalue()[:-1]</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Two messages are equal if they have the same content in the
<span class="gu">@@ -172,6 +248,7 @@ class Message:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if not isinstance(other, Message):
<span class="w"> </span>            return False
<span class="w"> </span>        if self.id != other.id:
<span class="gu">@@ -191,15 +268,45 @@ class Message:</span>
<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self.__eq__(other)

<span class="gd">-    def is_response(self, other: &#39;Message&#39;) -&gt;bool:</span>
<span class="gi">+    def is_response(self, other: &quot;Message&quot;) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is *other*, also a ``dns.message.Message``, a response to this
<span class="w"> </span>        message?

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def section_number(self, section: List[dns.rrset.RRset]) -&gt;int:</span>
<span class="gi">+        if (</span>
<span class="gi">+            other.flags &amp; dns.flags.QR == 0</span>
<span class="gi">+            or self.id != other.id</span>
<span class="gi">+            or dns.opcode.from_flags(self.flags) != dns.opcode.from_flags(other.flags)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if other.rcode() in {</span>
<span class="gi">+            dns.rcode.FORMERR,</span>
<span class="gi">+            dns.rcode.SERVFAIL,</span>
<span class="gi">+            dns.rcode.NOTIMP,</span>
<span class="gi">+            dns.rcode.REFUSED,</span>
<span class="gi">+        }:</span>
<span class="gi">+            # We don&#39;t check the question section in these cases if</span>
<span class="gi">+            # the other question section is empty, even though they</span>
<span class="gi">+            # still really ought to have a question section.</span>
<span class="gi">+            if len(other.question) == 0:</span>
<span class="gi">+                return True</span>
<span class="gi">+        if dns.opcode.is_update(self.flags):</span>
<span class="gi">+            # This is assuming the &quot;sender doesn&#39;t include anything</span>
<span class="gi">+            # from the update&quot;, but we don&#39;t care to check the other</span>
<span class="gi">+            # case, which is that all the sections are returned and</span>
<span class="gi">+            # identical.</span>
<span class="gi">+            return True</span>
<span class="gi">+        for n in self.question:</span>
<span class="gi">+            if n not in other.question:</span>
<span class="gi">+                return False</span>
<span class="gi">+        for n in other.question:</span>
<span class="gi">+            if n not in self.question:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def section_number(self, section: List[dns.rrset.RRset]) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the &quot;section number&quot; of the specified section for use
<span class="w"> </span>        in indexing.

<span class="gu">@@ -209,9 +316,13 @@ class Message:</span>

<span class="w"> </span>        Returns an ``int``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def section_from_number(self, number: int) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+        for i, our_section in enumerate(self.sections):</span>
<span class="gi">+            if section is our_section:</span>
<span class="gi">+                return self._section_enum(i)</span>
<span class="gi">+        raise ValueError(&quot;unknown section&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def section_from_number(self, number: int) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the section list associated with the specified section
<span class="w"> </span>        number.

<span class="gu">@@ -222,14 +333,22 @@ class Message:</span>

<span class="w"> </span>        Returns a ``list``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find_rrset(self, section: SectionType, name: dns.name.Name, rdclass:</span>
<span class="gd">-        dns.rdataclass.RdataClass, rdtype: dns.rdatatype.RdataType, covers:</span>
<span class="gd">-        dns.rdatatype.RdataType=dns.rdatatype.NONE, deleting: Optional[dns.</span>
<span class="gd">-        rdataclass.RdataClass]=None, create: bool=False, force_unique: bool</span>
<span class="gd">-        =False, idna_codec: Optional[dns.name.IDNACodec]=None</span>
<span class="gd">-        ) -&gt;dns.rrset.RRset:</span>
<span class="gi">+</span>
<span class="gi">+        section = self._section_enum.make(number)</span>
<span class="gi">+        return self.sections[section]</span>
<span class="gi">+</span>
<span class="gi">+    def find_rrset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        section: SectionType,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        deleting: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+        force_unique: bool = False,</span>
<span class="gi">+        idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    ) -&gt; dns.rrset.RRset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the RRset with the given attributes in the specified section.

<span class="w"> </span>        *section*, an ``int`` section number, a ``str`` section name, or one of
<span class="gu">@@ -269,14 +388,52 @@ class Message:</span>

<span class="w"> </span>        Returns a ``dns.rrset.RRset object``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_rrset(self, section: SectionType, name: dns.name.Name, rdclass:</span>
<span class="gd">-        dns.rdataclass.RdataClass, rdtype: dns.rdatatype.RdataType, covers:</span>
<span class="gd">-        dns.rdatatype.RdataType=dns.rdatatype.NONE, deleting: Optional[dns.</span>
<span class="gd">-        rdataclass.RdataClass]=None, create: bool=False, force_unique: bool</span>
<span class="gd">-        =False, idna_codec: Optional[dns.name.IDNACodec]=None) -&gt;Optional[dns</span>
<span class="gd">-        .rrset.RRset]:</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(section, int):</span>
<span class="gi">+            section_number = section</span>
<span class="gi">+            section = self.section_from_number(section_number)</span>
<span class="gi">+        elif isinstance(section, str):</span>
<span class="gi">+            section_number = self._section_enum.from_text(section)</span>
<span class="gi">+            section = self.section_from_number(section_number)</span>
<span class="gi">+        else:</span>
<span class="gi">+            section_number = self.section_number(section)</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, idna_codec=idna_codec)</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        if deleting is not None:</span>
<span class="gi">+            deleting = dns.rdataclass.RdataClass.make(deleting)</span>
<span class="gi">+        key = (section_number, name, rdclass, rdtype, covers, deleting)</span>
<span class="gi">+        if not force_unique:</span>
<span class="gi">+            if self.index is not None:</span>
<span class="gi">+                rrset = self.index.get(key)</span>
<span class="gi">+                if rrset is not None:</span>
<span class="gi">+                    return rrset</span>
<span class="gi">+            else:</span>
<span class="gi">+                for rrset in section:</span>
<span class="gi">+                    if rrset.full_match(name, rdclass, rdtype, covers, deleting):</span>
<span class="gi">+                        return rrset</span>
<span class="gi">+        if not create:</span>
<span class="gi">+            raise KeyError</span>
<span class="gi">+        rrset = dns.rrset.RRset(name, rdclass, rdtype, covers, deleting)</span>
<span class="gi">+        section.append(rrset)</span>
<span class="gi">+        if self.index is not None:</span>
<span class="gi">+            self.index[key] = rrset</span>
<span class="gi">+        return rrset</span>
<span class="gi">+</span>
<span class="gi">+    def get_rrset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        section: SectionType,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        deleting: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+        force_unique: bool = False,</span>
<span class="gi">+        idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    ) -&gt; Optional[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the RRset with the given attributes in the specified section.

<span class="w"> </span>        If the RRset is not found, None is returned.
<span class="gu">@@ -315,9 +472,24 @@ class Message:</span>

<span class="w"> </span>        Returns a ``dns.rrset.RRset object`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def section_count(self, section: SectionType) -&gt;int:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rrset = self.find_rrset(</span>
<span class="gi">+                section,</span>
<span class="gi">+                name,</span>
<span class="gi">+                rdclass,</span>
<span class="gi">+                rdtype,</span>
<span class="gi">+                covers,</span>
<span class="gi">+                deleting,</span>
<span class="gi">+                create,</span>
<span class="gi">+                force_unique,</span>
<span class="gi">+                idna_codec,</span>
<span class="gi">+            )</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            rrset = None</span>
<span class="gi">+        return rrset</span>
<span class="gi">+</span>
<span class="gi">+    def section_count(self, section: SectionType) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of records in the specified section.

<span class="w"> </span>        *section*, an ``int`` section number, a ``str`` section name, or one of
<span class="gu">@@ -328,20 +500,65 @@ class Message:</span>
<span class="w"> </span>            my_message.section_count(dns.message.ANSWER)
<span class="w"> </span>            my_message.section_count(&quot;ANSWER&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _compute_opt_reserve(self) -&gt;int:</span>
<span class="gi">+        if isinstance(section, int):</span>
<span class="gi">+            section_number = section</span>
<span class="gi">+            section = self.section_from_number(section_number)</span>
<span class="gi">+        elif isinstance(section, str):</span>
<span class="gi">+            section_number = self._section_enum.from_text(section)</span>
<span class="gi">+            section = self.section_from_number(section_number)</span>
<span class="gi">+        else:</span>
<span class="gi">+            section_number = self.section_number(section)</span>
<span class="gi">+        count = sum(max(1, len(rrs)) for rrs in section)</span>
<span class="gi">+        if section_number == MessageSection.ADDITIONAL:</span>
<span class="gi">+            if self.opt is not None:</span>
<span class="gi">+                count += 1</span>
<span class="gi">+            if self.tsig is not None:</span>
<span class="gi">+                count += 1</span>
<span class="gi">+        return count</span>
<span class="gi">+</span>
<span class="gi">+    def _compute_opt_reserve(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compute the size required for the OPT RR, padding excluded&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _compute_tsig_reserve(self) -&gt;int:</span>
<span class="gi">+        if not self.opt:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        # 1 byte for the root name, 10 for the standard RR fields</span>
<span class="gi">+        size = 11</span>
<span class="gi">+        # This would be more efficient if options had a size() method, but we won&#39;t</span>
<span class="gi">+        # worry about that for now.  We also don&#39;t worry if there is an existing padding</span>
<span class="gi">+        # option, as it is unlikely and probably harmless, as the worst case is that we</span>
<span class="gi">+        # may add another, and this seems to be legal.</span>
<span class="gi">+        for option in self.opt[0].options:</span>
<span class="gi">+            wire = option.to_wire()</span>
<span class="gi">+            # We add 4 here to account for the option type and length</span>
<span class="gi">+            size += len(wire) + 4</span>
<span class="gi">+        if self.pad:</span>
<span class="gi">+            # Padding will be added, so again add the option type and length.</span>
<span class="gi">+            size += 4</span>
<span class="gi">+        return size</span>
<span class="gi">+</span>
<span class="gi">+    def _compute_tsig_reserve(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compute the size required for the TSIG RR&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def to_wire(self, origin: Optional[dns.name.Name]=None, max_size: int=0,</span>
<span class="gd">-        multi: bool=False, tsig_ctx: Optional[Any]=None, prepend_length:</span>
<span class="gd">-        bool=False, prefer_truncation: bool=False, **kw: Dict[str, Any]</span>
<span class="gd">-        ) -&gt;bytes:</span>
<span class="gi">+        # This would be more efficient if TSIGs had a size method, but we won&#39;t</span>
<span class="gi">+        # worry about for now.  Also, we can&#39;t really cope with the potential</span>
<span class="gi">+        # compressibility of the TSIG owner name, so we estimate with the uncompressed</span>
<span class="gi">+        # size.  We will disable compression when TSIG and padding are both is active</span>
<span class="gi">+        # so that the padding comes out right.</span>
<span class="gi">+        if not self.tsig:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        f = io.BytesIO()</span>
<span class="gi">+        self.tsig.to_wire(f)</span>
<span class="gi">+        return len(f.getvalue())</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        max_size: int = 0,</span>
<span class="gi">+        multi: bool = False,</span>
<span class="gi">+        tsig_ctx: Optional[Any] = None,</span>
<span class="gi">+        prepend_length: bool = False,</span>
<span class="gi">+        prefer_truncation: bool = False,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string containing the message in DNS compressed wire
<span class="w"> </span>        format.

<span class="gu">@@ -375,12 +592,90 @@ class Message:</span>

<span class="w"> </span>        Returns a ``bytes``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def use_tsig(self, keyring: Any, keyname: Optional[Union[dns.name.Name,</span>
<span class="gd">-        str]]=None, fudge: int=300, original_id: Optional[int]=None,</span>
<span class="gd">-        tsig_error: int=0, other_data: bytes=b&#39;&#39;, algorithm: Union[dns.name</span>
<span class="gd">-        .Name, str]=dns.tsig.default_algorithm) -&gt;None:</span>
<span class="gi">+        if origin is None and self.origin is not None:</span>
<span class="gi">+            origin = self.origin</span>
<span class="gi">+        if max_size == 0:</span>
<span class="gi">+            if self.request_payload != 0:</span>
<span class="gi">+                max_size = self.request_payload</span>
<span class="gi">+            else:</span>
<span class="gi">+                max_size = 65535</span>
<span class="gi">+        if max_size &lt; 512:</span>
<span class="gi">+            max_size = 512</span>
<span class="gi">+        elif max_size &gt; 65535:</span>
<span class="gi">+            max_size = 65535</span>
<span class="gi">+        r = dns.renderer.Renderer(self.id, self.flags, max_size, origin)</span>
<span class="gi">+        opt_reserve = self._compute_opt_reserve()</span>
<span class="gi">+        r.reserve(opt_reserve)</span>
<span class="gi">+        tsig_reserve = self._compute_tsig_reserve()</span>
<span class="gi">+        r.reserve(tsig_reserve)</span>
<span class="gi">+        try:</span>
<span class="gi">+            for rrset in self.question:</span>
<span class="gi">+                r.add_question(rrset.name, rrset.rdtype, rrset.rdclass)</span>
<span class="gi">+            for rrset in self.answer:</span>
<span class="gi">+                r.add_rrset(dns.renderer.ANSWER, rrset, **kw)</span>
<span class="gi">+            for rrset in self.authority:</span>
<span class="gi">+                r.add_rrset(dns.renderer.AUTHORITY, rrset, **kw)</span>
<span class="gi">+            for rrset in self.additional:</span>
<span class="gi">+                r.add_rrset(dns.renderer.ADDITIONAL, rrset, **kw)</span>
<span class="gi">+        except dns.exception.TooBig:</span>
<span class="gi">+            if prefer_truncation:</span>
<span class="gi">+                if r.section &lt; dns.renderer.ADDITIONAL:</span>
<span class="gi">+                    r.flags |= dns.flags.TC</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        r.release_reserved()</span>
<span class="gi">+        if self.opt is not None:</span>
<span class="gi">+            r.add_opt(self.opt, self.pad, opt_reserve, tsig_reserve)</span>
<span class="gi">+        r.write_header()</span>
<span class="gi">+        if self.tsig is not None:</span>
<span class="gi">+            (new_tsig, ctx) = dns.tsig.sign(</span>
<span class="gi">+                r.get_wire(),</span>
<span class="gi">+                self.keyring,</span>
<span class="gi">+                self.tsig[0],</span>
<span class="gi">+                int(time.time()),</span>
<span class="gi">+                self.request_mac,</span>
<span class="gi">+                tsig_ctx,</span>
<span class="gi">+                multi,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.tsig.clear()</span>
<span class="gi">+            self.tsig.add(new_tsig)</span>
<span class="gi">+            r.add_rrset(dns.renderer.ADDITIONAL, self.tsig)</span>
<span class="gi">+            r.write_header()</span>
<span class="gi">+            if multi:</span>
<span class="gi">+                self.tsig_ctx = ctx</span>
<span class="gi">+        wire = r.get_wire()</span>
<span class="gi">+        if prepend_length:</span>
<span class="gi">+            wire = len(wire).to_bytes(2, &quot;big&quot;) + wire</span>
<span class="gi">+        return wire</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_tsig(</span>
<span class="gi">+        keyname, algorithm, time_signed, fudge, mac, original_id, error, other</span>
<span class="gi">+    ):</span>
<span class="gi">+        tsig = dns.rdtypes.ANY.TSIG.TSIG(</span>
<span class="gi">+            dns.rdataclass.ANY,</span>
<span class="gi">+            dns.rdatatype.TSIG,</span>
<span class="gi">+            algorithm,</span>
<span class="gi">+            time_signed,</span>
<span class="gi">+            fudge,</span>
<span class="gi">+            mac,</span>
<span class="gi">+            original_id,</span>
<span class="gi">+            error,</span>
<span class="gi">+            other,</span>
<span class="gi">+        )</span>
<span class="gi">+        return dns.rrset.from_rdata(keyname, 0, tsig)</span>
<span class="gi">+</span>
<span class="gi">+    def use_tsig(</span>
<span class="gi">+        self,</span>
<span class="gi">+        keyring: Any,</span>
<span class="gi">+        keyname: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+        fudge: int = 300,</span>
<span class="gi">+        original_id: Optional[int] = None,</span>
<span class="gi">+        tsig_error: int = 0,</span>
<span class="gi">+        other_data: bytes = b&quot;&quot;,</span>
<span class="gi">+        algorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;When sending, a TSIG signature using the specified key
<span class="w"> </span>        should be added.

<span class="gu">@@ -417,12 +712,80 @@ class Message:</span>
<span class="w"> </span>        *algorithm*, a ``dns.name.Name`` or ``str``, the TSIG algorithm to use.  This is
<span class="w"> </span>        only used if *keyring* is a ``dict``, and the key entry is a ``bytes``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def use_edns(self, edns: Optional[Union[int, bool]]=0, ednsflags: int=0,</span>
<span class="gd">-        payload: int=DEFAULT_EDNS_PAYLOAD, request_payload: Optional[int]=</span>
<span class="gd">-        None, options: Optional[List[dns.edns.Option]]=None, pad: int=0</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if isinstance(keyring, dns.tsig.Key):</span>
<span class="gi">+            key = keyring</span>
<span class="gi">+            keyname = key.name</span>
<span class="gi">+        elif callable(keyring):</span>
<span class="gi">+            key = keyring(self, keyname)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(keyname, str):</span>
<span class="gi">+                keyname = dns.name.from_text(keyname)</span>
<span class="gi">+            if keyname is None:</span>
<span class="gi">+                keyname = next(iter(keyring))</span>
<span class="gi">+            key = keyring[keyname]</span>
<span class="gi">+            if isinstance(key, bytes):</span>
<span class="gi">+                key = dns.tsig.Key(keyname, key, algorithm)</span>
<span class="gi">+        self.keyring = key</span>
<span class="gi">+        if original_id is None:</span>
<span class="gi">+            original_id = self.id</span>
<span class="gi">+        self.tsig = self._make_tsig(</span>
<span class="gi">+            keyname,</span>
<span class="gi">+            self.keyring.algorithm,</span>
<span class="gi">+            0,</span>
<span class="gi">+            fudge,</span>
<span class="gi">+            b&quot;\x00&quot; * dns.tsig.mac_sizes[self.keyring.algorithm],</span>
<span class="gi">+            original_id,</span>
<span class="gi">+            tsig_error,</span>
<span class="gi">+            other_data,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def keyname(self) -&gt; Optional[dns.name.Name]:</span>
<span class="gi">+        if self.tsig:</span>
<span class="gi">+            return self.tsig.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def keyalgorithm(self) -&gt; Optional[dns.name.Name]:</span>
<span class="gi">+        if self.tsig:</span>
<span class="gi">+            return self.tsig[0].algorithm</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def mac(self) -&gt; Optional[bytes]:</span>
<span class="gi">+        if self.tsig:</span>
<span class="gi">+            return self.tsig[0].mac</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def tsig_error(self) -&gt; Optional[int]:</span>
<span class="gi">+        if self.tsig:</span>
<span class="gi">+            return self.tsig[0].error</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def had_tsig(self) -&gt; bool:</span>
<span class="gi">+        return bool(self.tsig)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_opt(flags=0, payload=DEFAULT_EDNS_PAYLOAD, options=None):</span>
<span class="gi">+        opt = dns.rdtypes.ANY.OPT.OPT(payload, dns.rdatatype.OPT, options or ())</span>
<span class="gi">+        return dns.rrset.from_rdata(dns.name.root, int(flags), opt)</span>
<span class="gi">+</span>
<span class="gi">+    def use_edns(</span>
<span class="gi">+        self,</span>
<span class="gi">+        edns: Optional[Union[int, bool]] = 0,</span>
<span class="gi">+        ednsflags: int = 0,</span>
<span class="gi">+        payload: int = DEFAULT_EDNS_PAYLOAD,</span>
<span class="gi">+        request_payload: Optional[int] = None,</span>
<span class="gi">+        options: Optional[List[dns.edns.Option]] = None,</span>
<span class="gi">+        pad: int = 0,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Configure EDNS behavior.

<span class="w"> </span>        *edns*, an ``int``, is the EDNS level to use.  Specifying ``None``, ``False``,
<span class="gu">@@ -445,9 +808,64 @@ class Message:</span>
<span class="w"> </span>        padding is non-zero, an EDNS PADDING option will always be added to the
<span class="w"> </span>        message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def want_dnssec(self, wanted: bool=True) -&gt;None:</span>
<span class="gi">+        if edns is None or edns is False:</span>
<span class="gi">+            edns = -1</span>
<span class="gi">+        elif edns is True:</span>
<span class="gi">+            edns = 0</span>
<span class="gi">+        if edns &lt; 0:</span>
<span class="gi">+            self.opt = None</span>
<span class="gi">+            self.request_payload = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            # make sure the EDNS version in ednsflags agrees with edns</span>
<span class="gi">+            ednsflags &amp;= 0xFF00FFFF</span>
<span class="gi">+            ednsflags |= edns &lt;&lt; 16</span>
<span class="gi">+            if options is None:</span>
<span class="gi">+                options = []</span>
<span class="gi">+            self.opt = self._make_opt(ednsflags, payload, options)</span>
<span class="gi">+            if request_payload is None:</span>
<span class="gi">+                request_payload = payload</span>
<span class="gi">+            self.request_payload = request_payload</span>
<span class="gi">+            if pad &lt; 0:</span>
<span class="gi">+                raise ValueError(&quot;pad must be non-negative&quot;)</span>
<span class="gi">+            self.pad = pad</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def edns(self) -&gt; int:</span>
<span class="gi">+        if self.opt:</span>
<span class="gi">+            return (self.ednsflags &amp; 0xFF0000) &gt;&gt; 16</span>
<span class="gi">+        else:</span>
<span class="gi">+            return -1</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def ednsflags(self) -&gt; int:</span>
<span class="gi">+        if self.opt:</span>
<span class="gi">+            return self.opt.ttl</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    @ednsflags.setter</span>
<span class="gi">+    def ednsflags(self, v):</span>
<span class="gi">+        if self.opt:</span>
<span class="gi">+            self.opt.ttl = v</span>
<span class="gi">+        elif v:</span>
<span class="gi">+            self.opt = self._make_opt(v)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def payload(self) -&gt; int:</span>
<span class="gi">+        if self.opt:</span>
<span class="gi">+            return self.opt[0].payload</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def options(self) -&gt; Tuple:</span>
<span class="gi">+        if self.opt:</span>
<span class="gi">+            return self.opt[0].options</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ()</span>
<span class="gi">+</span>
<span class="gi">+    def want_dnssec(self, wanted: bool = True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enable or disable &#39;DNSSEC desired&#39; flag in requests.

<span class="w"> </span>        *wanted*, a ``bool``.  If ``True``, then DNSSEC data is
<span class="gu">@@ -455,35 +873,72 @@ class Message:</span>
<span class="w"> </span>        the DO bit is set.  If ``False``, the DO bit is cleared if
<span class="w"> </span>        EDNS is enabled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def rcode(self) -&gt;dns.rcode.Rcode:</span>
<span class="gi">+        if wanted:</span>
<span class="gi">+            self.ednsflags |= dns.flags.DO</span>
<span class="gi">+        elif self.opt:</span>
<span class="gi">+            self.ednsflags &amp;= ~int(dns.flags.DO)</span>
<span class="gi">+</span>
<span class="gi">+    def rcode(self) -&gt; dns.rcode.Rcode:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the rcode.

<span class="w"> </span>        Returns a ``dns.rcode.Rcode``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dns.rcode.from_flags(int(self.flags), int(self.ednsflags))</span>

<span class="gd">-    def set_rcode(self, rcode: dns.rcode.Rcode) -&gt;None:</span>
<span class="gi">+    def set_rcode(self, rcode: dns.rcode.Rcode) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the rcode.

<span class="w"> </span>        *rcode*, a ``dns.rcode.Rcode``, is the rcode to set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        (value, evalue) = dns.rcode.to_flags(rcode)</span>
<span class="gi">+        self.flags &amp;= 0xFFF0</span>
<span class="gi">+        self.flags |= value</span>
<span class="gi">+        self.ednsflags &amp;= 0x00FFFFFF</span>
<span class="gi">+        self.ednsflags |= evalue</span>

<span class="gd">-    def opcode(self) -&gt;dns.opcode.Opcode:</span>
<span class="gi">+    def opcode(self) -&gt; dns.opcode.Opcode:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the opcode.

<span class="w"> </span>        Returns a ``dns.opcode.Opcode``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dns.opcode.from_flags(int(self.flags))</span>

<span class="gd">-    def set_opcode(self, opcode: dns.opcode.Opcode) -&gt;None:</span>
<span class="gi">+    def set_opcode(self, opcode: dns.opcode.Opcode) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the opcode.

<span class="w"> </span>        *opcode*, a ``dns.opcode.Opcode``, is the opcode to set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flags &amp;= 0x87FF</span>
<span class="gi">+        self.flags |= dns.opcode.to_flags(opcode)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_one_rr_per_rrset(self, value):</span>
<span class="gi">+        # What the caller picked is fine.</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=unused-argument</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_rr_header(self, section, name, rdclass, rdtype):</span>
<span class="gi">+        return (rdclass, rdtype, None, False)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: enable=unused-argument</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_special_rr_header(self, section, count, position, name, rdclass, rdtype):</span>
<span class="gi">+        if rdtype == dns.rdatatype.OPT:</span>
<span class="gi">+            if (</span>
<span class="gi">+                section != MessageSection.ADDITIONAL</span>
<span class="gi">+                or self.opt</span>
<span class="gi">+                or name != dns.name.root</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise BadEDNS</span>
<span class="gi">+        elif rdtype == dns.rdatatype.TSIG:</span>
<span class="gi">+            if (</span>
<span class="gi">+                section != MessageSection.ADDITIONAL</span>
<span class="gi">+                or rdclass != dns.rdatatype.ANY</span>
<span class="gi">+                or position != count - 1</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise BadTSIG</span>
<span class="gi">+        return (rdclass, rdtype, None, False)</span>


<span class="w"> </span>class ChainingResult:
<span class="gu">@@ -505,8 +960,13 @@ class ChainingResult:</span>
<span class="w"> </span>    get to the canonical name.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, canonical_name: dns.name.Name, answer: Optional[dns.</span>
<span class="gd">-        rrset.RRset], minimum_ttl: int, cnames: List[dns.rrset.RRset]):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        canonical_name: dns.name.Name,</span>
<span class="gi">+        answer: Optional[dns.rrset.RRset],</span>
<span class="gi">+        minimum_ttl: int,</span>
<span class="gi">+        cnames: List[dns.rrset.RRset],</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.canonical_name = canonical_name
<span class="w"> </span>        self.answer = answer
<span class="w"> </span>        self.minimum_ttl = minimum_ttl
<span class="gu">@@ -514,8 +974,7 @@ class ChainingResult:</span>


<span class="w"> </span>class QueryMessage(Message):
<span class="gd">-</span>
<span class="gd">-    def resolve_chaining(self) -&gt;ChainingResult:</span>
<span class="gi">+    def resolve_chaining(self) -&gt; ChainingResult:</span>
<span class="w"> </span>        &quot;&quot;&quot;Follow the CNAME chain in the response to determine the answer
<span class="w"> </span>        RRset.

<span class="gu">@@ -531,9 +990,66 @@ class QueryMessage(Message):</span>

<span class="w"> </span>        Returns a ChainingResult object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def canonical_name(self) -&gt;dns.name.Name:</span>
<span class="gi">+        if self.flags &amp; dns.flags.QR == 0:</span>
<span class="gi">+            raise NotQueryResponse</span>
<span class="gi">+        if len(self.question) != 1:</span>
<span class="gi">+            raise dns.exception.FormError</span>
<span class="gi">+        question = self.question[0]</span>
<span class="gi">+        qname = question.name</span>
<span class="gi">+        min_ttl = dns.ttl.MAX_TTL</span>
<span class="gi">+        answer = None</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        cnames = []</span>
<span class="gi">+        while count &lt; MAX_CHAIN:</span>
<span class="gi">+            try:</span>
<span class="gi">+                answer = self.find_rrset(</span>
<span class="gi">+                    self.answer, qname, question.rdclass, question.rdtype</span>
<span class="gi">+                )</span>
<span class="gi">+                min_ttl = min(min_ttl, answer.ttl)</span>
<span class="gi">+                break</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                if question.rdtype != dns.rdatatype.CNAME:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        crrset = self.find_rrset(</span>
<span class="gi">+                            self.answer, qname, question.rdclass, dns.rdatatype.CNAME</span>
<span class="gi">+                        )</span>
<span class="gi">+                        cnames.append(crrset)</span>
<span class="gi">+                        min_ttl = min(min_ttl, crrset.ttl)</span>
<span class="gi">+                        for rd in crrset:</span>
<span class="gi">+                            qname = rd.target</span>
<span class="gi">+                            break</span>
<span class="gi">+                        count += 1</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        # Exit the chaining loop</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Exit the chaining loop</span>
<span class="gi">+                    break</span>
<span class="gi">+        if count &gt;= MAX_CHAIN:</span>
<span class="gi">+            raise ChainTooLong</span>
<span class="gi">+        if self.rcode() == dns.rcode.NXDOMAIN and answer is not None:</span>
<span class="gi">+            raise AnswerForNXDOMAIN</span>
<span class="gi">+        if answer is None:</span>
<span class="gi">+            # Further minimize the TTL with NCACHE.</span>
<span class="gi">+            auname = qname</span>
<span class="gi">+            while True:</span>
<span class="gi">+                # Look for an SOA RR whose owner name is a superdomain</span>
<span class="gi">+                # of qname.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    srrset = self.find_rrset(</span>
<span class="gi">+                        self.authority, auname, question.rdclass, dns.rdatatype.SOA</span>
<span class="gi">+                    )</span>
<span class="gi">+                    min_ttl = min(min_ttl, srrset.ttl, srrset[0].minimum)</span>
<span class="gi">+                    break</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        auname = auname.parent()</span>
<span class="gi">+                    except dns.name.NoParent:</span>
<span class="gi">+                        break</span>
<span class="gi">+        return ChainingResult(qname, answer, min_ttl, cnames)</span>
<span class="gi">+</span>
<span class="gi">+    def canonical_name(self) -&gt; dns.name.Name:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the canonical name of the first name in the question
<span class="w"> </span>        section.

<span class="gu">@@ -547,7 +1063,26 @@ class QueryMessage(Message):</span>

<span class="w"> </span>        Raises ``dns.exception.FormError`` if the question count is not 1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.resolve_chaining().canonical_name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _maybe_import_update():</span>
<span class="gi">+    # We avoid circular imports by doing this here.  We do it in another</span>
<span class="gi">+    # function as doing it in _message_factory_from_opcode() makes &quot;dns&quot;</span>
<span class="gi">+    # a local symbol, and the first line fails :)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=redefined-outer-name,import-outside-toplevel,unused-import</span>
<span class="gi">+    import dns.update  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _message_factory_from_opcode(opcode):</span>
<span class="gi">+    if opcode == dns.opcode.QUERY:</span>
<span class="gi">+        return QueryMessage</span>
<span class="gi">+    elif opcode == dns.opcode.UPDATE:</span>
<span class="gi">+        _maybe_import_update()</span>
<span class="gi">+        return dns.update.UpdateMessage</span>
<span class="gi">+    else:</span>
<span class="gi">+        return Message</span>


<span class="w"> </span>class _WireReader:
<span class="gu">@@ -567,9 +1102,17 @@ class _WireReader:</span>
<span class="w"> </span>    raising them.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, wire, initialize_message, question_only=False,</span>
<span class="gd">-        one_rr_per_rrset=False, ignore_trailing=False, keyring=None, multi=</span>
<span class="gd">-        False, continue_on_error=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        wire,</span>
<span class="gi">+        initialize_message,</span>
<span class="gi">+        question_only=False,</span>
<span class="gi">+        one_rr_per_rrset=False,</span>
<span class="gi">+        ignore_trailing=False,</span>
<span class="gi">+        keyring=None,</span>
<span class="gi">+        multi=False,</span>
<span class="gi">+        continue_on_error=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.parser = dns.wire.Parser(wire)
<span class="w"> </span>        self.message = None
<span class="w"> </span>        self.initialize_message = initialize_message
<span class="gu">@@ -585,7 +1128,20 @@ class _WireReader:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next *qcount* records from the wire data and add them to
<span class="w"> </span>        the question section.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.message is not None</span>
<span class="gi">+        section = self.message.sections[section_number]</span>
<span class="gi">+        for _ in range(qcount):</span>
<span class="gi">+            qname = self.parser.get_name(self.message.origin)</span>
<span class="gi">+            (rdtype, rdclass) = self.parser.get_struct(&quot;!HH&quot;)</span>
<span class="gi">+            (rdclass, rdtype, _, _) = self.message._parse_rr_header(</span>
<span class="gi">+                section_number, qname, rdclass, rdtype</span>
<span class="gi">+            )</span>
<span class="gi">+            self.message.find_rrset(</span>
<span class="gi">+                section, qname, rdclass, rdtype, create=True, force_unique=True</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _add_error(self, e):</span>
<span class="gi">+        self.errors.append(MessageError(e, self.parser.current))</span>

<span class="w"> </span>    def _get_section(self, section_number, count):
<span class="w"> </span>        &quot;&quot;&quot;Read the next I{count} records from the wire data and add them to
<span class="gu">@@ -594,20 +1150,144 @@ class _WireReader:</span>
<span class="w"> </span>        section_number: the section of the message to which to add records
<span class="w"> </span>        count: the number of records to read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.message is not None</span>
<span class="gi">+        section = self.message.sections[section_number]</span>
<span class="gi">+        force_unique = self.one_rr_per_rrset</span>
<span class="gi">+        for i in range(count):</span>
<span class="gi">+            rr_start = self.parser.current</span>
<span class="gi">+            absolute_name = self.parser.get_name()</span>
<span class="gi">+            if self.message.origin is not None:</span>
<span class="gi">+                name = absolute_name.relativize(self.message.origin)</span>
<span class="gi">+            else:</span>
<span class="gi">+                name = absolute_name</span>
<span class="gi">+            (rdtype, rdclass, ttl, rdlen) = self.parser.get_struct(&quot;!HHIH&quot;)</span>
<span class="gi">+            if rdtype in (dns.rdatatype.OPT, dns.rdatatype.TSIG):</span>
<span class="gi">+                (</span>
<span class="gi">+                    rdclass,</span>
<span class="gi">+                    rdtype,</span>
<span class="gi">+                    deleting,</span>
<span class="gi">+                    empty,</span>
<span class="gi">+                ) = self.message._parse_special_rr_header(</span>
<span class="gi">+                    section_number, count, i, name, rdclass, rdtype</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                (rdclass, rdtype, deleting, empty) = self.message._parse_rr_header(</span>
<span class="gi">+                    section_number, name, rdclass, rdtype</span>
<span class="gi">+                )</span>
<span class="gi">+            rdata_start = self.parser.current</span>
<span class="gi">+            try:</span>
<span class="gi">+                if empty:</span>
<span class="gi">+                    if rdlen &gt; 0:</span>
<span class="gi">+                        raise dns.exception.FormError</span>
<span class="gi">+                    rd = None</span>
<span class="gi">+                    covers = dns.rdatatype.NONE</span>
<span class="gi">+                else:</span>
<span class="gi">+                    with self.parser.restrict_to(rdlen):</span>
<span class="gi">+                        rd = dns.rdata.from_wire_parser(</span>
<span class="gi">+                            rdclass, rdtype, self.parser, self.message.origin</span>
<span class="gi">+                        )</span>
<span class="gi">+                    covers = rd.covers()</span>
<span class="gi">+                if self.message.xfr and rdtype == dns.rdatatype.SOA:</span>
<span class="gi">+                    force_unique = True</span>
<span class="gi">+                if rdtype == dns.rdatatype.OPT:</span>
<span class="gi">+                    self.message.opt = dns.rrset.from_rdata(name, ttl, rd)</span>
<span class="gi">+                elif rdtype == dns.rdatatype.TSIG:</span>
<span class="gi">+                    if self.keyring is None:</span>
<span class="gi">+                        raise UnknownTSIGKey(&quot;got signed message without keyring&quot;)</span>
<span class="gi">+                    if isinstance(self.keyring, dict):</span>
<span class="gi">+                        key = self.keyring.get(absolute_name)</span>
<span class="gi">+                        if isinstance(key, bytes):</span>
<span class="gi">+                            key = dns.tsig.Key(absolute_name, key, rd.algorithm)</span>
<span class="gi">+                    elif callable(self.keyring):</span>
<span class="gi">+                        key = self.keyring(self.message, absolute_name)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        key = self.keyring</span>
<span class="gi">+                    if key is None:</span>
<span class="gi">+                        raise UnknownTSIGKey(&quot;key &#39;%s&#39; unknown&quot; % name)</span>
<span class="gi">+                    self.message.keyring = key</span>
<span class="gi">+                    self.message.tsig_ctx = dns.tsig.validate(</span>
<span class="gi">+                        self.parser.wire,</span>
<span class="gi">+                        key,</span>
<span class="gi">+                        absolute_name,</span>
<span class="gi">+                        rd,</span>
<span class="gi">+                        int(time.time()),</span>
<span class="gi">+                        self.message.request_mac,</span>
<span class="gi">+                        rr_start,</span>
<span class="gi">+                        self.message.tsig_ctx,</span>
<span class="gi">+                        self.multi,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.message.tsig = dns.rrset.from_rdata(absolute_name, 0, rd)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    rrset = self.message.find_rrset(</span>
<span class="gi">+                        section,</span>
<span class="gi">+                        name,</span>
<span class="gi">+                        rdclass,</span>
<span class="gi">+                        rdtype,</span>
<span class="gi">+                        covers,</span>
<span class="gi">+                        deleting,</span>
<span class="gi">+                        True,</span>
<span class="gi">+                        force_unique,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if rd is not None:</span>
<span class="gi">+                        if ttl &gt; 0x7FFFFFFF:</span>
<span class="gi">+                            ttl = 0</span>
<span class="gi">+                        rrset.add(rd, ttl)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                if self.continue_on_error:</span>
<span class="gi">+                    self._add_error(e)</span>
<span class="gi">+                    self.parser.seek(rdata_start + rdlen)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>

<span class="w"> </span>    def read(self):
<span class="w"> </span>        &quot;&quot;&quot;Read a wire format DNS message and build a dns.message.Message
<span class="w"> </span>        object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>

<span class="gd">-def from_wire(wire: bytes, keyring: Optional[Any]=None, request_mac:</span>
<span class="gd">-    Optional[bytes]=b&#39;&#39;, xfr: bool=False, origin: Optional[dns.name.Name]=</span>
<span class="gd">-    None, tsig_ctx: Optional[Union[dns.tsig.HMACTSig, dns.tsig.GSSTSig]]=</span>
<span class="gd">-    None, multi: bool=False, question_only: bool=False, one_rr_per_rrset:</span>
<span class="gd">-    bool=False, ignore_trailing: bool=False, raise_on_truncation: bool=</span>
<span class="gd">-    False, continue_on_error: bool=False) -&gt;Message:</span>
<span class="gi">+        if self.parser.remaining() &lt; 12:</span>
<span class="gi">+            raise ShortHeader</span>
<span class="gi">+        (id, flags, qcount, ancount, aucount, adcount) = self.parser.get_struct(</span>
<span class="gi">+            &quot;!HHHHHH&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        factory = _message_factory_from_opcode(dns.opcode.from_flags(flags))</span>
<span class="gi">+        self.message = factory(id=id)</span>
<span class="gi">+        self.message.flags = dns.flags.Flag(flags)</span>
<span class="gi">+        self.initialize_message(self.message)</span>
<span class="gi">+        self.one_rr_per_rrset = self.message._get_one_rr_per_rrset(</span>
<span class="gi">+            self.one_rr_per_rrset</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._get_question(MessageSection.QUESTION, qcount)</span>
<span class="gi">+            if self.question_only:</span>
<span class="gi">+                return self.message</span>
<span class="gi">+            self._get_section(MessageSection.ANSWER, ancount)</span>
<span class="gi">+            self._get_section(MessageSection.AUTHORITY, aucount)</span>
<span class="gi">+            self._get_section(MessageSection.ADDITIONAL, adcount)</span>
<span class="gi">+            if not self.ignore_trailing and self.parser.remaining() != 0:</span>
<span class="gi">+                raise TrailingJunk</span>
<span class="gi">+            if self.multi and self.message.tsig_ctx and not self.message.had_tsig:</span>
<span class="gi">+                self.message.tsig_ctx.update(self.parser.wire)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            if self.continue_on_error:</span>
<span class="gi">+                self._add_error(e)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        return self.message</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_wire(</span>
<span class="gi">+    wire: bytes,</span>
<span class="gi">+    keyring: Optional[Any] = None,</span>
<span class="gi">+    request_mac: Optional[bytes] = b&quot;&quot;,</span>
<span class="gi">+    xfr: bool = False,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    tsig_ctx: Optional[Union[dns.tsig.HMACTSig, dns.tsig.GSSTSig]] = None,</span>
<span class="gi">+    multi: bool = False,</span>
<span class="gi">+    question_only: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    raise_on_truncation: bool = False,</span>
<span class="gi">+    continue_on_error: bool = False,</span>
<span class="gi">+) -&gt; Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a DNS wire format message into a message object.

<span class="w"> </span>    *keyring*, a ``dns.tsig.Key`` or ``dict``, the key or keyring to use if the message
<span class="gu">@@ -662,7 +1342,46 @@ def from_wire(wire: bytes, keyring: Optional[Any]=None, request_mac:</span>

<span class="w"> </span>    Returns a ``dns.message.Message``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # We permit None for request_mac solely for backwards compatibility</span>
<span class="gi">+    if request_mac is None:</span>
<span class="gi">+        request_mac = b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def initialize_message(message):</span>
<span class="gi">+        message.request_mac = request_mac</span>
<span class="gi">+        message.xfr = xfr</span>
<span class="gi">+        message.origin = origin</span>
<span class="gi">+        message.tsig_ctx = tsig_ctx</span>
<span class="gi">+</span>
<span class="gi">+    reader = _WireReader(</span>
<span class="gi">+        wire,</span>
<span class="gi">+        initialize_message,</span>
<span class="gi">+        question_only,</span>
<span class="gi">+        one_rr_per_rrset,</span>
<span class="gi">+        ignore_trailing,</span>
<span class="gi">+        keyring,</span>
<span class="gi">+        multi,</span>
<span class="gi">+        continue_on_error,</span>
<span class="gi">+    )</span>
<span class="gi">+    try:</span>
<span class="gi">+        m = reader.read()</span>
<span class="gi">+    except dns.exception.FormError:</span>
<span class="gi">+        if (</span>
<span class="gi">+            reader.message</span>
<span class="gi">+            and (reader.message.flags &amp; dns.flags.TC)</span>
<span class="gi">+            and raise_on_truncation</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise Truncated(message=reader.message)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise</span>
<span class="gi">+    # Reading a truncated message might not have any errors, so we</span>
<span class="gi">+    # have to do this check here too.</span>
<span class="gi">+    if m.flags &amp; dns.flags.TC and raise_on_truncation:</span>
<span class="gi">+        raise Truncated(message=m)</span>
<span class="gi">+    if continue_on_error:</span>
<span class="gi">+        m.errors = reader.errors</span>
<span class="gi">+</span>
<span class="gi">+    return m</span>


<span class="w"> </span>class _TextReader:
<span class="gu">@@ -678,8 +1397,15 @@ class _TextReader:</span>
<span class="w"> </span>    relativize_to: the origin to relativize to.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text, idna_codec, one_rr_per_rrset=False, origin=</span>
<span class="gd">-        None, relativize=True, relativize_to=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        text,</span>
<span class="gi">+        idna_codec,</span>
<span class="gi">+        one_rr_per_rrset=False,</span>
<span class="gi">+        origin=None,</span>
<span class="gi">+        relativize=True,</span>
<span class="gi">+        relativize_to=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.message = None
<span class="w"> </span>        self.tok = dns.tokenizer.Tokenizer(text, idna_codec=idna_codec)
<span class="w"> </span>        self.last_name = None
<span class="gu">@@ -697,28 +1423,221 @@ class _TextReader:</span>

<span class="w"> </span>    def _header_line(self, _):
<span class="w"> </span>        &quot;&quot;&quot;Process one line from the text format header section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        what = token.value</span>
<span class="gi">+        if what == &quot;id&quot;:</span>
<span class="gi">+            self.id = self.tok.get_int()</span>
<span class="gi">+        elif what == &quot;flags&quot;:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                token = self.tok.get()</span>
<span class="gi">+                if not token.is_identifier():</span>
<span class="gi">+                    self.tok.unget(token)</span>
<span class="gi">+                    break</span>
<span class="gi">+                self.flags = self.flags | dns.flags.from_text(token.value)</span>
<span class="gi">+        elif what == &quot;edns&quot;:</span>
<span class="gi">+            self.edns = self.tok.get_int()</span>
<span class="gi">+            self.ednsflags = self.ednsflags | (self.edns &lt;&lt; 16)</span>
<span class="gi">+        elif what == &quot;eflags&quot;:</span>
<span class="gi">+            if self.edns &lt; 0:</span>
<span class="gi">+                self.edns = 0</span>
<span class="gi">+            while True:</span>
<span class="gi">+                token = self.tok.get()</span>
<span class="gi">+                if not token.is_identifier():</span>
<span class="gi">+                    self.tok.unget(token)</span>
<span class="gi">+                    break</span>
<span class="gi">+                self.ednsflags = self.ednsflags | dns.flags.edns_from_text(token.value)</span>
<span class="gi">+        elif what == &quot;payload&quot;:</span>
<span class="gi">+            self.payload = self.tok.get_int()</span>
<span class="gi">+            if self.edns &lt; 0:</span>
<span class="gi">+                self.edns = 0</span>
<span class="gi">+        elif what == &quot;opcode&quot;:</span>
<span class="gi">+            text = self.tok.get_string()</span>
<span class="gi">+            self.opcode = dns.opcode.from_text(text)</span>
<span class="gi">+            self.flags = self.flags | dns.opcode.to_flags(self.opcode)</span>
<span class="gi">+        elif what == &quot;rcode&quot;:</span>
<span class="gi">+            text = self.tok.get_string()</span>
<span class="gi">+            self.rcode = dns.rcode.from_text(text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnknownHeaderField</span>
<span class="gi">+        self.tok.get_eol()</span>

<span class="w"> </span>    def _question_line(self, section_number):
<span class="w"> </span>        &quot;&quot;&quot;Process one line from the text format question section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        section = self.message.sections[section_number]</span>
<span class="gi">+        token = self.tok.get(want_leading=True)</span>
<span class="gi">+        if not token.is_whitespace():</span>
<span class="gi">+            self.last_name = self.tok.as_name(</span>
<span class="gi">+                token, self.message.origin, self.relativize, self.relativize_to</span>
<span class="gi">+            )</span>
<span class="gi">+        name = self.last_name</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            raise NoPreviousName</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        # Class</span>
<span class="gi">+        try:</span>
<span class="gi">+            rdclass = dns.rdataclass.from_text(token.value)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            rdclass = dns.rdataclass.IN</span>
<span class="gi">+        # Type</span>
<span class="gi">+        rdtype = dns.rdatatype.from_text(token.value)</span>
<span class="gi">+        (rdclass, rdtype, _, _) = self.message._parse_rr_header(</span>
<span class="gi">+            section_number, name, rdclass, rdtype</span>
<span class="gi">+        )</span>
<span class="gi">+        self.message.find_rrset(</span>
<span class="gi">+            section, name, rdclass, rdtype, create=True, force_unique=True</span>
<span class="gi">+        )</span>
<span class="gi">+        self.tok.get_eol()</span>

<span class="w"> </span>    def _rr_line(self, section_number):
<span class="w"> </span>        &quot;&quot;&quot;Process one line from the text format answer, authority, or
<span class="w"> </span>        additional data sections.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        section = self.message.sections[section_number]</span>
<span class="gi">+        # Name</span>
<span class="gi">+        token = self.tok.get(want_leading=True)</span>
<span class="gi">+        if not token.is_whitespace():</span>
<span class="gi">+            self.last_name = self.tok.as_name(</span>
<span class="gi">+                token, self.message.origin, self.relativize, self.relativize_to</span>
<span class="gi">+            )</span>
<span class="gi">+        name = self.last_name</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            raise NoPreviousName</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        # TTL</span>
<span class="gi">+        try:</span>
<span class="gi">+            ttl = int(token.value, 0)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            ttl = 0</span>
<span class="gi">+        # Class</span>
<span class="gi">+        try:</span>
<span class="gi">+            rdclass = dns.rdataclass.from_text(token.value)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            rdclass = dns.rdataclass.IN</span>
<span class="gi">+        # Type</span>
<span class="gi">+        rdtype = dns.rdatatype.from_text(token.value)</span>
<span class="gi">+        (rdclass, rdtype, deleting, empty) = self.message._parse_rr_header(</span>
<span class="gi">+            section_number, name, rdclass, rdtype</span>
<span class="gi">+        )</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if empty and not token.is_eol_or_eof():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        if not empty and token.is_eol_or_eof():</span>
<span class="gi">+            raise dns.exception.UnexpectedEnd</span>
<span class="gi">+        if not token.is_eol_or_eof():</span>
<span class="gi">+            self.tok.unget(token)</span>
<span class="gi">+            rd = dns.rdata.from_text(</span>
<span class="gi">+                rdclass,</span>
<span class="gi">+                rdtype,</span>
<span class="gi">+                self.tok,</span>
<span class="gi">+                self.message.origin,</span>
<span class="gi">+                self.relativize,</span>
<span class="gi">+                self.relativize_to,</span>
<span class="gi">+            )</span>
<span class="gi">+            covers = rd.covers()</span>
<span class="gi">+        else:</span>
<span class="gi">+            rd = None</span>
<span class="gi">+            covers = dns.rdatatype.NONE</span>
<span class="gi">+        rrset = self.message.find_rrset(</span>
<span class="gi">+            section,</span>
<span class="gi">+            name,</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            rdtype,</span>
<span class="gi">+            covers,</span>
<span class="gi">+            deleting,</span>
<span class="gi">+            True,</span>
<span class="gi">+            self.one_rr_per_rrset,</span>
<span class="gi">+        )</span>
<span class="gi">+        if rd is not None:</span>
<span class="gi">+            rrset.add(rd, ttl)</span>
<span class="gi">+</span>
<span class="gi">+    def _make_message(self):</span>
<span class="gi">+        factory = _message_factory_from_opcode(self.opcode)</span>
<span class="gi">+        message = factory(id=self.id)</span>
<span class="gi">+        message.flags = self.flags</span>
<span class="gi">+        if self.edns &gt;= 0:</span>
<span class="gi">+            message.use_edns(self.edns, self.ednsflags, self.payload)</span>
<span class="gi">+        if self.rcode:</span>
<span class="gi">+            message.set_rcode(self.rcode)</span>
<span class="gi">+        if self.origin:</span>
<span class="gi">+            message.origin = self.origin</span>
<span class="gi">+        return message</span>

<span class="w"> </span>    def read(self):
<span class="w"> </span>        &quot;&quot;&quot;Read a text format DNS message and build a dns.message.Message
<span class="w"> </span>        object.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-</span>
<span class="gd">-def from_text(text: str, idna_codec: Optional[dns.name.IDNACodec]=None,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, origin: Optional[dns.name.Name]=None,</span>
<span class="gd">-    relativize: bool=True, relativize_to: Optional[dns.name.Name]=None</span>
<span class="gd">-    ) -&gt;Message:</span>
<span class="gi">+        line_method = self._header_line</span>
<span class="gi">+        section_number = None</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            token = self.tok.get(True, True)</span>
<span class="gi">+            if token.is_eol_or_eof():</span>
<span class="gi">+                break</span>
<span class="gi">+            if token.is_comment():</span>
<span class="gi">+                u = token.value.upper()</span>
<span class="gi">+                if u == &quot;HEADER&quot;:</span>
<span class="gi">+                    line_method = self._header_line</span>
<span class="gi">+</span>
<span class="gi">+                if self.message:</span>
<span class="gi">+                    message = self.message</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # If we don&#39;t have a message, create one with the current</span>
<span class="gi">+                    # opcode, so that we know which section names to parse.</span>
<span class="gi">+                    message = self._make_message()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    section_number = message._section_enum.from_text(u)</span>
<span class="gi">+                    # We found a section name.  If we don&#39;t have a message,</span>
<span class="gi">+                    # use the one we just created.</span>
<span class="gi">+                    if not self.message:</span>
<span class="gi">+                        self.message = message</span>
<span class="gi">+                        self.one_rr_per_rrset = message._get_one_rr_per_rrset(</span>
<span class="gi">+                            self.one_rr_per_rrset</span>
<span class="gi">+                        )</span>
<span class="gi">+                    if section_number == MessageSection.QUESTION:</span>
<span class="gi">+                        line_method = self._question_line</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        line_method = self._rr_line</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    # It&#39;s just a comment.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                self.tok.get_eol()</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.tok.unget(token)</span>
<span class="gi">+            line_method(section_number)</span>
<span class="gi">+        if not self.message:</span>
<span class="gi">+            self.message = self._make_message()</span>
<span class="gi">+        return self.message</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the text format message into a message object.

<span class="w"> </span>    The reader stops after reading the first blank line in the input to
<span class="gu">@@ -748,11 +1667,22 @@ def from_text(text: str, idna_codec: Optional[dns.name.IDNACodec]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message object``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    # &#39;text&#39; can also be a file, but we don&#39;t publish that fact</span>
<span class="gi">+    # since it&#39;s an implementation detail.  The official file</span>
<span class="gi">+    # interface is from_file().</span>
<span class="gi">+</span>
<span class="gi">+    reader = _TextReader(</span>
<span class="gi">+        text, idna_codec, one_rr_per_rrset, origin, relativize, relativize_to</span>
<span class="gi">+    )</span>
<span class="gi">+    return reader.read()</span>

<span class="gd">-def from_file(f: Any, idna_codec: Optional[dns.name.IDNACodec]=None,</span>
<span class="gd">-    one_rr_per_rrset: bool=False) -&gt;Message:</span>
<span class="gi">+</span>
<span class="gi">+def from_file(</span>
<span class="gi">+    f: Any,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+) -&gt; Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read the next text format message from the specified file.

<span class="w"> </span>    Message blocks are separated by a single blank line.
<span class="gu">@@ -773,17 +1703,31 @@ def from_file(f: Any, idna_codec: Optional[dns.name.IDNACodec]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message object``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def make_query(qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="gd">-    rdatatype.RdataType, str], rdclass: Union[dns.rdataclass.RdataClass,</span>
<span class="gd">-    str]=dns.rdataclass.IN, use_edns: Optional[Union[int, bool]]=None,</span>
<span class="gd">-    want_dnssec: bool=False, ednsflags: Optional[int]=None, payload:</span>
<span class="gd">-    Optional[int]=None, request_payload: Optional[int]=None, options:</span>
<span class="gd">-    Optional[List[dns.edns.Option]]=None, idna_codec: Optional[dns.name.</span>
<span class="gd">-    IDNACodec]=None, id: Optional[int]=None, flags: int=dns.flags.RD, pad:</span>
<span class="gd">-    int=0) -&gt;QueryMessage:</span>
<span class="gi">+    if isinstance(f, str):</span>
<span class="gi">+        cm: contextlib.AbstractContextManager = open(f)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = contextlib.nullcontext(f)</span>
<span class="gi">+    with cm as f:</span>
<span class="gi">+        return from_text(f, idna_codec, one_rr_per_rrset)</span>
<span class="gi">+    assert False  # for mypy  lgtm[py/unreachable-statement]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_query(</span>
<span class="gi">+    qname: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    use_edns: Optional[Union[int, bool]] = None,</span>
<span class="gi">+    want_dnssec: bool = False,</span>
<span class="gi">+    ednsflags: Optional[int] = None,</span>
<span class="gi">+    payload: Optional[int] = None,</span>
<span class="gi">+    request_payload: Optional[int] = None,</span>
<span class="gi">+    options: Optional[List[dns.edns.Option]] = None,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    id: Optional[int] = None,</span>
<span class="gi">+    flags: int = dns.flags.RD,</span>
<span class="gi">+    pad: int = 0,</span>
<span class="gi">+) -&gt; QueryMessage:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a query message.

<span class="w"> </span>    The query name, type, and class may all be specified either
<span class="gu">@@ -838,12 +1782,43 @@ def make_query(qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>

<span class="w"> </span>    Returns a ``dns.message.QueryMessage``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def make_response(query: Message, recursion_available: bool=False,</span>
<span class="gd">-    our_payload: int=8192, fudge: int=300, tsig_error: int=0, pad: Optional</span>
<span class="gd">-    [int]=None) -&gt;Message:</span>
<span class="gi">+    if isinstance(qname, str):</span>
<span class="gi">+        qname = dns.name.from_text(qname, idna_codec=idna_codec)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    m = QueryMessage(id=id)</span>
<span class="gi">+    m.flags = dns.flags.Flag(flags)</span>
<span class="gi">+    m.find_rrset(m.question, qname, rdclass, rdtype, create=True, force_unique=True)</span>
<span class="gi">+    # only pass keywords on to use_edns if they have been set to a</span>
<span class="gi">+    # non-None value.  Setting a field will turn EDNS on if it hasn&#39;t</span>
<span class="gi">+    # been configured.</span>
<span class="gi">+    kwargs: Dict[str, Any] = {}</span>
<span class="gi">+    if ednsflags is not None:</span>
<span class="gi">+        kwargs[&quot;ednsflags&quot;] = ednsflags</span>
<span class="gi">+    if payload is not None:</span>
<span class="gi">+        kwargs[&quot;payload&quot;] = payload</span>
<span class="gi">+    if request_payload is not None:</span>
<span class="gi">+        kwargs[&quot;request_payload&quot;] = request_payload</span>
<span class="gi">+    if options is not None:</span>
<span class="gi">+        kwargs[&quot;options&quot;] = options</span>
<span class="gi">+    if kwargs and use_edns is None:</span>
<span class="gi">+        use_edns = 0</span>
<span class="gi">+    kwargs[&quot;edns&quot;] = use_edns</span>
<span class="gi">+    kwargs[&quot;pad&quot;] = pad</span>
<span class="gi">+    m.use_edns(**kwargs)</span>
<span class="gi">+    m.want_dnssec(want_dnssec)</span>
<span class="gi">+    return m</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_response(</span>
<span class="gi">+    query: Message,</span>
<span class="gi">+    recursion_available: bool = False,</span>
<span class="gi">+    our_payload: int = 8192,</span>
<span class="gi">+    fudge: int = 300,</span>
<span class="gi">+    tsig_error: int = 0,</span>
<span class="gi">+    pad: Optional[int] = None,</span>
<span class="gi">+) -&gt; Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a message which is a response for the specified query.
<span class="w"> </span>    The message returned is really a response skeleton; it has all of the infrastructure
<span class="w"> </span>    required of a response, but none of the content.
<span class="gu">@@ -871,10 +1846,43 @@ def make_response(query: Message, recursion_available: bool=False,</span>
<span class="w"> </span>    query.  For example, if query is a ``dns.update.UpdateMessage``, response will be
<span class="w"> </span>    too.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if query.flags &amp; dns.flags.QR:</span>
<span class="gi">+        raise dns.exception.FormError(&quot;specified query message is not a query&quot;)</span>
<span class="gi">+    factory = _message_factory_from_opcode(query.opcode())</span>
<span class="gi">+    response = factory(id=query.id)</span>
<span class="gi">+    response.flags = dns.flags.QR | (query.flags &amp; dns.flags.RD)</span>
<span class="gi">+    if recursion_available:</span>
<span class="gi">+        response.flags |= dns.flags.RA</span>
<span class="gi">+    response.set_opcode(query.opcode())</span>
<span class="gi">+    response.question = list(query.question)</span>
<span class="gi">+    if query.edns &gt;= 0:</span>
<span class="gi">+        if pad is None:</span>
<span class="gi">+            # Set response padding per RFC 8467</span>
<span class="gi">+            pad = 0</span>
<span class="gi">+            for option in query.options:</span>
<span class="gi">+                if option.otype == dns.edns.OptionType.PADDING:</span>
<span class="gi">+                    pad = 468</span>
<span class="gi">+        response.use_edns(0, 0, our_payload, query.payload, pad=pad)</span>
<span class="gi">+    if query.had_tsig:</span>
<span class="gi">+        response.use_tsig(</span>
<span class="gi">+            query.keyring,</span>
<span class="gi">+            query.keyname,</span>
<span class="gi">+            fudge,</span>
<span class="gi">+            None,</span>
<span class="gi">+            tsig_error,</span>
<span class="gi">+            b&quot;&quot;,</span>
<span class="gi">+            query.keyalgorithm,</span>
<span class="gi">+        )</span>
<span class="gi">+        response.request_mac = query.mac</span>
<span class="gi">+    return response</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+### BEGIN generated MessageSection constants</span>

<span class="w"> </span>QUESTION = MessageSection.QUESTION
<span class="w"> </span>ANSWER = MessageSection.ANSWER
<span class="w"> </span>AUTHORITY = MessageSection.AUTHORITY
<span class="w"> </span>ADDITIONAL = MessageSection.ADDITIONAL
<span class="gi">+</span>
<span class="gi">+### END generated MessageSection constants</span>
<span class="gh">diff --git a/dns/name.py b/dns/name.py</span>
<span class="gh">index b9a153e..22ccb39 100644</span>
<span class="gd">--- a/dns/name.py</span>
<span class="gi">+++ b/dns/name.py</span>
<span class="gu">@@ -1,32 +1,72 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Names.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="gd">-import encodings.idna</span>
<span class="gi">+import encodings.idna  # type: ignore</span>
<span class="w"> </span>import functools
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Any, Callable, Dict, Iterable, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns._features
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.wire
<span class="gd">-if dns._features.have(&#39;idna&#39;):</span>
<span class="gd">-    import idna</span>
<span class="gi">+</span>
<span class="gi">+if dns._features.have(&quot;idna&quot;):</span>
<span class="gi">+    import idna  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>    have_idna_2008 = True
<span class="gd">-else:</span>
<span class="gi">+else:  # pragma: no cover</span>
<span class="w"> </span>    have_idna_2008 = False
<span class="gd">-CompressType = Dict[&#39;Name&#39;, int]</span>
<span class="gi">+</span>
<span class="gi">+CompressType = Dict[&quot;Name&quot;, int]</span>


<span class="w"> </span>class NameRelation(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;Name relation result from fullcompare().&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # This is an IntEnum for backwards compatibility in case anyone</span>
<span class="gi">+    # has hardwired the constants.</span>
<span class="gi">+</span>
<span class="gi">+    #: The compared names have no relationship to each other.</span>
<span class="w"> </span>    NONE = 0
<span class="gi">+    #: the first name is a superdomain of the second.</span>
<span class="w"> </span>    SUPERDOMAIN = 1
<span class="gi">+    #: The first name is a subdomain of the second.</span>
<span class="w"> </span>    SUBDOMAIN = 2
<span class="gi">+    #: The compared names are equal.</span>
<span class="w"> </span>    EQUAL = 3
<span class="gi">+    #: The compared names have a common ancestor.</span>
<span class="w"> </span>    COMMONANCESTOR = 4

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return cls.COMMONANCESTOR</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _short_name(cls):</span>
<span class="gi">+        return cls.__name__</span>

<span class="gi">+</span>
<span class="gi">+# Backwards compatibility</span>
<span class="w"> </span>NAMERELN_NONE = NameRelation.NONE
<span class="w"> </span>NAMERELN_SUPERDOMAIN = NameRelation.SUPERDOMAIN
<span class="w"> </span>NAMERELN_SUBDOMAIN = NameRelation.SUBDOMAIN
<span class="gu">@@ -80,9 +120,12 @@ class NoIDNA2008(dns.exception.DNSException):</span>

<span class="w"> </span>class IDNAException(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;IDNA processing raised an exception.&quot;&quot;&quot;
<span class="gd">-    supp_kwargs = {&#39;idna_exception&#39;}</span>
<span class="gd">-    fmt = &#39;IDNA processing exception: {idna_exception}&#39;</span>

<span class="gi">+    supp_kwargs = {&quot;idna_exception&quot;}</span>
<span class="gi">+    fmt = &quot;IDNA processing exception: {idna_exception}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gu">@@ -95,11 +138,33 @@ _escaped = b&#39;&quot;().;\\@$&#39;</span>
<span class="w"> </span>_escaped_text = &#39;&quot;().;\\@$&#39;


<span class="gd">-def _escapify(label: Union[bytes, str]) -&gt;str:</span>
<span class="gi">+def _escapify(label: Union[bytes, str]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Escape the characters in label which need it.
<span class="w"> </span>    @returns: the escaped string
<span class="w"> </span>    @rtype: string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(label, bytes):</span>
<span class="gi">+        # Ordinary DNS label mode.  Escape special characters and values</span>
<span class="gi">+        # &lt; 0x20 or &gt; 0x7f.</span>
<span class="gi">+        text = &quot;&quot;</span>
<span class="gi">+        for c in label:</span>
<span class="gi">+            if c in _escaped:</span>
<span class="gi">+                text += &quot;\\&quot; + chr(c)</span>
<span class="gi">+            elif c &gt; 0x20 and c &lt; 0x7F:</span>
<span class="gi">+                text += chr(c)</span>
<span class="gi">+            else:</span>
<span class="gi">+                text += &quot;\\%03d&quot; % c</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    # Unicode label mode.  Escape only special characters and values &lt; 0x20</span>
<span class="gi">+    text = &quot;&quot;</span>
<span class="gi">+    for uc in label:</span>
<span class="gi">+        if uc in _escaped_text:</span>
<span class="gi">+            text += &quot;\\&quot; + uc</span>
<span class="gi">+        elif uc &lt;= &quot;\x20&quot;:</span>
<span class="gi">+            text += &quot;\\%03d&quot; % ord(uc)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text += uc</span>
<span class="gi">+    return text</span>


<span class="w"> </span>class IDNACodec:
<span class="gu">@@ -108,34 +173,70 @@ class IDNACodec:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        pass

<span class="gi">+    def is_idna(self, label: bytes) -&gt; bool:</span>
<span class="gi">+        return label.lower().startswith(b&quot;xn--&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def encode(self, label: str) -&gt; bytes:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    def decode(self, label: bytes) -&gt; str:</span>
<span class="gi">+        # We do not apply any IDNA policy on decode.</span>
<span class="gi">+        if self.is_idna(label):</span>
<span class="gi">+            try:</span>
<span class="gi">+                slabel = label[4:].decode(&quot;punycode&quot;)</span>
<span class="gi">+                return _escapify(slabel)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                raise IDNAException(idna_exception=e)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _escapify(label)</span>
<span class="gi">+</span>

<span class="w"> </span>class IDNA2003Codec(IDNACodec):
<span class="w"> </span>    &quot;&quot;&quot;IDNA 2003 encoder/decoder.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, strict_decode: bool=False):</span>
<span class="gi">+    def __init__(self, strict_decode: bool = False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the IDNA 2003 encoder/decoder.

<span class="w"> </span>        *strict_decode* is a ``bool``. If `True`, then IDNA2003 checking
<span class="w"> </span>        is done when decoding.  This can cause failures if the name
<span class="w"> </span>        was encoded with IDNA2008.  The default is `False`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.strict_decode = strict_decode

<span class="gd">-    def encode(self, label: str) -&gt;bytes:</span>
<span class="gi">+    def encode(self, label: str) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode *label*.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def decode(self, label: bytes) -&gt;str:</span>
<span class="gi">+        if label == &quot;&quot;:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            return encodings.idna.ToASCII(label)</span>
<span class="gi">+        except UnicodeError:</span>
<span class="gi">+            raise LabelTooLong</span>
<span class="gi">+</span>
<span class="gi">+    def decode(self, label: bytes) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decode *label*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.strict_decode:</span>
<span class="gi">+            return super().decode(label)</span>
<span class="gi">+        if label == b&quot;&quot;:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _escapify(encodings.idna.ToUnicode(label))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise IDNAException(idna_exception=e)</span>


<span class="w"> </span>class IDNA2008Codec(IDNACodec):
<span class="w"> </span>    &quot;&quot;&quot;IDNA 2008 encoder/decoder.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, uts_46: bool=False, transitional: bool=False,</span>
<span class="gd">-        allow_pure_ascii: bool=False, strict_decode: bool=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        uts_46: bool = False,</span>
<span class="gi">+        transitional: bool = False,</span>
<span class="gi">+        allow_pure_ascii: bool = False,</span>
<span class="gi">+        strict_decode: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the IDNA 2008 encoder/decoder.

<span class="w"> </span>        *uts_46* is a ``bool``.  If True, apply Unicode IDNA
<span class="gu">@@ -164,6 +265,41 @@ class IDNA2008Codec(IDNACodec):</span>
<span class="w"> </span>        self.allow_pure_ascii = allow_pure_ascii
<span class="w"> </span>        self.strict_decode = strict_decode

<span class="gi">+    def encode(self, label: str) -&gt; bytes:</span>
<span class="gi">+        if label == &quot;&quot;:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        if self.allow_pure_ascii and is_all_ascii(label):</span>
<span class="gi">+            encoded = label.encode(&quot;ascii&quot;)</span>
<span class="gi">+            if len(encoded) &gt; 63:</span>
<span class="gi">+                raise LabelTooLong</span>
<span class="gi">+            return encoded</span>
<span class="gi">+        if not have_idna_2008:</span>
<span class="gi">+            raise NoIDNA2008</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.uts_46:</span>
<span class="gi">+                label = idna.uts46_remap(label, False, self.transitional)</span>
<span class="gi">+            return idna.alabel(label)</span>
<span class="gi">+        except idna.IDNAError as e:</span>
<span class="gi">+            if e.args[0] == &quot;Label too long&quot;:</span>
<span class="gi">+                raise LabelTooLong</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise IDNAException(idna_exception=e)</span>
<span class="gi">+</span>
<span class="gi">+    def decode(self, label: bytes) -&gt; str:</span>
<span class="gi">+        if not self.strict_decode:</span>
<span class="gi">+            return super().decode(label)</span>
<span class="gi">+        if label == b&quot;&quot;:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        if not have_idna_2008:</span>
<span class="gi">+            raise NoIDNA2008</span>
<span class="gi">+        try:</span>
<span class="gi">+            ulabel = idna.ulabel(label)</span>
<span class="gi">+            if self.uts_46:</span>
<span class="gi">+                ulabel = idna.uts46_remap(ulabel, False, self.transitional)</span>
<span class="gi">+            return _escapify(ulabel)</span>
<span class="gi">+        except (idna.IDNAError, UnicodeError) as e:</span>
<span class="gi">+            raise IDNAException(idna_exception=e)</span>
<span class="gi">+</span>

<span class="w"> </span>IDNA_2003_Practical = IDNA2003Codec(False)
<span class="w"> </span>IDNA_2003_Strict = IDNA2003Codec(True)
<span class="gu">@@ -175,7 +311,7 @@ IDNA_2008_Transitional = IDNA2008Codec(True, True, False, False)</span>
<span class="w"> </span>IDNA_2008 = IDNA_2008_Practical


<span class="gd">-def _validate_labels(labels: Tuple[bytes, ...]) -&gt;None:</span>
<span class="gi">+def _validate_labels(labels: Tuple[bytes, ...]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check for empty labels in the middle of a label sequence,
<span class="w"> </span>    labels that are too long, and for too many labels.

<span class="gu">@@ -186,15 +322,36 @@ def _validate_labels(labels: Tuple[bytes, ...]) -&gt;None:</span>
<span class="w"> </span>    sequence

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def _maybe_convert_to_binary(label: Union[bytes, str]) -&gt;bytes:</span>
<span class="gi">+    l = len(labels)</span>
<span class="gi">+    total = 0</span>
<span class="gi">+    i = -1</span>
<span class="gi">+    j = 0</span>
<span class="gi">+    for label in labels:</span>
<span class="gi">+        ll = len(label)</span>
<span class="gi">+        total += ll + 1</span>
<span class="gi">+        if ll &gt; 63:</span>
<span class="gi">+            raise LabelTooLong</span>
<span class="gi">+        if i &lt; 0 and label == b&quot;&quot;:</span>
<span class="gi">+            i = j</span>
<span class="gi">+        j += 1</span>
<span class="gi">+    if total &gt; 255:</span>
<span class="gi">+        raise NameTooLong</span>
<span class="gi">+    if i &gt;= 0 and i != l - 1:</span>
<span class="gi">+        raise EmptyLabel</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _maybe_convert_to_binary(label: Union[bytes, str]) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;If label is ``str``, convert it to ``bytes``.  If it is already
<span class="w"> </span>    ``bytes`` just return it.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(label, bytes):</span>
<span class="gi">+        return label</span>
<span class="gi">+    if isinstance(label, str):</span>
<span class="gi">+        return label.encode()</span>
<span class="gi">+    raise ValueError  # pragma: no cover</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gu">@@ -205,10 +362,12 @@ class Name:</span>
<span class="w"> </span>    labels.  Each label is a ``bytes`` in DNS wire format.  Instances
<span class="w"> </span>    of the class are immutable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;labels&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;labels&quot;]</span>

<span class="w"> </span>    def __init__(self, labels: Iterable[Union[bytes, str]]):
<span class="w"> </span>        &quot;&quot;&quot;*labels* is any iterable whose values are ``str`` or ``bytes``.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        blabels = [_maybe_convert_to_binary(x) for x in labels]
<span class="w"> </span>        self.labels = tuple(blabels)
<span class="w"> </span>        _validate_labels(self.labels)
<span class="gu">@@ -220,38 +379,42 @@ class Name:</span>
<span class="w"> </span>        return Name(copy.deepcopy(self.labels, memo))

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;labels&#39;: self.labels}</span>
<span class="gi">+        # Names can be pickled</span>
<span class="gi">+        return {&quot;labels&quot;: self.labels}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        super().__setattr__(&#39;labels&#39;, state[&#39;labels&#39;])</span>
<span class="gi">+        super().__setattr__(&quot;labels&quot;, state[&quot;labels&quot;])</span>
<span class="w"> </span>        _validate_labels(self.labels)

<span class="gd">-    def is_absolute(self) -&gt;bool:</span>
<span class="gi">+    def is_absolute(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is the most significant label of this name the root label?

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def is_wild(self) -&gt;bool:</span>
<span class="gi">+        return len(self.labels) &gt; 0 and self.labels[-1] == b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def is_wild(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is this name wild?  (I.e. Is the least significant label &#39;*&#39;?)

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return len(self.labels) &gt; 0 and self.labels[0] == b&quot;*&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a case-insensitive hash of the name.

<span class="w"> </span>        Returns an ``int``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        h = 0
<span class="w"> </span>        for label in self.labels:
<span class="w"> </span>            for c in label.lower():
<span class="w"> </span>                h += (h &lt;&lt; 3) + c
<span class="w"> </span>        return h

<span class="gd">-    def fullcompare(self, other: &#39;Name&#39;) -&gt;Tuple[NameRelation, int, int]:</span>
<span class="gi">+    def fullcompare(self, other: &quot;Name&quot;) -&gt; Tuple[NameRelation, int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compare two names, returning a 3-tuple
<span class="w"> </span>        ``(relation, order, nlabels)``.

<span class="gu">@@ -282,9 +445,52 @@ class Name:</span>
<span class="w"> </span>        example1.      example2       none         &gt; 0    0
<span class="w"> </span>        =============  =============  ===========  =====  =======
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def is_subdomain(self, other: &#39;Name&#39;) -&gt;bool:</span>
<span class="gi">+        sabs = self.is_absolute()</span>
<span class="gi">+        oabs = other.is_absolute()</span>
<span class="gi">+        if sabs != oabs:</span>
<span class="gi">+            if sabs:</span>
<span class="gi">+                return (NameRelation.NONE, 1, 0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return (NameRelation.NONE, -1, 0)</span>
<span class="gi">+        l1 = len(self.labels)</span>
<span class="gi">+        l2 = len(other.labels)</span>
<span class="gi">+        ldiff = l1 - l2</span>
<span class="gi">+        if ldiff &lt; 0:</span>
<span class="gi">+            l = l1</span>
<span class="gi">+        else:</span>
<span class="gi">+            l = l2</span>
<span class="gi">+</span>
<span class="gi">+        order = 0</span>
<span class="gi">+        nlabels = 0</span>
<span class="gi">+        namereln = NameRelation.NONE</span>
<span class="gi">+        while l &gt; 0:</span>
<span class="gi">+            l -= 1</span>
<span class="gi">+            l1 -= 1</span>
<span class="gi">+            l2 -= 1</span>
<span class="gi">+            label1 = self.labels[l1].lower()</span>
<span class="gi">+            label2 = other.labels[l2].lower()</span>
<span class="gi">+            if label1 &lt; label2:</span>
<span class="gi">+                order = -1</span>
<span class="gi">+                if nlabels &gt; 0:</span>
<span class="gi">+                    namereln = NameRelation.COMMONANCESTOR</span>
<span class="gi">+                return (namereln, order, nlabels)</span>
<span class="gi">+            elif label1 &gt; label2:</span>
<span class="gi">+                order = 1</span>
<span class="gi">+                if nlabels &gt; 0:</span>
<span class="gi">+                    namereln = NameRelation.COMMONANCESTOR</span>
<span class="gi">+                return (namereln, order, nlabels)</span>
<span class="gi">+            nlabels += 1</span>
<span class="gi">+        order = ldiff</span>
<span class="gi">+        if ldiff &lt; 0:</span>
<span class="gi">+            namereln = NameRelation.SUPERDOMAIN</span>
<span class="gi">+        elif ldiff &gt; 0:</span>
<span class="gi">+            namereln = NameRelation.SUBDOMAIN</span>
<span class="gi">+        else:</span>
<span class="gi">+            namereln = NameRelation.EQUAL</span>
<span class="gi">+        return (namereln, order, nlabels)</span>
<span class="gi">+</span>
<span class="gi">+    def is_subdomain(self, other: &quot;Name&quot;) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is self a subdomain of other?

<span class="w"> </span>        Note that the notion of subdomain includes equality, e.g.
<span class="gu">@@ -292,9 +498,13 @@ class Name:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def is_superdomain(self, other: &#39;Name&#39;) -&gt;bool:</span>
<span class="gi">+        (nr, _, _) = self.fullcompare(other)</span>
<span class="gi">+        if nr == NameRelation.SUBDOMAIN or nr == NameRelation.EQUAL:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_superdomain(self, other: &quot;Name&quot;) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is self a superdomain of other?

<span class="w"> </span>        Note that the notion of superdomain includes equality, e.g.
<span class="gu">@@ -302,13 +512,18 @@ class Name:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def canonicalize(self) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        (nr, _, _) = self.fullcompare(other)</span>
<span class="gi">+        if nr == NameRelation.SUPERDOMAIN or nr == NameRelation.EQUAL:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def canonicalize(self) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a name which is equal to the current name, but is in
<span class="w"> </span>        DNSSEC canonical form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return Name([x.lower() for x in self.labels])</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, Name):
<span class="gu">@@ -347,12 +562,12 @@ class Name:</span>
<span class="w"> </span>            return NotImplemented

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;DNS name &#39; + self.__str__() + &#39;&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;DNS name &quot; + self.__str__() + &quot;&gt;&quot;</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.to_text(False)

<span class="gd">-    def to_text(self, omit_final_dot: bool=False) -&gt;str:</span>
<span class="gi">+    def to_text(self, omit_final_dot: bool = False) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert name to DNS text format.

<span class="w"> </span>        *omit_final_dot* is a ``bool``.  If True, don&#39;t emit the final
<span class="gu">@@ -361,10 +576,21 @@ class Name:</span>

<span class="w"> </span>        Returns a ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_unicode(self, omit_final_dot: bool=False, idna_codec: Optional[</span>
<span class="gd">-        IDNACodec]=None) -&gt;str:</span>
<span class="gi">+        if len(self.labels) == 0:</span>
<span class="gi">+            return &quot;@&quot;</span>
<span class="gi">+        if len(self.labels) == 1 and self.labels[0] == b&quot;&quot;:</span>
<span class="gi">+            return &quot;.&quot;</span>
<span class="gi">+        if omit_final_dot and self.is_absolute():</span>
<span class="gi">+            l = self.labels[:-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            l = self.labels</span>
<span class="gi">+        s = &quot;.&quot;.join(map(_escapify, l))</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def to_unicode(</span>
<span class="gi">+        self, omit_final_dot: bool = False, idna_codec: Optional[IDNACodec] = None</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert name to Unicode text format.

<span class="w"> </span>        IDN ACE labels are converted to Unicode.
<span class="gu">@@ -381,9 +607,20 @@ class Name:</span>

<span class="w"> </span>        Returns a ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_digestable(self, origin: Optional[&#39;Name&#39;]=None) -&gt;bytes:</span>
<span class="gi">+        if len(self.labels) == 0:</span>
<span class="gi">+            return &quot;@&quot;</span>
<span class="gi">+        if len(self.labels) == 1 and self.labels[0] == b&quot;&quot;:</span>
<span class="gi">+            return &quot;.&quot;</span>
<span class="gi">+        if omit_final_dot and self.is_absolute():</span>
<span class="gi">+            l = self.labels[:-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            l = self.labels</span>
<span class="gi">+        if idna_codec is None:</span>
<span class="gi">+            idna_codec = IDNA_2003_Practical</span>
<span class="gi">+        return &quot;.&quot;.join([idna_codec.decode(x) for x in l])</span>
<span class="gi">+</span>
<span class="gi">+    def to_digestable(self, origin: Optional[&quot;Name&quot;] = None) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert name to a format suitable for digesting in hashes.

<span class="w"> </span>        The name is canonicalized and converted to uncompressed wire
<span class="gu">@@ -399,11 +636,18 @@ class Name:</span>

<span class="w"> </span>        Returns a ``bytes``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_wire(self, file: Optional[Any]=None, compress: Optional[</span>
<span class="gd">-        CompressType]=None, origin: Optional[&#39;Name&#39;]=None, canonicalize:</span>
<span class="gd">-        bool=False) -&gt;Optional[bytes]:</span>
<span class="gi">+        digest = self.to_wire(origin=origin, canonicalize=True)</span>
<span class="gi">+        assert digest is not None</span>
<span class="gi">+        return digest</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        file: Optional[Any] = None,</span>
<span class="gi">+        compress: Optional[CompressType] = None,</span>
<span class="gi">+        origin: Optional[&quot;Name&quot;] = None,</span>
<span class="gi">+        canonicalize: bool = False,</span>
<span class="gi">+    ) -&gt; Optional[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert name to wire format, possibly compressing it.

<span class="w"> </span>        *file* is the file where the name is emitted (typically an
<span class="gu">@@ -429,13 +673,67 @@ class Name:</span>

<span class="w"> </span>        Returns a ``bytes`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            out = bytearray()</span>
<span class="gi">+            for label in self.labels:</span>
<span class="gi">+                out.append(len(label))</span>
<span class="gi">+                if canonicalize:</span>
<span class="gi">+                    out += label.lower()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    out += label</span>
<span class="gi">+            if not self.is_absolute():</span>
<span class="gi">+                if origin is None or not origin.is_absolute():</span>
<span class="gi">+                    raise NeedAbsoluteNameOrOrigin</span>
<span class="gi">+                for label in origin.labels:</span>
<span class="gi">+                    out.append(len(label))</span>
<span class="gi">+                    if canonicalize:</span>
<span class="gi">+                        out += label.lower()</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        out += label</span>
<span class="gi">+            return bytes(out)</span>
<span class="gi">+</span>
<span class="gi">+        labels: Iterable[bytes]</span>
<span class="gi">+        if not self.is_absolute():</span>
<span class="gi">+            if origin is None or not origin.is_absolute():</span>
<span class="gi">+                raise NeedAbsoluteNameOrOrigin</span>
<span class="gi">+            labels = list(self.labels)</span>
<span class="gi">+            labels.extend(list(origin.labels))</span>
<span class="gi">+        else:</span>
<span class="gi">+            labels = self.labels</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        for label in labels:</span>
<span class="gi">+            n = Name(labels[i:])</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            if compress is not None:</span>
<span class="gi">+                pos = compress.get(n)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pos = None</span>
<span class="gi">+            if pos is not None:</span>
<span class="gi">+                value = 0xC000 + pos</span>
<span class="gi">+                s = struct.pack(&quot;!H&quot;, value)</span>
<span class="gi">+                file.write(s)</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                if compress is not None and len(n) &gt; 1:</span>
<span class="gi">+                    pos = file.tell()</span>
<span class="gi">+                    if pos &lt;= 0x3FFF:</span>
<span class="gi">+                        compress[n] = pos</span>
<span class="gi">+                l = len(label)</span>
<span class="gi">+                file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+                if l &gt; 0:</span>
<span class="gi">+                    if canonicalize:</span>
<span class="gi">+                        file.write(label.lower())</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        file.write(label)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The length of the name (in labels).

<span class="w"> </span>        Returns an ``int``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        return len(self.labels)

<span class="w"> </span>    def __getitem__(self, index):
<span class="gu">@@ -447,7 +745,7 @@ class Name:</span>
<span class="w"> </span>    def __sub__(self, other):
<span class="w"> </span>        return self.relativize(other)

<span class="gd">-    def split(self, depth: int) -&gt;Tuple[&#39;Name&#39;, &#39;Name&#39;]:</span>
<span class="gi">+    def split(self, depth: int) -&gt; Tuple[&quot;Name&quot;, &quot;Name&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Split a name into a prefix and suffix names at the specified depth.

<span class="w"> </span>        *depth* is an ``int`` specifying the number of labels in the suffix
<span class="gu">@@ -457,9 +755,17 @@ class Name:</span>

<span class="w"> </span>        Returns the tuple ``(prefix, suffix)``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def concatenate(self, other: &#39;Name&#39;) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        l = len(self.labels)</span>
<span class="gi">+        if depth == 0:</span>
<span class="gi">+            return (self, dns.name.empty)</span>
<span class="gi">+        elif depth == l:</span>
<span class="gi">+            return (dns.name.empty, self)</span>
<span class="gi">+        elif depth &lt; 0 or depth &gt; l:</span>
<span class="gi">+            raise ValueError(&quot;depth must be &gt;= 0 and &lt;= the length of the name&quot;)</span>
<span class="gi">+        return (Name(self[:-depth]), Name(self[-depth:]))</span>
<span class="gi">+</span>
<span class="gi">+    def concatenate(self, other: &quot;Name&quot;) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new name which is the concatenation of self and other.

<span class="w"> </span>        Raises ``dns.name.AbsoluteConcatenation`` if the name is
<span class="gu">@@ -467,9 +773,14 @@ class Name:</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def relativize(self, origin: &#39;Name&#39;) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        if self.is_absolute() and len(other) &gt; 0:</span>
<span class="gi">+            raise AbsoluteConcatenation</span>
<span class="gi">+        labels = list(self.labels)</span>
<span class="gi">+        labels.extend(list(other.labels))</span>
<span class="gi">+        return Name(labels)</span>
<span class="gi">+</span>
<span class="gi">+    def relativize(self, origin: &quot;Name&quot;) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;If the name is a subdomain of *origin*, return a new name which is
<span class="w"> </span>        the name relative to origin.  Otherwise return the name.

<span class="gu">@@ -479,9 +790,13 @@ class Name:</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def derelativize(self, origin: &#39;Name&#39;) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        if origin is not None and self.is_subdomain(origin):</span>
<span class="gi">+            return Name(self[: -len(origin)])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+    def derelativize(self, origin: &quot;Name&quot;) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;If the name is a relative name, return a new name which is the
<span class="w"> </span>        concatenation of the name and origin.  Otherwise return the name.

<span class="gu">@@ -491,10 +806,15 @@ class Name:</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def choose_relativity(self, origin: Optional[&#39;Name&#39;]=None, relativize:</span>
<span class="gd">-        bool=True) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        if not self.is_absolute():</span>
<span class="gi">+            return self.concatenate(origin)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+    def choose_relativity(</span>
<span class="gi">+        self, origin: Optional[&quot;Name&quot;] = None, relativize: bool = True</span>
<span class="gi">+    ) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a name with the relativity desired by the caller.

<span class="w"> </span>        If *origin* is ``None``, then the name is returned.
<span class="gu">@@ -504,9 +824,16 @@ class Name:</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def parent(self) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        if origin:</span>
<span class="gi">+            if relativize:</span>
<span class="gi">+                return self.relativize(origin)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.derelativize(origin)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+    def parent(self) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the parent of the name.

<span class="w"> </span>        For example, the parent of ``www.dnspython.org.`` is ``dnspython.org``.
<span class="gu">@@ -516,9 +843,12 @@ class Name:</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def predecessor(self, origin: &#39;Name&#39;, prefix_ok: bool=True) -&gt;&#39;Name&#39;:</span>
<span class="gi">+        if self == root or self == empty:</span>
<span class="gi">+            raise NoParent</span>
<span class="gi">+        return Name(self.labels[1:])</span>
<span class="gi">+</span>
<span class="gi">+    def predecessor(self, origin: &quot;Name&quot;, prefix_ok: bool = True) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the maximal predecessor of *name* in the DNSSEC ordering in the zone
<span class="w"> </span>        whose origin is *origin*, or return the longest name under *origin* if the
<span class="w"> </span>        name is origin (i.e. wrap around to the longest name, which may still be
<span class="gu">@@ -532,9 +862,11 @@ class Name:</span>
<span class="w"> </span>        defaults to ``True``.  Normally it is good to allow this, but if computing
<span class="w"> </span>        a maximal predecessor at a zone cut point then ``False`` must be specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _handle_relativity_and_call(</span>
<span class="gi">+            _absolute_predecessor, self, origin, prefix_ok</span>
<span class="gi">+        )</span>

<span class="gd">-    def successor(self, origin: &#39;Name&#39;, prefix_ok: bool=True) -&gt;&#39;Name&#39;:</span>
<span class="gi">+    def successor(self, origin: &quot;Name&quot;, prefix_ok: bool = True) -&gt; &quot;Name&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the minimal successor of *name* in the DNSSEC ordering in the zone
<span class="w"> </span>        whose origin is *origin*, or return *origin* if the successor cannot be
<span class="w"> </span>        computed due to name length limitations.
<span class="gu">@@ -550,15 +882,19 @@ class Name:</span>
<span class="w"> </span>        defaults to ``True``.  Normally it is good to allow this, but if computing
<span class="w"> </span>        a minimal successor at a zone cut point then ``False`` must be specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _handle_relativity_and_call(_absolute_successor, self, origin, prefix_ok)</span>


<span class="gd">-root = Name([b&#39;&#39;])</span>
<span class="gi">+#: The root name, &#39;.&#39;</span>
<span class="gi">+root = Name([b&quot;&quot;])</span>
<span class="gi">+</span>
<span class="gi">+#: The empty name.</span>
<span class="w"> </span>empty = Name([])


<span class="gd">-def from_unicode(text: str, origin: Optional[Name]=root, idna_codec:</span>
<span class="gd">-    Optional[IDNACodec]=None) -&gt;Name:</span>
<span class="gi">+def from_unicode(</span>
<span class="gi">+    text: str, origin: Optional[Name] = root, idna_codec: Optional[IDNACodec] = None</span>
<span class="gi">+) -&gt; Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert unicode text into a Name object.

<span class="w"> </span>    Labels are encoded in IDN ACE form according to rules specified by
<span class="gu">@@ -575,11 +911,76 @@ def from_unicode(text: str, origin: Optional[Name]=root, idna_codec:</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        raise ValueError(&quot;input to from_unicode() must be a unicode string&quot;)</span>
<span class="gi">+    if not (origin is None or isinstance(origin, Name)):</span>
<span class="gi">+        raise ValueError(&quot;origin must be a Name or None&quot;)</span>
<span class="gi">+    labels = []</span>
<span class="gi">+    label = &quot;&quot;</span>
<span class="gi">+    escaping = False</span>
<span class="gi">+    edigits = 0</span>
<span class="gi">+    total = 0</span>
<span class="gi">+    if idna_codec is None:</span>
<span class="gi">+        idna_codec = IDNA_2003</span>
<span class="gi">+    if text == &quot;@&quot;:</span>
<span class="gi">+        text = &quot;&quot;</span>
<span class="gi">+    if text:</span>
<span class="gi">+        if text in [&quot;.&quot;, &quot;\u3002&quot;, &quot;\uff0e&quot;, &quot;\uff61&quot;]:</span>
<span class="gi">+            return Name([b&quot;&quot;])  # no Unicode &quot;u&quot; on this constant!</span>
<span class="gi">+        for c in text:</span>
<span class="gi">+            if escaping:</span>
<span class="gi">+                if edigits == 0:</span>
<span class="gi">+                    if c.isdigit():</span>
<span class="gi">+                        total = int(c)</span>
<span class="gi">+                        edigits += 1</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        label += c</span>
<span class="gi">+                        escaping = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not c.isdigit():</span>
<span class="gi">+                        raise BadEscape</span>
<span class="gi">+                    total *= 10</span>
<span class="gi">+                    total += int(c)</span>
<span class="gi">+                    edigits += 1</span>
<span class="gi">+                    if edigits == 3:</span>
<span class="gi">+                        escaping = False</span>
<span class="gi">+                        label += chr(total)</span>
<span class="gi">+            elif c in [&quot;.&quot;, &quot;\u3002&quot;, &quot;\uff0e&quot;, &quot;\uff61&quot;]:</span>
<span class="gi">+                if len(label) == 0:</span>
<span class="gi">+                    raise EmptyLabel</span>
<span class="gi">+                labels.append(idna_codec.encode(label))</span>
<span class="gi">+                label = &quot;&quot;</span>
<span class="gi">+            elif c == &quot;\\&quot;:</span>
<span class="gi">+                escaping = True</span>
<span class="gi">+                edigits = 0</span>
<span class="gi">+                total = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                label += c</span>
<span class="gi">+        if escaping:</span>
<span class="gi">+            raise BadEscape</span>
<span class="gi">+        if len(label) &gt; 0:</span>
<span class="gi">+            labels.append(idna_codec.encode(label))</span>
<span class="gi">+        else:</span>
<span class="gi">+            labels.append(b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if (len(labels) == 0 or labels[-1] != b&quot;&quot;) and origin is not None:</span>
<span class="gi">+        labels.extend(list(origin.labels))</span>
<span class="gi">+    return Name(labels)</span>

<span class="gd">-def from_text(text: Union[bytes, str], origin: Optional[Name]=root,</span>
<span class="gd">-    idna_codec: Optional[IDNACodec]=None) -&gt;Name:</span>
<span class="gi">+</span>
<span class="gi">+def is_all_ascii(text: str) -&gt; bool:</span>
<span class="gi">+    for c in text:</span>
<span class="gi">+        if ord(c) &gt; 0x7F:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text(</span>
<span class="gi">+    text: Union[bytes, str],</span>
<span class="gi">+    origin: Optional[Name] = root,</span>
<span class="gi">+    idna_codec: Optional[IDNACodec] = None,</span>
<span class="gi">+) -&gt; Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert text into a Name object.

<span class="w"> </span>    *text*, a ``bytes`` or ``str``, is the text to convert into a name.
<span class="gu">@@ -593,10 +994,79 @@ def from_text(text: Union[bytes, str], origin: Optional[Name]=root,</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if isinstance(text, str):</span>
<span class="gi">+        if not is_all_ascii(text):</span>
<span class="gi">+            # Some codepoint in the input text is &gt; 127, so IDNA applies.</span>
<span class="gi">+            return from_unicode(text, origin, idna_codec)</span>
<span class="gi">+        # The input is all ASCII, so treat this like an ordinary non-IDNA</span>
<span class="gi">+        # domain name.  Note that &quot;all ASCII&quot; is about the input text,</span>
<span class="gi">+        # not the codepoints in the domain name.  E.g. if text has value</span>
<span class="gi">+        #</span>
<span class="gi">+        # r&#39;\150\151\152\153\154\155\156\157\158\159&#39;</span>
<span class="gi">+        #</span>
<span class="gi">+        # then it&#39;s still &quot;all ASCII&quot; even though the domain name has</span>
<span class="gi">+        # codepoints &gt; 127.</span>
<span class="gi">+        text = text.encode(&quot;ascii&quot;)</span>
<span class="gi">+    if not isinstance(text, bytes):</span>
<span class="gi">+        raise ValueError(&quot;input to from_text() must be a string&quot;)</span>
<span class="gi">+    if not (origin is None or isinstance(origin, Name)):</span>
<span class="gi">+        raise ValueError(&quot;origin must be a Name or None&quot;)</span>
<span class="gi">+    labels = []</span>
<span class="gi">+    label = b&quot;&quot;</span>
<span class="gi">+    escaping = False</span>
<span class="gi">+    edigits = 0</span>
<span class="gi">+    total = 0</span>
<span class="gi">+    if text == b&quot;@&quot;:</span>
<span class="gi">+        text = b&quot;&quot;</span>
<span class="gi">+    if text:</span>
<span class="gi">+        if text == b&quot;.&quot;:</span>
<span class="gi">+            return Name([b&quot;&quot;])</span>
<span class="gi">+        for c in text:</span>
<span class="gi">+            byte_ = struct.pack(&quot;!B&quot;, c)</span>
<span class="gi">+            if escaping:</span>
<span class="gi">+                if edigits == 0:</span>
<span class="gi">+                    if byte_.isdigit():</span>
<span class="gi">+                        total = int(byte_)</span>
<span class="gi">+                        edigits += 1</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        label += byte_</span>
<span class="gi">+                        escaping = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not byte_.isdigit():</span>
<span class="gi">+                        raise BadEscape</span>
<span class="gi">+                    total *= 10</span>
<span class="gi">+                    total += int(byte_)</span>
<span class="gi">+                    edigits += 1</span>
<span class="gi">+                    if edigits == 3:</span>
<span class="gi">+                        escaping = False</span>
<span class="gi">+                        label += struct.pack(&quot;!B&quot;, total)</span>
<span class="gi">+            elif byte_ == b&quot;.&quot;:</span>
<span class="gi">+                if len(label) == 0:</span>
<span class="gi">+                    raise EmptyLabel</span>
<span class="gi">+                labels.append(label)</span>
<span class="gi">+                label = b&quot;&quot;</span>
<span class="gi">+            elif byte_ == b&quot;\\&quot;:</span>
<span class="gi">+                escaping = True</span>
<span class="gi">+                edigits = 0</span>
<span class="gi">+                total = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                label += byte_</span>
<span class="gi">+        if escaping:</span>
<span class="gi">+            raise BadEscape</span>
<span class="gi">+        if len(label) &gt; 0:</span>
<span class="gi">+            labels.append(label)</span>
<span class="gi">+        else:</span>
<span class="gi">+            labels.append(b&quot;&quot;)</span>
<span class="gi">+    if (len(labels) == 0 or labels[-1] != b&quot;&quot;) and origin is not None:</span>
<span class="gi">+        labels.extend(list(origin.labels))</span>
<span class="gi">+    return Name(labels)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# we need &#39;dns.wire.Parser&#39; quoted as dns.name and dns.wire depend on each other.</span>

<span class="gd">-def from_wire_parser(parser: &#39;dns.wire.Parser&#39;) -&gt;Name:</span>
<span class="gi">+</span>
<span class="gi">+def from_wire_parser(parser: &quot;dns.wire.Parser&quot;) -&gt; Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert possibly compressed wire format into a Name.

<span class="w"> </span>    *parser* is a dns.wire.Parser.
<span class="gu">@@ -608,10 +1078,28 @@ def from_wire_parser(parser: &#39;dns.wire.Parser&#39;) -&gt;Name:</span>

<span class="w"> </span>    Returns a ``dns.name.Name``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def from_wire(message: bytes, current: int) -&gt;Tuple[Name, int]:</span>
<span class="gi">+    labels = []</span>
<span class="gi">+    biggest_pointer = parser.current</span>
<span class="gi">+    with parser.restore_furthest():</span>
<span class="gi">+        count = parser.get_uint8()</span>
<span class="gi">+        while count != 0:</span>
<span class="gi">+            if count &lt; 64:</span>
<span class="gi">+                labels.append(parser.get_bytes(count))</span>
<span class="gi">+            elif count &gt;= 192:</span>
<span class="gi">+                current = (count &amp; 0x3F) * 256 + parser.get_uint8()</span>
<span class="gi">+                if current &gt;= biggest_pointer:</span>
<span class="gi">+                    raise BadPointer</span>
<span class="gi">+                biggest_pointer = current</span>
<span class="gi">+                parser.seek(current)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise BadLabelType</span>
<span class="gi">+            count = parser.get_uint8()</span>
<span class="gi">+        labels.append(b&quot;&quot;)</span>
<span class="gi">+    return Name(labels)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_wire(message: bytes, current: int) -&gt; Tuple[Name, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert possibly compressed wire format into a Name.

<span class="w"> </span>    *message* is a ``bytes`` containing an entire DNS message in DNS
<span class="gu">@@ -629,13 +1117,167 @@ def from_wire(message: bytes, current: int) -&gt;Tuple[Name, int]:</span>
<span class="w"> </span>    that was read and the number of bytes of the wire format message
<span class="w"> </span>    which were consumed reading it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(message, bytes):</span>
<span class="gi">+        raise ValueError(&quot;input to from_wire() must be a byte string&quot;)</span>
<span class="gi">+    parser = dns.wire.Parser(message, current)</span>
<span class="gi">+    name = from_wire_parser(parser)</span>
<span class="gi">+    return (name, parser.current - current)</span>


<span class="gd">-_MINIMAL_OCTET = b&#39;\x00&#39;</span>
<span class="gi">+# RFC 4471 Support</span>
<span class="gi">+</span>
<span class="gi">+_MINIMAL_OCTET = b&quot;\x00&quot;</span>
<span class="w"> </span>_MINIMAL_OCTET_VALUE = ord(_MINIMAL_OCTET)
<span class="w"> </span>_SUCCESSOR_PREFIX = Name([_MINIMAL_OCTET])
<span class="gd">-_MAXIMAL_OCTET = b&#39;\xff&#39;</span>
<span class="gi">+_MAXIMAL_OCTET = b&quot;\xff&quot;</span>
<span class="w"> </span>_MAXIMAL_OCTET_VALUE = ord(_MAXIMAL_OCTET)
<span class="gd">-_AT_SIGN_VALUE = ord(&#39;@&#39;)</span>
<span class="gd">-_LEFT_SQUARE_BRACKET_VALUE = ord(&#39;[&#39;)</span>
<span class="gi">+_AT_SIGN_VALUE = ord(&quot;@&quot;)</span>
<span class="gi">+_LEFT_SQUARE_BRACKET_VALUE = ord(&quot;[&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _wire_length(labels):</span>
<span class="gi">+    return functools.reduce(lambda v, x: v + len(x) + 1, labels, 0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pad_to_max_name(name):</span>
<span class="gi">+    needed = 255 - _wire_length(name.labels)</span>
<span class="gi">+    new_labels = []</span>
<span class="gi">+    while needed &gt; 64:</span>
<span class="gi">+        new_labels.append(_MAXIMAL_OCTET * 63)</span>
<span class="gi">+        needed -= 64</span>
<span class="gi">+    if needed &gt;= 2:</span>
<span class="gi">+        new_labels.append(_MAXIMAL_OCTET * (needed - 1))</span>
<span class="gi">+    # Note we&#39;re already maximal in the needed == 1 case as while we&#39;d like</span>
<span class="gi">+    # to add one more byte as a new label, we can&#39;t, as adding a new non-empty</span>
<span class="gi">+    # label requires at least 2 bytes.</span>
<span class="gi">+    new_labels = list(reversed(new_labels))</span>
<span class="gi">+    new_labels.extend(name.labels)</span>
<span class="gi">+    return Name(new_labels)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pad_to_max_label(label, suffix_labels):</span>
<span class="gi">+    length = len(label)</span>
<span class="gi">+    # We have to subtract one here to account for the length byte of label.</span>
<span class="gi">+    remaining = 255 - _wire_length(suffix_labels) - length - 1</span>
<span class="gi">+    if remaining &lt;= 0:</span>
<span class="gi">+        # Shouldn&#39;t happen!</span>
<span class="gi">+        return label</span>
<span class="gi">+    needed = min(63 - length, remaining)</span>
<span class="gi">+    return label + _MAXIMAL_OCTET * needed</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _absolute_predecessor(name: Name, origin: Name, prefix_ok: bool) -&gt; Name:</span>
<span class="gi">+    # This is the RFC 4471 predecessor algorithm using the &quot;absolute method&quot; of section</span>
<span class="gi">+    # 3.1.1.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Our caller must ensure that the name and origin are absolute, and that name is a</span>
<span class="gi">+    # subdomain of origin.</span>
<span class="gi">+    if name == origin:</span>
<span class="gi">+        return _pad_to_max_name(name)</span>
<span class="gi">+    least_significant_label = name[0]</span>
<span class="gi">+    if least_significant_label == _MINIMAL_OCTET:</span>
<span class="gi">+        return name.parent()</span>
<span class="gi">+    least_octet = least_significant_label[-1]</span>
<span class="gi">+    suffix_labels = name.labels[1:]</span>
<span class="gi">+    if least_octet == _MINIMAL_OCTET_VALUE:</span>
<span class="gi">+        new_labels = [least_significant_label[:-1]]</span>
<span class="gi">+    else:</span>
<span class="gi">+        octets = bytearray(least_significant_label)</span>
<span class="gi">+        octet = octets[-1]</span>
<span class="gi">+        if octet == _LEFT_SQUARE_BRACKET_VALUE:</span>
<span class="gi">+            octet = _AT_SIGN_VALUE</span>
<span class="gi">+        else:</span>
<span class="gi">+            octet -= 1</span>
<span class="gi">+        octets[-1] = octet</span>
<span class="gi">+        least_significant_label = bytes(octets)</span>
<span class="gi">+        new_labels = [_pad_to_max_label(least_significant_label, suffix_labels)]</span>
<span class="gi">+    new_labels.extend(suffix_labels)</span>
<span class="gi">+    name = Name(new_labels)</span>
<span class="gi">+    if prefix_ok:</span>
<span class="gi">+        return _pad_to_max_name(name)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _absolute_successor(name: Name, origin: Name, prefix_ok: bool) -&gt; Name:</span>
<span class="gi">+    # This is the RFC 4471 successor algorithm using the &quot;absolute method&quot; of section</span>
<span class="gi">+    # 3.1.2.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Our caller must ensure that the name and origin are absolute, and that name is a</span>
<span class="gi">+    # subdomain of origin.</span>
<span class="gi">+    if prefix_ok:</span>
<span class="gi">+        # Try prefixing \000 as new label</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _SUCCESSOR_PREFIX.concatenate(name)</span>
<span class="gi">+        except NameTooLong:</span>
<span class="gi">+            pass</span>
<span class="gi">+    while name != origin:</span>
<span class="gi">+        # Try extending the least significant label.</span>
<span class="gi">+        least_significant_label = name[0]</span>
<span class="gi">+        if len(least_significant_label) &lt; 63:</span>
<span class="gi">+            # We may be able to extend the least label with a minimal additional byte.</span>
<span class="gi">+            # This is only &quot;may&quot; because we could have a maximal length name even though</span>
<span class="gi">+            # the least significant label isn&#39;t maximally long.</span>
<span class="gi">+            new_labels = [least_significant_label + _MINIMAL_OCTET]</span>
<span class="gi">+            new_labels.extend(name.labels[1:])</span>
<span class="gi">+            try:</span>
<span class="gi">+                return dns.name.Name(new_labels)</span>
<span class="gi">+            except dns.name.NameTooLong:</span>
<span class="gi">+                pass</span>
<span class="gi">+        # We can&#39;t extend the label either, so we&#39;ll try to increment the least</span>
<span class="gi">+        # signficant non-maximal byte in it.</span>
<span class="gi">+        octets = bytearray(least_significant_label)</span>
<span class="gi">+        # We do this reversed iteration with an explicit indexing variable because</span>
<span class="gi">+        # if we find something to increment, we&#39;re going to want to truncate everything</span>
<span class="gi">+        # to the right of it.</span>
<span class="gi">+        for i in range(len(octets) - 1, -1, -1):</span>
<span class="gi">+            octet = octets[i]</span>
<span class="gi">+            if octet == _MAXIMAL_OCTET_VALUE:</span>
<span class="gi">+                # We can&#39;t increment this, so keep looking.</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Finally, something we can increment.  We have to apply a special rule for</span>
<span class="gi">+            # incrementing &quot;@&quot;, sending it to &quot;[&quot;, because RFC 4034 6.1 says that when</span>
<span class="gi">+            # comparing names, uppercase letters compare as if they were their</span>
<span class="gi">+            # lower-case equivalents. If we increment &quot;@&quot; to &quot;A&quot;, then it would compare</span>
<span class="gi">+            # as &quot;a&quot;, which is after &quot;[&quot;, &quot;\&quot;, &quot;]&quot;, &quot;^&quot;, &quot;_&quot;, and &quot;`&quot;, so we would have</span>
<span class="gi">+            # skipped the most minimal successor, namely &quot;[&quot;.</span>
<span class="gi">+            if octet == _AT_SIGN_VALUE:</span>
<span class="gi">+                octet = _LEFT_SQUARE_BRACKET_VALUE</span>
<span class="gi">+            else:</span>
<span class="gi">+                octet += 1</span>
<span class="gi">+            octets[i] = octet</span>
<span class="gi">+            # We can now truncate all of the maximal values we skipped (if any)</span>
<span class="gi">+            new_labels = [bytes(octets[: i + 1])]</span>
<span class="gi">+            new_labels.extend(name.labels[1:])</span>
<span class="gi">+            # We haven&#39;t changed the length of the name, so the Name constructor will</span>
<span class="gi">+            # always work.</span>
<span class="gi">+            return Name(new_labels)</span>
<span class="gi">+        # We couldn&#39;t increment, so chop off the least significant label and try</span>
<span class="gi">+        # again.</span>
<span class="gi">+        name = name.parent()</span>
<span class="gi">+</span>
<span class="gi">+    # We couldn&#39;t increment at all, so return the origin, as wrapping around is the</span>
<span class="gi">+    # DNSSEC way.</span>
<span class="gi">+    return origin</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _handle_relativity_and_call(</span>
<span class="gi">+    function: Callable[[Name, Name, bool], Name],</span>
<span class="gi">+    name: Name,</span>
<span class="gi">+    origin: Name,</span>
<span class="gi">+    prefix_ok: bool,</span>
<span class="gi">+) -&gt; Name:</span>
<span class="gi">+    # Make &quot;name&quot; absolute if needed, ensure that the origin is absolute,</span>
<span class="gi">+    # call function(), and then relativize the result if needed.</span>
<span class="gi">+    if not origin.is_absolute():</span>
<span class="gi">+        raise NeedAbsoluteNameOrOrigin</span>
<span class="gi">+    relative = not name.is_absolute()</span>
<span class="gi">+    if relative:</span>
<span class="gi">+        name = name.derelativize(origin)</span>
<span class="gi">+    elif not name.is_subdomain(origin):</span>
<span class="gi">+        raise NeedSubdomainOfOrigin</span>
<span class="gi">+    result_name = function(name, origin, prefix_ok)</span>
<span class="gi">+    if relative:</span>
<span class="gi">+        result_name = result_name.relativize(origin)</span>
<span class="gi">+    return result_name</span>
<span class="gh">diff --git a/dns/namedict.py b/dns/namedict.py</span>
<span class="gh">index e2fcfff..ca8b197 100644</span>
<span class="gd">--- a/dns/namedict.py</span>
<span class="gi">+++ b/dns/namedict.py</span>
<span class="gu">@@ -1,5 +1,35 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+# Copyright (C) 2016 Coresec Systems AB</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND CORESEC SYSTEMS AB DISCLAIMS ALL</span>
<span class="gi">+# WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED</span>
<span class="gi">+# WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CORESEC</span>
<span class="gi">+# SYSTEMS AB BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR</span>
<span class="gi">+# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS</span>
<span class="gi">+# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="gi">+# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION</span>
<span class="gi">+# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS name dictionary&quot;&quot;&quot;
<span class="gd">-from collections.abc import MutableMapping</span>
<span class="gi">+</span>
<span class="gi">+# pylint seems to be confused about this one!</span>
<span class="gi">+from collections.abc import MutableMapping  # pylint: disable=no-name-in-module</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.name


<span class="gu">@@ -9,21 +39,31 @@ class NameDict(MutableMapping):</span>
<span class="w"> </span>    In addition to being like a regular Python dictionary, this
<span class="w"> </span>    dictionary can also get the deepest match for a given key.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;max_depth&#39;, &#39;max_depth_items&#39;, &#39;__store&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;max_depth&quot;, &quot;max_depth_items&quot;, &quot;__store&quot;]</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.__store = dict()
<span class="gi">+        #: the maximum depth of the keys that have ever been added</span>
<span class="w"> </span>        self.max_depth = 0
<span class="gi">+        #: the number of items of maximum depth</span>
<span class="w"> </span>        self.max_depth_items = 0
<span class="w"> </span>        self.update(dict(*args, **kwargs))

<span class="gi">+    def __update_max_depth(self, key):</span>
<span class="gi">+        if len(key) == self.max_depth:</span>
<span class="gi">+            self.max_depth_items = self.max_depth_items + 1</span>
<span class="gi">+        elif len(key) &gt; self.max_depth:</span>
<span class="gi">+            self.max_depth = len(key)</span>
<span class="gi">+            self.max_depth_items = 1</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        return self.__store[key]

<span class="w"> </span>    def __setitem__(self, key, value):
<span class="w"> </span>        if not isinstance(key, dns.name.Name):
<span class="gd">-            raise ValueError(&#39;NameDict key must be a name&#39;)</span>
<span class="gi">+            raise ValueError(&quot;NameDict key must be a name&quot;)</span>
<span class="w"> </span>        self.__store[key] = value
<span class="w"> </span>        self.__update_max_depth(key)

<span class="gu">@@ -42,6 +82,9 @@ class NameDict(MutableMapping):</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self.__store)

<span class="gi">+    def has_key(self, key):</span>
<span class="gi">+        return key in self.__store</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_deepest_match(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Find the deepest match to *name* in the dictionary.

<span class="gu">@@ -54,4 +97,13 @@ class NameDict(MutableMapping):</span>
<span class="w"> </span>        Returns a ``(key, value)`` where *key* is the deepest
<span class="w"> </span>        ``dns.name.Name``, and *value* is the value associated with *key*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        depth = len(name)</span>
<span class="gi">+        if depth &gt; self.max_depth:</span>
<span class="gi">+            depth = self.max_depth</span>
<span class="gi">+        for i in range(-depth, 0):</span>
<span class="gi">+            n = dns.name.Name(name[i:])</span>
<span class="gi">+            if n in self:</span>
<span class="gi">+                return (n, self[n])</span>
<span class="gi">+        v = self[dns.name.empty]</span>
<span class="gi">+        return (dns.name.empty, v)</span>
<span class="gh">diff --git a/dns/nameserver.py b/dns/nameserver.py</span>
<span class="gh">index 3c1878b..5dbb4e8 100644</span>
<span class="gd">--- a/dns/nameserver.py</span>
<span class="gi">+++ b/dns/nameserver.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from typing import Optional, Union
<span class="w"> </span>from urllib.parse import urlparse
<span class="gi">+</span>
<span class="w"> </span>import dns.asyncbackend
<span class="w"> </span>import dns.asyncquery
<span class="w"> </span>import dns.inet
<span class="gu">@@ -8,59 +9,351 @@ import dns.query</span>


<span class="w"> </span>class Nameserver:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        pass

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        raise NotImplementedError

<span class="gi">+    def kind(self) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-class AddressAndPortNameserver(Nameserver):</span>
<span class="gi">+    def is_always_max_size(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def answer_nameserver(self) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def answer_port(self) -&gt; int:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def async_query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        backend: dns.asyncbackend.Backend,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gi">+</span>
<span class="gi">+class AddressAndPortNameserver(Nameserver):</span>
<span class="w"> </span>    def __init__(self, address: str, port: int):
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.address = address
<span class="w"> </span>        self.port = port

<span class="gi">+    def kind(self) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def is_always_max_size(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        ns_kind = self.kind()
<span class="gd">-        return f&#39;{ns_kind}:{self.address}@{self.port}&#39;</span>
<span class="gi">+        return f&quot;{ns_kind}:{self.address}@{self.port}&quot;</span>

<span class="gi">+    def answer_nameserver(self) -&gt; str:</span>
<span class="gi">+        return self.address</span>
<span class="gi">+</span>
<span class="gi">+    def answer_port(self) -&gt; int:</span>
<span class="gi">+        return self.port</span>

<span class="gd">-class Do53Nameserver(AddressAndPortNameserver):</span>

<span class="gd">-    def __init__(self, address: str, port: int=53):</span>
<span class="gi">+class Do53Nameserver(AddressAndPortNameserver):</span>
<span class="gi">+    def __init__(self, address: str, port: int = 53):</span>
<span class="w"> </span>        super().__init__(address, port)

<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;Do53&quot;</span>

<span class="gd">-class DoHNameserver(Nameserver):</span>
<span class="gi">+    def query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        if max_size:</span>
<span class="gi">+            response = dns.query.tcp(</span>
<span class="gi">+                request,</span>
<span class="gi">+                self.address,</span>
<span class="gi">+                timeout=timeout,</span>
<span class="gi">+                port=self.port,</span>
<span class="gi">+                source=source,</span>
<span class="gi">+                source_port=source_port,</span>
<span class="gi">+                one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                ignore_trailing=ignore_trailing,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = dns.query.udp(</span>
<span class="gi">+                request,</span>
<span class="gi">+                self.address,</span>
<span class="gi">+                timeout=timeout,</span>
<span class="gi">+                port=self.port,</span>
<span class="gi">+                source=source,</span>
<span class="gi">+                source_port=source_port,</span>
<span class="gi">+                raise_on_truncation=True,</span>
<span class="gi">+                one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                ignore_trailing=ignore_trailing,</span>
<span class="gi">+                ignore_errors=True,</span>
<span class="gi">+                ignore_unexpected=True,</span>
<span class="gi">+            )</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    async def async_query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        backend: dns.asyncbackend.Backend,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        if max_size:</span>
<span class="gi">+            response = await dns.asyncquery.tcp(</span>
<span class="gi">+                request,</span>
<span class="gi">+                self.address,</span>
<span class="gi">+                timeout=timeout,</span>
<span class="gi">+                port=self.port,</span>
<span class="gi">+                source=source,</span>
<span class="gi">+                source_port=source_port,</span>
<span class="gi">+                backend=backend,</span>
<span class="gi">+                one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                ignore_trailing=ignore_trailing,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            response = await dns.asyncquery.udp(</span>
<span class="gi">+                request,</span>
<span class="gi">+                self.address,</span>
<span class="gi">+                timeout=timeout,</span>
<span class="gi">+                port=self.port,</span>
<span class="gi">+                source=source,</span>
<span class="gi">+                source_port=source_port,</span>
<span class="gi">+                raise_on_truncation=True,</span>
<span class="gi">+                backend=backend,</span>
<span class="gi">+                one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                ignore_trailing=ignore_trailing,</span>
<span class="gi">+                ignore_errors=True,</span>
<span class="gi">+                ignore_unexpected=True,</span>
<span class="gi">+            )</span>
<span class="gi">+        return response</span>

<span class="gd">-    def __init__(self, url: str, bootstrap_address: Optional[str]=None,</span>
<span class="gd">-        verify: Union[bool, str]=True, want_get: bool=False):</span>
<span class="gi">+</span>
<span class="gi">+class DoHNameserver(Nameserver):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        url: str,</span>
<span class="gi">+        bootstrap_address: Optional[str] = None,</span>
<span class="gi">+        verify: Union[bool, str] = True,</span>
<span class="gi">+        want_get: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.url = url
<span class="w"> </span>        self.bootstrap_address = bootstrap_address
<span class="w"> </span>        self.verify = verify
<span class="w"> </span>        self.want_get = want_get

<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;DoH&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def is_always_max_size(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.url

<span class="gi">+    def answer_nameserver(self) -&gt; str:</span>
<span class="gi">+        return self.url</span>

<span class="gd">-class DoTNameserver(AddressAndPortNameserver):</span>
<span class="gi">+    def answer_port(self) -&gt; int:</span>
<span class="gi">+        port = urlparse(self.url).port</span>
<span class="gi">+        if port is None:</span>
<span class="gi">+            port = 443</span>
<span class="gi">+        return port</span>
<span class="gi">+</span>
<span class="gi">+    def query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool = False,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        return dns.query.https(</span>
<span class="gi">+            request,</span>
<span class="gi">+            self.url,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            source=source,</span>
<span class="gi">+            source_port=source_port,</span>
<span class="gi">+            bootstrap_address=self.bootstrap_address,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+            verify=self.verify,</span>
<span class="gi">+            post=(not self.want_get),</span>
<span class="gi">+        )</span>

<span class="gd">-    def __init__(self, address: str, port: int=853, hostname: Optional[str]</span>
<span class="gd">-        =None, verify: Union[bool, str]=True):</span>
<span class="gi">+    async def async_query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        backend: dns.asyncbackend.Backend,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        return await dns.asyncquery.https(</span>
<span class="gi">+            request,</span>
<span class="gi">+            self.url,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            source=source,</span>
<span class="gi">+            source_port=source_port,</span>
<span class="gi">+            bootstrap_address=self.bootstrap_address,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+            verify=self.verify,</span>
<span class="gi">+            post=(not self.want_get),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class DoTNameserver(AddressAndPortNameserver):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        address: str,</span>
<span class="gi">+        port: int = 853,</span>
<span class="gi">+        hostname: Optional[str] = None,</span>
<span class="gi">+        verify: Union[bool, str] = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(address, port)
<span class="w"> </span>        self.hostname = hostname
<span class="w"> </span>        self.verify = verify

<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;DoT&quot;</span>

<span class="gd">-class DoQNameserver(AddressAndPortNameserver):</span>
<span class="gi">+    def query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool = False,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        return dns.query.tls(</span>
<span class="gi">+            request,</span>
<span class="gi">+            self.address,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+            server_hostname=self.hostname,</span>
<span class="gi">+            verify=self.verify,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async def async_query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        backend: dns.asyncbackend.Backend,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        return await dns.asyncquery.tls(</span>
<span class="gi">+            request,</span>
<span class="gi">+            self.address,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+            server_hostname=self.hostname,</span>
<span class="gi">+            verify=self.verify,</span>
<span class="gi">+        )</span>

<span class="gd">-    def __init__(self, address: str, port: int=853, verify: Union[bool, str</span>
<span class="gd">-        ]=True, server_hostname: Optional[str]=None):</span>
<span class="gi">+</span>
<span class="gi">+class DoQNameserver(AddressAndPortNameserver):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        address: str,</span>
<span class="gi">+        port: int = 853,</span>
<span class="gi">+        verify: Union[bool, str] = True,</span>
<span class="gi">+        server_hostname: Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(address, port)
<span class="w"> </span>        self.verify = verify
<span class="w"> </span>        self.server_hostname = server_hostname
<span class="gi">+</span>
<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;DoQ&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool = False,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        return dns.query.quic(</span>
<span class="gi">+            request,</span>
<span class="gi">+            self.address,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+            verify=self.verify,</span>
<span class="gi">+            server_hostname=self.server_hostname,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    async def async_query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        request: dns.message.QueryMessage,</span>
<span class="gi">+        timeout: float,</span>
<span class="gi">+        source: Optional[str],</span>
<span class="gi">+        source_port: int,</span>
<span class="gi">+        max_size: bool,</span>
<span class="gi">+        backend: dns.asyncbackend.Backend,</span>
<span class="gi">+        one_rr_per_rrset: bool = False,</span>
<span class="gi">+        ignore_trailing: bool = False,</span>
<span class="gi">+    ) -&gt; dns.message.Message:</span>
<span class="gi">+        return await dns.asyncquery.quic(</span>
<span class="gi">+            request,</span>
<span class="gi">+            self.address,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing=ignore_trailing,</span>
<span class="gi">+            verify=self.verify,</span>
<span class="gi">+            server_hostname=self.server_hostname,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/dns/node.py b/dns/node.py</span>
<span class="gh">index 802f226..de85a82 100644</span>
<span class="gd">--- a/dns/node.py</span>
<span class="gi">+++ b/dns/node.py</span>
<span class="gu">@@ -1,7 +1,26 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS nodes.  A node is a set of rdatasets.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import enum
<span class="w"> </span>import io
<span class="w"> </span>from typing import Any, Dict, Optional
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.rdataclass
<span class="gu">@@ -9,17 +28,46 @@ import dns.rdataset</span>
<span class="w"> </span>import dns.rdatatype
<span class="w"> </span>import dns.renderer
<span class="w"> </span>import dns.rrset
<span class="gd">-_cname_types = {dns.rdatatype.CNAME}</span>
<span class="gd">-_neutral_types = {dns.rdatatype.NSEC, dns.rdatatype.NSEC3, dns.rdatatype.KEY}</span>
<span class="gi">+</span>
<span class="gi">+_cname_types = {</span>
<span class="gi">+    dns.rdatatype.CNAME,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# &quot;neutral&quot; types can coexist with a CNAME and thus are not &quot;other data&quot;</span>
<span class="gi">+_neutral_types = {</span>
<span class="gi">+    dns.rdatatype.NSEC,  # RFC 4035 section 2.5</span>
<span class="gi">+    dns.rdatatype.NSEC3,  # This is not likely to happen, but not impossible!</span>
<span class="gi">+    dns.rdatatype.KEY,  # RFC 4035 section 2.5, RFC 3007</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _matches_type_or_its_signature(rdtypes, rdtype, covers):</span>
<span class="gi">+    return rdtype in rdtypes or (rdtype == dns.rdatatype.RRSIG and covers in rdtypes)</span>


<span class="w"> </span>@enum.unique
<span class="w"> </span>class NodeKind(enum.Enum):
<span class="w"> </span>    &quot;&quot;&quot;Rdatasets in nodes&quot;&quot;&quot;
<span class="gd">-    REGULAR = 0</span>
<span class="gi">+</span>
<span class="gi">+    REGULAR = 0  # a.k.a &quot;other data&quot;</span>
<span class="w"> </span>    NEUTRAL = 1
<span class="w"> </span>    CNAME = 2

<span class="gi">+    @classmethod</span>
<span class="gi">+    def classify(</span>
<span class="gi">+        cls, rdtype: dns.rdatatype.RdataType, covers: dns.rdatatype.RdataType</span>
<span class="gi">+    ) -&gt; &quot;NodeKind&quot;:</span>
<span class="gi">+        if _matches_type_or_its_signature(_cname_types, rdtype, covers):</span>
<span class="gi">+            return NodeKind.CNAME</span>
<span class="gi">+        elif _matches_type_or_its_signature(_neutral_types, rdtype, covers):</span>
<span class="gi">+            return NodeKind.NEUTRAL</span>
<span class="gi">+        else:</span>
<span class="gi">+            return NodeKind.REGULAR</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def classify_rdataset(cls, rdataset: dns.rdataset.Rdataset) -&gt; &quot;NodeKind&quot;:</span>
<span class="gi">+        return cls.classify(rdataset.rdtype, rdataset.covers)</span>
<span class="gi">+</span>

<span class="w"> </span>class Node:
<span class="w"> </span>    &quot;&quot;&quot;A Node is a set of rdatasets.
<span class="gu">@@ -36,12 +84,14 @@ class Node:</span>
<span class="w"> </span>    an MX rdataset and add a CNAME rdataset, the MX rdataset will be
<span class="w"> </span>    deleted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;rdatasets&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;rdatasets&quot;]</span>

<span class="w"> </span>    def __init__(self):
<span class="gi">+        # the set of rdatasets, represented as a list.</span>
<span class="w"> </span>        self.rdatasets = []

<span class="gd">-    def to_text(self, name: dns.name.Name, **kw: Dict[str, Any]) -&gt;str:</span>
<span class="gi">+    def to_text(self, name: dns.name.Name, **kw: Dict[str, Any]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert a node to text format.

<span class="w"> </span>        Each rdataset at the node is printed.  Any keyword arguments
<span class="gu">@@ -53,12 +103,21 @@ class Node:</span>
<span class="w"> </span>        Returns a ``str``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        s = io.StringIO()</span>
<span class="gi">+        for rds in self.rdatasets:</span>
<span class="gi">+            if len(rds) &gt; 0:</span>
<span class="gi">+                s.write(rds.to_text(name, **kw))  # type: ignore[arg-type]</span>
<span class="gi">+                s.write(&quot;\n&quot;)</span>
<span class="gi">+        return s.getvalue()[:-1]</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;DNS node &#39; + str(id(self)) + &#39;&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;DNS node &quot; + str(id(self)) + &quot;&gt;&quot;</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gi">+        #</span>
<span class="gi">+        # This is inefficient.  Good thing we don&#39;t need to do it much.</span>
<span class="gi">+        #</span>
<span class="w"> </span>        for rd in self.rdatasets:
<span class="w"> </span>            if rd not in other.rdatasets:
<span class="w"> </span>                return False
<span class="gu">@@ -85,11 +144,32 @@ class Node:</span>
<span class="w"> </span>        RRSIGs are deleted.  If the rdataset being appended has
<span class="w"> </span>        ``NodeKind.REGULAR`` then CNAME and RRSIG(CNAME) are deleted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find_rdataset(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns</span>
<span class="gd">-        .rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.rdatatype</span>
<span class="gd">-        .NONE, create: bool=False) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+        # Make having just one rdataset at the node fast.</span>
<span class="gi">+        if len(self.rdatasets) &gt; 0:</span>
<span class="gi">+            kind = NodeKind.classify_rdataset(rdataset)</span>
<span class="gi">+            if kind == NodeKind.CNAME:</span>
<span class="gi">+                self.rdatasets = [</span>
<span class="gi">+                    rds</span>
<span class="gi">+                    for rds in self.rdatasets</span>
<span class="gi">+                    if NodeKind.classify_rdataset(rds) != NodeKind.REGULAR</span>
<span class="gi">+                ]</span>
<span class="gi">+            elif kind == NodeKind.REGULAR:</span>
<span class="gi">+                self.rdatasets = [</span>
<span class="gi">+                    rds</span>
<span class="gi">+                    for rds in self.rdatasets</span>
<span class="gi">+                    if NodeKind.classify_rdataset(rds) != NodeKind.CNAME</span>
<span class="gi">+                ]</span>
<span class="gi">+            # Otherwise the rdataset is NodeKind.NEUTRAL and we do not need to</span>
<span class="gi">+            # edit self.rdatasets.</span>
<span class="gi">+        self.rdatasets.append(rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def find_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find an rdataset matching the specified properties in the
<span class="w"> </span>        current node.

<span class="gu">@@ -114,11 +194,23 @@ class Node:</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_rdataset(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns.</span>
<span class="gd">-        rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.rdatatype.</span>
<span class="gd">-        NONE, create: bool=False) -&gt;Optional[dns.rdataset.Rdataset]:</span>
<span class="gi">+        for rds in self.rdatasets:</span>
<span class="gi">+            if rds.match(rdclass, rdtype, covers):</span>
<span class="gi">+                return rds</span>
<span class="gi">+        if not create:</span>
<span class="gi">+            raise KeyError</span>
<span class="gi">+        rds = dns.rdataset.Rdataset(rdclass, rdtype, covers)</span>
<span class="gi">+        self._append_rdataset(rds)</span>
<span class="gi">+        return rds</span>
<span class="gi">+</span>
<span class="gi">+    def get_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; Optional[dns.rdataset.Rdataset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get an rdataset matching the specified properties in the
<span class="w"> </span>        current node.

<span class="gu">@@ -142,11 +234,19 @@ class Node:</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def delete_rdataset(self, rdclass: dns.rdataclass.RdataClass, rdtype:</span>
<span class="gd">-        dns.rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.</span>
<span class="gd">-        rdatatype.NONE) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rds = self.find_rdataset(rdclass, rdtype, covers, create)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            rds = None</span>
<span class="gi">+        return rds</span>
<span class="gi">+</span>
<span class="gi">+    def delete_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete the rdataset matching the specified properties in the
<span class="w"> </span>        current node.

<span class="gu">@@ -158,9 +258,12 @@ class Node:</span>

<span class="w"> </span>        *covers*, an ``int``, the covered type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -&gt;None:</span>
<span class="gi">+        rds = self.get_rdataset(rdclass, rdtype, covers)</span>
<span class="gi">+        if rds is not None:</span>
<span class="gi">+            self.rdatasets.remove(rds)</span>
<span class="gi">+</span>
<span class="gi">+    def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace an rdataset.

<span class="w"> </span>        It is not an error if there is no rdataset matching *replacement*.
<span class="gu">@@ -174,9 +277,19 @@ class Node:</span>
<span class="w"> </span>        Raises ``ValueError`` if *replacement* is not a
<span class="w"> </span>        ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def classify(self) -&gt;NodeKind:</span>
<span class="gi">+        if not isinstance(replacement, dns.rdataset.Rdataset):</span>
<span class="gi">+            raise ValueError(&quot;replacement is not an rdataset&quot;)</span>
<span class="gi">+        if isinstance(replacement, dns.rrset.RRset):</span>
<span class="gi">+            # RRsets are not good replacements as the match() method</span>
<span class="gi">+            # is not compatible.</span>
<span class="gi">+            replacement = replacement.to_rdataset()</span>
<span class="gi">+        self.delete_rdataset(</span>
<span class="gi">+            replacement.rdclass, replacement.rdtype, replacement.covers</span>
<span class="gi">+        )</span>
<span class="gi">+        self._append_rdataset(replacement)</span>
<span class="gi">+</span>
<span class="gi">+    def classify(self) -&gt; NodeKind:</span>
<span class="w"> </span>        &quot;&quot;&quot;Classify a node.

<span class="w"> </span>        A node which contains a CNAME or RRSIG(CNAME) is a
<span class="gu">@@ -191,13 +304,56 @@ class Node:</span>
<span class="w"> </span>        or a neutral type is a a ``NodeKind.REGULAR`` node.  Regular nodes are
<span class="w"> </span>        also commonly referred to as &quot;other data&quot;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rdataset in self.rdatasets:</span>
<span class="gi">+            kind = NodeKind.classify(rdataset.rdtype, rdataset.covers)</span>
<span class="gi">+            if kind != NodeKind.NEUTRAL:</span>
<span class="gi">+                return kind</span>
<span class="gi">+        return NodeKind.NEUTRAL</span>
<span class="gi">+</span>
<span class="gi">+    def is_immutable(self) -&gt; bool:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ImmutableNode(Node):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, node):
<span class="w"> </span>        super().__init__()
<span class="gd">-        self.rdatasets = tuple([dns.rdataset.ImmutableRdataset(rds) for rds in</span>
<span class="gd">-            node.rdatasets])</span>
<span class="gi">+        self.rdatasets = tuple(</span>
<span class="gi">+            [dns.rdataset.ImmutableRdataset(rds) for rds in node.rdatasets]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def find_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; dns.rdataset.Rdataset:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+        return super().find_rdataset(rdclass, rdtype, covers, False)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; Optional[dns.rdataset.Rdataset]:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+        return super().get_rdataset(rdclass, rdtype, covers, False)</span>
<span class="gi">+</span>
<span class="gi">+    def delete_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -&gt; None:</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def is_immutable(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/dns/opcode.py b/dns/opcode.py</span>
<span class="gh">index dfea1ae..78b43d2 100644</span>
<span class="gd">--- a/dns/opcode.py</span>
<span class="gi">+++ b/dns/opcode.py</span>
<span class="gu">@@ -1,21 +1,52 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Opcodes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.exception


<span class="w"> </span>class Opcode(dns.enum.IntEnum):
<span class="gi">+    #: Query</span>
<span class="w"> </span>    QUERY = 0
<span class="gi">+    #: Inverse Query (historical)</span>
<span class="w"> </span>    IQUERY = 1
<span class="gi">+    #: Server Status (unspecified and unimplemented anywhere)</span>
<span class="w"> </span>    STATUS = 2
<span class="gi">+    #: Notify</span>
<span class="w"> </span>    NOTIFY = 4
<span class="gi">+    #: Dynamic Update</span>
<span class="w"> </span>    UPDATE = 5

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 15</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _unknown_exception_class(cls):</span>
<span class="gi">+        return UnknownOpcode</span>
<span class="gi">+</span>

<span class="w"> </span>class UnknownOpcode(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;An DNS opcode is unknown.&quot;&quot;&quot;


<span class="gd">-def from_text(text: str) -&gt;Opcode:</span>
<span class="gi">+def from_text(text: str) -&gt; Opcode:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert text into an opcode.

<span class="w"> </span>    *text*, a ``str``, the textual opcode
<span class="gu">@@ -24,20 +55,22 @@ def from_text(text: str) -&gt;Opcode:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return Opcode.from_text(text)</span>


<span class="gd">-def from_flags(flags: int) -&gt;Opcode:</span>
<span class="gi">+def from_flags(flags: int) -&gt; Opcode:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract an opcode from DNS message flags.

<span class="w"> </span>    *flags*, an ``int``, the DNS flags.

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return Opcode((flags &amp; 0x7800) &gt;&gt; 11)</span>


<span class="gd">-def to_flags(value: Opcode) -&gt;int:</span>
<span class="gi">+def to_flags(value: Opcode) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an opcode to a value suitable for ORing into DNS message
<span class="w"> </span>    flags.

<span class="gu">@@ -45,10 +78,11 @@ def to_flags(value: Opcode) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return (value &lt;&lt; 11) &amp; 0x7800</span>

<span class="gd">-def to_text(value: Opcode) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def to_text(value: Opcode) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an opcode to text.

<span class="w"> </span>    *value*, an ``int`` the opcode value,
<span class="gu">@@ -57,21 +91,27 @@ def to_text(value: Opcode) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return Opcode.to_text(value)</span>


<span class="gd">-def is_update(flags: int) -&gt;bool:</span>
<span class="gi">+def is_update(flags: int) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the opcode in flags UPDATE?

<span class="w"> </span>    *flags*, an ``int``, the DNS message flags.

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return from_flags(flags) == Opcode.UPDATE</span>


<span class="gi">+### BEGIN generated Opcode constants</span>
<span class="gi">+</span>
<span class="w"> </span>QUERY = Opcode.QUERY
<span class="w"> </span>IQUERY = Opcode.IQUERY
<span class="w"> </span>STATUS = Opcode.STATUS
<span class="w"> </span>NOTIFY = Opcode.NOTIFY
<span class="w"> </span>UPDATE = Opcode.UPDATE
<span class="gi">+</span>
<span class="gi">+### END generated Opcode constants</span>
<span class="gh">diff --git a/dns/query.py b/dns/query.py</span>
<span class="gh">index 2ec4b4f..f0ee916 100644</span>
<span class="gd">--- a/dns/query.py</span>
<span class="gi">+++ b/dns/query.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Talk to a DNS server.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import contextlib
<span class="w"> </span>import enum
<span class="gu">@@ -10,6 +28,7 @@ import socket</span>
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="w"> </span>from typing import Any, Dict, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns._features
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="gu">@@ -23,16 +42,32 @@ import dns.serial</span>
<span class="w"> </span>import dns.transaction
<span class="w"> </span>import dns.tsig
<span class="w"> </span>import dns.xfr
<span class="gd">-_have_httpx = dns._features.have(&#39;doh&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remaining(expiration):</span>
<span class="gi">+    if expiration is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    timeout = expiration - time.time()</span>
<span class="gi">+    if timeout &lt;= 0.0:</span>
<span class="gi">+        raise dns.exception.Timeout</span>
<span class="gi">+    return timeout</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _expiration_for_this_attempt(timeout, expiration):</span>
<span class="gi">+    if expiration is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return min(time.time() + timeout, expiration)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_have_httpx = dns._features.have(&quot;doh&quot;)</span>
<span class="w"> </span>if _have_httpx:
<span class="w"> </span>    import httpcore._backends.sync
<span class="w"> </span>    import httpx
<span class="gi">+</span>
<span class="w"> </span>    _CoreNetworkBackend = httpcore.NetworkBackend
<span class="w"> </span>    _CoreSyncStream = httpcore._backends.sync.SyncStream

<span class="gd">-</span>
<span class="w"> </span>    class _NetworkBackend(_CoreNetworkBackend):
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self, resolver, local_port, bootstrap_address, family):
<span class="w"> </span>            super().__init__()
<span class="w"> </span>            self._local_port = local_port
<span class="gu">@@ -40,46 +75,105 @@ if _have_httpx:</span>
<span class="w"> </span>            self._bootstrap_address = bootstrap_address
<span class="w"> </span>            self._family = family

<span class="gi">+        def connect_tcp(</span>
<span class="gi">+            self, host, port, timeout, local_address, socket_options=None</span>
<span class="gi">+        ):  # pylint: disable=signature-differs</span>
<span class="gi">+            addresses = []</span>
<span class="gi">+            _, expiration = _compute_times(timeout)</span>
<span class="gi">+            if dns.inet.is_address(host):</span>
<span class="gi">+                addresses.append(host)</span>
<span class="gi">+            elif self._bootstrap_address is not None:</span>
<span class="gi">+                addresses.append(self._bootstrap_address)</span>
<span class="gi">+            else:</span>
<span class="gi">+                timeout = _remaining(expiration)</span>
<span class="gi">+                family = self._family</span>
<span class="gi">+                if local_address:</span>
<span class="gi">+                    family = dns.inet.af_for_address(local_address)</span>
<span class="gi">+                answers = self._resolver.resolve_name(</span>
<span class="gi">+                    host, family=family, lifetime=timeout</span>
<span class="gi">+                )</span>
<span class="gi">+                addresses = answers.addresses()</span>
<span class="gi">+            for address in addresses:</span>
<span class="gi">+                af = dns.inet.af_for_address(address)</span>
<span class="gi">+                if local_address is not None or self._local_port != 0:</span>
<span class="gi">+                    source = dns.inet.low_level_address_tuple(</span>
<span class="gi">+                        (local_address, self._local_port), af</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    source = None</span>
<span class="gi">+                sock = _make_socket(af, socket.SOCK_STREAM, source)</span>
<span class="gi">+                attempt_expiration = _expiration_for_this_attempt(2.0, expiration)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    _connect(</span>
<span class="gi">+                        sock,</span>
<span class="gi">+                        dns.inet.low_level_address_tuple((address, port), af),</span>
<span class="gi">+                        attempt_expiration,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return _CoreSyncStream(sock)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            raise httpcore.ConnectError</span>
<span class="gi">+</span>
<span class="gi">+        def connect_unix_socket(</span>
<span class="gi">+            self, path, timeout, socket_options=None</span>
<span class="gi">+        ):  # pylint: disable=signature-differs</span>
<span class="gi">+            raise NotImplementedError</span>

<span class="w"> </span>    class _HTTPTransport(httpx.HTTPTransport):
<span class="gd">-</span>
<span class="gd">-        def __init__(self, *args, local_port=0, bootstrap_address=None,</span>
<span class="gd">-            resolver=None, family=socket.AF_UNSPEC, **kwargs):</span>
<span class="gi">+        def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            local_port=0,</span>
<span class="gi">+            bootstrap_address=None,</span>
<span class="gi">+            resolver=None,</span>
<span class="gi">+            family=socket.AF_UNSPEC,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            if resolver is None:
<span class="gi">+                # pylint: disable=import-outside-toplevel,redefined-outer-name</span>
<span class="w"> </span>                import dns.resolver
<span class="gi">+</span>
<span class="w"> </span>                resolver = dns.resolver.Resolver()
<span class="w"> </span>            super().__init__(*args, **kwargs)
<span class="gd">-            self._pool._network_backend = _NetworkBackend(resolver,</span>
<span class="gd">-                local_port, bootstrap_address, family)</span>
<span class="gi">+            self._pool._network_backend = _NetworkBackend(</span>
<span class="gi">+                resolver, local_port, bootstrap_address, family</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>else:

<span class="gi">+    class _HTTPTransport:  # type: ignore</span>
<span class="gi">+        def connect_tcp(self, host, port, timeout, local_address):</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>

<span class="gd">-    class _HTTPTransport:</span>
<span class="gd">-        pass</span>
<span class="w"> </span>have_doh = _have_httpx
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import ssl
<span class="gd">-except ImportError:</span>
<span class="gd">-</span>
<span class="gi">+except ImportError:  # pragma: no cover</span>

<span class="gd">-    class ssl:</span>
<span class="gi">+    class ssl:  # type: ignore</span>
<span class="w"> </span>        CERT_NONE = 0

<span class="gd">-</span>
<span class="w"> </span>        class WantReadException(Exception):
<span class="w"> </span>            pass

<span class="gd">-</span>
<span class="w"> </span>        class WantWriteException(Exception):
<span class="w"> </span>            pass

<span class="gd">-</span>
<span class="w"> </span>        class SSLContext:
<span class="w"> </span>            pass

<span class="gd">-</span>
<span class="w"> </span>        class SSLSocket:
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="gi">+        @classmethod</span>
<span class="gi">+        def create_default_context(cls, *args, **kwargs):</span>
<span class="gi">+            raise Exception(&quot;no ssl support&quot;)  # pylint: disable=broad-exception-raised</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Function used to create a socket.  Can be overridden if needed in special</span>
<span class="gi">+# situations.</span>
<span class="w"> </span>socket_factory = socket.socket


<span class="gu">@@ -101,20 +195,183 @@ class NoDOQ(dns.exception.DNSException):</span>
<span class="w"> </span>    available.&quot;&quot;&quot;


<span class="gi">+# for backwards compatibility</span>
<span class="w"> </span>TransferError = dns.xfr.TransferError
<span class="gd">-if hasattr(selectors, &#39;PollSelector&#39;):</span>
<span class="gd">-    _selector_class = selectors.PollSelector</span>
<span class="gd">-else:</span>
<span class="gd">-    _selector_class = selectors.SelectSelector</span>


<span class="gd">-def https(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>
<span class="gd">-    port: int=443, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, session:</span>
<span class="gd">-    Optional[Any]=None, path: str=&#39;/dns-query&#39;, post: bool=True,</span>
<span class="gd">-    bootstrap_address: Optional[str]=None, verify: Union[bool, str]=True,</span>
<span class="gd">-    resolver: Optional[&#39;dns.resolver.Resolver&#39;]=None, family: Optional[int]</span>
<span class="gd">-    =socket.AF_UNSPEC) -&gt;dns.message.Message:</span>
<span class="gi">+def _compute_times(timeout):</span>
<span class="gi">+    now = time.time()</span>
<span class="gi">+    if timeout is None:</span>
<span class="gi">+        return (now, None)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (now, now + timeout)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _wait_for(fd, readable, writable, _, expiration):</span>
<span class="gi">+    # Use the selected selector class to wait for any of the specified</span>
<span class="gi">+    # events.  An &quot;expiration&quot; absolute time is converted into a relative</span>
<span class="gi">+    # timeout.</span>
<span class="gi">+    #</span>
<span class="gi">+    # The unused parameter is &#39;error&#39;, which is always set when</span>
<span class="gi">+    # selecting for read or write, and we have no error-only selects.</span>
<span class="gi">+</span>
<span class="gi">+    if readable and isinstance(fd, ssl.SSLSocket) and fd.pending() &gt; 0:</span>
<span class="gi">+        return True</span>
<span class="gi">+    sel = _selector_class()</span>
<span class="gi">+    events = 0</span>
<span class="gi">+    if readable:</span>
<span class="gi">+        events |= selectors.EVENT_READ</span>
<span class="gi">+    if writable:</span>
<span class="gi">+        events |= selectors.EVENT_WRITE</span>
<span class="gi">+    if events:</span>
<span class="gi">+        sel.register(fd, events)</span>
<span class="gi">+    if expiration is None:</span>
<span class="gi">+        timeout = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        timeout = expiration - time.time()</span>
<span class="gi">+        if timeout &lt;= 0.0:</span>
<span class="gi">+            raise dns.exception.Timeout</span>
<span class="gi">+    if not sel.select(timeout):</span>
<span class="gi">+        raise dns.exception.Timeout</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_selector_class(selector_class):</span>
<span class="gi">+    # Internal API. Do not use.</span>
<span class="gi">+</span>
<span class="gi">+    global _selector_class</span>
<span class="gi">+</span>
<span class="gi">+    _selector_class = selector_class</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if hasattr(selectors, &quot;PollSelector&quot;):</span>
<span class="gi">+    # Prefer poll() on platforms that support it because it has no</span>
<span class="gi">+    # limits on the maximum value of a file descriptor (plus it will</span>
<span class="gi">+    # be more efficient for high values).</span>
<span class="gi">+    #</span>
<span class="gi">+    # We ignore typing here as we can&#39;t say _selector_class is Any</span>
<span class="gi">+    # on python &lt; 3.8 due to a bug.</span>
<span class="gi">+    _selector_class = selectors.PollSelector  # type: ignore</span>
<span class="gi">+else:</span>
<span class="gi">+    _selector_class = selectors.SelectSelector  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _wait_for_readable(s, expiration):</span>
<span class="gi">+    _wait_for(s, True, False, True, expiration)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _wait_for_writable(s, expiration):</span>
<span class="gi">+    _wait_for(s, False, True, True, expiration)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _addresses_equal(af, a1, a2):</span>
<span class="gi">+    # Convert the first value of the tuple, which is a textual format</span>
<span class="gi">+    # address into binary form, so that we are not confused by different</span>
<span class="gi">+    # textual representations of the same address</span>
<span class="gi">+    try:</span>
<span class="gi">+        n1 = dns.inet.inet_pton(af, a1[0])</span>
<span class="gi">+        n2 = dns.inet.inet_pton(af, a2[0])</span>
<span class="gi">+    except dns.exception.SyntaxError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return n1 == n2 and a1[1:] == a2[1:]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _matches_destination(af, from_address, destination, ignore_unexpected):</span>
<span class="gi">+    # Check that from_address is appropriate for a response to a query</span>
<span class="gi">+    # sent to destination.</span>
<span class="gi">+    if not destination:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if _addresses_equal(af, from_address, destination) or (</span>
<span class="gi">+        dns.inet.is_multicast(destination[0]) and from_address[1:] == destination[1:]</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif ignore_unexpected:</span>
<span class="gi">+        return False</span>
<span class="gi">+    raise UnexpectedSource(</span>
<span class="gi">+        f&quot;got a response from {from_address} instead of &quot; f&quot;{destination}&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _destination_and_source(</span>
<span class="gi">+    where, port, source, source_port, where_must_be_address=True</span>
<span class="gi">+):</span>
<span class="gi">+    # Apply defaults and compute destination and source tuples</span>
<span class="gi">+    # suitable for use in connect(), sendto(), or bind().</span>
<span class="gi">+    af = None</span>
<span class="gi">+    destination = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        af = dns.inet.af_for_address(where)</span>
<span class="gi">+        destination = where</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        if where_must_be_address:</span>
<span class="gi">+            raise</span>
<span class="gi">+        # URLs are ok so eat the exception</span>
<span class="gi">+    if source:</span>
<span class="gi">+        saf = dns.inet.af_for_address(source)</span>
<span class="gi">+        if af:</span>
<span class="gi">+            # We know the destination af, so source had better agree!</span>
<span class="gi">+            if saf != af:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;different address families for source and destination&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # We didn&#39;t know the destination af, but we know the source,</span>
<span class="gi">+            # so that&#39;s our af.</span>
<span class="gi">+            af = saf</span>
<span class="gi">+    if source_port and not source:</span>
<span class="gi">+        # Caller has specified a source_port but not an address, so we</span>
<span class="gi">+        # need to return a source, and we need to use the appropriate</span>
<span class="gi">+        # wildcard address as the address.</span>
<span class="gi">+        try:</span>
<span class="gi">+            source = dns.inet.any_for_af(af)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # we catch this and raise ValueError for backwards compatibility</span>
<span class="gi">+            raise ValueError(&quot;source_port specified but address family is unknown&quot;)</span>
<span class="gi">+    # Convert high-level (address, port) tuples into low-level address</span>
<span class="gi">+    # tuples.</span>
<span class="gi">+    if destination:</span>
<span class="gi">+        destination = dns.inet.low_level_address_tuple((destination, port), af)</span>
<span class="gi">+    if source:</span>
<span class="gi">+        source = dns.inet.low_level_address_tuple((source, source_port), af)</span>
<span class="gi">+    return (af, destination, source)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_socket(af, type, source, ssl_context=None, server_hostname=None):</span>
<span class="gi">+    s = socket_factory(af, type)</span>
<span class="gi">+    try:</span>
<span class="gi">+        s.setblocking(False)</span>
<span class="gi">+        if source is not None:</span>
<span class="gi">+            s.bind(source)</span>
<span class="gi">+        if ssl_context:</span>
<span class="gi">+            # LGTM gets a false positive here, as our default context is OK</span>
<span class="gi">+            return ssl_context.wrap_socket(</span>
<span class="gi">+                s,</span>
<span class="gi">+                do_handshake_on_connect=False,  # lgtm[py/insecure-protocol]</span>
<span class="gi">+                server_hostname=server_hostname,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return s</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        s.close()</span>
<span class="gi">+        raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def https(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 443,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    session: Optional[Any] = None,</span>
<span class="gi">+    path: str = &quot;/dns-query&quot;,</span>
<span class="gi">+    post: bool = True,</span>
<span class="gi">+    bootstrap_address: Optional[str] = None,</span>
<span class="gi">+    verify: Union[bool, str] = True,</span>
<span class="gi">+    resolver: Optional[&quot;dns.resolver.Resolver&quot;] = None,</span>
<span class="gi">+    family: Optional[int] = socket.AF_UNSPEC,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via DNS-over-HTTPS.

<span class="w"> </span>    *q*, a ``dns.message.Message``, the query to send.
<span class="gu">@@ -165,7 +422,85 @@ def https(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not have_doh:</span>
<span class="gi">+        raise NoDOH  # pragma: no cover</span>
<span class="gi">+    if session and not isinstance(session, httpx.Client):</span>
<span class="gi">+        raise ValueError(&quot;session parameter must be an httpx.Client&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (af, _, the_source) = _destination_and_source(</span>
<span class="gi">+        where, port, source, source_port, False</span>
<span class="gi">+    )</span>
<span class="gi">+    transport = None</span>
<span class="gi">+    headers = {&quot;accept&quot;: &quot;application/dns-message&quot;}</span>
<span class="gi">+    if af is not None and dns.inet.is_address(where):</span>
<span class="gi">+        if af == socket.AF_INET:</span>
<span class="gi">+            url = &quot;https://{}:{}{}&quot;.format(where, port, path)</span>
<span class="gi">+        elif af == socket.AF_INET6:</span>
<span class="gi">+            url = &quot;https://[{}]:{}{}&quot;.format(where, port, path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        url = where</span>
<span class="gi">+</span>
<span class="gi">+    # set source port and source address</span>
<span class="gi">+</span>
<span class="gi">+    if the_source is None:</span>
<span class="gi">+        local_address = None</span>
<span class="gi">+        local_port = 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        local_address = the_source[0]</span>
<span class="gi">+        local_port = the_source[1]</span>
<span class="gi">+    transport = _HTTPTransport(</span>
<span class="gi">+        local_address=local_address,</span>
<span class="gi">+        http1=True,</span>
<span class="gi">+        http2=True,</span>
<span class="gi">+        verify=verify,</span>
<span class="gi">+        local_port=local_port,</span>
<span class="gi">+        bootstrap_address=bootstrap_address,</span>
<span class="gi">+        resolver=resolver,</span>
<span class="gi">+        family=family,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if session:</span>
<span class="gi">+        cm: contextlib.AbstractContextManager = contextlib.nullcontext(session)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = httpx.Client(http1=True, http2=True, verify=verify, transport=transport)</span>
<span class="gi">+    with cm as session:</span>
<span class="gi">+        # see https://tools.ietf.org/html/rfc8484#section-4.1.1 for DoH</span>
<span class="gi">+        # GET and POST examples</span>
<span class="gi">+        if post:</span>
<span class="gi">+            headers.update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    &quot;content-type&quot;: &quot;application/dns-message&quot;,</span>
<span class="gi">+                    &quot;content-length&quot;: str(len(wire)),</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+            response = session.post(url, headers=headers, content=wire, timeout=timeout)</span>
<span class="gi">+        else:</span>
<span class="gi">+            wire = base64.urlsafe_b64encode(wire).rstrip(b&quot;=&quot;)</span>
<span class="gi">+            twire = wire.decode()  # httpx does a repr() if we give it bytes</span>
<span class="gi">+            response = session.get(</span>
<span class="gi">+                url, headers=headers, timeout=timeout, params={&quot;dns&quot;: twire}</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # see https://tools.ietf.org/html/rfc8484#section-4.2.1 for info about DoH</span>
<span class="gi">+    # status codes</span>
<span class="gi">+    if response.status_code &lt; 200 or response.status_code &gt; 299:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;{} responded with status code {}&quot;</span>
<span class="gi">+            &quot;\nResponse body: {}&quot;.format(where, response.status_code, response.content)</span>
<span class="gi">+        )</span>
<span class="gi">+    r = dns.message.from_wire(</span>
<span class="gi">+        response.content,</span>
<span class="gi">+        keyring=q.keyring,</span>
<span class="gi">+        request_mac=q.request_mac,</span>
<span class="gi">+        one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+        ignore_trailing=ignore_trailing,</span>
<span class="gi">+    )</span>
<span class="gi">+    r.time = response.elapsed.total_seconds()</span>
<span class="gi">+    if not q.is_response(r):</span>
<span class="gi">+        raise BadResponse</span>
<span class="gi">+    return r</span>


<span class="w"> </span>def _udp_recv(sock, max_size, expiration):
<span class="gu">@@ -173,7 +508,11 @@ def _udp_recv(sock, max_size, expiration):</span>
<span class="w"> </span>    A Timeout exception will be raised if the operation is not completed
<span class="w"> </span>    by the expiration time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return sock.recvfrom(max_size)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            _wait_for_readable(sock, expiration)</span>


<span class="w"> </span>def _udp_send(sock, data, destination, expiration):
<span class="gu">@@ -181,11 +520,22 @@ def _udp_send(sock, data, destination, expiration):</span>
<span class="w"> </span>    A Timeout exception will be raised if the operation is not completed
<span class="w"> </span>    by the expiration time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def send_udp(sock: Any, what: Union[dns.message.Message, bytes],</span>
<span class="gd">-    destination: Any, expiration: Optional[float]=None) -&gt;Tuple[int, float]:</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if destination:</span>
<span class="gi">+                return sock.sendto(data, destination)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return sock.send(data)</span>
<span class="gi">+        except BlockingIOError:  # pragma: no cover</span>
<span class="gi">+            _wait_for_writable(sock, expiration)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def send_udp(</span>
<span class="gi">+    sock: Any,</span>
<span class="gi">+    what: Union[dns.message.Message, bytes],</span>
<span class="gi">+    destination: Any,</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+) -&gt; Tuple[int, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Send a DNS message to the specified UDP socket.

<span class="w"> </span>    *sock*, a ``socket``.
<span class="gu">@@ -201,15 +551,27 @@ def send_udp(sock: Any, what: Union[dns.message.Message, bytes],</span>

<span class="w"> </span>    Returns an ``(int, float)`` tuple of bytes sent and the sent time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def receive_udp(sock: Any, destination: Optional[Any]=None, expiration:</span>
<span class="gd">-    Optional[float]=None, ignore_unexpected: bool=False, one_rr_per_rrset:</span>
<span class="gd">-    bool=False, keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]]=None,</span>
<span class="gd">-    request_mac: Optional[bytes]=b&#39;&#39;, ignore_trailing: bool=False,</span>
<span class="gd">-    raise_on_truncation: bool=False, ignore_errors: bool=False, query:</span>
<span class="gd">-    Optional[dns.message.Message]=None) -&gt;Any:</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        what = what.to_wire()</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    n = _udp_send(sock, what, destination, expiration)</span>
<span class="gi">+    return (n, sent_time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def receive_udp(</span>
<span class="gi">+    sock: Any,</span>
<span class="gi">+    destination: Optional[Any] = None,</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+    ignore_unexpected: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,</span>
<span class="gi">+    request_mac: Optional[bytes] = b&quot;&quot;,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    raise_on_truncation: bool = False,</span>
<span class="gi">+    ignore_errors: bool = False,</span>
<span class="gi">+    query: Optional[dns.message.Message] = None,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a DNS message from a UDP socket.

<span class="w"> </span>    *sock*, a ``socket``.
<span class="gu">@@ -258,14 +620,65 @@ def receive_udp(sock: Any, destination: Optional[Any]=None, expiration:</span>
<span class="w"> </span>    *ignore_errors* is ``True``, check that the received message is a response
<span class="w"> </span>    to this query, and if not keep listening for a valid response.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def udp(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>
<span class="gd">-    port: int=53, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    ignore_unexpected: bool=False, one_rr_per_rrset: bool=False,</span>
<span class="gd">-    ignore_trailing: bool=False, raise_on_truncation: bool=False, sock:</span>
<span class="gd">-    Optional[Any]=None, ignore_errors: bool=False) -&gt;dns.message.Message:</span>
<span class="gi">+    wire = b&quot;&quot;</span>
<span class="gi">+    while True:</span>
<span class="gi">+        (wire, from_address) = _udp_recv(sock, 65535, expiration)</span>
<span class="gi">+        if not _matches_destination(</span>
<span class="gi">+            sock.family, from_address, destination, ignore_unexpected</span>
<span class="gi">+        ):</span>
<span class="gi">+            continue</span>
<span class="gi">+        received_time = time.time()</span>
<span class="gi">+        try:</span>
<span class="gi">+            r = dns.message.from_wire(</span>
<span class="gi">+                wire,</span>
<span class="gi">+                keyring=keyring,</span>
<span class="gi">+                request_mac=request_mac,</span>
<span class="gi">+                one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                ignore_trailing=ignore_trailing,</span>
<span class="gi">+                raise_on_truncation=raise_on_truncation,</span>
<span class="gi">+            )</span>
<span class="gi">+        except dns.message.Truncated as e:</span>
<span class="gi">+            # If we got Truncated and not FORMERR, we at least got the header with TC</span>
<span class="gi">+            # set, and very likely the question section, so we&#39;ll re-raise if the</span>
<span class="gi">+            # message seems to be a response as we need to know when truncation happens.</span>
<span class="gi">+            # We need to check that it seems to be a response as we don&#39;t want a random</span>
<span class="gi">+            # injected message with TC set to cause us to bail out.</span>
<span class="gi">+            if (</span>
<span class="gi">+                ignore_errors</span>
<span class="gi">+                and query is not None</span>
<span class="gi">+                and not query.is_response(e.message())</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if ignore_errors:</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+        if ignore_errors and query is not None and not query.is_response(r):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if destination:</span>
<span class="gi">+            return (r, received_time)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (r, received_time, from_address)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def udp(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    ignore_unexpected: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    raise_on_truncation: bool = False,</span>
<span class="gi">+    sock: Optional[Any] = None,</span>
<span class="gi">+    ignore_errors: bool = False,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via UDP.

<span class="w"> </span>    *q*, a ``dns.message.Message``, the query to send
<span class="gu">@@ -307,15 +720,56 @@ def udp(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def udp_with_fallback(q: dns.message.Message, where: str, timeout: Optional</span>
<span class="gd">-    [float]=None, port: int=53, source: Optional[str]=None, source_port:</span>
<span class="gd">-    int=0, ignore_unexpected: bool=False, one_rr_per_rrset: bool=False,</span>
<span class="gd">-    ignore_trailing: bool=False, udp_sock: Optional[Any]=None, tcp_sock:</span>
<span class="gd">-    Optional[Any]=None, ignore_errors: bool=False) -&gt;Tuple[dns.message.</span>
<span class="gd">-    Message, bool]:</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (af, destination, source) = _destination_and_source(</span>
<span class="gi">+        where, port, source, source_port</span>
<span class="gi">+    )</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        cm: contextlib.AbstractContextManager = contextlib.nullcontext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = _make_socket(af, socket.SOCK_DGRAM, source)</span>
<span class="gi">+    with cm as s:</span>
<span class="gi">+        send_udp(s, wire, destination, expiration)</span>
<span class="gi">+        (r, received_time) = receive_udp(</span>
<span class="gi">+            s,</span>
<span class="gi">+            destination,</span>
<span class="gi">+            expiration,</span>
<span class="gi">+            ignore_unexpected,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            q.keyring,</span>
<span class="gi">+            q.mac,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            raise_on_truncation,</span>
<span class="gi">+            ignore_errors,</span>
<span class="gi">+            q,</span>
<span class="gi">+        )</span>
<span class="gi">+        r.time = received_time - begin_time</span>
<span class="gi">+        # We don&#39;t need to check q.is_response() if we are in ignore_errors mode</span>
<span class="gi">+        # as receive_udp() will have checked it.</span>
<span class="gi">+        if not (ignore_errors or q.is_response(r)):</span>
<span class="gi">+            raise BadResponse</span>
<span class="gi">+        return r</span>
<span class="gi">+    assert (</span>
<span class="gi">+        False  # help mypy figure out we can&#39;t get here  lgtm[py/unreachable-statement]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def udp_with_fallback(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    ignore_unexpected: bool = False,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    udp_sock: Optional[Any] = None,</span>
<span class="gi">+    tcp_sock: Optional[Any] = None,</span>
<span class="gi">+    ignore_errors: bool = False,</span>
<span class="gi">+) -&gt; Tuple[dns.message.Message, bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response to the query, trying UDP first and falling back
<span class="w"> </span>    to TCP if UDP results in a truncated response.

<span class="gu">@@ -359,7 +813,35 @@ def udp_with_fallback(q: dns.message.Message, where: str, timeout: Optional</span>
<span class="w"> </span>    Returns a (``dns.message.Message``, tcp) tuple where tcp is ``True`` if and only if
<span class="w"> </span>    TCP was used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        response = udp(</span>
<span class="gi">+            q,</span>
<span class="gi">+            where,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            port,</span>
<span class="gi">+            source,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            ignore_unexpected,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            True,</span>
<span class="gi">+            udp_sock,</span>
<span class="gi">+            ignore_errors,</span>
<span class="gi">+        )</span>
<span class="gi">+        return (response, False)</span>
<span class="gi">+    except dns.message.Truncated:</span>
<span class="gi">+        response = tcp(</span>
<span class="gi">+            q,</span>
<span class="gi">+            where,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            port,</span>
<span class="gi">+            source,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            tcp_sock,</span>
<span class="gi">+        )</span>
<span class="gi">+        return (response, True)</span>


<span class="w"> </span>def _net_read(sock, count, expiration):
<span class="gu">@@ -368,7 +850,19 @@ def _net_read(sock, count, expiration):</span>
<span class="w"> </span>    A Timeout exception will be raised if the operation is not completed
<span class="w"> </span>    by the expiration time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s = b&quot;&quot;</span>
<span class="gi">+    while count &gt; 0:</span>
<span class="gi">+        try:</span>
<span class="gi">+            n = sock.recv(count)</span>
<span class="gi">+            if n == b&quot;&quot;:</span>
<span class="gi">+                raise EOFError</span>
<span class="gi">+            count -= len(n)</span>
<span class="gi">+            s += n</span>
<span class="gi">+        except (BlockingIOError, ssl.SSLWantReadError):</span>
<span class="gi">+            _wait_for_readable(sock, expiration)</span>
<span class="gi">+        except ssl.SSLWantWriteError:  # pragma: no cover</span>
<span class="gi">+            _wait_for_writable(sock, expiration)</span>
<span class="gi">+    return s</span>


<span class="w"> </span>def _net_write(sock, data, expiration):
<span class="gu">@@ -376,11 +870,22 @@ def _net_write(sock, data, expiration):</span>
<span class="w"> </span>    A Timeout exception will be raised if the operation is not completed
<span class="w"> </span>    by the expiration time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def send_tcp(sock: Any, what: Union[dns.message.Message, bytes], expiration:</span>
<span class="gd">-    Optional[float]=None) -&gt;Tuple[int, float]:</span>
<span class="gi">+    current = 0</span>
<span class="gi">+    l = len(data)</span>
<span class="gi">+    while current &lt; l:</span>
<span class="gi">+        try:</span>
<span class="gi">+            current += sock.send(data[current:])</span>
<span class="gi">+        except (BlockingIOError, ssl.SSLWantWriteError):</span>
<span class="gi">+            _wait_for_writable(sock, expiration)</span>
<span class="gi">+        except ssl.SSLWantReadError:  # pragma: no cover</span>
<span class="gi">+            _wait_for_readable(sock, expiration)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def send_tcp(</span>
<span class="gi">+    sock: Any,</span>
<span class="gi">+    what: Union[dns.message.Message, bytes],</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+) -&gt; Tuple[int, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Send a DNS message to the specified TCP socket.

<span class="w"> </span>    *sock*, a ``socket``.
<span class="gu">@@ -393,13 +898,27 @@ def send_tcp(sock: Any, what: Union[dns.message.Message, bytes], expiration:</span>

<span class="w"> </span>    Returns an ``(int, float)`` tuple of bytes sent and the sent time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def receive_tcp(sock: Any, expiration: Optional[float]=None,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, keyring: Optional[Dict[dns.name.Name, dns</span>
<span class="gd">-    .tsig.Key]]=None, request_mac: Optional[bytes]=b&#39;&#39;, ignore_trailing:</span>
<span class="gd">-    bool=False) -&gt;Tuple[dns.message.Message, float]:</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        tcpmsg = what.to_wire(prepend_length=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # copying the wire into tcpmsg is inefficient, but lets us</span>
<span class="gi">+        # avoid writev() or doing a short write that would get pushed</span>
<span class="gi">+        # onto the net</span>
<span class="gi">+        tcpmsg = len(what).to_bytes(2, &quot;big&quot;) + what</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    _net_write(sock, tcpmsg, expiration)</span>
<span class="gi">+    return (len(tcpmsg), sent_time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def receive_tcp(</span>
<span class="gi">+    sock: Any,</span>
<span class="gi">+    expiration: Optional[float] = None,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,</span>
<span class="gi">+    request_mac: Optional[bytes] = b&quot;&quot;,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+) -&gt; Tuple[dns.message.Message, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a DNS message from a TCP socket.

<span class="w"> </span>    *sock*, a ``socket``.
<span class="gu">@@ -424,13 +943,43 @@ def receive_tcp(sock: Any, expiration: Optional[float]=None,</span>
<span class="w"> </span>    Returns a ``(dns.message.Message, float)`` tuple of the received message
<span class="w"> </span>    and the received time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def tcp(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>
<span class="gd">-    port: int=53, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, sock:</span>
<span class="gd">-    Optional[Any]=None) -&gt;dns.message.Message:</span>
<span class="gi">+    ldata = _net_read(sock, 2, expiration)</span>
<span class="gi">+    (l,) = struct.unpack(&quot;!H&quot;, ldata)</span>
<span class="gi">+    wire = _net_read(sock, l, expiration)</span>
<span class="gi">+    received_time = time.time()</span>
<span class="gi">+    r = dns.message.from_wire(</span>
<span class="gi">+        wire,</span>
<span class="gi">+        keyring=keyring,</span>
<span class="gi">+        request_mac=request_mac,</span>
<span class="gi">+        one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+        ignore_trailing=ignore_trailing,</span>
<span class="gi">+    )</span>
<span class="gi">+    return (r, received_time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _connect(s, address, expiration):</span>
<span class="gi">+    err = s.connect_ex(address)</span>
<span class="gi">+    if err == 0:</span>
<span class="gi">+        return</span>
<span class="gi">+    if err in (errno.EINPROGRESS, errno.EWOULDBLOCK, errno.EALREADY):</span>
<span class="gi">+        _wait_for_writable(s, expiration)</span>
<span class="gi">+        err = s.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)</span>
<span class="gi">+    if err != 0:</span>
<span class="gi">+        raise OSError(err, os.strerror(err))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tcp(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    sock: Optional[Any] = None,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via TCP.

<span class="w"> </span>    *q*, a ``dns.message.Message``, the query to send
<span class="gu">@@ -462,15 +1011,79 @@ def tcp(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def tls(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>
<span class="gd">-    port: int=853, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, sock:</span>
<span class="gd">-    Optional[ssl.SSLSocket]=None, ssl_context: Optional[ssl.SSLContext]=</span>
<span class="gd">-    None, server_hostname: Optional[str]=None, verify: Union[bool, str]=True</span>
<span class="gd">-    ) -&gt;dns.message.Message:</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        cm: contextlib.AbstractContextManager = contextlib.nullcontext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        (af, destination, source) = _destination_and_source(</span>
<span class="gi">+            where, port, source, source_port</span>
<span class="gi">+        )</span>
<span class="gi">+        cm = _make_socket(af, socket.SOCK_STREAM, source)</span>
<span class="gi">+    with cm as s:</span>
<span class="gi">+        if not sock:</span>
<span class="gi">+            _connect(s, destination, expiration)</span>
<span class="gi">+        send_tcp(s, wire, expiration)</span>
<span class="gi">+        (r, received_time) = receive_tcp(</span>
<span class="gi">+            s, expiration, one_rr_per_rrset, q.keyring, q.mac, ignore_trailing</span>
<span class="gi">+        )</span>
<span class="gi">+        r.time = received_time - begin_time</span>
<span class="gi">+        if not q.is_response(r):</span>
<span class="gi">+            raise BadResponse</span>
<span class="gi">+        return r</span>
<span class="gi">+    assert (</span>
<span class="gi">+        False  # help mypy figure out we can&#39;t get here  lgtm[py/unreachable-statement]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tls_handshake(s, expiration):</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            s.do_handshake()</span>
<span class="gi">+            return</span>
<span class="gi">+        except ssl.SSLWantReadError:</span>
<span class="gi">+            _wait_for_readable(s, expiration)</span>
<span class="gi">+        except ssl.SSLWantWriteError:  # pragma: no cover</span>
<span class="gi">+            _wait_for_writable(s, expiration)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_dot_ssl_context(</span>
<span class="gi">+    server_hostname: Optional[str], verify: Union[bool, str]</span>
<span class="gi">+) -&gt; ssl.SSLContext:</span>
<span class="gi">+    cafile: Optional[str] = None</span>
<span class="gi">+    capath: Optional[str] = None</span>
<span class="gi">+    if isinstance(verify, str):</span>
<span class="gi">+        if os.path.isfile(verify):</span>
<span class="gi">+            cafile = verify</span>
<span class="gi">+        elif os.path.isdir(verify):</span>
<span class="gi">+            capath = verify</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;invalid verify string&quot;)</span>
<span class="gi">+    ssl_context = ssl.create_default_context(cafile=cafile, capath=capath)</span>
<span class="gi">+    ssl_context.minimum_version = ssl.TLSVersion.TLSv1_2</span>
<span class="gi">+    if server_hostname is None:</span>
<span class="gi">+        ssl_context.check_hostname = False</span>
<span class="gi">+    ssl_context.set_alpn_protocols([&quot;dot&quot;])</span>
<span class="gi">+    if verify is False:</span>
<span class="gi">+        ssl_context.verify_mode = ssl.CERT_NONE</span>
<span class="gi">+    return ssl_context</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tls(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 853,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    sock: Optional[ssl.SSLSocket] = None,</span>
<span class="gi">+    ssl_context: Optional[ssl.SSLContext] = None,</span>
<span class="gi">+    server_hostname: Optional[str] = None,</span>
<span class="gi">+    verify: Union[bool, str] = True,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via TLS.

<span class="w"> </span>    *q*, a ``dns.message.Message``, the query to send
<span class="gu">@@ -517,14 +1130,66 @@ def tls(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>
<span class="w"> </span>    Returns a ``dns.message.Message``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def quic(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>
<span class="gd">-    port: int=853, source: Optional[str]=None, source_port: int=0,</span>
<span class="gd">-    one_rr_per_rrset: bool=False, ignore_trailing: bool=False, connection:</span>
<span class="gd">-    Optional[dns.quic.SyncQuicConnection]=None, verify: Union[bool, str]=</span>
<span class="gd">-    True, server_hostname: Optional[str]=None) -&gt;dns.message.Message:</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        #</span>
<span class="gi">+        # If a socket was provided, there&#39;s no special TLS handling needed.</span>
<span class="gi">+        #</span>
<span class="gi">+        return tcp(</span>
<span class="gi">+            q,</span>
<span class="gi">+            where,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            port,</span>
<span class="gi">+            source,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            one_rr_per_rrset,</span>
<span class="gi">+            ignore_trailing,</span>
<span class="gi">+            sock,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    (af, destination, source) = _destination_and_source(</span>
<span class="gi">+        where, port, source, source_port</span>
<span class="gi">+    )</span>
<span class="gi">+    if ssl_context is None and not sock:</span>
<span class="gi">+        ssl_context = _make_dot_ssl_context(server_hostname, verify)</span>
<span class="gi">+</span>
<span class="gi">+    with _make_socket(</span>
<span class="gi">+        af,</span>
<span class="gi">+        socket.SOCK_STREAM,</span>
<span class="gi">+        source,</span>
<span class="gi">+        ssl_context=ssl_context,</span>
<span class="gi">+        server_hostname=server_hostname,</span>
<span class="gi">+    ) as s:</span>
<span class="gi">+        _connect(s, destination, expiration)</span>
<span class="gi">+        _tls_handshake(s, expiration)</span>
<span class="gi">+        send_tcp(s, wire, expiration)</span>
<span class="gi">+        (r, received_time) = receive_tcp(</span>
<span class="gi">+            s, expiration, one_rr_per_rrset, q.keyring, q.mac, ignore_trailing</span>
<span class="gi">+        )</span>
<span class="gi">+        r.time = received_time - begin_time</span>
<span class="gi">+        if not q.is_response(r):</span>
<span class="gi">+            raise BadResponse</span>
<span class="gi">+        return r</span>
<span class="gi">+    assert (</span>
<span class="gi">+        False  # help mypy figure out we can&#39;t get here  lgtm[py/unreachable-statement]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def quic(</span>
<span class="gi">+    q: dns.message.Message,</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 853,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    one_rr_per_rrset: bool = False,</span>
<span class="gi">+    ignore_trailing: bool = False,</span>
<span class="gi">+    connection: Optional[dns.quic.SyncQuicConnection] = None,</span>
<span class="gi">+    verify: Union[bool, str] = True,</span>
<span class="gi">+    server_hostname: Optional[str] = None,</span>
<span class="gi">+) -&gt; dns.message.Message:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the response obtained after sending a query via DNS-over-QUIC.

<span class="w"> </span>    *q*, a ``dns.message.Message``, the query to send.
<span class="gu">@@ -561,17 +1226,61 @@ def quic(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def xfr(where: str, zone: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="gd">-    rdatatype.RdataType, str]=dns.rdatatype.AXFR, rdclass: Union[dns.</span>
<span class="gd">-    rdataclass.RdataClass, str]=dns.rdataclass.IN, timeout: Optional[float]</span>
<span class="gd">-    =None, port: int=53, keyring: Optional[Dict[dns.name.Name, dns.tsig.Key</span>
<span class="gd">-    ]]=None, keyname: Optional[Union[dns.name.Name, str]]=None, relativize:</span>
<span class="gd">-    bool=True, lifetime: Optional[float]=None, source: Optional[str]=None,</span>
<span class="gd">-    source_port: int=0, serial: int=0, use_udp: bool=False, keyalgorithm:</span>
<span class="gd">-    Union[dns.name.Name, str]=dns.tsig.default_algorithm) -&gt;Any:</span>
<span class="gi">+    if not dns.quic.have_quic:</span>
<span class="gi">+        raise NoDOQ(&quot;DNS-over-QUIC is not available.&quot;)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    q.id = 0</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    the_connection: dns.quic.SyncQuicConnection</span>
<span class="gi">+    the_manager: dns.quic.SyncQuicManager</span>
<span class="gi">+    if connection:</span>
<span class="gi">+        manager: contextlib.AbstractContextManager = contextlib.nullcontext(None)</span>
<span class="gi">+        the_connection = connection</span>
<span class="gi">+    else:</span>
<span class="gi">+        manager = dns.quic.SyncQuicManager(</span>
<span class="gi">+            verify_mode=verify, server_name=server_hostname</span>
<span class="gi">+        )</span>
<span class="gi">+        the_manager = manager  # for type checking happiness</span>
<span class="gi">+</span>
<span class="gi">+    with manager:</span>
<span class="gi">+        if not connection:</span>
<span class="gi">+            the_connection = the_manager.connect(where, port, source, source_port)</span>
<span class="gi">+        (start, expiration) = _compute_times(timeout)</span>
<span class="gi">+        with the_connection.make_stream(timeout) as stream:</span>
<span class="gi">+            stream.send(wire, True)</span>
<span class="gi">+            wire = stream.receive(_remaining(expiration))</span>
<span class="gi">+        finish = time.time()</span>
<span class="gi">+    r = dns.message.from_wire(</span>
<span class="gi">+        wire,</span>
<span class="gi">+        keyring=q.keyring,</span>
<span class="gi">+        request_mac=q.request_mac,</span>
<span class="gi">+        one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+        ignore_trailing=ignore_trailing,</span>
<span class="gi">+    )</span>
<span class="gi">+    r.time = max(finish - start, 0.0)</span>
<span class="gi">+    if not q.is_response(r):</span>
<span class="gi">+        raise BadResponse</span>
<span class="gi">+    return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def xfr(</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    zone: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.AXFR,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,</span>
<span class="gi">+    keyname: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    serial: int = 0,</span>
<span class="gi">+    use_udp: bool = False,</span>
<span class="gi">+    keyalgorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a generator for the responses to a zone transfer.

<span class="w"> </span>    *where*, a ``str`` containing an IPv4 or IPv6 address,  where
<span class="gu">@@ -623,7 +1332,122 @@ def xfr(where: str, zone: Union[dns.name.Name, str], rdtype: Union[dns.</span>

<span class="w"> </span>    Returns a generator of ``dns.message.Message`` objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(zone, str):</span>
<span class="gi">+        zone = dns.name.from_text(zone)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    q = dns.message.make_query(zone, rdtype, rdclass)</span>
<span class="gi">+    if rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+        rrset = dns.rrset.from_text(zone, 0, &quot;IN&quot;, &quot;SOA&quot;, &quot;. . %u 0 0 0 0&quot; % serial)</span>
<span class="gi">+        q.authority.append(rrset)</span>
<span class="gi">+    if keyring is not None:</span>
<span class="gi">+        q.use_tsig(keyring, keyname, algorithm=keyalgorithm)</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (af, destination, source) = _destination_and_source(</span>
<span class="gi">+        where, port, source, source_port</span>
<span class="gi">+    )</span>
<span class="gi">+    if use_udp and rdtype != dns.rdatatype.IXFR:</span>
<span class="gi">+        raise ValueError(&quot;cannot do a UDP AXFR&quot;)</span>
<span class="gi">+    sock_type = socket.SOCK_DGRAM if use_udp else socket.SOCK_STREAM</span>
<span class="gi">+    with _make_socket(af, sock_type, source) as s:</span>
<span class="gi">+        (_, expiration) = _compute_times(lifetime)</span>
<span class="gi">+        _connect(s, destination, expiration)</span>
<span class="gi">+        l = len(wire)</span>
<span class="gi">+        if use_udp:</span>
<span class="gi">+            _udp_send(s, wire, None, expiration)</span>
<span class="gi">+        else:</span>
<span class="gi">+            tcpmsg = struct.pack(&quot;!H&quot;, l) + wire</span>
<span class="gi">+            _net_write(s, tcpmsg, expiration)</span>
<span class="gi">+        done = False</span>
<span class="gi">+        delete_mode = True</span>
<span class="gi">+        expecting_SOA = False</span>
<span class="gi">+        soa_rrset = None</span>
<span class="gi">+        if relativize:</span>
<span class="gi">+            origin = zone</span>
<span class="gi">+            oname = dns.name.empty</span>
<span class="gi">+        else:</span>
<span class="gi">+            origin = None</span>
<span class="gi">+            oname = zone</span>
<span class="gi">+        tsig_ctx = None</span>
<span class="gi">+        while not done:</span>
<span class="gi">+            (_, mexpiration) = _compute_times(timeout)</span>
<span class="gi">+            if mexpiration is None or (</span>
<span class="gi">+                expiration is not None and mexpiration &gt; expiration</span>
<span class="gi">+            ):</span>
<span class="gi">+                mexpiration = expiration</span>
<span class="gi">+            if use_udp:</span>
<span class="gi">+                (wire, _) = _udp_recv(s, 65535, mexpiration)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ldata = _net_read(s, 2, mexpiration)</span>
<span class="gi">+                (l,) = struct.unpack(&quot;!H&quot;, ldata)</span>
<span class="gi">+                wire = _net_read(s, l, mexpiration)</span>
<span class="gi">+            is_ixfr = rdtype == dns.rdatatype.IXFR</span>
<span class="gi">+            r = dns.message.from_wire(</span>
<span class="gi">+                wire,</span>
<span class="gi">+                keyring=q.keyring,</span>
<span class="gi">+                request_mac=q.mac,</span>
<span class="gi">+                xfr=True,</span>
<span class="gi">+                origin=origin,</span>
<span class="gi">+                tsig_ctx=tsig_ctx,</span>
<span class="gi">+                multi=True,</span>
<span class="gi">+                one_rr_per_rrset=is_ixfr,</span>
<span class="gi">+            )</span>
<span class="gi">+            rcode = r.rcode()</span>
<span class="gi">+            if rcode != dns.rcode.NOERROR:</span>
<span class="gi">+                raise TransferError(rcode)</span>
<span class="gi">+            tsig_ctx = r.tsig_ctx</span>
<span class="gi">+            answer_index = 0</span>
<span class="gi">+            if soa_rrset is None:</span>
<span class="gi">+                if not r.answer or r.answer[0].name != oname:</span>
<span class="gi">+                    raise dns.exception.FormError(&quot;No answer or RRset not for qname&quot;)</span>
<span class="gi">+                rrset = r.answer[0]</span>
<span class="gi">+                if rrset.rdtype != dns.rdatatype.SOA:</span>
<span class="gi">+                    raise dns.exception.FormError(&quot;first RRset is not an SOA&quot;)</span>
<span class="gi">+                answer_index = 1</span>
<span class="gi">+                soa_rrset = rrset.copy()</span>
<span class="gi">+                if rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                    if dns.serial.Serial(soa_rrset[0].serial) &lt;= serial:</span>
<span class="gi">+                        #</span>
<span class="gi">+                        # We&#39;re already up-to-date.</span>
<span class="gi">+                        #</span>
<span class="gi">+                        done = True</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        expecting_SOA = True</span>
<span class="gi">+            #</span>
<span class="gi">+            # Process SOAs in the answer section (other than the initial</span>
<span class="gi">+            # SOA in the first message).</span>
<span class="gi">+            #</span>
<span class="gi">+            for rrset in r.answer[answer_index:]:</span>
<span class="gi">+                if done:</span>
<span class="gi">+                    raise dns.exception.FormError(&quot;answers after final SOA&quot;)</span>
<span class="gi">+                if rrset.rdtype == dns.rdatatype.SOA and rrset.name == oname:</span>
<span class="gi">+                    if expecting_SOA:</span>
<span class="gi">+                        if rrset[0].serial != serial:</span>
<span class="gi">+                            raise dns.exception.FormError(&quot;IXFR base serial mismatch&quot;)</span>
<span class="gi">+                        expecting_SOA = False</span>
<span class="gi">+                    elif rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                        delete_mode = not delete_mode</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # If this SOA RRset is equal to the first we saw then we&#39;re</span>
<span class="gi">+                    # finished. If this is an IXFR we also check that we&#39;re</span>
<span class="gi">+                    # seeing the record in the expected part of the response.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    if rrset == soa_rrset and (</span>
<span class="gi">+                        rdtype == dns.rdatatype.AXFR</span>
<span class="gi">+                        or (rdtype == dns.rdatatype.IXFR and delete_mode)</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        done = True</span>
<span class="gi">+                elif expecting_SOA:</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # We made an IXFR request and are expecting another</span>
<span class="gi">+                    # SOA RR, but saw something else, so this must be an</span>
<span class="gi">+                    # AXFR response.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    rdtype = dns.rdatatype.AXFR</span>
<span class="gi">+                    expecting_SOA = False</span>
<span class="gi">+            if done and q.keyring and not r.had_tsig:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;missing TSIG&quot;)</span>
<span class="gi">+            yield r</span>


<span class="w"> </span>class UDPMode(enum.IntEnum):
<span class="gu">@@ -633,15 +1457,23 @@ class UDPMode(enum.IntEnum):</span>
<span class="w"> </span>    TRY_FIRST means &quot;try to use UDP but fall back to TCP if needed&quot;
<span class="w"> </span>    ONLY means &quot;raise ``dns.xfr.UseTCP`` if trying UDP does not succeed&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    NEVER = 0
<span class="w"> </span>    TRY_FIRST = 1
<span class="w"> </span>    ONLY = 2


<span class="gd">-def inbound_xfr(where: str, txn_manager: dns.transaction.TransactionManager,</span>
<span class="gd">-    query: Optional[dns.message.Message]=None, port: int=53, timeout:</span>
<span class="gd">-    Optional[float]=None, lifetime: Optional[float]=None, source: Optional[</span>
<span class="gd">-    str]=None, source_port: int=0, udp_mode: UDPMode=UDPMode.NEVER) -&gt;None:</span>
<span class="gi">+def inbound_xfr(</span>
<span class="gi">+    where: str,</span>
<span class="gi">+    txn_manager: dns.transaction.TransactionManager,</span>
<span class="gi">+    query: Optional[dns.message.Message] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    timeout: Optional[float] = None,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    udp_mode: UDPMode = UDPMode.NEVER,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Conduct an inbound transfer and apply it via a transaction from the
<span class="w"> </span>    txn_manager.

<span class="gu">@@ -678,4 +1510,69 @@ def inbound_xfr(where: str, txn_manager: dns.transaction.TransactionManager,</span>

<span class="w"> </span>    Raises on errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if query is None:</span>
<span class="gi">+        (query, serial) = dns.xfr.make_query(txn_manager)</span>
<span class="gi">+    else:</span>
<span class="gi">+        serial = dns.xfr.extract_serial_from_query(query)</span>
<span class="gi">+    rdtype = query.question[0].rdtype</span>
<span class="gi">+    is_ixfr = rdtype == dns.rdatatype.IXFR</span>
<span class="gi">+    origin = txn_manager.from_wire_origin()</span>
<span class="gi">+    wire = query.to_wire()</span>
<span class="gi">+    (af, destination, source) = _destination_and_source(</span>
<span class="gi">+        where, port, source, source_port</span>
<span class="gi">+    )</span>
<span class="gi">+    (_, expiration) = _compute_times(lifetime)</span>
<span class="gi">+    retry = True</span>
<span class="gi">+    while retry:</span>
<span class="gi">+        retry = False</span>
<span class="gi">+        if is_ixfr and udp_mode != UDPMode.NEVER:</span>
<span class="gi">+            sock_type = socket.SOCK_DGRAM</span>
<span class="gi">+            is_udp = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            sock_type = socket.SOCK_STREAM</span>
<span class="gi">+            is_udp = False</span>
<span class="gi">+        with _make_socket(af, sock_type, source) as s:</span>
<span class="gi">+            _connect(s, destination, expiration)</span>
<span class="gi">+            if is_udp:</span>
<span class="gi">+                _udp_send(s, wire, None, expiration)</span>
<span class="gi">+            else:</span>
<span class="gi">+                tcpmsg = struct.pack(&quot;!H&quot;, len(wire)) + wire</span>
<span class="gi">+                _net_write(s, tcpmsg, expiration)</span>
<span class="gi">+            with dns.xfr.Inbound(txn_manager, rdtype, serial, is_udp) as inbound:</span>
<span class="gi">+                done = False</span>
<span class="gi">+                tsig_ctx = None</span>
<span class="gi">+                while not done:</span>
<span class="gi">+                    (_, mexpiration) = _compute_times(timeout)</span>
<span class="gi">+                    if mexpiration is None or (</span>
<span class="gi">+                        expiration is not None and mexpiration &gt; expiration</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        mexpiration = expiration</span>
<span class="gi">+                    if is_udp:</span>
<span class="gi">+                        (rwire, _) = _udp_recv(s, 65535, mexpiration)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        ldata = _net_read(s, 2, mexpiration)</span>
<span class="gi">+                        (l,) = struct.unpack(&quot;!H&quot;, ldata)</span>
<span class="gi">+                        rwire = _net_read(s, l, mexpiration)</span>
<span class="gi">+                    r = dns.message.from_wire(</span>
<span class="gi">+                        rwire,</span>
<span class="gi">+                        keyring=query.keyring,</span>
<span class="gi">+                        request_mac=query.mac,</span>
<span class="gi">+                        xfr=True,</span>
<span class="gi">+                        origin=origin,</span>
<span class="gi">+                        tsig_ctx=tsig_ctx,</span>
<span class="gi">+                        multi=(not is_udp),</span>
<span class="gi">+                        one_rr_per_rrset=is_ixfr,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        done = inbound.process_message(r)</span>
<span class="gi">+                    except dns.xfr.UseTCP:</span>
<span class="gi">+                        assert is_udp  # should not happen if we used TCP!</span>
<span class="gi">+                        if udp_mode == UDPMode.ONLY:</span>
<span class="gi">+                            raise</span>
<span class="gi">+                        done = True</span>
<span class="gi">+                        retry = True</span>
<span class="gi">+                        udp_mode = UDPMode.NEVER</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    tsig_ctx = r.tsig_ctx</span>
<span class="gi">+                if not retry and query.keyring and not r.had_tsig:</span>
<span class="gi">+                    raise dns.exception.FormError(&quot;missing TSIG&quot;)</span>
<span class="gh">diff --git a/dns/quic/_asyncio.py b/dns/quic/_asyncio.py</span>
<span class="gh">index 046f81d..0f44331 100644</span>
<span class="gd">--- a/dns/quic/_asyncio.py</span>
<span class="gi">+++ b/dns/quic/_asyncio.py</span>
<span class="gu">@@ -1,23 +1,69 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="gd">-import aioquic.quic.configuration</span>
<span class="gd">-import aioquic.quic.connection</span>
<span class="gd">-import aioquic.quic.events</span>
<span class="gi">+</span>
<span class="gi">+import aioquic.quic.configuration  # type: ignore</span>
<span class="gi">+import aioquic.quic.connection  # type: ignore</span>
<span class="gi">+import aioquic.quic.events  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.asyncbackend
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="gd">-from dns.quic._common import QUIC_MAX_DATAGRAM, AsyncQuicConnection, AsyncQuicManager, BaseQuicStream, UnexpectedEOF</span>
<span class="gi">+from dns.quic._common import (</span>
<span class="gi">+    QUIC_MAX_DATAGRAM,</span>
<span class="gi">+    AsyncQuicConnection,</span>
<span class="gi">+    AsyncQuicManager,</span>
<span class="gi">+    BaseQuicStream,</span>
<span class="gi">+    UnexpectedEOF,</span>
<span class="gi">+)</span>


<span class="w"> </span>class AsyncioQuicStream(BaseQuicStream):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, connection, stream_id):
<span class="w"> </span>        super().__init__(connection, stream_id)
<span class="w"> </span>        self._wake_up = asyncio.Condition()

<span class="gi">+    async def _wait_for_wake_up(self):</span>
<span class="gi">+        async with self._wake_up:</span>
<span class="gi">+            await self._wake_up.wait()</span>
<span class="gi">+</span>
<span class="gi">+    async def wait_for(self, amount, expiration):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            timeout = self._timeout_from_expiration(expiration)</span>
<span class="gi">+            if self._buffer.have(amount):</span>
<span class="gi">+                return</span>
<span class="gi">+            self._expecting = amount</span>
<span class="gi">+            try:</span>
<span class="gi">+                await asyncio.wait_for(self._wait_for_wake_up(), timeout)</span>
<span class="gi">+            except TimeoutError:</span>
<span class="gi">+                raise dns.exception.Timeout</span>
<span class="gi">+            self._expecting = 0</span>
<span class="gi">+</span>
<span class="gi">+    async def receive(self, timeout=None):</span>
<span class="gi">+        expiration = self._expiration_from_timeout(timeout)</span>
<span class="gi">+        await self.wait_for(2, expiration)</span>
<span class="gi">+        (size,) = struct.unpack(&quot;!H&quot;, self._buffer.get(2))</span>
<span class="gi">+        await self.wait_for(size, expiration)</span>
<span class="gi">+        return self._buffer.get(size)</span>
<span class="gi">+</span>
<span class="gi">+    async def send(self, datagram, is_end=False):</span>
<span class="gi">+        data = self._encapsulate(datagram)</span>
<span class="gi">+        await self._connection.write(self._stream_id, data, is_end)</span>
<span class="gi">+</span>
<span class="gi">+    async def _add_input(self, data, is_end):</span>
<span class="gi">+        if self._common_add_input(data, is_end):</span>
<span class="gi">+            async with self._wake_up:</span>
<span class="gi">+                self._wake_up.notify()</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self._close()</span>
<span class="gi">+</span>
<span class="gi">+    # Streams are async context managers</span>
<span class="gi">+</span>
<span class="w"> </span>    async def __aenter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -29,11 +75,8 @@ class AsyncioQuicStream(BaseQuicStream):</span>


<span class="w"> </span>class AsyncioQuicConnection(AsyncQuicConnection):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, connection, address, port, source, source_port,</span>
<span class="gd">-        manager=None):</span>
<span class="gd">-        super().__init__(connection, address, port, source, source_port,</span>
<span class="gd">-            manager)</span>
<span class="gi">+    def __init__(self, connection, address, port, source, source_port, manager=None):</span>
<span class="gi">+        super().__init__(connection, address, port, source, source_port, manager)</span>
<span class="w"> </span>        self._socket = None
<span class="w"> </span>        self._handshake_complete = asyncio.Event()
<span class="w"> </span>        self._socket_created = asyncio.Event()
<span class="gu">@@ -41,17 +84,144 @@ class AsyncioQuicConnection(AsyncQuicConnection):</span>
<span class="w"> </span>        self._receiver_task = None
<span class="w"> </span>        self._sender_task = None

<span class="gi">+    async def _receiver(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            af = dns.inet.af_for_address(self._address)</span>
<span class="gi">+            backend = dns.asyncbackend.get_backend(&quot;asyncio&quot;)</span>
<span class="gi">+            # Note that peer is a low-level address tuple, but make_socket() wants</span>
<span class="gi">+            # a high-level address tuple, so we convert.</span>
<span class="gi">+            self._socket = await backend.make_socket(</span>
<span class="gi">+                af, socket.SOCK_DGRAM, 0, self._source, (self._peer[0], self._peer[1])</span>
<span class="gi">+            )</span>
<span class="gi">+            self._socket_created.set()</span>
<span class="gi">+            async with self._socket:</span>
<span class="gi">+                while not self._done:</span>
<span class="gi">+                    (datagram, address) = await self._socket.recvfrom(</span>
<span class="gi">+                        QUIC_MAX_DATAGRAM, None</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if address[0] != self._peer[0] or address[1] != self._peer[1]:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    self._connection.receive_datagram(datagram, address, time.time())</span>
<span class="gi">+                    # Wake up the timer in case the sender is sleeping, as there may be</span>
<span class="gi">+                    # stuff to send now.</span>
<span class="gi">+                    async with self._wake_timer:</span>
<span class="gi">+                        self._wake_timer.notify_all()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._done = True</span>
<span class="gi">+            async with self._wake_timer:</span>
<span class="gi">+                self._wake_timer.notify_all()</span>
<span class="gi">+            self._handshake_complete.set()</span>

<span class="gd">-class AsyncioQuicManager(AsyncQuicManager):</span>
<span class="gi">+    async def _wait_for_wake_timer(self):</span>
<span class="gi">+        async with self._wake_timer:</span>
<span class="gi">+            await self._wake_timer.wait()</span>
<span class="gi">+</span>
<span class="gi">+    async def _sender(self):</span>
<span class="gi">+        await self._socket_created.wait()</span>
<span class="gi">+        while not self._done:</span>
<span class="gi">+            datagrams = self._connection.datagrams_to_send(time.time())</span>
<span class="gi">+            for datagram, address in datagrams:</span>
<span class="gi">+                assert address == self._peer</span>
<span class="gi">+                await self._socket.sendto(datagram, self._peer, None)</span>
<span class="gi">+            (expiration, interval) = self._get_timer_values()</span>
<span class="gi">+            try:</span>
<span class="gi">+                await asyncio.wait_for(self._wait_for_wake_timer(), interval)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="gi">+            self._handle_timer(expiration)</span>
<span class="gi">+            await self._handle_events()</span>
<span class="gi">+</span>
<span class="gi">+    async def _handle_events(self):</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            event = self._connection.next_event()</span>
<span class="gi">+            if event is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            if isinstance(event, aioquic.quic.events.StreamDataReceived):</span>
<span class="gi">+                stream = self._streams.get(event.stream_id)</span>
<span class="gi">+                if stream:</span>
<span class="gi">+                    await stream._add_input(event.data, event.end_stream)</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.HandshakeCompleted):</span>
<span class="gi">+                self._handshake_complete.set()</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.ConnectionTerminated):</span>
<span class="gi">+                self._done = True</span>
<span class="gi">+                self._receiver_task.cancel()</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.StreamReset):</span>
<span class="gi">+                stream = self._streams.get(event.stream_id)</span>
<span class="gi">+                if stream:</span>
<span class="gi">+                    await stream._add_input(b&quot;&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+            count += 1</span>
<span class="gi">+            if count &gt; 10:</span>
<span class="gi">+                # yield</span>
<span class="gi">+                count = 0</span>
<span class="gi">+                await asyncio.sleep(0)</span>
<span class="gi">+</span>
<span class="gi">+    async def write(self, stream, data, is_end=False):</span>
<span class="gi">+        self._connection.send_stream_data(stream, data, is_end)</span>
<span class="gi">+        async with self._wake_timer:</span>
<span class="gi">+            self._wake_timer.notify_all()</span>

<span class="gd">-    def __init__(self, conf=None, verify_mode=ssl.CERT_REQUIRED,</span>
<span class="gd">-        server_name=None):</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._receiver_task = asyncio.Task(self._receiver())</span>
<span class="gi">+        self._sender_task = asyncio.Task(self._sender())</span>
<span class="gi">+</span>
<span class="gi">+    async def make_stream(self, timeout=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            await asyncio.wait_for(self._handshake_complete.wait(), timeout)</span>
<span class="gi">+        except TimeoutError:</span>
<span class="gi">+            raise dns.exception.Timeout</span>
<span class="gi">+        if self._done:</span>
<span class="gi">+            raise UnexpectedEOF</span>
<span class="gi">+        stream_id = self._connection.get_next_available_stream_id(False)</span>
<span class="gi">+        stream = AsyncioQuicStream(self, stream_id)</span>
<span class="gi">+        self._streams[stream_id] = stream</span>
<span class="gi">+        return stream</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._manager.closed(self._peer[0], self._peer[1])</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            self._connection.close()</span>
<span class="gi">+            # sender might be blocked on this, so set it</span>
<span class="gi">+            self._socket_created.set()</span>
<span class="gi">+            async with self._wake_timer:</span>
<span class="gi">+                self._wake_timer.notify_all()</span>
<span class="gi">+            try:</span>
<span class="gi">+                await self._receiver_task</span>
<span class="gi">+            except asyncio.CancelledError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                await self._sender_task</span>
<span class="gi">+            except asyncio.CancelledError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            await self._socket.close()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class AsyncioQuicManager(AsyncQuicManager):</span>
<span class="gi">+    def __init__(self, conf=None, verify_mode=ssl.CERT_REQUIRED, server_name=None):</span>
<span class="w"> </span>        super().__init__(conf, verify_mode, AsyncioQuicConnection, server_name)

<span class="gi">+    def connect(</span>
<span class="gi">+        self, address, port=853, source=None, source_port=0, want_session_ticket=True</span>
<span class="gi">+    ):</span>
<span class="gi">+        (connection, start) = self._connect(</span>
<span class="gi">+            address, port, source, source_port, want_session_ticket</span>
<span class="gi">+        )</span>
<span class="gi">+        if start:</span>
<span class="gi">+            connection.run()</span>
<span class="gi">+        return connection</span>
<span class="gi">+</span>
<span class="w"> </span>    async def __aenter__(self):
<span class="w"> </span>        return self

<span class="w"> </span>    async def __aexit__(self, exc_type, exc_val, exc_tb):
<span class="gi">+        # Copy the iterator into a list as exiting things will mutate the connections</span>
<span class="gi">+        # table.</span>
<span class="w"> </span>        connections = list(self._connections.values())
<span class="w"> </span>        for connection in connections:
<span class="w"> </span>            await connection.close()
<span class="gh">diff --git a/dns/quic/_common.py b/dns/quic/_common.py</span>
<span class="gh">index d37beb9..0eacc69 100644</span>
<span class="gd">--- a/dns/quic/_common.py</span>
<span class="gi">+++ b/dns/quic/_common.py</span>
<span class="gu">@@ -1,14 +1,21 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="w"> </span>import functools
<span class="w"> </span>import socket
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="w"> </span>from typing import Any, Optional
<span class="gd">-import aioquic.quic.configuration</span>
<span class="gd">-import aioquic.quic.connection</span>
<span class="gi">+</span>
<span class="gi">+import aioquic.quic.configuration  # type: ignore</span>
<span class="gi">+import aioquic.quic.connection  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.inet
<span class="gi">+</span>
<span class="w"> </span>QUIC_MAX_DATAGRAM = 2048
<span class="w"> </span>MAX_SESSION_TICKETS = 8
<span class="gi">+# If we hit the max sessions limit we will delete this many of the oldest connections.</span>
<span class="gi">+# The value must be a integer &gt; 0 and &lt;= MAX_SESSION_TICKETS.</span>
<span class="w"> </span>SESSIONS_TO_DELETE = MAX_SESSION_TICKETS // 4


<span class="gu">@@ -17,25 +24,81 @@ class UnexpectedEOF(Exception):</span>


<span class="w"> </span>class Buffer:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="gd">-        self._buffer = b&#39;&#39;</span>
<span class="gi">+        self._buffer = b&quot;&quot;</span>
<span class="w"> </span>        self._seen_end = False

<span class="gi">+    def put(self, data, is_end):</span>
<span class="gi">+        if self._seen_end:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._buffer += data</span>
<span class="gi">+        if is_end:</span>
<span class="gi">+            self._seen_end = True</span>

<span class="gd">-class BaseQuicStream:</span>
<span class="gi">+    def have(self, amount):</span>
<span class="gi">+        if len(self._buffer) &gt;= amount:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if self._seen_end:</span>
<span class="gi">+            raise UnexpectedEOF</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def seen_end(self):</span>
<span class="gi">+        return self._seen_end</span>

<span class="gi">+    def get(self, amount):</span>
<span class="gi">+        assert self.have(amount)</span>
<span class="gi">+        data = self._buffer[:amount]</span>
<span class="gi">+        self._buffer = self._buffer[amount:]</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class BaseQuicStream:</span>
<span class="w"> </span>    def __init__(self, connection, stream_id):
<span class="w"> </span>        self._connection = connection
<span class="w"> </span>        self._stream_id = stream_id
<span class="w"> </span>        self._buffer = Buffer()
<span class="w"> </span>        self._expecting = 0

<span class="gi">+    def id(self):</span>
<span class="gi">+        return self._stream_id</span>

<span class="gd">-class BaseQuicConnection:</span>
<span class="gi">+    def _expiration_from_timeout(self, timeout):</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            expiration = time.time() + timeout</span>
<span class="gi">+        else:</span>
<span class="gi">+            expiration = None</span>
<span class="gi">+        return expiration</span>
<span class="gi">+</span>
<span class="gi">+    def _timeout_from_expiration(self, expiration):</span>
<span class="gi">+        if expiration is not None:</span>
<span class="gi">+            timeout = max(expiration - time.time(), 0.0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            timeout = None</span>
<span class="gi">+        return timeout</span>

<span class="gd">-    def __init__(self, connection, address, port, source=None, source_port=</span>
<span class="gd">-        0, manager=None):</span>
<span class="gi">+    # Subclass must implement receive() as sync / async and which returns a message</span>
<span class="gi">+    # or raises UnexpectedEOF.</span>
<span class="gi">+</span>
<span class="gi">+    def _encapsulate(self, datagram):</span>
<span class="gi">+        l = len(datagram)</span>
<span class="gi">+        return struct.pack(&quot;!H&quot;, l) + datagram</span>
<span class="gi">+</span>
<span class="gi">+    def _common_add_input(self, data, is_end):</span>
<span class="gi">+        self._buffer.put(data, is_end)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._expecting &gt; 0 and self._buffer.have(self._expecting)</span>
<span class="gi">+        except UnexpectedEOF:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    def _close(self):</span>
<span class="gi">+        self._connection.close_stream(self._stream_id)</span>
<span class="gi">+        self._buffer.put(b&quot;&quot;, True)  # send EOF in case we haven&#39;t seen it.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class BaseQuicConnection:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, connection, address, port, source=None, source_port=0, manager=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._done = False
<span class="w"> </span>        self._connection = connection
<span class="w"> </span>        self._address = address
<span class="gu">@@ -47,25 +110,45 @@ class BaseQuicConnection:</span>
<span class="w"> </span>        self._peer = dns.inet.low_level_address_tuple((address, port))
<span class="w"> </span>        if source is None and source_port != 0:
<span class="w"> </span>            if self._af == socket.AF_INET:
<span class="gd">-                source = &#39;0.0.0.0&#39;</span>
<span class="gi">+                source = &quot;0.0.0.0&quot;</span>
<span class="w"> </span>            elif self._af == socket.AF_INET6:
<span class="gd">-                source = &#39;::&#39;</span>
<span class="gi">+                source = &quot;::&quot;</span>
<span class="w"> </span>            else:
<span class="w"> </span>                raise NotImplementedError
<span class="w"> </span>        if source:
<span class="gd">-            self._source = source, source_port</span>
<span class="gi">+            self._source = (source, source_port)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._source = None

<span class="gi">+    def close_stream(self, stream_id):</span>
<span class="gi">+        del self._streams[stream_id]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_timer_values(self, closed_is_special=True):</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        expiration = self._connection.get_timer()</span>
<span class="gi">+        if expiration is None:</span>
<span class="gi">+            expiration = now + 3600  # arbitrary &quot;big&quot; value</span>
<span class="gi">+        interval = max(expiration - now, 0)</span>
<span class="gi">+        if self._closed and closed_is_special:</span>
<span class="gi">+            # lower sleep interval to avoid a race in the closing process</span>
<span class="gi">+            # which can lead to higher latency closing due to sleeping when</span>
<span class="gi">+            # we have events.</span>
<span class="gi">+            interval = min(interval, 0.05)</span>
<span class="gi">+        return (expiration, interval)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_timer(self, expiration):</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        if expiration &lt;= now:</span>
<span class="gi">+            self._connection.handle_timer(now)</span>
<span class="gi">+</span>

<span class="w"> </span>class AsyncQuicConnection(BaseQuicConnection):
<span class="gd">-    pass</span>
<span class="gi">+    async def make_stream(self, timeout: Optional[float] = None) -&gt; Any:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class BaseQuicManager:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, conf, verify_mode, connection_factory, server_name=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, conf, verify_mode, connection_factory, server_name=None):</span>
<span class="w"> </span>        self._connections = {}
<span class="w"> </span>        self._connection_factory = connection_factory
<span class="w"> </span>        self._session_tickets = {}
<span class="gu">@@ -74,13 +157,68 @@ class BaseQuicManager:</span>
<span class="w"> </span>            if isinstance(verify_mode, str):
<span class="w"> </span>                verify_path = verify_mode
<span class="w"> </span>                verify_mode = True
<span class="gd">-            conf = aioquic.quic.configuration.QuicConfiguration(alpn_protocols</span>
<span class="gd">-                =[&#39;doq&#39;, &#39;doq-i03&#39;], verify_mode=verify_mode, server_name=</span>
<span class="gd">-                server_name)</span>
<span class="gi">+            conf = aioquic.quic.configuration.QuicConfiguration(</span>
<span class="gi">+                alpn_protocols=[&quot;doq&quot;, &quot;doq-i03&quot;],</span>
<span class="gi">+                verify_mode=verify_mode,</span>
<span class="gi">+                server_name=server_name,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if verify_path is not None:
<span class="w"> </span>                conf.load_verify_locations(verify_path)
<span class="w"> </span>        self._conf = conf

<span class="gi">+    def _connect(</span>
<span class="gi">+        self, address, port=853, source=None, source_port=0, want_session_ticket=True</span>
<span class="gi">+    ):</span>
<span class="gi">+        connection = self._connections.get((address, port))</span>
<span class="gi">+        if connection is not None:</span>
<span class="gi">+            return (connection, False)</span>
<span class="gi">+        conf = self._conf</span>
<span class="gi">+        if want_session_ticket:</span>
<span class="gi">+            try:</span>
<span class="gi">+                session_ticket = self._session_tickets.pop((address, port))</span>
<span class="gi">+                # We found a session ticket, so make a configuration that uses it.</span>
<span class="gi">+                conf = copy.copy(conf)</span>
<span class="gi">+                conf.session_ticket = session_ticket</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # No session ticket.</span>
<span class="gi">+                pass</span>
<span class="gi">+            # Whether or not we found a session ticket, we want a handler to save</span>
<span class="gi">+            # one.</span>
<span class="gi">+            session_ticket_handler = functools.partial(</span>
<span class="gi">+                self.save_session_ticket, address, port</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            session_ticket_handler = None</span>
<span class="gi">+        qconn = aioquic.quic.connection.QuicConnection(</span>
<span class="gi">+            configuration=conf,</span>
<span class="gi">+            session_ticket_handler=session_ticket_handler,</span>
<span class="gi">+        )</span>
<span class="gi">+        lladdress = dns.inet.low_level_address_tuple((address, port))</span>
<span class="gi">+        qconn.connect(lladdress, time.time())</span>
<span class="gi">+        connection = self._connection_factory(</span>
<span class="gi">+            qconn, address, port, source, source_port, self</span>
<span class="gi">+        )</span>
<span class="gi">+        self._connections[(address, port)] = connection</span>
<span class="gi">+        return (connection, True)</span>
<span class="gi">+</span>
<span class="gi">+    def closed(self, address, port):</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._connections[(address, port)]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def save_session_ticket(self, address, port, ticket):</span>
<span class="gi">+        # We rely on dictionaries keys() being in insertion order here.  We</span>
<span class="gi">+        # can&#39;t just popitem() as that would be LIFO which is the opposite of</span>
<span class="gi">+        # what we want.</span>
<span class="gi">+        l = len(self._session_tickets)</span>
<span class="gi">+        if l &gt;= MAX_SESSION_TICKETS:</span>
<span class="gi">+            keys_to_delete = list(self._session_tickets.keys())[0:SESSIONS_TO_DELETE]</span>
<span class="gi">+            for key in keys_to_delete:</span>
<span class="gi">+                del self._session_tickets[key]</span>
<span class="gi">+        self._session_tickets[(address, port)] = ticket</span>
<span class="gi">+</span>

<span class="w"> </span>class AsyncQuicManager(BaseQuicManager):
<span class="gd">-    pass</span>
<span class="gi">+    def connect(self, address, port=853, source=None, source_port=0):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/dns/quic/_sync.py b/dns/quic/_sync.py</span>
<span class="gh">index 5052983..120cb5f 100644</span>
<span class="gd">--- a/dns/quic/_sync.py</span>
<span class="gi">+++ b/dns/quic/_sync.py</span>
<span class="gu">@@ -1,28 +1,73 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import selectors
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="w"> </span>import struct
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="gd">-import aioquic.quic.configuration</span>
<span class="gd">-import aioquic.quic.connection</span>
<span class="gd">-import aioquic.quic.events</span>
<span class="gi">+</span>
<span class="gi">+import aioquic.quic.configuration  # type: ignore</span>
<span class="gi">+import aioquic.quic.connection  # type: ignore</span>
<span class="gi">+import aioquic.quic.events  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="gd">-from dns.quic._common import QUIC_MAX_DATAGRAM, BaseQuicConnection, BaseQuicManager, BaseQuicStream, UnexpectedEOF</span>
<span class="gd">-if hasattr(selectors, &#39;PollSelector&#39;):</span>
<span class="gd">-    _selector_class = selectors.PollSelector</span>
<span class="gi">+from dns.quic._common import (</span>
<span class="gi">+    QUIC_MAX_DATAGRAM,</span>
<span class="gi">+    BaseQuicConnection,</span>
<span class="gi">+    BaseQuicManager,</span>
<span class="gi">+    BaseQuicStream,</span>
<span class="gi">+    UnexpectedEOF,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# Avoid circularity with dns.query</span>
<span class="gi">+if hasattr(selectors, &quot;PollSelector&quot;):</span>
<span class="gi">+    _selector_class = selectors.PollSelector  # type: ignore</span>
<span class="w"> </span>else:
<span class="gd">-    _selector_class = selectors.SelectSelector</span>
<span class="gi">+    _selector_class = selectors.SelectSelector  # type: ignore</span>


<span class="w"> </span>class SyncQuicStream(BaseQuicStream):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, connection, stream_id):
<span class="w"> </span>        super().__init__(connection, stream_id)
<span class="w"> </span>        self._wake_up = threading.Condition()
<span class="w"> </span>        self._lock = threading.Lock()

<span class="gi">+    def wait_for(self, amount, expiration):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            timeout = self._timeout_from_expiration(expiration)</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                if self._buffer.have(amount):</span>
<span class="gi">+                    return</span>
<span class="gi">+                self._expecting = amount</span>
<span class="gi">+            with self._wake_up:</span>
<span class="gi">+                if not self._wake_up.wait(timeout):</span>
<span class="gi">+                    raise dns.exception.Timeout</span>
<span class="gi">+            self._expecting = 0</span>
<span class="gi">+</span>
<span class="gi">+    def receive(self, timeout=None):</span>
<span class="gi">+        expiration = self._expiration_from_timeout(timeout)</span>
<span class="gi">+        self.wait_for(2, expiration)</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            (size,) = struct.unpack(&quot;!H&quot;, self._buffer.get(2))</span>
<span class="gi">+        self.wait_for(size, expiration)</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            return self._buffer.get(size)</span>
<span class="gi">+</span>
<span class="gi">+    def send(self, datagram, is_end=False):</span>
<span class="gi">+        data = self._encapsulate(datagram)</span>
<span class="gi">+        self._connection.write(self._stream_id, data, is_end)</span>
<span class="gi">+</span>
<span class="gi">+    def _add_input(self, data, is_end):</span>
<span class="gi">+        if self._common_add_input(data, is_end):</span>
<span class="gi">+            with self._wake_up:</span>
<span class="gi">+                self._wake_up.notify()</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._close()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -34,39 +79,159 @@ class SyncQuicStream(BaseQuicStream):</span>


<span class="w"> </span>class SyncQuicConnection(BaseQuicConnection):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, connection, address, port, source, source_port, manager</span>
<span class="gd">-        ):</span>
<span class="gd">-        super().__init__(connection, address, port, source, source_port,</span>
<span class="gd">-            manager)</span>
<span class="gi">+    def __init__(self, connection, address, port, source, source_port, manager):</span>
<span class="gi">+        super().__init__(connection, address, port, source, source_port, manager)</span>
<span class="w"> </span>        self._socket = socket.socket(self._af, socket.SOCK_DGRAM, 0)
<span class="w"> </span>        if self._source is not None:
<span class="w"> </span>            try:
<span class="gd">-                self._socket.bind(dns.inet.low_level_address_tuple(self.</span>
<span class="gd">-                    _source, self._af))</span>
<span class="gi">+                self._socket.bind(</span>
<span class="gi">+                    dns.inet.low_level_address_tuple(self._source, self._af)</span>
<span class="gi">+                )</span>
<span class="w"> </span>            except Exception:
<span class="w"> </span>                self._socket.close()
<span class="w"> </span>                raise
<span class="w"> </span>        self._socket.connect(self._peer)
<span class="gd">-        self._send_wakeup, self._receive_wakeup = socket.socketpair()</span>
<span class="gi">+        (self._send_wakeup, self._receive_wakeup) = socket.socketpair()</span>
<span class="w"> </span>        self._receive_wakeup.setblocking(False)
<span class="w"> </span>        self._socket.setblocking(False)
<span class="w"> </span>        self._handshake_complete = threading.Event()
<span class="w"> </span>        self._worker_thread = None
<span class="w"> </span>        self._lock = threading.Lock()

<span class="gi">+    def _read(self):</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        while count &lt; 10:</span>
<span class="gi">+            count += 1</span>
<span class="gi">+            try:</span>
<span class="gi">+                datagram = self._socket.recv(QUIC_MAX_DATAGRAM)</span>
<span class="gi">+            except BlockingIOError:</span>
<span class="gi">+                return</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                self._connection.receive_datagram(datagram, self._peer, time.time())</span>

<span class="gd">-class SyncQuicManager(BaseQuicManager):</span>
<span class="gi">+    def _drain_wakeup(self):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._receive_wakeup.recv(32)</span>
<span class="gi">+            except BlockingIOError:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    def _worker(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            sel = _selector_class()</span>
<span class="gi">+            sel.register(self._socket, selectors.EVENT_READ, self._read)</span>
<span class="gi">+            sel.register(self._receive_wakeup, selectors.EVENT_READ, self._drain_wakeup)</span>
<span class="gi">+            while not self._done:</span>
<span class="gi">+                (expiration, interval) = self._get_timer_values(False)</span>
<span class="gi">+                items = sel.select(interval)</span>
<span class="gi">+                for key, _ in items:</span>
<span class="gi">+                    key.data()</span>
<span class="gi">+                with self._lock:</span>
<span class="gi">+                    self._handle_timer(expiration)</span>
<span class="gi">+                self._handle_events()</span>
<span class="gi">+                with self._lock:</span>
<span class="gi">+                    datagrams = self._connection.datagrams_to_send(time.time())</span>
<span class="gi">+                for datagram, _ in datagrams:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        self._socket.send(datagram)</span>
<span class="gi">+                    except BlockingIOError:</span>
<span class="gi">+                        # we let QUIC handle any lossage</span>
<span class="gi">+                        pass</span>
<span class="gi">+        finally:</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                self._done = True</span>
<span class="gi">+            # Ensure anyone waiting for this gets woken up.</span>
<span class="gi">+            self._handshake_complete.set()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_events(self):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                event = self._connection.next_event()</span>
<span class="gi">+            if event is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            if isinstance(event, aioquic.quic.events.StreamDataReceived):</span>
<span class="gi">+                with self._lock:</span>
<span class="gi">+                    stream = self._streams.get(event.stream_id)</span>
<span class="gi">+                if stream:</span>
<span class="gi">+                    stream._add_input(event.data, event.end_stream)</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.HandshakeCompleted):</span>
<span class="gi">+                self._handshake_complete.set()</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.ConnectionTerminated):</span>
<span class="gi">+                with self._lock:</span>
<span class="gi">+                    self._done = True</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.StreamReset):</span>
<span class="gi">+                with self._lock:</span>
<span class="gi">+                    stream = self._streams.get(event.stream_id)</span>
<span class="gi">+                if stream:</span>
<span class="gi">+                    stream._add_input(b&quot;&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, stream, data, is_end=False):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._connection.send_stream_data(stream, data, is_end)</span>
<span class="gi">+        self._send_wakeup.send(b&quot;\x01&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._worker_thread = threading.Thread(target=self._worker)</span>
<span class="gi">+        self._worker_thread.start()</span>
<span class="gi">+</span>
<span class="gi">+    def make_stream(self, timeout=None):</span>
<span class="gi">+        if not self._handshake_complete.wait(timeout):</span>
<span class="gi">+            raise dns.exception.Timeout</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            if self._done:</span>
<span class="gi">+                raise UnexpectedEOF</span>
<span class="gi">+            stream_id = self._connection.get_next_available_stream_id(False)</span>
<span class="gi">+            stream = SyncQuicStream(self, stream_id)</span>
<span class="gi">+            self._streams[stream_id] = stream</span>
<span class="gi">+        return stream</span>
<span class="gi">+</span>
<span class="gi">+    def close_stream(self, stream_id):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            super().close_stream(stream_id)</span>

<span class="gd">-    def __init__(self, conf=None, verify_mode=ssl.CERT_REQUIRED,</span>
<span class="gd">-        server_name=None):</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            if self._closed:</span>
<span class="gi">+                return</span>
<span class="gi">+            self._manager.closed(self._peer[0], self._peer[1])</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            self._connection.close()</span>
<span class="gi">+            self._send_wakeup.send(b&quot;\x01&quot;)</span>
<span class="gi">+        self._worker_thread.join()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class SyncQuicManager(BaseQuicManager):</span>
<span class="gi">+    def __init__(self, conf=None, verify_mode=ssl.CERT_REQUIRED, server_name=None):</span>
<span class="w"> </span>        super().__init__(conf, verify_mode, SyncQuicConnection, server_name)
<span class="w"> </span>        self._lock = threading.Lock()

<span class="gi">+    def connect(</span>
<span class="gi">+        self, address, port=853, source=None, source_port=0, want_session_ticket=True</span>
<span class="gi">+    ):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            (connection, start) = self._connect(</span>
<span class="gi">+                address, port, source, source_port, want_session_ticket</span>
<span class="gi">+            )</span>
<span class="gi">+            if start:</span>
<span class="gi">+                connection.run()</span>
<span class="gi">+            return connection</span>
<span class="gi">+</span>
<span class="gi">+    def closed(self, address, port):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            super().closed(address, port)</span>
<span class="gi">+</span>
<span class="gi">+    def save_session_ticket(self, address, port, ticket):</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            super().save_session_ticket(address, port, ticket)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="w"> </span>    def __exit__(self, exc_type, exc_val, exc_tb):
<span class="gi">+        # Copy the iterator into a list as exiting things will mutate the connections</span>
<span class="gi">+        # table.</span>
<span class="w"> </span>        connections = list(self._connections.values())
<span class="w"> </span>        for connection in connections:
<span class="w"> </span>            connection.close()
<span class="gh">diff --git a/dns/quic/_trio.py b/dns/quic/_trio.py</span>
<span class="gh">index 70d5e90..35e36b9 100644</span>
<span class="gd">--- a/dns/quic/_trio.py</span>
<span class="gi">+++ b/dns/quic/_trio.py</span>
<span class="gu">@@ -1,23 +1,67 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="gd">-import aioquic.quic.configuration</span>
<span class="gd">-import aioquic.quic.connection</span>
<span class="gd">-import aioquic.quic.events</span>
<span class="gi">+</span>
<span class="gi">+import aioquic.quic.configuration  # type: ignore</span>
<span class="gi">+import aioquic.quic.connection  # type: ignore</span>
<span class="gi">+import aioquic.quic.events  # type: ignore</span>
<span class="w"> </span>import trio
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.inet
<span class="w"> </span>from dns._asyncbackend import NullContext
<span class="gd">-from dns.quic._common import QUIC_MAX_DATAGRAM, AsyncQuicConnection, AsyncQuicManager, BaseQuicStream, UnexpectedEOF</span>
<span class="gi">+from dns.quic._common import (</span>
<span class="gi">+    QUIC_MAX_DATAGRAM,</span>
<span class="gi">+    AsyncQuicConnection,</span>
<span class="gi">+    AsyncQuicManager,</span>
<span class="gi">+    BaseQuicStream,</span>
<span class="gi">+    UnexpectedEOF,</span>
<span class="gi">+)</span>


<span class="w"> </span>class TrioQuicStream(BaseQuicStream):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, connection, stream_id):
<span class="w"> </span>        super().__init__(connection, stream_id)
<span class="w"> </span>        self._wake_up = trio.Condition()

<span class="gi">+    async def wait_for(self, amount):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if self._buffer.have(amount):</span>
<span class="gi">+                return</span>
<span class="gi">+            self._expecting = amount</span>
<span class="gi">+            async with self._wake_up:</span>
<span class="gi">+                await self._wake_up.wait()</span>
<span class="gi">+            self._expecting = 0</span>
<span class="gi">+</span>
<span class="gi">+    async def receive(self, timeout=None):</span>
<span class="gi">+        if timeout is None:</span>
<span class="gi">+            context = NullContext(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            context = trio.move_on_after(timeout)</span>
<span class="gi">+        with context:</span>
<span class="gi">+            await self.wait_for(2)</span>
<span class="gi">+            (size,) = struct.unpack(&quot;!H&quot;, self._buffer.get(2))</span>
<span class="gi">+            await self.wait_for(size)</span>
<span class="gi">+            return self._buffer.get(size)</span>
<span class="gi">+        raise dns.exception.Timeout</span>
<span class="gi">+</span>
<span class="gi">+    async def send(self, datagram, is_end=False):</span>
<span class="gi">+        data = self._encapsulate(datagram)</span>
<span class="gi">+        await self._connection.write(self._stream_id, data, is_end)</span>
<span class="gi">+</span>
<span class="gi">+    async def _add_input(self, data, is_end):</span>
<span class="gi">+        if self._common_add_input(data, is_end):</span>
<span class="gi">+            async with self._wake_up:</span>
<span class="gi">+                self._wake_up.notify()</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self._close()</span>
<span class="gi">+</span>
<span class="gi">+    # Streams are async context managers</span>
<span class="gi">+</span>
<span class="w"> </span>    async def __aenter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -29,29 +73,137 @@ class TrioQuicStream(BaseQuicStream):</span>


<span class="w"> </span>class TrioQuicConnection(AsyncQuicConnection):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, connection, address, port, source, source_port,</span>
<span class="gd">-        manager=None):</span>
<span class="gd">-        super().__init__(connection, address, port, source, source_port,</span>
<span class="gd">-            manager)</span>
<span class="gi">+    def __init__(self, connection, address, port, source, source_port, manager=None):</span>
<span class="gi">+        super().__init__(connection, address, port, source, source_port, manager)</span>
<span class="w"> </span>        self._socket = trio.socket.socket(self._af, socket.SOCK_DGRAM, 0)
<span class="w"> </span>        self._handshake_complete = trio.Event()
<span class="w"> </span>        self._run_done = trio.Event()
<span class="w"> </span>        self._worker_scope = None
<span class="w"> </span>        self._send_pending = False

<span class="gi">+    async def _worker(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self._source:</span>
<span class="gi">+                await self._socket.bind(</span>
<span class="gi">+                    dns.inet.low_level_address_tuple(self._source, self._af)</span>
<span class="gi">+                )</span>
<span class="gi">+            await self._socket.connect(self._peer)</span>
<span class="gi">+            while not self._done:</span>
<span class="gi">+                (expiration, interval) = self._get_timer_values(False)</span>
<span class="gi">+                if self._send_pending:</span>
<span class="gi">+                    # Do not block forever if sends are pending.  Even though we</span>
<span class="gi">+                    # have a wake-up mechanism if we&#39;ve already started the blocking</span>
<span class="gi">+                    # read, the possibility of context switching in send means that</span>
<span class="gi">+                    # more writes can happen while we have no wake up context, so</span>
<span class="gi">+                    # we need self._send_pending to avoid (effectively) a &quot;lost wakeup&quot;</span>
<span class="gi">+                    # race.</span>
<span class="gi">+                    interval = 0.0</span>
<span class="gi">+                with trio.CancelScope(</span>
<span class="gi">+                    deadline=trio.current_time() + interval</span>
<span class="gi">+                ) as self._worker_scope:</span>
<span class="gi">+                    datagram = await self._socket.recv(QUIC_MAX_DATAGRAM)</span>
<span class="gi">+                    self._connection.receive_datagram(datagram, self._peer, time.time())</span>
<span class="gi">+                self._worker_scope = None</span>
<span class="gi">+                self._handle_timer(expiration)</span>
<span class="gi">+                await self._handle_events()</span>
<span class="gi">+                # We clear this now, before sending anything, as sending can cause</span>
<span class="gi">+                # context switches that do more sends.  We want to know if that</span>
<span class="gi">+                # happens so we don&#39;t block a long time on the recv() above.</span>
<span class="gi">+                self._send_pending = False</span>
<span class="gi">+                datagrams = self._connection.datagrams_to_send(time.time())</span>
<span class="gi">+                for datagram, _ in datagrams:</span>
<span class="gi">+                    await self._socket.send(datagram)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._done = True</span>
<span class="gi">+            self._handshake_complete.set()</span>

<span class="gd">-class TrioQuicManager(AsyncQuicManager):</span>
<span class="gi">+    async def _handle_events(self):</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            event = self._connection.next_event()</span>
<span class="gi">+            if event is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            if isinstance(event, aioquic.quic.events.StreamDataReceived):</span>
<span class="gi">+                stream = self._streams.get(event.stream_id)</span>
<span class="gi">+                if stream:</span>
<span class="gi">+                    await stream._add_input(event.data, event.end_stream)</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.HandshakeCompleted):</span>
<span class="gi">+                self._handshake_complete.set()</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.ConnectionTerminated):</span>
<span class="gi">+                self._done = True</span>
<span class="gi">+                self._socket.close()</span>
<span class="gi">+            elif isinstance(event, aioquic.quic.events.StreamReset):</span>
<span class="gi">+                stream = self._streams.get(event.stream_id)</span>
<span class="gi">+                if stream:</span>
<span class="gi">+                    await stream._add_input(b&quot;&quot;, True)</span>
<span class="gi">+            count += 1</span>
<span class="gi">+            if count &gt; 10:</span>
<span class="gi">+                # yield</span>
<span class="gi">+                count = 0</span>
<span class="gi">+                await trio.sleep(0)</span>
<span class="gi">+</span>
<span class="gi">+    async def write(self, stream, data, is_end=False):</span>
<span class="gi">+        self._connection.send_stream_data(stream, data, is_end)</span>
<span class="gi">+        self._send_pending = True</span>
<span class="gi">+        if self._worker_scope is not None:</span>
<span class="gi">+            self._worker_scope.cancel()</span>
<span class="gi">+</span>
<span class="gi">+    async def run(self):</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        async with trio.open_nursery() as nursery:</span>
<span class="gi">+            nursery.start_soon(self._worker)</span>
<span class="gi">+        self._run_done.set()</span>
<span class="gi">+</span>
<span class="gi">+    async def make_stream(self, timeout=None):</span>
<span class="gi">+        if timeout is None:</span>
<span class="gi">+            context = NullContext(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            context = trio.move_on_after(timeout)</span>
<span class="gi">+        with context:</span>
<span class="gi">+            await self._handshake_complete.wait()</span>
<span class="gi">+            if self._done:</span>
<span class="gi">+                raise UnexpectedEOF</span>
<span class="gi">+            stream_id = self._connection.get_next_available_stream_id(False)</span>
<span class="gi">+            stream = TrioQuicStream(self, stream_id)</span>
<span class="gi">+            self._streams[stream_id] = stream</span>
<span class="gi">+            return stream</span>
<span class="gi">+        raise dns.exception.Timeout</span>

<span class="gd">-    def __init__(self, nursery, conf=None, verify_mode=ssl.CERT_REQUIRED,</span>
<span class="gd">-        server_name=None):</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._manager.closed(self._peer[0], self._peer[1])</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            self._connection.close()</span>
<span class="gi">+            self._send_pending = True</span>
<span class="gi">+            if self._worker_scope is not None:</span>
<span class="gi">+                self._worker_scope.cancel()</span>
<span class="gi">+            await self._run_done.wait()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class TrioQuicManager(AsyncQuicManager):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, nursery, conf=None, verify_mode=ssl.CERT_REQUIRED, server_name=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(conf, verify_mode, TrioQuicConnection, server_name)
<span class="w"> </span>        self._nursery = nursery

<span class="gi">+    def connect(</span>
<span class="gi">+        self, address, port=853, source=None, source_port=0, want_session_ticket=True</span>
<span class="gi">+    ):</span>
<span class="gi">+        (connection, start) = self._connect(</span>
<span class="gi">+            address, port, source, source_port, want_session_ticket</span>
<span class="gi">+        )</span>
<span class="gi">+        if start:</span>
<span class="gi">+            self._nursery.start_soon(connection.run)</span>
<span class="gi">+        return connection</span>
<span class="gi">+</span>
<span class="w"> </span>    async def __aenter__(self):
<span class="w"> </span>        return self

<span class="w"> </span>    async def __aexit__(self, exc_type, exc_val, exc_tb):
<span class="gi">+        # Copy the iterator into a list as exiting things will mutate the connections</span>
<span class="gi">+        # table.</span>
<span class="w"> </span>        connections = list(self._connections.values())
<span class="w"> </span>        for connection in connections:
<span class="w"> </span>            await connection.close()
<span class="gh">diff --git a/dns/rcode.py b/dns/rcode.py</span>
<span class="gh">index 820a695..8e6386f 100644</span>
<span class="gd">--- a/dns/rcode.py</span>
<span class="gi">+++ b/dns/rcode.py</span>
<span class="gu">@@ -1,38 +1,86 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Result Codes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Tuple
<span class="gi">+</span>
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.exception


<span class="w"> </span>class Rcode(dns.enum.IntEnum):
<span class="gi">+    #: No error</span>
<span class="w"> </span>    NOERROR = 0
<span class="gi">+    #: Format error</span>
<span class="w"> </span>    FORMERR = 1
<span class="gi">+    #: Server failure</span>
<span class="w"> </span>    SERVFAIL = 2
<span class="gi">+    #: Name does not exist (&quot;Name Error&quot; in RFC 1025 terminology).</span>
<span class="w"> </span>    NXDOMAIN = 3
<span class="gi">+    #: Not implemented</span>
<span class="w"> </span>    NOTIMP = 4
<span class="gi">+    #: Refused</span>
<span class="w"> </span>    REFUSED = 5
<span class="gi">+    #: Name exists.</span>
<span class="w"> </span>    YXDOMAIN = 6
<span class="gi">+    #: RRset exists.</span>
<span class="w"> </span>    YXRRSET = 7
<span class="gi">+    #: RRset does not exist.</span>
<span class="w"> </span>    NXRRSET = 8
<span class="gi">+    #: Not authoritative.</span>
<span class="w"> </span>    NOTAUTH = 9
<span class="gi">+    #: Name not in zone.</span>
<span class="w"> </span>    NOTZONE = 10
<span class="gi">+    #: DSO-TYPE Not Implemented</span>
<span class="w"> </span>    DSOTYPENI = 11
<span class="gi">+    #: Bad EDNS version.</span>
<span class="w"> </span>    BADVERS = 16
<span class="gi">+    #: TSIG Signature Failure</span>
<span class="w"> </span>    BADSIG = 16
<span class="gi">+    #: Key not recognized.</span>
<span class="w"> </span>    BADKEY = 17
<span class="gi">+    #: Signature out of time window.</span>
<span class="w"> </span>    BADTIME = 18
<span class="gi">+    #: Bad TKEY Mode.</span>
<span class="w"> </span>    BADMODE = 19
<span class="gi">+    #: Duplicate key name.</span>
<span class="w"> </span>    BADNAME = 20
<span class="gi">+    #: Algorithm not supported.</span>
<span class="w"> </span>    BADALG = 21
<span class="gi">+    #: Bad Truncation</span>
<span class="w"> </span>    BADTRUNC = 22
<span class="gi">+    #: Bad/missing Server Cookie</span>
<span class="w"> </span>    BADCOOKIE = 23

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 4095</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _unknown_exception_class(cls):</span>
<span class="gi">+        return UnknownRcode</span>
<span class="gi">+</span>

<span class="w"> </span>class UnknownRcode(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;A DNS rcode is unknown.&quot;&quot;&quot;


<span class="gd">-def from_text(text: str) -&gt;Rcode:</span>
<span class="gi">+def from_text(text: str) -&gt; Rcode:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert text into an rcode.

<span class="w"> </span>    *text*, a ``str``, the textual rcode or an integer in textual form.
<span class="gu">@@ -41,10 +89,11 @@ def from_text(text: str) -&gt;Rcode:</span>

<span class="w"> </span>    Returns a ``dns.rcode.Rcode``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return Rcode.from_text(text)</span>


<span class="gd">-def from_flags(flags: int, ednsflags: int) -&gt;Rcode:</span>
<span class="gi">+def from_flags(flags: int, ednsflags: int) -&gt; Rcode:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the rcode value encoded by flags and ednsflags.

<span class="w"> </span>    *flags*, an ``int``, the DNS flags field.
<span class="gu">@@ -55,10 +104,12 @@ def from_flags(flags: int, ednsflags: int) -&gt;Rcode:</span>

<span class="w"> </span>    Returns a ``dns.rcode.Rcode``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    value = (flags &amp; 0x000F) | ((ednsflags &gt;&gt; 20) &amp; 0xFF0)</span>
<span class="gi">+    return Rcode.make(value)</span>

<span class="gd">-def to_flags(value: Rcode) -&gt;Tuple[int, int]:</span>
<span class="gi">+</span>
<span class="gi">+def to_flags(value: Rcode) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a (flags, ednsflags) tuple which encodes the rcode.

<span class="w"> </span>    *value*, a ``dns.rcode.Rcode``, the rcode.
<span class="gu">@@ -67,10 +118,15 @@ def to_flags(value: Rcode) -&gt;Tuple[int, int]:</span>

<span class="w"> </span>    Returns an ``(int, int)`` tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if value &lt; 0 or value &gt; 4095:</span>
<span class="gi">+        raise ValueError(&quot;rcode must be &gt;= 0 and &lt;= 4095&quot;)</span>
<span class="gi">+    v = value &amp; 0xF</span>
<span class="gi">+    ev = (value &amp; 0xFF0) &lt;&lt; 20</span>
<span class="gi">+    return (v, ev)</span>


<span class="gd">-def to_text(value: Rcode, tsig: bool=False) -&gt;str:</span>
<span class="gi">+def to_text(value: Rcode, tsig: bool = False) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert rcode into text.

<span class="w"> </span>    *value*, a ``dns.rcode.Rcode``, the rcode.
<span class="gu">@@ -79,9 +135,14 @@ def to_text(value: Rcode, tsig: bool=False) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if tsig and value == Rcode.BADVERS:</span>
<span class="gi">+        return &quot;BADSIG&quot;</span>
<span class="gi">+    return Rcode.to_text(value)</span>


<span class="gi">+### BEGIN generated Rcode constants</span>
<span class="gi">+</span>
<span class="w"> </span>NOERROR = Rcode.NOERROR
<span class="w"> </span>FORMERR = Rcode.FORMERR
<span class="w"> </span>SERVFAIL = Rcode.SERVFAIL
<span class="gu">@@ -103,3 +164,5 @@ BADNAME = Rcode.BADNAME</span>
<span class="w"> </span>BADALG = Rcode.BADALG
<span class="w"> </span>BADTRUNC = Rcode.BADTRUNC
<span class="w"> </span>BADCOOKIE = Rcode.BADCOOKIE
<span class="gi">+</span>
<span class="gi">+### END generated Rcode constants</span>
<span class="gh">diff --git a/dns/rdata.py b/dns/rdata.py</span>
<span class="gh">index 11cbf5e..024fd8f 100644</span>
<span class="gd">--- a/dns/rdata.py</span>
<span class="gi">+++ b/dns/rdata.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS rdata.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import binascii
<span class="w"> </span>import inspect
<span class="gu">@@ -7,6 +25,7 @@ import itertools</span>
<span class="w"> </span>import random
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from typing import Any, Dict, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.ipv4
<span class="gu">@@ -17,7 +36,15 @@ import dns.rdatatype</span>
<span class="w"> </span>import dns.tokenizer
<span class="w"> </span>import dns.ttl
<span class="w"> </span>import dns.wire
<span class="gi">+</span>
<span class="w"> </span>_chunksize = 32
<span class="gi">+</span>
<span class="gi">+# We currently allow comparisons for rdata with relative names for backwards</span>
<span class="gi">+# compatibility, but in the future we will not, as these kinds of comparisons</span>
<span class="gi">+# can lead to subtle bugs if code is not carefully written.</span>
<span class="gi">+#</span>
<span class="gi">+# This switch allows the future behavior to be turned on so code can be</span>
<span class="gi">+# tested with it.</span>
<span class="w"> </span>_allow_relative_comparisons = True


<span class="gu">@@ -29,49 +56,81 @@ class NoRelativeRdataOrdering(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gd">-def _wordbreak(data, chunksize=_chunksize, separator=b&#39; &#39;):</span>
<span class="gi">+def _wordbreak(data, chunksize=_chunksize, separator=b&quot; &quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Break a binary string into chunks of chunksize characters separated by
<span class="w"> </span>    a space.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if not chunksize:</span>
<span class="gi">+        return data.decode()</span>
<span class="gi">+    return separator.join(</span>
<span class="gi">+        [data[i : i + chunksize] for i in range(0, len(data), chunksize)]</span>
<span class="gi">+    ).decode()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=unused-argument</span>

<span class="gd">-def _hexify(data, chunksize=_chunksize, separator=b&#39; &#39;, **kw):</span>
<span class="gi">+</span>
<span class="gi">+def _hexify(data, chunksize=_chunksize, separator=b&quot; &quot;, **kw):</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a binary string into its hex encoding, broken up into chunks
<span class="w"> </span>    of chunksize characters separated by a separator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return _wordbreak(binascii.hexlify(data), chunksize, separator)</span>


<span class="gd">-def _base64ify(data, chunksize=_chunksize, separator=b&#39; &#39;, **kw):</span>
<span class="gi">+def _base64ify(data, chunksize=_chunksize, separator=b&quot; &quot;, **kw):</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a binary string into its base64 encoding, broken up into chunks
<span class="w"> </span>    of chunksize characters separated by a separator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return _wordbreak(base64.b64encode(data), chunksize, separator)</span>


<span class="gi">+# pylint: enable=unused-argument</span>
<span class="gi">+</span>
<span class="w"> </span>__escaped = b&#39;&quot;\\&#39;


<span class="w"> </span>def _escapify(qstring):
<span class="w"> </span>    &quot;&quot;&quot;Escape the characters in a quoted string which need it.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(qstring, str):</span>
<span class="gi">+        qstring = qstring.encode()</span>
<span class="gi">+    if not isinstance(qstring, bytearray):</span>
<span class="gi">+        qstring = bytearray(qstring)</span>
<span class="gi">+</span>
<span class="gi">+    text = &quot;&quot;</span>
<span class="gi">+    for c in qstring:</span>
<span class="gi">+        if c in __escaped:</span>
<span class="gi">+            text += &quot;\\&quot; + chr(c)</span>
<span class="gi">+        elif c &gt;= 0x20 and c &lt; 0x7F:</span>
<span class="gi">+            text += chr(c)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text += &quot;\\%03d&quot; % c</span>
<span class="gi">+    return text</span>


<span class="w"> </span>def _truncate_bitmap(what):
<span class="w"> </span>    &quot;&quot;&quot;Determine the index of greatest byte that isn&#39;t all zeros, and
<span class="w"> </span>    return the bitmap that contains all the bytes less than that index.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    for i in range(len(what) - 1, -1, -1):</span>
<span class="gi">+        if what[i] != 0:</span>
<span class="gi">+            return what[0 : i + 1]</span>
<span class="gi">+    return what[0:1]</span>

<span class="gi">+</span>
<span class="gi">+# So we don&#39;t have to edit all the rdata classes...</span>
<span class="w"> </span>_constify = dns.immutable.constify


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class Rdata:
<span class="w"> </span>    &quot;&quot;&quot;Base class for all DNS rdata types.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;rdclass&#39;, &#39;rdtype&#39;, &#39;rdcomment&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;rdclass&quot;, &quot;rdtype&quot;, &quot;rdcomment&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype):
<span class="w"> </span>        &quot;&quot;&quot;Initialize an rdata.
<span class="gu">@@ -80,11 +139,25 @@ class Rdata:</span>

<span class="w"> </span>        *rdtype*, an ``int`` is the rdatatype of the Rdata.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.rdclass = self._as_rdataclass(rdclass)
<span class="w"> </span>        self.rdtype = self._as_rdatatype(rdtype)
<span class="w"> </span>        self.rdcomment = None

<span class="gi">+    def _get_all_slots(self):</span>
<span class="gi">+        return itertools.chain.from_iterable(</span>
<span class="gi">+            getattr(cls, &quot;__slots__&quot;, []) for cls in self.__class__.__mro__</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getstate__(self):
<span class="gi">+        # We used to try to do a tuple of all slots here, but it</span>
<span class="gi">+        # doesn&#39;t work as self._all_slots isn&#39;t available at</span>
<span class="gi">+        # __setstate__() time.  Before that we tried to store a tuple</span>
<span class="gi">+        # of __slots__, but that didn&#39;t work as it didn&#39;t store the</span>
<span class="gi">+        # slots defined by ancestors.  This older way didn&#39;t fail</span>
<span class="gi">+        # outright, but ended up with partially broken objects, e.g.</span>
<span class="gi">+        # if you unpickled an A RR it wouldn&#39;t have rdclass and rdtype</span>
<span class="gi">+        # attributes, and would compare badly.</span>
<span class="w"> </span>        state = {}
<span class="w"> </span>        for slot in self._get_all_slots():
<span class="w"> </span>            state[slot] = getattr(self, slot)
<span class="gu">@@ -93,10 +166,12 @@ class Rdata:</span>
<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        for slot, val in state.items():
<span class="w"> </span>            object.__setattr__(self, slot, val)
<span class="gd">-        if not hasattr(self, &#39;rdcomment&#39;):</span>
<span class="gd">-            object.__setattr__(self, &#39;rdcomment&#39;, None)</span>
<span class="gi">+        if not hasattr(self, &quot;rdcomment&quot;):</span>
<span class="gi">+            # Pickled rdata from 2.0.x might not have a rdcomment, so add</span>
<span class="gi">+            # it if needed.</span>
<span class="gi">+            object.__setattr__(self, &quot;rdcomment&quot;, None)</span>

<span class="gd">-    def covers(self) -&gt;dns.rdatatype.RdataType:</span>
<span class="gi">+    def covers(self) -&gt; dns.rdatatype.RdataType:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the type a Rdata covers.

<span class="w"> </span>        DNS SIG/RRSIG rdatas apply to a specific type; this type is
<span class="gu">@@ -107,59 +182,96 @@ class Rdata:</span>

<span class="w"> </span>        Returns a ``dns.rdatatype.RdataType``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def extended_rdatatype(self) -&gt;int:</span>
<span class="gi">+        return dns.rdatatype.NONE</span>
<span class="gi">+</span>
<span class="gi">+    def extended_rdatatype(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a 32-bit type value, the least significant 16 bits of
<span class="w"> </span>        which are the ordinary DNS type, and the upper 16 bits of which are
<span class="w"> </span>        the &quot;covered&quot; type, if any.

<span class="w"> </span>        Returns an ``int``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_text(self, origin: Optional[dns.name.Name]=None, relativize:</span>
<span class="gd">-        bool=True, **kw: Dict[str, Any]) -&gt;str:</span>
<span class="gi">+        return self.covers() &lt;&lt; 16 | self.rdtype</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert an rdata to text format.

<span class="w"> </span>        Returns a ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_wire(self, file: Optional[Any]=None, compress: Optional[dns.name</span>
<span class="gd">-        .CompressType]=None, origin: Optional[dns.name.Name]=None,</span>
<span class="gd">-        canonicalize: bool=False) -&gt;bytes:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        file: Optional[Any],</span>
<span class="gi">+        compress: Optional[dns.name.CompressType] = None,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        canonicalize: bool = False,</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        file: Optional[Any] = None,</span>
<span class="gi">+        compress: Optional[dns.name.CompressType] = None,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        canonicalize: bool = False,</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert an rdata to wire format.

<span class="w"> </span>        Returns a ``bytes`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_generic(self, origin: Optional[dns.name.Name]=None</span>
<span class="gd">-        ) -&gt;&#39;dns.rdata.GenericRdata&#39;:</span>
<span class="gi">+        if file:</span>
<span class="gi">+            return self._to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+        else:</span>
<span class="gi">+            f = io.BytesIO()</span>
<span class="gi">+            self._to_wire(f, compress, origin, canonicalize)</span>
<span class="gi">+            return f.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+    def to_generic(</span>
<span class="gi">+        self, origin: Optional[dns.name.Name] = None</span>
<span class="gi">+    ) -&gt; &quot;dns.rdata.GenericRdata&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a dns.rdata.GenericRdata equivalent of this rdata.

<span class="w"> </span>        Returns a ``dns.rdata.GenericRdata``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dns.rdata.GenericRdata(</span>
<span class="gi">+            self.rdclass, self.rdtype, self.to_wire(origin=origin)</span>
<span class="gi">+        )</span>

<span class="gd">-    def to_digestable(self, origin: Optional[dns.name.Name]=None) -&gt;bytes:</span>
<span class="gi">+    def to_digestable(self, origin: Optional[dns.name.Name] = None) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert rdata to a format suitable for digesting in hashes.  This
<span class="w"> </span>        is also the DNSSEC canonical form.

<span class="w"> </span>        Returns a ``bytes``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return self.to_wire(origin=origin, canonicalize=True)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        covers = self.covers()
<span class="w"> </span>        if covers == dns.rdatatype.NONE:
<span class="gd">-            ctext = &#39;&#39;</span>
<span class="gi">+            ctext = &quot;&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            ctext = &#39;(&#39; + dns.rdatatype.to_text(covers) + &#39;)&#39;</span>
<span class="gd">-        return &#39;&lt;DNS &#39; + dns.rdataclass.to_text(self.rdclass</span>
<span class="gd">-            ) + &#39; &#39; + dns.rdatatype.to_text(self.rdtype</span>
<span class="gd">-            ) + ctext + &#39; rdata: &#39; + str(self) + &#39;&gt;&#39;</span>
<span class="gi">+            ctext = &quot;(&quot; + dns.rdatatype.to_text(covers) + &quot;)&quot;</span>
<span class="gi">+        return (</span>
<span class="gi">+            &quot;&lt;DNS &quot;</span>
<span class="gi">+            + dns.rdataclass.to_text(self.rdclass)</span>
<span class="gi">+            + &quot; &quot;</span>
<span class="gi">+            + dns.rdatatype.to_text(self.rdtype)</span>
<span class="gi">+            + ctext</span>
<span class="gi">+            + &quot; rdata: &quot;</span>
<span class="gi">+            + str(self)</span>
<span class="gi">+            + &quot;&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.to_text()
<span class="gu">@@ -180,7 +292,36 @@ class Rdata:</span>
<span class="w"> </span>            In the future, all ordering comparisons for rdata with
<span class="w"> </span>            relative names will be disallowed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            our = self.to_digestable()</span>
<span class="gi">+            our_relative = False</span>
<span class="gi">+        except dns.name.NeedAbsoluteNameOrOrigin:</span>
<span class="gi">+            if _allow_relative_comparisons:</span>
<span class="gi">+                our = self.to_digestable(dns.name.root)</span>
<span class="gi">+            our_relative = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            their = other.to_digestable()</span>
<span class="gi">+            their_relative = False</span>
<span class="gi">+        except dns.name.NeedAbsoluteNameOrOrigin:</span>
<span class="gi">+            if _allow_relative_comparisons:</span>
<span class="gi">+                their = other.to_digestable(dns.name.root)</span>
<span class="gi">+            their_relative = True</span>
<span class="gi">+        if _allow_relative_comparisons:</span>
<span class="gi">+            if our_relative != their_relative:</span>
<span class="gi">+                # For the purpose of comparison, all rdata with at least one</span>
<span class="gi">+                # relative name is less than an rdata with only absolute names.</span>
<span class="gi">+                if our_relative:</span>
<span class="gi">+                    return -1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return 1</span>
<span class="gi">+        elif our_relative or their_relative:</span>
<span class="gi">+            raise NoRelativeRdataOrdering</span>
<span class="gi">+        if our == their:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        elif our &gt; their:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            return -1</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Rdata):
<span class="gu">@@ -211,33 +352,67 @@ class Rdata:</span>
<span class="w"> </span>        return not self.__eq__(other)

<span class="w"> </span>    def __lt__(self, other):
<span class="gd">-        if not isinstance(other, Rdata</span>
<span class="gd">-            ) or self.rdclass != other.rdclass or self.rdtype != other.rdtype:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(other, Rdata)</span>
<span class="gi">+            or self.rdclass != other.rdclass</span>
<span class="gi">+            or self.rdtype != other.rdtype</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self._cmp(other) &lt; 0

<span class="w"> </span>    def __le__(self, other):
<span class="gd">-        if not isinstance(other, Rdata</span>
<span class="gd">-            ) or self.rdclass != other.rdclass or self.rdtype != other.rdtype:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(other, Rdata)</span>
<span class="gi">+            or self.rdclass != other.rdclass</span>
<span class="gi">+            or self.rdtype != other.rdtype</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self._cmp(other) &lt;= 0

<span class="w"> </span>    def __ge__(self, other):
<span class="gd">-        if not isinstance(other, Rdata</span>
<span class="gd">-            ) or self.rdclass != other.rdclass or self.rdtype != other.rdtype:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(other, Rdata)</span>
<span class="gi">+            or self.rdclass != other.rdclass</span>
<span class="gi">+            or self.rdtype != other.rdtype</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self._cmp(other) &gt;= 0

<span class="w"> </span>    def __gt__(self, other):
<span class="gd">-        if not isinstance(other, Rdata</span>
<span class="gd">-            ) or self.rdclass != other.rdclass or self.rdtype != other.rdtype:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(other, Rdata)</span>
<span class="gi">+            or self.rdclass != other.rdclass</span>
<span class="gi">+            or self.rdtype != other.rdtype</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self._cmp(other) &gt; 0

<span class="w"> </span>    def __hash__(self):
<span class="w"> </span>        return hash(self.to_digestable(dns.name.root))

<span class="gd">-    def replace(self, **kwargs: Any) -&gt;&#39;Rdata&#39;:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        tok: dns.tokenizer.Tokenizer,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+    ) -&gt; &quot;Rdata&quot;:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        parser: dns.wire.Parser,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    ) -&gt; &quot;Rdata&quot;:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    def replace(self, **kwargs: Any) -&gt; &quot;Rdata&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new Rdata instance based on the instance replace was
<span class="w"> </span>        invoked on. It is possible to pass different parameters to
<span class="gu">@@ -248,7 +423,179 @@ class Rdata:</span>

<span class="w"> </span>        Returns an instance of the same Rdata subclass as *self*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Get the constructor parameters.</span>
<span class="gi">+        parameters = inspect.signature(self.__init__).parameters  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        # Ensure that all of the arguments correspond to valid fields.</span>
<span class="gi">+        # Don&#39;t allow rdclass or rdtype to be changed, though.</span>
<span class="gi">+        for key in kwargs:</span>
<span class="gi">+            if key == &quot;rdcomment&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if key not in parameters:</span>
<span class="gi">+                raise AttributeError(</span>
<span class="gi">+                    &quot;&#39;{}&#39; object has no attribute &#39;{}&#39;&quot;.format(</span>
<span class="gi">+                        self.__class__.__name__, key</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            if key in (&quot;rdclass&quot;, &quot;rdtype&quot;):</span>
<span class="gi">+                raise AttributeError(</span>
<span class="gi">+                    &quot;Cannot overwrite &#39;{}&#39; attribute &#39;{}&#39;&quot;.format(</span>
<span class="gi">+                        self.__class__.__name__, key</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # Construct the parameter list.  For each field, use the value in</span>
<span class="gi">+        # kwargs if present, and the current value otherwise.</span>
<span class="gi">+        args = (kwargs.get(key, getattr(self, key)) for key in parameters)</span>
<span class="gi">+</span>
<span class="gi">+        # Create, validate, and return the new object.</span>
<span class="gi">+        rd = self.__class__(*args)</span>
<span class="gi">+        # The comment is not set in the constructor, so give it special</span>
<span class="gi">+        # handling.</span>
<span class="gi">+        rdcomment = kwargs.get(&quot;rdcomment&quot;, self.rdcomment)</span>
<span class="gi">+        if rdcomment is not None:</span>
<span class="gi">+            object.__setattr__(rd, &quot;rdcomment&quot;, rdcomment)</span>
<span class="gi">+        return rd</span>
<span class="gi">+</span>
<span class="gi">+    # Type checking and conversion helpers.  These are class methods as</span>
<span class="gi">+    # they don&#39;t touch object state and may be useful to others.</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_rdataclass(cls, value):</span>
<span class="gi">+        return dns.rdataclass.RdataClass.make(value)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_rdatatype(cls, value):</span>
<span class="gi">+        return dns.rdatatype.RdataType.make(value)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_bytes(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        encode: bool = False,</span>
<span class="gi">+        max_length: Optional[int] = None,</span>
<span class="gi">+        empty_ok: bool = True,</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="gi">+        if encode and isinstance(value, str):</span>
<span class="gi">+            bvalue = value.encode()</span>
<span class="gi">+        elif isinstance(value, bytearray):</span>
<span class="gi">+            bvalue = bytes(value)</span>
<span class="gi">+        elif isinstance(value, bytes):</span>
<span class="gi">+            bvalue = value</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;not bytes&quot;)</span>
<span class="gi">+        if max_length is not None and len(bvalue) &gt; max_length:</span>
<span class="gi">+            raise ValueError(&quot;too long&quot;)</span>
<span class="gi">+        if not empty_ok and len(bvalue) == 0:</span>
<span class="gi">+            raise ValueError(&quot;empty bytes not allowed&quot;)</span>
<span class="gi">+        return bvalue</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_name(cls, value):</span>
<span class="gi">+        # Note that proper name conversion (e.g. with origin and IDNA</span>
<span class="gi">+        # awareness) is expected to be done via from_text.  This is just</span>
<span class="gi">+        # a simple thing for people invoking the constructor directly.</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            return dns.name.from_text(value)</span>
<span class="gi">+        elif not isinstance(value, dns.name.Name):</span>
<span class="gi">+            raise ValueError(&quot;not a name&quot;)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_uint8(cls, value):</span>
<span class="gi">+        if not isinstance(value, int):</span>
<span class="gi">+            raise ValueError(&quot;not an integer&quot;)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 255:</span>
<span class="gi">+            raise ValueError(&quot;not a uint8&quot;)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_uint16(cls, value):</span>
<span class="gi">+        if not isinstance(value, int):</span>
<span class="gi">+            raise ValueError(&quot;not an integer&quot;)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 65535:</span>
<span class="gi">+            raise ValueError(&quot;not a uint16&quot;)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_uint32(cls, value):</span>
<span class="gi">+        if not isinstance(value, int):</span>
<span class="gi">+            raise ValueError(&quot;not an integer&quot;)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 4294967295:</span>
<span class="gi">+            raise ValueError(&quot;not a uint32&quot;)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_uint48(cls, value):</span>
<span class="gi">+        if not isinstance(value, int):</span>
<span class="gi">+            raise ValueError(&quot;not an integer&quot;)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 281474976710655:</span>
<span class="gi">+            raise ValueError(&quot;not a uint48&quot;)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_int(cls, value, low=None, high=None):</span>
<span class="gi">+        if not isinstance(value, int):</span>
<span class="gi">+            raise ValueError(&quot;not an integer&quot;)</span>
<span class="gi">+        if low is not None and value &lt; low:</span>
<span class="gi">+            raise ValueError(&quot;value too small&quot;)</span>
<span class="gi">+        if high is not None and value &gt; high:</span>
<span class="gi">+            raise ValueError(&quot;value too large&quot;)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_ipv4_address(cls, value):</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            return dns.ipv4.canonicalize(value)</span>
<span class="gi">+        elif isinstance(value, bytes):</span>
<span class="gi">+            return dns.ipv4.inet_ntoa(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;not an IPv4 address&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_ipv6_address(cls, value):</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            return dns.ipv6.canonicalize(value)</span>
<span class="gi">+        elif isinstance(value, bytes):</span>
<span class="gi">+            return dns.ipv6.inet_ntoa(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;not an IPv6 address&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_bool(cls, value):</span>
<span class="gi">+        if isinstance(value, bool):</span>
<span class="gi">+            return value</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;not a boolean&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_ttl(cls, value):</span>
<span class="gi">+        if isinstance(value, int):</span>
<span class="gi">+            return cls._as_int(value, 0, dns.ttl.MAX_TTL)</span>
<span class="gi">+        elif isinstance(value, str):</span>
<span class="gi">+            return dns.ttl.from_text(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;not a TTL&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _as_tuple(cls, value, as_value):</span>
<span class="gi">+        try:</span>
<span class="gi">+            # For user convenience, if value is a singleton of the list</span>
<span class="gi">+            # element type, wrap it in a tuple.</span>
<span class="gi">+            return (as_value(value),)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # Otherwise, check each element of the iterable *value*</span>
<span class="gi">+            # against *as_value*.</span>
<span class="gi">+            return tuple(as_value(v) for v in value)</span>
<span class="gi">+</span>
<span class="gi">+    # Processing order</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        items = list(iterable)</span>
<span class="gi">+        random.shuffle(items)</span>
<span class="gi">+        return items</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gu">@@ -258,23 +605,86 @@ class GenericRdata(Rdata):</span>
<span class="w"> </span>    This class is used for rdata types for which we have no better
<span class="w"> </span>    implementation.  It implements the DNS &quot;unknown RRs&quot; scheme.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;data&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;data&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, data):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.data = data

<span class="gd">-</span>
<span class="gd">-_rdata_classes: Dict[Tuple[dns.rdataclass.RdataClass, dns.rdatatype.</span>
<span class="gd">-    RdataType], Any] = {}</span>
<span class="gd">-_module_prefix = &#39;dns.rdtypes&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def from_text(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>
<span class="gd">-    [dns.rdatatype.RdataType, str], tok: Union[dns.tokenizer.Tokenizer, str</span>
<span class="gd">-    ], origin: Optional[dns.name.Name]=None, relativize: bool=True,</span>
<span class="gd">-    relativize_to: Optional[dns.name.Name]=None, idna_codec: Optional[dns.</span>
<span class="gd">-    name.IDNACodec]=None) -&gt;Rdata:</span>
<span class="gi">+    def to_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        return r&quot;\# %d &quot; % len(self.data) + _hexify(self.data, **kw)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        token = tok.get()</span>
<span class="gi">+        if not token.is_identifier() or token.value != r&quot;\#&quot;:</span>
<span class="gi">+            raise dns.exception.SyntaxError(r&quot;generic rdata does not start with \#&quot;)</span>
<span class="gi">+        length = tok.get_int()</span>
<span class="gi">+        hex = tok.concatenate_remaining_identifiers(True).encode()</span>
<span class="gi">+        data = binascii.unhexlify(hex)</span>
<span class="gi">+        if len(data) != length:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;generic rdata hex data has wrong length&quot;)</span>
<span class="gi">+        return cls(rdclass, rdtype, data)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(self.data)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        return cls(rdclass, rdtype, parser.get_remaining())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_rdata_classes: Dict[Tuple[dns.rdataclass.RdataClass, dns.rdatatype.RdataType], Any] = (</span>
<span class="gi">+    {}</span>
<span class="gi">+)</span>
<span class="gi">+_module_prefix = &quot;dns.rdtypes&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_rdata_class(rdclass, rdtype):</span>
<span class="gi">+    cls = _rdata_classes.get((rdclass, rdtype))</span>
<span class="gi">+    if not cls:</span>
<span class="gi">+        cls = _rdata_classes.get((dns.rdatatype.ANY, rdtype))</span>
<span class="gi">+        if not cls:</span>
<span class="gi">+            rdclass_text = dns.rdataclass.to_text(rdclass)</span>
<span class="gi">+            rdtype_text = dns.rdatatype.to_text(rdtype)</span>
<span class="gi">+            rdtype_text = rdtype_text.replace(&quot;-&quot;, &quot;_&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                mod = import_module(</span>
<span class="gi">+                    &quot;.&quot;.join([_module_prefix, rdclass_text, rdtype_text])</span>
<span class="gi">+                )</span>
<span class="gi">+                cls = getattr(mod, rdtype_text)</span>
<span class="gi">+                _rdata_classes[(rdclass, rdtype)] = cls</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    mod = import_module(&quot;.&quot;.join([_module_prefix, &quot;ANY&quot;, rdtype_text]))</span>
<span class="gi">+                    cls = getattr(mod, rdtype_text)</span>
<span class="gi">+                    _rdata_classes[(dns.rdataclass.ANY, rdtype)] = cls</span>
<span class="gi">+                    _rdata_classes[(rdclass, rdtype)] = cls</span>
<span class="gi">+                except ImportError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+    if not cls:</span>
<span class="gi">+        cls = GenericRdata</span>
<span class="gi">+        _rdata_classes[(rdclass, rdtype)] = cls</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text(</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    tok: Union[dns.tokenizer.Tokenizer, str],</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+) -&gt; Rdata:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build an rdata object from text format.

<span class="w"> </span>    This function attempts to dynamically load a class which
<span class="gu">@@ -311,12 +721,57 @@ def from_text(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>
<span class="w"> </span>    Returns an instance of the chosen Rdata subclass.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def from_wire_parser(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype:</span>
<span class="gd">-    Union[dns.rdatatype.RdataType, str], parser: dns.wire.Parser, origin:</span>
<span class="gd">-    Optional[dns.name.Name]=None) -&gt;Rdata:</span>
<span class="gi">+    if isinstance(tok, str):</span>
<span class="gi">+        tok = dns.tokenizer.Tokenizer(tok, idna_codec=idna_codec)</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    cls = get_rdata_class(rdclass, rdtype)</span>
<span class="gi">+    with dns.exception.ExceptionWrapper(dns.exception.SyntaxError):</span>
<span class="gi">+        rdata = None</span>
<span class="gi">+        if cls != GenericRdata:</span>
<span class="gi">+            # peek at first token</span>
<span class="gi">+            token = tok.get()</span>
<span class="gi">+            tok.unget(token)</span>
<span class="gi">+            if token.is_identifier() and token.value == r&quot;\#&quot;:</span>
<span class="gi">+                #</span>
<span class="gi">+                # Known type using the generic syntax.  Extract the</span>
<span class="gi">+                # wire form from the generic syntax, and then run</span>
<span class="gi">+                # from_wire on it.</span>
<span class="gi">+                #</span>
<span class="gi">+                grdata = GenericRdata.from_text(</span>
<span class="gi">+                    rdclass, rdtype, tok, origin, relativize, relativize_to</span>
<span class="gi">+                )</span>
<span class="gi">+                rdata = from_wire(</span>
<span class="gi">+                    rdclass, rdtype, grdata.data, 0, len(grdata.data), origin</span>
<span class="gi">+                )</span>
<span class="gi">+                #</span>
<span class="gi">+                # If this comparison isn&#39;t equal, then there must have been</span>
<span class="gi">+                # compressed names in the wire format, which is an error,</span>
<span class="gi">+                # there being no reasonable context to decompress with.</span>
<span class="gi">+                #</span>
<span class="gi">+                rwire = rdata.to_wire()</span>
<span class="gi">+                if rwire != grdata.data:</span>
<span class="gi">+                    raise dns.exception.SyntaxError(</span>
<span class="gi">+                        &quot;compressed data in &quot;</span>
<span class="gi">+                        &quot;generic syntax form &quot;</span>
<span class="gi">+                        &quot;of known rdatatype&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+        if rdata is None:</span>
<span class="gi">+            rdata = cls.from_text(</span>
<span class="gi">+                rdclass, rdtype, tok, origin, relativize, relativize_to</span>
<span class="gi">+            )</span>
<span class="gi">+        token = tok.get_eol_as_token()</span>
<span class="gi">+        if token.comment is not None:</span>
<span class="gi">+            object.__setattr__(rdata, &quot;rdcomment&quot;, token.comment)</span>
<span class="gi">+        return rdata</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_wire_parser(</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    parser: dns.wire.Parser,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; Rdata:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build an rdata object from wire format

<span class="w"> </span>    This function attempts to dynamically load a class which
<span class="gu">@@ -339,12 +794,22 @@ def from_wire_parser(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype:</span>

<span class="w"> </span>    Returns an instance of the chosen Rdata subclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def from_wire(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>
<span class="gd">-    [dns.rdatatype.RdataType, str], wire: bytes, current: int, rdlen: int,</span>
<span class="gd">-    origin: Optional[dns.name.Name]=None) -&gt;Rdata:</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    cls = get_rdata_class(rdclass, rdtype)</span>
<span class="gi">+    with dns.exception.ExceptionWrapper(dns.exception.FormError):</span>
<span class="gi">+        return cls.from_wire_parser(rdclass, rdtype, parser, origin)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_wire(</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    wire: bytes,</span>
<span class="gi">+    current: int,</span>
<span class="gi">+    rdlen: int,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; Rdata:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build an rdata object from wire format

<span class="w"> </span>    This function attempts to dynamically load a class which
<span class="gu">@@ -371,19 +836,28 @@ def from_wire(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>

<span class="w"> </span>    Returns an instance of the chosen Rdata subclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = dns.wire.Parser(wire, current)</span>
<span class="gi">+    with parser.restrict_to(rdlen):</span>
<span class="gi">+        return from_wire_parser(rdclass, rdtype, parser, origin)</span>


<span class="w"> </span>class RdatatypeExists(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;DNS rdatatype already exists.&quot;&quot;&quot;
<span class="gd">-    supp_kwargs = {&#39;rdclass&#39;, &#39;rdtype&#39;}</span>
<span class="gd">-    fmt = (&#39;The rdata type with class {rdclass:d} and rdtype {rdtype:d} &#39; +</span>
<span class="gd">-        &#39;already exists.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    supp_kwargs = {&quot;rdclass&quot;, &quot;rdtype&quot;}</span>
<span class="gi">+    fmt = (</span>
<span class="gi">+        &quot;The rdata type with class {rdclass:d} and rdtype {rdtype:d} &quot;</span>
<span class="gi">+        + &quot;already exists.&quot;</span>
<span class="gi">+    )</span>


<span class="gd">-def register_type(implementation: Any, rdtype: int, rdtype_text: str,</span>
<span class="gd">-    is_singleton: bool=False, rdclass: dns.rdataclass.RdataClass=dns.</span>
<span class="gd">-    rdataclass.IN) -&gt;None:</span>
<span class="gi">+def register_type(</span>
<span class="gi">+    implementation: Any,</span>
<span class="gi">+    rdtype: int,</span>
<span class="gi">+    rdtype_text: str,</span>
<span class="gi">+    is_singleton: bool = False,</span>
<span class="gi">+    rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Dynamically register a module to handle an rdatatype.

<span class="w"> </span>    *implementation*, a module implementing the type in the usual dnspython
<span class="gu">@@ -399,4 +873,12 @@ def register_type(implementation: Any, rdtype: int, rdtype_text: str,</span>
<span class="w"> </span>    *rdclass*, the rdataclass of the type, or ``dns.rdataclass.ANY`` if
<span class="w"> </span>    it applies to all classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    existing_cls = get_rdata_class(rdclass, rdtype)</span>
<span class="gi">+    if existing_cls != GenericRdata or dns.rdatatype.is_metatype(rdtype):</span>
<span class="gi">+        raise RdatatypeExists(rdclass=rdclass, rdtype=rdtype)</span>
<span class="gi">+    _rdata_classes[(rdclass, rdtype)] = getattr(</span>
<span class="gi">+        implementation, rdtype_text.replace(&quot;-&quot;, &quot;_&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    dns.rdatatype.register_type(rdtype, rdtype_text, is_singleton)</span>
<span class="gh">diff --git a/dns/rdataclass.py b/dns/rdataclass.py</span>
<span class="gh">index 2db3e64..89b85a7 100644</span>
<span class="gd">--- a/dns/rdataclass.py</span>
<span class="gi">+++ b/dns/rdataclass.py</span>
<span class="gu">@@ -1,10 +1,29 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Rdata Classes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.exception


<span class="w"> </span>class RdataClass(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;DNS Rdata Class&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    RESERVED0 = 0
<span class="w"> </span>    IN = 1
<span class="w"> </span>    INTERNET = IN
<span class="gu">@@ -15,6 +34,22 @@ class RdataClass(dns.enum.IntEnum):</span>
<span class="w"> </span>    NONE = 254
<span class="w"> </span>    ANY = 255

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 65535</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _short_name(cls):</span>
<span class="gi">+        return &quot;class&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _prefix(cls):</span>
<span class="gi">+        return &quot;CLASS&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _unknown_exception_class(cls):</span>
<span class="gi">+        return UnknownRdataclass</span>
<span class="gi">+</span>

<span class="w"> </span>_metaclasses = {RdataClass.NONE, RdataClass.ANY}

<span class="gu">@@ -23,7 +58,7 @@ class UnknownRdataclass(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;A DNS class is unknown.&quot;&quot;&quot;


<span class="gd">-def from_text(text: str) -&gt;RdataClass:</span>
<span class="gi">+def from_text(text: str) -&gt; RdataClass:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert text into a DNS rdata class value.

<span class="w"> </span>    The input text can be a defined DNS RR class mnemonic or
<span class="gu">@@ -37,10 +72,11 @@ def from_text(text: str) -&gt;RdataClass:</span>

<span class="w"> </span>    Returns a ``dns.rdataclass.RdataClass``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return RdataClass.from_text(text)</span>


<span class="gd">-def to_text(value: RdataClass) -&gt;str:</span>
<span class="gi">+def to_text(value: RdataClass) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a DNS rdata class value to text.

<span class="w"> </span>    If the value has a known mnemonic, it will be used, otherwise the
<span class="gu">@@ -50,18 +86,24 @@ def to_text(value: RdataClass) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return RdataClass.to_text(value)</span>


<span class="gd">-def is_metaclass(rdclass: RdataClass) -&gt;bool:</span>
<span class="gi">+def is_metaclass(rdclass: RdataClass) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;True if the specified class is a metaclass.

<span class="w"> </span>    The currently defined metaclasses are ANY and NONE.

<span class="w"> </span>    *rdclass* is a ``dns.rdataclass.RdataClass``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if rdclass in _metaclasses:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+### BEGIN generated RdataClass constants</span>

<span class="w"> </span>RESERVED0 = RdataClass.RESERVED0
<span class="w"> </span>IN = RdataClass.IN
<span class="gu">@@ -72,3 +114,5 @@ HS = RdataClass.HS</span>
<span class="w"> </span>HESIOD = RdataClass.HESIOD
<span class="w"> </span>NONE = RdataClass.NONE
<span class="w"> </span>ANY = RdataClass.ANY
<span class="gi">+</span>
<span class="gi">+### END generated RdataClass constants</span>
<span class="gh">diff --git a/dns/rdataset.py b/dns/rdataset.py</span>
<span class="gh">index 7228b61..8bff58d 100644</span>
<span class="gd">--- a/dns/rdataset.py</span>
<span class="gi">+++ b/dns/rdataset.py</span>
<span class="gu">@@ -1,8 +1,27 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS rdatasets (an rdataset is a set of rdatas of a given type and class)&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import io
<span class="w"> </span>import random
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Any, Collection, Dict, List, Optional, Union, cast
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -12,6 +31,8 @@ import dns.rdatatype</span>
<span class="w"> </span>import dns.renderer
<span class="w"> </span>import dns.set
<span class="w"> </span>import dns.ttl
<span class="gi">+</span>
<span class="gi">+# define SimpleSet here for backwards compatibility</span>
<span class="w"> </span>SimpleSet = dns.set.Set


<span class="gu">@@ -26,11 +47,16 @@ class IncompatibleTypes(dns.exception.DNSException):</span>

<span class="w"> </span>class Rdataset(dns.set.Set):
<span class="w"> </span>    &quot;&quot;&quot;A DNS rdataset.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;rdclass&#39;, &#39;rdtype&#39;, &#39;covers&#39;, &#39;ttl&#39;]</span>

<span class="gd">-    def __init__(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns.</span>
<span class="gd">-        rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.rdatatype.</span>
<span class="gd">-        NONE, ttl: int=0):</span>
<span class="gi">+    __slots__ = [&quot;rdclass&quot;, &quot;rdtype&quot;, &quot;covers&quot;, &quot;ttl&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        ttl: int = 0,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new rdataset of the specified class and type.

<span class="w"> </span>        *rdclass*, a ``dns.rdataclass.RdataClass``, the rdataclass.
<span class="gu">@@ -41,13 +67,22 @@ class Rdataset(dns.set.Set):</span>

<span class="w"> </span>        *ttl*, an ``int``, the TTL.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.rdclass = rdclass
<span class="w"> </span>        self.rdtype: dns.rdatatype.RdataType = rdtype
<span class="w"> </span>        self.covers: dns.rdatatype.RdataType = covers
<span class="w"> </span>        self.ttl = ttl

<span class="gd">-    def update_ttl(self, ttl: int) -&gt;None:</span>
<span class="gi">+    def _clone(self):</span>
<span class="gi">+        obj = super()._clone()</span>
<span class="gi">+        obj.rdclass = self.rdclass</span>
<span class="gi">+        obj.rdtype = self.rdtype</span>
<span class="gi">+        obj.covers = self.covers</span>
<span class="gi">+        obj.ttl = self.ttl</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    def update_ttl(self, ttl: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform TTL minimization.

<span class="w"> </span>        Set the TTL of the rdataset to be the lesser of the set&#39;s current
<span class="gu">@@ -56,9 +91,15 @@ class Rdataset(dns.set.Set):</span>

<span class="w"> </span>        *ttl*, an ``int`` or ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add(self, rd: dns.rdata.Rdata, ttl: Optional[int]=None) -&gt;None:</span>
<span class="gi">+        ttl = dns.ttl.make(ttl)</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            self.ttl = ttl</span>
<span class="gi">+        elif ttl &lt; self.ttl:</span>
<span class="gi">+            self.ttl = ttl</span>
<span class="gi">+</span>
<span class="gi">+    def add(  # pylint: disable=arguments-differ,arguments-renamed</span>
<span class="gi">+        self, rd: dns.rdata.Rdata, ttl: Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add the specified rdata to the rdataset.

<span class="w"> </span>        If the optional *ttl* parameter is supplied, then
<span class="gu">@@ -74,7 +115,34 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        Raises ``dns.rdataset.DifferingCovers`` if the type is a signature
<span class="w"> </span>        type and the covered type does not match that of the rdataset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="gi">+        # If we&#39;re adding a signature, do some special handling to</span>
<span class="gi">+        # check that the signature covers the same type as the</span>
<span class="gi">+        # other rdatas in this rdataset.  If this is the first rdata</span>
<span class="gi">+        # in the set, initialize the covers field.</span>
<span class="gi">+        #</span>
<span class="gi">+        if self.rdclass != rd.rdclass or self.rdtype != rd.rdtype:</span>
<span class="gi">+            raise IncompatibleTypes</span>
<span class="gi">+        if ttl is not None:</span>
<span class="gi">+            self.update_ttl(ttl)</span>
<span class="gi">+        if self.rdtype == dns.rdatatype.RRSIG or self.rdtype == dns.rdatatype.SIG:</span>
<span class="gi">+            covers = rd.covers()</span>
<span class="gi">+            if len(self) == 0 and self.covers == dns.rdatatype.NONE:</span>
<span class="gi">+                self.covers = covers</span>
<span class="gi">+            elif self.covers != covers:</span>
<span class="gi">+                raise DifferingCovers</span>
<span class="gi">+        if dns.rdatatype.is_singleton(rd.rdtype) and len(self) &gt; 0:</span>
<span class="gi">+            self.clear()</span>
<span class="gi">+        super().add(rd)</span>
<span class="gi">+</span>
<span class="gi">+    def union_update(self, other):</span>
<span class="gi">+        self.update_ttl(other.ttl)</span>
<span class="gi">+        super().union_update(other)</span>
<span class="gi">+</span>
<span class="gi">+    def intersection_update(self, other):</span>
<span class="gi">+        self.update_ttl(other.ttl)</span>
<span class="gi">+        super().intersection_update(other)</span>

<span class="w"> </span>    def update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Add all rdatas in other to self.
<span class="gu">@@ -82,16 +150,33 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        *other*, a ``dns.rdataset.Rdataset``, the rdataset from which
<span class="w"> </span>        to update.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.update_ttl(other.ttl)</span>
<span class="gi">+        super().update(other)</span>
<span class="gi">+</span>
<span class="gi">+    def _rdata_repr(self):</span>
<span class="gi">+        def maybe_truncate(s):</span>
<span class="gi">+            if len(s) &gt; 100:</span>
<span class="gi">+                return s[:100] + &quot;...&quot;</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;[%s]&quot; % &quot;, &quot;.join(&quot;&lt;%s&gt;&quot; % maybe_truncate(str(rr)) for rr in self)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.covers == 0:
<span class="gd">-            ctext = &#39;&#39;</span>
<span class="gi">+            ctext = &quot;&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            ctext = &#39;(&#39; + dns.rdatatype.to_text(self.covers) + &#39;)&#39;</span>
<span class="gd">-        return &#39;&lt;DNS &#39; + dns.rdataclass.to_text(self.rdclass</span>
<span class="gd">-            ) + &#39; &#39; + dns.rdatatype.to_text(self.rdtype</span>
<span class="gd">-            ) + ctext + &#39; rdataset: &#39; + self._rdata_repr() + &#39;&gt;&#39;</span>
<span class="gi">+            ctext = &quot;(&quot; + dns.rdatatype.to_text(self.covers) + &quot;)&quot;</span>
<span class="gi">+        return (</span>
<span class="gi">+            &quot;&lt;DNS &quot;</span>
<span class="gi">+            + dns.rdataclass.to_text(self.rdclass)</span>
<span class="gi">+            + &quot; &quot;</span>
<span class="gi">+            + dns.rdatatype.to_text(self.rdtype)</span>
<span class="gi">+            + ctext</span>
<span class="gi">+            + &quot; rdataset: &quot;</span>
<span class="gi">+            + self._rdata_repr()</span>
<span class="gi">+            + &quot;&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.to_text()
<span class="gu">@@ -99,18 +184,26 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Rdataset):
<span class="w"> </span>            return False
<span class="gd">-        if (self.rdclass != other.rdclass or self.rdtype != other.rdtype or</span>
<span class="gd">-            self.covers != other.covers):</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.rdclass != other.rdclass</span>
<span class="gi">+            or self.rdtype != other.rdtype</span>
<span class="gi">+            or self.covers != other.covers</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return False
<span class="w"> </span>        return super().__eq__(other)

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self.__eq__(other)

<span class="gd">-    def to_text(self, name: Optional[dns.name.Name]=None, origin: Optional[</span>
<span class="gd">-        dns.name.Name]=None, relativize: bool=True, override_rdclass:</span>
<span class="gd">-        Optional[dns.rdataclass.RdataClass]=None, want_comments: bool=False,</span>
<span class="gd">-        **kw: Dict[str, Any]) -&gt;str:</span>
<span class="gi">+    def to_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Optional[dns.name.Name] = None,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        override_rdclass: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+        want_comments: bool = False,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the rdataset into DNS zone file format.

<span class="w"> </span>        See ``dns.name.Name.choose_relativity`` for more information
<span class="gu">@@ -135,12 +228,65 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        *want_comments*, a ``bool``.  If ``True``, emit comments for rdata
<span class="w"> </span>        which have them.  The default is ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_wire(self, name: dns.name.Name, file: Any, compress: Optional[</span>
<span class="gd">-        dns.name.CompressType]=None, origin: Optional[dns.name.Name]=None,</span>
<span class="gd">-        override_rdclass: Optional[dns.rdataclass.RdataClass]=None,</span>
<span class="gd">-        want_shuffle: bool=True) -&gt;int:</span>
<span class="gi">+        if name is not None:</span>
<span class="gi">+            name = name.choose_relativity(origin, relativize)</span>
<span class="gi">+            ntext = str(name)</span>
<span class="gi">+            pad = &quot; &quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            ntext = &quot;&quot;</span>
<span class="gi">+            pad = &quot;&quot;</span>
<span class="gi">+        s = io.StringIO()</span>
<span class="gi">+        if override_rdclass is not None:</span>
<span class="gi">+            rdclass = override_rdclass</span>
<span class="gi">+        else:</span>
<span class="gi">+            rdclass = self.rdclass</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            #</span>
<span class="gi">+            # Empty rdatasets are used for the question section, and in</span>
<span class="gi">+            # some dynamic updates, so we don&#39;t need to print out the TTL</span>
<span class="gi">+            # (which is meaningless anyway).</span>
<span class="gi">+            #</span>
<span class="gi">+            s.write(</span>
<span class="gi">+                &quot;{}{}{} {}\n&quot;.format(</span>
<span class="gi">+                    ntext,</span>
<span class="gi">+                    pad,</span>
<span class="gi">+                    dns.rdataclass.to_text(rdclass),</span>
<span class="gi">+                    dns.rdatatype.to_text(self.rdtype),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            for rd in self:</span>
<span class="gi">+                extra = &quot;&quot;</span>
<span class="gi">+                if want_comments:</span>
<span class="gi">+                    if rd.rdcomment:</span>
<span class="gi">+                        extra = f&quot; ;{rd.rdcomment}&quot;</span>
<span class="gi">+                s.write(</span>
<span class="gi">+                    &quot;%s%s%d %s %s %s%s\n&quot;</span>
<span class="gi">+                    % (</span>
<span class="gi">+                        ntext,</span>
<span class="gi">+                        pad,</span>
<span class="gi">+                        self.ttl,</span>
<span class="gi">+                        dns.rdataclass.to_text(rdclass),</span>
<span class="gi">+                        dns.rdatatype.to_text(self.rdtype),</span>
<span class="gi">+                        rd.to_text(origin=origin, relativize=relativize, **kw),</span>
<span class="gi">+                        extra,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+        #</span>
<span class="gi">+        # We strip off the final \n for the caller&#39;s convenience in printing</span>
<span class="gi">+        #</span>
<span class="gi">+        return s.getvalue()[:-1]</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        file: Any,</span>
<span class="gi">+        compress: Optional[dns.name.CompressType] = None,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        override_rdclass: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+        want_shuffle: bool = True,</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the rdataset to wire format.

<span class="w"> </span>        *name*, a ``dns.name.Name`` is the owner name to use.
<span class="gu">@@ -164,16 +310,44 @@ class Rdataset(dns.set.Set):</span>

<span class="w"> </span>        Returns an ``int``, the number of records emitted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def match(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns.</span>
<span class="gd">-        rdatatype.RdataType, covers: dns.rdatatype.RdataType) -&gt;bool:</span>
<span class="gi">+        if override_rdclass is not None:</span>
<span class="gi">+            rdclass = override_rdclass</span>
<span class="gi">+            want_shuffle = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            rdclass = self.rdclass</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            name.to_wire(file, compress, origin)</span>
<span class="gi">+            file.write(struct.pack(&quot;!HHIH&quot;, self.rdtype, rdclass, 0, 0))</span>
<span class="gi">+            return 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            l: Union[Rdataset, List[dns.rdata.Rdata]]</span>
<span class="gi">+            if want_shuffle:</span>
<span class="gi">+                l = list(self)</span>
<span class="gi">+                random.shuffle(l)</span>
<span class="gi">+            else:</span>
<span class="gi">+                l = self</span>
<span class="gi">+            for rd in l:</span>
<span class="gi">+                name.to_wire(file, compress, origin)</span>
<span class="gi">+                file.write(struct.pack(&quot;!HHI&quot;, self.rdtype, rdclass, self.ttl))</span>
<span class="gi">+                with dns.renderer.prefixed_length(file, 2):</span>
<span class="gi">+                    rd.to_wire(file, compress, origin)</span>
<span class="gi">+            return len(self)</span>
<span class="gi">+</span>
<span class="gi">+    def match(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this rdataset matches the specified class,
<span class="w"> </span>        type, and covers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.rdclass == rdclass and self.rdtype == rdtype and self.covers == covers:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="gd">-    def processing_order(self) -&gt;List[dns.rdata.Rdata]:</span>
<span class="gi">+    def processing_order(self) -&gt; List[dns.rdata.Rdata]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return rdatas in a valid processing order according to the type&#39;s
<span class="w"> </span>        specification.  For example, MX records are in preference order from
<span class="w"> </span>        lowest to highest preferences, with items of the same preference
<span class="gu">@@ -182,44 +356,92 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        For types that do not define a processing order, the rdatas are
<span class="w"> </span>        simply shuffled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self[0]._processing_order(iter(self))</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gd">-class ImmutableRdataset(Rdataset):</span>
<span class="gi">+class ImmutableRdataset(Rdataset):  # lgtm[py/missing-equals]</span>
<span class="w"> </span>    &quot;&quot;&quot;An immutable DNS rdataset.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _clone_class = Rdataset

<span class="w"> </span>    def __init__(self, rdataset: Rdataset):
<span class="w"> </span>        &quot;&quot;&quot;Create an immutable rdataset from the specified rdataset.&quot;&quot;&quot;
<span class="gd">-        super().__init__(rdataset.rdclass, rdataset.rdtype, rdataset.covers,</span>
<span class="gd">-            rdataset.ttl)</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            rdataset.rdclass, rdataset.rdtype, rdataset.covers, rdataset.ttl</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.items = dns.immutable.Dict(rdataset.items)

<span class="gi">+    def update_ttl(self, ttl):</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def add(self, rd, ttl=None):</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def union_update(self, other):</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def intersection_update(self, other):</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, other):</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __delitem__(self, i):
<span class="gd">-        raise TypeError(&#39;immutable&#39;)</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # lgtm complains about these not raising ArithmeticError, but there is</span>
<span class="gi">+    # precedent for overrides of these methods in other classes to raise</span>
<span class="gi">+    # TypeError, and it seems like the better exception.</span>

<span class="gd">-    def __ior__(self, other):</span>
<span class="gd">-        raise TypeError(&#39;immutable&#39;)</span>
<span class="gi">+    def __ior__(self, other):  # lgtm[py/unexpected-raise-in-special-method]</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>

<span class="gd">-    def __iand__(self, other):</span>
<span class="gd">-        raise TypeError(&#39;immutable&#39;)</span>
<span class="gi">+    def __iand__(self, other):  # lgtm[py/unexpected-raise-in-special-method]</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>

<span class="gd">-    def __iadd__(self, other):</span>
<span class="gd">-        raise TypeError(&#39;immutable&#39;)</span>
<span class="gi">+    def __iadd__(self, other):  # lgtm[py/unexpected-raise-in-special-method]</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>

<span class="gd">-    def __isub__(self, other):</span>
<span class="gd">-        raise TypeError(&#39;immutable&#39;)</span>
<span class="gi">+    def __isub__(self, other):  # lgtm[py/unexpected-raise-in-special-method]</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>

<span class="w"> </span>    def __copy__(self):
<span class="w"> </span>        return ImmutableRdataset(super().copy())

<span class="gi">+    def copy(self):</span>
<span class="gi">+        return ImmutableRdataset(super().copy())</span>

<span class="gd">-def from_text_list(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype:</span>
<span class="gd">-    Union[dns.rdatatype.RdataType, str], ttl: int, text_rdatas: Collection[</span>
<span class="gd">-    str], idna_codec: Optional[dns.name.IDNACodec]=None, origin: Optional[</span>
<span class="gd">-    dns.name.Name]=None, relativize: bool=True, relativize_to: Optional[dns</span>
<span class="gd">-    .name.Name]=None) -&gt;Rdataset:</span>
<span class="gi">+    def union(self, other):</span>
<span class="gi">+        return ImmutableRdataset(super().union(other))</span>
<span class="gi">+</span>
<span class="gi">+    def intersection(self, other):</span>
<span class="gi">+        return ImmutableRdataset(super().intersection(other))</span>
<span class="gi">+</span>
<span class="gi">+    def difference(self, other):</span>
<span class="gi">+        return ImmutableRdataset(super().difference(other))</span>
<span class="gi">+</span>
<span class="gi">+    def symmetric_difference(self, other):</span>
<span class="gi">+        return ImmutableRdataset(super().symmetric_difference(other))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text_list(</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    ttl: int,</span>
<span class="gi">+    text_rdatas: Collection[str],</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an rdataset with the specified class, type, and TTL, and with
<span class="w"> </span>    the specified list of rdatas in text format.

<span class="gu">@@ -237,32 +459,58 @@ def from_text_list(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype:</span>

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def from_text(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>
<span class="gd">-    [dns.rdatatype.RdataType, str], ttl: int, *text_rdatas: Any) -&gt;Rdataset:</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    r = Rdataset(rdclass, rdtype)</span>
<span class="gi">+    r.update_ttl(ttl)</span>
<span class="gi">+    for t in text_rdatas:</span>
<span class="gi">+        rd = dns.rdata.from_text(</span>
<span class="gi">+            r.rdclass, r.rdtype, t, origin, relativize, relativize_to, idna_codec</span>
<span class="gi">+        )</span>
<span class="gi">+        r.add(rd)</span>
<span class="gi">+    return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text(</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    ttl: int,</span>
<span class="gi">+    *text_rdatas: Any,</span>
<span class="gi">+) -&gt; Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an rdataset with the specified class, type, and TTL, and with
<span class="w"> </span>    the specified rdatas in text format.

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return from_text_list(rdclass, rdtype, ttl, cast(Collection[str], text_rdatas))</span>


<span class="gd">-def from_rdata_list(ttl: int, rdatas: Collection[dns.rdata.Rdata]) -&gt;Rdataset:</span>
<span class="gi">+def from_rdata_list(ttl: int, rdatas: Collection[dns.rdata.Rdata]) -&gt; Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an rdataset with the specified TTL, and with
<span class="w"> </span>    the specified list of rdata objects.

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if len(rdatas) == 0:</span>
<span class="gi">+        raise ValueError(&quot;rdata list must not be empty&quot;)</span>
<span class="gi">+    r = None</span>
<span class="gi">+    for rd in rdatas:</span>
<span class="gi">+        if r is None:</span>
<span class="gi">+            r = Rdataset(rd.rdclass, rd.rdtype)</span>
<span class="gi">+            r.update_ttl(ttl)</span>
<span class="gi">+        r.add(rd)</span>
<span class="gi">+    assert r is not None</span>
<span class="gi">+    return r</span>

<span class="gd">-def from_rdata(ttl: int, *rdatas: Any) -&gt;Rdataset:</span>
<span class="gi">+</span>
<span class="gi">+def from_rdata(ttl: int, *rdatas: Any) -&gt; Rdataset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an rdataset with the specified TTL, and with
<span class="w"> </span>    the specified rdata objects.

<span class="w"> </span>    Returns a ``dns.rdataset.Rdataset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return from_rdata_list(ttl, cast(Collection[dns.rdata.Rdata], rdatas))</span>
<span class="gh">diff --git a/dns/rdatatype.py b/dns/rdatatype.py</span>
<span class="gh">index f375d83..e6c5818 100644</span>
<span class="gd">--- a/dns/rdatatype.py</span>
<span class="gi">+++ b/dns/rdatatype.py</span>
<span class="gu">@@ -1,11 +1,31 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Rdata Types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict
<span class="gi">+</span>
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.exception


<span class="w"> </span>class RdataType(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;DNS Rdata Type&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    TYPE0 = 0
<span class="w"> </span>    NONE = 0
<span class="w"> </span>    A = 1
<span class="gu">@@ -88,19 +108,59 @@ class RdataType(dns.enum.IntEnum):</span>
<span class="w"> </span>    TA = 32768
<span class="w"> </span>    DLV = 32769

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 65535</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _short_name(cls):</span>
<span class="gi">+        return &quot;type&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _prefix(cls):</span>
<span class="gi">+        return &quot;TYPE&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _extra_from_text(cls, text):</span>
<span class="gi">+        if text.find(&quot;-&quot;) &gt;= 0:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls[text.replace(&quot;-&quot;, &quot;_&quot;)]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        return _registered_by_text.get(text)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _extra_to_text(cls, value, current_text):</span>
<span class="gi">+        if current_text is None:</span>
<span class="gi">+            return _registered_by_value.get(value)</span>
<span class="gi">+        if current_text.find(&quot;_&quot;) &gt;= 0:</span>
<span class="gi">+            return current_text.replace(&quot;_&quot;, &quot;-&quot;)</span>
<span class="gi">+        return current_text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _unknown_exception_class(cls):</span>
<span class="gi">+        return UnknownRdatatype</span>
<span class="gi">+</span>

<span class="w"> </span>_registered_by_text: Dict[str, RdataType] = {}
<span class="w"> </span>_registered_by_value: Dict[RdataType, str] = {}
<span class="gi">+</span>
<span class="w"> </span>_metatypes = {RdataType.OPT}
<span class="gd">-_singletons = {RdataType.SOA, RdataType.NXT, RdataType.DNAME, RdataType.</span>
<span class="gd">-    NSEC, RdataType.CNAME}</span>
<span class="gi">+</span>
<span class="gi">+_singletons = {</span>
<span class="gi">+    RdataType.SOA,</span>
<span class="gi">+    RdataType.NXT,</span>
<span class="gi">+    RdataType.DNAME,</span>
<span class="gi">+    RdataType.NSEC,</span>
<span class="gi">+    RdataType.CNAME,</span>
<span class="gi">+}</span>


<span class="w"> </span>class UnknownRdatatype(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;DNS resource record type is unknown.&quot;&quot;&quot;


<span class="gd">-def from_text(text: str) -&gt;RdataType:</span>
<span class="gi">+def from_text(text: str) -&gt; RdataType:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert text into a DNS rdata type value.

<span class="w"> </span>    The input text can be a defined DNS RR type mnemonic or
<span class="gu">@@ -114,10 +174,11 @@ def from_text(text: str) -&gt;RdataType:</span>

<span class="w"> </span>    Returns a ``dns.rdatatype.RdataType``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return RdataType.from_text(text)</span>


<span class="gd">-def to_text(value: RdataType) -&gt;str:</span>
<span class="gi">+def to_text(value: RdataType) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a DNS rdata type value to text.

<span class="w"> </span>    If the value has a known mnemonic, it will be used, otherwise the
<span class="gu">@@ -127,10 +188,11 @@ def to_text(value: RdataType) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return RdataType.to_text(value)</span>

<span class="gd">-def is_metatype(rdtype: RdataType) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_metatype(rdtype: RdataType) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;True if the specified type is a metatype.

<span class="w"> </span>    *rdtype* is a ``dns.rdatatype.RdataType``.
<span class="gu">@@ -140,10 +202,11 @@ def is_metatype(rdtype: RdataType) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return (256 &gt; rdtype &gt;= 128) or rdtype in _metatypes</span>


<span class="gd">-def is_singleton(rdtype: RdataType) -&gt;bool:</span>
<span class="gi">+def is_singleton(rdtype: RdataType) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the specified type a singleton type?

<span class="w"> </span>    Singleton types can only have a single rdata in an rdataset, or a single
<span class="gu">@@ -156,11 +219,16 @@ def is_singleton(rdtype: RdataType) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if rdtype in _singletons:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>

<span class="gd">-def register_type(rdtype: RdataType, rdtype_text: str, is_singleton: bool=False</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=redefined-outer-name</span>
<span class="gi">+def register_type(</span>
<span class="gi">+    rdtype: RdataType, rdtype_text: str, is_singleton: bool = False</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Dynamically register an rdatatype.

<span class="w"> </span>    *rdtype*, a ``dns.rdatatype.RdataType``, the rdatatype to register.
<span class="gu">@@ -170,9 +238,15 @@ def register_type(rdtype: RdataType, rdtype_text: str, is_singleton: bool=False</span>
<span class="w"> </span>    *is_singleton*, a ``bool``, indicating if the type is a singleton (i.e.
<span class="w"> </span>    RRsets of the type can have only one member.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    _registered_by_text[rdtype_text] = rdtype</span>
<span class="gi">+    _registered_by_value[rdtype] = rdtype_text</span>
<span class="gi">+    if is_singleton:</span>
<span class="gi">+        _singletons.add(rdtype)</span>


<span class="gi">+### BEGIN generated RdataType constants</span>
<span class="gi">+</span>
<span class="w"> </span>TYPE0 = RdataType.TYPE0
<span class="w"> </span>NONE = RdataType.NONE
<span class="w"> </span>A = RdataType.A
<span class="gu">@@ -254,3 +328,5 @@ AVC = RdataType.AVC</span>
<span class="w"> </span>AMTRELAY = RdataType.AMTRELAY
<span class="w"> </span>TA = RdataType.TA
<span class="w"> </span>DLV = RdataType.DLV
<span class="gi">+</span>
<span class="gi">+### END generated RdataType constants</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/AFSDB.py b/dns/rdtypes/ANY/AFSDB.py</span>
<span class="gh">index 085e3a6..06a3b97 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/AFSDB.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/AFSDB.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.mxbase

<span class="gu">@@ -6,12 +23,23 @@ import dns.rdtypes.mxbase</span>
<span class="w"> </span>class AFSDB(dns.rdtypes.mxbase.UncompressedDowncasingMX):
<span class="w"> </span>    &quot;&quot;&quot;AFSDB record&quot;&quot;&quot;

<span class="gi">+    # Use the property mechanism to make &quot;subtype&quot; an alias for the</span>
<span class="gi">+    # &quot;preference&quot; attribute, and &quot;hostname&quot; an alias for the &quot;exchange&quot;</span>
<span class="gi">+    # attribute.</span>
<span class="gi">+    #</span>
<span class="gi">+    # This lets us inherit the UncompressedMX implementation but lets</span>
<span class="gi">+    # the caller use appropriate attribute names for the rdata type.</span>
<span class="gi">+    #</span>
<span class="gi">+    # We probably lose some performance vs. a cut-and-paste</span>
<span class="gi">+    # implementation, but this way we don&#39;t copy code, and that&#39;s</span>
<span class="gi">+    # good.</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def subtype(self):
<span class="gd">-        &quot;&quot;&quot;the AFSDB subtype&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;the AFSDB subtype&quot;</span>
<span class="gi">+        return self.preference</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def hostname(self):
<span class="gd">-        &quot;&quot;&quot;the AFSDB hostname&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;the AFSDB hostname&quot;</span>
<span class="gi">+        return self.exchange</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/AMTRELAY.py b/dns/rdtypes/ANY/AMTRELAY.py</span>
<span class="gh">index a0c35ed..ed2b072 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/AMTRELAY.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/AMTRELAY.py</span>
<span class="gu">@@ -1,23 +1,91 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.util


<span class="w"> </span>class Relay(dns.rdtypes.util.Gateway):
<span class="gd">-    name = &#39;AMTRELAY relay&#39;</span>
<span class="gi">+    name = &quot;AMTRELAY relay&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def relay(self):</span>
<span class="gi">+        return self.gateway</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class AMTRELAY(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;AMTRELAY record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;precedence&#39;, &#39;discovery_optional&#39;, &#39;relay_type&#39;, &#39;relay&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, precedence, discovery_optional,</span>
<span class="gd">-        relay_type, relay):</span>
<span class="gi">+    # see: RFC 8777</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;precedence&quot;, &quot;discovery_optional&quot;, &quot;relay_type&quot;, &quot;relay&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, rdclass, rdtype, precedence, discovery_optional, relay_type, relay</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        relay = Relay(relay_type, relay)
<span class="w"> </span>        self.precedence = self._as_uint8(precedence)
<span class="w"> </span>        self.discovery_optional = self._as_bool(discovery_optional)
<span class="w"> </span>        self.relay_type = relay.type
<span class="w"> </span>        self.relay = relay.relay
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        relay = Relay(self.relay_type, self.relay).to_text(origin, relativize)</span>
<span class="gi">+        return &quot;%d %d %d %s&quot; % (</span>
<span class="gi">+            self.precedence,</span>
<span class="gi">+            self.discovery_optional,</span>
<span class="gi">+            self.relay_type,</span>
<span class="gi">+            relay,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        precedence = tok.get_uint8()</span>
<span class="gi">+        discovery_optional = tok.get_uint8()</span>
<span class="gi">+        if discovery_optional &gt; 1:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting 0 or 1&quot;)</span>
<span class="gi">+        discovery_optional = bool(discovery_optional)</span>
<span class="gi">+        relay_type = tok.get_uint8()</span>
<span class="gi">+        if relay_type &gt; 0x7F:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting an integer &lt;= 127&quot;)</span>
<span class="gi">+        relay = Relay.from_text(relay_type, tok, origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, precedence, discovery_optional, relay_type, relay.relay</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        relay_type = self.relay_type | (self.discovery_optional &lt;&lt; 7)</span>
<span class="gi">+        header = struct.pack(&quot;!BB&quot;, self.precedence, relay_type)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        Relay(self.relay_type, self.relay).to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (precedence, relay_type) = parser.get_struct(&quot;!BB&quot;)</span>
<span class="gi">+        discovery_optional = bool(relay_type &gt;&gt; 7)</span>
<span class="gi">+        relay_type &amp;= 0x7F</span>
<span class="gi">+        relay = Relay.from_wire_parser(relay_type, parser, origin)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, precedence, discovery_optional, relay_type, relay.relay</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/AVC.py b/dns/rdtypes/ANY/AVC.py</span>
<span class="gh">index fdcfaeb..a27ae2d 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/AVC.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/AVC.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2016 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.txtbase

<span class="gu">@@ -5,3 +22,5 @@ import dns.rdtypes.txtbase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class AVC(dns.rdtypes.txtbase.TXTBase):
<span class="w"> </span>    &quot;&quot;&quot;AVC record&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # See: IANA dns parameters for AVC</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/CAA.py b/dns/rdtypes/ANY/CAA.py</span>
<span class="gh">index e9e0c89..2e6a7e7 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/CAA.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/CAA.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,12 +26,46 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class CAA(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;CAA (Certification Authority Authorization) record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;flags&#39;, &#39;tag&#39;, &#39;value&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 6844</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;flags&quot;, &quot;tag&quot;, &quot;value&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, flags, tag, value):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.flags = self._as_uint8(flags)
<span class="w"> </span>        self.tag = self._as_bytes(tag, True, 255)
<span class="w"> </span>        if not tag.isalnum():
<span class="gd">-            raise ValueError(&#39;tag is not alphanumeric&#39;)</span>
<span class="gi">+            raise ValueError(&quot;tag is not alphanumeric&quot;)</span>
<span class="w"> </span>        self.value = self._as_bytes(value)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &#39;%u %s &quot;%s&quot;&#39; % (</span>
<span class="gi">+            self.flags,</span>
<span class="gi">+            dns.rdata._escapify(self.tag),</span>
<span class="gi">+            dns.rdata._escapify(self.value),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        flags = tok.get_uint8()</span>
<span class="gi">+        tag = tok.get_string().encode()</span>
<span class="gi">+        value = tok.get_string().encode()</span>
<span class="gi">+        return cls(rdclass, rdtype, flags, tag, value)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, self.flags))</span>
<span class="gi">+        l = len(self.tag)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.tag)</span>
<span class="gi">+        file.write(self.value)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        flags = parser.get_uint8()</span>
<span class="gi">+        tag = parser.get_counted_bytes()</span>
<span class="gi">+        value = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, flags, tag, value)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/CDNSKEY.py b/dns/rdtypes/ANY/CDNSKEY.py</span>
<span class="gh">index 4c3c80e..b613409 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/CDNSKEY.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/CDNSKEY.py</span>
<span class="gu">@@ -1,6 +1,31 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="gd">-import dns.rdtypes.dnskeybase</span>
<span class="gd">-from dns.rdtypes.dnskeybase import REVOKE, SEP, ZONE</span>
<span class="gi">+import dns.rdtypes.dnskeybase  # lgtm[py/import-and-import-from]</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=unused-import</span>
<span class="gi">+from dns.rdtypes.dnskeybase import (  # noqa: F401  lgtm[py/unused-import]</span>
<span class="gi">+    REVOKE,</span>
<span class="gi">+    SEP,</span>
<span class="gi">+    ZONE,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# pylint: enable=unused-import</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gh">diff --git a/dns/rdtypes/ANY/CDS.py b/dns/rdtypes/ANY/CDS.py</span>
<span class="gh">index d79117e..8312b97 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/CDS.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/CDS.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.dsbase

<span class="gu">@@ -5,5 +22,8 @@ import dns.rdtypes.dsbase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class CDS(dns.rdtypes.dsbase.DSBase):
<span class="w"> </span>    &quot;&quot;&quot;CDS record&quot;&quot;&quot;
<span class="gd">-    _digest_length_by_type = {**dns.rdtypes.dsbase.DSBase.</span>
<span class="gd">-        _digest_length_by_type, (0): 1}</span>
<span class="gi">+</span>
<span class="gi">+    _digest_length_by_type = {</span>
<span class="gi">+        **dns.rdtypes.dsbase.DSBase._digest_length_by_type,</span>
<span class="gi">+        0: 1,  # delete, RFC 8078 Sec. 4 (including Errata ID 5049)</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/CERT.py b/dns/rdtypes/ANY/CERT.py</span>
<span class="gh">index 922f467..f369cc8 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/CERT.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/CERT.py</span>
<span class="gu">@@ -1,26 +1,116 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.dnssectypes
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="w"> </span>import dns.tokenizer
<span class="gd">-_ctype_by_value = {(1): &#39;PKIX&#39;, (2): &#39;SPKI&#39;, (3): &#39;PGP&#39;, (4): &#39;IPKIX&#39;, (5):</span>
<span class="gd">-    &#39;ISPKI&#39;, (6): &#39;IPGP&#39;, (7): &#39;ACPKIX&#39;, (8): &#39;IACPKIX&#39;, (253): &#39;URI&#39;, (254</span>
<span class="gd">-    ): &#39;OID&#39;}</span>
<span class="gd">-_ctype_by_name = {&#39;PKIX&#39;: 1, &#39;SPKI&#39;: 2, &#39;PGP&#39;: 3, &#39;IPKIX&#39;: 4, &#39;ISPKI&#39;: 5,</span>
<span class="gd">-    &#39;IPGP&#39;: 6, &#39;ACPKIX&#39;: 7, &#39;IACPKIX&#39;: 8, &#39;URI&#39;: 253, &#39;OID&#39;: 254}</span>
<span class="gi">+</span>
<span class="gi">+_ctype_by_value = {</span>
<span class="gi">+    1: &quot;PKIX&quot;,</span>
<span class="gi">+    2: &quot;SPKI&quot;,</span>
<span class="gi">+    3: &quot;PGP&quot;,</span>
<span class="gi">+    4: &quot;IPKIX&quot;,</span>
<span class="gi">+    5: &quot;ISPKI&quot;,</span>
<span class="gi">+    6: &quot;IPGP&quot;,</span>
<span class="gi">+    7: &quot;ACPKIX&quot;,</span>
<span class="gi">+    8: &quot;IACPKIX&quot;,</span>
<span class="gi">+    253: &quot;URI&quot;,</span>
<span class="gi">+    254: &quot;OID&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+_ctype_by_name = {</span>
<span class="gi">+    &quot;PKIX&quot;: 1,</span>
<span class="gi">+    &quot;SPKI&quot;: 2,</span>
<span class="gi">+    &quot;PGP&quot;: 3,</span>
<span class="gi">+    &quot;IPKIX&quot;: 4,</span>
<span class="gi">+    &quot;ISPKI&quot;: 5,</span>
<span class="gi">+    &quot;IPGP&quot;: 6,</span>
<span class="gi">+    &quot;ACPKIX&quot;: 7,</span>
<span class="gi">+    &quot;IACPKIX&quot;: 8,</span>
<span class="gi">+    &quot;URI&quot;: 253,</span>
<span class="gi">+    &quot;OID&quot;: 254,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ctype_from_text(what):</span>
<span class="gi">+    v = _ctype_by_name.get(what)</span>
<span class="gi">+    if v is not None:</span>
<span class="gi">+        return v</span>
<span class="gi">+    return int(what)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ctype_to_text(what):</span>
<span class="gi">+    v = _ctype_by_value.get(what)</span>
<span class="gi">+    if v is not None:</span>
<span class="gi">+        return v</span>
<span class="gi">+    return str(what)</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class CERT(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;CERT record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;certificate_type&#39;, &#39;key_tag&#39;, &#39;algorithm&#39;, &#39;certificate&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, certificate_type, key_tag,</span>
<span class="gd">-        algorithm, certificate):</span>
<span class="gi">+    # see RFC 4398</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;certificate_type&quot;, &quot;key_tag&quot;, &quot;algorithm&quot;, &quot;certificate&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, rdclass, rdtype, certificate_type, key_tag, algorithm, certificate</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.certificate_type = self._as_uint16(certificate_type)
<span class="w"> </span>        self.key_tag = self._as_uint16(key_tag)
<span class="w"> </span>        self.algorithm = self._as_uint8(algorithm)
<span class="w"> </span>        self.certificate = self._as_bytes(certificate)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        certificate_type = _ctype_to_text(self.certificate_type)</span>
<span class="gi">+        return &quot;%s %d %s %s&quot; % (</span>
<span class="gi">+            certificate_type,</span>
<span class="gi">+            self.key_tag,</span>
<span class="gi">+            dns.dnssectypes.Algorithm.to_text(self.algorithm),</span>
<span class="gi">+            dns.rdata._base64ify(self.certificate, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        certificate_type = _ctype_from_text(tok.get_string())</span>
<span class="gi">+        key_tag = tok.get_uint16()</span>
<span class="gi">+        algorithm = dns.dnssectypes.Algorithm.from_text(tok.get_string())</span>
<span class="gi">+        b64 = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        certificate = base64.b64decode(b64)</span>
<span class="gi">+        return cls(rdclass, rdtype, certificate_type, key_tag, algorithm, certificate)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        prefix = struct.pack(</span>
<span class="gi">+            &quot;!HHB&quot;, self.certificate_type, self.key_tag, self.algorithm</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(prefix)</span>
<span class="gi">+        file.write(self.certificate)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (certificate_type, key_tag, algorithm) = parser.get_struct(&quot;!HHB&quot;)</span>
<span class="gi">+        certificate = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, certificate_type, key_tag, algorithm, certificate)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/CNAME.py b/dns/rdtypes/ANY/CNAME.py</span>
<span class="gh">index 573f74e..665e407 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/CNAME.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/CNAME.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.nsbase

<span class="gh">diff --git a/dns/rdtypes/ANY/CSYNC.py b/dns/rdtypes/ANY/CSYNC.py</span>
<span class="gh">index 88807e3..2f972f6 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/CSYNC.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/CSYNC.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011, 2016 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -9,13 +27,14 @@ import dns.rdtypes.util</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class Bitmap(dns.rdtypes.util.Bitmap):
<span class="gd">-    type_name = &#39;CSYNC&#39;</span>
<span class="gi">+    type_name = &quot;CSYNC&quot;</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class CSYNC(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;CSYNC record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;serial&#39;, &#39;flags&#39;, &#39;windows&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;serial&quot;, &quot;flags&quot;, &quot;windows&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, serial, flags, windows):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -24,3 +43,26 @@ class CSYNC(dns.rdata.Rdata):</span>
<span class="w"> </span>        if not isinstance(windows, Bitmap):
<span class="w"> </span>            windows = Bitmap(windows)
<span class="w"> </span>        self.windows = tuple(windows.windows)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        text = Bitmap(self.windows).to_text()</span>
<span class="gi">+        return &quot;%d %d%s&quot; % (self.serial, self.flags, text)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        serial = tok.get_uint32()</span>
<span class="gi">+        flags = tok.get_uint16()</span>
<span class="gi">+        bitmap = Bitmap.from_text(tok)</span>
<span class="gi">+        return cls(rdclass, rdtype, serial, flags, bitmap)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!IH&quot;, self.serial, self.flags))</span>
<span class="gi">+        Bitmap(self.windows).to_wire(file)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (serial, flags) = parser.get_struct(&quot;!IH&quot;)</span>
<span class="gi">+        bitmap = Bitmap.from_wire_parser(parser)</span>
<span class="gi">+        return cls(rdclass, rdtype, serial, flags, bitmap)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/DLV.py b/dns/rdtypes/ANY/DLV.py</span>
<span class="gh">index 19c3328..6c134f1 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/DLV.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/DLV.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.dsbase

<span class="gh">diff --git a/dns/rdtypes/ANY/DNAME.py b/dns/rdtypes/ANY/DNAME.py</span>
<span class="gh">index 279fb81..bbf9186 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/DNAME.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/DNAME.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.nsbase

<span class="gu">@@ -5,3 +22,6 @@ import dns.rdtypes.nsbase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class DNAME(dns.rdtypes.nsbase.UncompressedNS):
<span class="w"> </span>    &quot;&quot;&quot;DNAME record&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.target.to_wire(file, None, origin, canonicalize)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/DNSKEY.py b/dns/rdtypes/ANY/DNSKEY.py</span>
<span class="gh">index 9b0bfaf..6d961a9 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/DNSKEY.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/DNSKEY.py</span>
<span class="gu">@@ -1,6 +1,31 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="gd">-import dns.rdtypes.dnskeybase</span>
<span class="gd">-from dns.rdtypes.dnskeybase import REVOKE, SEP, ZONE</span>
<span class="gi">+import dns.rdtypes.dnskeybase  # lgtm[py/import-and-import-from]</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=unused-import</span>
<span class="gi">+from dns.rdtypes.dnskeybase import (  # noqa: F401  lgtm[py/unused-import]</span>
<span class="gi">+    REVOKE,</span>
<span class="gi">+    SEP,</span>
<span class="gi">+    ZONE,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# pylint: enable=unused-import</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gh">diff --git a/dns/rdtypes/ANY/DS.py b/dns/rdtypes/ANY/DS.py</span>
<span class="gh">index d5a27a9..58b3108 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/DS.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/DS.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.dsbase

<span class="gh">diff --git a/dns/rdtypes/ANY/EUI48.py b/dns/rdtypes/ANY/EUI48.py</span>
<span class="gh">index b99cfbe..c843be5 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/EUI48.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/EUI48.py</span>
<span class="gu">@@ -1,3 +1,21 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2015 Red Hat, Inc.</span>
<span class="gi">+# Author: Petr Spacek &lt;pspacek@redhat.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &#39;AS IS&#39; AND RED HAT DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.euibase

<span class="gu">@@ -5,5 +23,8 @@ import dns.rdtypes.euibase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class EUI48(dns.rdtypes.euibase.EUIBase):
<span class="w"> </span>    &quot;&quot;&quot;EUI48 record&quot;&quot;&quot;
<span class="gd">-    byte_len = 6</span>
<span class="gd">-    text_len = byte_len * 3 - 1</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc7043.txt</span>
<span class="gi">+</span>
<span class="gi">+    byte_len = 6  # 0123456789ab (in hex)</span>
<span class="gi">+    text_len = byte_len * 3 - 1  # 01-23-45-67-89-ab</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/EUI64.py b/dns/rdtypes/ANY/EUI64.py</span>
<span class="gh">index 1789d71..f6d7e25 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/EUI64.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/EUI64.py</span>
<span class="gu">@@ -1,3 +1,21 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2015 Red Hat, Inc.</span>
<span class="gi">+# Author: Petr Spacek &lt;pspacek@redhat.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &#39;AS IS&#39; AND RED HAT DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.euibase

<span class="gu">@@ -5,5 +23,8 @@ import dns.rdtypes.euibase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class EUI64(dns.rdtypes.euibase.EUIBase):
<span class="w"> </span>    &quot;&quot;&quot;EUI64 record&quot;&quot;&quot;
<span class="gd">-    byte_len = 8</span>
<span class="gd">-    text_len = byte_len * 3 - 1</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc7043.txt</span>
<span class="gi">+</span>
<span class="gi">+    byte_len = 8  # 0123456789abcdef (in hex)</span>
<span class="gi">+    text_len = byte_len * 3 - 1  # 01-23-45-67-89-ab-cd-ef</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/GPOS.py b/dns/rdtypes/ANY/GPOS.py</span>
<span class="gh">index 1f28c06..312338f 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/GPOS.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/GPOS.py</span>
<span class="gu">@@ -1,14 +1,54 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="w"> </span>import dns.tokenizer


<span class="gi">+def _validate_float_string(what):</span>
<span class="gi">+    if len(what) == 0:</span>
<span class="gi">+        raise dns.exception.FormError</span>
<span class="gi">+    if what[0] == b&quot;-&quot;[0] or what[0] == b&quot;+&quot;[0]:</span>
<span class="gi">+        what = what[1:]</span>
<span class="gi">+    if what.isdigit():</span>
<span class="gi">+        return</span>
<span class="gi">+    try:</span>
<span class="gi">+        (left, right) = what.split(b&quot;.&quot;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise dns.exception.FormError</span>
<span class="gi">+    if left == b&quot;&quot; and right == b&quot;&quot;:</span>
<span class="gi">+        raise dns.exception.FormError</span>
<span class="gi">+    if not left == b&quot;&quot; and not left.decode().isdigit():</span>
<span class="gi">+        raise dns.exception.FormError</span>
<span class="gi">+    if not right == b&quot;&quot; and not right.decode().isdigit():</span>
<span class="gi">+        raise dns.exception.FormError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class GPOS(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;GPOS record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;latitude&#39;, &#39;longitude&#39;, &#39;altitude&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 1712</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;latitude&quot;, &quot;longitude&quot;, &quot;altitude&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, latitude, longitude, altitude):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -29,22 +69,57 @@ class GPOS(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.altitude = altitude
<span class="w"> </span>        flat = self.float_latitude
<span class="w"> </span>        if flat &lt; -90.0 or flat &gt; 90.0:
<span class="gd">-            raise dns.exception.FormError(&#39;bad latitude&#39;)</span>
<span class="gi">+            raise dns.exception.FormError(&quot;bad latitude&quot;)</span>
<span class="w"> </span>        flong = self.float_longitude
<span class="w"> </span>        if flong &lt; -180.0 or flong &gt; 180.0:
<span class="gd">-            raise dns.exception.FormError(&#39;bad longitude&#39;)</span>
<span class="gi">+            raise dns.exception.FormError(&quot;bad longitude&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &quot;{} {} {}&quot;.format(</span>
<span class="gi">+            self.latitude.decode(), self.longitude.decode(), self.altitude.decode()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        latitude = tok.get_string()</span>
<span class="gi">+        longitude = tok.get_string()</span>
<span class="gi">+        altitude = tok.get_string()</span>
<span class="gi">+        return cls(rdclass, rdtype, latitude, longitude, altitude)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        l = len(self.latitude)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.latitude)</span>
<span class="gi">+        l = len(self.longitude)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.longitude)</span>
<span class="gi">+        l = len(self.altitude)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.altitude)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        latitude = parser.get_counted_bytes()</span>
<span class="gi">+        longitude = parser.get_counted_bytes()</span>
<span class="gi">+        altitude = parser.get_counted_bytes()</span>
<span class="gi">+        return cls(rdclass, rdtype, latitude, longitude, altitude)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_latitude(self):
<span class="gd">-        &quot;&quot;&quot;latitude as a floating point value&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;latitude as a floating point value&quot;</span>
<span class="gi">+        return float(self.latitude)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_longitude(self):
<span class="gd">-        &quot;&quot;&quot;longitude as a floating point value&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;longitude as a floating point value&quot;</span>
<span class="gi">+        return float(self.longitude)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_altitude(self):
<span class="gd">-        &quot;&quot;&quot;altitude as a floating point value&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;altitude as a floating point value&quot;</span>
<span class="gi">+        return float(self.altitude)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/HINFO.py b/dns/rdtypes/ANY/HINFO.py</span>
<span class="gh">index b0da043..c2c45de 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/HINFO.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/HINFO.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,9 +26,41 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class HINFO(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;HINFO record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;cpu&#39;, &#39;os&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 1035</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;cpu&quot;, &quot;os&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, cpu, os):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.cpu = self._as_bytes(cpu, True, 255)
<span class="w"> </span>        self.os = self._as_bytes(os, True, 255)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &#39;&quot;{}&quot; &quot;{}&quot;&#39;.format(</span>
<span class="gi">+            dns.rdata._escapify(self.cpu), dns.rdata._escapify(self.os)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        cpu = tok.get_string(max_length=255)</span>
<span class="gi">+        os = tok.get_string(max_length=255)</span>
<span class="gi">+        return cls(rdclass, rdtype, cpu, os)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        l = len(self.cpu)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.cpu)</span>
<span class="gi">+        l = len(self.os)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.os)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        cpu = parser.get_counted_bytes()</span>
<span class="gi">+        os = parser.get_counted_bytes()</span>
<span class="gi">+        return cls(rdclass, rdtype, cpu, os)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/HIP.py b/dns/rdtypes/ANY/HIP.py</span>
<span class="gh">index 5590282..9166913 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/HIP.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/HIP.py</span>
<span class="gu">@@ -1,6 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2010, 2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -10,7 +28,10 @@ import dns.rdatatype</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class HIP(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;HIP record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;hit&#39;, &#39;algorithm&#39;, &#39;key&#39;, &#39;servers&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 5205</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;hit&quot;, &quot;algorithm&quot;, &quot;key&quot;, &quot;servers&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, hit, algorithm, key, servers):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -18,3 +39,47 @@ class HIP(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.algorithm = self._as_uint8(algorithm)
<span class="w"> </span>        self.key = self._as_bytes(key, True)
<span class="w"> </span>        self.servers = self._as_tuple(servers, self._as_name)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        hit = binascii.hexlify(self.hit).decode()</span>
<span class="gi">+        key = base64.b64encode(self.key).replace(b&quot;\n&quot;, b&quot;&quot;).decode()</span>
<span class="gi">+        text = &quot;&quot;</span>
<span class="gi">+        servers = []</span>
<span class="gi">+        for server in self.servers:</span>
<span class="gi">+            servers.append(server.choose_relativity(origin, relativize))</span>
<span class="gi">+        if len(servers) &gt; 0:</span>
<span class="gi">+            text += &quot; &quot; + &quot; &quot;.join((x.to_unicode() for x in servers))</span>
<span class="gi">+        return &quot;%u %s %s%s&quot; % (self.algorithm, hit, key, text)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        algorithm = tok.get_uint8()</span>
<span class="gi">+        hit = binascii.unhexlify(tok.get_string().encode())</span>
<span class="gi">+        key = base64.b64decode(tok.get_string().encode())</span>
<span class="gi">+        servers = []</span>
<span class="gi">+        for token in tok.get_remaining():</span>
<span class="gi">+            server = tok.as_name(token, origin, relativize, relativize_to)</span>
<span class="gi">+            servers.append(server)</span>
<span class="gi">+        return cls(rdclass, rdtype, hit, algorithm, key, servers)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        lh = len(self.hit)</span>
<span class="gi">+        lk = len(self.key)</span>
<span class="gi">+        file.write(struct.pack(&quot;!BBH&quot;, lh, self.algorithm, lk))</span>
<span class="gi">+        file.write(self.hit)</span>
<span class="gi">+        file.write(self.key)</span>
<span class="gi">+        for server in self.servers:</span>
<span class="gi">+            server.to_wire(file, None, origin, False)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (lh, algorithm, lk) = parser.get_struct(&quot;!BBH&quot;)</span>
<span class="gi">+        hit = parser.get_bytes(lh)</span>
<span class="gi">+        key = parser.get_bytes(lk)</span>
<span class="gi">+        servers = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            server = parser.get_name(origin)</span>
<span class="gi">+            servers.append(server)</span>
<span class="gi">+        return cls(rdclass, rdtype, hit, algorithm, key, servers)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/ISDN.py b/dns/rdtypes/ANY/ISDN.py</span>
<span class="gh">index c961c24..fb01eab 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/ISDN.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/ISDN.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,9 +26,52 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ISDN(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;ISDN record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;address&#39;, &#39;subaddress&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 1183</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;address&quot;, &quot;subaddress&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, address, subaddress):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.address = self._as_bytes(address, True, 255)
<span class="w"> </span>        self.subaddress = self._as_bytes(subaddress, True, 255)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        if self.subaddress:</span>
<span class="gi">+            return &#39;&quot;{}&quot; &quot;{}&quot;&#39;.format(</span>
<span class="gi">+                dns.rdata._escapify(self.address), dns.rdata._escapify(self.subaddress)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&quot;%s&quot;&#39; % dns.rdata._escapify(self.address)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        address = tok.get_string()</span>
<span class="gi">+        tokens = tok.get_remaining(max_tokens=1)</span>
<span class="gi">+        if len(tokens) &gt;= 1:</span>
<span class="gi">+            subaddress = tokens[0].unescape().value</span>
<span class="gi">+        else:</span>
<span class="gi">+            subaddress = &quot;&quot;</span>
<span class="gi">+        return cls(rdclass, rdtype, address, subaddress)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        l = len(self.address)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.address)</span>
<span class="gi">+        l = len(self.subaddress)</span>
<span class="gi">+        if l &gt; 0:</span>
<span class="gi">+            assert l &lt; 256</span>
<span class="gi">+            file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+            file.write(self.subaddress)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        address = parser.get_counted_bytes()</span>
<span class="gi">+        if parser.remaining() &gt; 0:</span>
<span class="gi">+            subaddress = parser.get_counted_bytes()</span>
<span class="gi">+        else:</span>
<span class="gi">+            subaddress = b&quot;&quot;</span>
<span class="gi">+        return cls(rdclass, rdtype, address, subaddress)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/L32.py b/dns/rdtypes/ANY/L32.py</span>
<span class="gh">index 67c8691..09804c2 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/L32.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/L32.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata

<span class="gu">@@ -6,9 +9,33 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class L32(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;L32 record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;preference&#39;, &#39;locator32&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc6742.txt</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;preference&quot;, &quot;locator32&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, preference, locator32):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        self.locator32 = self._as_ipv4_address(locator32)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return f&quot;{self.preference} {self.locator32}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        nodeid = tok.get_identifier()</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, nodeid)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, self.preference))</span>
<span class="gi">+        file.write(dns.ipv4.inet_aton(self.locator32))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        preference = parser.get_uint16()</span>
<span class="gi">+        locator32 = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, locator32)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/L64.py b/dns/rdtypes/ANY/L64.py</span>
<span class="gh">index 34cf23b..fb76808 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/L64.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/L64.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.util

<span class="gu">@@ -6,15 +9,39 @@ import dns.rdtypes.util</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class L64(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;L64 record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;preference&#39;, &#39;locator64&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc6742.txt</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;preference&quot;, &quot;locator64&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, preference, locator64):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        if isinstance(locator64, bytes):
<span class="w"> </span>            if len(locator64) != 8:
<span class="gd">-                raise ValueError(&#39;invalid locator64&#39;)</span>
<span class="gd">-            self.locator64 = dns.rdata._hexify(locator64, 4, b&#39;:&#39;)</span>
<span class="gi">+                raise ValueError(&quot;invalid locator64&quot;)</span>
<span class="gi">+            self.locator64 = dns.rdata._hexify(locator64, 4, b&quot;:&quot;)</span>
<span class="w"> </span>        else:
<span class="gd">-            dns.rdtypes.util.parse_formatted_hex(locator64, 4, 4, &#39;:&#39;)</span>
<span class="gi">+            dns.rdtypes.util.parse_formatted_hex(locator64, 4, 4, &quot;:&quot;)</span>
<span class="w"> </span>            self.locator64 = locator64
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return f&quot;{self.preference} {self.locator64}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        locator64 = tok.get_identifier()</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, locator64)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, self.preference))</span>
<span class="gi">+        file.write(dns.rdtypes.util.parse_formatted_hex(self.locator64, 4, 4, &quot;:&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        preference = parser.get_uint16()</span>
<span class="gi">+        locator64 = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, locator64)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/LOC.py b/dns/rdtypes/ANY/LOC.py</span>
<span class="gh">index 2be3324..a36a2c1 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/LOC.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/LOC.py</span>
<span class="gu">@@ -1,25 +1,134 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gd">-_pows = tuple(10 ** i for i in range(0, 11))</span>
<span class="gi">+</span>
<span class="gi">+_pows = tuple(10**i for i in range(0, 11))</span>
<span class="gi">+</span>
<span class="gi">+# default values are in centimeters</span>
<span class="w"> </span>_default_size = 100.0
<span class="w"> </span>_default_hprec = 1000000.0
<span class="w"> </span>_default_vprec = 1000.0
<span class="gd">-_MAX_LATITUDE = 2147483648 + 90 * 3600000</span>
<span class="gd">-_MIN_LATITUDE = 2147483648 - 90 * 3600000</span>
<span class="gd">-_MAX_LONGITUDE = 2147483648 + 180 * 3600000</span>
<span class="gd">-_MIN_LONGITUDE = 2147483648 - 180 * 3600000</span>
<span class="gi">+</span>
<span class="gi">+# for use by from_wire()</span>
<span class="gi">+_MAX_LATITUDE = 0x80000000 + 90 * 3600000</span>
<span class="gi">+_MIN_LATITUDE = 0x80000000 - 90 * 3600000</span>
<span class="gi">+_MAX_LONGITUDE = 0x80000000 + 180 * 3600000</span>
<span class="gi">+_MIN_LONGITUDE = 0x80000000 - 180 * 3600000</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _exponent_of(what, desc):</span>
<span class="gi">+    if what == 0:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    exp = None</span>
<span class="gi">+    for i, pow in enumerate(_pows):</span>
<span class="gi">+        if what &lt; pow:</span>
<span class="gi">+            exp = i - 1</span>
<span class="gi">+            break</span>
<span class="gi">+    if exp is None or exp &lt; 0:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;%s value out of bounds&quot; % desc)</span>
<span class="gi">+    return exp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _float_to_tuple(what):</span>
<span class="gi">+    if what &lt; 0:</span>
<span class="gi">+        sign = -1</span>
<span class="gi">+        what *= -1</span>
<span class="gi">+    else:</span>
<span class="gi">+        sign = 1</span>
<span class="gi">+    what = round(what * 3600000)</span>
<span class="gi">+    degrees = int(what // 3600000)</span>
<span class="gi">+    what -= degrees * 3600000</span>
<span class="gi">+    minutes = int(what // 60000)</span>
<span class="gi">+    what -= minutes * 60000</span>
<span class="gi">+    seconds = int(what // 1000)</span>
<span class="gi">+    what -= int(seconds * 1000)</span>
<span class="gi">+    what = int(what)</span>
<span class="gi">+    return (degrees, minutes, seconds, what, sign)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tuple_to_float(what):</span>
<span class="gi">+    value = float(what[0])</span>
<span class="gi">+    value += float(what[1]) / 60.0</span>
<span class="gi">+    value += float(what[2]) / 3600.0</span>
<span class="gi">+    value += float(what[3]) / 3600000.0</span>
<span class="gi">+    return float(what[4]) * value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _encode_size(what, desc):</span>
<span class="gi">+    what = int(what)</span>
<span class="gi">+    exponent = _exponent_of(what, desc) &amp; 0xF</span>
<span class="gi">+    base = what // pow(10, exponent) &amp; 0xF</span>
<span class="gi">+    return base * 16 + exponent</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _decode_size(what, desc):</span>
<span class="gi">+    exponent = what &amp; 0x0F</span>
<span class="gi">+    if exponent &gt; 9:</span>
<span class="gi">+        raise dns.exception.FormError(&quot;bad %s exponent&quot; % desc)</span>
<span class="gi">+    base = (what &amp; 0xF0) &gt;&gt; 4</span>
<span class="gi">+    if base &gt; 9:</span>
<span class="gi">+        raise dns.exception.FormError(&quot;bad %s base&quot; % desc)</span>
<span class="gi">+    return base * pow(10, exponent)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_coordinate_list(value, low, high):</span>
<span class="gi">+    if value[0] &lt; low or value[0] &gt; high:</span>
<span class="gi">+        raise ValueError(f&quot;not in range [{low}, {high}]&quot;)</span>
<span class="gi">+    if value[1] &lt; 0 or value[1] &gt; 59:</span>
<span class="gi">+        raise ValueError(&quot;bad minutes value&quot;)</span>
<span class="gi">+    if value[2] &lt; 0 or value[2] &gt; 59:</span>
<span class="gi">+        raise ValueError(&quot;bad seconds value&quot;)</span>
<span class="gi">+    if value[3] &lt; 0 or value[3] &gt; 999:</span>
<span class="gi">+        raise ValueError(&quot;bad milliseconds value&quot;)</span>
<span class="gi">+    if value[4] != 1 and value[4] != -1:</span>
<span class="gi">+        raise ValueError(&quot;bad hemisphere value&quot;)</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class LOC(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;LOC record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;latitude&#39;, &#39;longitude&#39;, &#39;altitude&#39;, &#39;size&#39;,</span>
<span class="gd">-        &#39;horizontal_precision&#39;, &#39;vertical_precision&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, latitude, longitude, altitude, size</span>
<span class="gd">-        =_default_size, hprec=_default_hprec, vprec=_default_vprec):</span>
<span class="gi">+    # see: RFC 1876</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;latitude&quot;,</span>
<span class="gi">+        &quot;longitude&quot;,</span>
<span class="gi">+        &quot;altitude&quot;,</span>
<span class="gi">+        &quot;size&quot;,</span>
<span class="gi">+        &quot;horizontal_precision&quot;,</span>
<span class="gi">+        &quot;vertical_precision&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        latitude,</span>
<span class="gi">+        longitude,</span>
<span class="gi">+        altitude,</span>
<span class="gi">+        size=_default_size,</span>
<span class="gi">+        hprec=_default_hprec,</span>
<span class="gi">+        vprec=_default_vprec,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a LOC record instance.

<span class="w"> </span>        The parameters I{latitude} and I{longitude} may be either a 4-tuple
<span class="gu">@@ -27,6 +136,7 @@ class LOC(dns.rdata.Rdata):</span>
<span class="w"> </span>        or they may be floating point values specifying the number of
<span class="w"> </span>        degrees. The other parameters are floats. Size, horizontal precision,
<span class="w"> </span>        and vertical precision are specified in centimeters.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        if isinstance(latitude, int):
<span class="w"> </span>            latitude = float(latitude)
<span class="gu">@@ -45,12 +155,200 @@ class LOC(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.horizontal_precision = float(hprec)
<span class="w"> </span>        self.vertical_precision = float(vprec)

<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        if self.latitude[4] &gt; 0:</span>
<span class="gi">+            lat_hemisphere = &quot;N&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            lat_hemisphere = &quot;S&quot;</span>
<span class="gi">+        if self.longitude[4] &gt; 0:</span>
<span class="gi">+            long_hemisphere = &quot;E&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            long_hemisphere = &quot;W&quot;</span>
<span class="gi">+        text = &quot;%d %d %d.%03d %s %d %d %d.%03d %s %0.2fm&quot; % (</span>
<span class="gi">+            self.latitude[0],</span>
<span class="gi">+            self.latitude[1],</span>
<span class="gi">+            self.latitude[2],</span>
<span class="gi">+            self.latitude[3],</span>
<span class="gi">+            lat_hemisphere,</span>
<span class="gi">+            self.longitude[0],</span>
<span class="gi">+            self.longitude[1],</span>
<span class="gi">+            self.longitude[2],</span>
<span class="gi">+            self.longitude[3],</span>
<span class="gi">+            long_hemisphere,</span>
<span class="gi">+            self.altitude / 100.0,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # do not print default values</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.size != _default_size</span>
<span class="gi">+            or self.horizontal_precision != _default_hprec</span>
<span class="gi">+            or self.vertical_precision != _default_vprec</span>
<span class="gi">+        ):</span>
<span class="gi">+            text += &quot; {:0.2f}m {:0.2f}m {:0.2f}m&quot;.format(</span>
<span class="gi">+                self.size / 100.0,</span>
<span class="gi">+                self.horizontal_precision / 100.0,</span>
<span class="gi">+                self.vertical_precision / 100.0,</span>
<span class="gi">+            )</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        latitude = [0, 0, 0, 0, 1]</span>
<span class="gi">+        longitude = [0, 0, 0, 0, 1]</span>
<span class="gi">+        size = _default_size</span>
<span class="gi">+        hprec = _default_hprec</span>
<span class="gi">+        vprec = _default_vprec</span>
<span class="gi">+</span>
<span class="gi">+        latitude[0] = tok.get_int()</span>
<span class="gi">+        t = tok.get_string()</span>
<span class="gi">+        if t.isdigit():</span>
<span class="gi">+            latitude[1] = int(t)</span>
<span class="gi">+            t = tok.get_string()</span>
<span class="gi">+            if &quot;.&quot; in t:</span>
<span class="gi">+                (seconds, milliseconds) = t.split(&quot;.&quot;)</span>
<span class="gi">+                if not seconds.isdigit():</span>
<span class="gi">+                    raise dns.exception.SyntaxError(&quot;bad latitude seconds value&quot;)</span>
<span class="gi">+                latitude[2] = int(seconds)</span>
<span class="gi">+                l = len(milliseconds)</span>
<span class="gi">+                if l == 0 or l &gt; 3 or not milliseconds.isdigit():</span>
<span class="gi">+                    raise dns.exception.SyntaxError(&quot;bad latitude milliseconds value&quot;)</span>
<span class="gi">+                if l == 1:</span>
<span class="gi">+                    m = 100</span>
<span class="gi">+                elif l == 2:</span>
<span class="gi">+                    m = 10</span>
<span class="gi">+                else:</span>
<span class="gi">+                    m = 1</span>
<span class="gi">+                latitude[3] = m * int(milliseconds)</span>
<span class="gi">+                t = tok.get_string()</span>
<span class="gi">+            elif t.isdigit():</span>
<span class="gi">+                latitude[2] = int(t)</span>
<span class="gi">+                t = tok.get_string()</span>
<span class="gi">+        if t == &quot;S&quot;:</span>
<span class="gi">+            latitude[4] = -1</span>
<span class="gi">+        elif t != &quot;N&quot;:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;bad latitude hemisphere value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        longitude[0] = tok.get_int()</span>
<span class="gi">+        t = tok.get_string()</span>
<span class="gi">+        if t.isdigit():</span>
<span class="gi">+            longitude[1] = int(t)</span>
<span class="gi">+            t = tok.get_string()</span>
<span class="gi">+            if &quot;.&quot; in t:</span>
<span class="gi">+                (seconds, milliseconds) = t.split(&quot;.&quot;)</span>
<span class="gi">+                if not seconds.isdigit():</span>
<span class="gi">+                    raise dns.exception.SyntaxError(&quot;bad longitude seconds value&quot;)</span>
<span class="gi">+                longitude[2] = int(seconds)</span>
<span class="gi">+                l = len(milliseconds)</span>
<span class="gi">+                if l == 0 or l &gt; 3 or not milliseconds.isdigit():</span>
<span class="gi">+                    raise dns.exception.SyntaxError(&quot;bad longitude milliseconds value&quot;)</span>
<span class="gi">+                if l == 1:</span>
<span class="gi">+                    m = 100</span>
<span class="gi">+                elif l == 2:</span>
<span class="gi">+                    m = 10</span>
<span class="gi">+                else:</span>
<span class="gi">+                    m = 1</span>
<span class="gi">+                longitude[3] = m * int(milliseconds)</span>
<span class="gi">+                t = tok.get_string()</span>
<span class="gi">+            elif t.isdigit():</span>
<span class="gi">+                longitude[2] = int(t)</span>
<span class="gi">+                t = tok.get_string()</span>
<span class="gi">+        if t == &quot;W&quot;:</span>
<span class="gi">+            longitude[4] = -1</span>
<span class="gi">+        elif t != &quot;E&quot;:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;bad longitude hemisphere value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        t = tok.get_string()</span>
<span class="gi">+        if t[-1] == &quot;m&quot;:</span>
<span class="gi">+            t = t[0:-1]</span>
<span class="gi">+        altitude = float(t) * 100.0  # m -&gt; cm</span>
<span class="gi">+</span>
<span class="gi">+        tokens = tok.get_remaining(max_tokens=3)</span>
<span class="gi">+        if len(tokens) &gt;= 1:</span>
<span class="gi">+            value = tokens[0].unescape().value</span>
<span class="gi">+            if value[-1] == &quot;m&quot;:</span>
<span class="gi">+                value = value[0:-1]</span>
<span class="gi">+            size = float(value) * 100.0  # m -&gt; cm</span>
<span class="gi">+            if len(tokens) &gt;= 2:</span>
<span class="gi">+                value = tokens[1].unescape().value</span>
<span class="gi">+                if value[-1] == &quot;m&quot;:</span>
<span class="gi">+                    value = value[0:-1]</span>
<span class="gi">+                hprec = float(value) * 100.0  # m -&gt; cm</span>
<span class="gi">+                if len(tokens) &gt;= 3:</span>
<span class="gi">+                    value = tokens[2].unescape().value</span>
<span class="gi">+                    if value[-1] == &quot;m&quot;:</span>
<span class="gi">+                        value = value[0:-1]</span>
<span class="gi">+                    vprec = float(value) * 100.0  # m -&gt; cm</span>
<span class="gi">+</span>
<span class="gi">+        # Try encoding these now so we raise if they are bad</span>
<span class="gi">+        _encode_size(size, &quot;size&quot;)</span>
<span class="gi">+        _encode_size(hprec, &quot;horizontal precision&quot;)</span>
<span class="gi">+        _encode_size(vprec, &quot;vertical precision&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(rdclass, rdtype, latitude, longitude, altitude, size, hprec, vprec)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        milliseconds = (</span>
<span class="gi">+            self.latitude[0] * 3600000</span>
<span class="gi">+            + self.latitude[1] * 60000</span>
<span class="gi">+            + self.latitude[2] * 1000</span>
<span class="gi">+            + self.latitude[3]</span>
<span class="gi">+        ) * self.latitude[4]</span>
<span class="gi">+        latitude = 0x80000000 + milliseconds</span>
<span class="gi">+        milliseconds = (</span>
<span class="gi">+            self.longitude[0] * 3600000</span>
<span class="gi">+            + self.longitude[1] * 60000</span>
<span class="gi">+            + self.longitude[2] * 1000</span>
<span class="gi">+            + self.longitude[3]</span>
<span class="gi">+        ) * self.longitude[4]</span>
<span class="gi">+        longitude = 0x80000000 + milliseconds</span>
<span class="gi">+        altitude = int(self.altitude) + 10000000</span>
<span class="gi">+        size = _encode_size(self.size, &quot;size&quot;)</span>
<span class="gi">+        hprec = _encode_size(self.horizontal_precision, &quot;horizontal precision&quot;)</span>
<span class="gi">+        vprec = _encode_size(self.vertical_precision, &quot;vertical precision&quot;)</span>
<span class="gi">+        wire = struct.pack(</span>
<span class="gi">+            &quot;!BBBBIII&quot;, 0, size, hprec, vprec, latitude, longitude, altitude</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(wire)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (</span>
<span class="gi">+            version,</span>
<span class="gi">+            size,</span>
<span class="gi">+            hprec,</span>
<span class="gi">+            vprec,</span>
<span class="gi">+            latitude,</span>
<span class="gi">+            longitude,</span>
<span class="gi">+            altitude,</span>
<span class="gi">+        ) = parser.get_struct(&quot;!BBBBIII&quot;)</span>
<span class="gi">+        if version != 0:</span>
<span class="gi">+            raise dns.exception.FormError(&quot;LOC version not zero&quot;)</span>
<span class="gi">+        if latitude &lt; _MIN_LATITUDE or latitude &gt; _MAX_LATITUDE:</span>
<span class="gi">+            raise dns.exception.FormError(&quot;bad latitude&quot;)</span>
<span class="gi">+        if latitude &gt; 0x80000000:</span>
<span class="gi">+            latitude = (latitude - 0x80000000) / 3600000</span>
<span class="gi">+        else:</span>
<span class="gi">+            latitude = -1 * (0x80000000 - latitude) / 3600000</span>
<span class="gi">+        if longitude &lt; _MIN_LONGITUDE or longitude &gt; _MAX_LONGITUDE:</span>
<span class="gi">+            raise dns.exception.FormError(&quot;bad longitude&quot;)</span>
<span class="gi">+        if longitude &gt; 0x80000000:</span>
<span class="gi">+            longitude = (longitude - 0x80000000) / 3600000</span>
<span class="gi">+        else:</span>
<span class="gi">+            longitude = -1 * (0x80000000 - longitude) / 3600000</span>
<span class="gi">+        altitude = float(altitude) - 10000000.0</span>
<span class="gi">+        size = _decode_size(size, &quot;size&quot;)</span>
<span class="gi">+        hprec = _decode_size(hprec, &quot;horizontal precision&quot;)</span>
<span class="gi">+        vprec = _decode_size(vprec, &quot;vertical precision&quot;)</span>
<span class="gi">+        return cls(rdclass, rdtype, latitude, longitude, altitude, size, hprec, vprec)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def float_latitude(self):
<span class="gd">-        &quot;&quot;&quot;latitude as a floating point value&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;latitude as a floating point value&quot;</span>
<span class="gi">+        return _tuple_to_float(self.latitude)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_longitude(self):
<span class="gd">-        &quot;&quot;&quot;longitude as a floating point value&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;longitude as a floating point value&quot;</span>
<span class="gi">+        return _tuple_to_float(self.longitude)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/LP.py b/dns/rdtypes/ANY/LP.py</span>
<span class="gh">index 44d48de..312663f 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/LP.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/LP.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata

<span class="gu">@@ -6,9 +9,34 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class LP(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;LP record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;preference&#39;, &#39;fqdn&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc6742.txt</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;preference&quot;, &quot;fqdn&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, preference, fqdn):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        self.fqdn = self._as_name(fqdn)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        fqdn = self.fqdn.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;%d %s&quot; % (self.preference, fqdn)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        fqdn = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, fqdn)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, self.preference))</span>
<span class="gi">+        self.fqdn.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        preference = parser.get_uint16()</span>
<span class="gi">+        fqdn = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, fqdn)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/MX.py b/dns/rdtypes/ANY/MX.py</span>
<span class="gh">index 560cf68..0c300c5 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/MX.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/MX.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.mxbase

<span class="gh">diff --git a/dns/rdtypes/ANY/NID.py b/dns/rdtypes/ANY/NID.py</span>
<span class="gh">index 4f8b115..2f64917 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/NID.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/NID.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.util

<span class="gu">@@ -6,15 +9,39 @@ import dns.rdtypes.util</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NID(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;NID record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;preference&#39;, &#39;nodeid&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc6742.txt</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;preference&quot;, &quot;nodeid&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, preference, nodeid):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        if isinstance(nodeid, bytes):
<span class="w"> </span>            if len(nodeid) != 8:
<span class="gd">-                raise ValueError(&#39;invalid nodeid&#39;)</span>
<span class="gd">-            self.nodeid = dns.rdata._hexify(nodeid, 4, b&#39;:&#39;)</span>
<span class="gi">+                raise ValueError(&quot;invalid nodeid&quot;)</span>
<span class="gi">+            self.nodeid = dns.rdata._hexify(nodeid, 4, b&quot;:&quot;)</span>
<span class="w"> </span>        else:
<span class="gd">-            dns.rdtypes.util.parse_formatted_hex(nodeid, 4, 4, &#39;:&#39;)</span>
<span class="gi">+            dns.rdtypes.util.parse_formatted_hex(nodeid, 4, 4, &quot;:&quot;)</span>
<span class="w"> </span>            self.nodeid = nodeid
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return f&quot;{self.preference} {self.nodeid}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        nodeid = tok.get_identifier()</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, nodeid)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, self.preference))</span>
<span class="gi">+        file.write(dns.rdtypes.util.parse_formatted_hex(self.nodeid, 4, 4, &quot;:&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        preference = parser.get_uint16()</span>
<span class="gi">+        nodeid = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, nodeid)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/NINFO.py b/dns/rdtypes/ANY/NINFO.py</span>
<span class="gh">index cb66fe7..b177bdd 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/NINFO.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/NINFO.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.txtbase

<span class="gu">@@ -5,3 +22,5 @@ import dns.rdtypes.txtbase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NINFO(dns.rdtypes.txtbase.TXTBase):
<span class="w"> </span>    &quot;&quot;&quot;NINFO record&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # see: draft-reid-dnsext-zs-01</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/NS.py b/dns/rdtypes/ANY/NS.py</span>
<span class="gh">index bc1f8b0..c3f34ce 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/NS.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/NS.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.nsbase

<span class="gh">diff --git a/dns/rdtypes/ANY/NSEC.py b/dns/rdtypes/ANY/NSEC.py</span>
<span class="gh">index 3a68e73..340525a 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/NSEC.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/NSEC.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -8,13 +25,14 @@ import dns.rdtypes.util</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class Bitmap(dns.rdtypes.util.Bitmap):
<span class="gd">-    type_name = &#39;NSEC&#39;</span>
<span class="gi">+    type_name = &quot;NSEC&quot;</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NSEC(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;NSEC record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;next&#39;, &#39;windows&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;next&quot;, &quot;windows&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, next, windows):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -22,3 +40,28 @@ class NSEC(dns.rdata.Rdata):</span>
<span class="w"> </span>        if not isinstance(windows, Bitmap):
<span class="w"> </span>            windows = Bitmap(windows)
<span class="w"> </span>        self.windows = tuple(windows.windows)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        next = self.next.choose_relativity(origin, relativize)</span>
<span class="gi">+        text = Bitmap(self.windows).to_text()</span>
<span class="gi">+        return &quot;{}{}&quot;.format(next, text)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        next = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        windows = Bitmap.from_text(tok)</span>
<span class="gi">+        return cls(rdclass, rdtype, next, windows)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        # Note that NSEC downcasing, originally mandated by RFC 4034</span>
<span class="gi">+        # section 6.2 was removed by RFC 6840 section 5.1.</span>
<span class="gi">+        self.next.to_wire(file, None, origin, False)</span>
<span class="gi">+        Bitmap(self.windows).to_wire(file)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        next = parser.get_name(origin)</span>
<span class="gi">+        bitmap = Bitmap.from_wire_parser(parser)</span>
<span class="gi">+        return cls(rdclass, rdtype, next, bitmap)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/NSEC3.py b/dns/rdtypes/ANY/NSEC3.py</span>
<span class="gh">index 4f6caed..d71302b 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/NSEC3.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/NSEC3.py</span>
<span class="gu">@@ -1,31 +1,58 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="w"> </span>import dns.rdatatype
<span class="w"> </span>import dns.rdtypes.util
<span class="gd">-b32_hex_to_normal = bytes.maketrans(b&#39;0123456789ABCDEFGHIJKLMNOPQRSTUV&#39;,</span>
<span class="gd">-    b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#39;)</span>
<span class="gd">-b32_normal_to_hex = bytes.maketrans(b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#39;,</span>
<span class="gd">-    b&#39;0123456789ABCDEFGHIJKLMNOPQRSTUV&#39;)</span>
<span class="gi">+</span>
<span class="gi">+b32_hex_to_normal = bytes.maketrans(</span>
<span class="gi">+    b&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;, b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>
<span class="gi">+)</span>
<span class="gi">+b32_normal_to_hex = bytes.maketrans(</span>
<span class="gi">+    b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;, b&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# hash algorithm constants</span>
<span class="w"> </span>SHA1 = 1
<span class="gi">+</span>
<span class="gi">+# flag constants</span>
<span class="w"> </span>OPTOUT = 1


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class Bitmap(dns.rdtypes.util.Bitmap):
<span class="gd">-    type_name = &#39;NSEC3&#39;</span>
<span class="gi">+    type_name = &quot;NSEC3&quot;</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NSEC3(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;NSEC3 record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;algorithm&#39;, &#39;flags&#39;, &#39;iterations&#39;, &#39;salt&#39;, &#39;next&#39;, &#39;windows&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, algorithm, flags, iterations, salt,</span>
<span class="gd">-        next, windows):</span>
<span class="gi">+    __slots__ = [&quot;algorithm&quot;, &quot;flags&quot;, &quot;iterations&quot;, &quot;salt&quot;, &quot;next&quot;, &quot;windows&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, rdclass, rdtype, algorithm, flags, iterations, salt, next, windows</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.algorithm = self._as_uint8(algorithm)
<span class="w"> </span>        self.flags = self._as_uint8(flags)
<span class="gu">@@ -35,3 +62,65 @@ class NSEC3(dns.rdata.Rdata):</span>
<span class="w"> </span>        if not isinstance(windows, Bitmap):
<span class="w"> </span>            windows = Bitmap(windows)
<span class="w"> </span>        self.windows = tuple(windows.windows)
<span class="gi">+</span>
<span class="gi">+    def _next_text(self):</span>
<span class="gi">+        next = base64.b32encode(self.next).translate(b32_normal_to_hex).lower().decode()</span>
<span class="gi">+        next = next.rstrip(&quot;=&quot;)</span>
<span class="gi">+        return next</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        next = self._next_text()</span>
<span class="gi">+        if self.salt == b&quot;&quot;:</span>
<span class="gi">+            salt = &quot;-&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            salt = binascii.hexlify(self.salt).decode()</span>
<span class="gi">+        text = Bitmap(self.windows).to_text()</span>
<span class="gi">+        return &quot;%u %u %u %s %s%s&quot; % (</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            self.flags,</span>
<span class="gi">+            self.iterations,</span>
<span class="gi">+            salt,</span>
<span class="gi">+            next,</span>
<span class="gi">+            text,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        algorithm = tok.get_uint8()</span>
<span class="gi">+        flags = tok.get_uint8()</span>
<span class="gi">+        iterations = tok.get_uint16()</span>
<span class="gi">+        salt = tok.get_string()</span>
<span class="gi">+        if salt == &quot;-&quot;:</span>
<span class="gi">+            salt = b&quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            salt = binascii.unhexlify(salt.encode(&quot;ascii&quot;))</span>
<span class="gi">+        next = tok.get_string().encode(&quot;ascii&quot;).upper().translate(b32_hex_to_normal)</span>
<span class="gi">+        if next.endswith(b&quot;=&quot;):</span>
<span class="gi">+            raise binascii.Error(&quot;Incorrect padding&quot;)</span>
<span class="gi">+        if len(next) % 8 != 0:</span>
<span class="gi">+            next += b&quot;=&quot; * (8 - len(next) % 8)</span>
<span class="gi">+        next = base64.b32decode(next)</span>
<span class="gi">+        bitmap = Bitmap.from_text(tok)</span>
<span class="gi">+        return cls(rdclass, rdtype, algorithm, flags, iterations, salt, next, bitmap)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        l = len(self.salt)</span>
<span class="gi">+        file.write(struct.pack(&quot;!BBHB&quot;, self.algorithm, self.flags, self.iterations, l))</span>
<span class="gi">+        file.write(self.salt)</span>
<span class="gi">+        l = len(self.next)</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.next)</span>
<span class="gi">+        Bitmap(self.windows).to_wire(file)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (algorithm, flags, iterations) = parser.get_struct(&quot;!BBH&quot;)</span>
<span class="gi">+        salt = parser.get_counted_bytes()</span>
<span class="gi">+        next = parser.get_counted_bytes()</span>
<span class="gi">+        bitmap = Bitmap.from_wire_parser(parser)</span>
<span class="gi">+        return cls(rdclass, rdtype, algorithm, flags, iterations, salt, next, bitmap)</span>
<span class="gi">+</span>
<span class="gi">+    def next_name(self, origin=None):</span>
<span class="gi">+        return dns.name.from_text(self._next_text(), origin)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/NSEC3PARAM.py b/dns/rdtypes/ANY/NSEC3PARAM.py</span>
<span class="gh">index 0d40074..d1e62eb 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/NSEC3PARAM.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/NSEC3PARAM.py</span>
<span class="gu">@@ -1,5 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,7 +26,8 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NSEC3PARAM(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;NSEC3PARAM record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;algorithm&#39;, &#39;flags&#39;, &#39;iterations&#39;, &#39;salt&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;algorithm&quot;, &quot;flags&quot;, &quot;iterations&quot;, &quot;salt&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, algorithm, flags, iterations, salt):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -16,3 +35,35 @@ class NSEC3PARAM(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.flags = self._as_uint8(flags)
<span class="w"> </span>        self.iterations = self._as_uint16(iterations)
<span class="w"> </span>        self.salt = self._as_bytes(salt, True, 255)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        if self.salt == b&quot;&quot;:</span>
<span class="gi">+            salt = &quot;-&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            salt = binascii.hexlify(self.salt).decode()</span>
<span class="gi">+        return &quot;%u %u %u %s&quot; % (self.algorithm, self.flags, self.iterations, salt)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        algorithm = tok.get_uint8()</span>
<span class="gi">+        flags = tok.get_uint8()</span>
<span class="gi">+        iterations = tok.get_uint16()</span>
<span class="gi">+        salt = tok.get_string()</span>
<span class="gi">+        if salt == &quot;-&quot;:</span>
<span class="gi">+            salt = &quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            salt = binascii.unhexlify(salt.encode())</span>
<span class="gi">+        return cls(rdclass, rdtype, algorithm, flags, iterations, salt)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        l = len(self.salt)</span>
<span class="gi">+        file.write(struct.pack(&quot;!BBHB&quot;, self.algorithm, self.flags, self.iterations, l))</span>
<span class="gi">+        file.write(self.salt)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (algorithm, flags, iterations) = parser.get_struct(&quot;!BBH&quot;)</span>
<span class="gi">+        salt = parser.get_counted_bytes()</span>
<span class="gi">+        return cls(rdclass, rdtype, algorithm, flags, iterations, salt)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/OPENPGPKEY.py b/dns/rdtypes/ANY/OPENPGPKEY.py</span>
<span class="gh">index 2722935..4d7a4b6 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/OPENPGPKEY.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/OPENPGPKEY.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2016 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -9,6 +27,27 @@ import dns.tokenizer</span>
<span class="w"> </span>class OPENPGPKEY(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;OPENPGPKEY record&quot;&quot;&quot;

<span class="gi">+    # see: RFC 7929</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, rdclass, rdtype, key):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.key = self._as_bytes(key)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return dns.rdata._base64ify(self.key, chunksize=None, **kw)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        b64 = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        key = base64.b64decode(b64)</span>
<span class="gi">+        return cls(rdclass, rdtype, key)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(self.key)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        key = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, key)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/OPT.py b/dns/rdtypes/ANY/OPT.py</span>
<span class="gh">index 096cbcb..d343dfa 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/OPT.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/OPT.py</span>
<span class="gu">@@ -1,14 +1,36 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.edns
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata

<span class="gi">+# We don&#39;t implement from_text, and that&#39;s ok.</span>
<span class="gi">+# pylint: disable=abstract-method</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class OPT(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;OPT record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;options&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;options&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, options):
<span class="w"> </span>        &quot;&quot;&quot;Initialize an OPT rdata.
<span class="gu">@@ -20,15 +42,36 @@ class OPT(dns.rdata.Rdata):</span>

<span class="w"> </span>        *options*, a tuple of ``bytes``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)

<span class="w"> </span>        def as_option(option):
<span class="w"> </span>            if not isinstance(option, dns.edns.Option):
<span class="gd">-                raise ValueError(&#39;option is not a dns.edns.option&#39;)</span>
<span class="gi">+                raise ValueError(&quot;option is not a dns.edns.option&quot;)</span>
<span class="w"> </span>            return option
<span class="gi">+</span>
<span class="w"> </span>        self.options = self._as_tuple(options, as_option)

<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        for opt in self.options:</span>
<span class="gi">+            owire = opt.to_wire()</span>
<span class="gi">+            file.write(struct.pack(&quot;!HH&quot;, opt.otype, len(owire)))</span>
<span class="gi">+            file.write(owire)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &quot; &quot;.join(opt.to_text() for opt in self.options)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        options = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            (otype, olen) = parser.get_struct(&quot;!HH&quot;)</span>
<span class="gi">+            with parser.restrict_to(olen):</span>
<span class="gi">+                opt = dns.edns.option_from_wire_parser(otype, parser)</span>
<span class="gi">+            options.append(opt)</span>
<span class="gi">+        return cls(rdclass, rdtype, options)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def payload(self):
<span class="gd">-        &quot;&quot;&quot;payload size&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;payload size&quot;</span>
<span class="gi">+        return self.rdclass</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/PTR.py b/dns/rdtypes/ANY/PTR.py</span>
<span class="gh">index b0a3915..98c3616 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/PTR.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/PTR.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.nsbase

<span class="gh">diff --git a/dns/rdtypes/ANY/RP.py b/dns/rdtypes/ANY/RP.py</span>
<span class="gh">index ab9501f..9b74549 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/RP.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/RP.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -7,9 +24,35 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class RP(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;RP record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;mbox&#39;, &#39;txt&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 1183</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;mbox&quot;, &quot;txt&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, mbox, txt):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.mbox = self._as_name(mbox)
<span class="w"> </span>        self.txt = self._as_name(txt)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        mbox = self.mbox.choose_relativity(origin, relativize)</span>
<span class="gi">+        txt = self.txt.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;{} {}&quot;.format(str(mbox), str(txt))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        mbox = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        txt = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(rdclass, rdtype, mbox, txt)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.mbox.to_wire(file, None, origin, canonicalize)</span>
<span class="gi">+        self.txt.to_wire(file, None, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        mbox = parser.get_name(origin)</span>
<span class="gi">+        txt = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, mbox, txt)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/RRSIG.py b/dns/rdtypes/ANY/RRSIG.py</span>
<span class="gh">index d8b408e..8beb423 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/RRSIG.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/RRSIG.py</span>
<span class="gu">@@ -1,7 +1,25 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import calendar
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>import dns.dnssectypes
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="gu">@@ -13,14 +31,54 @@ class BadSigTime(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;Time in DNS SIG or RRSIG resource record cannot be parsed.&quot;&quot;&quot;


<span class="gi">+def sigtime_to_posixtime(what):</span>
<span class="gi">+    if len(what) &lt;= 10 and what.isdigit():</span>
<span class="gi">+        return int(what)</span>
<span class="gi">+    if len(what) != 14:</span>
<span class="gi">+        raise BadSigTime</span>
<span class="gi">+    year = int(what[0:4])</span>
<span class="gi">+    month = int(what[4:6])</span>
<span class="gi">+    day = int(what[6:8])</span>
<span class="gi">+    hour = int(what[8:10])</span>
<span class="gi">+    minute = int(what[10:12])</span>
<span class="gi">+    second = int(what[12:14])</span>
<span class="gi">+    return calendar.timegm((year, month, day, hour, minute, second, 0, 0, 0))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def posixtime_to_sigtime(what):</span>
<span class="gi">+    return time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.gmtime(what))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class RRSIG(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;RRSIG record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;type_covered&#39;, &#39;algorithm&#39;, &#39;labels&#39;, &#39;original_ttl&#39;,</span>
<span class="gd">-        &#39;expiration&#39;, &#39;inception&#39;, &#39;key_tag&#39;, &#39;signer&#39;, &#39;signature&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, type_covered, algorithm, labels,</span>
<span class="gd">-        original_ttl, expiration, inception, key_tag, signer, signature):</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;type_covered&quot;,</span>
<span class="gi">+        &quot;algorithm&quot;,</span>
<span class="gi">+        &quot;labels&quot;,</span>
<span class="gi">+        &quot;original_ttl&quot;,</span>
<span class="gi">+        &quot;expiration&quot;,</span>
<span class="gi">+        &quot;inception&quot;,</span>
<span class="gi">+        &quot;key_tag&quot;,</span>
<span class="gi">+        &quot;signer&quot;,</span>
<span class="gi">+        &quot;signature&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        type_covered,</span>
<span class="gi">+        algorithm,</span>
<span class="gi">+        labels,</span>
<span class="gi">+        original_ttl,</span>
<span class="gi">+        expiration,</span>
<span class="gi">+        inception,</span>
<span class="gi">+        key_tag,</span>
<span class="gi">+        signer,</span>
<span class="gi">+        signature,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.type_covered = self._as_rdatatype(type_covered)
<span class="w"> </span>        self.algorithm = dns.dnssectypes.Algorithm.make(algorithm)
<span class="gu">@@ -31,3 +89,69 @@ class RRSIG(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.key_tag = self._as_uint16(key_tag)
<span class="w"> </span>        self.signer = self._as_name(signer)
<span class="w"> </span>        self.signature = self._as_bytes(signature)
<span class="gi">+</span>
<span class="gi">+    def covers(self):</span>
<span class="gi">+        return self.type_covered</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &quot;%s %d %d %d %s %s %d %s %s&quot; % (</span>
<span class="gi">+            dns.rdatatype.to_text(self.type_covered),</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            self.labels,</span>
<span class="gi">+            self.original_ttl,</span>
<span class="gi">+            posixtime_to_sigtime(self.expiration),</span>
<span class="gi">+            posixtime_to_sigtime(self.inception),</span>
<span class="gi">+            self.key_tag,</span>
<span class="gi">+            self.signer.choose_relativity(origin, relativize),</span>
<span class="gi">+            dns.rdata._base64ify(self.signature, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        type_covered = dns.rdatatype.from_text(tok.get_string())</span>
<span class="gi">+        algorithm = dns.dnssectypes.Algorithm.from_text(tok.get_string())</span>
<span class="gi">+        labels = tok.get_int()</span>
<span class="gi">+        original_ttl = tok.get_ttl()</span>
<span class="gi">+        expiration = sigtime_to_posixtime(tok.get_string())</span>
<span class="gi">+        inception = sigtime_to_posixtime(tok.get_string())</span>
<span class="gi">+        key_tag = tok.get_int()</span>
<span class="gi">+        signer = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        b64 = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        signature = base64.b64decode(b64)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            rdtype,</span>
<span class="gi">+            type_covered,</span>
<span class="gi">+            algorithm,</span>
<span class="gi">+            labels,</span>
<span class="gi">+            original_ttl,</span>
<span class="gi">+            expiration,</span>
<span class="gi">+            inception,</span>
<span class="gi">+            key_tag,</span>
<span class="gi">+            signer,</span>
<span class="gi">+            signature,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(</span>
<span class="gi">+            &quot;!HBBIIIH&quot;,</span>
<span class="gi">+            self.type_covered,</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            self.labels,</span>
<span class="gi">+            self.original_ttl,</span>
<span class="gi">+            self.expiration,</span>
<span class="gi">+            self.inception,</span>
<span class="gi">+            self.key_tag,</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        self.signer.to_wire(file, None, origin, canonicalize)</span>
<span class="gi">+        file.write(self.signature)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;!HBBIIIH&quot;)</span>
<span class="gi">+        signer = parser.get_name(origin)</span>
<span class="gi">+        signature = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, *header, signer, signature)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/RT.py b/dns/rdtypes/ANY/RT.py</span>
<span class="gh">index 93a6252..5a4d45c 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/RT.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/RT.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.mxbase

<span class="gh">diff --git a/dns/rdtypes/ANY/SMIMEA.py b/dns/rdtypes/ANY/SMIMEA.py</span>
<span class="gh">index f61fd49..55d87bf 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/SMIMEA.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/SMIMEA.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.tlsabase

<span class="gh">diff --git a/dns/rdtypes/ANY/SOA.py b/dns/rdtypes/ANY/SOA.py</span>
<span class="gh">index 62d0470..09aa832 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/SOA.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/SOA.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -8,11 +26,14 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class SOA(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;SOA record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;mname&#39;, &#39;rname&#39;, &#39;serial&#39;, &#39;refresh&#39;, &#39;retry&#39;, &#39;expire&#39;,</span>
<span class="gd">-        &#39;minimum&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, mname, rname, serial, refresh,</span>
<span class="gd">-        retry, expire, minimum):</span>
<span class="gi">+    # see: RFC 1035</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;mname&quot;, &quot;rname&quot;, &quot;serial&quot;, &quot;refresh&quot;, &quot;retry&quot;, &quot;expire&quot;, &quot;minimum&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, rdclass, rdtype, mname, rname, serial, refresh, retry, expire, minimum</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.mname = self._as_name(mname)
<span class="w"> </span>        self.rname = self._as_name(rname)
<span class="gu">@@ -21,3 +42,45 @@ class SOA(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.retry = self._as_ttl(retry)
<span class="w"> </span>        self.expire = self._as_ttl(expire)
<span class="w"> </span>        self.minimum = self._as_ttl(minimum)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        mname = self.mname.choose_relativity(origin, relativize)</span>
<span class="gi">+        rname = self.rname.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;%s %s %d %d %d %d %d&quot; % (</span>
<span class="gi">+            mname,</span>
<span class="gi">+            rname,</span>
<span class="gi">+            self.serial,</span>
<span class="gi">+            self.refresh,</span>
<span class="gi">+            self.retry,</span>
<span class="gi">+            self.expire,</span>
<span class="gi">+            self.minimum,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        mname = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        rname = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        serial = tok.get_uint32()</span>
<span class="gi">+        refresh = tok.get_ttl()</span>
<span class="gi">+        retry = tok.get_ttl()</span>
<span class="gi">+        expire = tok.get_ttl()</span>
<span class="gi">+        minimum = tok.get_ttl()</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, mname, rname, serial, refresh, retry, expire, minimum</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.mname.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+        self.rname.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+        five_ints = struct.pack(</span>
<span class="gi">+            &quot;!IIIII&quot;, self.serial, self.refresh, self.retry, self.expire, self.minimum</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(five_ints)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        mname = parser.get_name(origin)</span>
<span class="gi">+        rname = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, mname, rname, *parser.get_struct(&quot;!IIIII&quot;))</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/SPF.py b/dns/rdtypes/ANY/SPF.py</span>
<span class="gh">index 1f512e9..1df3b70 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/SPF.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/SPF.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.txtbase

<span class="gu">@@ -5,3 +22,5 @@ import dns.rdtypes.txtbase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class SPF(dns.rdtypes.txtbase.TXTBase):
<span class="w"> </span>    &quot;&quot;&quot;SPF record&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # see: RFC 4408</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/SSHFP.py b/dns/rdtypes/ANY/SSHFP.py</span>
<span class="gh">index 5bf303c..d2c4b07 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/SSHFP.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/SSHFP.py</span>
<span class="gu">@@ -1,5 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2005-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="w"> </span>import dns.rdatatype
<span class="gu">@@ -8,10 +26,43 @@ import dns.rdatatype</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class SSHFP(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;SSHFP record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;algorithm&#39;, &#39;fp_type&#39;, &#39;fingerprint&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # See RFC 4255</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;algorithm&quot;, &quot;fp_type&quot;, &quot;fingerprint&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, algorithm, fp_type, fingerprint):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.algorithm = self._as_uint8(algorithm)
<span class="w"> </span>        self.fp_type = self._as_uint8(fp_type)
<span class="w"> </span>        self.fingerprint = self._as_bytes(fingerprint, True)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        kw = kw.copy()</span>
<span class="gi">+        chunksize = kw.pop(&quot;chunksize&quot;, 128)</span>
<span class="gi">+        return &quot;%d %d %s&quot; % (</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            self.fp_type,</span>
<span class="gi">+            dns.rdata._hexify(self.fingerprint, chunksize=chunksize, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        algorithm = tok.get_uint8()</span>
<span class="gi">+        fp_type = tok.get_uint8()</span>
<span class="gi">+        fingerprint = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        fingerprint = binascii.unhexlify(fingerprint)</span>
<span class="gi">+        return cls(rdclass, rdtype, algorithm, fp_type, fingerprint)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(&quot;!BB&quot;, self.algorithm, self.fp_type)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        file.write(self.fingerprint)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;BB&quot;)</span>
<span class="gi">+        fingerprint = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, header[0], header[1], fingerprint)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/TKEY.py b/dns/rdtypes/ANY/TKEY.py</span>
<span class="gh">index 43462af..5b490b8 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/TKEY.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/TKEY.py</span>
<span class="gu">@@ -1,5 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,11 +26,29 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class TKEY(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;TKEY Record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;algorithm&#39;, &#39;inception&#39;, &#39;expiration&#39;, &#39;mode&#39;, &#39;error&#39;,</span>
<span class="gd">-        &#39;key&#39;, &#39;other&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, algorithm, inception, expiration,</span>
<span class="gd">-        mode, error, key, other=b&#39;&#39;):</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;algorithm&quot;,</span>
<span class="gi">+        &quot;inception&quot;,</span>
<span class="gi">+        &quot;expiration&quot;,</span>
<span class="gi">+        &quot;mode&quot;,</span>
<span class="gi">+        &quot;error&quot;,</span>
<span class="gi">+        &quot;key&quot;,</span>
<span class="gi">+        &quot;other&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        algorithm,</span>
<span class="gi">+        inception,</span>
<span class="gi">+        expiration,</span>
<span class="gi">+        mode,</span>
<span class="gi">+        error,</span>
<span class="gi">+        key,</span>
<span class="gi">+        other=b&quot;&quot;,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.algorithm = self._as_name(algorithm)
<span class="w"> </span>        self.inception = self._as_uint32(inception)
<span class="gu">@@ -21,6 +57,84 @@ class TKEY(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.error = self._as_uint16(error)
<span class="w"> </span>        self.key = self._as_bytes(key)
<span class="w"> </span>        self.other = self._as_bytes(other)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        _algorithm = self.algorithm.choose_relativity(origin, relativize)</span>
<span class="gi">+        text = &quot;%s %u %u %u %u %s&quot; % (</span>
<span class="gi">+            str(_algorithm),</span>
<span class="gi">+            self.inception,</span>
<span class="gi">+            self.expiration,</span>
<span class="gi">+            self.mode,</span>
<span class="gi">+            self.error,</span>
<span class="gi">+            dns.rdata._base64ify(self.key, 0),</span>
<span class="gi">+        )</span>
<span class="gi">+        if len(self.other) &gt; 0:</span>
<span class="gi">+            text += &quot; %s&quot; % (dns.rdata._base64ify(self.other, 0))</span>
<span class="gi">+</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        algorithm = tok.get_name(relativize=False)</span>
<span class="gi">+        inception = tok.get_uint32()</span>
<span class="gi">+        expiration = tok.get_uint32()</span>
<span class="gi">+        mode = tok.get_uint16()</span>
<span class="gi">+        error = tok.get_uint16()</span>
<span class="gi">+        key_b64 = tok.get_string().encode()</span>
<span class="gi">+        key = base64.b64decode(key_b64)</span>
<span class="gi">+        other_b64 = tok.concatenate_remaining_identifiers(True).encode()</span>
<span class="gi">+        other = base64.b64decode(other_b64)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, algorithm, inception, expiration, mode, error, key, other</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.algorithm.to_wire(file, compress, origin)</span>
<span class="gi">+        file.write(</span>
<span class="gi">+            struct.pack(&quot;!IIHH&quot;, self.inception, self.expiration, self.mode, self.error)</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, len(self.key)))</span>
<span class="gi">+        file.write(self.key)</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, len(self.other)))</span>
<span class="gi">+        if len(self.other) &gt; 0:</span>
<span class="gi">+            file.write(self.other)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        algorithm = parser.get_name(origin)</span>
<span class="gi">+        inception, expiration, mode, error = parser.get_struct(&quot;!IIHH&quot;)</span>
<span class="gi">+        key = parser.get_counted_bytes(2)</span>
<span class="gi">+        other = parser.get_counted_bytes(2)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, algorithm, inception, expiration, mode, error, key, other</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Constants for the mode field - from RFC 2930:</span>
<span class="gi">+    # 2.5 The Mode Field</span>
<span class="gi">+    #</span>
<span class="gi">+    #    The mode field specifies the general scheme for key agreement or</span>
<span class="gi">+    #    the purpose of the TKEY DNS message.  Servers and resolvers</span>
<span class="gi">+    #    supporting this specification MUST implement the Diffie-Hellman key</span>
<span class="gi">+    #    agreement mode and the key deletion mode for queries.  All other</span>
<span class="gi">+    #    modes are OPTIONAL.  A server supporting TKEY that receives a TKEY</span>
<span class="gi">+    #    request with a mode it does not support returns the BADMODE error.</span>
<span class="gi">+    #    The following values of the Mode octet are defined, available, or</span>
<span class="gi">+    #    reserved:</span>
<span class="gi">+    #</span>
<span class="gi">+    #          Value    Description</span>
<span class="gi">+    #          -----    -----------</span>
<span class="gi">+    #           0        - reserved, see section 7</span>
<span class="gi">+    #           1       server assignment</span>
<span class="gi">+    #           2       Diffie-Hellman exchange</span>
<span class="gi">+    #           3       GSS-API negotiation</span>
<span class="gi">+    #           4       resolver assignment</span>
<span class="gi">+    #           5       key deletion</span>
<span class="gi">+    #          6-65534   - available, see section 7</span>
<span class="gi">+    #          65535     - reserved, see section 7</span>
<span class="w"> </span>    SERVER_ASSIGNMENT = 1
<span class="w"> </span>    DIFFIE_HELLMAN_EXCHANGE = 2
<span class="w"> </span>    GSSAPI_NEGOTIATION = 3
<span class="gh">diff --git a/dns/rdtypes/ANY/TLSA.py b/dns/rdtypes/ANY/TLSA.py</span>
<span class="gh">index 3cc2a11..4dffc55 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/TLSA.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/TLSA.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.tlsabase

<span class="gh">diff --git a/dns/rdtypes/ANY/TSIG.py b/dns/rdtypes/ANY/TSIG.py</span>
<span class="gh">index 9f3e67e..7942382 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/TSIG.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/TSIG.py</span>
<span class="gu">@@ -1,5 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rcode
<span class="gu">@@ -9,11 +27,29 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class TSIG(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;TSIG record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;algorithm&#39;, &#39;time_signed&#39;, &#39;fudge&#39;, &#39;mac&#39;, &#39;original_id&#39;,</span>
<span class="gd">-        &#39;error&#39;, &#39;other&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, algorithm, time_signed, fudge, mac,</span>
<span class="gd">-        original_id, error, other):</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;algorithm&quot;,</span>
<span class="gi">+        &quot;time_signed&quot;,</span>
<span class="gi">+        &quot;fudge&quot;,</span>
<span class="gi">+        &quot;mac&quot;,</span>
<span class="gi">+        &quot;original_id&quot;,</span>
<span class="gi">+        &quot;error&quot;,</span>
<span class="gi">+        &quot;other&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        algorithm,</span>
<span class="gi">+        time_signed,</span>
<span class="gi">+        fudge,</span>
<span class="gi">+        mac,</span>
<span class="gi">+        original_id,</span>
<span class="gi">+        error,</span>
<span class="gi">+        other,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a TSIG rdata.

<span class="w"> </span>        *rdclass*, an ``int`` is the rdataclass of the Rdata.
<span class="gu">@@ -34,6 +70,7 @@ class TSIG(dns.rdata.Rdata):</span>

<span class="w"> </span>        *other*, a ``bytes``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.algorithm = self._as_name(algorithm)
<span class="w"> </span>        self.time_signed = self._as_uint48(time_signed)
<span class="gu">@@ -42,3 +79,82 @@ class TSIG(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.original_id = self._as_uint16(original_id)
<span class="w"> </span>        self.error = dns.rcode.Rcode.make(error)
<span class="w"> </span>        self.other = self._as_bytes(other)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        algorithm = self.algorithm.choose_relativity(origin, relativize)</span>
<span class="gi">+        error = dns.rcode.to_text(self.error, True)</span>
<span class="gi">+        text = (</span>
<span class="gi">+            f&quot;{algorithm} {self.time_signed} {self.fudge} &quot;</span>
<span class="gi">+            + f&quot;{len(self.mac)} {dns.rdata._base64ify(self.mac, 0)} &quot;</span>
<span class="gi">+            + f&quot;{self.original_id} {error} {len(self.other)}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.other:</span>
<span class="gi">+            text += f&quot; {dns.rdata._base64ify(self.other, 0)}&quot;</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        algorithm = tok.get_name(relativize=False)</span>
<span class="gi">+        time_signed = tok.get_uint48()</span>
<span class="gi">+        fudge = tok.get_uint16()</span>
<span class="gi">+        mac_len = tok.get_uint16()</span>
<span class="gi">+        mac = base64.b64decode(tok.get_string())</span>
<span class="gi">+        if len(mac) != mac_len:</span>
<span class="gi">+            raise SyntaxError(&quot;invalid MAC&quot;)</span>
<span class="gi">+        original_id = tok.get_uint16()</span>
<span class="gi">+        error = dns.rcode.from_text(tok.get_string())</span>
<span class="gi">+        other_len = tok.get_uint16()</span>
<span class="gi">+        if other_len &gt; 0:</span>
<span class="gi">+            other = base64.b64decode(tok.get_string())</span>
<span class="gi">+            if len(other) != other_len:</span>
<span class="gi">+                raise SyntaxError(&quot;invalid other data&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            other = b&quot;&quot;</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            rdtype,</span>
<span class="gi">+            algorithm,</span>
<span class="gi">+            time_signed,</span>
<span class="gi">+            fudge,</span>
<span class="gi">+            mac,</span>
<span class="gi">+            original_id,</span>
<span class="gi">+            error,</span>
<span class="gi">+            other,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.algorithm.to_wire(file, None, origin, False)</span>
<span class="gi">+        file.write(</span>
<span class="gi">+            struct.pack(</span>
<span class="gi">+                &quot;!HIHH&quot;,</span>
<span class="gi">+                (self.time_signed &gt;&gt; 32) &amp; 0xFFFF,</span>
<span class="gi">+                self.time_signed &amp; 0xFFFFFFFF,</span>
<span class="gi">+                self.fudge,</span>
<span class="gi">+                len(self.mac),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(self.mac)</span>
<span class="gi">+        file.write(struct.pack(&quot;!HHH&quot;, self.original_id, self.error, len(self.other)))</span>
<span class="gi">+        file.write(self.other)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        algorithm = parser.get_name()</span>
<span class="gi">+        time_signed = parser.get_uint48()</span>
<span class="gi">+        fudge = parser.get_uint16()</span>
<span class="gi">+        mac = parser.get_counted_bytes(2)</span>
<span class="gi">+        (original_id, error) = parser.get_struct(&quot;!HH&quot;)</span>
<span class="gi">+        other = parser.get_counted_bytes(2)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            rdtype,</span>
<span class="gi">+            algorithm,</span>
<span class="gi">+            time_signed,</span>
<span class="gi">+            fudge,</span>
<span class="gi">+            mac,</span>
<span class="gi">+            original_id,</span>
<span class="gi">+            error,</span>
<span class="gi">+            other,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/TXT.py b/dns/rdtypes/ANY/TXT.py</span>
<span class="gh">index ecbfa14..6d4dae2 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/TXT.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/TXT.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.txtbase

<span class="gh">diff --git a/dns/rdtypes/ANY/URI.py b/dns/rdtypes/ANY/URI.py</span>
<span class="gh">index 9764c07..2efbb30 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/URI.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/URI.py</span>
<span class="gu">@@ -1,4 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+# Copyright (C) 2015 Red Hat, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -9,7 +28,10 @@ import dns.rdtypes.util</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class URI(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;URI record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;priority&#39;, &#39;weight&#39;, &#39;target&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see RFC 7553</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;priority&quot;, &quot;weight&quot;, &quot;target&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, priority, weight, target):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -17,4 +39,41 @@ class URI(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.weight = self._as_uint16(weight)
<span class="w"> </span>        self.target = self._as_bytes(target, True)
<span class="w"> </span>        if len(self.target) == 0:
<span class="gd">-            raise dns.exception.SyntaxError(&#39;URI target cannot be empty&#39;)</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;URI target cannot be empty&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &#39;%d %d &quot;%s&quot;&#39; % (self.priority, self.weight, self.target.decode())</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        priority = tok.get_uint16()</span>
<span class="gi">+        weight = tok.get_uint16()</span>
<span class="gi">+        target = tok.get().unescape()</span>
<span class="gi">+        if not (target.is_quoted_string() or target.is_identifier()):</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;URI target must be a string&quot;)</span>
<span class="gi">+        return cls(rdclass, rdtype, priority, weight, target.value)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        two_ints = struct.pack(&quot;!HH&quot;, self.priority, self.weight)</span>
<span class="gi">+        file.write(two_ints)</span>
<span class="gi">+        file.write(self.target)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (priority, weight) = parser.get_struct(&quot;!HH&quot;)</span>
<span class="gi">+        target = parser.get_remaining()</span>
<span class="gi">+        if len(target) == 0:</span>
<span class="gi">+            raise dns.exception.FormError(&quot;URI target may not be empty&quot;)</span>
<span class="gi">+        return cls(rdclass, rdtype, priority, weight, target)</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_priority(self):</span>
<span class="gi">+        return self.priority</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_weight(self):</span>
<span class="gi">+        return self.weight</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        return dns.rdtypes.util.weighted_processing_order(iterable)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/X25.py b/dns/rdtypes/ANY/X25.py</span>
<span class="gh">index 81d5a53..8375611 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/X25.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/X25.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,8 +26,32 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class X25(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;X25 record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;address&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see RFC 1183</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;address&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, address):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.address = self._as_bytes(address, True, 255)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &#39;&quot;%s&quot;&#39; % dns.rdata._escapify(self.address)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        address = tok.get_string()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        l = len(self.address)</span>
<span class="gi">+        assert l &lt; 256</span>
<span class="gi">+        file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+        file.write(self.address)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        address = parser.get_counted_bytes()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/ZONEMD.py b/dns/rdtypes/ANY/ZONEMD.py</span>
<span class="gh">index 6beade3..c90e3ee 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/ZONEMD.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/ZONEMD.py</span>
<span class="gu">@@ -1,5 +1,8 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="w"> </span>import dns.rdatatype
<span class="gu">@@ -9,20 +12,55 @@ import dns.zonetypes</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ZONEMD(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;ZONEMD record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;serial&#39;, &#39;scheme&#39;, &#39;hash_algorithm&#39;, &#39;digest&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, serial, scheme, hash_algorithm, digest</span>
<span class="gd">-        ):</span>
<span class="gi">+    # See RFC 8976</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;serial&quot;, &quot;scheme&quot;, &quot;hash_algorithm&quot;, &quot;digest&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, rdclass, rdtype, serial, scheme, hash_algorithm, digest):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.serial = self._as_uint32(serial)
<span class="w"> </span>        self.scheme = dns.zonetypes.DigestScheme.make(scheme)
<span class="gd">-        self.hash_algorithm = dns.zonetypes.DigestHashAlgorithm.make(</span>
<span class="gd">-            hash_algorithm)</span>
<span class="gi">+        self.hash_algorithm = dns.zonetypes.DigestHashAlgorithm.make(hash_algorithm)</span>
<span class="w"> </span>        self.digest = self._as_bytes(digest)
<span class="gd">-        if self.scheme == 0:</span>
<span class="gd">-            raise ValueError(&#39;scheme 0 is reserved&#39;)</span>
<span class="gd">-        if self.hash_algorithm == 0:</span>
<span class="gd">-            raise ValueError(&#39;hash_algorithm 0 is reserved&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.scheme == 0:  # reserved, RFC 8976 Sec. 5.2</span>
<span class="gi">+            raise ValueError(&quot;scheme 0 is reserved&quot;)</span>
<span class="gi">+        if self.hash_algorithm == 0:  # reserved, RFC 8976 Sec. 5.3</span>
<span class="gi">+            raise ValueError(&quot;hash_algorithm 0 is reserved&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        hasher = dns.zonetypes._digest_hashers.get(self.hash_algorithm)
<span class="w"> </span>        if hasher and hasher().digest_size != len(self.digest):
<span class="gd">-            raise ValueError(&#39;digest length inconsistent with hash algorithm&#39;)</span>
<span class="gi">+            raise ValueError(&quot;digest length inconsistent with hash algorithm&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        kw = kw.copy()</span>
<span class="gi">+        chunksize = kw.pop(&quot;chunksize&quot;, 128)</span>
<span class="gi">+        return &quot;%d %d %d %s&quot; % (</span>
<span class="gi">+            self.serial,</span>
<span class="gi">+            self.scheme,</span>
<span class="gi">+            self.hash_algorithm,</span>
<span class="gi">+            dns.rdata._hexify(self.digest, chunksize=chunksize, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        serial = tok.get_uint32()</span>
<span class="gi">+        scheme = tok.get_uint8()</span>
<span class="gi">+        hash_algorithm = tok.get_uint8()</span>
<span class="gi">+        digest = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        digest = binascii.unhexlify(digest)</span>
<span class="gi">+        return cls(rdclass, rdtype, serial, scheme, hash_algorithm, digest)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(&quot;!IBB&quot;, self.serial, self.scheme, self.hash_algorithm)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        file.write(self.digest)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;!IBB&quot;)</span>
<span class="gi">+        digest = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, header[0], header[1], header[2], digest)</span>
<span class="gh">diff --git a/dns/rdtypes/CH/A.py b/dns/rdtypes/CH/A.py</span>
<span class="gh">index 49c36d8..583a88a 100644</span>
<span class="gd">--- a/dns/rdtypes/CH/A.py</span>
<span class="gi">+++ b/dns/rdtypes/CH/A.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.mxbase

<span class="gu">@@ -6,9 +24,36 @@ import dns.rdtypes.mxbase</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class A(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;A record for Chaosnet&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;domain&#39;, &#39;address&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # domain: the domain of the address</span>
<span class="gi">+    # address: the 16-bit address</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;domain&quot;, &quot;address&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, domain, address):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.domain = self._as_name(domain)
<span class="w"> </span>        self.address = self._as_uint16(address)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        domain = self.domain.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;%s %o&quot; % (domain, self.address)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        domain = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        address = tok.get_uint16(base=8)</span>
<span class="gi">+        return cls(rdclass, rdtype, domain, address)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.domain.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+        pref = struct.pack(&quot;!H&quot;, self.address)</span>
<span class="gi">+        file.write(pref)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        domain = parser.get_name(origin)</span>
<span class="gi">+        address = parser.get_uint16()</span>
<span class="gi">+        return cls(rdclass, rdtype, domain, address)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/A.py b/dns/rdtypes/IN/A.py</span>
<span class="gh">index 5c5f664..e09d611 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/A.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/A.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.ipv4
<span class="gu">@@ -8,8 +25,27 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class A(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;A record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;address&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;address&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, address):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.address = self._as_ipv4_address(address)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return self.address</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        address = tok.get_identifier()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(dns.ipv4.inet_aton(self.address))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        address = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/AAAA.py b/dns/rdtypes/IN/AAAA.py</span>
<span class="gh">index b24c5fb..0cd139e 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/AAAA.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/AAAA.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.ipv6
<span class="gu">@@ -8,8 +25,27 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class AAAA(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;AAAA record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;address&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;address&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, address):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.address = self._as_ipv6_address(address)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return self.address</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        address = tok.get_identifier()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(dns.ipv6.inet_aton(self.address))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        address = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/APL.py b/dns/rdtypes/IN/APL.py</span>
<span class="gh">index 6572e67..44cb3fe 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/APL.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/APL.py</span>
<span class="gu">@@ -1,6 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import codecs
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.ipv4
<span class="gu">@@ -12,7 +30,8 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class APLItem:
<span class="w"> </span>    &quot;&quot;&quot;An APL list item.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;family&#39;, &#39;negation&#39;, &#39;address&#39;, &#39;prefix&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;family&quot;, &quot;negation&quot;, &quot;address&quot;, &quot;prefix&quot;]</span>

<span class="w"> </span>    def __init__(self, family, negation, address, prefix):
<span class="w"> </span>        self.family = dns.rdata.Rdata._as_uint16(family)
<span class="gu">@@ -29,19 +48,103 @@ class APLItem:</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        if self.negation:
<span class="gd">-            return &#39;!%d:%s/%s&#39; % (self.family, self.address, self.prefix)</span>
<span class="gi">+            return &quot;!%d:%s/%s&quot; % (self.family, self.address, self.prefix)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;%d:%s/%s&quot; % (self.family, self.address, self.prefix)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file):</span>
<span class="gi">+        if self.family == 1:</span>
<span class="gi">+            address = dns.ipv4.inet_aton(self.address)</span>
<span class="gi">+        elif self.family == 2:</span>
<span class="gi">+            address = dns.ipv6.inet_aton(self.address)</span>
<span class="w"> </span>        else:
<span class="gd">-            return &#39;%d:%s/%s&#39; % (self.family, self.address, self.prefix)</span>
<span class="gi">+            address = binascii.unhexlify(self.address)</span>
<span class="gi">+        #</span>
<span class="gi">+        # Truncate least significant zero bytes.</span>
<span class="gi">+        #</span>
<span class="gi">+        last = 0</span>
<span class="gi">+        for i in range(len(address) - 1, -1, -1):</span>
<span class="gi">+            if address[i] != 0:</span>
<span class="gi">+                last = i + 1</span>
<span class="gi">+                break</span>
<span class="gi">+        address = address[0:last]</span>
<span class="gi">+        l = len(address)</span>
<span class="gi">+        assert l &lt; 128</span>
<span class="gi">+        if self.negation:</span>
<span class="gi">+            l |= 0x80</span>
<span class="gi">+        header = struct.pack(&quot;!HBB&quot;, self.family, self.prefix, l)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        file.write(address)</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class APL(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;APL record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;items&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 3123</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;items&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, items):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        for item in items:
<span class="w"> </span>            if not isinstance(item, APLItem):
<span class="gd">-                raise ValueError(&#39;item not an APLItem&#39;)</span>
<span class="gi">+                raise ValueError(&quot;item not an APLItem&quot;)</span>
<span class="w"> </span>        self.items = tuple(items)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &quot; &quot;.join(map(str, self.items))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        items = []</span>
<span class="gi">+        for token in tok.get_remaining():</span>
<span class="gi">+            item = token.unescape().value</span>
<span class="gi">+            if item[0] == &quot;!&quot;:</span>
<span class="gi">+                negation = True</span>
<span class="gi">+                item = item[1:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                negation = False</span>
<span class="gi">+            (family, rest) = item.split(&quot;:&quot;, 1)</span>
<span class="gi">+            family = int(family)</span>
<span class="gi">+            (address, prefix) = rest.split(&quot;/&quot;, 1)</span>
<span class="gi">+            prefix = int(prefix)</span>
<span class="gi">+            item = APLItem(family, negation, address, prefix)</span>
<span class="gi">+            items.append(item)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(rdclass, rdtype, items)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        for item in self.items:</span>
<span class="gi">+            item.to_wire(file)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        items = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            header = parser.get_struct(&quot;!HBB&quot;)</span>
<span class="gi">+            afdlen = header[2]</span>
<span class="gi">+            if afdlen &gt; 127:</span>
<span class="gi">+                negation = True</span>
<span class="gi">+                afdlen -= 128</span>
<span class="gi">+            else:</span>
<span class="gi">+                negation = False</span>
<span class="gi">+            address = parser.get_bytes(afdlen)</span>
<span class="gi">+            l = len(address)</span>
<span class="gi">+            if header[0] == 1:</span>
<span class="gi">+                if l &lt; 4:</span>
<span class="gi">+                    address += b&quot;\x00&quot; * (4 - l)</span>
<span class="gi">+            elif header[0] == 2:</span>
<span class="gi">+                if l &lt; 16:</span>
<span class="gi">+                    address += b&quot;\x00&quot; * (16 - l)</span>
<span class="gi">+            else:</span>
<span class="gi">+                #</span>
<span class="gi">+                # This isn&#39;t really right according to the RFC, but it</span>
<span class="gi">+                # seems better than throwing an exception</span>
<span class="gi">+                #</span>
<span class="gi">+                address = codecs.encode(address, &quot;hex_codec&quot;)</span>
<span class="gi">+            item = APLItem(header[0], negation, address, header[1])</span>
<span class="gi">+            items.append(item)</span>
<span class="gi">+        return cls(rdclass, rdtype, items)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/DHCID.py b/dns/rdtypes/IN/DHCID.py</span>
<span class="gh">index ab8928f..723492f 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/DHCID.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/DHCID.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -7,8 +25,30 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class DHCID(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;DHCID record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;data&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 4701</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;data&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, data):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.data = self._as_bytes(data)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return dns.rdata._base64ify(self.data, **kw)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        b64 = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        data = base64.b64decode(b64)</span>
<span class="gi">+        return cls(rdclass, rdtype, data)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(self.data)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        data = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, data)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/HTTPS.py b/dns/rdtypes/IN/HTTPS.py</span>
<span class="gh">index 4e56d14..15464cb 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/HTTPS.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/HTTPS.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.svcbbase

<span class="gh">diff --git a/dns/rdtypes/IN/IPSECKEY.py b/dns/rdtypes/IN/IPSECKEY.py</span>
<span class="gh">index cb4b002..e3a6615 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/IPSECKEY.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/IPSECKEY.py</span>
<span class="gu">@@ -1,21 +1,43 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.util


<span class="w"> </span>class Gateway(dns.rdtypes.util.Gateway):
<span class="gd">-    name = &#39;IPSECKEY gateway&#39;</span>
<span class="gi">+    name = &quot;IPSECKEY gateway&quot;</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class IPSECKEY(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;IPSECKEY record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;precedence&#39;, &#39;gateway_type&#39;, &#39;algorithm&#39;, &#39;gateway&#39;, &#39;key&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, precedence, gateway_type, algorithm,</span>
<span class="gd">-        gateway, key):</span>
<span class="gi">+    # see: RFC 4025</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;precedence&quot;, &quot;gateway_type&quot;, &quot;algorithm&quot;, &quot;gateway&quot;, &quot;key&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, rdclass, rdtype, precedence, gateway_type, algorithm, gateway, key</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        gateway = Gateway(gateway_type, gateway)
<span class="w"> </span>        self.precedence = self._as_uint8(precedence)
<span class="gu">@@ -23,3 +45,47 @@ class IPSECKEY(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.algorithm = self._as_uint8(algorithm)
<span class="w"> </span>        self.gateway = gateway.gateway
<span class="w"> </span>        self.key = self._as_bytes(key)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        gateway = Gateway(self.gateway_type, self.gateway).to_text(origin, relativize)</span>
<span class="gi">+        return &quot;%d %d %d %s %s&quot; % (</span>
<span class="gi">+            self.precedence,</span>
<span class="gi">+            self.gateway_type,</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            gateway,</span>
<span class="gi">+            dns.rdata._base64ify(self.key, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        precedence = tok.get_uint8()</span>
<span class="gi">+        gateway_type = tok.get_uint8()</span>
<span class="gi">+        algorithm = tok.get_uint8()</span>
<span class="gi">+        gateway = Gateway.from_text(</span>
<span class="gi">+            gateway_type, tok, origin, relativize, relativize_to</span>
<span class="gi">+        )</span>
<span class="gi">+        b64 = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        key = base64.b64decode(b64)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, precedence, gateway_type, algorithm, gateway.gateway, key</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(&quot;!BBB&quot;, self.precedence, self.gateway_type, self.algorithm)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        Gateway(self.gateway_type, self.gateway).to_wire(</span>
<span class="gi">+            file, compress, origin, canonicalize</span>
<span class="gi">+        )</span>
<span class="gi">+        file.write(self.key)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;!BBB&quot;)</span>
<span class="gi">+        gateway_type = header[1]</span>
<span class="gi">+        gateway = Gateway.from_wire_parser(gateway_type, parser, origin)</span>
<span class="gi">+        key = parser.get_remaining()</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, header[0], gateway_type, header[2], gateway.gateway, key</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/dns/rdtypes/IN/KX.py b/dns/rdtypes/IN/KX.py</span>
<span class="gh">index b6f7705..6073df4 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/KX.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/KX.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.mxbase

<span class="gh">diff --git a/dns/rdtypes/IN/NAPTR.py b/dns/rdtypes/IN/NAPTR.py</span>
<span class="gh">index eb0966e..195d1cb 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/NAPTR.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/NAPTR.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -6,14 +24,24 @@ import dns.rdata</span>
<span class="w"> </span>import dns.rdtypes.util


<span class="gi">+def _write_string(file, s):</span>
<span class="gi">+    l = len(s)</span>
<span class="gi">+    assert l &lt; 256</span>
<span class="gi">+    file.write(struct.pack(&quot;!B&quot;, l))</span>
<span class="gi">+    file.write(s)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NAPTR(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;NAPTR record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;order&#39;, &#39;preference&#39;, &#39;flags&#39;, &#39;service&#39;, &#39;regexp&#39;,</span>
<span class="gd">-        &#39;replacement&#39;]</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, order, preference, flags, service,</span>
<span class="gd">-        regexp, replacement):</span>
<span class="gi">+    # see: RFC 3403</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;order&quot;, &quot;preference&quot;, &quot;flags&quot;, &quot;service&quot;, &quot;regexp&quot;, &quot;replacement&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, rdclass, rdtype, order, preference, flags, service, regexp, replacement</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.flags = self._as_bytes(flags, True, 255)
<span class="w"> </span>        self.service = self._as_bytes(service, True, 255)
<span class="gu">@@ -21,3 +49,62 @@ class NAPTR(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.order = self._as_uint16(order)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        self.replacement = self._as_name(replacement)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        replacement = self.replacement.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &#39;%d %d &quot;%s&quot; &quot;%s&quot; &quot;%s&quot; %s&#39; % (</span>
<span class="gi">+            self.order,</span>
<span class="gi">+            self.preference,</span>
<span class="gi">+            dns.rdata._escapify(self.flags),</span>
<span class="gi">+            dns.rdata._escapify(self.service),</span>
<span class="gi">+            dns.rdata._escapify(self.regexp),</span>
<span class="gi">+            replacement,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        order = tok.get_uint16()</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        flags = tok.get_string()</span>
<span class="gi">+        service = tok.get_string()</span>
<span class="gi">+        regexp = tok.get_string()</span>
<span class="gi">+        replacement = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass, rdtype, order, preference, flags, service, regexp, replacement</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        two_ints = struct.pack(&quot;!HH&quot;, self.order, self.preference)</span>
<span class="gi">+        file.write(two_ints)</span>
<span class="gi">+        _write_string(file, self.flags)</span>
<span class="gi">+        _write_string(file, self.service)</span>
<span class="gi">+        _write_string(file, self.regexp)</span>
<span class="gi">+        self.replacement.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (order, preference) = parser.get_struct(&quot;!HH&quot;)</span>
<span class="gi">+        strings = []</span>
<span class="gi">+        for _ in range(3):</span>
<span class="gi">+            s = parser.get_counted_bytes()</span>
<span class="gi">+            strings.append(s)</span>
<span class="gi">+        replacement = parser.get_name(origin)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            rdtype,</span>
<span class="gi">+            order,</span>
<span class="gi">+            preference,</span>
<span class="gi">+            strings[0],</span>
<span class="gi">+            strings[1],</span>
<span class="gi">+            strings[2],</span>
<span class="gi">+            replacement,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_priority(self):</span>
<span class="gi">+        return (self.order, self.preference)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        return dns.rdtypes.util.priority_processing_order(iterable)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/NSAP.py b/dns/rdtypes/IN/NSAP.py</span>
<span class="gh">index 7af3b5e..a4854b3 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/NSAP.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/NSAP.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -8,8 +26,35 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NSAP(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;NSAP record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;address&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 1706</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;address&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, address):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.address = self._as_bytes(address)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &quot;0x%s&quot; % binascii.hexlify(self.address).decode()</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        address = tok.get_string()</span>
<span class="gi">+        if address[0:2] != &quot;0x&quot;:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;string does not start with 0x&quot;)</span>
<span class="gi">+        address = address[2:].replace(&quot;.&quot;, &quot;&quot;)</span>
<span class="gi">+        if len(address) % 2 != 0:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;hexstring has odd length&quot;)</span>
<span class="gi">+        address = binascii.unhexlify(address.encode())</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(self.address)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        address = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, address)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/NSAP_PTR.py b/dns/rdtypes/IN/NSAP_PTR.py</span>
<span class="gh">index 6b64d23..ce1c663 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/NSAP_PTR.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/NSAP_PTR.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.nsbase

<span class="gh">diff --git a/dns/rdtypes/IN/PX.py b/dns/rdtypes/IN/PX.py</span>
<span class="gh">index 59ed238..cdca153 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/PX.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/PX.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -9,10 +27,47 @@ import dns.rdtypes.util</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class PX(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;PX record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;preference&#39;, &#39;map822&#39;, &#39;mapx400&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 2163</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;preference&quot;, &quot;map822&quot;, &quot;mapx400&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, preference, map822, mapx400):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        self.map822 = self._as_name(map822)
<span class="w"> </span>        self.mapx400 = self._as_name(mapx400)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        map822 = self.map822.choose_relativity(origin, relativize)</span>
<span class="gi">+        mapx400 = self.mapx400.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;%d %s %s&quot; % (self.preference, map822, mapx400)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        map822 = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        mapx400 = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, map822, mapx400)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        pref = struct.pack(&quot;!H&quot;, self.preference)</span>
<span class="gi">+        file.write(pref)</span>
<span class="gi">+        self.map822.to_wire(file, None, origin, canonicalize)</span>
<span class="gi">+        self.mapx400.to_wire(file, None, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        preference = parser.get_uint16()</span>
<span class="gi">+        map822 = parser.get_name(origin)</span>
<span class="gi">+        mapx400 = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, map822, mapx400)</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_priority(self):</span>
<span class="gi">+        return self.preference</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        return dns.rdtypes.util.priority_processing_order(iterable)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/SRV.py b/dns/rdtypes/IN/SRV.py</span>
<span class="gh">index 014a72f..5adef98 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/SRV.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/SRV.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -9,7 +27,10 @@ import dns.rdtypes.util</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class SRV(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;SRV record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;priority&#39;, &#39;weight&#39;, &#39;port&#39;, &#39;target&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 2782</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;priority&quot;, &quot;weight&quot;, &quot;port&quot;, &quot;target&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, priority, weight, port, target):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -17,3 +38,38 @@ class SRV(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.weight = self._as_uint16(weight)
<span class="w"> </span>        self.port = self._as_uint16(port)
<span class="w"> </span>        self.target = self._as_name(target)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        target = self.target.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;%d %d %d %s&quot; % (self.priority, self.weight, self.port, target)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        priority = tok.get_uint16()</span>
<span class="gi">+        weight = tok.get_uint16()</span>
<span class="gi">+        port = tok.get_uint16()</span>
<span class="gi">+        target = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(rdclass, rdtype, priority, weight, port, target)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        three_ints = struct.pack(&quot;!HHH&quot;, self.priority, self.weight, self.port)</span>
<span class="gi">+        file.write(three_ints)</span>
<span class="gi">+        self.target.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        (priority, weight, port) = parser.get_struct(&quot;!HHH&quot;)</span>
<span class="gi">+        target = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, priority, weight, port, target)</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_priority(self):</span>
<span class="gi">+        return self.priority</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_weight(self):</span>
<span class="gi">+        return self.weight</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        return dns.rdtypes.util.weighted_processing_order(iterable)</span>
<span class="gh">diff --git a/dns/rdtypes/IN/SVCB.py b/dns/rdtypes/IN/SVCB.py</span>
<span class="gh">index a9446c8..ff3e932 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/SVCB.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/SVCB.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdtypes.svcbbase

<span class="gh">diff --git a/dns/rdtypes/IN/WKS.py b/dns/rdtypes/IN/WKS.py</span>
<span class="gh">index 9bb41d9..881a784 100644</span>
<span class="gd">--- a/dns/rdtypes/IN/WKS.py</span>
<span class="gi">+++ b/dns/rdtypes/IN/WKS.py</span>
<span class="gu">@@ -1,12 +1,32 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.ipv4
<span class="w"> </span>import dns.rdata
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    _proto_tcp = socket.getprotobyname(&#39;tcp&#39;)</span>
<span class="gd">-    _proto_udp = socket.getprotobyname(&#39;udp&#39;)</span>
<span class="gi">+    _proto_tcp = socket.getprotobyname(&quot;tcp&quot;)</span>
<span class="gi">+    _proto_udp = socket.getprotobyname(&quot;udp&quot;)</span>
<span class="w"> </span>except OSError:
<span class="gi">+    # Fall back to defaults in case /etc/protocols is unavailable.</span>
<span class="w"> </span>    _proto_tcp = 6
<span class="w"> </span>    _proto_udp = 17

<span class="gu">@@ -14,10 +34,67 @@ except OSError:</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class WKS(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;WKS record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;address&#39;, &#39;protocol&#39;, &#39;bitmap&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 1035</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;address&quot;, &quot;protocol&quot;, &quot;bitmap&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, address, protocol, bitmap):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.address = self._as_ipv4_address(address)
<span class="w"> </span>        self.protocol = self._as_uint8(protocol)
<span class="w"> </span>        self.bitmap = self._as_bytes(bitmap)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        bits = []</span>
<span class="gi">+        for i, byte in enumerate(self.bitmap):</span>
<span class="gi">+            for j in range(0, 8):</span>
<span class="gi">+                if byte &amp; (0x80 &gt;&gt; j):</span>
<span class="gi">+                    bits.append(str(i * 8 + j))</span>
<span class="gi">+        text = &quot; &quot;.join(bits)</span>
<span class="gi">+        return &quot;%s %d %s&quot; % (self.address, self.protocol, text)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        address = tok.get_string()</span>
<span class="gi">+        protocol = tok.get_string()</span>
<span class="gi">+        if protocol.isdigit():</span>
<span class="gi">+            protocol = int(protocol)</span>
<span class="gi">+        else:</span>
<span class="gi">+            protocol = socket.getprotobyname(protocol)</span>
<span class="gi">+        bitmap = bytearray()</span>
<span class="gi">+        for token in tok.get_remaining():</span>
<span class="gi">+            value = token.unescape().value</span>
<span class="gi">+            if value.isdigit():</span>
<span class="gi">+                serv = int(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if protocol != _proto_udp and protocol != _proto_tcp:</span>
<span class="gi">+                    raise NotImplementedError(&quot;protocol must be TCP or UDP&quot;)</span>
<span class="gi">+                if protocol == _proto_udp:</span>
<span class="gi">+                    protocol_text = &quot;udp&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    protocol_text = &quot;tcp&quot;</span>
<span class="gi">+                serv = socket.getservbyname(value, protocol_text)</span>
<span class="gi">+            i = serv // 8</span>
<span class="gi">+            l = len(bitmap)</span>
<span class="gi">+            if l &lt; i + 1:</span>
<span class="gi">+                for _ in range(l, i + 1):</span>
<span class="gi">+                    bitmap.append(0)</span>
<span class="gi">+            bitmap[i] = bitmap[i] | (0x80 &gt;&gt; (serv % 8))</span>
<span class="gi">+        bitmap = dns.rdata._truncate_bitmap(bitmap)</span>
<span class="gi">+        return cls(rdclass, rdtype, address, protocol, bitmap)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(dns.ipv4.inet_aton(self.address))</span>
<span class="gi">+        protocol = struct.pack(&quot;!B&quot;, self.protocol)</span>
<span class="gi">+        file.write(protocol)</span>
<span class="gi">+        file.write(self.bitmap)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        address = parser.get_bytes(4)</span>
<span class="gi">+        protocol = parser.get_uint8()</span>
<span class="gi">+        bitmap = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, address, protocol, bitmap)</span>
<span class="gh">diff --git a/dns/rdtypes/dnskeybase.py b/dns/rdtypes/dnskeybase.py</span>
<span class="gh">index 9fd68d0..db300f8 100644</span>
<span class="gd">--- a/dns/rdtypes/dnskeybase.py</span>
<span class="gi">+++ b/dns/rdtypes/dnskeybase.py</span>
<span class="gu">@@ -1,23 +1,44 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import enum
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.dnssectypes
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gd">-__all__ = [&#39;SEP&#39;, &#39;REVOKE&#39;, &#39;ZONE&#39;]</span>
<span class="gi">+</span>
<span class="gi">+# wildcard import</span>
<span class="gi">+__all__ = [&quot;SEP&quot;, &quot;REVOKE&quot;, &quot;ZONE&quot;]  # noqa: F822</span>


<span class="w"> </span>class Flag(enum.IntFlag):
<span class="gd">-    SEP = 1</span>
<span class="gd">-    REVOKE = 128</span>
<span class="gd">-    ZONE = 256</span>
<span class="gi">+    SEP = 0x0001</span>
<span class="gi">+    REVOKE = 0x0080</span>
<span class="gi">+    ZONE = 0x0100</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class DNSKEYBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like a DNSKEY record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;flags&#39;, &#39;protocol&#39;, &#39;algorithm&#39;, &#39;key&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;flags&quot;, &quot;protocol&quot;, &quot;algorithm&quot;, &quot;key&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, flags, protocol, algorithm, key):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -26,7 +47,41 @@ class DNSKEYBase(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.algorithm = dns.dnssectypes.Algorithm.make(algorithm)
<span class="w"> </span>        self.key = self._as_bytes(key)

<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return &quot;%d %d %d %s&quot; % (</span>
<span class="gi">+            self.flags,</span>
<span class="gi">+            self.protocol,</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            dns.rdata._base64ify(self.key, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        flags = tok.get_uint16()</span>
<span class="gi">+        protocol = tok.get_uint8()</span>
<span class="gi">+        algorithm = tok.get_string()</span>
<span class="gi">+        b64 = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        key = base64.b64decode(b64)</span>
<span class="gi">+        return cls(rdclass, rdtype, flags, protocol, algorithm, key)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(&quot;!HBB&quot;, self.flags, self.protocol, self.algorithm)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        file.write(self.key)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;!HBB&quot;)</span>
<span class="gi">+        key = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, header[0], header[1], header[2], key)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+### BEGIN generated Flag constants</span>

<span class="w"> </span>SEP = Flag.SEP
<span class="w"> </span>REVOKE = Flag.REVOKE
<span class="w"> </span>ZONE = Flag.ZONE
<span class="gi">+</span>
<span class="gi">+### END generated Flag constants</span>
<span class="gh">diff --git a/dns/rdtypes/dsbase.py b/dns/rdtypes/dsbase.py</span>
<span class="gh">index a394668..cd21f02 100644</span>
<span class="gd">--- a/dns/rdtypes/dsbase.py</span>
<span class="gi">+++ b/dns/rdtypes/dsbase.py</span>
<span class="gu">@@ -1,5 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2010, 2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.dnssectypes
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -9,21 +27,59 @@ import dns.rdatatype</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class DSBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like a DS record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;key_tag&#39;, &#39;algorithm&#39;, &#39;digest_type&#39;, &#39;digest&#39;]</span>
<span class="gd">-    _digest_length_by_type = {(1): 20, (2): 32, (3): 32, (4): 48}</span>

<span class="gd">-    def __init__(self, rdclass, rdtype, key_tag, algorithm, digest_type, digest</span>
<span class="gd">-        ):</span>
<span class="gi">+    __slots__ = [&quot;key_tag&quot;, &quot;algorithm&quot;, &quot;digest_type&quot;, &quot;digest&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    # Digest types registry:</span>
<span class="gi">+    # https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml</span>
<span class="gi">+    _digest_length_by_type = {</span>
<span class="gi">+        1: 20,  # SHA-1, RFC 3658 Sec. 2.4</span>
<span class="gi">+        2: 32,  # SHA-256, RFC 4509 Sec. 2.2</span>
<span class="gi">+        3: 32,  # GOST R 34.11-94, RFC 5933 Sec. 4 in conjunction with RFC 4490 Sec. 2.1</span>
<span class="gi">+        4: 48,  # SHA-384, RFC 6605 Sec. 2</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, rdclass, rdtype, key_tag, algorithm, digest_type, digest):</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.key_tag = self._as_uint16(key_tag)
<span class="w"> </span>        self.algorithm = dns.dnssectypes.Algorithm.make(algorithm)
<span class="gd">-        self.digest_type = dns.dnssectypes.DSDigest.make(self._as_uint8(</span>
<span class="gd">-            digest_type))</span>
<span class="gi">+        self.digest_type = dns.dnssectypes.DSDigest.make(self._as_uint8(digest_type))</span>
<span class="w"> </span>        self.digest = self._as_bytes(digest)
<span class="w"> </span>        try:
<span class="gd">-            if len(self.digest) != self._digest_length_by_type[self.digest_type</span>
<span class="gd">-                ]:</span>
<span class="gd">-                raise ValueError(&#39;digest length inconsistent with digest type&#39;)</span>
<span class="gi">+            if len(self.digest) != self._digest_length_by_type[self.digest_type]:</span>
<span class="gi">+                raise ValueError(&quot;digest length inconsistent with digest type&quot;)</span>
<span class="w"> </span>        except KeyError:
<span class="gd">-            if self.digest_type == 0:</span>
<span class="gd">-                raise ValueError(&#39;digest type 0 is reserved&#39;)</span>
<span class="gi">+            if self.digest_type == 0:  # reserved, RFC 3658 Sec. 2.4</span>
<span class="gi">+                raise ValueError(&quot;digest type 0 is reserved&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        kw = kw.copy()</span>
<span class="gi">+        chunksize = kw.pop(&quot;chunksize&quot;, 128)</span>
<span class="gi">+        return &quot;%d %d %d %s&quot; % (</span>
<span class="gi">+            self.key_tag,</span>
<span class="gi">+            self.algorithm,</span>
<span class="gi">+            self.digest_type,</span>
<span class="gi">+            dns.rdata._hexify(self.digest, chunksize=chunksize, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        key_tag = tok.get_uint16()</span>
<span class="gi">+        algorithm = tok.get_string()</span>
<span class="gi">+        digest_type = tok.get_uint8()</span>
<span class="gi">+        digest = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        digest = binascii.unhexlify(digest)</span>
<span class="gi">+        return cls(rdclass, rdtype, key_tag, algorithm, digest_type, digest)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(&quot;!HBB&quot;, self.key_tag, self.algorithm, self.digest_type)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        file.write(self.digest)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;!HBB&quot;)</span>
<span class="gi">+        digest = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, header[0], header[1], header[2], digest)</span>
<span class="gh">diff --git a/dns/rdtypes/euibase.py b/dns/rdtypes/euibase.py</span>
<span class="gh">index dc72327..751087b 100644</span>
<span class="gd">--- a/dns/rdtypes/euibase.py</span>
<span class="gi">+++ b/dns/rdtypes/euibase.py</span>
<span class="gu">@@ -1,4 +1,21 @@</span>
<span class="gi">+# Copyright (C) 2015 Red Hat, Inc.</span>
<span class="gi">+# Author: Petr Spacek &lt;pspacek@redhat.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &#39;AS IS&#39; AND RED HAT DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata

<span class="gu">@@ -6,12 +23,48 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class EUIBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;EUIxx record&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;eui&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: rfc7043.txt</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;eui&quot;]</span>
<span class="gi">+    # define these in subclasses</span>
<span class="gi">+    # byte_len = 6  # 0123456789ab (in hex)</span>
<span class="gi">+    # text_len = byte_len * 3 - 1  # 01-23-45-67-89-ab</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, eui):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.eui = self._as_bytes(eui)
<span class="w"> </span>        if len(self.eui) != self.byte_len:
<span class="w"> </span>            raise dns.exception.FormError(
<span class="gd">-                &#39;EUI%s rdata has to have %s bytes&#39; % (self.byte_len * 8,</span>
<span class="gd">-                self.byte_len))</span>
<span class="gi">+                &quot;EUI%s rdata has to have %s bytes&quot; % (self.byte_len * 8, self.byte_len)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        return dns.rdata._hexify(self.eui, chunksize=2, separator=b&quot;-&quot;, **kw)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        text = tok.get_string()</span>
<span class="gi">+        if len(text) != cls.text_len:</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                &quot;Input text must have %s characters&quot; % cls.text_len</span>
<span class="gi">+            )</span>
<span class="gi">+        for i in range(2, cls.byte_len * 3 - 1, 3):</span>
<span class="gi">+            if text[i] != &quot;-&quot;:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;Dash expected at position %s&quot; % i)</span>
<span class="gi">+        text = text.replace(&quot;-&quot;, &quot;&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = binascii.unhexlify(text.encode())</span>
<span class="gi">+        except (ValueError, TypeError) as ex:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;Hex decoding error: %s&quot; % str(ex))</span>
<span class="gi">+        return cls(rdclass, rdtype, data)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(self.eui)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        eui = parser.get_bytes(cls.byte_len)</span>
<span class="gi">+        return cls(rdclass, rdtype, eui)</span>
<span class="gh">diff --git a/dns/rdtypes/mxbase.py b/dns/rdtypes/mxbase.py</span>
<span class="gh">index 47ac142..6d5e3d8 100644</span>
<span class="gd">--- a/dns/rdtypes/mxbase.py</span>
<span class="gi">+++ b/dns/rdtypes/mxbase.py</span>
<span class="gu">@@ -1,5 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;MX-like base classes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -10,13 +29,44 @@ import dns.rdtypes.util</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class MXBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like an MX record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;preference&#39;, &#39;exchange&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;preference&quot;, &quot;exchange&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, preference, exchange):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.preference = self._as_uint16(preference)
<span class="w"> </span>        self.exchange = self._as_name(exchange)

<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        exchange = self.exchange.choose_relativity(origin, relativize)</span>
<span class="gi">+        return &quot;%d %s&quot; % (self.preference, exchange)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        preference = tok.get_uint16()</span>
<span class="gi">+        exchange = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, exchange)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        pref = struct.pack(&quot;!H&quot;, self.preference)</span>
<span class="gi">+        file.write(pref)</span>
<span class="gi">+        self.exchange.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        preference = parser.get_uint16()</span>
<span class="gi">+        exchange = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, preference, exchange)</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_priority(self):</span>
<span class="gi">+        return self.preference</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        return dns.rdtypes.util.priority_processing_order(iterable)</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class UncompressedMX(MXBase):
<span class="gu">@@ -24,8 +74,14 @@ class UncompressedMX(MXBase):</span>
<span class="w"> </span>    is not compressed when converted to DNS wire format, and whose
<span class="w"> </span>    digestable form is not downcased.&quot;&quot;&quot;

<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        super()._to_wire(file, None, origin, False)</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class UncompressedDowncasingMX(MXBase):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like an MX record, but whose name
<span class="w"> </span>    is not compressed when convert to DNS wire format.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        super()._to_wire(file, None, origin, canonicalize)</span>
<span class="gh">diff --git a/dns/rdtypes/nsbase.py b/dns/rdtypes/nsbase.py</span>
<span class="gh">index 21eef60..904224f 100644</span>
<span class="gd">--- a/dns/rdtypes/nsbase.py</span>
<span class="gi">+++ b/dns/rdtypes/nsbase.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;NS-like base classes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -8,15 +26,38 @@ import dns.rdata</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NSBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like an NS record.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;target&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;target&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, target):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="w"> </span>        self.target = self._as_name(target)

<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        target = self.target.choose_relativity(origin, relativize)</span>
<span class="gi">+        return str(target)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        target = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        return cls(rdclass, rdtype, target)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.target.to_wire(file, compress, origin, canonicalize)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        target = parser.get_name(origin)</span>
<span class="gi">+        return cls(rdclass, rdtype, target)</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class UncompressedNS(NSBase):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like an NS record, but whose name
<span class="w"> </span>    is not compressed when convert to DNS wire format, and whose
<span class="w"> </span>    digestable form is not downcased.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        self.target.to_wire(file, None, origin, False)</span>
<span class="gh">diff --git a/dns/rdtypes/svcbbase.py b/dns/rdtypes/svcbbase.py</span>
<span class="gh">index e82b8fd..0565241 100644</span>
<span class="gd">--- a/dns/rdtypes/svcbbase.py</span>
<span class="gi">+++ b/dns/rdtypes/svcbbase.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import enum
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.enum
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="gu">@@ -13,6 +16,9 @@ import dns.renderer</span>
<span class="w"> </span>import dns.tokenizer
<span class="w"> </span>import dns.wire

<span class="gi">+# Until there is an RFC, this module is experimental and may be changed in</span>
<span class="gi">+# incompatible ways.</span>
<span class="gi">+</span>

<span class="w"> </span>class UnknownParamKey(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;Unknown SVCB ParamKey&quot;&quot;&quot;
<span class="gu">@@ -20,6 +26,7 @@ class UnknownParamKey(dns.exception.DNSException):</span>

<span class="w"> </span>class ParamKey(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;SVCB ParamKey&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    MANDATORY = 0
<span class="w"> </span>    ALPN = 1
<span class="w"> </span>    NO_DEFAULT_ALPN = 2
<span class="gu">@@ -29,6 +36,22 @@ class ParamKey(dns.enum.IntEnum):</span>
<span class="w"> </span>    IPV6HINT = 6
<span class="w"> </span>    DOHPATH = 7

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 65535</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _short_name(cls):</span>
<span class="gi">+        return &quot;SVCBParamKey&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _prefix(cls):</span>
<span class="gi">+        return &quot;KEY&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _unknown_exception_class(cls):</span>
<span class="gi">+        return UnknownParamKey</span>
<span class="gi">+</span>

<span class="w"> </span>class Emptiness(enum.IntEnum):
<span class="w"> </span>    NEVER = 0
<span class="gu">@@ -36,13 +59,108 @@ class Emptiness(enum.IntEnum):</span>
<span class="w"> </span>    ALLOWED = 2


<span class="gi">+def _validate_key(key):</span>
<span class="gi">+    force_generic = False</span>
<span class="gi">+    if isinstance(key, bytes):</span>
<span class="gi">+        # We decode to latin-1 so we get 0-255 as valid and do NOT interpret</span>
<span class="gi">+        # UTF-8 sequences</span>
<span class="gi">+        key = key.decode(&quot;latin-1&quot;)</span>
<span class="gi">+    if isinstance(key, str):</span>
<span class="gi">+        if key.lower().startswith(&quot;key&quot;):</span>
<span class="gi">+            force_generic = True</span>
<span class="gi">+            if key[3:].startswith(&quot;0&quot;) and len(key) != 4:</span>
<span class="gi">+                # key has leading zeros</span>
<span class="gi">+                raise ValueError(&quot;leading zeros in key&quot;)</span>
<span class="gi">+        key = key.replace(&quot;-&quot;, &quot;_&quot;)</span>
<span class="gi">+    return (ParamKey.make(key), force_generic)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def key_to_text(key):</span>
<span class="gi">+    return ParamKey.to_text(key).replace(&quot;_&quot;, &quot;-&quot;).lower()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Like rdata escapify, but escapes &#39;,&#39; too.</span>
<span class="gi">+</span>
<span class="w"> </span>_escaped = b&#39;&quot;,\\&#39;


<span class="gi">+def _escapify(qstring):</span>
<span class="gi">+    text = &quot;&quot;</span>
<span class="gi">+    for c in qstring:</span>
<span class="gi">+        if c in _escaped:</span>
<span class="gi">+            text += &quot;\\&quot; + chr(c)</span>
<span class="gi">+        elif c &gt;= 0x20 and c &lt; 0x7F:</span>
<span class="gi">+            text += chr(c)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text += &quot;\\%03d&quot; % c</span>
<span class="gi">+    return text</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _unescape(value):</span>
<span class="gi">+    if value == &quot;&quot;:</span>
<span class="gi">+        return value</span>
<span class="gi">+    unescaped = b&quot;&quot;</span>
<span class="gi">+    l = len(value)</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; l:</span>
<span class="gi">+        c = value[i]</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        if c == &quot;\\&quot;:</span>
<span class="gi">+            if i &gt;= l:  # pragma: no cover   (can&#39;t happen via tokenizer get())</span>
<span class="gi">+                raise dns.exception.UnexpectedEnd</span>
<span class="gi">+            c = value[i]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            if c.isdigit():</span>
<span class="gi">+                if i &gt;= l:</span>
<span class="gi">+                    raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                c2 = value[i]</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                if i &gt;= l:</span>
<span class="gi">+                    raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                c3 = value[i]</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                if not (c2.isdigit() and c3.isdigit()):</span>
<span class="gi">+                    raise dns.exception.SyntaxError</span>
<span class="gi">+                codepoint = int(c) * 100 + int(c2) * 10 + int(c3)</span>
<span class="gi">+                if codepoint &gt; 255:</span>
<span class="gi">+                    raise dns.exception.SyntaxError</span>
<span class="gi">+                unescaped += b&quot;%c&quot; % (codepoint)</span>
<span class="gi">+                continue</span>
<span class="gi">+        unescaped += c.encode()</span>
<span class="gi">+    return unescaped</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _split(value):</span>
<span class="gi">+    l = len(value)</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    items = []</span>
<span class="gi">+    unescaped = b&quot;&quot;</span>
<span class="gi">+    while i &lt; l:</span>
<span class="gi">+        c = value[i]</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        if c == ord(&quot;\\&quot;):</span>
<span class="gi">+            if i &gt;= l:  # pragma: no cover   (can&#39;t happen via tokenizer get())</span>
<span class="gi">+                raise dns.exception.UnexpectedEnd</span>
<span class="gi">+            c = value[i]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            unescaped += b&quot;%c&quot; % (c)</span>
<span class="gi">+        elif c == ord(&quot;,&quot;):</span>
<span class="gi">+            items.append(unescaped)</span>
<span class="gi">+            unescaped = b&quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            unescaped += b&quot;%c&quot; % (c)</span>
<span class="gi">+    items.append(unescaped)</span>
<span class="gi">+    return items</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class Param:
<span class="w"> </span>    &quot;&quot;&quot;Abstract base class for SVCB parameters&quot;&quot;&quot;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def emptiness(cls):</span>
<span class="gi">+        return Emptiness.NEVER</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class GenericParam(Param):
<span class="gu">@@ -51,75 +169,269 @@ class GenericParam(Param):</span>
<span class="w"> </span>    def __init__(self, value):
<span class="w"> </span>        self.value = dns.rdata.Rdata._as_bytes(value, True)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def emptiness(cls):</span>
<span class="gi">+        return Emptiness.ALLOWED</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        if value is None or len(value) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return cls(_unescape(value))</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        return &#39;&quot;&#39; + dns.rdata._escapify(self.value) + &#39;&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        value = parser.get_bytes(parser.remaining())</span>
<span class="gi">+        if len(value) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return cls(value)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        file.write(self.value)</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class MandatoryParam(Param):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, keys):
<span class="gi">+        # check for duplicates</span>
<span class="w"> </span>        keys = sorted([_validate_key(key)[0] for key in keys])
<span class="w"> </span>        prior_k = None
<span class="w"> </span>        for k in keys:
<span class="w"> </span>            if k == prior_k:
<span class="gd">-                raise ValueError(f&#39;duplicate key {k:d}&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;duplicate key {k:d}&quot;)</span>
<span class="w"> </span>            prior_k = k
<span class="w"> </span>            if k == ParamKey.MANDATORY:
<span class="gd">-                raise ValueError(&#39;listed the mandatory key as mandatory&#39;)</span>
<span class="gi">+                raise ValueError(&quot;listed the mandatory key as mandatory&quot;)</span>
<span class="w"> </span>        self.keys = tuple(keys)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        keys = [k.encode() for k in value.split(&quot;,&quot;)]</span>
<span class="gi">+        return cls(keys)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        return &#39;&quot;&#39; + &quot;,&quot;.join([key_to_text(key) for key in self.keys]) + &#39;&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        keys = []</span>
<span class="gi">+        last_key = -1</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            key = parser.get_uint16()</span>
<span class="gi">+            if key &lt; last_key:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;manadatory keys not ascending&quot;)</span>
<span class="gi">+            last_key = key</span>
<span class="gi">+            keys.append(key)</span>
<span class="gi">+        return cls(keys)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        for key in self.keys:</span>
<span class="gi">+            file.write(struct.pack(&quot;!H&quot;, key))</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ALPNParam(Param):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, ids):
<span class="gd">-        self.ids = dns.rdata.Rdata._as_tuple(ids, lambda x: dns.rdata.Rdata</span>
<span class="gd">-            ._as_bytes(x, True, 255, False))</span>
<span class="gi">+        self.ids = dns.rdata.Rdata._as_tuple(</span>
<span class="gi">+            ids, lambda x: dns.rdata.Rdata._as_bytes(x, True, 255, False)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        return cls(_split(_unescape(value)))</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        value = &quot;,&quot;.join([_escapify(id) for id in self.ids])</span>
<span class="gi">+        return &#39;&quot;&#39; + dns.rdata._escapify(value.encode()) + &#39;&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        ids = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            id = parser.get_counted_bytes()</span>
<span class="gi">+            ids.append(id)</span>
<span class="gi">+        return cls(ids)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        for id in self.ids:</span>
<span class="gi">+            file.write(struct.pack(&quot;!B&quot;, len(id)))</span>
<span class="gi">+            file.write(id)</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class NoDefaultALPNParam(Param):
<span class="gd">-    pass</span>
<span class="gi">+    # We don&#39;t ever expect to instantiate this class, but we need</span>
<span class="gi">+    # a from_value() and a from_wire_parser(), so we just return None</span>
<span class="gi">+    # from the class methods when things are OK.</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def emptiness(cls):</span>
<span class="gi">+        return Emptiness.ALWAYS</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        if value is None or value == &quot;&quot;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;no-default-alpn with non-empty value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        if parser.remaining() != 0:</span>
<span class="gi">+            raise dns.exception.FormError</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class PortParam(Param):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, port):
<span class="w"> </span>        self.port = dns.rdata.Rdata._as_uint16(port)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        value = int(value)</span>
<span class="gi">+        return cls(value)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        return f&#39;&quot;{self.port}&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        port = parser.get_uint16()</span>
<span class="gi">+        return cls(port)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, self.port))</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class IPv4HintParam(Param):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, addresses):
<span class="gd">-        self.addresses = dns.rdata.Rdata._as_tuple(addresses, dns.rdata.</span>
<span class="gd">-            Rdata._as_ipv4_address)</span>
<span class="gi">+        self.addresses = dns.rdata.Rdata._as_tuple(</span>
<span class="gi">+            addresses, dns.rdata.Rdata._as_ipv4_address</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        addresses = value.split(&quot;,&quot;)</span>
<span class="gi">+        return cls(addresses)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        return &#39;&quot;&#39; + &quot;,&quot;.join(self.addresses) + &#39;&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        addresses = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            ip = parser.get_bytes(4)</span>
<span class="gi">+            addresses.append(dns.ipv4.inet_ntoa(ip))</span>
<span class="gi">+        return cls(addresses)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        for address in self.addresses:</span>
<span class="gi">+            file.write(dns.ipv4.inet_aton(address))</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class IPv6HintParam(Param):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, addresses):
<span class="gd">-        self.addresses = dns.rdata.Rdata._as_tuple(addresses, dns.rdata.</span>
<span class="gd">-            Rdata._as_ipv6_address)</span>
<span class="gi">+        self.addresses = dns.rdata.Rdata._as_tuple(</span>
<span class="gi">+            addresses, dns.rdata.Rdata._as_ipv6_address</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        addresses = value.split(&quot;,&quot;)</span>
<span class="gi">+        return cls(addresses)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        return &#39;&quot;&#39; + &quot;,&quot;.join(self.addresses) + &#39;&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        addresses = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            ip = parser.get_bytes(16)</span>
<span class="gi">+            addresses.append(dns.ipv6.inet_ntoa(ip))</span>
<span class="gi">+        return cls(addresses)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        for address in self.addresses:</span>
<span class="gi">+            file.write(dns.ipv6.inet_aton(address))</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ECHParam(Param):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, ech):
<span class="w"> </span>        self.ech = dns.rdata.Rdata._as_bytes(ech, True)

<span class="gd">-</span>
<span class="gd">-_class_for_key = {ParamKey.MANDATORY: MandatoryParam, ParamKey.ALPN:</span>
<span class="gd">-    ALPNParam, ParamKey.NO_DEFAULT_ALPN: NoDefaultALPNParam, ParamKey.PORT:</span>
<span class="gd">-    PortParam, ParamKey.IPV4HINT: IPv4HintParam, ParamKey.ECH: ECHParam,</span>
<span class="gd">-    ParamKey.IPV6HINT: IPv6HintParam}</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_value(cls, value):</span>
<span class="gi">+        if &quot;\\&quot; in value:</span>
<span class="gi">+            raise ValueError(&quot;escape in ECH value&quot;)</span>
<span class="gi">+        value = base64.b64decode(value.encode())</span>
<span class="gi">+        return cls(value)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self):</span>
<span class="gi">+        b64 = base64.b64encode(self.ech).decode(&quot;ascii&quot;)</span>
<span class="gi">+        return f&#39;&quot;{b64}&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        value = parser.get_bytes(parser.remaining())</span>
<span class="gi">+        return cls(value)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file, origin=None):  # pylint: disable=W0613</span>
<span class="gi">+        file.write(self.ech)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_class_for_key = {</span>
<span class="gi">+    ParamKey.MANDATORY: MandatoryParam,</span>
<span class="gi">+    ParamKey.ALPN: ALPNParam,</span>
<span class="gi">+    ParamKey.NO_DEFAULT_ALPN: NoDefaultALPNParam,</span>
<span class="gi">+    ParamKey.PORT: PortParam,</span>
<span class="gi">+    ParamKey.IPV4HINT: IPv4HintParam,</span>
<span class="gi">+    ParamKey.ECH: ECHParam,</span>
<span class="gi">+    ParamKey.IPV6HINT: IPv6HintParam,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_and_define(params, key, value):</span>
<span class="gi">+    (key, force_generic) = _validate_key(_unescape(key))</span>
<span class="gi">+    if key in params:</span>
<span class="gi">+        raise SyntaxError(f&#39;duplicate key &quot;{key:d}&quot;&#39;)</span>
<span class="gi">+    cls = _class_for_key.get(key, GenericParam)</span>
<span class="gi">+    emptiness = cls.emptiness()</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        if emptiness == Emptiness.NEVER:</span>
<span class="gi">+            raise SyntaxError(&quot;value cannot be empty&quot;)</span>
<span class="gi">+        value = cls.from_value(value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if force_generic:</span>
<span class="gi">+            value = cls.from_wire_parser(dns.wire.Parser(_unescape(value)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = cls.from_value(value)</span>
<span class="gi">+    params[key] = value</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class SVCBBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for SVCB-like records&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;priority&#39;, &#39;target&#39;, &#39;params&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: draft-ietf-dnsop-svcb-https-11</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;priority&quot;, &quot;target&quot;, &quot;params&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, priority, target, params):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -128,14 +440,114 @@ class SVCBBase(dns.rdata.Rdata):</span>
<span class="w"> </span>        for k, v in params.items():
<span class="w"> </span>            k = ParamKey.make(k)
<span class="w"> </span>            if not isinstance(v, Param) and v is not None:
<span class="gd">-                raise ValueError(f&#39;{k:d} not a Param&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;{k:d} not a Param&quot;)</span>
<span class="w"> </span>        self.params = dns.immutable.Dict(params)
<span class="gi">+        # Make sure any parameter listed as mandatory is present in the</span>
<span class="gi">+        # record.</span>
<span class="w"> </span>        mandatory = params.get(ParamKey.MANDATORY)
<span class="w"> </span>        if mandatory:
<span class="w"> </span>            for key in mandatory.keys:
<span class="gi">+                # Note we have to say &quot;not in&quot; as we have None as a value</span>
<span class="gi">+                # so a get() and a not None test would be wrong.</span>
<span class="w"> </span>                if key not in params:
<span class="gd">-                    raise ValueError(</span>
<span class="gd">-                        f&#39;key {key:d} declared mandatory but not present&#39;)</span>
<span class="gi">+                    raise ValueError(f&quot;key {key:d} declared mandatory but not present&quot;)</span>
<span class="gi">+        # The no-default-alpn parameter requires the alpn parameter.</span>
<span class="w"> </span>        if ParamKey.NO_DEFAULT_ALPN in params:
<span class="w"> </span>            if ParamKey.ALPN not in params:
<span class="gd">-                raise ValueError(&#39;no-default-alpn present, but alpn missing&#39;)</span>
<span class="gi">+                raise ValueError(&quot;no-default-alpn present, but alpn missing&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        target = self.target.choose_relativity(origin, relativize)</span>
<span class="gi">+        params = []</span>
<span class="gi">+        for key in sorted(self.params.keys()):</span>
<span class="gi">+            value = self.params[key]</span>
<span class="gi">+            if value is None:</span>
<span class="gi">+                params.append(key_to_text(key))</span>
<span class="gi">+            else:</span>
<span class="gi">+                kv = key_to_text(key) + &quot;=&quot; + value.to_text()</span>
<span class="gi">+                params.append(kv)</span>
<span class="gi">+        if len(params) &gt; 0:</span>
<span class="gi">+            space = &quot; &quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            space = &quot;&quot;</span>
<span class="gi">+        return &quot;%d %s%s%s&quot; % (self.priority, target, space, &quot; &quot;.join(params))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        priority = tok.get_uint16()</span>
<span class="gi">+        target = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        if priority == 0:</span>
<span class="gi">+            token = tok.get()</span>
<span class="gi">+            if not token.is_eol_or_eof():</span>
<span class="gi">+                raise SyntaxError(&quot;parameters in AliasMode&quot;)</span>
<span class="gi">+            tok.unget(token)</span>
<span class="gi">+        params = {}</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token = tok.get()</span>
<span class="gi">+            if token.is_eol_or_eof():</span>
<span class="gi">+                tok.unget(token)</span>
<span class="gi">+                break</span>
<span class="gi">+            if token.ttype != dns.tokenizer.IDENTIFIER:</span>
<span class="gi">+                raise SyntaxError(&quot;parameter is not an identifier&quot;)</span>
<span class="gi">+            equals = token.value.find(&quot;=&quot;)</span>
<span class="gi">+            if equals == len(token.value) - 1:</span>
<span class="gi">+                # &#39;key=&#39;, so next token should be a quoted string without</span>
<span class="gi">+                # any intervening whitespace.</span>
<span class="gi">+                key = token.value[:-1]</span>
<span class="gi">+                token = tok.get(want_leading=True)</span>
<span class="gi">+                if token.ttype != dns.tokenizer.QUOTED_STRING:</span>
<span class="gi">+                    raise SyntaxError(&quot;whitespace after =&quot;)</span>
<span class="gi">+                value = token.value</span>
<span class="gi">+            elif equals &gt; 0:</span>
<span class="gi">+                # key=value</span>
<span class="gi">+                key = token.value[:equals]</span>
<span class="gi">+                value = token.value[equals + 1 :]</span>
<span class="gi">+            elif equals == 0:</span>
<span class="gi">+                # =key</span>
<span class="gi">+                raise SyntaxError(&#39;parameter cannot start with &quot;=&quot;&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # key</span>
<span class="gi">+                key = token.value</span>
<span class="gi">+                value = None</span>
<span class="gi">+            _validate_and_define(params, key, value)</span>
<span class="gi">+        return cls(rdclass, rdtype, priority, target, params)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        file.write(struct.pack(&quot;!H&quot;, self.priority))</span>
<span class="gi">+        self.target.to_wire(file, None, origin, False)</span>
<span class="gi">+        for key in sorted(self.params):</span>
<span class="gi">+            file.write(struct.pack(&quot;!H&quot;, key))</span>
<span class="gi">+            value = self.params[key]</span>
<span class="gi">+            with dns.renderer.prefixed_length(file, 2):</span>
<span class="gi">+                # Note that we&#39;re still writing a length of zero if the value is None</span>
<span class="gi">+                if value is not None:</span>
<span class="gi">+                    value.to_wire(file, origin)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        priority = parser.get_uint16()</span>
<span class="gi">+        target = parser.get_name(origin)</span>
<span class="gi">+        if priority == 0 and parser.remaining() != 0:</span>
<span class="gi">+            raise dns.exception.FormError(&quot;parameters in AliasMode&quot;)</span>
<span class="gi">+        params = {}</span>
<span class="gi">+        prior_key = -1</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            key = parser.get_uint16()</span>
<span class="gi">+            if key &lt; prior_key:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;keys not in order&quot;)</span>
<span class="gi">+            prior_key = key</span>
<span class="gi">+            vlen = parser.get_uint16()</span>
<span class="gi">+            pcls = _class_for_key.get(key, GenericParam)</span>
<span class="gi">+            with parser.restrict_to(vlen):</span>
<span class="gi">+                value = pcls.from_wire_parser(parser, origin)</span>
<span class="gi">+            params[key] = value</span>
<span class="gi">+        return cls(rdclass, rdtype, priority, target, params)</span>
<span class="gi">+</span>
<span class="gi">+    def _processing_priority(self):</span>
<span class="gi">+        return self.priority</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _processing_order(cls, iterable):</span>
<span class="gi">+        return dns.rdtypes.util.priority_processing_order(iterable)</span>
<span class="gh">diff --git a/dns/rdtypes/tlsabase.py b/dns/rdtypes/tlsabase.py</span>
<span class="gh">index fc65a48..a059d2c 100644</span>
<span class="gd">--- a/dns/rdtypes/tlsabase.py</span>
<span class="gi">+++ b/dns/rdtypes/tlsabase.py</span>
<span class="gu">@@ -1,5 +1,23 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2005-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="w"> </span>import dns.rdatatype
<span class="gu">@@ -8,7 +26,10 @@ import dns.rdatatype</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class TLSABase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for TLSA and SMIMEA records&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;usage&#39;, &#39;selector&#39;, &#39;mtype&#39;, &#39;cert&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    # see: RFC 6698</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;usage&quot;, &quot;selector&quot;, &quot;mtype&quot;, &quot;cert&quot;]</span>

<span class="w"> </span>    def __init__(self, rdclass, rdtype, usage, selector, mtype, cert):
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gu">@@ -16,3 +37,35 @@ class TLSABase(dns.rdata.Rdata):</span>
<span class="w"> </span>        self.selector = self._as_uint8(selector)
<span class="w"> </span>        self.mtype = self._as_uint8(mtype)
<span class="w"> </span>        self.cert = self._as_bytes(cert)
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True, **kw):</span>
<span class="gi">+        kw = kw.copy()</span>
<span class="gi">+        chunksize = kw.pop(&quot;chunksize&quot;, 128)</span>
<span class="gi">+        return &quot;%d %d %d %s&quot; % (</span>
<span class="gi">+            self.usage,</span>
<span class="gi">+            self.selector,</span>
<span class="gi">+            self.mtype,</span>
<span class="gi">+            dns.rdata._hexify(self.cert, chunksize=chunksize, **kw),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        usage = tok.get_uint8()</span>
<span class="gi">+        selector = tok.get_uint8()</span>
<span class="gi">+        mtype = tok.get_uint8()</span>
<span class="gi">+        cert = tok.concatenate_remaining_identifiers().encode()</span>
<span class="gi">+        cert = binascii.unhexlify(cert)</span>
<span class="gi">+        return cls(rdclass, rdtype, usage, selector, mtype, cert)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        header = struct.pack(&quot;!BBB&quot;, self.usage, self.selector, self.mtype)</span>
<span class="gi">+        file.write(header)</span>
<span class="gi">+        file.write(self.cert)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        header = parser.get_struct(&quot;BBB&quot;)</span>
<span class="gi">+        cert = parser.get_remaining()</span>
<span class="gi">+        return cls(rdclass, rdtype, header[0], header[1], header[2], cert)</span>
<span class="gh">diff --git a/dns/rdtypes/txtbase.py b/dns/rdtypes/txtbase.py</span>
<span class="gh">index 5fba0da..44d6df5 100644</span>
<span class="gd">--- a/dns/rdtypes/txtbase.py</span>
<span class="gi">+++ b/dns/rdtypes/txtbase.py</span>
<span class="gu">@@ -1,5 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TXT-like base class.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Dict, Iterable, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.rdata
<span class="gu">@@ -10,10 +29,15 @@ import dns.tokenizer</span>
<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class TXTBase(dns.rdata.Rdata):
<span class="w"> </span>    &quot;&quot;&quot;Base class for rdata that is like a TXT record (see RFC 1035).&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;strings&#39;]</span>

<span class="gd">-    def __init__(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns.</span>
<span class="gd">-        rdatatype.RdataType, strings: Iterable[Union[bytes, str]]):</span>
<span class="gi">+    __slots__ = [&quot;strings&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        strings: Iterable[Union[bytes, str]],</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a TXT-like rdata.

<span class="w"> </span>        *rdclass*, an ``int`` is the rdataclass of the Rdata.
<span class="gu">@@ -23,5 +47,58 @@ class TXTBase(dns.rdata.Rdata):</span>
<span class="w"> </span>        *strings*, a tuple of ``bytes``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super().__init__(rdclass, rdtype)
<span class="gd">-        self.strings: Tuple[bytes] = self._as_tuple(strings, lambda x: self</span>
<span class="gd">-            ._as_bytes(x, True, 255))</span>
<span class="gi">+        self.strings: Tuple[bytes] = self._as_tuple(</span>
<span class="gi">+            strings, lambda x: self._as_bytes(x, True, 255)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        txt = &quot;&quot;</span>
<span class="gi">+        prefix = &quot;&quot;</span>
<span class="gi">+        for s in self.strings:</span>
<span class="gi">+            txt += &#39;{}&quot;{}&quot;&#39;.format(prefix, dns.rdata._escapify(s))</span>
<span class="gi">+            prefix = &quot; &quot;</span>
<span class="gi">+        return txt</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        tok: dns.tokenizer.Tokenizer,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+    ) -&gt; dns.rdata.Rdata:</span>
<span class="gi">+        strings = []</span>
<span class="gi">+        for token in tok.get_remaining():</span>
<span class="gi">+            token = token.unescape_to_bytes()</span>
<span class="gi">+            # The &#39;if&#39; below is always true in the current code, but we</span>
<span class="gi">+            # are leaving this check in in case things change some day.</span>
<span class="gi">+            if not (</span>
<span class="gi">+                token.is_quoted_string() or token.is_identifier()</span>
<span class="gi">+            ):  # pragma: no cover</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;expected a string&quot;)</span>
<span class="gi">+            if len(token.value) &gt; 255:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;string too long&quot;)</span>
<span class="gi">+            strings.append(token.value)</span>
<span class="gi">+        if len(strings) == 0:</span>
<span class="gi">+            raise dns.exception.UnexpectedEnd</span>
<span class="gi">+        return cls(rdclass, rdtype, strings)</span>
<span class="gi">+</span>
<span class="gi">+    def _to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        for s in self.strings:</span>
<span class="gi">+            with dns.renderer.prefixed_length(file, 1):</span>
<span class="gi">+                file.write(s)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):</span>
<span class="gi">+        strings = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            s = parser.get_counted_bytes()</span>
<span class="gi">+            strings.append(s)</span>
<span class="gi">+        return cls(rdclass, rdtype, strings)</span>
<span class="gh">diff --git a/dns/rdtypes/util.py b/dns/rdtypes/util.py</span>
<span class="gh">index 920b9b3..54908fd 100644</span>
<span class="gd">--- a/dns/rdtypes/util.py</span>
<span class="gi">+++ b/dns/rdtypes/util.py</span>
<span class="gu">@@ -1,7 +1,25 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import random
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Any, List
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.ipv4
<span class="w"> </span>import dns.ipv6
<span class="gu">@@ -11,33 +29,229 @@ import dns.rdata</span>

<span class="w"> </span>class Gateway:
<span class="w"> </span>    &quot;&quot;&quot;A helper class for the IPSECKEY gateway and AMTRELAY relay fields&quot;&quot;&quot;
<span class="gd">-    name = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;&quot;</span>

<span class="w"> </span>    def __init__(self, type, gateway=None):
<span class="w"> </span>        self.type = dns.rdata.Rdata._as_uint8(type)
<span class="w"> </span>        self.gateway = gateway
<span class="w"> </span>        self._check()

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _invalid_type(cls, gateway_type):</span>
<span class="gi">+        return f&quot;invalid {cls.name} type: {gateway_type}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _check(self):</span>
<span class="gi">+        if self.type == 0:</span>
<span class="gi">+            if self.gateway not in (&quot;.&quot;, None):</span>
<span class="gi">+                raise SyntaxError(f&quot;invalid {self.name} for type 0&quot;)</span>
<span class="gi">+            self.gateway = None</span>
<span class="gi">+        elif self.type == 1:</span>
<span class="gi">+            # check that it&#39;s OK</span>
<span class="gi">+            dns.ipv4.inet_aton(self.gateway)</span>
<span class="gi">+        elif self.type == 2:</span>
<span class="gi">+            # check that it&#39;s OK</span>
<span class="gi">+            dns.ipv6.inet_aton(self.gateway)</span>
<span class="gi">+        elif self.type == 3:</span>
<span class="gi">+            if not isinstance(self.gateway, dns.name.Name):</span>
<span class="gi">+                raise SyntaxError(f&quot;invalid {self.name}; not a name&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SyntaxError(self._invalid_type(self.type))</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self, origin=None, relativize=True):</span>
<span class="gi">+        if self.type == 0:</span>
<span class="gi">+            return &quot;.&quot;</span>
<span class="gi">+        elif self.type in (1, 2):</span>
<span class="gi">+            return self.gateway</span>
<span class="gi">+        elif self.type == 3:</span>
<span class="gi">+            return str(self.gateway.choose_relativity(origin, relativize))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(self._invalid_type(self.type))  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(</span>
<span class="gi">+        cls, gateway_type, tok, origin=None, relativize=True, relativize_to=None</span>
<span class="gi">+    ):</span>
<span class="gi">+        if gateway_type in (0, 1, 2):</span>
<span class="gi">+            gateway = tok.get_string()</span>
<span class="gi">+        elif gateway_type == 3:</span>
<span class="gi">+            gateway = tok.get_name(origin, relativize, relativize_to)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                cls._invalid_type(gateway_type)</span>
<span class="gi">+            )  # pragma: no cover</span>
<span class="gi">+        return cls(gateway_type, gateway)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=unused-argument</span>
<span class="gi">+    def to_wire(self, file, compress=None, origin=None, canonicalize=False):</span>
<span class="gi">+        if self.type == 0:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif self.type == 1:</span>
<span class="gi">+            file.write(dns.ipv4.inet_aton(self.gateway))</span>
<span class="gi">+        elif self.type == 2:</span>
<span class="gi">+            file.write(dns.ipv6.inet_aton(self.gateway))</span>
<span class="gi">+        elif self.type == 3:</span>
<span class="gi">+            self.gateway.to_wire(file, None, origin, False)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(self._invalid_type(self.type))  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: enable=unused-argument</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, gateway_type, parser, origin=None):</span>
<span class="gi">+        if gateway_type == 0:</span>
<span class="gi">+            gateway = None</span>
<span class="gi">+        elif gateway_type == 1:</span>
<span class="gi">+            gateway = dns.ipv4.inet_ntoa(parser.get_bytes(4))</span>
<span class="gi">+        elif gateway_type == 2:</span>
<span class="gi">+            gateway = dns.ipv6.inet_ntoa(parser.get_bytes(16))</span>
<span class="gi">+        elif gateway_type == 3:</span>
<span class="gi">+            gateway = parser.get_name(origin)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise dns.exception.FormError(cls._invalid_type(gateway_type))</span>
<span class="gi">+        return cls(gateway_type, gateway)</span>
<span class="gi">+</span>

<span class="w"> </span>class Bitmap:
<span class="w"> </span>    &quot;&quot;&quot;A helper class for the NSEC/NSEC3/CSYNC type bitmaps&quot;&quot;&quot;
<span class="gd">-    type_name = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = &quot;&quot;</span>

<span class="w"> </span>    def __init__(self, windows=None):
<span class="w"> </span>        last_window = -1
<span class="w"> </span>        self.windows = windows
<span class="w"> </span>        for window, bitmap in self.windows:
<span class="w"> </span>            if not isinstance(window, int):
<span class="gd">-                raise ValueError(f&#39;bad {self.type_name} window type&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;bad {self.type_name} window type&quot;)</span>
<span class="w"> </span>            if window &lt;= last_window:
<span class="gd">-                raise ValueError(f&#39;bad {self.type_name} window order&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;bad {self.type_name} window order&quot;)</span>
<span class="w"> </span>            if window &gt; 256:
<span class="gd">-                raise ValueError(f&#39;bad {self.type_name} window number&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;bad {self.type_name} window number&quot;)</span>
<span class="w"> </span>            last_window = window
<span class="w"> </span>            if not isinstance(bitmap, bytes):
<span class="gd">-                raise ValueError(f&#39;bad {self.type_name} octets type&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;bad {self.type_name} octets type&quot;)</span>
<span class="w"> </span>            if len(bitmap) == 0 or len(bitmap) &gt; 32:
<span class="gd">-                raise ValueError(f&#39;bad {self.type_name} octets&#39;)</span>
<span class="gi">+                raise ValueError(f&quot;bad {self.type_name} octets&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(self) -&gt; str:</span>
<span class="gi">+        text = &quot;&quot;</span>
<span class="gi">+        for window, bitmap in self.windows:</span>
<span class="gi">+            bits = []</span>
<span class="gi">+            for i, byte in enumerate(bitmap):</span>
<span class="gi">+                for j in range(0, 8):</span>
<span class="gi">+                    if byte &amp; (0x80 &gt;&gt; j):</span>
<span class="gi">+                        rdtype = window * 256 + i * 8 + j</span>
<span class="gi">+                        bits.append(dns.rdatatype.to_text(rdtype))</span>
<span class="gi">+            text += &quot; &quot; + &quot; &quot;.join(bits)</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_text(cls, tok: &quot;dns.tokenizer.Tokenizer&quot;) -&gt; &quot;Bitmap&quot;:</span>
<span class="gi">+        rdtypes = []</span>
<span class="gi">+        for token in tok.get_remaining():</span>
<span class="gi">+            rdtype = dns.rdatatype.from_text(token.unescape().value)</span>
<span class="gi">+            if rdtype == 0:</span>
<span class="gi">+                raise dns.exception.SyntaxError(f&quot;{cls.type_name} with bit 0&quot;)</span>
<span class="gi">+            rdtypes.append(rdtype)</span>
<span class="gi">+        return cls.from_rdtypes(rdtypes)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_rdtypes(cls, rdtypes: List[dns.rdatatype.RdataType]) -&gt; &quot;Bitmap&quot;:</span>
<span class="gi">+        rdtypes = sorted(rdtypes)</span>
<span class="gi">+        window = 0</span>
<span class="gi">+        octets = 0</span>
<span class="gi">+        prior_rdtype = 0</span>
<span class="gi">+        bitmap = bytearray(b&quot;\0&quot; * 32)</span>
<span class="gi">+        windows = []</span>
<span class="gi">+        for rdtype in rdtypes:</span>
<span class="gi">+            if rdtype == prior_rdtype:</span>
<span class="gi">+                continue</span>
<span class="gi">+            prior_rdtype = rdtype</span>
<span class="gi">+            new_window = rdtype // 256</span>
<span class="gi">+            if new_window != window:</span>
<span class="gi">+                if octets != 0:</span>
<span class="gi">+                    windows.append((window, bytes(bitmap[0:octets])))</span>
<span class="gi">+                bitmap = bytearray(b&quot;\0&quot; * 32)</span>
<span class="gi">+                window = new_window</span>
<span class="gi">+            offset = rdtype % 256</span>
<span class="gi">+            byte = offset // 8</span>
<span class="gi">+            bit = offset % 8</span>
<span class="gi">+            octets = byte + 1</span>
<span class="gi">+            bitmap[byte] = bitmap[byte] | (0x80 &gt;&gt; bit)</span>
<span class="gi">+        if octets != 0:</span>
<span class="gi">+            windows.append((window, bytes(bitmap[0:octets])))</span>
<span class="gi">+        return cls(windows)</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(self, file: Any) -&gt; None:</span>
<span class="gi">+        for window, bitmap in self.windows:</span>
<span class="gi">+            file.write(struct.pack(&quot;!BB&quot;, window, len(bitmap)))</span>
<span class="gi">+            file.write(bitmap)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_wire_parser(cls, parser: &quot;dns.wire.Parser&quot;) -&gt; &quot;Bitmap&quot;:</span>
<span class="gi">+        windows = []</span>
<span class="gi">+        while parser.remaining() &gt; 0:</span>
<span class="gi">+            window = parser.get_uint8()</span>
<span class="gi">+            bitmap = parser.get_counted_bytes()</span>
<span class="gi">+            windows.append((window, bitmap))</span>
<span class="gi">+        return cls(windows)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _priority_table(items):</span>
<span class="gi">+    by_priority = collections.defaultdict(list)</span>
<span class="gi">+    for rdata in items:</span>
<span class="gi">+        by_priority[rdata._processing_priority()].append(rdata)</span>
<span class="gi">+    return by_priority</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def priority_processing_order(iterable):</span>
<span class="gi">+    items = list(iterable)</span>
<span class="gi">+    if len(items) == 1:</span>
<span class="gi">+        return items</span>
<span class="gi">+    by_priority = _priority_table(items)</span>
<span class="gi">+    ordered = []</span>
<span class="gi">+    for k in sorted(by_priority.keys()):</span>
<span class="gi">+        rdatas = by_priority[k]</span>
<span class="gi">+        random.shuffle(rdatas)</span>
<span class="gi">+        ordered.extend(rdatas)</span>
<span class="gi">+    return ordered</span>


<span class="w"> </span>_no_weight = 0.1
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def weighted_processing_order(iterable):</span>
<span class="gi">+    items = list(iterable)</span>
<span class="gi">+    if len(items) == 1:</span>
<span class="gi">+        return items</span>
<span class="gi">+    by_priority = _priority_table(items)</span>
<span class="gi">+    ordered = []</span>
<span class="gi">+    for k in sorted(by_priority.keys()):</span>
<span class="gi">+        rdatas = by_priority[k]</span>
<span class="gi">+        total = sum(rdata._processing_weight() or _no_weight for rdata in rdatas)</span>
<span class="gi">+        while len(rdatas) &gt; 1:</span>
<span class="gi">+            r = random.uniform(0, total)</span>
<span class="gi">+            for n, rdata in enumerate(rdatas):</span>
<span class="gi">+                weight = rdata._processing_weight() or _no_weight</span>
<span class="gi">+                if weight &gt; r:</span>
<span class="gi">+                    break</span>
<span class="gi">+                r -= weight</span>
<span class="gi">+            total -= weight</span>
<span class="gi">+            ordered.append(rdata)  # pylint: disable=undefined-loop-variable</span>
<span class="gi">+            del rdatas[n]  # pylint: disable=undefined-loop-variable</span>
<span class="gi">+        ordered.append(rdatas[0])</span>
<span class="gi">+    return ordered</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_formatted_hex(formatted, num_chunks, chunk_size, separator):</span>
<span class="gi">+    if len(formatted) != num_chunks * (chunk_size + 1) - 1:</span>
<span class="gi">+        raise ValueError(&quot;invalid formatted hex string&quot;)</span>
<span class="gi">+    value = b&quot;&quot;</span>
<span class="gi">+    for _ in range(num_chunks):</span>
<span class="gi">+        chunk = formatted[0:chunk_size]</span>
<span class="gi">+        value += int(chunk, 16).to_bytes(chunk_size // 2, &quot;big&quot;)</span>
<span class="gi">+        formatted = formatted[chunk_size:]</span>
<span class="gi">+        if len(formatted) &gt; 0 and formatted[0] != separator:</span>
<span class="gi">+            raise ValueError(&quot;invalid formatted hex string&quot;)</span>
<span class="gi">+        formatted = formatted[1:]</span>
<span class="gi">+    return value</span>
<span class="gh">diff --git a/dns/renderer.py b/dns/renderer.py</span>
<span class="gh">index fbebb17..a77481f 100644</span>
<span class="gd">--- a/dns/renderer.py</span>
<span class="gi">+++ b/dns/renderer.py</span>
<span class="gu">@@ -1,17 +1,55 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Help for building DNS wire format messages&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import io
<span class="w"> </span>import random
<span class="w"> </span>import struct
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.tsig
<span class="gi">+</span>
<span class="w"> </span>QUESTION = 0
<span class="w"> </span>ANSWER = 1
<span class="w"> </span>AUTHORITY = 2
<span class="w"> </span>ADDITIONAL = 3


<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def prefixed_length(output, length_length):</span>
<span class="gi">+    output.write(b&quot;\00&quot; * length_length)</span>
<span class="gi">+    start = output.tell()</span>
<span class="gi">+    yield</span>
<span class="gi">+    end = output.tell()</span>
<span class="gi">+    length = end - start</span>
<span class="gi">+    if length &gt; 0:</span>
<span class="gi">+        try:</span>
<span class="gi">+            output.seek(start - length_length)</span>
<span class="gi">+            try:</span>
<span class="gi">+                output.write(length.to_bytes(length_length, &quot;big&quot;))</span>
<span class="gi">+            except OverflowError:</span>
<span class="gi">+                raise dns.exception.FormError</span>
<span class="gi">+        finally:</span>
<span class="gi">+            output.seek(end)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Renderer:
<span class="w"> </span>    &quot;&quot;&quot;Helper class for building DNS wire-format messages.

<span class="gu">@@ -59,6 +97,7 @@ class Renderer:</span>

<span class="w"> </span>    def __init__(self, id=None, flags=0, max_size=65535, origin=None):
<span class="w"> </span>        &quot;&quot;&quot;Initialize a new renderer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.output = io.BytesIO()
<span class="w"> </span>        if id is None:
<span class="w"> </span>            self.id = random.randint(0, 65535)
<span class="gu">@@ -70,8 +109,8 @@ class Renderer:</span>
<span class="w"> </span>        self.compress = {}
<span class="w"> </span>        self.section = QUESTION
<span class="w"> </span>        self.counts = [0, 0, 0, 0]
<span class="gd">-        self.output.write(b&#39;\x00&#39; * 12)</span>
<span class="gd">-        self.mac = &#39;&#39;</span>
<span class="gi">+        self.output.write(b&quot;\x00&quot; * 12)</span>
<span class="gi">+        self.mac = &quot;&quot;</span>
<span class="w"> </span>        self.reserved = 0
<span class="w"> </span>        self.was_padded = False

<span class="gu">@@ -80,7 +119,15 @@ class Renderer:</span>
<span class="w"> </span>        compression table entries that pointed beyond the truncation
<span class="w"> </span>        point.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.output.seek(where)</span>
<span class="gi">+        self.output.truncate()</span>
<span class="gi">+        keys_to_delete = []</span>
<span class="gi">+        for k, v in self.compress.items():</span>
<span class="gi">+            if v &gt;= where:</span>
<span class="gi">+                keys_to_delete.append(k)</span>
<span class="gi">+        for k in keys_to_delete:</span>
<span class="gi">+            del self.compress[k]</span>

<span class="w"> </span>    def _set_section(self, section):
<span class="w"> </span>        &quot;&quot;&quot;Set the renderer&#39;s current section.
<span class="gu">@@ -91,11 +138,37 @@ class Renderer:</span>
<span class="w"> </span>        Raises dns.exception.FormError if an attempt was made to set
<span class="w"> </span>        a section value less than the current section.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if self.section != section:</span>
<span class="gi">+            if self.section &gt; section:</span>
<span class="gi">+                raise dns.exception.FormError</span>
<span class="gi">+            self.section = section</span>
<span class="gi">+</span>
<span class="gi">+    @contextlib.contextmanager</span>
<span class="gi">+    def _track_size(self):</span>
<span class="gi">+        start = self.output.tell()</span>
<span class="gi">+        yield start</span>
<span class="gi">+        if self.output.tell() &gt; self.max_size:</span>
<span class="gi">+            self._rollback(start)</span>
<span class="gi">+            raise dns.exception.TooBig</span>
<span class="gi">+</span>
<span class="gi">+    @contextlib.contextmanager</span>
<span class="gi">+    def _temporarily_seek_to(self, where):</span>
<span class="gi">+        current = self.output.tell()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.output.seek(where)</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.output.seek(current)</span>

<span class="w"> </span>    def add_question(self, qname, rdtype, rdclass=dns.rdataclass.IN):
<span class="w"> </span>        &quot;&quot;&quot;Add a question to the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self._set_section(QUESTION)</span>
<span class="gi">+        with self._track_size():</span>
<span class="gi">+            qname.to_wire(self.output, self.compress, self.origin)</span>
<span class="gi">+            self.output.write(struct.pack(&quot;!HH&quot;, rdtype, rdclass))</span>
<span class="gi">+        self.counts[QUESTION] += 1</span>

<span class="w"> </span>    def add_rrset(self, section, rrset, **kw):
<span class="w"> </span>        &quot;&quot;&quot;Add the rrset to the specified section.
<span class="gu">@@ -103,7 +176,11 @@ class Renderer:</span>
<span class="w"> </span>        Any keyword arguments are passed on to the rdataset&#39;s to_wire()
<span class="w"> </span>        routine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self._set_section(section)</span>
<span class="gi">+        with self._track_size():</span>
<span class="gi">+            n = rrset.to_wire(self.output, self.compress, self.origin, **kw)</span>
<span class="gi">+        self.counts[section] += n</span>

<span class="w"> </span>    def add_rdataset(self, section, name, rdataset, **kw):
<span class="w"> </span>        &quot;&quot;&quot;Add the rdataset to the specified section, using the specified
<span class="gu">@@ -112,7 +189,11 @@ class Renderer:</span>
<span class="w"> </span>        Any keyword arguments are passed on to the rdataset&#39;s to_wire()
<span class="w"> </span>        routine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self._set_section(section)</span>
<span class="gi">+        with self._track_size():</span>
<span class="gi">+            n = rdataset.to_wire(name, self.output, self.compress, self.origin, **kw)</span>
<span class="gi">+        self.counts[section] += n</span>

<span class="w"> </span>    def add_opt(self, opt, pad=0, opt_size=0, tsig_size=0):
<span class="w"> </span>        &quot;&quot;&quot;Add *opt* to the additional section, applying padding if desired.  The
<span class="gu">@@ -121,19 +202,68 @@ class Renderer:</span>

<span class="w"> </span>        Note that we don&#39;t have reliable way of knowing how big a GSS-TSIG digest
<span class="w"> </span>        might be, so we we might not get an even multiple of the pad in that case.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if pad:</span>
<span class="gi">+            ttl = opt.ttl</span>
<span class="gi">+            assert opt_size &gt;= 11</span>
<span class="gi">+            opt_rdata = opt[0]</span>
<span class="gi">+            size_without_padding = self.output.tell() + opt_size + tsig_size</span>
<span class="gi">+            remainder = size_without_padding % pad</span>
<span class="gi">+            if remainder:</span>
<span class="gi">+                pad = b&quot;\x00&quot; * (pad - remainder)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pad = b&quot;&quot;</span>
<span class="gi">+            options = list(opt_rdata.options)</span>
<span class="gi">+            options.append(dns.edns.GenericOption(dns.edns.OptionType.PADDING, pad))</span>
<span class="gi">+            opt = dns.message.Message._make_opt(ttl, opt_rdata.rdclass, options)</span>
<span class="gi">+            self.was_padded = True</span>
<span class="gi">+        self.add_rrset(ADDITIONAL, opt)</span>

<span class="w"> </span>    def add_edns(self, edns, ednsflags, payload, options=None):
<span class="w"> </span>        &quot;&quot;&quot;Add an EDNS OPT record to the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def add_tsig(self, keyname, secret, fudge, id, tsig_error, other_data,</span>
<span class="gd">-        request_mac, algorithm=dns.tsig.default_algorithm):</span>
<span class="gi">+        # make sure the EDNS version in ednsflags agrees with edns</span>
<span class="gi">+        ednsflags &amp;= 0xFF00FFFF</span>
<span class="gi">+        ednsflags |= edns &lt;&lt; 16</span>
<span class="gi">+        opt = dns.message.Message._make_opt(ednsflags, payload, options)</span>
<span class="gi">+        self.add_opt(opt)</span>
<span class="gi">+</span>
<span class="gi">+    def add_tsig(</span>
<span class="gi">+        self,</span>
<span class="gi">+        keyname,</span>
<span class="gi">+        secret,</span>
<span class="gi">+        fudge,</span>
<span class="gi">+        id,</span>
<span class="gi">+        tsig_error,</span>
<span class="gi">+        other_data,</span>
<span class="gi">+        request_mac,</span>
<span class="gi">+        algorithm=dns.tsig.default_algorithm,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a TSIG signature to the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def add_multi_tsig(self, ctx, keyname, secret, fudge, id, tsig_error,</span>
<span class="gd">-        other_data, request_mac, algorithm=dns.tsig.default_algorithm):</span>
<span class="gi">+        s = self.output.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(secret, dns.tsig.Key):</span>
<span class="gi">+            key = secret</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = dns.tsig.Key(keyname, secret, algorithm)</span>
<span class="gi">+        tsig = dns.message.Message._make_tsig(</span>
<span class="gi">+            keyname, algorithm, 0, fudge, b&quot;&quot;, id, tsig_error, other_data</span>
<span class="gi">+        )</span>
<span class="gi">+        (tsig, _) = dns.tsig.sign(s, key, tsig[0], int(time.time()), request_mac)</span>
<span class="gi">+        self._write_tsig(tsig, keyname)</span>
<span class="gi">+</span>
<span class="gi">+    def add_multi_tsig(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ctx,</span>
<span class="gi">+        keyname,</span>
<span class="gi">+        secret,</span>
<span class="gi">+        fudge,</span>
<span class="gi">+        id,</span>
<span class="gi">+        tsig_error,</span>
<span class="gi">+        other_data,</span>
<span class="gi">+        request_mac,</span>
<span class="gi">+        algorithm=dns.tsig.default_algorithm,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a TSIG signature to the message. Unlike add_tsig(), this can be
<span class="w"> </span>        used for a series of consecutive DNS envelopes, e.g. for a zone
<span class="w"> </span>        transfer over TCP [RFC2845, 4.4].
<span class="gu">@@ -141,7 +271,39 @@ class Renderer:</span>
<span class="w"> </span>        For the first message in the sequence, give ctx=None. For each
<span class="w"> </span>        subsequent message, give the ctx that was returned from the
<span class="w"> </span>        add_multi_tsig() call for the previous message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        s = self.output.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(secret, dns.tsig.Key):</span>
<span class="gi">+            key = secret</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = dns.tsig.Key(keyname, secret, algorithm)</span>
<span class="gi">+        tsig = dns.message.Message._make_tsig(</span>
<span class="gi">+            keyname, algorithm, 0, fudge, b&quot;&quot;, id, tsig_error, other_data</span>
<span class="gi">+        )</span>
<span class="gi">+        (tsig, ctx) = dns.tsig.sign(</span>
<span class="gi">+            s, key, tsig[0], int(time.time()), request_mac, ctx, True</span>
<span class="gi">+        )</span>
<span class="gi">+        self._write_tsig(tsig, keyname)</span>
<span class="gi">+        return ctx</span>
<span class="gi">+</span>
<span class="gi">+    def _write_tsig(self, tsig, keyname):</span>
<span class="gi">+        if self.was_padded:</span>
<span class="gi">+            compress = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            compress = self.compress</span>
<span class="gi">+        self._set_section(ADDITIONAL)</span>
<span class="gi">+        with self._track_size():</span>
<span class="gi">+            keyname.to_wire(self.output, compress, self.origin)</span>
<span class="gi">+            self.output.write(</span>
<span class="gi">+                struct.pack(&quot;!HHI&quot;, dns.rdatatype.TSIG, dns.rdataclass.ANY, 0)</span>
<span class="gi">+            )</span>
<span class="gi">+            with prefixed_length(self.output, 2):</span>
<span class="gi">+                tsig.to_wire(self.output)</span>
<span class="gi">+</span>
<span class="gi">+        self.counts[ADDITIONAL] += 1</span>
<span class="gi">+        with self._temporarily_seek_to(10):</span>
<span class="gi">+            self.output.write(struct.pack(&quot;!H&quot;, self.counts[ADDITIONAL]))</span>

<span class="w"> </span>    def write_header(self):
<span class="w"> </span>        &quot;&quot;&quot;Write the DNS message header.
<span class="gu">@@ -150,16 +312,35 @@ class Renderer:</span>
<span class="w"> </span>        have been rendered, but before the optional TSIG signature
<span class="w"> </span>        is added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        with self._temporarily_seek_to(0):</span>
<span class="gi">+            self.output.write(</span>
<span class="gi">+                struct.pack(</span>
<span class="gi">+                    &quot;!HHHHHH&quot;,</span>
<span class="gi">+                    self.id,</span>
<span class="gi">+                    self.flags,</span>
<span class="gi">+                    self.counts[0],</span>
<span class="gi">+                    self.counts[1],</span>
<span class="gi">+                    self.counts[2],</span>
<span class="gi">+                    self.counts[3],</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def get_wire(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the wire format message.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def reserve(self, size: int) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Reserve *size* bytes.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return self.output.getvalue()</span>

<span class="gd">-    def release_reserved(self) -&gt;None:</span>
<span class="gi">+    def reserve(self, size: int) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reserve *size* bytes.&quot;&quot;&quot;</span>
<span class="gi">+        if size &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;reserved amount must be non-negative&quot;)</span>
<span class="gi">+        if size &gt; self.max_size:</span>
<span class="gi">+            raise ValueError(&quot;cannot reserve more than the maximum size&quot;)</span>
<span class="gi">+        self.reserved += size</span>
<span class="gi">+        self.max_size -= size</span>
<span class="gi">+</span>
<span class="gi">+    def release_reserved(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Release the reserved bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.max_size += self.reserved</span>
<span class="gi">+        self.reserved = 0</span>
<span class="gh">diff --git a/dns/resolver.py b/dns/resolver.py</span>
<span class="gh">index 116ab15..f08f824 100644</span>
<span class="gd">--- a/dns/resolver.py</span>
<span class="gi">+++ b/dns/resolver.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS stub resolver.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import random
<span class="w"> </span>import socket
<span class="gu">@@ -8,6 +26,7 @@ import time</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import Any, Dict, Iterator, List, Optional, Sequence, Tuple, Union
<span class="w"> </span>from urllib.parse import urlparse
<span class="gi">+</span>
<span class="w"> </span>import dns._ddr
<span class="w"> </span>import dns.edns
<span class="w"> </span>import dns.exception
<span class="gu">@@ -25,40 +44,70 @@ import dns.rdatatype</span>
<span class="w"> </span>import dns.rdtypes.svcbbase
<span class="w"> </span>import dns.reversename
<span class="w"> </span>import dns.tsig
<span class="gd">-if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+</span>
<span class="gi">+if sys.platform == &quot;win32&quot;:</span>
<span class="w"> </span>    import dns.win32util


<span class="w"> </span>class NXDOMAIN(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;The DNS query name does not exist.&quot;&quot;&quot;
<span class="gd">-    supp_kwargs = {&#39;qnames&#39;, &#39;responses&#39;}</span>
<span class="gd">-    fmt = None</span>

<span class="gi">+    supp_kwargs = {&quot;qnames&quot;, &quot;responses&quot;}</span>
<span class="gi">+    fmt = None  # we have our own __str__ implementation</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=arguments-differ</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        if &#39;qnames&#39; not in self.kwargs:</span>
<span class="gi">+    def _check_kwargs(self, qnames, responses=None):</span>
<span class="gi">+        if not isinstance(qnames, (list, tuple, set)):</span>
<span class="gi">+            raise AttributeError(&quot;qnames must be a list, tuple or set&quot;)</span>
<span class="gi">+        if len(qnames) == 0:</span>
<span class="gi">+            raise AttributeError(&quot;qnames must contain at least one element&quot;)</span>
<span class="gi">+        if responses is None:</span>
<span class="gi">+            responses = {}</span>
<span class="gi">+        elif not isinstance(responses, dict):</span>
<span class="gi">+            raise AttributeError(&quot;responses must be a dict(qname=response)&quot;)</span>
<span class="gi">+        kwargs = dict(qnames=qnames, responses=responses)</span>
<span class="gi">+        return kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        if &quot;qnames&quot; not in self.kwargs:</span>
<span class="w"> </span>            return super().__str__()
<span class="gd">-        qnames = self.kwargs[&#39;qnames&#39;]</span>
<span class="gi">+        qnames = self.kwargs[&quot;qnames&quot;]</span>
<span class="w"> </span>        if len(qnames) &gt; 1:
<span class="gd">-            msg = &#39;None of DNS query names exist&#39;</span>
<span class="gi">+            msg = &quot;None of DNS query names exist&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            msg = &#39;The DNS query name does not exist&#39;</span>
<span class="gd">-        qnames = &#39;, &#39;.join(map(str, qnames))</span>
<span class="gd">-        return &#39;{}: {}&#39;.format(msg, qnames)</span>
<span class="gi">+            msg = &quot;The DNS query name does not exist&quot;</span>
<span class="gi">+        qnames = &quot;, &quot;.join(map(str, qnames))</span>
<span class="gi">+        return &quot;{}: {}&quot;.format(msg, qnames)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def canonical_name(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the unresolved canonical name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;qnames&quot; not in self.kwargs:</span>
<span class="gi">+            raise TypeError(&quot;parametrized exception required&quot;)</span>
<span class="gi">+        for qname in self.kwargs[&quot;qnames&quot;]:</span>
<span class="gi">+            response = self.kwargs[&quot;responses&quot;][qname]</span>
<span class="gi">+            try:</span>
<span class="gi">+                cname = response.canonical_name()</span>
<span class="gi">+                if cname != qname:</span>
<span class="gi">+                    return cname</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                # We can just eat this exception as it means there was</span>
<span class="gi">+                # something wrong with the response.</span>
<span class="gi">+                pass</span>
<span class="gi">+        return self.kwargs[&quot;qnames&quot;][0]</span>

<span class="w"> </span>    def __add__(self, e_nx):
<span class="w"> </span>        &quot;&quot;&quot;Augment by results from another NXDOMAIN exception.&quot;&quot;&quot;
<span class="gd">-        qnames0 = list(self.kwargs.get(&#39;qnames&#39;, []))</span>
<span class="gd">-        responses0 = dict(self.kwargs.get(&#39;responses&#39;, {}))</span>
<span class="gd">-        responses1 = e_nx.kwargs.get(&#39;responses&#39;, {})</span>
<span class="gd">-        for qname1 in e_nx.kwargs.get(&#39;qnames&#39;, []):</span>
<span class="gi">+        qnames0 = list(self.kwargs.get(&quot;qnames&quot;, []))</span>
<span class="gi">+        responses0 = dict(self.kwargs.get(&quot;responses&quot;, {}))</span>
<span class="gi">+        responses1 = e_nx.kwargs.get(&quot;responses&quot;, {})</span>
<span class="gi">+        for qname1 in e_nx.kwargs.get(&quot;qnames&quot;, []):</span>
<span class="w"> </span>            if qname1 not in qnames0:
<span class="w"> </span>                qnames0.append(qname1)
<span class="w"> </span>            if qname1 in responses1:
<span class="gu">@@ -70,7 +119,7 @@ class NXDOMAIN(dns.exception.DNSException):</span>

<span class="w"> </span>        Returns a list of ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.kwargs[&quot;qnames&quot;]</span>

<span class="w"> </span>    def responses(self):
<span class="w"> </span>        &quot;&quot;&quot;A map from queried names to their NXDOMAIN responses.
<span class="gu">@@ -78,51 +127,79 @@ class NXDOMAIN(dns.exception.DNSException):</span>
<span class="w"> </span>        Returns a dict mapping a ``dns.name.Name`` to a
<span class="w"> </span>        ``dns.message.Message``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.kwargs[&quot;responses&quot;]</span>

<span class="w"> </span>    def response(self, qname):
<span class="w"> </span>        &quot;&quot;&quot;The response for query *qname*.

<span class="w"> </span>        Returns a ``dns.message.Message``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.kwargs[&quot;responses&quot;][qname]</span>


<span class="w"> </span>class YXDOMAIN(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;The DNS query name is too long after DNAME substitution.&quot;&quot;&quot;


<span class="gd">-ErrorTuple = Tuple[Optional[str], bool, int, Union[Exception, str],</span>
<span class="gd">-    Optional[dns.message.Message]]</span>
<span class="gi">+ErrorTuple = Tuple[</span>
<span class="gi">+    Optional[str],</span>
<span class="gi">+    bool,</span>
<span class="gi">+    int,</span>
<span class="gi">+    Union[Exception, str],</span>
<span class="gi">+    Optional[dns.message.Message],</span>
<span class="gi">+]</span>


<span class="gd">-def _errors_to_text(errors: List[ErrorTuple]) -&gt;List[str]:</span>
<span class="gi">+def _errors_to_text(errors: List[ErrorTuple]) -&gt; List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Turn a resolution errors trace into a list of text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    texts = []</span>
<span class="gi">+    for err in errors:</span>
<span class="gi">+        texts.append(&quot;Server {} answered {}&quot;.format(err[0], err[3]))</span>
<span class="gi">+    return texts</span>


<span class="w"> </span>class LifetimeTimeout(dns.exception.Timeout):
<span class="w"> </span>    &quot;&quot;&quot;The resolution lifetime expired.&quot;&quot;&quot;
<span class="gd">-    msg = &#39;The resolution lifetime expired.&#39;</span>
<span class="gd">-    fmt = &#39;%s after {timeout:.3f} seconds: {errors}&#39; % msg[:-1]</span>
<span class="gd">-    supp_kwargs = {&#39;timeout&#39;, &#39;errors&#39;}</span>

<span class="gi">+    msg = &quot;The resolution lifetime expired.&quot;</span>
<span class="gi">+    fmt = &quot;%s after {timeout:.3f} seconds: {errors}&quot; % msg[:-1]</span>
<span class="gi">+    supp_kwargs = {&quot;timeout&quot;, &quot;errors&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gi">+    def _fmt_kwargs(self, **kwargs):</span>
<span class="gi">+        srv_msgs = _errors_to_text(kwargs[&quot;errors&quot;])</span>
<span class="gi">+        return super()._fmt_kwargs(</span>
<span class="gi">+            timeout=kwargs[&quot;timeout&quot;], errors=&quot;; &quot;.join(srv_msgs)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="gi">+# We added more detail to resolution timeouts, but they are still</span>
<span class="gi">+# subclasses of dns.exception.Timeout for backwards compatibility.  We also</span>
<span class="gi">+# keep dns.resolver.Timeout defined for backwards compatibility.</span>
<span class="w"> </span>Timeout = LifetimeTimeout


<span class="w"> </span>class NoAnswer(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;The DNS response does not contain an answer to the question.&quot;&quot;&quot;
<span class="gd">-    fmt = (</span>
<span class="gd">-        &#39;The DNS response does not contain an answer to the question: {query}&#39;)</span>
<span class="gd">-    supp_kwargs = {&#39;response&#39;}</span>

<span class="gi">+    fmt = &quot;The DNS response does not contain an answer to the question: {query}&quot;</span>
<span class="gi">+    supp_kwargs = {&quot;response&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gi">+    def _fmt_kwargs(self, **kwargs):</span>
<span class="gi">+        return super()._fmt_kwargs(query=kwargs[&quot;response&quot;].question)</span>
<span class="gi">+</span>
<span class="gi">+    def response(self):</span>
<span class="gi">+        return self.kwargs[&quot;response&quot;]</span>
<span class="gi">+</span>

<span class="w"> </span>class NoNameservers(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;All nameservers failed to answer the query.
<span class="gu">@@ -132,13 +209,22 @@ class NoNameservers(dns.exception.DNSException):</span>
<span class="w"> </span>    [(server IP address, any object convertible to string)].
<span class="w"> </span>    Non-empty errors list will add explanatory message ()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    msg = &#39;All nameservers failed to answer the query.&#39;</span>
<span class="gd">-    fmt = &#39;%s {query}: {errors}&#39; % msg[:-1]</span>
<span class="gd">-    supp_kwargs = {&#39;request&#39;, &#39;errors&#39;}</span>

<span class="gi">+    msg = &quot;All nameservers failed to answer the query.&quot;</span>
<span class="gi">+    fmt = &quot;%s {query}: {errors}&quot; % msg[:-1]</span>
<span class="gi">+    supp_kwargs = {&quot;request&quot;, &quot;errors&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    # We do this as otherwise mypy complains about unexpected keyword argument</span>
<span class="gi">+    # idna_exception</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gi">+    def _fmt_kwargs(self, **kwargs):</span>
<span class="gi">+        srv_msgs = _errors_to_text(kwargs[&quot;errors&quot;])</span>
<span class="gi">+        return super()._fmt_kwargs(</span>
<span class="gi">+            query=kwargs[&quot;request&quot;].question, errors=&quot;; &quot;.join(srv_msgs)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class NotAbsolute(dns.exception.DNSException):
<span class="w"> </span>    &quot;&quot;&quot;An absolute domain name is required but a relative name was provided.&quot;&quot;&quot;
<span class="gu">@@ -172,10 +258,15 @@ class Answer:</span>
<span class="w"> </span>    RRset&#39;s name might not be the query name.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, qname: dns.name.Name, rdtype: dns.rdatatype.</span>
<span class="gd">-        RdataType, rdclass: dns.rdataclass.RdataClass, response: dns.</span>
<span class="gd">-        message.QueryMessage, nameserver: Optional[str]=None, port:</span>
<span class="gd">-        Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        qname: dns.name.Name,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        response: dns.message.QueryMessage,</span>
<span class="gi">+        nameserver: Optional[str] = None,</span>
<span class="gi">+        port: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.qname = qname
<span class="w"> </span>        self.rdtype = rdtype
<span class="w"> </span>        self.rdclass = rdclass
<span class="gu">@@ -183,25 +274,27 @@ class Answer:</span>
<span class="w"> </span>        self.nameserver = nameserver
<span class="w"> </span>        self.port = port
<span class="w"> </span>        self.chaining_result = response.resolve_chaining()
<span class="gi">+        # Copy some attributes out of chaining_result for backwards</span>
<span class="gi">+        # compatibility and convenience.</span>
<span class="w"> </span>        self.canonical_name = self.chaining_result.canonical_name
<span class="w"> </span>        self.rrset = self.chaining_result.answer
<span class="w"> </span>        self.expiration = time.time() + self.chaining_result.minimum_ttl

<span class="gd">-    def __getattr__(self, attr):</span>
<span class="gd">-        if attr == &#39;name&#39;:</span>
<span class="gi">+    def __getattr__(self, attr):  # pragma: no cover</span>
<span class="gi">+        if attr == &quot;name&quot;:</span>
<span class="w"> </span>            return self.rrset.name
<span class="gd">-        elif attr == &#39;ttl&#39;:</span>
<span class="gi">+        elif attr == &quot;ttl&quot;:</span>
<span class="w"> </span>            return self.rrset.ttl
<span class="gd">-        elif attr == &#39;covers&#39;:</span>
<span class="gi">+        elif attr == &quot;covers&quot;:</span>
<span class="w"> </span>            return self.rrset.covers
<span class="gd">-        elif attr == &#39;rdclass&#39;:</span>
<span class="gi">+        elif attr == &quot;rdclass&quot;:</span>
<span class="w"> </span>            return self.rrset.rdclass
<span class="gd">-        elif attr == &#39;rdtype&#39;:</span>
<span class="gi">+        elif attr == &quot;rdtype&quot;:</span>
<span class="w"> </span>            return self.rrset.rdtype
<span class="w"> </span>        else:
<span class="w"> </span>            raise AttributeError(attr)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self.rrset and len(self.rrset) or 0

<span class="w"> </span>    def __iter__(self):
<span class="gu">@@ -227,64 +320,127 @@ class HostAnswers(Answers):</span>
<span class="w"> </span>    type.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def make(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        v6: Optional[Answer] = None,</span>
<span class="gi">+        v4: Optional[Answer] = None,</span>
<span class="gi">+        add_empty: bool = True,</span>
<span class="gi">+    ) -&gt; &quot;HostAnswers&quot;:</span>
<span class="gi">+        answers = HostAnswers()</span>
<span class="gi">+        if v6 is not None and (add_empty or v6.rrset):</span>
<span class="gi">+            answers[dns.rdatatype.AAAA] = v6</span>
<span class="gi">+        if v4 is not None and (add_empty or v4.rrset):</span>
<span class="gi">+            answers[dns.rdatatype.A] = v4</span>
<span class="gi">+        return answers</span>
<span class="gi">+</span>
<span class="gi">+    # Returns pairs of (address, family) from this result, potentiallys</span>
<span class="gi">+    # filtering by address family.</span>
<span class="gi">+    def addresses_and_families(</span>
<span class="gi">+        self, family: int = socket.AF_UNSPEC</span>
<span class="gi">+    ) -&gt; Iterator[Tuple[str, int]]:</span>
<span class="gi">+        if family == socket.AF_UNSPEC:</span>
<span class="gi">+            yield from self.addresses_and_families(socket.AF_INET6)</span>
<span class="gi">+            yield from self.addresses_and_families(socket.AF_INET)</span>
<span class="gi">+            return</span>
<span class="gi">+        elif family == socket.AF_INET6:</span>
<span class="gi">+            answer = self.get(dns.rdatatype.AAAA)</span>
<span class="gi">+        elif family == socket.AF_INET:</span>
<span class="gi">+            answer = self.get(dns.rdatatype.A)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;unknown address family {family}&quot;)</span>
<span class="gi">+        if answer:</span>
<span class="gi">+            for rdata in answer:</span>
<span class="gi">+                yield (rdata.address, family)</span>
<span class="gi">+</span>
<span class="gi">+    # Returns addresses from this result, potentially filtering by</span>
<span class="gi">+    # address family.</span>
<span class="gi">+    def addresses(self, family: int = socket.AF_UNSPEC) -&gt; Iterator[str]:</span>
<span class="gi">+        return (pair[0] for pair in self.addresses_and_families(family))</span>
<span class="gi">+</span>
<span class="gi">+    # Returns the canonical name from this result.</span>
<span class="gi">+    def canonical_name(self) -&gt; dns.name.Name:</span>
<span class="gi">+        answer = self.get(dns.rdatatype.AAAA, self.get(dns.rdatatype.A))</span>
<span class="gi">+        return answer.canonical_name</span>
<span class="gi">+</span>

<span class="w"> </span>class CacheStatistics:
<span class="w"> </span>    &quot;&quot;&quot;Cache Statistics&quot;&quot;&quot;

<span class="gd">-    def __init__(self, hits: int=0, misses: int=0) -&gt;None:</span>
<span class="gi">+    def __init__(self, hits: int = 0, misses: int = 0) -&gt; None:</span>
<span class="w"> </span>        self.hits = hits
<span class="w"> </span>        self.misses = misses

<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.hits = 0</span>
<span class="gi">+        self.misses = 0</span>
<span class="gi">+</span>
<span class="gi">+    def clone(self) -&gt; &quot;CacheStatistics&quot;:</span>
<span class="gi">+        return CacheStatistics(self.hits, self.misses)</span>

<span class="gd">-class CacheBase:</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+class CacheBase:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.lock = threading.Lock()
<span class="w"> </span>        self.statistics = CacheStatistics()

<span class="gd">-    def reset_statistics(self) -&gt;None:</span>
<span class="gi">+    def reset_statistics(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset all statistics to zero.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self.statistics.reset()</span>

<span class="gd">-    def hits(self) -&gt;int:</span>
<span class="gi">+    def hits(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;How many hits has the cache had?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            return self.statistics.hits</span>

<span class="gd">-    def misses(self) -&gt;int:</span>
<span class="gi">+    def misses(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;How many misses has the cache had?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            return self.statistics.misses</span>

<span class="gd">-    def get_statistics_snapshot(self) -&gt;CacheStatistics:</span>
<span class="gi">+    def get_statistics_snapshot(self) -&gt; CacheStatistics:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a consistent snapshot of all the statistics.

<span class="w"> </span>        If running with multiple threads, it&#39;s better to take a
<span class="w"> </span>        snapshot than to call statistics methods such as hits() and
<span class="w"> </span>        misses() individually.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            return self.statistics.clone()</span>


<span class="gd">-CacheKey = Tuple[dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.</span>
<span class="gd">-    RdataClass]</span>
<span class="gi">+CacheKey = Tuple[dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass]</span>


<span class="w"> </span>class Cache(CacheBase):
<span class="w"> </span>    &quot;&quot;&quot;Simple thread-safe DNS answer cache.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, cleaning_interval: float=300.0) -&gt;None:</span>
<span class="gi">+    def __init__(self, cleaning_interval: float = 300.0) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;*cleaning_interval*, a ``float`` is the number of seconds between
<span class="w"> </span>        periodic cleanings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.data: Dict[CacheKey, Answer] = {}
<span class="w"> </span>        self.cleaning_interval = cleaning_interval
<span class="w"> </span>        self.next_cleaning: float = time.time() + self.cleaning_interval

<span class="gd">-    def _maybe_clean(self) -&gt;None:</span>
<span class="gi">+    def _maybe_clean(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clean the cache if it&#39;s time to do so.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get(self, key: CacheKey) -&gt;Optional[Answer]:</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        if self.next_cleaning &lt;= now:</span>
<span class="gi">+            keys_to_delete = []</span>
<span class="gi">+            for k, v in self.data.items():</span>
<span class="gi">+                if v.expiration &lt;= now:</span>
<span class="gi">+                    keys_to_delete.append(k)</span>
<span class="gi">+            for k in keys_to_delete:</span>
<span class="gi">+                del self.data[k]</span>
<span class="gi">+            now = time.time()</span>
<span class="gi">+            self.next_cleaning = now + self.cleaning_interval</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key: CacheKey) -&gt; Optional[Answer]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the answer associated with *key*.

<span class="w"> </span>        Returns None if no answer is cached for the key.
<span class="gu">@@ -294,9 +450,17 @@ class Cache(CacheBase):</span>

<span class="w"> </span>        Returns a ``dns.resolver.Answer`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def put(self, key: CacheKey, value: Answer) -&gt;None:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self._maybe_clean()</span>
<span class="gi">+            v = self.data.get(key)</span>
<span class="gi">+            if v is None or v.expiration &lt;= time.time():</span>
<span class="gi">+                self.statistics.misses += 1</span>
<span class="gi">+                return None</span>
<span class="gi">+            self.statistics.hits += 1</span>
<span class="gi">+            return v</span>
<span class="gi">+</span>
<span class="gi">+    def put(self, key: CacheKey, value: Answer) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Associate key and value in the cache.

<span class="w"> </span>        *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
<span class="gu">@@ -304,9 +468,12 @@ class Cache(CacheBase):</span>

<span class="w"> </span>        *value*, a ``dns.resolver.Answer``, the answer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def flush(self, key: Optional[CacheKey]=None) -&gt;None:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self._maybe_clean()</span>
<span class="gi">+            self.data[key] = value</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self, key: Optional[CacheKey] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Flush the cache.

<span class="w"> </span>        If *key* is not ``None``, only that item is flushed.  Otherwise the entire cache
<span class="gu">@@ -315,7 +482,14 @@ class Cache(CacheBase):</span>
<span class="w"> </span>        *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
<span class="w"> </span>        tuple whose values are the query name, rdtype, and rdclass respectively.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if key is not None:</span>
<span class="gi">+                if key in self.data:</span>
<span class="gi">+                    del self.data[key]</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.data = {}</span>
<span class="gi">+                self.next_cleaning = time.time() + self.cleaning_interval</span>


<span class="w"> </span>class LRUCacheNode:
<span class="gu">@@ -328,6 +502,16 @@ class LRUCacheNode:</span>
<span class="w"> </span>        self.prev = self
<span class="w"> </span>        self.next = self

<span class="gi">+    def link_after(self, node: &quot;LRUCacheNode&quot;) -&gt; None:</span>
<span class="gi">+        self.prev = node</span>
<span class="gi">+        self.next = node.next</span>
<span class="gi">+        node.next.prev = self</span>
<span class="gi">+        node.next = self</span>
<span class="gi">+</span>
<span class="gi">+    def unlink(self) -&gt; None:</span>
<span class="gi">+        self.next.prev = self.prev</span>
<span class="gi">+        self.prev.next = self.next</span>
<span class="gi">+</span>

<span class="w"> </span>class LRUCache(CacheBase):
<span class="w"> </span>    &quot;&quot;&quot;Thread-safe, bounded, least-recently-used DNS answer cache.
<span class="gu">@@ -339,10 +523,11 @@ class LRUCache(CacheBase):</span>
<span class="w"> </span>    for a new one.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, max_size: int=100000) -&gt;None:</span>
<span class="gi">+    def __init__(self, max_size: int = 100000) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;*max_size*, an ``int``, is the maximum number of nodes to cache;
<span class="w"> </span>        it must be greater than 0.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.data: Dict[CacheKey, LRUCacheNode] = {}
<span class="w"> </span>        self.set_max_size(max_size)
<span class="gu">@@ -350,7 +535,12 @@ class LRUCache(CacheBase):</span>
<span class="w"> </span>        self.sentinel.prev = self.sentinel
<span class="w"> </span>        self.sentinel.next = self.sentinel

<span class="gd">-    def get(self, key: CacheKey) -&gt;Optional[Answer]:</span>
<span class="gi">+    def set_max_size(self, max_size: int) -&gt; None:</span>
<span class="gi">+        if max_size &lt; 1:</span>
<span class="gi">+            max_size = 1</span>
<span class="gi">+        self.max_size = max_size</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key: CacheKey) -&gt; Optional[Answer]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the answer associated with *key*.

<span class="w"> </span>        Returns None if no answer is cached for the key.
<span class="gu">@@ -360,13 +550,34 @@ class LRUCache(CacheBase):</span>

<span class="w"> </span>        Returns a ``dns.resolver.Answer`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_hits_for_key(self, key: CacheKey) -&gt;int:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            node = self.data.get(key)</span>
<span class="gi">+            if node is None:</span>
<span class="gi">+                self.statistics.misses += 1</span>
<span class="gi">+                return None</span>
<span class="gi">+            # Unlink because we&#39;re either going to move the node to the front</span>
<span class="gi">+            # of the LRU list or we&#39;re going to free it.</span>
<span class="gi">+            node.unlink()</span>
<span class="gi">+            if node.value.expiration &lt;= time.time():</span>
<span class="gi">+                del self.data[node.key]</span>
<span class="gi">+                self.statistics.misses += 1</span>
<span class="gi">+                return None</span>
<span class="gi">+            node.link_after(self.sentinel)</span>
<span class="gi">+            self.statistics.hits += 1</span>
<span class="gi">+            node.hits += 1</span>
<span class="gi">+            return node.value</span>
<span class="gi">+</span>
<span class="gi">+    def get_hits_for_key(self, key: CacheKey) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the number of cache hits associated with the specified key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def put(self, key: CacheKey, value: Answer) -&gt;None:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            node = self.data.get(key)</span>
<span class="gi">+            if node is None or node.value.expiration &lt;= time.time():</span>
<span class="gi">+                return 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                return node.hits</span>
<span class="gi">+</span>
<span class="gi">+    def put(self, key: CacheKey, value: Answer) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Associate key and value in the cache.

<span class="w"> </span>        *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
<span class="gu">@@ -374,9 +585,21 @@ class LRUCache(CacheBase):</span>

<span class="w"> </span>        *value*, a ``dns.resolver.Answer``, the answer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def flush(self, key: Optional[CacheKey]=None) -&gt;None:</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            node = self.data.get(key)</span>
<span class="gi">+            if node is not None:</span>
<span class="gi">+                node.unlink()</span>
<span class="gi">+                del self.data[node.key]</span>
<span class="gi">+            while len(self.data) &gt;= self.max_size:</span>
<span class="gi">+                gnode = self.sentinel.prev</span>
<span class="gi">+                gnode.unlink()</span>
<span class="gi">+                del self.data[gnode.key]</span>
<span class="gi">+            node = LRUCacheNode(key, value)</span>
<span class="gi">+            node.link_after(self.sentinel)</span>
<span class="gi">+            self.data[key] = node</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self, key: Optional[CacheKey] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Flush the cache.

<span class="w"> </span>        If *key* is not ``None``, only that item is flushed.  Otherwise the entire cache
<span class="gu">@@ -385,7 +608,20 @@ class LRUCache(CacheBase):</span>
<span class="w"> </span>        *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
<span class="w"> </span>        tuple whose values are the query name, rdtype, and rdclass respectively.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if key is not None:</span>
<span class="gi">+                node = self.data.get(key)</span>
<span class="gi">+                if node is not None:</span>
<span class="gi">+                    node.unlink()</span>
<span class="gi">+                    del self.data[node.key]</span>
<span class="gi">+            else:</span>
<span class="gi">+                gnode = self.sentinel.next</span>
<span class="gi">+                while gnode != self.sentinel:</span>
<span class="gi">+                    next = gnode.next</span>
<span class="gi">+                    gnode.unlink()</span>
<span class="gi">+                    gnode = next</span>
<span class="gi">+                self.data = {}</span>


<span class="w"> </span>class _Resolution:
<span class="gu">@@ -400,10 +636,16 @@ class _Resolution:</span>
<span class="w"> </span>    resolver data structures directly.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, resolver: &#39;BaseResolver&#39;, qname: Union[dns.name.Name,</span>
<span class="gd">-        str], rdtype: Union[dns.rdatatype.RdataType, str], rdclass: Union[</span>
<span class="gd">-        dns.rdataclass.RdataClass, str], tcp: bool, raise_on_no_answer:</span>
<span class="gd">-        bool, search: Optional[bool]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        resolver: &quot;BaseResolver&quot;,</span>
<span class="gi">+        qname: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+        tcp: bool,</span>
<span class="gi">+        raise_on_no_answer: bool,</span>
<span class="gi">+        search: Optional[bool],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if isinstance(qname, str):
<span class="w"> </span>            qname = dns.name.from_text(qname, None)
<span class="w"> </span>        rdtype = dns.rdatatype.RdataType.make(rdtype)
<span class="gu">@@ -419,8 +661,8 @@ class _Resolution:</span>
<span class="w"> </span>        self.rdclass = rdclass
<span class="w"> </span>        self.tcp = tcp
<span class="w"> </span>        self.raise_on_no_answer = raise_on_no_answer
<span class="gd">-        self.nxdomain_responses: Dict[dns.name.Name, dns.message.QueryMessage</span>
<span class="gd">-            ] = {}</span>
<span class="gi">+        self.nxdomain_responses: Dict[dns.name.Name, dns.message.QueryMessage] = {}</span>
<span class="gi">+        # Initialize other things to help analysis tools</span>
<span class="w"> </span>        self.qname = dns.name.empty
<span class="w"> </span>        self.nameservers: List[dns.nameserver.Nameserver] = []
<span class="w"> </span>        self.current_nameservers: List[dns.nameserver.Nameserver] = []
<span class="gu">@@ -431,18 +673,234 @@ class _Resolution:</span>
<span class="w"> </span>        self.request: Optional[dns.message.QueryMessage] = None
<span class="w"> </span>        self.backoff = 0.0

<span class="gd">-    def next_request(self) -&gt;Tuple[Optional[dns.message.QueryMessage],</span>
<span class="gd">-        Optional[Answer]]:</span>
<span class="gi">+    def next_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Tuple[Optional[dns.message.QueryMessage], Optional[Answer]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the next request to send, and check the cache.

<span class="w"> </span>        Returns a (request, answer) tuple.  At most one of request or
<span class="w"> </span>        answer will not be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # We return a tuple instead of Union[Message,Answer] as it lets</span>
<span class="gi">+        # the caller avoid isinstance().</span>
<span class="gi">+</span>
<span class="gi">+        while len(self.qnames) &gt; 0:</span>
<span class="gi">+            self.qname = self.qnames.pop(0)</span>
<span class="gi">+</span>
<span class="gi">+            # Do we know the answer?</span>
<span class="gi">+            if self.resolver.cache:</span>
<span class="gi">+                answer = self.resolver.cache.get(</span>
<span class="gi">+                    (self.qname, self.rdtype, self.rdclass)</span>
<span class="gi">+                )</span>
<span class="gi">+                if answer is not None:</span>
<span class="gi">+                    if answer.rrset is None and self.raise_on_no_answer:</span>
<span class="gi">+                        raise NoAnswer(response=answer.response)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        return (None, answer)</span>
<span class="gi">+                answer = self.resolver.cache.get(</span>
<span class="gi">+                    (self.qname, dns.rdatatype.ANY, self.rdclass)</span>
<span class="gi">+                )</span>
<span class="gi">+                if answer is not None and answer.response.rcode() == dns.rcode.NXDOMAIN:</span>
<span class="gi">+                    # cached NXDOMAIN; record it and continue to next</span>
<span class="gi">+                    # name.</span>
<span class="gi">+                    self.nxdomain_responses[self.qname] = answer.response</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            # Build the request</span>
<span class="gi">+            request = dns.message.make_query(self.qname, self.rdtype, self.rdclass)</span>
<span class="gi">+            if self.resolver.keyname is not None:</span>
<span class="gi">+                request.use_tsig(</span>
<span class="gi">+                    self.resolver.keyring,</span>
<span class="gi">+                    self.resolver.keyname,</span>
<span class="gi">+                    algorithm=self.resolver.keyalgorithm,</span>
<span class="gi">+                )</span>
<span class="gi">+            request.use_edns(</span>
<span class="gi">+                self.resolver.edns,</span>
<span class="gi">+                self.resolver.ednsflags,</span>
<span class="gi">+                self.resolver.payload,</span>
<span class="gi">+                options=self.resolver.ednsoptions,</span>
<span class="gi">+            )</span>
<span class="gi">+            if self.resolver.flags is not None:</span>
<span class="gi">+                request.flags = self.resolver.flags</span>
<span class="gi">+</span>
<span class="gi">+            self.nameservers = self.resolver._enrich_nameservers(</span>
<span class="gi">+                self.resolver._nameservers,</span>
<span class="gi">+                self.resolver.nameserver_ports,</span>
<span class="gi">+                self.resolver.port,</span>
<span class="gi">+            )</span>
<span class="gi">+            if self.resolver.rotate:</span>
<span class="gi">+                random.shuffle(self.nameservers)</span>
<span class="gi">+            self.current_nameservers = self.nameservers[:]</span>
<span class="gi">+            self.errors = []</span>
<span class="gi">+            self.nameserver = None</span>
<span class="gi">+            self.tcp_attempt = False</span>
<span class="gi">+            self.retry_with_tcp = False</span>
<span class="gi">+            self.request = request</span>
<span class="gi">+            self.backoff = 0.10</span>
<span class="gi">+</span>
<span class="gi">+            return (request, None)</span>
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="gi">+        # We&#39;ve tried everything and only gotten NXDOMAINs.  (We know</span>
<span class="gi">+        # it&#39;s only NXDOMAINs as anything else would have returned</span>
<span class="gi">+        # before now.)</span>
<span class="gi">+        #</span>
<span class="gi">+        raise NXDOMAIN(qnames=self.qnames_to_try, responses=self.nxdomain_responses)</span>
<span class="gi">+</span>
<span class="gi">+    def next_nameserver(self) -&gt; Tuple[dns.nameserver.Nameserver, bool, float]:</span>
<span class="gi">+        if self.retry_with_tcp:</span>
<span class="gi">+            assert self.nameserver is not None</span>
<span class="gi">+            assert not self.nameserver.is_always_max_size()</span>
<span class="gi">+            self.tcp_attempt = True</span>
<span class="gi">+            self.retry_with_tcp = False</span>
<span class="gi">+            return (self.nameserver, True, 0)</span>
<span class="gi">+</span>
<span class="gi">+        backoff = 0.0</span>
<span class="gi">+        if not self.current_nameservers:</span>
<span class="gi">+            if len(self.nameservers) == 0:</span>
<span class="gi">+                # Out of things to try!</span>
<span class="gi">+                raise NoNameservers(request=self.request, errors=self.errors)</span>
<span class="gi">+            self.current_nameservers = self.nameservers[:]</span>
<span class="gi">+            backoff = self.backoff</span>
<span class="gi">+            self.backoff = min(self.backoff * 2, 2)</span>
<span class="gi">+</span>
<span class="gi">+        self.nameserver = self.current_nameservers.pop(0)</span>
<span class="gi">+        self.tcp_attempt = self.tcp or self.nameserver.is_always_max_size()</span>
<span class="gi">+        return (self.nameserver, self.tcp_attempt, backoff)</span>
<span class="gi">+</span>
<span class="gi">+    def query_result(</span>
<span class="gi">+        self, response: Optional[dns.message.Message], ex: Optional[Exception]</span>
<span class="gi">+    ) -&gt; Tuple[Optional[Answer], bool]:</span>
<span class="gi">+        #</span>
<span class="gi">+        # returns an (answer: Answer, end_loop: bool) tuple.</span>
<span class="gi">+        #</span>
<span class="gi">+        assert self.nameserver is not None</span>
<span class="gi">+        if ex:</span>
<span class="gi">+            # Exception during I/O or from_wire()</span>
<span class="gi">+            assert response is None</span>
<span class="gi">+            self.errors.append(</span>
<span class="gi">+                (</span>
<span class="gi">+                    str(self.nameserver),</span>
<span class="gi">+                    self.tcp_attempt,</span>
<span class="gi">+                    self.nameserver.answer_port(),</span>
<span class="gi">+                    ex,</span>
<span class="gi">+                    response,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(ex, dns.exception.FormError)</span>
<span class="gi">+                or isinstance(ex, EOFError)</span>
<span class="gi">+                or isinstance(ex, OSError)</span>
<span class="gi">+                or isinstance(ex, NotImplementedError)</span>
<span class="gi">+            ):</span>
<span class="gi">+                # This nameserver is no good, take it out of the mix.</span>
<span class="gi">+                self.nameservers.remove(self.nameserver)</span>
<span class="gi">+            elif isinstance(ex, dns.message.Truncated):</span>
<span class="gi">+                if self.tcp_attempt:</span>
<span class="gi">+                    # Truncation with TCP is no good!</span>
<span class="gi">+                    self.nameservers.remove(self.nameserver)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.retry_with_tcp = True</span>
<span class="gi">+            return (None, False)</span>
<span class="gi">+        # We got an answer!</span>
<span class="gi">+        assert response is not None</span>
<span class="gi">+        assert isinstance(response, dns.message.QueryMessage)</span>
<span class="gi">+        rcode = response.rcode()</span>
<span class="gi">+        if rcode == dns.rcode.NOERROR:</span>
<span class="gi">+            try:</span>
<span class="gi">+                answer = Answer(</span>
<span class="gi">+                    self.qname,</span>
<span class="gi">+                    self.rdtype,</span>
<span class="gi">+                    self.rdclass,</span>
<span class="gi">+                    response,</span>
<span class="gi">+                    self.nameserver.answer_nameserver(),</span>
<span class="gi">+                    self.nameserver.answer_port(),</span>
<span class="gi">+                )</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self.errors.append(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        str(self.nameserver),</span>
<span class="gi">+                        self.tcp_attempt,</span>
<span class="gi">+                        self.nameserver.answer_port(),</span>
<span class="gi">+                        e,</span>
<span class="gi">+                        response,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                # The nameserver is no good, take it out of the mix.</span>
<span class="gi">+                self.nameservers.remove(self.nameserver)</span>
<span class="gi">+                return (None, False)</span>
<span class="gi">+            if self.resolver.cache:</span>
<span class="gi">+                self.resolver.cache.put((self.qname, self.rdtype, self.rdclass), answer)</span>
<span class="gi">+            if answer.rrset is None and self.raise_on_no_answer:</span>
<span class="gi">+                raise NoAnswer(response=answer.response)</span>
<span class="gi">+            return (answer, True)</span>
<span class="gi">+        elif rcode == dns.rcode.NXDOMAIN:</span>
<span class="gi">+            # Further validate the response by making an Answer, even</span>
<span class="gi">+            # if we aren&#39;t going to cache it.</span>
<span class="gi">+            try:</span>
<span class="gi">+                answer = Answer(</span>
<span class="gi">+                    self.qname, dns.rdatatype.ANY, dns.rdataclass.IN, response</span>
<span class="gi">+                )</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self.errors.append(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        str(self.nameserver),</span>
<span class="gi">+                        self.tcp_attempt,</span>
<span class="gi">+                        self.nameserver.answer_port(),</span>
<span class="gi">+                        e,</span>
<span class="gi">+                        response,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                # The nameserver is no good, take it out of the mix.</span>
<span class="gi">+                self.nameservers.remove(self.nameserver)</span>
<span class="gi">+                return (None, False)</span>
<span class="gi">+            self.nxdomain_responses[self.qname] = response</span>
<span class="gi">+            if self.resolver.cache:</span>
<span class="gi">+                self.resolver.cache.put(</span>
<span class="gi">+                    (self.qname, dns.rdatatype.ANY, self.rdclass), answer</span>
<span class="gi">+                )</span>
<span class="gi">+            # Make next_nameserver() return None, so caller breaks its</span>
<span class="gi">+            # inner loop and calls next_request().</span>
<span class="gi">+            return (None, True)</span>
<span class="gi">+        elif rcode == dns.rcode.YXDOMAIN:</span>
<span class="gi">+            yex = YXDOMAIN()</span>
<span class="gi">+            self.errors.append(</span>
<span class="gi">+                (</span>
<span class="gi">+                    str(self.nameserver),</span>
<span class="gi">+                    self.tcp_attempt,</span>
<span class="gi">+                    self.nameserver.answer_port(),</span>
<span class="gi">+                    yex,</span>
<span class="gi">+                    response,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            raise yex</span>
<span class="gi">+        else:</span>
<span class="gi">+            #</span>
<span class="gi">+            # We got a response, but we&#39;re not happy with the</span>
<span class="gi">+            # rcode in it.</span>
<span class="gi">+            #</span>
<span class="gi">+            if rcode != dns.rcode.SERVFAIL or not self.resolver.retry_servfail:</span>
<span class="gi">+                self.nameservers.remove(self.nameserver)</span>
<span class="gi">+            self.errors.append(</span>
<span class="gi">+                (</span>
<span class="gi">+                    str(self.nameserver),</span>
<span class="gi">+                    self.tcp_attempt,</span>
<span class="gi">+                    self.nameserver.answer_port(),</span>
<span class="gi">+                    dns.rcode.to_text(rcode),</span>
<span class="gi">+                    response,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            return (None, False)</span>


<span class="w"> </span>class BaseResolver:
<span class="w"> </span>    &quot;&quot;&quot;DNS stub resolver.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # We initialize in reset()</span>
<span class="gi">+    #</span>
<span class="gi">+    # pylint: disable=attribute-defined-outside-init</span>
<span class="gi">+</span>
<span class="w"> </span>    domain: dns.name.Name
<span class="w"> </span>    nameserver_ports: Dict[str, int]
<span class="w"> </span>    port: int
<span class="gu">@@ -464,8 +922,9 @@ class BaseResolver:</span>
<span class="w"> </span>    ndots: Optional[int]
<span class="w"> </span>    _nameservers: Sequence[Union[str, dns.nameserver.Nameserver]]

<span class="gd">-    def __init__(self, filename: str=&#39;/etc/resolv.conf&#39;, configure: bool=True</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, filename: str = &quot;/etc/resolv.conf&quot;, configure: bool = True</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;*filename*, a ``str`` or file object, specifying a file
<span class="w"> </span>        in standard /etc/resolv.conf format.  This parameter is meaningful
<span class="w"> </span>        only when *configure* is true and the platform is POSIX.
<span class="gu">@@ -476,18 +935,41 @@ class BaseResolver:</span>
<span class="w"> </span>        /etc/resolv.conf file on POSIX systems and from the registry
<span class="w"> </span>        on Windows systems.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.reset()
<span class="w"> </span>        if configure:
<span class="gd">-            if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+            if sys.platform == &quot;win32&quot;:</span>
<span class="w"> </span>                self.read_registry()
<span class="w"> </span>            elif filename:
<span class="w"> </span>                self.read_resolv_conf(filename)

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset all resolver configuration to the defaults.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def read_resolv_conf(self, f: Any) -&gt;None:</span>
<span class="gi">+        self.domain = dns.name.Name(dns.name.from_text(socket.gethostname())[1:])</span>
<span class="gi">+        if len(self.domain) == 0:</span>
<span class="gi">+            self.domain = dns.name.root</span>
<span class="gi">+        self._nameservers = []</span>
<span class="gi">+        self.nameserver_ports = {}</span>
<span class="gi">+        self.port = 53</span>
<span class="gi">+        self.search = []</span>
<span class="gi">+        self.use_search_by_default = False</span>
<span class="gi">+        self.timeout = 2.0</span>
<span class="gi">+        self.lifetime = 5.0</span>
<span class="gi">+        self.keyring = None</span>
<span class="gi">+        self.keyname = None</span>
<span class="gi">+        self.keyalgorithm = dns.tsig.default_algorithm</span>
<span class="gi">+        self.edns = -1</span>
<span class="gi">+        self.ednsflags = 0</span>
<span class="gi">+        self.ednsoptions = None</span>
<span class="gi">+        self.payload = 0</span>
<span class="gi">+        self.cache = None</span>
<span class="gi">+        self.flags = None</span>
<span class="gi">+        self.retry_servfail = False</span>
<span class="gi">+        self.rotate = False</span>
<span class="gi">+        self.ndots = None</span>
<span class="gi">+</span>
<span class="gi">+    def read_resolv_conf(self, f: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process *f* as a file in the /etc/resolv.conf format.  If f is
<span class="w"> </span>        a ``str``, it is used as the name of the file to open; otherwise it
<span class="w"> </span>        is treated as the file itself.
<span class="gu">@@ -503,25 +985,160 @@ class BaseResolver:</span>
<span class="w"> </span>        - options - supported options are rotate, timeout, edns0, and ndots

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def read_registry(self) -&gt;None:</span>
<span class="gi">+        nameservers = []</span>
<span class="gi">+        if isinstance(f, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                cm: contextlib.AbstractContextManager = open(f)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # /etc/resolv.conf doesn&#39;t exist, can&#39;t be read, etc.</span>
<span class="gi">+                raise NoResolverConfiguration(f&quot;cannot open {f}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cm = contextlib.nullcontext(f)</span>
<span class="gi">+        with cm as f:</span>
<span class="gi">+            for l in f:</span>
<span class="gi">+                if len(l) == 0 or l[0] == &quot;#&quot; or l[0] == &quot;;&quot;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                tokens = l.split()</span>
<span class="gi">+</span>
<span class="gi">+                # Any line containing less than 2 tokens is malformed</span>
<span class="gi">+                if len(tokens) &lt; 2:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if tokens[0] == &quot;nameserver&quot;:</span>
<span class="gi">+                    nameservers.append(tokens[1])</span>
<span class="gi">+                elif tokens[0] == &quot;domain&quot;:</span>
<span class="gi">+                    self.domain = dns.name.from_text(tokens[1])</span>
<span class="gi">+                    # domain and search are exclusive</span>
<span class="gi">+                    self.search = []</span>
<span class="gi">+                elif tokens[0] == &quot;search&quot;:</span>
<span class="gi">+                    # the last search wins</span>
<span class="gi">+                    self.search = []</span>
<span class="gi">+                    for suffix in tokens[1:]:</span>
<span class="gi">+                        self.search.append(dns.name.from_text(suffix))</span>
<span class="gi">+                    # We don&#39;t set domain as it is not used if</span>
<span class="gi">+                    # len(self.search) &gt; 0</span>
<span class="gi">+                elif tokens[0] == &quot;options&quot;:</span>
<span class="gi">+                    for opt in tokens[1:]:</span>
<span class="gi">+                        if opt == &quot;rotate&quot;:</span>
<span class="gi">+                            self.rotate = True</span>
<span class="gi">+                        elif opt == &quot;edns0&quot;:</span>
<span class="gi">+                            self.use_edns()</span>
<span class="gi">+                        elif &quot;timeout&quot; in opt:</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                self.timeout = int(opt.split(&quot;:&quot;)[1])</span>
<span class="gi">+                            except (ValueError, IndexError):</span>
<span class="gi">+                                pass</span>
<span class="gi">+                        elif &quot;ndots&quot; in opt:</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                self.ndots = int(opt.split(&quot;:&quot;)[1])</span>
<span class="gi">+                            except (ValueError, IndexError):</span>
<span class="gi">+                                pass</span>
<span class="gi">+        if len(nameservers) == 0:</span>
<span class="gi">+            raise NoResolverConfiguration(&quot;no nameservers&quot;)</span>
<span class="gi">+        # Assigning directly instead of appending means we invoke the</span>
<span class="gi">+        # setter logic, with additonal checking and enrichment.</span>
<span class="gi">+        self.nameservers = nameservers</span>
<span class="gi">+</span>
<span class="gi">+    def read_registry(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract resolver configuration from the Windows registry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def use_tsig(self, keyring: Any, keyname: Optional[Union[dns.name.Name,</span>
<span class="gd">-        str]]=None, algorithm: Union[dns.name.Name, str]=dns.tsig.</span>
<span class="gd">-        default_algorithm) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            info = dns.win32util.get_dns_info()  # type: ignore</span>
<span class="gi">+            if info.domain is not None:</span>
<span class="gi">+                self.domain = info.domain</span>
<span class="gi">+            self.nameservers = info.nameservers</span>
<span class="gi">+            self.search = info.search</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def _compute_timeout(</span>
<span class="gi">+        self,</span>
<span class="gi">+        start: float,</span>
<span class="gi">+        lifetime: Optional[float] = None,</span>
<span class="gi">+        errors: Optional[List[ErrorTuple]] = None,</span>
<span class="gi">+    ) -&gt; float:</span>
<span class="gi">+        lifetime = self.lifetime if lifetime is None else lifetime</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        duration = now - start</span>
<span class="gi">+        if errors is None:</span>
<span class="gi">+            errors = []</span>
<span class="gi">+        if duration &lt; 0:</span>
<span class="gi">+            if duration &lt; -1:</span>
<span class="gi">+                # Time going backwards is bad.  Just give up.</span>
<span class="gi">+                raise LifetimeTimeout(timeout=duration, errors=errors)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Time went backwards, but only a little.  This can</span>
<span class="gi">+                # happen, e.g. under vmware with older linux kernels.</span>
<span class="gi">+                # Pretend it didn&#39;t happen.</span>
<span class="gi">+                duration = 0</span>
<span class="gi">+        if duration &gt;= lifetime:</span>
<span class="gi">+            raise LifetimeTimeout(timeout=duration, errors=errors)</span>
<span class="gi">+        return min(lifetime - duration, self.timeout)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_qnames_to_try(</span>
<span class="gi">+        self, qname: dns.name.Name, search: Optional[bool]</span>
<span class="gi">+    ) -&gt; List[dns.name.Name]:</span>
<span class="gi">+        # This is a separate method so we can unit test the search</span>
<span class="gi">+        # rules without requiring the Internet.</span>
<span class="gi">+        if search is None:</span>
<span class="gi">+            search = self.use_search_by_default</span>
<span class="gi">+        qnames_to_try = []</span>
<span class="gi">+        if qname.is_absolute():</span>
<span class="gi">+            qnames_to_try.append(qname)</span>
<span class="gi">+        else:</span>
<span class="gi">+            abs_qname = qname.concatenate(dns.name.root)</span>
<span class="gi">+            if search:</span>
<span class="gi">+                if len(self.search) &gt; 0:</span>
<span class="gi">+                    # There is a search list, so use it exclusively</span>
<span class="gi">+                    search_list = self.search[:]</span>
<span class="gi">+                elif self.domain != dns.name.root and self.domain is not None:</span>
<span class="gi">+                    # We have some notion of a domain that isn&#39;t the root, so</span>
<span class="gi">+                    # use it as the search list.</span>
<span class="gi">+                    search_list = [self.domain]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    search_list = []</span>
<span class="gi">+                # Figure out the effective ndots (default is 1)</span>
<span class="gi">+                if self.ndots is None:</span>
<span class="gi">+                    ndots = 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ndots = self.ndots</span>
<span class="gi">+                for suffix in search_list:</span>
<span class="gi">+                    qnames_to_try.append(qname + suffix)</span>
<span class="gi">+                if len(qname) &gt; ndots:</span>
<span class="gi">+                    # The name has at least ndots dots, so we should try an</span>
<span class="gi">+                    # absolute query first.</span>
<span class="gi">+                    qnames_to_try.insert(0, abs_qname)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # The name has less than ndots dots, so we should search</span>
<span class="gi">+                    # first, then try the absolute name.</span>
<span class="gi">+                    qnames_to_try.append(abs_qname)</span>
<span class="gi">+            else:</span>
<span class="gi">+                qnames_to_try.append(abs_qname)</span>
<span class="gi">+        return qnames_to_try</span>
<span class="gi">+</span>
<span class="gi">+    def use_tsig(</span>
<span class="gi">+        self,</span>
<span class="gi">+        keyring: Any,</span>
<span class="gi">+        keyname: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+        algorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a TSIG signature to each query.

<span class="w"> </span>        The parameters are passed to ``dns.message.Message.use_tsig()``;
<span class="w"> </span>        see its documentation for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def use_edns(self, edns: Optional[Union[int, bool]]=0, ednsflags: int=0,</span>
<span class="gd">-        payload: int=dns.message.DEFAULT_EDNS_PAYLOAD, options: Optional[</span>
<span class="gd">-        List[dns.edns.Option]]=None) -&gt;None:</span>
<span class="gi">+        self.keyring = keyring</span>
<span class="gi">+        self.keyname = keyname</span>
<span class="gi">+        self.keyalgorithm = algorithm</span>
<span class="gi">+</span>
<span class="gi">+    def use_edns(</span>
<span class="gi">+        self,</span>
<span class="gi">+        edns: Optional[Union[int, bool]] = 0,</span>
<span class="gi">+        ednsflags: int = 0,</span>
<span class="gi">+        payload: int = dns.message.DEFAULT_EDNS_PAYLOAD,</span>
<span class="gi">+        options: Optional[List[dns.edns.Option]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Configure EDNS behavior.

<span class="w"> </span>        *edns*, an ``int``, is the EDNS level to use.  Specifying
<span class="gu">@@ -538,18 +1155,72 @@ class BaseResolver:</span>
<span class="w"> </span>        *options*, a list of ``dns.edns.Option`` objects or ``None``, the EDNS
<span class="w"> </span>        options.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def set_flags(self, flags: int) -&gt;None:</span>
<span class="gi">+        if edns is None or edns is False:</span>
<span class="gi">+            edns = -1</span>
<span class="gi">+        elif edns is True:</span>
<span class="gi">+            edns = 0</span>
<span class="gi">+        self.edns = edns</span>
<span class="gi">+        self.ednsflags = ednsflags</span>
<span class="gi">+        self.payload = payload</span>
<span class="gi">+        self.ednsoptions = options</span>
<span class="gi">+</span>
<span class="gi">+    def set_flags(self, flags: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Overrides the default flags with your own.

<span class="w"> </span>        *flags*, an ``int``, the message flags to use.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.flags = flags</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _enrich_nameservers(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        nameservers: Sequence[Union[str, dns.nameserver.Nameserver]],</span>
<span class="gi">+        nameserver_ports: Dict[str, int],</span>
<span class="gi">+        default_port: int,</span>
<span class="gi">+    ) -&gt; List[dns.nameserver.Nameserver]:</span>
<span class="gi">+        enriched_nameservers = []</span>
<span class="gi">+        if isinstance(nameservers, list):</span>
<span class="gi">+            for nameserver in nameservers:</span>
<span class="gi">+                enriched_nameserver: dns.nameserver.Nameserver</span>
<span class="gi">+                if isinstance(nameserver, dns.nameserver.Nameserver):</span>
<span class="gi">+                    enriched_nameserver = nameserver</span>
<span class="gi">+                elif dns.inet.is_address(nameserver):</span>
<span class="gi">+                    port = nameserver_ports.get(nameserver, default_port)</span>
<span class="gi">+                    enriched_nameserver = dns.nameserver.Do53Nameserver(</span>
<span class="gi">+                        nameserver, port</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        if urlparse(nameserver).scheme != &quot;https&quot;:</span>
<span class="gi">+                            raise NotImplementedError</span>
<span class="gi">+                    except Exception:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            f&quot;nameserver {nameserver} is not a &quot;</span>
<span class="gi">+                            &quot;dns.nameserver.Nameserver instance or text form, &quot;</span>
<span class="gi">+                            &quot;IP address, nor a valid https URL&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    enriched_nameserver = dns.nameserver.DoHNameserver(nameserver)</span>
<span class="gi">+                enriched_nameservers.append(enriched_nameserver)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;nameservers must be a list or tuple (not a {})&quot;.format(</span>
<span class="gi">+                    type(nameservers)</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        return enriched_nameservers</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def nameservers(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Sequence[Union[str, dns.nameserver.Nameserver]]:</span>
<span class="gi">+        return self._nameservers</span>

<span class="w"> </span>    @nameservers.setter
<span class="gd">-    def nameservers(self, nameservers: Sequence[Union[str, dns.nameserver.</span>
<span class="gd">-        Nameserver]]) -&gt;None:</span>
<span class="gi">+    def nameservers(</span>
<span class="gi">+        self, nameservers: Sequence[Union[str, dns.nameserver.Nameserver]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        *nameservers*, a ``list`` of nameservers, where a nameserver is either
<span class="w"> </span>        a string interpretable as a nameserver, or a ``dns.nameserver.Nameserver``
<span class="gu">@@ -557,18 +1228,26 @@ class BaseResolver:</span>

<span class="w"> </span>        Raises ``ValueError`` if *nameservers* is not a list of nameservers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We just call _enrich_nameservers() for checking</span>
<span class="gi">+        self._enrich_nameservers(nameservers, self.nameserver_ports, self.port)</span>
<span class="gi">+        self._nameservers = nameservers</span>


<span class="w"> </span>class Resolver(BaseResolver):
<span class="w"> </span>    &quot;&quot;&quot;DNS stub resolver.&quot;&quot;&quot;

<span class="gd">-    def resolve(self, qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="gd">-        rdatatype.RdataType, str]=dns.rdatatype.A, rdclass: Union[dns.</span>
<span class="gd">-        rdataclass.RdataClass, str]=dns.rdataclass.IN, tcp: bool=False,</span>
<span class="gd">-        source: Optional[str]=None, raise_on_no_answer: bool=True,</span>
<span class="gd">-        source_port: int=0, lifetime: Optional[float]=None, search:</span>
<span class="gd">-        Optional[bool]=None) -&gt;Answer:</span>
<span class="gi">+    def resolve(</span>
<span class="gi">+        self,</span>
<span class="gi">+        qname: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+        rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+        tcp: bool = False,</span>
<span class="gi">+        source: Optional[str] = None,</span>
<span class="gi">+        raise_on_no_answer: bool = True,</span>
<span class="gi">+        source_port: int = 0,</span>
<span class="gi">+        lifetime: Optional[float] = None,</span>
<span class="gi">+        search: Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; Answer:  # pylint: disable=arguments-differ</span>
<span class="w"> </span>        &quot;&quot;&quot;Query nameservers to find the answer to the question.

<span class="w"> </span>        The *qname*, *rdtype*, and *rdclass* parameters may be objects
<span class="gu">@@ -619,13 +1298,57 @@ class Resolver(BaseResolver):</span>
<span class="w"> </span>        Returns a ``dns.resolver.Answer`` instance.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def query(self, qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="gd">-        rdatatype.RdataType, str]=dns.rdatatype.A, rdclass: Union[dns.</span>
<span class="gd">-        rdataclass.RdataClass, str]=dns.rdataclass.IN, tcp: bool=False,</span>
<span class="gd">-        source: Optional[str]=None, raise_on_no_answer: bool=True,</span>
<span class="gd">-        source_port: int=0, lifetime: Optional[float]=None) -&gt;Answer:</span>
<span class="gi">+        resolution = _Resolution(</span>
<span class="gi">+            self, qname, rdtype, rdclass, tcp, raise_on_no_answer, search</span>
<span class="gi">+        )</span>
<span class="gi">+        start = time.time()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            (request, answer) = resolution.next_request()</span>
<span class="gi">+            # Note we need to say &quot;if answer is not None&quot; and not just</span>
<span class="gi">+            # &quot;if answer&quot; because answer implements __len__, and python</span>
<span class="gi">+            # will call that.  We want to return if we have an answer</span>
<span class="gi">+            # object, including in cases where its length is 0.</span>
<span class="gi">+            if answer is not None:</span>
<span class="gi">+                # cache hit!</span>
<span class="gi">+                return answer</span>
<span class="gi">+            assert request is not None  # needed for type checking</span>
<span class="gi">+            done = False</span>
<span class="gi">+            while not done:</span>
<span class="gi">+                (nameserver, tcp, backoff) = resolution.next_nameserver()</span>
<span class="gi">+                if backoff:</span>
<span class="gi">+                    time.sleep(backoff)</span>
<span class="gi">+                timeout = self._compute_timeout(start, lifetime, resolution.errors)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    response = nameserver.query(</span>
<span class="gi">+                        request,</span>
<span class="gi">+                        timeout=timeout,</span>
<span class="gi">+                        source=source,</span>
<span class="gi">+                        source_port=source_port,</span>
<span class="gi">+                        max_size=tcp,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception as ex:</span>
<span class="gi">+                    (_, done) = resolution.query_result(None, ex)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                (answer, done) = resolution.query_result(response, None)</span>
<span class="gi">+                # Note we need to say &quot;if answer is not None&quot; and not just</span>
<span class="gi">+                # &quot;if answer&quot; because answer implements __len__, and python</span>
<span class="gi">+                # will call that.  We want to return if we have an answer</span>
<span class="gi">+                # object, including in cases where its length is 0.</span>
<span class="gi">+                if answer is not None:</span>
<span class="gi">+                    return answer</span>
<span class="gi">+</span>
<span class="gi">+    def query(</span>
<span class="gi">+        self,</span>
<span class="gi">+        qname: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+        rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+        tcp: bool = False,</span>
<span class="gi">+        source: Optional[str] = None,</span>
<span class="gi">+        raise_on_no_answer: bool = True,</span>
<span class="gi">+        source_port: int = 0,</span>
<span class="gi">+        lifetime: Optional[float] = None,</span>
<span class="gi">+    ) -&gt; Answer:  # pragma: no cover</span>
<span class="w"> </span>        &quot;&quot;&quot;Query nameservers to find the answer to the question.

<span class="w"> </span>        This method calls resolve() with ``search=True``, and is
<span class="gu">@@ -633,9 +1356,24 @@ class Resolver(BaseResolver):</span>
<span class="w"> </span>        dnspython.  See the documentation for the resolve() method for
<span class="w"> </span>        further details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def resolve_address(self, ipaddr: str, *args: Any, **kwargs: Any) -&gt;Answer:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;please use dns.resolver.Resolver.resolve() instead&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.resolve(</span>
<span class="gi">+            qname,</span>
<span class="gi">+            rdtype,</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            tcp,</span>
<span class="gi">+            source,</span>
<span class="gi">+            raise_on_no_answer,</span>
<span class="gi">+            source_port,</span>
<span class="gi">+            lifetime,</span>
<span class="gi">+            True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_address(self, ipaddr: str, *args: Any, **kwargs: Any) -&gt; Answer:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use a resolver to run a reverse query for PTR records.

<span class="w"> </span>        This utilizes the resolve() method to perform a PTR lookup on the
<span class="gu">@@ -648,10 +1386,23 @@ class Resolver(BaseResolver):</span>
<span class="w"> </span>        except for rdtype and rdclass are also supported by this
<span class="w"> </span>        function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def resolve_name(self, name: Union[dns.name.Name, str], family: int=</span>
<span class="gd">-        socket.AF_UNSPEC, **kwargs: Any) -&gt;HostAnswers:</span>
<span class="gi">+        # We make a modified kwargs for type checking happiness, as otherwise</span>
<span class="gi">+        # we get a legit warning about possibly having rdtype and rdclass</span>
<span class="gi">+        # in the kwargs more than once.</span>
<span class="gi">+        modified_kwargs: Dict[str, Any] = {}</span>
<span class="gi">+        modified_kwargs.update(kwargs)</span>
<span class="gi">+        modified_kwargs[&quot;rdtype&quot;] = dns.rdatatype.PTR</span>
<span class="gi">+        modified_kwargs[&quot;rdclass&quot;] = dns.rdataclass.IN</span>
<span class="gi">+        return self.resolve(</span>
<span class="gi">+            dns.reversename.from_address(ipaddr), *args, **modified_kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_name(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        family: int = socket.AF_UNSPEC,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; HostAnswers:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use a resolver to query for address records.

<span class="w"> </span>        This utilizes the resolve() method to perform A and/or AAAA lookups on
<span class="gu">@@ -666,9 +1417,54 @@ class Resolver(BaseResolver):</span>
<span class="w"> </span>        except for rdtype and rdclass are also supported by this
<span class="w"> </span>        function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def canonical_name(self, name: Union[dns.name.Name, str]) -&gt;dns.name.Name:</span>
<span class="gi">+        # We make a modified kwargs for type checking happiness, as otherwise</span>
<span class="gi">+        # we get a legit warning about possibly having rdtype and rdclass</span>
<span class="gi">+        # in the kwargs more than once.</span>
<span class="gi">+        modified_kwargs: Dict[str, Any] = {}</span>
<span class="gi">+        modified_kwargs.update(kwargs)</span>
<span class="gi">+        modified_kwargs.pop(&quot;rdtype&quot;, None)</span>
<span class="gi">+        modified_kwargs[&quot;rdclass&quot;] = dns.rdataclass.IN</span>
<span class="gi">+</span>
<span class="gi">+        if family == socket.AF_INET:</span>
<span class="gi">+            v4 = self.resolve(name, dns.rdatatype.A, **modified_kwargs)</span>
<span class="gi">+            return HostAnswers.make(v4=v4)</span>
<span class="gi">+        elif family == socket.AF_INET6:</span>
<span class="gi">+            v6 = self.resolve(name, dns.rdatatype.AAAA, **modified_kwargs)</span>
<span class="gi">+            return HostAnswers.make(v6=v6)</span>
<span class="gi">+        elif family != socket.AF_UNSPEC:</span>
<span class="gi">+            raise NotImplementedError(f&quot;unknown address family {family}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        raise_on_no_answer = modified_kwargs.pop(&quot;raise_on_no_answer&quot;, True)</span>
<span class="gi">+        lifetime = modified_kwargs.pop(&quot;lifetime&quot;, None)</span>
<span class="gi">+        start = time.time()</span>
<span class="gi">+        v6 = self.resolve(</span>
<span class="gi">+            name,</span>
<span class="gi">+            dns.rdatatype.AAAA,</span>
<span class="gi">+            raise_on_no_answer=False,</span>
<span class="gi">+            lifetime=self._compute_timeout(start, lifetime),</span>
<span class="gi">+            **modified_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+        # Note that setting name ensures we query the same name</span>
<span class="gi">+        # for A as we did for AAAA.  (This is just in case search lists</span>
<span class="gi">+        # are active by default in the resolver configuration and</span>
<span class="gi">+        # we might be talking to a server that says NXDOMAIN when it</span>
<span class="gi">+        # wants to say NOERROR no data.</span>
<span class="gi">+        name = v6.qname</span>
<span class="gi">+        v4 = self.resolve(</span>
<span class="gi">+            name,</span>
<span class="gi">+            dns.rdatatype.A,</span>
<span class="gi">+            raise_on_no_answer=False,</span>
<span class="gi">+            lifetime=self._compute_timeout(start, lifetime),</span>
<span class="gi">+            **modified_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+        answers = HostAnswers.make(v6=v6, v4=v4, add_empty=not raise_on_no_answer)</span>
<span class="gi">+        if not answers:</span>
<span class="gi">+            raise NoAnswer(response=v6.response)</span>
<span class="gi">+        return answers</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=redefined-outer-name</span>
<span class="gi">+</span>
<span class="gi">+    def canonical_name(self, name: Union[dns.name.Name, str]) -&gt; dns.name.Name:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determine the canonical name of *name*.

<span class="w"> </span>        The canonical name is the name the resolver uses for queries
<span class="gu">@@ -682,9 +1478,16 @@ class Resolver(BaseResolver):</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            answer = self.resolve(name, raise_on_no_answer=False)</span>
<span class="gi">+            canonical_name = answer.canonical_name</span>
<span class="gi">+        except dns.resolver.NXDOMAIN as e:</span>
<span class="gi">+            canonical_name = e.canonical_name</span>
<span class="gi">+        return canonical_name</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: enable=redefined-outer-name</span>

<span class="gd">-    def try_ddr(self, lifetime: float=5.0) -&gt;None:</span>
<span class="gi">+    def try_ddr(self, lifetime: float = 5.0) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to update the resolver&#39;s nameservers using Discovery of Designated
<span class="w"> </span>        Resolvers (DDR).  If successful, the resolver will subsequently use
<span class="w"> </span>        DNS-over-HTTPS or DNS-over-TLS for future queries.
<span class="gu">@@ -703,31 +1506,53 @@ class Resolver(BaseResolver):</span>
<span class="w"> </span>        the bootstrap nameserver is in the Subject Alternative Name field of the
<span class="w"> </span>        TLS certficate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+        try:</span>
<span class="gi">+            expiration = time.time() + lifetime</span>
<span class="gi">+            answer = self.resolve(</span>
<span class="gi">+                dns._ddr._local_resolver_name, &quot;SVCB&quot;, lifetime=lifetime</span>
<span class="gi">+            )</span>
<span class="gi">+            timeout = dns.query._remaining(expiration)</span>
<span class="gi">+            nameservers = dns._ddr._get_nameservers_sync(answer, timeout)</span>
<span class="gi">+            if len(nameservers) &gt; 0:</span>
<span class="gi">+                self.nameservers = nameservers</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: The default resolver.</span>
<span class="w"> </span>default_resolver: Optional[Resolver] = None


<span class="gd">-def get_default_resolver() -&gt;Resolver:</span>
<span class="gi">+def get_default_resolver() -&gt; Resolver:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the default resolver, initializing it if necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default_resolver is None:</span>
<span class="gi">+        reset_default_resolver()</span>
<span class="gi">+    assert default_resolver is not None</span>
<span class="gi">+    return default_resolver</span>


<span class="gd">-def reset_default_resolver() -&gt;None:</span>
<span class="gi">+def reset_default_resolver() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Re-initialize default resolver.

<span class="w"> </span>    Note that the resolver configuration (i.e. /etc/resolv.conf on UNIX
<span class="w"> </span>    systems) will be re-read immediately.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def resolve(qname: Union[dns.name.Name, str], rdtype: Union[dns.rdatatype.</span>
<span class="gd">-    RdataType, str]=dns.rdatatype.A, rdclass: Union[dns.rdataclass.</span>
<span class="gd">-    RdataClass, str]=dns.rdataclass.IN, tcp: bool=False, source: Optional[</span>
<span class="gd">-    str]=None, raise_on_no_answer: bool=True, source_port: int=0, lifetime:</span>
<span class="gd">-    Optional[float]=None, search: Optional[bool]=None) -&gt;Answer:</span>
<span class="gi">+    global default_resolver</span>
<span class="gi">+    default_resolver = Resolver()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve(</span>
<span class="gi">+    qname: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    raise_on_no_answer: bool = True,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    search: Optional[bool] = None,</span>
<span class="gi">+) -&gt; Answer:  # pragma: no cover</span>
<span class="w"> </span>    &quot;&quot;&quot;Query nameservers to find the answer to the question.

<span class="w"> </span>    This is a convenience function that uses the default resolver
<span class="gu">@@ -736,14 +1561,30 @@ def resolve(qname: Union[dns.name.Name, str], rdtype: Union[dns.rdatatype.</span>
<span class="w"> </span>    See ``dns.resolver.Resolver.resolve`` for more information on the
<span class="w"> </span>    parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def query(qname: Union[dns.name.Name, str], rdtype: Union[dns.rdatatype.</span>
<span class="gd">-    RdataType, str]=dns.rdatatype.A, rdclass: Union[dns.rdataclass.</span>
<span class="gd">-    RdataClass, str]=dns.rdataclass.IN, tcp: bool=False, source: Optional[</span>
<span class="gd">-    str]=None, raise_on_no_answer: bool=True, source_port: int=0, lifetime:</span>
<span class="gd">-    Optional[float]=None) -&gt;Answer:</span>
<span class="gi">+    return get_default_resolver().resolve(</span>
<span class="gi">+        qname,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        tcp,</span>
<span class="gi">+        source,</span>
<span class="gi">+        raise_on_no_answer,</span>
<span class="gi">+        source_port,</span>
<span class="gi">+        lifetime,</span>
<span class="gi">+        search,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def query(</span>
<span class="gi">+    qname: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    raise_on_no_answer: bool = True,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+) -&gt; Answer:  # pragma: no cover</span>
<span class="w"> </span>    &quot;&quot;&quot;Query nameservers to find the answer to the question.

<span class="w"> </span>    This method calls resolve() with ``search=True``, and is
<span class="gu">@@ -751,50 +1592,71 @@ def query(qname: Union[dns.name.Name, str], rdtype: Union[dns.rdatatype.</span>
<span class="w"> </span>    dnspython.  See the documentation for the resolve() method for
<span class="w"> </span>    further details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def resolve_address(ipaddr: str, *args: Any, **kwargs: Any) -&gt;Answer:</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;please use dns.resolver.resolve() instead&quot;, DeprecationWarning, stacklevel=2</span>
<span class="gi">+    )</span>
<span class="gi">+    return resolve(</span>
<span class="gi">+        qname,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        tcp,</span>
<span class="gi">+        source,</span>
<span class="gi">+        raise_on_no_answer,</span>
<span class="gi">+        source_port,</span>
<span class="gi">+        lifetime,</span>
<span class="gi">+        True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_address(ipaddr: str, *args: Any, **kwargs: Any) -&gt; Answer:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use a resolver to run a reverse query for PTR records.

<span class="w"> </span>    See ``dns.resolver.Resolver.resolve_address`` for more information on the
<span class="w"> </span>    parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    return get_default_resolver().resolve_address(ipaddr, *args, **kwargs)</span>

<span class="gd">-def resolve_name(name: Union[dns.name.Name, str], family: int=socket.</span>
<span class="gd">-    AF_UNSPEC, **kwargs: Any) -&gt;HostAnswers:</span>
<span class="gi">+</span>
<span class="gi">+def resolve_name(</span>
<span class="gi">+    name: Union[dns.name.Name, str], family: int = socket.AF_UNSPEC, **kwargs: Any</span>
<span class="gi">+) -&gt; HostAnswers:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use a resolver to query for address records.

<span class="w"> </span>    See ``dns.resolver.Resolver.resolve_name`` for more information on the
<span class="w"> </span>    parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return get_default_resolver().resolve_name(name, family, **kwargs)</span>


<span class="gd">-def canonical_name(name: Union[dns.name.Name, str]) -&gt;dns.name.Name:</span>
<span class="gi">+def canonical_name(name: Union[dns.name.Name, str]) -&gt; dns.name.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine the canonical name of *name*.

<span class="w"> </span>    See ``dns.resolver.Resolver.canonical_name`` for more information on the
<span class="w"> </span>    parameters and possible exceptions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return get_default_resolver().canonical_name(name)</span>


<span class="gd">-def try_ddr(lifetime: float=5.0) -&gt;None:</span>
<span class="gi">+def try_ddr(lifetime: float = 5.0) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to update the default resolver&#39;s nameservers using Discovery of Designated
<span class="w"> </span>    Resolvers (DDR).  If successful, the resolver will subsequently use
<span class="w"> </span>    DNS-over-HTTPS or DNS-over-TLS for future queries.

<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.try_ddr` for more information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_default_resolver().try_ddr(lifetime)</span>


<span class="gd">-def zone_for_name(name: Union[dns.name.Name, str], rdclass: dns.rdataclass.</span>
<span class="gd">-    RdataClass=dns.rdataclass.IN, tcp: bool=False, resolver: Optional[</span>
<span class="gd">-    Resolver]=None, lifetime: Optional[float]=None) -&gt;dns.name.Name:</span>
<span class="gi">+def zone_for_name(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+) -&gt; dns.name.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the name of the zone which contains the specified name.

<span class="w"> </span>    *name*, an absolute ``dns.name.Name`` or ``str``, the query name.
<span class="gu">@@ -819,11 +1681,66 @@ def zone_for_name(name: Union[dns.name.Name, str], rdclass: dns.rdataclass.</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def make_resolver_at(where: Union[dns.name.Name, str], port: int=53, family:</span>
<span class="gd">-    int=socket.AF_UNSPEC, resolver: Optional[Resolver]=None) -&gt;Resolver:</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, dns.name.root)</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    if not name.is_absolute():</span>
<span class="gi">+        raise NotAbsolute(name)</span>
<span class="gi">+    start = time.time()</span>
<span class="gi">+    expiration: Optional[float]</span>
<span class="gi">+    if lifetime is not None:</span>
<span class="gi">+        expiration = start + lifetime</span>
<span class="gi">+    else:</span>
<span class="gi">+        expiration = None</span>
<span class="gi">+    while 1:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rlifetime: Optional[float]</span>
<span class="gi">+            if expiration is not None:</span>
<span class="gi">+                rlifetime = expiration - time.time()</span>
<span class="gi">+                if rlifetime &lt;= 0:</span>
<span class="gi">+                    rlifetime = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                rlifetime = None</span>
<span class="gi">+            answer = resolver.resolve(</span>
<span class="gi">+                name, dns.rdatatype.SOA, rdclass, tcp, lifetime=rlifetime</span>
<span class="gi">+            )</span>
<span class="gi">+            assert answer.rrset is not None</span>
<span class="gi">+            if answer.rrset.name == name:</span>
<span class="gi">+                return name</span>
<span class="gi">+            # otherwise we were CNAMEd or DNAMEd and need to look higher</span>
<span class="gi">+        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer) as e:</span>
<span class="gi">+            if isinstance(e, dns.resolver.NXDOMAIN):</span>
<span class="gi">+                response = e.responses().get(name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                response = e.response()  # pylint: disable=no-value-for-parameter</span>
<span class="gi">+            if response:</span>
<span class="gi">+                for rrs in response.authority:</span>
<span class="gi">+                    if rrs.rdtype == dns.rdatatype.SOA and rrs.rdclass == rdclass:</span>
<span class="gi">+                        (nr, _, _) = rrs.name.fullcompare(name)</span>
<span class="gi">+                        if nr == dns.name.NAMERELN_SUPERDOMAIN:</span>
<span class="gi">+                            # We&#39;re doing a proper superdomain check as</span>
<span class="gi">+                            # if the name were equal we ought to have gotten</span>
<span class="gi">+                            # it in the answer section!  We are ignoring the</span>
<span class="gi">+                            # possibility that the authority is insane and</span>
<span class="gi">+                            # is including multiple SOA RRs for different</span>
<span class="gi">+                            # authorities.</span>
<span class="gi">+                            return rrs.name</span>
<span class="gi">+            # we couldn&#39;t extract anything useful from the response (e.g. it&#39;s</span>
<span class="gi">+            # a type 3 NXDOMAIN)</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = name.parent()</span>
<span class="gi">+        except dns.name.NoParent:</span>
<span class="gi">+            raise NoRootSOA</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_resolver_at(</span>
<span class="gi">+    where: Union[dns.name.Name, str],</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    family: int = socket.AF_UNSPEC,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+) -&gt; Resolver:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a stub resolver using the specified destination as the full resolver.

<span class="w"> </span>    *where*, a ``dns.name.Name`` or ``str`` the domain name or IP address of the
<span class="gu">@@ -841,16 +1758,34 @@ def make_resolver_at(where: Union[dns.name.Name, str], port: int=53, family:</span>

<span class="w"> </span>    Returns a ``dns.resolver.Resolver`` or raises an exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def resolve_at(where: Union[dns.name.Name, str], qname: Union[dns.name.Name,</span>
<span class="gd">-    str], rdtype: Union[dns.rdatatype.RdataType, str]=dns.rdatatype.A,</span>
<span class="gd">-    rdclass: Union[dns.rdataclass.RdataClass, str]=dns.rdataclass.IN, tcp:</span>
<span class="gd">-    bool=False, source: Optional[str]=None, raise_on_no_answer: bool=True,</span>
<span class="gd">-    source_port: int=0, lifetime: Optional[float]=None, search: Optional[</span>
<span class="gd">-    bool]=None, port: int=53, family: int=socket.AF_UNSPEC, resolver:</span>
<span class="gd">-    Optional[Resolver]=None) -&gt;Answer:</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    nameservers: List[Union[str, dns.nameserver.Nameserver]] = []</span>
<span class="gi">+    if isinstance(where, str) and dns.inet.is_address(where):</span>
<span class="gi">+        nameservers.append(dns.nameserver.Do53Nameserver(where, port))</span>
<span class="gi">+    else:</span>
<span class="gi">+        for address in resolver.resolve_name(where, family).addresses():</span>
<span class="gi">+            nameservers.append(dns.nameserver.Do53Nameserver(address, port))</span>
<span class="gi">+    res = dns.resolver.Resolver(configure=False)</span>
<span class="gi">+    res.nameservers = nameservers</span>
<span class="gi">+    return res</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_at(</span>
<span class="gi">+    where: Union[dns.name.Name, str],</span>
<span class="gi">+    qname: Union[dns.name.Name, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    tcp: bool = False,</span>
<span class="gi">+    source: Optional[str] = None,</span>
<span class="gi">+    raise_on_no_answer: bool = True,</span>
<span class="gi">+    source_port: int = 0,</span>
<span class="gi">+    lifetime: Optional[float] = None,</span>
<span class="gi">+    search: Optional[bool] = None,</span>
<span class="gi">+    port: int = 53,</span>
<span class="gi">+    family: int = socket.AF_UNSPEC,</span>
<span class="gi">+    resolver: Optional[Resolver] = None,</span>
<span class="gi">+) -&gt; Answer:</span>
<span class="w"> </span>    &quot;&quot;&quot;Query nameservers to find the answer to the question.

<span class="w"> </span>    This is a convenience function that calls ``dns.resolver.make_resolver_at()`` to
<span class="gu">@@ -864,11 +1799,29 @@ def resolve_at(where: Union[dns.name.Name, str], qname: Union[dns.name.Name,</span>
<span class="w"> </span>    ``dns.resolver.make_resolver_at()`` and then use that resolver for the queries
<span class="w"> </span>    instead of calling ``resolve_at()`` multiple times.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return make_resolver_at(where, port, family, resolver).resolve(</span>
<span class="gi">+        qname,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        tcp,</span>
<span class="gi">+        source,</span>
<span class="gi">+        raise_on_no_answer,</span>
<span class="gi">+        source_port,</span>
<span class="gi">+        lifetime,</span>
<span class="gi">+        search,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+# Support for overriding the system resolver for all python code in the</span>
<span class="gi">+# running process.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+_protocols_for_socktype = {</span>
<span class="gi">+    socket.SOCK_DGRAM: [socket.SOL_UDP],</span>
<span class="gi">+    socket.SOCK_STREAM: [socket.SOL_TCP],</span>
<span class="gi">+}</span>

<span class="gd">-</span>
<span class="gd">-_protocols_for_socktype = {socket.SOCK_DGRAM: [socket.SOL_UDP], socket.</span>
<span class="gd">-    SOCK_STREAM: [socket.SOL_TCP]}</span>
<span class="w"> </span>_resolver = None
<span class="w"> </span>_original_getaddrinfo = socket.getaddrinfo
<span class="w"> </span>_original_getnameinfo = socket.getnameinfo
<span class="gu">@@ -878,7 +1831,191 @@ _original_gethostbyname_ex = socket.gethostbyname_ex</span>
<span class="w"> </span>_original_gethostbyaddr = socket.gethostbyaddr


<span class="gd">-def override_system_resolver(resolver: Optional[Resolver]=None) -&gt;None:</span>
<span class="gi">+def _getaddrinfo(</span>
<span class="gi">+    host=None, service=None, family=socket.AF_UNSPEC, socktype=0, proto=0, flags=0</span>
<span class="gi">+):</span>
<span class="gi">+    if flags &amp; socket.AI_NUMERICHOST != 0:</span>
<span class="gi">+        # Short circuit directly into the system&#39;s getaddrinfo().  We&#39;re</span>
<span class="gi">+        # not adding any value in this case, and this avoids infinite loops</span>
<span class="gi">+        # because dns.query.* needs to call getaddrinfo() for IPv6 scoping</span>
<span class="gi">+        # reasons.  We will also do this short circuit below if we</span>
<span class="gi">+        # discover that the host is an address literal.</span>
<span class="gi">+        return _original_getaddrinfo(host, service, family, socktype, proto, flags)</span>
<span class="gi">+    if flags &amp; (socket.AI_ADDRCONFIG | socket.AI_V4MAPPED) != 0:</span>
<span class="gi">+        # Not implemented.  We raise a gaierror as opposed to a</span>
<span class="gi">+        # NotImplementedError as it helps callers handle errors more</span>
<span class="gi">+        # appropriately.  [Issue #316]</span>
<span class="gi">+        #</span>
<span class="gi">+        # We raise EAI_FAIL as opposed to EAI_SYSTEM because there is</span>
<span class="gi">+        # no EAI_SYSTEM on Windows [Issue #416].  We didn&#39;t go for</span>
<span class="gi">+        # EAI_BADFLAGS as the flags aren&#39;t bad, we just don&#39;t</span>
<span class="gi">+        # implement them.</span>
<span class="gi">+        raise socket.gaierror(</span>
<span class="gi">+            socket.EAI_FAIL, &quot;Non-recoverable failure in name resolution&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if host is None and service is None:</span>
<span class="gi">+        raise socket.gaierror(socket.EAI_NONAME, &quot;Name or service not known&quot;)</span>
<span class="gi">+    addrs = []</span>
<span class="gi">+    canonical_name = None  # pylint: disable=redefined-outer-name</span>
<span class="gi">+    # Is host None or an address literal?  If so, use the system&#39;s</span>
<span class="gi">+    # getaddrinfo().</span>
<span class="gi">+    if host is None:</span>
<span class="gi">+        return _original_getaddrinfo(host, service, family, socktype, proto, flags)</span>
<span class="gi">+    try:</span>
<span class="gi">+        # We don&#39;t care about the result of af_for_address(), we&#39;re just</span>
<span class="gi">+        # calling it so it raises an exception if host is not an IPv4 or</span>
<span class="gi">+        # IPv6 address.</span>
<span class="gi">+        dns.inet.af_for_address(host)</span>
<span class="gi">+        return _original_getaddrinfo(host, service, family, socktype, proto, flags)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        pass</span>
<span class="gi">+    # Something needs resolution!</span>
<span class="gi">+    try:</span>
<span class="gi">+        answers = _resolver.resolve_name(host, family)</span>
<span class="gi">+        addrs = answers.addresses_and_families()</span>
<span class="gi">+        canonical_name = answers.canonical_name().to_text(True)</span>
<span class="gi">+    except dns.resolver.NXDOMAIN:</span>
<span class="gi">+        raise socket.gaierror(socket.EAI_NONAME, &quot;Name or service not known&quot;)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        # We raise EAI_AGAIN here as the failure may be temporary</span>
<span class="gi">+        # (e.g. a timeout) and EAI_SYSTEM isn&#39;t defined on Windows.</span>
<span class="gi">+        # [Issue #416]</span>
<span class="gi">+        raise socket.gaierror(socket.EAI_AGAIN, &quot;Temporary failure in name resolution&quot;)</span>
<span class="gi">+    port = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Is it a port literal?</span>
<span class="gi">+        if service is None:</span>
<span class="gi">+            port = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            port = int(service)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        if flags &amp; socket.AI_NUMERICSERV == 0:</span>
<span class="gi">+            try:</span>
<span class="gi">+                port = socket.getservbyname(service)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="gi">+    if port is None:</span>
<span class="gi">+        raise socket.gaierror(socket.EAI_NONAME, &quot;Name or service not known&quot;)</span>
<span class="gi">+    tuples = []</span>
<span class="gi">+    if socktype == 0:</span>
<span class="gi">+        socktypes = [socket.SOCK_DGRAM, socket.SOCK_STREAM]</span>
<span class="gi">+    else:</span>
<span class="gi">+        socktypes = [socktype]</span>
<span class="gi">+    if flags &amp; socket.AI_CANONNAME != 0:</span>
<span class="gi">+        cname = canonical_name</span>
<span class="gi">+    else:</span>
<span class="gi">+        cname = &quot;&quot;</span>
<span class="gi">+    for addr, af in addrs:</span>
<span class="gi">+        for socktype in socktypes:</span>
<span class="gi">+            for proto in _protocols_for_socktype[socktype]:</span>
<span class="gi">+                addr_tuple = dns.inet.low_level_address_tuple((addr, port), af)</span>
<span class="gi">+                tuples.append((af, socktype, proto, cname, addr_tuple))</span>
<span class="gi">+    if len(tuples) == 0:</span>
<span class="gi">+        raise socket.gaierror(socket.EAI_NONAME, &quot;Name or service not known&quot;)</span>
<span class="gi">+    return tuples</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _getnameinfo(sockaddr, flags=0):</span>
<span class="gi">+    host = sockaddr[0]</span>
<span class="gi">+    port = sockaddr[1]</span>
<span class="gi">+    if len(sockaddr) == 4:</span>
<span class="gi">+        scope = sockaddr[3]</span>
<span class="gi">+        family = socket.AF_INET6</span>
<span class="gi">+    else:</span>
<span class="gi">+        scope = None</span>
<span class="gi">+        family = socket.AF_INET</span>
<span class="gi">+    tuples = _getaddrinfo(host, port, family, socket.SOCK_STREAM, socket.SOL_TCP, 0)</span>
<span class="gi">+    if len(tuples) &gt; 1:</span>
<span class="gi">+        raise socket.error(&quot;sockaddr resolved to multiple addresses&quot;)</span>
<span class="gi">+    addr = tuples[0][4][0]</span>
<span class="gi">+    if flags &amp; socket.NI_DGRAM:</span>
<span class="gi">+        pname = &quot;udp&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        pname = &quot;tcp&quot;</span>
<span class="gi">+    qname = dns.reversename.from_address(addr)</span>
<span class="gi">+    if flags &amp; socket.NI_NUMERICHOST == 0:</span>
<span class="gi">+        try:</span>
<span class="gi">+            answer = _resolver.resolve(qname, &quot;PTR&quot;)</span>
<span class="gi">+            hostname = answer.rrset[0].target.to_text(True)</span>
<span class="gi">+        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):</span>
<span class="gi">+            if flags &amp; socket.NI_NAMEREQD:</span>
<span class="gi">+                raise socket.gaierror(socket.EAI_NONAME, &quot;Name or service not known&quot;)</span>
<span class="gi">+            hostname = addr</span>
<span class="gi">+            if scope is not None:</span>
<span class="gi">+                hostname += &quot;%&quot; + str(scope)</span>
<span class="gi">+    else:</span>
<span class="gi">+        hostname = addr</span>
<span class="gi">+        if scope is not None:</span>
<span class="gi">+            hostname += &quot;%&quot; + str(scope)</span>
<span class="gi">+    if flags &amp; socket.NI_NUMERICSERV:</span>
<span class="gi">+        service = str(port)</span>
<span class="gi">+    else:</span>
<span class="gi">+        service = socket.getservbyport(port, pname)</span>
<span class="gi">+    return (hostname, service)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _getfqdn(name=None):</span>
<span class="gi">+    if name is None:</span>
<span class="gi">+        name = socket.gethostname()</span>
<span class="gi">+    try:</span>
<span class="gi">+        (name, _, _) = _gethostbyaddr(name)</span>
<span class="gi">+        # Python&#39;s version checks aliases too, but our gethostbyname</span>
<span class="gi">+        # ignores them, so we do so here as well.</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _gethostbyname(name):</span>
<span class="gi">+    return _gethostbyname_ex(name)[2][0]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _gethostbyname_ex(name):</span>
<span class="gi">+    aliases = []</span>
<span class="gi">+    addresses = []</span>
<span class="gi">+    tuples = _getaddrinfo(</span>
<span class="gi">+        name, 0, socket.AF_INET, socket.SOCK_STREAM, socket.SOL_TCP, socket.AI_CANONNAME</span>
<span class="gi">+    )</span>
<span class="gi">+    canonical = tuples[0][3]</span>
<span class="gi">+    for item in tuples:</span>
<span class="gi">+        addresses.append(item[4][0])</span>
<span class="gi">+    # XXX we just ignore aliases</span>
<span class="gi">+    return (canonical, aliases, addresses)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _gethostbyaddr(ip):</span>
<span class="gi">+    try:</span>
<span class="gi">+        dns.ipv6.inet_aton(ip)</span>
<span class="gi">+        sockaddr = (ip, 80, 0, 0)</span>
<span class="gi">+        family = socket.AF_INET6</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dns.ipv4.inet_aton(ip)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise socket.gaierror(socket.EAI_NONAME, &quot;Name or service not known&quot;)</span>
<span class="gi">+        sockaddr = (ip, 80)</span>
<span class="gi">+        family = socket.AF_INET</span>
<span class="gi">+    (name, _) = _getnameinfo(sockaddr, socket.NI_NAMEREQD)</span>
<span class="gi">+    aliases = []</span>
<span class="gi">+    addresses = []</span>
<span class="gi">+    tuples = _getaddrinfo(</span>
<span class="gi">+        name, 0, family, socket.SOCK_STREAM, socket.SOL_TCP, socket.AI_CANONNAME</span>
<span class="gi">+    )</span>
<span class="gi">+    canonical = tuples[0][3]</span>
<span class="gi">+    # We only want to include an address from the tuples if it&#39;s the</span>
<span class="gi">+    # same as the one we asked about.  We do this comparison in binary</span>
<span class="gi">+    # to avoid any differences in text representations.</span>
<span class="gi">+    bin_ip = dns.inet.inet_pton(family, ip)</span>
<span class="gi">+    for item in tuples:</span>
<span class="gi">+        addr = item[4][0]</span>
<span class="gi">+        bin_addr = dns.inet.inet_pton(family, addr)</span>
<span class="gi">+        if bin_ip == bin_addr:</span>
<span class="gi">+            addresses.append(addr)</span>
<span class="gi">+    # XXX we just ignore aliases</span>
<span class="gi">+    return (canonical, aliases, addresses)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def override_system_resolver(resolver: Optional[Resolver] = None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Override the system resolver routines in the socket module with
<span class="w"> </span>    versions which use dnspython&#39;s resolver.

<span class="gu">@@ -891,9 +2028,27 @@ def override_system_resolver(resolver: Optional[Resolver]=None) -&gt;None:</span>

<span class="w"> </span>    resolver, a ``dns.resolver.Resolver`` or ``None``, the resolver to use.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    global _resolver</span>
<span class="gi">+    _resolver = resolver</span>
<span class="gi">+    socket.getaddrinfo = _getaddrinfo</span>
<span class="gi">+    socket.getnameinfo = _getnameinfo</span>
<span class="gi">+    socket.getfqdn = _getfqdn</span>
<span class="gi">+    socket.gethostbyname = _gethostbyname</span>
<span class="gi">+    socket.gethostbyname_ex = _gethostbyname_ex</span>
<span class="gi">+    socket.gethostbyaddr = _gethostbyaddr</span>


<span class="gd">-def restore_system_resolver() -&gt;None:</span>
<span class="gi">+def restore_system_resolver() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Undo the effects of prior override_system_resolver().&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    global _resolver</span>
<span class="gi">+    _resolver = None</span>
<span class="gi">+    socket.getaddrinfo = _original_getaddrinfo</span>
<span class="gi">+    socket.getnameinfo = _original_getnameinfo</span>
<span class="gi">+    socket.getfqdn = _original_getfqdn</span>
<span class="gi">+    socket.gethostbyname = _original_gethostbyname</span>
<span class="gi">+    socket.gethostbyname_ex = _original_gethostbyname_ex</span>
<span class="gi">+    socket.gethostbyaddr = _original_gethostbyaddr</span>
<span class="gh">diff --git a/dns/reversename.py b/dns/reversename.py</span>
<span class="gh">index 416c57f..8236c71 100644</span>
<span class="gd">--- a/dns/reversename.py</span>
<span class="gi">+++ b/dns/reversename.py</span>
<span class="gu">@@ -1,14 +1,37 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2006-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Reverse Map Names.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="gi">+</span>
<span class="w"> </span>import dns.ipv4
<span class="w"> </span>import dns.ipv6
<span class="w"> </span>import dns.name
<span class="gd">-ipv4_reverse_domain = dns.name.from_text(&#39;in-addr.arpa.&#39;)</span>
<span class="gd">-ipv6_reverse_domain = dns.name.from_text(&#39;ip6.arpa.&#39;)</span>

<span class="gi">+ipv4_reverse_domain = dns.name.from_text(&quot;in-addr.arpa.&quot;)</span>
<span class="gi">+ipv6_reverse_domain = dns.name.from_text(&quot;ip6.arpa.&quot;)</span>

<span class="gd">-def from_address(text: str, v4_origin: dns.name.Name=ipv4_reverse_domain,</span>
<span class="gd">-    v6_origin: dns.name.Name=ipv6_reverse_domain) -&gt;dns.name.Name:</span>
<span class="gi">+</span>
<span class="gi">+def from_address(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    v4_origin: dns.name.Name = ipv4_reverse_domain,</span>
<span class="gi">+    v6_origin: dns.name.Name = ipv6_reverse_domain,</span>
<span class="gi">+) -&gt; dns.name.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an IPv4 or IPv6 address in textual form into a Name object whose
<span class="w"> </span>    value is the reverse-map domain name of the address.

<span class="gu">@@ -27,11 +50,26 @@ def from_address(text: str, v4_origin: dns.name.Name=ipv4_reverse_domain,</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        v6 = dns.ipv6.inet_aton(text)</span>
<span class="gi">+        if dns.ipv6.is_mapped(v6):</span>
<span class="gi">+            parts = [&quot;%d&quot; % byte for byte in v6[12:]]</span>
<span class="gi">+            origin = v4_origin</span>
<span class="gi">+        else:</span>
<span class="gi">+            parts = [x for x in str(binascii.hexlify(v6).decode())]</span>
<span class="gi">+            origin = v6_origin</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        parts = [&quot;%d&quot; % byte for byte in dns.ipv4.inet_aton(text)]</span>
<span class="gi">+        origin = v4_origin</span>
<span class="gi">+    return dns.name.from_text(&quot;.&quot;.join(reversed(parts)), origin=origin)</span>


<span class="gd">-def to_address(name: dns.name.Name, v4_origin: dns.name.Name=</span>
<span class="gd">-    ipv4_reverse_domain, v6_origin: dns.name.Name=ipv6_reverse_domain) -&gt;str:</span>
<span class="gi">+def to_address(</span>
<span class="gi">+    name: dns.name.Name,</span>
<span class="gi">+    v4_origin: dns.name.Name = ipv4_reverse_domain,</span>
<span class="gi">+    v6_origin: dns.name.Name = ipv6_reverse_domain,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a reverse map domain name into textual address form.

<span class="w"> </span>    *name*, a ``dns.name.Name``, an IPv4 or IPv6 address in reverse-map name
<span class="gu">@@ -48,4 +86,20 @@ def to_address(name: dns.name.Name, v4_origin: dns.name.Name=</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if name.is_subdomain(v4_origin):</span>
<span class="gi">+        name = name.relativize(v4_origin)</span>
<span class="gi">+        text = b&quot;.&quot;.join(reversed(name.labels))</span>
<span class="gi">+        # run through inet_ntoa() to check syntax and make pretty.</span>
<span class="gi">+        return dns.ipv4.inet_ntoa(dns.ipv4.inet_aton(text))</span>
<span class="gi">+    elif name.is_subdomain(v6_origin):</span>
<span class="gi">+        name = name.relativize(v6_origin)</span>
<span class="gi">+        labels = list(reversed(name.labels))</span>
<span class="gi">+        parts = []</span>
<span class="gi">+        for i in range(0, len(labels), 4):</span>
<span class="gi">+            parts.append(b&quot;&quot;.join(labels[i : i + 4]))</span>
<span class="gi">+        text = b&quot;:&quot;.join(parts)</span>
<span class="gi">+        # run through inet_ntoa() to check syntax and make pretty.</span>
<span class="gi">+        return dns.ipv6.inet_ntoa(dns.ipv6.inet_aton(text))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;unknown reverse-map address family&quot;)</span>
<span class="gh">diff --git a/dns/rrset.py b/dns/rrset.py</span>
<span class="gh">index f235f64..6f39b10 100644</span>
<span class="gd">--- a/dns/rrset.py</span>
<span class="gi">+++ b/dns/rrset.py</span>
<span class="gu">@@ -1,5 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS RRsets (an RRset is a named rdataset)&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Collection, Dict, Optional, Union, cast
<span class="gi">+</span>
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.rdataclass
<span class="w"> </span>import dns.rdataset
<span class="gu">@@ -15,29 +34,51 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>    arguments, reflecting the fact that RRsets always have an owner
<span class="w"> </span>    name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;name&#39;, &#39;deleting&#39;]</span>

<span class="gd">-    def __init__(self, name: dns.name.Name, rdclass: dns.rdataclass.</span>
<span class="gd">-        RdataClass, rdtype: dns.rdatatype.RdataType, covers: dns.rdatatype.</span>
<span class="gd">-        RdataType=dns.rdatatype.NONE, deleting: Optional[dns.rdataclass.</span>
<span class="gd">-        RdataClass]=None):</span>
<span class="gi">+    __slots__ = [&quot;name&quot;, &quot;deleting&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        deleting: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new RRset.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(rdclass, rdtype, covers)
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.deleting = deleting

<span class="gi">+    def _clone(self):</span>
<span class="gi">+        obj = super()._clone()</span>
<span class="gi">+        obj.name = self.name</span>
<span class="gi">+        obj.deleting = self.deleting</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.covers == 0:
<span class="gd">-            ctext = &#39;&#39;</span>
<span class="gi">+            ctext = &quot;&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            ctext = &#39;(&#39; + dns.rdatatype.to_text(self.covers) + &#39;)&#39;</span>
<span class="gi">+            ctext = &quot;(&quot; + dns.rdatatype.to_text(self.covers) + &quot;)&quot;</span>
<span class="w"> </span>        if self.deleting is not None:
<span class="gd">-            dtext = &#39; delete=&#39; + dns.rdataclass.to_text(self.deleting)</span>
<span class="gi">+            dtext = &quot; delete=&quot; + dns.rdataclass.to_text(self.deleting)</span>
<span class="w"> </span>        else:
<span class="gd">-            dtext = &#39;&#39;</span>
<span class="gd">-        return &#39;&lt;DNS &#39; + str(self.name) + &#39; &#39; + dns.rdataclass.to_text(self</span>
<span class="gd">-            .rdclass) + &#39; &#39; + dns.rdatatype.to_text(self.rdtype</span>
<span class="gd">-            ) + ctext + dtext + &#39; RRset: &#39; + self._rdata_repr() + &#39;&gt;&#39;</span>
<span class="gi">+            dtext = &quot;&quot;</span>
<span class="gi">+        return (</span>
<span class="gi">+            &quot;&lt;DNS &quot;</span>
<span class="gi">+            + str(self.name)</span>
<span class="gi">+            + &quot; &quot;</span>
<span class="gi">+            + dns.rdataclass.to_text(self.rdclass)</span>
<span class="gi">+            + &quot; &quot;</span>
<span class="gi">+            + dns.rdatatype.to_text(self.rdtype)</span>
<span class="gi">+            + ctext</span>
<span class="gi">+            + dtext</span>
<span class="gi">+            + &quot; RRset: &quot;</span>
<span class="gi">+            + self._rdata_repr()</span>
<span class="gi">+            + &quot;&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.to_text()
<span class="gu">@@ -50,7 +91,7 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>            return False
<span class="w"> </span>        return super().__eq__(other)

<span class="gd">-    def match(self, *args: Any, **kwargs: Any) -&gt;bool:</span>
<span class="gi">+    def match(self, *args: Any, **kwargs: Any) -&gt; bool:  # type: ignore[override]</span>
<span class="w"> </span>        &quot;&quot;&quot;Does this rrset match the specified attributes?

<span class="w"> </span>        Behaves as :py:func:`full_match()` if the first argument is a
<span class="gu">@@ -62,18 +103,36 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>        makes RRsets matchable as Rdatasets while preserving backwards
<span class="w"> </span>        compatibility.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def full_match(self, name: dns.name.Name, rdclass: dns.rdataclass.</span>
<span class="gd">-        RdataClass, rdtype: dns.rdatatype.RdataType, covers: dns.rdatatype.</span>
<span class="gd">-        RdataType, deleting: Optional[dns.rdataclass.RdataClass]=None) -&gt;bool:</span>
<span class="gi">+        if isinstance(args[0], dns.name.Name):</span>
<span class="gi">+            return self.full_match(*args, **kwargs)  # type: ignore[arg-type]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return super().match(*args, **kwargs)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+    def full_match(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType,</span>
<span class="gi">+        deleting: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this rrset matches the specified name, class,
<span class="w"> </span>        type, covers, and deletion state.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not super().match(rdclass, rdtype, covers):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.name != name or self.deleting != deleting:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>

<span class="gd">-    def to_text(self, origin: Optional[dns.name.Name]=None, relativize:</span>
<span class="gd">-        bool=True, **kw: Dict[str, Any]) -&gt;str:</span>
<span class="gi">+    # pylint: disable=arguments-differ</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(  # type: ignore[override]</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the RRset into DNS zone file format.

<span class="w"> </span>        See ``dns.name.Name.choose_relativity`` for more information
<span class="gu">@@ -89,11 +148,18 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>        *relativize*, a ``bool``.  If ``True``, names will be relativized
<span class="w"> </span>        to *origin*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_wire(self, file: Any, compress: Optional[dns.name.CompressType]=</span>
<span class="gd">-        None, origin: Optional[dns.name.Name]=None, **kw: Dict[str, Any]</span>
<span class="gd">-        ) -&gt;int:</span>
<span class="gi">+        return super().to_text(</span>
<span class="gi">+            self.name, origin, relativize, self.deleting, **kw  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def to_wire(  # type: ignore[override]</span>
<span class="gi">+        self,</span>
<span class="gi">+        file: Any,</span>
<span class="gi">+        compress: Optional[dns.name.CompressType] = None,  # type: ignore</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        **kw: Dict[str, Any],</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the RRset to wire format.

<span class="w"> </span>        All keyword arguments are passed to ``dns.rdataset.to_wire()``; see
<span class="gu">@@ -101,21 +167,32 @@ class RRset(dns.rdataset.Rdataset):</span>

<span class="w"> </span>        Returns an ``int``, the number of records emitted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_rdataset(self) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+        return super().to_wire(</span>
<span class="gi">+            self.name, file, compress, origin, self.deleting, **kw  # type:ignore</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: enable=arguments-differ</span>
<span class="gi">+</span>
<span class="gi">+    def to_rdataset(self) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert an RRset into an Rdataset.

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def from_text_list(name: Union[dns.name.Name, str], ttl: int, rdclass:</span>
<span class="gd">-    Union[dns.rdataclass.RdataClass, str], rdtype: Union[dns.rdatatype.</span>
<span class="gd">-    RdataType, str], text_rdatas: Collection[str], idna_codec: Optional[dns</span>
<span class="gd">-    .name.IDNACodec]=None, origin: Optional[dns.name.Name]=None, relativize:</span>
<span class="gd">-    bool=True, relativize_to: Optional[dns.name.Name]=None) -&gt;RRset:</span>
<span class="gi">+        return dns.rdataset.from_rdata_list(self.ttl, list(self))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text_list(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    ttl: int,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    text_rdatas: Collection[str],</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+) -&gt; RRset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an RRset with the specified name, TTL, class, and type, and with
<span class="w"> </span>    the specified list of rdatas in text format.

<span class="gu">@@ -133,23 +210,45 @@ def from_text_list(name: Union[dns.name.Name, str], ttl: int, rdclass:</span>

<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def from_text(name: Union[dns.name.Name, str], ttl: int, rdclass: Union[dns</span>
<span class="gd">-    .rdataclass.RdataClass, str], rdtype: Union[dns.rdatatype.RdataType,</span>
<span class="gd">-    str], *text_rdatas: Any) -&gt;RRset:</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, None, idna_codec=idna_codec)</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    r = RRset(name, rdclass, rdtype)</span>
<span class="gi">+    r.update_ttl(ttl)</span>
<span class="gi">+    for t in text_rdatas:</span>
<span class="gi">+        rd = dns.rdata.from_text(</span>
<span class="gi">+            r.rdclass, r.rdtype, t, origin, relativize, relativize_to, idna_codec</span>
<span class="gi">+        )</span>
<span class="gi">+        r.add(rd)</span>
<span class="gi">+    return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    ttl: int,</span>
<span class="gi">+    rdclass: Union[dns.rdataclass.RdataClass, str],</span>
<span class="gi">+    rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+    *text_rdatas: Any,</span>
<span class="gi">+) -&gt; RRset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an RRset with the specified name, TTL, class, and type and with
<span class="w"> </span>    the specified rdatas in text format.

<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return from_text_list(</span>
<span class="gi">+        name, ttl, rdclass, rdtype, cast(Collection[str], text_rdatas)</span>
<span class="gi">+    )</span>


<span class="gd">-def from_rdata_list(name: Union[dns.name.Name, str], ttl: int, rdatas:</span>
<span class="gd">-    Collection[dns.rdata.Rdata], idna_codec: Optional[dns.name.IDNACodec]=None</span>
<span class="gd">-    ) -&gt;RRset:</span>
<span class="gi">+def from_rdata_list(</span>
<span class="gi">+    name: Union[dns.name.Name, str],</span>
<span class="gi">+    ttl: int,</span>
<span class="gi">+    rdatas: Collection[dns.rdata.Rdata],</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+) -&gt; RRset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an RRset with the specified name and TTL, and with
<span class="w"> </span>    the specified list of rdata objects.

<span class="gu">@@ -160,14 +259,27 @@ def from_rdata_list(name: Union[dns.name.Name, str], ttl: int, rdatas:</span>
<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, None, idna_codec=idna_codec)</span>
<span class="gi">+</span>
<span class="gi">+    if len(rdatas) == 0:</span>
<span class="gi">+        raise ValueError(&quot;rdata list must not be empty&quot;)</span>
<span class="gi">+    r = None</span>
<span class="gi">+    for rd in rdatas:</span>
<span class="gi">+        if r is None:</span>
<span class="gi">+            r = RRset(name, rd.rdclass, rd.rdtype)</span>
<span class="gi">+            r.update_ttl(ttl)</span>
<span class="gi">+        r.add(rd)</span>
<span class="gi">+    assert r is not None</span>
<span class="gi">+    return r</span>

<span class="gd">-def from_rdata(name: Union[dns.name.Name, str], ttl: int, *rdatas: Any</span>
<span class="gd">-    ) -&gt;RRset:</span>
<span class="gi">+</span>
<span class="gi">+def from_rdata(name: Union[dns.name.Name, str], ttl: int, *rdatas: Any) -&gt; RRset:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an RRset with the specified name and TTL, and with
<span class="w"> </span>    the specified rdata objects.

<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return from_rdata_list(name, ttl, cast(Collection[dns.rdata.Rdata], rdatas))</span>
<span class="gh">diff --git a/dns/serial.py b/dns/serial.py</span>
<span class="gh">index 3d76f4d..3417299 100644</span>
<span class="gd">--- a/dns/serial.py</span>
<span class="gi">+++ b/dns/serial.py</span>
<span class="gu">@@ -1,14 +1,15 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Serial Number Arthimetic from RFC 1982&quot;&quot;&quot;


<span class="w"> </span>class Serial:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, value: int, bits: int=32):</span>
<span class="gd">-        self.value = value % 2 ** bits</span>
<span class="gi">+    def __init__(self, value: int, bits: int = 32):</span>
<span class="gi">+        self.value = value % 2**bits</span>
<span class="w"> </span>        self.bits = bits

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;dns.serial.Serial({self.value}, {self.bits})&#39;</span>
<span class="gi">+        return f&quot;dns.serial.Serial({self.value}, {self.bits})&quot;</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, int):
<span class="gu">@@ -29,11 +30,11 @@ class Serial:</span>
<span class="w"> </span>            other = Serial(other, self.bits)
<span class="w"> </span>        elif not isinstance(other, Serial) or other.bits != self.bits:
<span class="w"> </span>            return NotImplemented
<span class="gd">-        if self.value &lt; other.value and other.value - self.value &lt; 2 ** (self</span>
<span class="gd">-            .bits - 1):</span>
<span class="gi">+        if self.value &lt; other.value and other.value - self.value &lt; 2 ** (self.bits - 1):</span>
<span class="w"> </span>            return True
<span class="gd">-        elif self.value &gt; other.value and self.value - other.value &gt; 2 ** (self</span>
<span class="gd">-            .bits - 1):</span>
<span class="gi">+        elif self.value &gt; other.value and self.value - other.value &gt; 2 ** (</span>
<span class="gi">+            self.bits - 1</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return True
<span class="w"> </span>        else:
<span class="w"> </span>            return False
<span class="gu">@@ -46,11 +47,11 @@ class Serial:</span>
<span class="w"> </span>            other = Serial(other, self.bits)
<span class="w"> </span>        elif not isinstance(other, Serial) or other.bits != self.bits:
<span class="w"> </span>            return NotImplemented
<span class="gd">-        if self.value &lt; other.value and other.value - self.value &gt; 2 ** (self</span>
<span class="gd">-            .bits - 1):</span>
<span class="gi">+        if self.value &lt; other.value and other.value - self.value &gt; 2 ** (self.bits - 1):</span>
<span class="w"> </span>            return True
<span class="gd">-        elif self.value &gt; other.value and self.value - other.value &lt; 2 ** (self</span>
<span class="gd">-            .bits - 1):</span>
<span class="gi">+        elif self.value &gt; other.value and self.value - other.value &lt; 2 ** (</span>
<span class="gi">+            self.bits - 1</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return True
<span class="w"> </span>        else:
<span class="w"> </span>            return False
<span class="gu">@@ -66,10 +67,10 @@ class Serial:</span>
<span class="w"> </span>            delta = other
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError
<span class="gd">-        if abs(delta) &gt; 2 ** (self.bits - 1) - 1:</span>
<span class="gi">+        if abs(delta) &gt; (2 ** (self.bits - 1) - 1):</span>
<span class="w"> </span>            raise ValueError
<span class="w"> </span>        v += delta
<span class="gd">-        v = v % 2 ** self.bits</span>
<span class="gi">+        v = v % 2**self.bits</span>
<span class="w"> </span>        return Serial(v, self.bits)

<span class="w"> </span>    def __iadd__(self, other):
<span class="gu">@@ -80,10 +81,10 @@ class Serial:</span>
<span class="w"> </span>            delta = other
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError
<span class="gd">-        if abs(delta) &gt; 2 ** (self.bits - 1) - 1:</span>
<span class="gi">+        if abs(delta) &gt; (2 ** (self.bits - 1) - 1):</span>
<span class="w"> </span>            raise ValueError
<span class="w"> </span>        v += delta
<span class="gd">-        v = v % 2 ** self.bits</span>
<span class="gi">+        v = v % 2**self.bits</span>
<span class="w"> </span>        self.value = v
<span class="w"> </span>        return self

<span class="gu">@@ -95,10 +96,10 @@ class Serial:</span>
<span class="w"> </span>            delta = other
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError
<span class="gd">-        if abs(delta) &gt; 2 ** (self.bits - 1) - 1:</span>
<span class="gi">+        if abs(delta) &gt; (2 ** (self.bits - 1) - 1):</span>
<span class="w"> </span>            raise ValueError
<span class="w"> </span>        v -= delta
<span class="gd">-        v = v % 2 ** self.bits</span>
<span class="gi">+        v = v % 2**self.bits</span>
<span class="w"> </span>        return Serial(v, self.bits)

<span class="w"> </span>    def __isub__(self, other):
<span class="gu">@@ -109,9 +110,9 @@ class Serial:</span>
<span class="w"> </span>            delta = other
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError
<span class="gd">-        if abs(delta) &gt; 2 ** (self.bits - 1) - 1:</span>
<span class="gi">+        if abs(delta) &gt; (2 ** (self.bits - 1) - 1):</span>
<span class="w"> </span>            raise ValueError
<span class="w"> </span>        v -= delta
<span class="gd">-        v = v % 2 ** self.bits</span>
<span class="gi">+        v = v % 2**self.bits</span>
<span class="w"> </span>        self.value = v
<span class="w"> </span>        return self
<span class="gh">diff --git a/dns/set.py b/dns/set.py</span>
<span class="gh">index d90e21f..f0fb0d5 100644</span>
<span class="gd">--- a/dns/set.py</span>
<span class="gi">+++ b/dns/set.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import itertools


<span class="gu">@@ -9,38 +26,50 @@ class Set:</span>
<span class="w"> </span>    as these sets are based on lists and are thus indexable, and this
<span class="w"> </span>    ability is widely used in dnspython applications.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;items&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;items&quot;]</span>

<span class="w"> </span>    def __init__(self, items=None):
<span class="w"> </span>        &quot;&quot;&quot;Initialize the set.

<span class="w"> </span>        *items*, an iterable or ``None``, the initial set of items.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.items = dict()
<span class="w"> </span>        if items is not None:
<span class="w"> </span>            for item in items:
<span class="gd">-                self.add(item)</span>
<span class="gi">+                # This is safe for how we use set, but if other code</span>
<span class="gi">+                # subclasses it could be a legitimate issue.</span>
<span class="gi">+                self.add(item)  # lgtm[py/init-calls-subclass]</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;dns.set.Set(%s)&#39; % repr(list(self.items.keys()))</span>
<span class="gi">+        return &quot;dns.set.Set(%s)&quot; % repr(list(self.items.keys()))</span>

<span class="w"> </span>    def add(self, item):
<span class="w"> </span>        &quot;&quot;&quot;Add an item to the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if item not in self.items:</span>
<span class="gi">+            self.items[item] = None</span>

<span class="w"> </span>    def remove(self, item):
<span class="w"> </span>        &quot;&quot;&quot;Remove an item from the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self.items[item]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise ValueError</span>

<span class="w"> </span>    def discard(self, item):
<span class="w"> </span>        &quot;&quot;&quot;Remove an item from the set if present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.items.pop(item, None)</span>

<span class="w"> </span>    def pop(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove an arbitrary item from the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        (k, _) = self.items.popitem()</span>
<span class="gi">+        return k</span>

<span class="gd">-    def _clone(self) -&gt;&#39;Set&#39;:</span>
<span class="gi">+    def _clone(self) -&gt; &quot;Set&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Make a (shallow) copy of the set.

<span class="w"> </span>        There is a &#39;clone protocol&#39; that subclasses of this class
<span class="gu">@@ -52,44 +81,87 @@ class Set:</span>
<span class="w"> </span>        return new instances (e.g. union) once, and keep using them in
<span class="w"> </span>        subclasses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(self, &quot;_clone_class&quot;):</span>
<span class="gi">+            cls = self._clone_class  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            cls = self.__class__</span>
<span class="gi">+        obj = cls.__new__(cls)</span>
<span class="gi">+        obj.items = dict()</span>
<span class="gi">+        obj.items.update(self.items)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def __copy__(self):
<span class="w"> </span>        &quot;&quot;&quot;Make a (shallow) copy of the set.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        return self._clone()

<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;Make a (shallow) copy of the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return self._clone()</span>

<span class="w"> </span>    def union_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, adding any elements from other which are not
<span class="w"> </span>        already in the set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        if self is other:  # lgtm[py/comparison-using-is]</span>
<span class="gi">+            return</span>
<span class="gi">+        for item in other.items:</span>
<span class="gi">+            self.add(item)</span>

<span class="w"> </span>    def intersection_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, removing any elements from other which are not
<span class="w"> </span>        in both sets.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        if self is other:  # lgtm[py/comparison-using-is]</span>
<span class="gi">+            return</span>
<span class="gi">+        # we make a copy of the list so that we can remove items from</span>
<span class="gi">+        # the list without breaking the iterator.</span>
<span class="gi">+        for item in list(self.items):</span>
<span class="gi">+            if item not in other.items:</span>
<span class="gi">+                del self.items[item]</span>

<span class="w"> </span>    def difference_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, removing any elements from other which are in
<span class="w"> </span>        the set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        if self is other:  # lgtm[py/comparison-using-is]</span>
<span class="gi">+            self.items.clear()</span>
<span class="gi">+        else:</span>
<span class="gi">+            for item in other.items:</span>
<span class="gi">+                self.discard(item)</span>

<span class="w"> </span>    def symmetric_difference_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, retaining only elements unique to both sets.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        if self is other:  # lgtm[py/comparison-using-is]</span>
<span class="gi">+            self.items.clear()</span>
<span class="gi">+        else:</span>
<span class="gi">+            overlap = self.intersection(other)</span>
<span class="gi">+            self.union_update(other)</span>
<span class="gi">+            self.difference_update(overlap)</span>

<span class="w"> </span>    def union(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which is the union of ``self`` and ``other``.

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        obj = self._clone()</span>
<span class="gi">+        obj.union_update(other)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def intersection(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which is the intersection of ``self`` and
<span class="gu">@@ -97,7 +169,10 @@ class Set:</span>

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        obj = self._clone()</span>
<span class="gi">+        obj.intersection_update(other)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def difference(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which ``self`` - ``other``, i.e. the items
<span class="gu">@@ -105,7 +180,10 @@ class Set:</span>

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        obj = self._clone()</span>
<span class="gi">+        obj.difference_update(other)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def symmetric_difference(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which (``self`` - ``other``) | (``other``
<span class="gu">@@ -114,7 +192,10 @@ class Set:</span>

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        obj = self._clone()</span>
<span class="gi">+        obj.symmetric_difference_update(other)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def __or__(self, other):
<span class="w"> </span>        return self.union(other)
<span class="gu">@@ -158,11 +239,13 @@ class Set:</span>
<span class="w"> </span>        *other*, the collection of items with which to update the set, which
<span class="w"> </span>        may be any iterable type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        for item in other:</span>
<span class="gi">+            self.add(item)</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Make the set empty.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items.clear()</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        return self.items == other.items
<span class="gu">@@ -194,11 +277,31 @@ class Set:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        for item in self.items:</span>
<span class="gi">+            if item not in other.items:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def issuperset(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Is this set a superset of *other*?

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        for item in other.items:</span>
<span class="gi">+            if item not in self.items:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def isdisjoint(self, other):</span>
<span class="gi">+        if not isinstance(other, Set):</span>
<span class="gi">+            raise ValueError(&quot;other must be a Set instance&quot;)</span>
<span class="gi">+        for item in other.items:</span>
<span class="gi">+            if item in self.items:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/dns/tokenizer.py b/dns/tokenizer.py</span>
<span class="gh">index c6a389f..454cac4 100644</span>
<span class="gd">--- a/dns/tokenizer.py</span>
<span class="gi">+++ b/dns/tokenizer.py</span>
<span class="gu">@@ -1,12 +1,33 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Tokenize DNS zone file format&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import io
<span class="w"> </span>import sys
<span class="w"> </span>from typing import Any, List, Optional, Tuple
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.ttl
<span class="gd">-_DELIMITERS = {&#39; &#39;, &#39;\t&#39;, &#39;\n&#39;, &#39;;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&quot;&#39;}</span>
<span class="gi">+</span>
<span class="gi">+_DELIMITERS = {&quot; &quot;, &quot;\t&quot;, &quot;\n&quot;, &quot;;&quot;, &quot;(&quot;, &quot;)&quot;, &#39;&quot;&#39;}</span>
<span class="w"> </span>_QUOTING_DELIMITERS = {&#39;&quot;&#39;}
<span class="gi">+</span>
<span class="w"> </span>EOF = 0
<span class="w"> </span>EOL = 1
<span class="w"> </span>WHITESPACE = 2
<span class="gu">@@ -28,14 +49,44 @@ class Token:</span>
<span class="w"> </span>    has_escape: Does the token value contain escapes?
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, ttype: int, value: Any=&#39;&#39;, has_escape: bool=False,</span>
<span class="gd">-        comment: Optional[str]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ttype: int,</span>
<span class="gi">+        value: Any = &quot;&quot;,</span>
<span class="gi">+        has_escape: bool = False,</span>
<span class="gi">+        comment: Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a token instance.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.ttype = ttype
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.has_escape = has_escape
<span class="w"> </span>        self.comment = comment

<span class="gi">+    def is_eof(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == EOF</span>
<span class="gi">+</span>
<span class="gi">+    def is_eol(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == EOL</span>
<span class="gi">+</span>
<span class="gi">+    def is_whitespace(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == WHITESPACE</span>
<span class="gi">+</span>
<span class="gi">+    def is_identifier(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == IDENTIFIER</span>
<span class="gi">+</span>
<span class="gi">+    def is_quoted_string(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == QUOTED_STRING</span>
<span class="gi">+</span>
<span class="gi">+    def is_comment(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == COMMENT</span>
<span class="gi">+</span>
<span class="gi">+    def is_delimiter(self) -&gt; bool:  # pragma: no cover (we don&#39;t return delimiters yet)</span>
<span class="gi">+        return self.ttype == DELIMITER</span>
<span class="gi">+</span>
<span class="gi">+    def is_eol_or_eof(self) -&gt; bool:</span>
<span class="gi">+        return self.ttype == EOL or self.ttype == EOF</span>
<span class="gi">+</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Token):
<span class="w"> </span>            return False
<span class="gu">@@ -49,6 +100,100 @@ class Token:</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return &#39;%d &quot;%s&quot;&#39; % (self.ttype, self.value)

<span class="gi">+    def unescape(self) -&gt; &quot;Token&quot;:</span>
<span class="gi">+        if not self.has_escape:</span>
<span class="gi">+            return self</span>
<span class="gi">+        unescaped = &quot;&quot;</span>
<span class="gi">+        l = len(self.value)</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while i &lt; l:</span>
<span class="gi">+            c = self.value[i]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            if c == &quot;\\&quot;:</span>
<span class="gi">+                if i &gt;= l:  # pragma: no cover   (can&#39;t happen via get())</span>
<span class="gi">+                    raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                c = self.value[i]</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                if c.isdigit():</span>
<span class="gi">+                    if i &gt;= l:</span>
<span class="gi">+                        raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                    c2 = self.value[i]</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+                    if i &gt;= l:</span>
<span class="gi">+                        raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                    c3 = self.value[i]</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+                    if not (c2.isdigit() and c3.isdigit()):</span>
<span class="gi">+                        raise dns.exception.SyntaxError</span>
<span class="gi">+                    codepoint = int(c) * 100 + int(c2) * 10 + int(c3)</span>
<span class="gi">+                    if codepoint &gt; 255:</span>
<span class="gi">+                        raise dns.exception.SyntaxError</span>
<span class="gi">+                    c = chr(codepoint)</span>
<span class="gi">+            unescaped += c</span>
<span class="gi">+        return Token(self.ttype, unescaped)</span>
<span class="gi">+</span>
<span class="gi">+    def unescape_to_bytes(self) -&gt; &quot;Token&quot;:</span>
<span class="gi">+        # We used to use unescape() for TXT-like records, but this</span>
<span class="gi">+        # caused problems as we&#39;d process DNS escapes into Unicode code</span>
<span class="gi">+        # points instead of byte values, and then a to_text() of the</span>
<span class="gi">+        # processed data would not equal the original input.  For</span>
<span class="gi">+        # example, \226 in the TXT record would have a to_text() of</span>
<span class="gi">+        # \195\162 because we applied UTF-8 encoding to Unicode code</span>
<span class="gi">+        # point 226.</span>
<span class="gi">+        #</span>
<span class="gi">+        # We now apply escapes while converting directly to bytes,</span>
<span class="gi">+        # avoiding this double encoding.</span>
<span class="gi">+        #</span>
<span class="gi">+        # This code also handles cases where the unicode input has</span>
<span class="gi">+        # non-ASCII code-points in it by converting it to UTF-8.  TXT</span>
<span class="gi">+        # records aren&#39;t defined for Unicode, but this is the best we</span>
<span class="gi">+        # can do to preserve meaning.  For example,</span>
<span class="gi">+        #</span>
<span class="gi">+        #     foo\u200bbar</span>
<span class="gi">+        #</span>
<span class="gi">+        # (where \u200b is Unicode code point 0x200b) will be treated</span>
<span class="gi">+        # as if the input had been the UTF-8 encoding of that string,</span>
<span class="gi">+        # namely:</span>
<span class="gi">+        #</span>
<span class="gi">+        #     foo\226\128\139bar</span>
<span class="gi">+        #</span>
<span class="gi">+        unescaped = b&quot;&quot;</span>
<span class="gi">+        l = len(self.value)</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while i &lt; l:</span>
<span class="gi">+            c = self.value[i]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            if c == &quot;\\&quot;:</span>
<span class="gi">+                if i &gt;= l:  # pragma: no cover   (can&#39;t happen via get())</span>
<span class="gi">+                    raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                c = self.value[i]</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                if c.isdigit():</span>
<span class="gi">+                    if i &gt;= l:</span>
<span class="gi">+                        raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                    c2 = self.value[i]</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+                    if i &gt;= l:</span>
<span class="gi">+                        raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                    c3 = self.value[i]</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+                    if not (c2.isdigit() and c3.isdigit()):</span>
<span class="gi">+                        raise dns.exception.SyntaxError</span>
<span class="gi">+                    codepoint = int(c) * 100 + int(c2) * 10 + int(c3)</span>
<span class="gi">+                    if codepoint &gt; 255:</span>
<span class="gi">+                        raise dns.exception.SyntaxError</span>
<span class="gi">+                    unescaped += b&quot;%c&quot; % (codepoint)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Note that as mentioned above, if c is a Unicode</span>
<span class="gi">+                    # code point outside of the ASCII range, then this</span>
<span class="gi">+                    # += is converting that code point to its UTF-8</span>
<span class="gi">+                    # encoding and appending multiple bytes to</span>
<span class="gi">+                    # unescaped.</span>
<span class="gi">+                    unescaped += c.encode()</span>
<span class="gi">+            else:</span>
<span class="gi">+                unescaped += c.encode()</span>
<span class="gi">+        return Token(self.ttype, bytes(unescaped))</span>
<span class="gi">+</span>

<span class="w"> </span>class Tokenizer:
<span class="w"> </span>    &quot;&quot;&quot;A DNS zone file format tokenizer.
<span class="gu">@@ -83,8 +228,12 @@ class Tokenizer:</span>
<span class="w"> </span>    encoder/decoder is used.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, f: Any=sys.stdin, filename: Optional[str]=None,</span>
<span class="gd">-        idna_codec: Optional[dns.name.IDNACodec]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        f: Any = sys.stdin,</span>
<span class="gi">+        filename: Optional[str] = None,</span>
<span class="gi">+        idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a tokenizer instance.

<span class="w"> </span>        f: The file to tokenize.  The default is sys.stdin.
<span class="gu">@@ -98,19 +247,21 @@ class Tokenizer:</span>
<span class="w"> </span>        encoder/decoder.  If None, the default IDNA 2003
<span class="w"> </span>        encoder/decoder is used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(f, str):
<span class="w"> </span>            f = io.StringIO(f)
<span class="w"> </span>            if filename is None:
<span class="gd">-                filename = &#39;&lt;string&gt;&#39;</span>
<span class="gi">+                filename = &quot;&lt;string&gt;&quot;</span>
<span class="w"> </span>        elif isinstance(f, bytes):
<span class="w"> </span>            f = io.StringIO(f.decode())
<span class="w"> </span>            if filename is None:
<span class="gd">-                filename = &#39;&lt;string&gt;&#39;</span>
<span class="gd">-        elif filename is None:</span>
<span class="gd">-            if f is sys.stdin:</span>
<span class="gd">-                filename = &#39;&lt;stdin&gt;&#39;</span>
<span class="gd">-            else:</span>
<span class="gd">-                filename = &#39;&lt;file&gt;&#39;</span>
<span class="gi">+                filename = &quot;&lt;string&gt;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            if filename is None:</span>
<span class="gi">+                if f is sys.stdin:</span>
<span class="gi">+                    filename = &quot;&lt;stdin&gt;&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    filename = &quot;&lt;file&gt;&quot;</span>
<span class="w"> </span>        self.file = f
<span class="w"> </span>        self.ungotten_char: Optional[str] = None
<span class="w"> </span>        self.ungotten_token: Optional[Token] = None
<span class="gu">@@ -126,19 +277,33 @@ class Tokenizer:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.idna_codec = idna_codec

<span class="gd">-    def _get_char(self) -&gt;str:</span>
<span class="gi">+    def _get_char(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read a character from input.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def where(self) -&gt;Tuple[str, int]:</span>
<span class="gi">+        if self.ungotten_char is None:</span>
<span class="gi">+            if self.eof:</span>
<span class="gi">+                c = &quot;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                c = self.file.read(1)</span>
<span class="gi">+                if c == &quot;&quot;:</span>
<span class="gi">+                    self.eof = True</span>
<span class="gi">+                elif c == &quot;\n&quot;:</span>
<span class="gi">+                    self.line_number += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            c = self.ungotten_char</span>
<span class="gi">+            self.ungotten_char = None</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def where(self) -&gt; Tuple[str, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current location in the input.

<span class="w"> </span>        Returns a (string, int) tuple.  The first item is the filename of
<span class="w"> </span>        the input, the second is the current line number.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _unget_char(self, c: str) -&gt;None:</span>
<span class="gi">+        return (self.filename, self.line_number)</span>
<span class="gi">+</span>
<span class="gi">+    def _unget_char(self, c: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unget a character.

<span class="w"> </span>        The unget buffer for characters is only one character large; it is
<span class="gu">@@ -148,9 +313,13 @@ class Tokenizer:</span>
<span class="w"> </span>        c: the character to unget
<span class="w"> </span>        raises UngetBufferFull: there is already an ungotten char
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def skip_whitespace(self) -&gt;int:</span>
<span class="gi">+        if self.ungotten_char is not None:</span>
<span class="gi">+            # this should never happen!</span>
<span class="gi">+            raise UngetBufferFull  # pragma: no cover</span>
<span class="gi">+        self.ungotten_char = c</span>
<span class="gi">+</span>
<span class="gi">+    def skip_whitespace(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Consume input until a non-whitespace character is encountered.

<span class="w"> </span>        The non-whitespace character is then ungotten, and the number of
<span class="gu">@@ -160,9 +329,17 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns the number of characters skipped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get(self, want_leading: bool=False, want_comment: bool=False) -&gt;Token:</span>
<span class="gi">+        skipped = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = self._get_char()</span>
<span class="gi">+            if c != &quot; &quot; and c != &quot;\t&quot;:</span>
<span class="gi">+                if (c != &quot;\n&quot;) or not self.multiline:</span>
<span class="gi">+                    self._unget_char(c)</span>
<span class="gi">+                    return skipped</span>
<span class="gi">+            skipped += 1</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, want_leading: bool = False, want_comment: bool = False) -&gt; Token:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the next token.

<span class="w"> </span>        want_leading: If True, return a WHITESPACE token if the
<span class="gu">@@ -177,9 +354,103 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a Token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def unget(self, token: Token) -&gt;None:</span>
<span class="gi">+        if self.ungotten_token is not None:</span>
<span class="gi">+            utoken = self.ungotten_token</span>
<span class="gi">+            self.ungotten_token = None</span>
<span class="gi">+            if utoken.is_whitespace():</span>
<span class="gi">+                if want_leading:</span>
<span class="gi">+                    return utoken</span>
<span class="gi">+            elif utoken.is_comment():</span>
<span class="gi">+                if want_comment:</span>
<span class="gi">+                    return utoken</span>
<span class="gi">+            else:</span>
<span class="gi">+                return utoken</span>
<span class="gi">+        skipped = self.skip_whitespace()</span>
<span class="gi">+        if want_leading and skipped &gt; 0:</span>
<span class="gi">+            return Token(WHITESPACE, &quot; &quot;)</span>
<span class="gi">+        token = &quot;&quot;</span>
<span class="gi">+        ttype = IDENTIFIER</span>
<span class="gi">+        has_escape = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = self._get_char()</span>
<span class="gi">+            if c == &quot;&quot; or c in self.delimiters:</span>
<span class="gi">+                if c == &quot;&quot; and self.quoting:</span>
<span class="gi">+                    raise dns.exception.UnexpectedEnd</span>
<span class="gi">+                if token == &quot;&quot; and ttype != QUOTED_STRING:</span>
<span class="gi">+                    if c == &quot;(&quot;:</span>
<span class="gi">+                        self.multiline += 1</span>
<span class="gi">+                        self.skip_whitespace()</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    elif c == &quot;)&quot;:</span>
<span class="gi">+                        if self.multiline &lt;= 0:</span>
<span class="gi">+                            raise dns.exception.SyntaxError</span>
<span class="gi">+                        self.multiline -= 1</span>
<span class="gi">+                        self.skip_whitespace()</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    elif c == &#39;&quot;&#39;:</span>
<span class="gi">+                        if not self.quoting:</span>
<span class="gi">+                            self.quoting = True</span>
<span class="gi">+                            self.delimiters = _QUOTING_DELIMITERS</span>
<span class="gi">+                            ttype = QUOTED_STRING</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self.quoting = False</span>
<span class="gi">+                            self.delimiters = _DELIMITERS</span>
<span class="gi">+                            self.skip_whitespace()</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    elif c == &quot;\n&quot;:</span>
<span class="gi">+                        return Token(EOL, &quot;\n&quot;)</span>
<span class="gi">+                    elif c == &quot;;&quot;:</span>
<span class="gi">+                        while 1:</span>
<span class="gi">+                            c = self._get_char()</span>
<span class="gi">+                            if c == &quot;\n&quot; or c == &quot;&quot;:</span>
<span class="gi">+                                break</span>
<span class="gi">+                            token += c</span>
<span class="gi">+                        if want_comment:</span>
<span class="gi">+                            self._unget_char(c)</span>
<span class="gi">+                            return Token(COMMENT, token)</span>
<span class="gi">+                        elif c == &quot;&quot;:</span>
<span class="gi">+                            if self.multiline:</span>
<span class="gi">+                                raise dns.exception.SyntaxError(</span>
<span class="gi">+                                    &quot;unbalanced parentheses&quot;</span>
<span class="gi">+                                )</span>
<span class="gi">+                            return Token(EOF, comment=token)</span>
<span class="gi">+                        elif self.multiline:</span>
<span class="gi">+                            self.skip_whitespace()</span>
<span class="gi">+                            token = &quot;&quot;</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            return Token(EOL, &quot;\n&quot;, comment=token)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # This code exists in case we ever want a</span>
<span class="gi">+                        # delimiter to be returned.  It never produces</span>
<span class="gi">+                        # a token currently.</span>
<span class="gi">+                        token = c</span>
<span class="gi">+                        ttype = DELIMITER</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._unget_char(c)</span>
<span class="gi">+                break</span>
<span class="gi">+            elif self.quoting and c == &quot;\n&quot;:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;newline in quoted string&quot;)</span>
<span class="gi">+            elif c == &quot;\\&quot;:</span>
<span class="gi">+                #</span>
<span class="gi">+                # It&#39;s an escape.  Put it and the next character into</span>
<span class="gi">+                # the token; it will be checked later for goodness.</span>
<span class="gi">+                #</span>
<span class="gi">+                token += c</span>
<span class="gi">+                has_escape = True</span>
<span class="gi">+                c = self._get_char()</span>
<span class="gi">+                if c == &quot;&quot; or (c == &quot;\n&quot; and not self.quoting):</span>
<span class="gi">+                    raise dns.exception.UnexpectedEnd</span>
<span class="gi">+            token += c</span>
<span class="gi">+        if token == &quot;&quot; and ttype != QUOTED_STRING:</span>
<span class="gi">+            if self.multiline:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;unbalanced parentheses&quot;)</span>
<span class="gi">+            ttype = EOF</span>
<span class="gi">+        return Token(ttype, token, has_escape)</span>
<span class="gi">+</span>
<span class="gi">+    def unget(self, token: Token) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unget a token.

<span class="w"> </span>        The unget buffer for tokens is only one token large; it is
<span class="gu">@@ -190,29 +461,45 @@ class Tokenizer:</span>

<span class="w"> </span>        Raises UngetBufferFull: there is already an ungotten token
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if self.ungotten_token is not None:</span>
<span class="gi">+            raise UngetBufferFull</span>
<span class="gi">+        self.ungotten_token = token</span>

<span class="w"> </span>    def next(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the next item in an iteration.

<span class="w"> </span>        Returns a Token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if token.is_eof():</span>
<span class="gi">+            raise StopIteration</span>
<span class="gi">+        return token</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return self

<span class="gd">-    def get_int(self, base: int=10) -&gt;int:</span>
<span class="gi">+    # Helpers</span>
<span class="gi">+</span>
<span class="gi">+    def get_int(self, base: int = 10) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as an unsigned integer.

<span class="w"> </span>        Raises dns.exception.SyntaxError if not an unsigned integer.

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_uint8(self) -&gt;int:</span>
<span class="gi">+        token = self.get().unescape()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting an identifier&quot;)</span>
<span class="gi">+        if not token.value.isdigit():</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting an integer&quot;)</span>
<span class="gi">+        return int(token.value, base)</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint8(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as an 8-bit unsigned
<span class="w"> </span>        integer.

<span class="gu">@@ -220,9 +507,15 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_uint16(self, base: int=10) -&gt;int:</span>
<span class="gi">+        value = self.get_int()</span>
<span class="gi">+        if value &lt; 0 or value &gt; 255:</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                &quot;%d is not an unsigned 8-bit integer&quot; % value</span>
<span class="gi">+            )</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint16(self, base: int = 10) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a 16-bit unsigned
<span class="w"> </span>        integer.

<span class="gu">@@ -230,9 +523,20 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_uint32(self, base: int=10) -&gt;int:</span>
<span class="gi">+        value = self.get_int(base=base)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 65535:</span>
<span class="gi">+            if base == 8:</span>
<span class="gi">+                raise dns.exception.SyntaxError(</span>
<span class="gi">+                    &quot;%o is not an octal unsigned 16-bit integer&quot; % value</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise dns.exception.SyntaxError(</span>
<span class="gi">+                    &quot;%d is not an unsigned 16-bit integer&quot; % value</span>
<span class="gi">+                )</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint32(self, base: int = 10) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a 32-bit unsigned
<span class="w"> </span>        integer.

<span class="gu">@@ -240,9 +544,15 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_uint48(self, base: int=10) -&gt;int:</span>
<span class="gi">+        value = self.get_int(base=base)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 4294967295:</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                &quot;%d is not an unsigned 32-bit integer&quot; % value</span>
<span class="gi">+            )</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint48(self, base: int = 10) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a 48-bit unsigned
<span class="w"> </span>        integer.

<span class="gu">@@ -250,9 +560,15 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_string(self, max_length: Optional[int]=None) -&gt;str:</span>
<span class="gi">+        value = self.get_int(base=base)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 281474976710655:</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                &quot;%d is not an unsigned 48-bit integer&quot; % value</span>
<span class="gi">+            )</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def get_string(self, max_length: Optional[int] = None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a string.

<span class="w"> </span>        Raises dns.exception.SyntaxError if not a string.
<span class="gu">@@ -261,27 +577,47 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_identifier(self) -&gt;str:</span>
<span class="gi">+        token = self.get().unescape()</span>
<span class="gi">+        if not (token.is_identifier() or token.is_quoted_string()):</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting a string&quot;)</span>
<span class="gi">+        if max_length and len(token.value) &gt; max_length:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;string too long&quot;)</span>
<span class="gi">+        return token.value</span>
<span class="gi">+</span>
<span class="gi">+    def get_identifier(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token, which should be an identifier.

<span class="w"> </span>        Raises dns.exception.SyntaxError if not an identifier.

<span class="w"> </span>        Returns a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_remaining(self, max_tokens: Optional[int]=None) -&gt;List[Token]:</span>
<span class="gi">+        token = self.get().unescape()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting an identifier&quot;)</span>
<span class="gi">+        return token.value</span>
<span class="gi">+</span>
<span class="gi">+    def get_remaining(self, max_tokens: Optional[int] = None) -&gt; List[Token]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the remaining tokens on the line, until an EOL or EOF is seen.

<span class="w"> </span>        max_tokens: If not None, stop after this number of tokens.

<span class="w"> </span>        Returns a list of tokens.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def concatenate_remaining_identifiers(self, allow_empty: bool=False) -&gt;str:</span>
<span class="gi">+        tokens = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token = self.get()</span>
<span class="gi">+            if token.is_eol_or_eof():</span>
<span class="gi">+                self.unget(token)</span>
<span class="gi">+                break</span>
<span class="gi">+            tokens.append(token)</span>
<span class="gi">+            if len(tokens) == max_tokens:</span>
<span class="gi">+                break</span>
<span class="gi">+        return tokens</span>
<span class="gi">+</span>
<span class="gi">+    def concatenate_remaining_identifiers(self, allow_empty: bool = False) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the remaining tokens on the line, which should be identifiers.

<span class="w"> </span>        Raises dns.exception.SyntaxError if there are no remaining tokens,
<span class="gu">@@ -293,39 +629,71 @@ class Tokenizer:</span>
<span class="w"> </span>        Returns a string containing a concatenation of the remaining
<span class="w"> </span>        identifiers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def as_name(self, token: Token, origin: Optional[dns.name.Name]=None,</span>
<span class="gd">-        relativize: bool=False, relativize_to: Optional[dns.name.Name]=None</span>
<span class="gd">-        ) -&gt;dns.name.Name:</span>
<span class="gi">+        s = &quot;&quot;</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token = self.get().unescape()</span>
<span class="gi">+            if token.is_eol_or_eof():</span>
<span class="gi">+                self.unget(token)</span>
<span class="gi">+                break</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+            s += token.value</span>
<span class="gi">+        if not (allow_empty or s):</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting another identifier&quot;)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def as_name(</span>
<span class="gi">+        self,</span>
<span class="gi">+        token: Token,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = False,</span>
<span class="gi">+        relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+    ) -&gt; dns.name.Name:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to interpret the token as a DNS name.

<span class="w"> </span>        Raises dns.exception.SyntaxError if not a name.

<span class="w"> </span>        Returns a dns.name.Name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_name(self, origin: Optional[dns.name.Name]=None, relativize:</span>
<span class="gd">-        bool=False, relativize_to: Optional[dns.name.Name]=None</span>
<span class="gd">-        ) -&gt;dns.name.Name:</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting an identifier&quot;)</span>
<span class="gi">+        name = dns.name.from_text(token.value, origin, self.idna_codec)</span>
<span class="gi">+        return name.choose_relativity(relativize_to or origin, relativize)</span>
<span class="gi">+</span>
<span class="gi">+    def get_name(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+        relativize: bool = False,</span>
<span class="gi">+        relativize_to: Optional[dns.name.Name] = None,</span>
<span class="gi">+    ) -&gt; dns.name.Name:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a DNS name.

<span class="w"> </span>        Raises dns.exception.SyntaxError if not a name.

<span class="w"> </span>        Returns a dns.name.Name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_eol_as_token(self) -&gt;Token:</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        return self.as_name(token, origin, relativize, relativize_to)</span>
<span class="gi">+</span>
<span class="gi">+    def get_eol_as_token(self) -&gt; Token:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and raise an exception if it isn&#39;t EOL or
<span class="w"> </span>        EOF.

<span class="w"> </span>        Returns a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_ttl(self) -&gt;int:</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if not token.is_eol_or_eof():</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                &#39;expected EOL or EOF, got %d &quot;%s&quot;&#39; % (token.ttype, token.value)</span>
<span class="gi">+            )</span>
<span class="gi">+        return token</span>
<span class="gi">+</span>
<span class="gi">+    def get_eol(self) -&gt; str:</span>
<span class="gi">+        return self.get_eol_as_token().value</span>
<span class="gi">+</span>
<span class="gi">+    def get_ttl(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a DNS TTL.

<span class="w"> </span>        Raises dns.exception.SyntaxError or dns.ttl.BadTTL if not an
<span class="gu">@@ -333,4 +701,8 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        token = self.get().unescape()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;expecting an identifier&quot;)</span>
<span class="gi">+        return dns.ttl.from_text(token.value)</span>
<span class="gh">diff --git a/dns/transaction.py b/dns/transaction.py</span>
<span class="gh">index 3acb2f4..84e54f7 100644</span>
<span class="gd">--- a/dns/transaction.py</span>
<span class="gi">+++ b/dns/transaction.py</span>
<span class="gu">@@ -1,5 +1,8 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>from typing import Any, Callable, Iterator, List, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.node
<span class="gu">@@ -12,12 +15,11 @@ import dns.ttl</span>


<span class="w"> </span>class TransactionManager:
<span class="gd">-</span>
<span class="gd">-    def reader(self) -&gt;&#39;Transaction&#39;:</span>
<span class="gi">+    def reader(self) -&gt; &quot;Transaction&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin a read-only transaction.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="gd">-    def writer(self, replacement: bool=False) -&gt;&#39;Transaction&#39;:</span>
<span class="gi">+    def writer(self, replacement: bool = False) -&gt; &quot;Transaction&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin a writable transaction.

<span class="w"> </span>        *replacement*, a ``bool``.  If `True`, the content of the
<span class="gu">@@ -25,10 +27,11 @@ class TransactionManager:</span>
<span class="w"> </span>        the default, then the content of the transaction updates the
<span class="w"> </span>        existing content.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="gd">-    def origin_information(self) -&gt;Tuple[Optional[dns.name.Name], bool,</span>
<span class="gd">-        Optional[dns.name.Name]]:</span>
<span class="gi">+    def origin_information(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Tuple[Optional[dns.name.Name], bool, Optional[dns.name.Name]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a tuple

<span class="w"> </span>            (absolute_origin, relativize, effective_origin)
<span class="gu">@@ -51,15 +54,19 @@ class TransactionManager:</span>
<span class="w"> </span>        relativity).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="gd">-    def get_class(self) -&gt;dns.rdataclass.RdataClass:</span>
<span class="gi">+    def get_class(self) -&gt; dns.rdataclass.RdataClass:</span>
<span class="w"> </span>        &quot;&quot;&quot;The class of the transaction manager.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="gd">-    def from_wire_origin(self) -&gt;Optional[dns.name.Name]:</span>
<span class="gi">+    def from_wire_origin(self) -&gt; Optional[dns.name.Name]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Origin to use in from_wire() calls.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        (absolute_origin, relativize, _) = self.origin_information()</span>
<span class="gi">+        if relativize:</span>
<span class="gi">+            return absolute_origin</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>class DeleteNotExact(dns.exception.DNSException):
<span class="gu">@@ -74,17 +81,35 @@ class AlreadyEnded(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;Tried to use an already-ended transaction.&quot;&quot;&quot;


<span class="gd">-CheckPutRdatasetType = Callable[[&#39;Transaction&#39;, dns.name.Name, dns.rdataset</span>
<span class="gd">-    .Rdataset], None]</span>
<span class="gd">-CheckDeleteRdatasetType = Callable[[&#39;Transaction&#39;, dns.name.Name, dns.</span>
<span class="gd">-    rdatatype.RdataType, dns.rdatatype.RdataType], None]</span>
<span class="gd">-CheckDeleteNameType = Callable[[&#39;Transaction&#39;, dns.name.Name], None]</span>
<span class="gi">+def _ensure_immutable_rdataset(rdataset):</span>
<span class="gi">+    if rdataset is None or isinstance(rdataset, dns.rdataset.ImmutableRdataset):</span>
<span class="gi">+        return rdataset</span>
<span class="gi">+    return dns.rdataset.ImmutableRdataset(rdataset)</span>


<span class="gd">-class Transaction:</span>
<span class="gi">+def _ensure_immutable_node(node):</span>
<span class="gi">+    if node is None or node.is_immutable():</span>
<span class="gi">+        return node</span>
<span class="gi">+    return dns.node.ImmutableNode(node)</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, manager: TransactionManager, replacement: bool=False,</span>
<span class="gd">-        read_only: bool=False):</span>
<span class="gi">+CheckPutRdatasetType = Callable[</span>
<span class="gi">+    [&quot;Transaction&quot;, dns.name.Name, dns.rdataset.Rdataset], None</span>
<span class="gi">+]</span>
<span class="gi">+CheckDeleteRdatasetType = Callable[</span>
<span class="gi">+    [&quot;Transaction&quot;, dns.name.Name, dns.rdatatype.RdataType, dns.rdatatype.RdataType],</span>
<span class="gi">+    None,</span>
<span class="gi">+]</span>
<span class="gi">+CheckDeleteNameType = Callable[[&quot;Transaction&quot;, dns.name.Name], None]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Transaction:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        manager: TransactionManager,</span>
<span class="gi">+        replacement: bool = False,</span>
<span class="gi">+        read_only: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.manager = manager
<span class="w"> </span>        self.replacement = replacement
<span class="w"> </span>        self.read_only = read_only
<span class="gu">@@ -93,24 +118,44 @@ class Transaction:</span>
<span class="w"> </span>        self._check_delete_rdataset: List[CheckDeleteRdatasetType] = []
<span class="w"> </span>        self._check_delete_name: List[CheckDeleteNameType] = []

<span class="gd">-    def get(self, name: Optional[Union[dns.name.Name, str]], rdtype: Union[</span>
<span class="gd">-        dns.rdatatype.RdataType, str], covers: Union[dns.rdatatype.</span>
<span class="gd">-        RdataType, str]=dns.rdatatype.NONE) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+    #</span>
<span class="gi">+    # This is the high level API</span>
<span class="gi">+    #</span>
<span class="gi">+    # Note that we currently use non-immutable types in the return type signature to</span>
<span class="gi">+    # avoid covariance problems, e.g. if the caller has a List[Rdataset], mypy will be</span>
<span class="gi">+    # unhappy if we return an ImmutableRdataset.</span>
<span class="gi">+</span>
<span class="gi">+    def get(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Optional[Union[dns.name.Name, str]],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the rdataset associated with *name*, *rdtype*, and *covers*,
<span class="w"> </span>        or `None` if not found.

<span class="w"> </span>        Note that the returned rdataset is immutable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_node(self, name: dns.name.Name) -&gt;Optional[dns.node.Node]:</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        rdataset = self._get_rdataset(name, rdtype, covers)</span>
<span class="gi">+        return _ensure_immutable_rdataset(rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def get_node(self, name: dns.name.Name) -&gt; Optional[dns.node.Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the node at *name*, if any.

<span class="w"> </span>        Returns an immutable node or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _ensure_immutable_node(self._get_node(name))</span>
<span class="gi">+</span>
<span class="gi">+    def _check_read_only(self) -&gt; None:</span>
<span class="gi">+        if self.read_only:</span>
<span class="gi">+            raise ReadOnly</span>

<span class="gd">-    def add(self, *args: Any) -&gt;None:</span>
<span class="gi">+    def add(self, *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add records.

<span class="w"> </span>        The arguments may be:
<span class="gu">@@ -121,9 +166,11 @@ class Transaction:</span>

<span class="w"> </span>            - name, ttl, rdata...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        self._check_read_only()</span>
<span class="gi">+        self._add(False, args)</span>

<span class="gd">-    def replace(self, *args: Any) -&gt;None:</span>
<span class="gi">+    def replace(self, *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace the existing rdataset at the name with the specified
<span class="w"> </span>        rdataset, or add the specified rdataset if there was no existing
<span class="w"> </span>        rdataset.
<span class="gu">@@ -140,9 +187,11 @@ class Transaction:</span>
<span class="w"> </span>        a delete of the name followed by one or more calls to add() or
<span class="w"> </span>        replace().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        self._check_read_only()</span>
<span class="gi">+        self._add(True, args)</span>

<span class="gd">-    def delete(self, *args: Any) -&gt;None:</span>
<span class="gi">+    def delete(self, *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete records.

<span class="w"> </span>        It is not an error if some of the records are not in the existing
<span class="gu">@@ -160,9 +209,11 @@ class Transaction:</span>

<span class="w"> </span>            - name, rdata...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        self._check_read_only()</span>
<span class="gi">+        self._delete(False, args)</span>

<span class="gd">-    def delete_exact(self, *args: Any) -&gt;None:</span>
<span class="gi">+    def delete_exact(self, *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete records.

<span class="w"> </span>        The arguments may be:
<span class="gu">@@ -181,14 +232,23 @@ class Transaction:</span>
<span class="w"> </span>        are not in the existing set.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        self._check_read_only()</span>
<span class="gi">+        self._delete(True, args)</span>

<span class="gd">-    def name_exists(self, name: Union[dns.name.Name, str]) -&gt;bool:</span>
<span class="gi">+    def name_exists(self, name: Union[dns.name.Name, str]) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Does the specified name exist?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def update_serial(self, value: int=1, relative: bool=True, name: dns.</span>
<span class="gd">-        name.Name=dns.name.empty) -&gt;None:</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        return self._name_exists(name)</span>
<span class="gi">+</span>
<span class="gi">+    def update_serial(</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: int = 1,</span>
<span class="gi">+        relative: bool = True,</span>
<span class="gi">+        name: dns.name.Name = dns.name.empty,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the serial number.

<span class="w"> </span>        *value*, an `int`, is an increment if *relative* is `True`, or the
<span class="gu">@@ -200,13 +260,30 @@ class Transaction:</span>
<span class="w"> </span>        so large that it would cause the new serial to be less than the
<span class="w"> </span>        prior value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if value &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;negative update_serial() value&quot;)</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        rdataset = self._get_rdataset(name, dns.rdatatype.SOA, dns.rdatatype.NONE)</span>
<span class="gi">+        if rdataset is None or len(rdataset) == 0:</span>
<span class="gi">+            raise KeyError</span>
<span class="gi">+        if relative:</span>
<span class="gi">+            serial = dns.serial.Serial(rdataset[0].serial) + value</span>
<span class="gi">+        else:</span>
<span class="gi">+            serial = dns.serial.Serial(value)</span>
<span class="gi">+        serial = serial.value  # convert back to int</span>
<span class="gi">+        if serial == 0:</span>
<span class="gi">+            serial = 1</span>
<span class="gi">+        rdata = rdataset[0].replace(serial=serial)</span>
<span class="gi">+        new_rdataset = dns.rdataset.from_rdata(rdataset.ttl, rdata)</span>
<span class="gi">+        self.replace(name, new_rdataset)</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        self._check_ended()
<span class="w"> </span>        return self._iterate_rdatasets()

<span class="gd">-    def changed(self) -&gt;bool:</span>
<span class="gi">+    def changed(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Has this transaction changed anything?

<span class="w"> </span>        For read-only transactions, the result is always `False`.
<span class="gu">@@ -214,9 +291,10 @@ class Transaction:</span>
<span class="w"> </span>        For writable transactions, the result is `True` if at some time
<span class="w"> </span>        during the life of the transaction, the content was changed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        return self._changed()</span>

<span class="gd">-    def commit(self) -&gt;None:</span>
<span class="gi">+    def commit(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Commit the transaction.

<span class="w"> </span>        Normally transactions are used as context managers and commit
<span class="gu">@@ -227,9 +305,9 @@ class Transaction:</span>
<span class="w"> </span>        Raises an exception if the commit fails (in which case the transaction
<span class="w"> </span>        is also rolled back.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._end(True)</span>

<span class="gd">-    def rollback(self) -&gt;None:</span>
<span class="gi">+    def rollback(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Rollback the transaction.

<span class="w"> </span>        Normally transactions are used as context managers and commit
<span class="gu">@@ -239,9 +317,9 @@ class Transaction:</span>

<span class="w"> </span>        Rollback cannot otherwise fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._end(False)</span>

<span class="gd">-    def check_put_rdataset(self, check: CheckPutRdatasetType) -&gt;None:</span>
<span class="gi">+    def check_put_rdataset(self, check: CheckPutRdatasetType) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call *check* before putting (storing) an rdataset.

<span class="w"> </span>        The function is called with the transaction, the name, and the rdataset.
<span class="gu">@@ -251,9 +329,9 @@ class Transaction:</span>
<span class="w"> </span>        called.  The check function should raise an exception if it objects to
<span class="w"> </span>        the put, and otherwise should return ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_put_rdataset.append(check)</span>

<span class="gd">-    def check_delete_rdataset(self, check: CheckDeleteRdatasetType) -&gt;None:</span>
<span class="gi">+    def check_delete_rdataset(self, check: CheckDeleteRdatasetType) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call *check* before deleting an rdataset.

<span class="w"> </span>        The function is called with the transaction, the name, the rdatatype,
<span class="gu">@@ -264,9 +342,9 @@ class Transaction:</span>
<span class="w"> </span>        called.  The check function should raise an exception if it objects to
<span class="w"> </span>        the put, and otherwise should return ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_delete_rdataset.append(check)</span>

<span class="gd">-    def check_delete_name(self, check: CheckDeleteNameType) -&gt;None:</span>
<span class="gi">+    def check_delete_name(self, check: CheckDeleteNameType) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call *check* before putting (storing) an rdataset.

<span class="w"> </span>        The function is called with the transaction and the name.
<span class="gu">@@ -276,25 +354,206 @@ class Transaction:</span>
<span class="w"> </span>        called.  The check function should raise an exception if it objects to
<span class="w"> </span>        the put, and otherwise should return ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_delete_name.append(check)</span>

<span class="gd">-    def iterate_rdatasets(self) -&gt;Iterator[Tuple[dns.name.Name, dns.</span>
<span class="gd">-        rdataset.Rdataset]]:</span>
<span class="gi">+    def iterate_rdatasets(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Iterator[Tuple[dns.name.Name, dns.rdataset.Rdataset]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate all the rdatasets in the transaction, returning
<span class="w"> </span>        (`dns.name.Name`, `dns.rdataset.Rdataset`) tuples.

<span class="w"> </span>        Note that as is usual with python iterators, adding or removing items
<span class="w"> </span>        while iterating will invalidate the iterator and may raise `RuntimeError`
<span class="w"> </span>        or fail to iterate over all entries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        return self._iterate_rdatasets()</span>

<span class="gd">-    def iterate_names(self) -&gt;Iterator[dns.name.Name]:</span>
<span class="gi">+    def iterate_names(self) -&gt; Iterator[dns.name.Name]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate all the names in the transaction.

<span class="w"> </span>        Note that as is usual with python iterators, adding or removing names
<span class="w"> </span>        while iterating will invalidate the iterator and may raise `RuntimeError`
<span class="w"> </span>        or fail to iterate over all entries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        return self._iterate_names()</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # Helper methods</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    def _raise_if_not_empty(self, method, args):</span>
<span class="gi">+        if len(args) != 0:</span>
<span class="gi">+            raise TypeError(f&quot;extra parameters to {method}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _rdataset_from_args(self, method, deleting, args):</span>
<span class="gi">+        try:</span>
<span class="gi">+            arg = args.popleft()</span>
<span class="gi">+            if isinstance(arg, dns.rrset.RRset):</span>
<span class="gi">+                rdataset = arg.to_rdataset()</span>
<span class="gi">+            elif isinstance(arg, dns.rdataset.Rdataset):</span>
<span class="gi">+                rdataset = arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                if deleting:</span>
<span class="gi">+                    ttl = 0</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if isinstance(arg, int):</span>
<span class="gi">+                        ttl = arg</span>
<span class="gi">+                        if ttl &gt; dns.ttl.MAX_TTL:</span>
<span class="gi">+                            raise ValueError(f&quot;{method}: TTL value too big&quot;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise TypeError(f&quot;{method}: expected a TTL&quot;)</span>
<span class="gi">+                    arg = args.popleft()</span>
<span class="gi">+                if isinstance(arg, dns.rdata.Rdata):</span>
<span class="gi">+                    rdataset = dns.rdataset.from_rdata(ttl, arg)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise TypeError(f&quot;{method}: expected an Rdata&quot;)</span>
<span class="gi">+            return rdataset</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            if deleting:</span>
<span class="gi">+                return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                # reraise</span>
<span class="gi">+                raise TypeError(f&quot;{method}: expected more arguments&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _add(self, replace, args):</span>
<span class="gi">+        try:</span>
<span class="gi">+            args = collections.deque(args)</span>
<span class="gi">+            if replace:</span>
<span class="gi">+                method = &quot;replace()&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                method = &quot;add()&quot;</span>
<span class="gi">+            arg = args.popleft()</span>
<span class="gi">+            if isinstance(arg, str):</span>
<span class="gi">+                arg = dns.name.from_text(arg, None)</span>
<span class="gi">+            if isinstance(arg, dns.name.Name):</span>
<span class="gi">+                name = arg</span>
<span class="gi">+                rdataset = self._rdataset_from_args(method, False, args)</span>
<span class="gi">+            elif isinstance(arg, dns.rrset.RRset):</span>
<span class="gi">+                rrset = arg</span>
<span class="gi">+                name = rrset.name</span>
<span class="gi">+                # rrsets are also rdatasets, but they don&#39;t print the</span>
<span class="gi">+                # same and can&#39;t be stored in nodes, so convert.</span>
<span class="gi">+                rdataset = rrset.to_rdataset()</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;{method} requires a name or RRset as the first argument&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if rdataset.rdclass != self.manager.get_class():</span>
<span class="gi">+                raise ValueError(f&quot;{method} has objects of wrong RdataClass&quot;)</span>
<span class="gi">+            if rdataset.rdtype == dns.rdatatype.SOA:</span>
<span class="gi">+                (_, _, origin) = self._origin_information()</span>
<span class="gi">+                if name != origin:</span>
<span class="gi">+                    raise ValueError(f&quot;{method} has non-origin SOA&quot;)</span>
<span class="gi">+            self._raise_if_not_empty(method, args)</span>
<span class="gi">+            if not replace:</span>
<span class="gi">+                existing = self._get_rdataset(name, rdataset.rdtype, rdataset.covers)</span>
<span class="gi">+                if existing is not None:</span>
<span class="gi">+                    if isinstance(existing, dns.rdataset.ImmutableRdataset):</span>
<span class="gi">+                        trds = dns.rdataset.Rdataset(</span>
<span class="gi">+                            existing.rdclass, existing.rdtype, existing.covers</span>
<span class="gi">+                        )</span>
<span class="gi">+                        trds.update(existing)</span>
<span class="gi">+                        existing = trds</span>
<span class="gi">+                    rdataset = existing.union(rdataset)</span>
<span class="gi">+            self._checked_put_rdataset(name, rdataset)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise TypeError(f&quot;not enough parameters to {method}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _delete(self, exact, args):</span>
<span class="gi">+        try:</span>
<span class="gi">+            args = collections.deque(args)</span>
<span class="gi">+            if exact:</span>
<span class="gi">+                method = &quot;delete_exact()&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                method = &quot;delete()&quot;</span>
<span class="gi">+            arg = args.popleft()</span>
<span class="gi">+            if isinstance(arg, str):</span>
<span class="gi">+                arg = dns.name.from_text(arg, None)</span>
<span class="gi">+            if isinstance(arg, dns.name.Name):</span>
<span class="gi">+                name = arg</span>
<span class="gi">+                if len(args) &gt; 0 and (</span>
<span class="gi">+                    isinstance(args[0], int) or isinstance(args[0], str)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # deleting by type and (optionally) covers</span>
<span class="gi">+                    rdtype = dns.rdatatype.RdataType.make(args.popleft())</span>
<span class="gi">+                    if len(args) &gt; 0:</span>
<span class="gi">+                        covers = dns.rdatatype.RdataType.make(args.popleft())</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        covers = dns.rdatatype.NONE</span>
<span class="gi">+                    self._raise_if_not_empty(method, args)</span>
<span class="gi">+                    existing = self._get_rdataset(name, rdtype, covers)</span>
<span class="gi">+                    if existing is None:</span>
<span class="gi">+                        if exact:</span>
<span class="gi">+                            raise DeleteNotExact(f&quot;{method}: missing rdataset&quot;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._delete_rdataset(name, rdtype, covers)</span>
<span class="gi">+                    return</span>
<span class="gi">+                else:</span>
<span class="gi">+                    rdataset = self._rdataset_from_args(method, True, args)</span>
<span class="gi">+            elif isinstance(arg, dns.rrset.RRset):</span>
<span class="gi">+                rdataset = arg  # rrsets are also rdatasets</span>
<span class="gi">+                name = rdataset.name</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;{method} requires a name or RRset as the first argument&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            self._raise_if_not_empty(method, args)</span>
<span class="gi">+            if rdataset:</span>
<span class="gi">+                if rdataset.rdclass != self.manager.get_class():</span>
<span class="gi">+                    raise ValueError(f&quot;{method} has objects of wrong RdataClass&quot;)</span>
<span class="gi">+                existing = self._get_rdataset(name, rdataset.rdtype, rdataset.covers)</span>
<span class="gi">+                if existing is not None:</span>
<span class="gi">+                    if exact:</span>
<span class="gi">+                        intersection = existing.intersection(rdataset)</span>
<span class="gi">+                        if intersection != rdataset:</span>
<span class="gi">+                            raise DeleteNotExact(f&quot;{method}: missing rdatas&quot;)</span>
<span class="gi">+                    rdataset = existing.difference(rdataset)</span>
<span class="gi">+                    if len(rdataset) == 0:</span>
<span class="gi">+                        self._checked_delete_rdataset(</span>
<span class="gi">+                            name, rdataset.rdtype, rdataset.covers</span>
<span class="gi">+                        )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._checked_put_rdataset(name, rdataset)</span>
<span class="gi">+                elif exact:</span>
<span class="gi">+                    raise DeleteNotExact(f&quot;{method}: missing rdataset&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if exact and not self._name_exists(name):</span>
<span class="gi">+                    raise DeleteNotExact(f&quot;{method}: name not known&quot;)</span>
<span class="gi">+                self._checked_delete_name(name)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise TypeError(f&quot;not enough parameters to {method}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_ended(self):</span>
<span class="gi">+        if self._ended:</span>
<span class="gi">+            raise AlreadyEnded</span>
<span class="gi">+</span>
<span class="gi">+    def _end(self, commit):</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if self._ended:</span>
<span class="gi">+            raise AlreadyEnded</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._end_transaction(commit)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._ended = True</span>
<span class="gi">+</span>
<span class="gi">+    def _checked_put_rdataset(self, name, rdataset):</span>
<span class="gi">+        for check in self._check_put_rdataset:</span>
<span class="gi">+            check(self, name, rdataset)</span>
<span class="gi">+        self._put_rdataset(name, rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def _checked_delete_rdataset(self, name, rdtype, covers):</span>
<span class="gi">+        for check in self._check_delete_rdataset:</span>
<span class="gi">+            check(self, name, rdtype, covers)</span>
<span class="gi">+        self._delete_rdataset(name, rdtype, covers)</span>
<span class="gi">+</span>
<span class="gi">+    def _checked_delete_name(self, name):</span>
<span class="gi">+        for check in self._check_delete_name:</span>
<span class="gi">+            check(self, name)</span>
<span class="gi">+        self._delete_name(name)</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # Transactions are context managers.</span>
<span class="gi">+    #</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -307,40 +566,45 @@ class Transaction:</span>
<span class="w"> </span>                self.rollback()
<span class="w"> </span>        return False

<span class="gi">+    #</span>
<span class="gi">+    # This is the low level API, which must be implemented by subclasses</span>
<span class="gi">+    # of Transaction.</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="w"> </span>    def _get_rdataset(self, name, rdtype, covers):
<span class="w"> </span>        &quot;&quot;&quot;Return the rdataset associated with *name*, *rdtype*, and *covers*,
<span class="w"> </span>        or `None` if not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _put_rdataset(self, name, rdataset):
<span class="w"> </span>        &quot;&quot;&quot;Store the rdataset.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _delete_name(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Delete all data associated with *name*.

<span class="w"> </span>        It is not an error if the name does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _delete_rdataset(self, name, rdtype, covers):
<span class="w"> </span>        &quot;&quot;&quot;Delete all data associated with *name*, *rdtype*, and *covers*.

<span class="w"> </span>        It is not an error if the rdataset does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _name_exists(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Does name exist?

<span class="w"> </span>        Returns a bool.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _changed(self):
<span class="w"> </span>        &quot;&quot;&quot;Has this transaction changed anything?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _end_transaction(self, commit):
<span class="w"> </span>        &quot;&quot;&quot;End the transaction.
<span class="gu">@@ -351,7 +615,7 @@ class Transaction:</span>
<span class="w"> </span>        If committing and the commit fails, then roll back and raise an
<span class="w"> </span>        exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _set_origin(self, origin):
<span class="w"> </span>        &quot;&quot;&quot;Set the origin.
<span class="gu">@@ -360,19 +624,28 @@ class Transaction:</span>
<span class="w"> </span>        source, and an origin setting operation occurs (e.g. $ORIGIN
<span class="w"> </span>        in a zone file).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _iterate_rdatasets(self):
<span class="w"> </span>        &quot;&quot;&quot;Return an iterator that yields (name, rdataset) tuples.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _iterate_names(self):
<span class="w"> </span>        &quot;&quot;&quot;Return an iterator that yields a name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>

<span class="w"> </span>    def _get_node(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Return the node at *name*, if any.

<span class="w"> </span>        Returns a node or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # Low-level API with a default implementation, in case a subclass needs</span>
<span class="gi">+    # to override.</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    def _origin_information(self):</span>
<span class="gi">+        # This is only used by _add()</span>
<span class="gi">+        return self.manager.origin_information()</span>
<span class="gh">diff --git a/dns/tsig.py b/dns/tsig.py</span>
<span class="gh">index 38ac6a5..780852e 100644</span>
<span class="gd">--- a/dns/tsig.py</span>
<span class="gi">+++ b/dns/tsig.py</span>
<span class="gu">@@ -1,8 +1,27 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS TSIG support.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import hashlib
<span class="w"> </span>import hmac
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.rcode
<span class="gu">@@ -45,20 +64,33 @@ class PeerBadTruncation(PeerError):</span>
<span class="w"> </span>    &quot;&quot;&quot;The peer didn&#39;t like amount of truncation in the TSIG we sent&quot;&quot;&quot;


<span class="gd">-HMAC_MD5 = dns.name.from_text(&#39;HMAC-MD5.SIG-ALG.REG.INT&#39;)</span>
<span class="gd">-HMAC_SHA1 = dns.name.from_text(&#39;hmac-sha1&#39;)</span>
<span class="gd">-HMAC_SHA224 = dns.name.from_text(&#39;hmac-sha224&#39;)</span>
<span class="gd">-HMAC_SHA256 = dns.name.from_text(&#39;hmac-sha256&#39;)</span>
<span class="gd">-HMAC_SHA256_128 = dns.name.from_text(&#39;hmac-sha256-128&#39;)</span>
<span class="gd">-HMAC_SHA384 = dns.name.from_text(&#39;hmac-sha384&#39;)</span>
<span class="gd">-HMAC_SHA384_192 = dns.name.from_text(&#39;hmac-sha384-192&#39;)</span>
<span class="gd">-HMAC_SHA512 = dns.name.from_text(&#39;hmac-sha512&#39;)</span>
<span class="gd">-HMAC_SHA512_256 = dns.name.from_text(&#39;hmac-sha512-256&#39;)</span>
<span class="gd">-GSS_TSIG = dns.name.from_text(&#39;gss-tsig&#39;)</span>
<span class="gi">+# TSIG Algorithms</span>
<span class="gi">+</span>
<span class="gi">+HMAC_MD5 = dns.name.from_text(&quot;HMAC-MD5.SIG-ALG.REG.INT&quot;)</span>
<span class="gi">+HMAC_SHA1 = dns.name.from_text(&quot;hmac-sha1&quot;)</span>
<span class="gi">+HMAC_SHA224 = dns.name.from_text(&quot;hmac-sha224&quot;)</span>
<span class="gi">+HMAC_SHA256 = dns.name.from_text(&quot;hmac-sha256&quot;)</span>
<span class="gi">+HMAC_SHA256_128 = dns.name.from_text(&quot;hmac-sha256-128&quot;)</span>
<span class="gi">+HMAC_SHA384 = dns.name.from_text(&quot;hmac-sha384&quot;)</span>
<span class="gi">+HMAC_SHA384_192 = dns.name.from_text(&quot;hmac-sha384-192&quot;)</span>
<span class="gi">+HMAC_SHA512 = dns.name.from_text(&quot;hmac-sha512&quot;)</span>
<span class="gi">+HMAC_SHA512_256 = dns.name.from_text(&quot;hmac-sha512-256&quot;)</span>
<span class="gi">+GSS_TSIG = dns.name.from_text(&quot;gss-tsig&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>default_algorithm = HMAC_SHA256
<span class="gd">-mac_sizes = {HMAC_SHA1: 20, HMAC_SHA224: 28, HMAC_SHA256: 32,</span>
<span class="gd">-    HMAC_SHA256_128: 16, HMAC_SHA384: 48, HMAC_SHA384_192: 24, HMAC_SHA512:</span>
<span class="gd">-    64, HMAC_SHA512_256: 32, HMAC_MD5: 16, GSS_TSIG: 128}</span>
<span class="gi">+</span>
<span class="gi">+mac_sizes = {</span>
<span class="gi">+    HMAC_SHA1: 20,</span>
<span class="gi">+    HMAC_SHA224: 28,</span>
<span class="gi">+    HMAC_SHA256: 32,</span>
<span class="gi">+    HMAC_SHA256_128: 16,</span>
<span class="gi">+    HMAC_SHA384: 48,</span>
<span class="gi">+    HMAC_SHA384_192: 24,</span>
<span class="gi">+    HMAC_SHA512: 64,</span>
<span class="gi">+    HMAC_SHA512_256: 32,</span>
<span class="gi">+    HMAC_MD5: 16,</span>
<span class="gi">+    GSS_TSIG: 128,  # This is what we assume to be the worst case!</span>
<span class="gi">+}</span>


<span class="w"> </span>class GSSTSig:
<span class="gu">@@ -73,12 +105,26 @@ class GSSTSig:</span>

<span class="w"> </span>    def __init__(self, gssapi_context):
<span class="w"> </span>        self.gssapi_context = gssapi_context
<span class="gd">-        self.data = b&#39;&#39;</span>
<span class="gd">-        self.name = &#39;gss-tsig&#39;</span>
<span class="gi">+        self.data = b&quot;&quot;</span>
<span class="gi">+        self.name = &quot;gss-tsig&quot;</span>

<span class="gi">+    def update(self, data):</span>
<span class="gi">+        self.data += data</span>

<span class="gd">-class GSSTSigAdapter:</span>
<span class="gi">+    def sign(self):</span>
<span class="gi">+        # defer to the GSSAPI function to sign</span>
<span class="gi">+        return self.gssapi_context.get_signature(self.data)</span>

<span class="gi">+    def verify(self, expected):</span>
<span class="gi">+        try:</span>
<span class="gi">+            # defer to the GSSAPI function to verify</span>
<span class="gi">+            return self.gssapi_context.verify_signature(self.data, expected)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # note the usage of a bare exception</span>
<span class="gi">+            raise BadSignature</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class GSSTSigAdapter:</span>
<span class="w"> </span>    def __init__(self, keyring):
<span class="w"> </span>        self.keyring = keyring

<span class="gu">@@ -92,24 +138,49 @@ class GSSTSigAdapter:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return None

<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_tkey_and_step(cls, key, message, keyname):</span>
<span class="gi">+        # if the message is a TKEY type, absorb the key material</span>
<span class="gi">+        # into the context using step(); this is used to allow the</span>
<span class="gi">+        # client to complete the GSSAPI negotiation before attempting</span>
<span class="gi">+        # to verify the signed response to a TKEY message exchange</span>
<span class="gi">+        try:</span>
<span class="gi">+            rrset = message.find_rrset(</span>
<span class="gi">+                message.answer, keyname, dns.rdataclass.ANY, dns.rdatatype.TKEY</span>
<span class="gi">+            )</span>
<span class="gi">+            if rrset:</span>
<span class="gi">+                token = rrset[0].key</span>
<span class="gi">+                gssapi_context = key.secret</span>
<span class="gi">+                return gssapi_context.step(token)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>

<span class="w"> </span>class HMACTSig:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    HMAC TSIG implementation.  This uses the HMAC python module to handle the
<span class="w"> </span>    sign/verify operations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _hashes = {HMAC_SHA1: hashlib.sha1, HMAC_SHA224: hashlib.sha224,</span>
<span class="gd">-        HMAC_SHA256: hashlib.sha256, HMAC_SHA256_128: (hashlib.sha256, 128),</span>
<span class="gd">-        HMAC_SHA384: hashlib.sha384, HMAC_SHA384_192: (hashlib.sha384, 192),</span>
<span class="gd">-        HMAC_SHA512: hashlib.sha512, HMAC_SHA512_256: (hashlib.sha512, 256),</span>
<span class="gd">-        HMAC_MD5: hashlib.md5}</span>
<span class="gi">+</span>
<span class="gi">+    _hashes = {</span>
<span class="gi">+        HMAC_SHA1: hashlib.sha1,</span>
<span class="gi">+        HMAC_SHA224: hashlib.sha224,</span>
<span class="gi">+        HMAC_SHA256: hashlib.sha256,</span>
<span class="gi">+        HMAC_SHA256_128: (hashlib.sha256, 128),</span>
<span class="gi">+        HMAC_SHA384: hashlib.sha384,</span>
<span class="gi">+        HMAC_SHA384_192: (hashlib.sha384, 192),</span>
<span class="gi">+        HMAC_SHA512: hashlib.sha512,</span>
<span class="gi">+        HMAC_SHA512_256: (hashlib.sha512, 256),</span>
<span class="gi">+        HMAC_MD5: hashlib.md5,</span>
<span class="gi">+    }</span>

<span class="w"> </span>    def __init__(self, key, algorithm):
<span class="w"> </span>        try:
<span class="w"> </span>            hashinfo = self._hashes[algorithm]
<span class="w"> </span>        except KeyError:
<span class="gd">-            raise NotImplementedError(</span>
<span class="gd">-                f&#39;TSIG algorithm {algorithm} is not supported&#39;)</span>
<span class="gi">+            raise NotImplementedError(f&quot;TSIG algorithm {algorithm} is not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # create the HMAC context</span>
<span class="w"> </span>        if isinstance(hashinfo, tuple):
<span class="w"> </span>            self.hmac_context = hmac.new(key, digestmod=hashinfo[0])
<span class="w"> </span>            self.size = hashinfo[1]
<span class="gu">@@ -118,17 +189,58 @@ class HMACTSig:</span>
<span class="w"> </span>            self.size = None
<span class="w"> </span>        self.name = self.hmac_context.name
<span class="w"> </span>        if self.size:
<span class="gd">-            self.name += f&#39;-{self.size}&#39;</span>
<span class="gi">+            self.name += f&quot;-{self.size}&quot;</span>

<span class="gi">+    def update(self, data):</span>
<span class="gi">+        return self.hmac_context.update(data)</span>
<span class="gi">+</span>
<span class="gi">+    def sign(self):</span>
<span class="gi">+        # defer to the HMAC digest() function for that digestmod</span>
<span class="gi">+        digest = self.hmac_context.digest()</span>
<span class="gi">+        if self.size:</span>
<span class="gi">+            digest = digest[: (self.size // 8)]</span>
<span class="gi">+        return digest</span>

<span class="gd">-def _digest(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=None</span>
<span class="gd">-    ):</span>
<span class="gi">+    def verify(self, expected):</span>
<span class="gi">+        # re-digest and compare the results</span>
<span class="gi">+        mac = self.sign()</span>
<span class="gi">+        if not hmac.compare_digest(mac, expected):</span>
<span class="gi">+            raise BadSignature</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _digest(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a context containing the TSIG rdata for the input parameters
<span class="w"> </span>    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
<span class="w"> </span>    @raises ValueError: I{other_data} is too long
<span class="w"> </span>    @raises NotImplementedError: I{algorithm} is not supported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    first = not (ctx and multi)</span>
<span class="gi">+    if first:</span>
<span class="gi">+        ctx = get_context(key)</span>
<span class="gi">+        if request_mac:</span>
<span class="gi">+            ctx.update(struct.pack(&quot;!H&quot;, len(request_mac)))</span>
<span class="gi">+            ctx.update(request_mac)</span>
<span class="gi">+    ctx.update(struct.pack(&quot;!H&quot;, rdata.original_id))</span>
<span class="gi">+    ctx.update(wire[2:])</span>
<span class="gi">+    if first:</span>
<span class="gi">+        ctx.update(key.name.to_digestable())</span>
<span class="gi">+        ctx.update(struct.pack(&quot;!H&quot;, dns.rdataclass.ANY))</span>
<span class="gi">+        ctx.update(struct.pack(&quot;!I&quot;, 0))</span>
<span class="gi">+    if time is None:</span>
<span class="gi">+        time = rdata.time_signed</span>
<span class="gi">+    upper_time = (time &gt;&gt; 32) &amp; 0xFFFF</span>
<span class="gi">+    lower_time = time &amp; 0xFFFFFFFF</span>
<span class="gi">+    time_encoded = struct.pack(&quot;!HIH&quot;, upper_time, lower_time, rdata.fudge)</span>
<span class="gi">+    other_len = len(rdata.other)</span>
<span class="gi">+    if other_len &gt; 65535:</span>
<span class="gi">+        raise ValueError(&quot;TSIG Other Data is &gt; 65535 bytes&quot;)</span>
<span class="gi">+    if first:</span>
<span class="gi">+        ctx.update(key.algorithm.to_digestable() + time_encoded)</span>
<span class="gi">+        ctx.update(struct.pack(&quot;!HH&quot;, rdata.error, other_len) + rdata.other)</span>
<span class="gi">+    else:</span>
<span class="gi">+        ctx.update(time_encoded)</span>
<span class="gi">+    return ctx</span>


<span class="w"> </span>def _maybe_start_digest(key, mac, multi):
<span class="gu">@@ -136,7 +248,13 @@ def _maybe_start_digest(key, mac, multi):</span>
<span class="w"> </span>    start a new context.
<span class="w"> </span>    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if multi:</span>
<span class="gi">+        ctx = get_context(key)</span>
<span class="gi">+        ctx.update(struct.pack(&quot;!H&quot;, len(mac)))</span>
<span class="gi">+        ctx.update(mac)</span>
<span class="gi">+        return ctx</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def sign(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=False):
<span class="gu">@@ -147,11 +265,17 @@ def sign(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=False):</span>
<span class="w"> </span>    @raises ValueError: I{other_data} is too long
<span class="w"> </span>    @raises NotImplementedError: I{algorithm} is not supported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    ctx = _digest(wire, key, rdata, time, request_mac, ctx, multi)</span>
<span class="gi">+    mac = ctx.sign()</span>
<span class="gi">+    tsig = rdata.replace(time_signed=time, mac=mac)</span>

<span class="gd">-def validate(wire, key, owner, rdata, now, request_mac, tsig_start, ctx=</span>
<span class="gd">-    None, multi=False):</span>
<span class="gi">+    return (tsig, _maybe_start_digest(key, mac, multi))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate(</span>
<span class="gi">+    wire, key, owner, rdata, now, request_mac, tsig_start, ctx=None, multi=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate the specified TSIG rdata against the other input parameters.

<span class="w"> </span>    @raises FormError: The TSIG is badly formed.
<span class="gu">@@ -159,7 +283,32 @@ def validate(wire, key, owner, rdata, now, request_mac, tsig_start, ctx=</span>
<span class="w"> </span>    server.
<span class="w"> </span>    @raises BadSignature: The TSIG signature did not validate
<span class="w"> </span>    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    (adcount,) = struct.unpack(&quot;!H&quot;, wire[10:12])</span>
<span class="gi">+    if adcount == 0:</span>
<span class="gi">+        raise dns.exception.FormError</span>
<span class="gi">+    adcount -= 1</span>
<span class="gi">+    new_wire = wire[0:10] + struct.pack(&quot;!H&quot;, adcount) + wire[12:tsig_start]</span>
<span class="gi">+    if rdata.error != 0:</span>
<span class="gi">+        if rdata.error == dns.rcode.BADSIG:</span>
<span class="gi">+            raise PeerBadSignature</span>
<span class="gi">+        elif rdata.error == dns.rcode.BADKEY:</span>
<span class="gi">+            raise PeerBadKey</span>
<span class="gi">+        elif rdata.error == dns.rcode.BADTIME:</span>
<span class="gi">+            raise PeerBadTime</span>
<span class="gi">+        elif rdata.error == dns.rcode.BADTRUNC:</span>
<span class="gi">+            raise PeerBadTruncation</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PeerError(&quot;unknown TSIG error code %d&quot; % rdata.error)</span>
<span class="gi">+    if abs(rdata.time_signed - now) &gt; rdata.fudge:</span>
<span class="gi">+        raise BadTime</span>
<span class="gi">+    if key.name != owner:</span>
<span class="gi">+        raise BadKey</span>
<span class="gi">+    if key.algorithm != rdata.algorithm:</span>
<span class="gi">+        raise BadAlgorithm</span>
<span class="gi">+    ctx = _digest(new_wire, key, rdata, None, request_mac, ctx, multi)</span>
<span class="gi">+    ctx.verify(rdata.mac)</span>
<span class="gi">+    return _maybe_start_digest(key, rdata.mac, multi)</span>


<span class="w"> </span>def get_context(key):
<span class="gu">@@ -168,11 +317,14 @@ def get_context(key):</span>
<span class="w"> </span>    @rtype: HMAC context
<span class="w"> </span>    @raises NotImplementedError: I{algorithm} is not supported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if key.algorithm == GSS_TSIG:</span>
<span class="gi">+        return GSSTSig(key.secret)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return HMACTSig(key.secret, key.algorithm)</span>

<span class="gd">-class Key:</span>

<span class="gi">+class Key:</span>
<span class="w"> </span>    def __init__(self, name, secret, algorithm=default_algorithm):
<span class="w"> </span>        if isinstance(name, str):
<span class="w"> </span>            name = dns.name.from_text(name)
<span class="gu">@@ -185,12 +337,16 @@ class Key:</span>
<span class="w"> </span>        self.algorithm = algorithm

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return (isinstance(other, Key) and self.name == other.name and self</span>
<span class="gd">-            .secret == other.secret and self.algorithm == other.algorithm)</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(other, Key)</span>
<span class="gi">+            and self.name == other.name</span>
<span class="gi">+            and self.secret == other.secret</span>
<span class="gi">+            and self.algorithm == other.algorithm</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        r = f&quot;&lt;DNS key name=&#39;{self.name}&#39;, &quot; + f&quot;algorithm=&#39;{self.algorithm}&#39;&quot;
<span class="w"> </span>        if self.algorithm != GSS_TSIG:
<span class="w"> </span>            r += f&quot;, secret=&#39;{base64.b64encode(self.secret).decode()}&#39;&quot;
<span class="gd">-        r += &#39;&gt;&#39;</span>
<span class="gi">+        r += &quot;&gt;&quot;</span>
<span class="w"> </span>        return r
<span class="gh">diff --git a/dns/tsigkeyring.py b/dns/tsigkeyring.py</span>
<span class="gh">index 83df7bd..1010a79 100644</span>
<span class="gd">--- a/dns/tsigkeyring.py</span>
<span class="gi">+++ b/dns/tsigkeyring.py</span>
<span class="gu">@@ -1,23 +1,68 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A place to store TSIG keys.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>from typing import Any, Dict
<span class="gi">+</span>
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.tsig


<span class="gd">-def from_text(textring: Dict[str, Any]) -&gt;Dict[dns.name.Name, dns.tsig.Key]:</span>
<span class="gi">+def from_text(textring: Dict[str, Any]) -&gt; Dict[dns.name.Name, dns.tsig.Key]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a dictionary containing (textual DNS name, base64 secret)
<span class="w"> </span>    pairs into a binary keyring which has (dns.name.Name, bytes) pairs, or
<span class="w"> </span>    a dictionary containing (textual DNS name, (algorithm, base64 secret))
<span class="w"> </span>    pairs into a binary keyring which has (dns.name.Name, dns.tsig.Key) pairs.
<span class="w"> </span>    @rtype: dict&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    keyring = {}</span>
<span class="gi">+    for name, value in textring.items():</span>
<span class="gi">+        kname = dns.name.from_text(name)</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            keyring[kname] = dns.tsig.Key(kname, value).secret</span>
<span class="gi">+        else:</span>
<span class="gi">+            (algorithm, secret) = value</span>
<span class="gi">+            keyring[kname] = dns.tsig.Key(kname, secret, algorithm)</span>
<span class="gi">+    return keyring</span>


<span class="gd">-def to_text(keyring: Dict[dns.name.Name, Any]) -&gt;Dict[str, Any]:</span>
<span class="gi">+def to_text(keyring: Dict[dns.name.Name, Any]) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a dictionary containing (dns.name.Name, dns.tsig.Key) pairs
<span class="w"> </span>    into a text keyring which has (textual DNS name, (textual algorithm,
<span class="w"> </span>    base64 secret)) pairs, or a dictionary containing (dns.name.Name, bytes)
<span class="w"> </span>    pairs into a text keyring which has (textual DNS name, base64 secret) pairs.
<span class="w"> </span>    @rtype: dict&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    textring = {}</span>
<span class="gi">+</span>
<span class="gi">+    def b64encode(secret):</span>
<span class="gi">+        return base64.encodebytes(secret).decode().rstrip()</span>
<span class="gi">+</span>
<span class="gi">+    for name, key in keyring.items():</span>
<span class="gi">+        tname = name.to_text()</span>
<span class="gi">+        if isinstance(key, bytes):</span>
<span class="gi">+            textring[tname] = b64encode(key)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(key.secret, bytes):</span>
<span class="gi">+                text_secret = b64encode(key.secret)</span>
<span class="gi">+            else:</span>
<span class="gi">+                text_secret = str(key.secret)</span>
<span class="gi">+</span>
<span class="gi">+            textring[tname] = (key.algorithm.to_text(), text_secret)</span>
<span class="gi">+    return textring</span>
<span class="gh">diff --git a/dns/ttl.py b/dns/ttl.py</span>
<span class="gh">index 0ade6bc..264b033 100644</span>
<span class="gd">--- a/dns/ttl.py</span>
<span class="gi">+++ b/dns/ttl.py</span>
<span class="gu">@@ -1,14 +1,39 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS TTL conversion.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="gd">-MAX_TTL = 2 ** 32 - 1</span>
<span class="gi">+</span>
<span class="gi">+# Technically TTLs are supposed to be between 0 and 2**31 - 1, with values</span>
<span class="gi">+# greater than that interpreted as 0, but we do not impose this policy here</span>
<span class="gi">+# as values &gt; 2**31 - 1 occur in real world data.</span>
<span class="gi">+#</span>
<span class="gi">+# We leave it to applications to impose tighter bounds if desired.</span>
<span class="gi">+MAX_TTL = 2**32 - 1</span>


<span class="w"> </span>class BadTTL(dns.exception.SyntaxError):
<span class="w"> </span>    &quot;&quot;&quot;DNS TTL value is not well-formed.&quot;&quot;&quot;


<span class="gd">-def from_text(text: str) -&gt;int:</span>
<span class="gi">+def from_text(text: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the text form of a TTL to an integer.

<span class="w"> </span>    The BIND 8 units syntax for TTLs (e.g. &#39;1w6d4h3m10s&#39;) is supported.
<span class="gu">@@ -19,4 +44,49 @@ def from_text(text: str) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if text.isdigit():</span>
<span class="gi">+        total = int(text)</span>
<span class="gi">+    elif len(text) == 0:</span>
<span class="gi">+        raise BadTTL</span>
<span class="gi">+    else:</span>
<span class="gi">+        total = 0</span>
<span class="gi">+        current = 0</span>
<span class="gi">+        need_digit = True</span>
<span class="gi">+        for c in text:</span>
<span class="gi">+            if c.isdigit():</span>
<span class="gi">+                current *= 10</span>
<span class="gi">+                current += int(c)</span>
<span class="gi">+                need_digit = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                if need_digit:</span>
<span class="gi">+                    raise BadTTL</span>
<span class="gi">+                c = c.lower()</span>
<span class="gi">+                if c == &quot;w&quot;:</span>
<span class="gi">+                    total += current * 604800</span>
<span class="gi">+                elif c == &quot;d&quot;:</span>
<span class="gi">+                    total += current * 86400</span>
<span class="gi">+                elif c == &quot;h&quot;:</span>
<span class="gi">+                    total += current * 3600</span>
<span class="gi">+                elif c == &quot;m&quot;:</span>
<span class="gi">+                    total += current * 60</span>
<span class="gi">+                elif c == &quot;s&quot;:</span>
<span class="gi">+                    total += current</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise BadTTL(&quot;unknown unit &#39;%s&#39;&quot; % c)</span>
<span class="gi">+                current = 0</span>
<span class="gi">+                need_digit = True</span>
<span class="gi">+        if not current == 0:</span>
<span class="gi">+            raise BadTTL(&quot;trailing integer&quot;)</span>
<span class="gi">+    if total &lt; 0 or total &gt; MAX_TTL:</span>
<span class="gi">+        raise BadTTL(&quot;TTL should be between 0 and 2**32 - 1 (inclusive)&quot;)</span>
<span class="gi">+    return total</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make(value: Union[int, str]) -&gt; int:</span>
<span class="gi">+    if isinstance(value, int):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        return dns.ttl.from_text(value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;cannot convert value to TTL&quot;)</span>
<span class="gh">diff --git a/dns/update.py b/dns/update.py</span>
<span class="gh">index d53b842..bf1157a 100644</span>
<span class="gd">--- a/dns/update.py</span>
<span class="gi">+++ b/dns/update.py</span>
<span class="gu">@@ -1,5 +1,24 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Dynamic Update Support&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, List, Optional, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.message
<span class="w"> </span>import dns.name
<span class="w"> </span>import dns.opcode
<span class="gu">@@ -12,20 +31,30 @@ import dns.tsig</span>

<span class="w"> </span>class UpdateSection(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;Update sections&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ZONE = 0
<span class="w"> </span>    PREREQ = 1
<span class="w"> </span>    UPDATE = 2
<span class="w"> </span>    ADDITIONAL = 3

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 3</span>

<span class="gd">-class UpdateMessage(dns.message.Message):</span>
<span class="gd">-    _section_enum = UpdateSection</span>

<span class="gd">-    def __init__(self, zone: Optional[Union[dns.name.Name, str]]=None,</span>
<span class="gd">-        rdclass: dns.rdataclass.RdataClass=dns.rdataclass.IN, keyring:</span>
<span class="gd">-        Optional[Any]=None, keyname: Optional[dns.name.Name]=None,</span>
<span class="gd">-        keyalgorithm: Union[dns.name.Name, str]=dns.tsig.default_algorithm,</span>
<span class="gd">-        id: Optional[int]=None):</span>
<span class="gi">+class UpdateMessage(dns.message.Message):  # lgtm[py/missing-equals]</span>
<span class="gi">+    # ignore the mypy error here as we mean to use a different enum</span>
<span class="gi">+    _section_enum = UpdateSection  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        zone: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+        keyring: Optional[Any] = None,</span>
<span class="gi">+        keyname: Optional[dns.name.Name] = None,</span>
<span class="gi">+        keyalgorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,</span>
<span class="gi">+        id: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a new DNS Update object.

<span class="w"> </span>        See the documentation of the Message class for a complete
<span class="gu">@@ -49,29 +78,54 @@ class UpdateMessage(dns.message.Message):</span>
<span class="w"> </span>        rdclass = dns.rdataclass.RdataClass.make(rdclass)
<span class="w"> </span>        self.zone_rdclass = rdclass
<span class="w"> </span>        if self.origin:
<span class="gd">-            self.find_rrset(self.zone, self.origin, rdclass, dns.rdatatype.</span>
<span class="gd">-                SOA, create=True, force_unique=True)</span>
<span class="gi">+            self.find_rrset(</span>
<span class="gi">+                self.zone,</span>
<span class="gi">+                self.origin,</span>
<span class="gi">+                rdclass,</span>
<span class="gi">+                dns.rdatatype.SOA,</span>
<span class="gi">+                create=True,</span>
<span class="gi">+                force_unique=True,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        if keyring is not None:
<span class="w"> </span>            self.use_tsig(keyring, keyname, algorithm=keyalgorithm)

<span class="w"> </span>    @property
<span class="gd">-    def zone(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def zone(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The zone section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[0]</span>
<span class="gi">+</span>
<span class="gi">+    @zone.setter</span>
<span class="gi">+    def zone(self, v):</span>
<span class="gi">+        self.sections[0] = v</span>

<span class="w"> </span>    @property
<span class="gd">-    def prerequisite(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def prerequisite(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The prerequisite section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[1]</span>
<span class="gi">+</span>
<span class="gi">+    @prerequisite.setter</span>
<span class="gi">+    def prerequisite(self, v):</span>
<span class="gi">+        self.sections[1] = v</span>

<span class="w"> </span>    @property
<span class="gd">-    def update(self) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+    def update(self) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The update section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[2]</span>
<span class="gi">+</span>
<span class="gi">+    @update.setter</span>
<span class="gi">+    def update(self, v):</span>
<span class="gi">+        self.sections[2] = v</span>

<span class="w"> </span>    def _add_rr(self, name, ttl, rd, deleting=None, section=None):
<span class="w"> </span>        &quot;&quot;&quot;Add a single RR to the update section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if section is None:</span>
<span class="gi">+            section = self.update</span>
<span class="gi">+        covers = rd.covers()</span>
<span class="gi">+        rrset = self.find_rrset(</span>
<span class="gi">+            section, name, self.zone_rdclass, rd.rdtype, covers, deleting, True, True</span>
<span class="gi">+        )</span>
<span class="gi">+        rrset.add(rd, ttl)</span>

<span class="w"> </span>    def _add(self, replace, section, name, *args):
<span class="w"> </span>        &quot;&quot;&quot;Add records.
<span class="gu">@@ -88,9 +142,32 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - ttl, rdtype, string...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def add(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if isinstance(args[0], dns.rdataset.Rdataset):</span>
<span class="gi">+            for rds in args:</span>
<span class="gi">+                if replace:</span>
<span class="gi">+                    self.delete(name, rds.rdtype)</span>
<span class="gi">+                for rd in rds:</span>
<span class="gi">+                    self._add_rr(name, rds.ttl, rd, section=section)</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = list(args)</span>
<span class="gi">+            ttl = int(args.pop(0))</span>
<span class="gi">+            if isinstance(args[0], dns.rdata.Rdata):</span>
<span class="gi">+                if replace:</span>
<span class="gi">+                    self.delete(name, args[0].rdtype)</span>
<span class="gi">+                for rd in args:</span>
<span class="gi">+                    self._add_rr(name, ttl, rd, section=section)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rdtype = dns.rdatatype.RdataType.make(args.pop(0))</span>
<span class="gi">+                if replace:</span>
<span class="gi">+                    self.delete(name, rdtype)</span>
<span class="gi">+                for s in args:</span>
<span class="gi">+                    rd = dns.rdata.from_text(self.zone_rdclass, rdtype, s, self.origin)</span>
<span class="gi">+                    self._add_rr(name, ttl, rd, section=section)</span>
<span class="gi">+</span>
<span class="gi">+    def add(self, name: Union[dns.name.Name, str], *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add records.

<span class="w"> </span>        The first argument is always a name.  The other
<span class="gu">@@ -102,9 +179,10 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - ttl, rdtype, string...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def delete(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:</span>
<span class="gi">+        self._add(False, self.update, name, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def delete(self, name: Union[dns.name.Name, str], *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete records.

<span class="w"> </span>        The first argument is always a name.  The other
<span class="gu">@@ -118,9 +196,53 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - rdtype, [string...]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def replace(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if len(args) == 0:</span>
<span class="gi">+            self.find_rrset(</span>
<span class="gi">+                self.update,</span>
<span class="gi">+                name,</span>
<span class="gi">+                dns.rdataclass.ANY,</span>
<span class="gi">+                dns.rdatatype.ANY,</span>
<span class="gi">+                dns.rdatatype.NONE,</span>
<span class="gi">+                dns.rdataclass.ANY,</span>
<span class="gi">+                True,</span>
<span class="gi">+                True,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(args[0], dns.rdataset.Rdataset):</span>
<span class="gi">+            for rds in args:</span>
<span class="gi">+                for rd in rds:</span>
<span class="gi">+                    self._add_rr(name, 0, rd, dns.rdataclass.NONE)</span>
<span class="gi">+        else:</span>
<span class="gi">+            largs = list(args)</span>
<span class="gi">+            if isinstance(largs[0], dns.rdata.Rdata):</span>
<span class="gi">+                for rd in largs:</span>
<span class="gi">+                    self._add_rr(name, 0, rd, dns.rdataclass.NONE)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rdtype = dns.rdatatype.RdataType.make(largs.pop(0))</span>
<span class="gi">+                if len(largs) == 0:</span>
<span class="gi">+                    self.find_rrset(</span>
<span class="gi">+                        self.update,</span>
<span class="gi">+                        name,</span>
<span class="gi">+                        self.zone_rdclass,</span>
<span class="gi">+                        rdtype,</span>
<span class="gi">+                        dns.rdatatype.NONE,</span>
<span class="gi">+                        dns.rdataclass.ANY,</span>
<span class="gi">+                        True,</span>
<span class="gi">+                        True,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    for s in largs:</span>
<span class="gi">+                        rd = dns.rdata.from_text(</span>
<span class="gi">+                            self.zone_rdclass,</span>
<span class="gi">+                            rdtype,</span>
<span class="gi">+                            s,  # type: ignore[arg-type]</span>
<span class="gi">+                            self.origin,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        self._add_rr(name, 0, rd, dns.rdataclass.NONE)</span>
<span class="gi">+</span>
<span class="gi">+    def replace(self, name: Union[dns.name.Name, str], *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace records.

<span class="w"> </span>        The first argument is always a name.  The other
<span class="gu">@@ -135,9 +257,10 @@ class UpdateMessage(dns.message.Message):</span>
<span class="w"> </span>        Note that if you want to replace the entire node, you should do
<span class="w"> </span>        a delete of the name followed by one or more calls to add.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def present(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:</span>
<span class="gi">+        self._add(True, self.update, name, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def present(self, name: Union[dns.name.Name, str], *args: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Require that an owner name (and optionally an rdata type,
<span class="w"> </span>        or specific rdataset) exists as a prerequisite to the
<span class="w"> </span>        execution of the update.
<span class="gu">@@ -151,17 +274,113 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - rdtype, string...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def absent(self, name: Union[dns.name.Name, str], rdtype: Optional[</span>
<span class="gd">-        Union[dns.rdatatype.RdataType, str]]=None) -&gt;None:</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if len(args) == 0:</span>
<span class="gi">+            self.find_rrset(</span>
<span class="gi">+                self.prerequisite,</span>
<span class="gi">+                name,</span>
<span class="gi">+                dns.rdataclass.ANY,</span>
<span class="gi">+                dns.rdatatype.ANY,</span>
<span class="gi">+                dns.rdatatype.NONE,</span>
<span class="gi">+                None,</span>
<span class="gi">+                True,</span>
<span class="gi">+                True,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif (</span>
<span class="gi">+            isinstance(args[0], dns.rdataset.Rdataset)</span>
<span class="gi">+            or isinstance(args[0], dns.rdata.Rdata)</span>
<span class="gi">+            or len(args) &gt; 1</span>
<span class="gi">+        ):</span>
<span class="gi">+            if not isinstance(args[0], dns.rdataset.Rdataset):</span>
<span class="gi">+                # Add a 0 TTL</span>
<span class="gi">+                largs = list(args)</span>
<span class="gi">+                largs.insert(0, 0)  # type: ignore[arg-type]</span>
<span class="gi">+                self._add(False, self.prerequisite, name, *largs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._add(False, self.prerequisite, name, *args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            rdtype = dns.rdatatype.RdataType.make(args[0])</span>
<span class="gi">+            self.find_rrset(</span>
<span class="gi">+                self.prerequisite,</span>
<span class="gi">+                name,</span>
<span class="gi">+                dns.rdataclass.ANY,</span>
<span class="gi">+                rdtype,</span>
<span class="gi">+                dns.rdatatype.NONE,</span>
<span class="gi">+                None,</span>
<span class="gi">+                True,</span>
<span class="gi">+                True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def absent(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Optional[Union[dns.rdatatype.RdataType, str]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Require that an owner name (and optionally an rdata type) does
<span class="w"> </span>        not exist as a prerequisite to the execution of the update.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>

<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if rdtype is None:</span>
<span class="gi">+            self.find_rrset(</span>
<span class="gi">+                self.prerequisite,</span>
<span class="gi">+                name,</span>
<span class="gi">+                dns.rdataclass.NONE,</span>
<span class="gi">+                dns.rdatatype.ANY,</span>
<span class="gi">+                dns.rdatatype.NONE,</span>
<span class="gi">+                None,</span>
<span class="gi">+                True,</span>
<span class="gi">+                True,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+            self.find_rrset(</span>
<span class="gi">+                self.prerequisite,</span>
<span class="gi">+                name,</span>
<span class="gi">+                dns.rdataclass.NONE,</span>
<span class="gi">+                rdtype,</span>
<span class="gi">+                dns.rdatatype.NONE,</span>
<span class="gi">+                None,</span>
<span class="gi">+                True,</span>
<span class="gi">+                True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_one_rr_per_rrset(self, value):</span>
<span class="gi">+        # Updates are always one_rr_per_rrset</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_rr_header(self, section, name, rdclass, rdtype):</span>
<span class="gi">+        deleting = None</span>
<span class="gi">+        empty = False</span>
<span class="gi">+        if section == UpdateSection.ZONE:</span>
<span class="gi">+            if (</span>
<span class="gi">+                dns.rdataclass.is_metaclass(rdclass)</span>
<span class="gi">+                or rdtype != dns.rdatatype.SOA</span>
<span class="gi">+                or self.zone</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise dns.exception.FormError</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not self.zone:</span>
<span class="gi">+                raise dns.exception.FormError</span>
<span class="gi">+            if rdclass in (dns.rdataclass.ANY, dns.rdataclass.NONE):</span>
<span class="gi">+                deleting = rdclass</span>
<span class="gi">+                rdclass = self.zone[0].rdclass</span>
<span class="gi">+                empty = (</span>
<span class="gi">+                    deleting == dns.rdataclass.ANY or section == UpdateSection.PREREQ</span>
<span class="gi">+                )</span>
<span class="gi">+        return (rdclass, rdtype, deleting, empty)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# backwards compatibility</span>
<span class="w"> </span>Update = UpdateMessage
<span class="gi">+</span>
<span class="gi">+### BEGIN generated UpdateSection constants</span>
<span class="gi">+</span>
<span class="w"> </span>ZONE = UpdateSection.ZONE
<span class="w"> </span>PREREQ = UpdateSection.PREREQ
<span class="w"> </span>UPDATE = UpdateSection.UPDATE
<span class="w"> </span>ADDITIONAL = UpdateSection.ADDITIONAL
<span class="gi">+</span>
<span class="gi">+### END generated UpdateSection constants</span>
<span class="gh">diff --git a/dns/version.py b/dns/version.py</span>
<span class="gh">index 6246edc..251f258 100644</span>
<span class="gd">--- a/dns/version.py</span>
<span class="gi">+++ b/dns/version.py</span>
<span class="gu">@@ -1,16 +1,58 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;dnspython release version information.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+#: MAJOR</span>
<span class="w"> </span>MAJOR = 2
<span class="gi">+#: MINOR</span>
<span class="w"> </span>MINOR = 6
<span class="gi">+#: MICRO</span>
<span class="w"> </span>MICRO = 1
<span class="gd">-RELEASELEVEL = 15</span>
<span class="gi">+#: RELEASELEVEL</span>
<span class="gi">+RELEASELEVEL = 0x0F</span>
<span class="gi">+#: SERIAL</span>
<span class="w"> </span>SERIAL = 0
<span class="gd">-if RELEASELEVEL == 15:</span>
<span class="gd">-    version = &#39;%d.%d.%d&#39; % (MAJOR, MINOR, MICRO)</span>
<span class="gd">-elif RELEASELEVEL == 0:</span>
<span class="gd">-    version = &#39;%d.%d.%ddev%d&#39; % (MAJOR, MINOR, MICRO, SERIAL)</span>
<span class="gd">-elif RELEASELEVEL == 12:</span>
<span class="gd">-    version = &#39;%d.%d.%drc%d&#39; % (MAJOR, MINOR, MICRO, SERIAL)</span>
<span class="gd">-else:</span>
<span class="gd">-    version = &#39;%d.%d.%d%x%d&#39; % (MAJOR, MINOR, MICRO, RELEASELEVEL, SERIAL)</span>
<span class="gd">-hexversion = (MAJOR &lt;&lt; 24 | MINOR &lt;&lt; 16 | MICRO &lt;&lt; 8 | RELEASELEVEL &lt;&lt; 4 |</span>
<span class="gd">-    SERIAL)</span>
<span class="gi">+</span>
<span class="gi">+if RELEASELEVEL == 0x0F:  # pragma: no cover  lgtm[py/unreachable-statement]</span>
<span class="gi">+    #: version</span>
<span class="gi">+    version = &quot;%d.%d.%d&quot; % (MAJOR, MINOR, MICRO)  # lgtm[py/unreachable-statement]</span>
<span class="gi">+elif RELEASELEVEL == 0x00:  # pragma: no cover  lgtm[py/unreachable-statement]</span>
<span class="gi">+    version = &quot;%d.%d.%ddev%d&quot; % (</span>
<span class="gi">+        MAJOR,</span>
<span class="gi">+        MINOR,</span>
<span class="gi">+        MICRO,</span>
<span class="gi">+        SERIAL,</span>
<span class="gi">+    )  # lgtm[py/unreachable-statement]</span>
<span class="gi">+elif RELEASELEVEL == 0x0C:  # pragma: no cover  lgtm[py/unreachable-statement]</span>
<span class="gi">+    version = &quot;%d.%d.%drc%d&quot; % (</span>
<span class="gi">+        MAJOR,</span>
<span class="gi">+        MINOR,</span>
<span class="gi">+        MICRO,</span>
<span class="gi">+        SERIAL,</span>
<span class="gi">+    )  # lgtm[py/unreachable-statement]</span>
<span class="gi">+else:  # pragma: no cover  lgtm[py/unreachable-statement]</span>
<span class="gi">+    version = &quot;%d.%d.%d%x%d&quot; % (</span>
<span class="gi">+        MAJOR,</span>
<span class="gi">+        MINOR,</span>
<span class="gi">+        MICRO,</span>
<span class="gi">+        RELEASELEVEL,</span>
<span class="gi">+        SERIAL,</span>
<span class="gi">+    )  # lgtm[py/unreachable-statement]</span>
<span class="gi">+</span>
<span class="gi">+#: hexversion</span>
<span class="gi">+hexversion = MAJOR &lt;&lt; 24 | MINOR &lt;&lt; 16 | MICRO &lt;&lt; 8 | RELEASELEVEL &lt;&lt; 4 | SERIAL</span>
<span class="gh">diff --git a/dns/versioned.py b/dns/versioned.py</span>
<span class="gh">index d716a34..fd78e67 100644</span>
<span class="gd">--- a/dns/versioned.py</span>
<span class="gi">+++ b/dns/versioned.py</span>
<span class="gu">@@ -1,7 +1,11 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Versioned Zones.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import threading
<span class="w"> </span>from typing import Callable, Deque, Optional, Set, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.immutable
<span class="w"> </span>import dns.name
<span class="gu">@@ -17,6 +21,7 @@ class UseTransaction(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;To alter a versioned zone, use a transaction.&quot;&quot;&quot;


<span class="gi">+# Backwards compatibility</span>
<span class="w"> </span>Node = dns.zone.VersionedNode
<span class="w"> </span>ImmutableNode = dns.zone.ImmutableVersionedNode
<span class="w"> </span>Version = dns.zone.Version
<span class="gu">@@ -25,15 +30,26 @@ ImmutableVersion = dns.zone.ImmutableVersion</span>
<span class="w"> </span>Transaction = dns.zone.Transaction


<span class="gd">-class Zone(dns.zone.Zone):</span>
<span class="gd">-    __slots__ = [&#39;_versions&#39;, &#39;_versions_lock&#39;, &#39;_write_txn&#39;,</span>
<span class="gd">-        &#39;_write_waiters&#39;, &#39;_write_event&#39;, &#39;_pruning_policy&#39;, &#39;_readers&#39;]</span>
<span class="gi">+class Zone(dns.zone.Zone):  # lgtm[py/missing-equals]</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;_versions&quot;,</span>
<span class="gi">+        &quot;_versions_lock&quot;,</span>
<span class="gi">+        &quot;_write_txn&quot;,</span>
<span class="gi">+        &quot;_write_waiters&quot;,</span>
<span class="gi">+        &quot;_write_event&quot;,</span>
<span class="gi">+        &quot;_pruning_policy&quot;,</span>
<span class="gi">+        &quot;_readers&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>    node_factory = Node

<span class="gd">-    def __init__(self, origin: Optional[Union[dns.name.Name, str]], rdclass:</span>
<span class="gd">-        dns.rdataclass.RdataClass=dns.rdataclass.IN, relativize: bool=True,</span>
<span class="gd">-        pruning_policy: Optional[Callable[[&#39;Zone&#39;, Version], Optional[bool]</span>
<span class="gd">-        ]]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[Union[dns.name.Name, str]],</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        pruning_policy: Optional[Callable[[&quot;Zone&quot;, Version], Optional[bool]]] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a versioned zone object.

<span class="w"> </span>        *origin* is the origin of the zone.  It may be a ``dns.name.Name``,
<span class="gu">@@ -60,17 +76,145 @@ class Zone(dns.zone.Zone):</span>
<span class="w"> </span>        self._write_event: Optional[threading.Event] = None
<span class="w"> </span>        self._write_waiters: Deque[threading.Event] = collections.deque()
<span class="w"> </span>        self._readers: Set[Transaction] = set()
<span class="gd">-        self._commit_version_unlocked(None, WritableVersion(self,</span>
<span class="gd">-            replacement=True), origin)</span>
<span class="gi">+        self._commit_version_unlocked(</span>
<span class="gi">+            None, WritableVersion(self, replacement=True), origin</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def reader(</span>
<span class="gi">+        self, id: Optional[int] = None, serial: Optional[int] = None</span>
<span class="gi">+    ) -&gt; Transaction:  # pylint: disable=arguments-differ</span>
<span class="gi">+        if id is not None and serial is not None:</span>
<span class="gi">+            raise ValueError(&quot;cannot specify both id and serial&quot;)</span>
<span class="gi">+        with self._version_lock:</span>
<span class="gi">+            if id is not None:</span>
<span class="gi">+                version = None</span>
<span class="gi">+                for v in reversed(self._versions):</span>
<span class="gi">+                    if v.id == id:</span>
<span class="gi">+                        version = v</span>
<span class="gi">+                        break</span>
<span class="gi">+                if version is None:</span>
<span class="gi">+                    raise KeyError(&quot;version not found&quot;)</span>
<span class="gi">+            elif serial is not None:</span>
<span class="gi">+                if self.relativize:</span>
<span class="gi">+                    oname = dns.name.empty</span>
<span class="gi">+                else:</span>
<span class="gi">+                    assert self.origin is not None</span>
<span class="gi">+                    oname = self.origin</span>
<span class="gi">+                version = None</span>
<span class="gi">+                for v in reversed(self._versions):</span>
<span class="gi">+                    n = v.nodes.get(oname)</span>
<span class="gi">+                    if n:</span>
<span class="gi">+                        rds = n.get_rdataset(self.rdclass, dns.rdatatype.SOA)</span>
<span class="gi">+                        if rds and rds[0].serial == serial:</span>
<span class="gi">+                            version = v</span>
<span class="gi">+                            break</span>
<span class="gi">+                if version is None:</span>
<span class="gi">+                    raise KeyError(&quot;serial not found&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                version = self._versions[-1]</span>
<span class="gi">+            txn = Transaction(self, False, version)</span>
<span class="gi">+            self._readers.add(txn)</span>
<span class="gi">+            return txn</span>
<span class="gi">+</span>
<span class="gi">+    def writer(self, replacement: bool = False) -&gt; Transaction:</span>
<span class="gi">+        event = None</span>
<span class="gi">+        while True:</span>
<span class="gi">+            with self._version_lock:</span>
<span class="gi">+                # Checking event == self._write_event ensures that either</span>
<span class="gi">+                # no one was waiting before we got lucky and found no write</span>
<span class="gi">+                # txn, or we were the one who was waiting and got woken up.</span>
<span class="gi">+                # This prevents &quot;taking cuts&quot; when creating a write txn.</span>
<span class="gi">+                if self._write_txn is None and event == self._write_event:</span>
<span class="gi">+                    # Creating the transaction defers version setup</span>
<span class="gi">+                    # (i.e.  copying the nodes dictionary) until we</span>
<span class="gi">+                    # give up the lock, so that we hold the lock as</span>
<span class="gi">+                    # short a time as possible.  This is why we call</span>
<span class="gi">+                    # _setup_version() below.</span>
<span class="gi">+                    self._write_txn = Transaction(</span>
<span class="gi">+                        self, replacement, make_immutable=True</span>
<span class="gi">+                    )</span>
<span class="gi">+                    # give up our exclusive right to make a Transaction</span>
<span class="gi">+                    self._write_event = None</span>
<span class="gi">+                    break</span>
<span class="gi">+                # Someone else is writing already, so we will have to</span>
<span class="gi">+                # wait, but we want to do the actual wait outside the</span>
<span class="gi">+                # lock.</span>
<span class="gi">+                event = threading.Event()</span>
<span class="gi">+                self._write_waiters.append(event)</span>
<span class="gi">+            # wait (note we gave up the lock!)</span>
<span class="gi">+            #</span>
<span class="gi">+            # We only wake one sleeper at a time, so it&#39;s important</span>
<span class="gi">+            # that no event waiter can exit this method (e.g. via</span>
<span class="gi">+            # cancellation) without returning a transaction or waking</span>
<span class="gi">+            # someone else up.</span>
<span class="gi">+            #</span>
<span class="gi">+            # This is not a problem with Threading module threads as</span>
<span class="gi">+            # they cannot be canceled, but could be an issue with trio</span>
<span class="gi">+            # tasks when we do the async version of writer().</span>
<span class="gi">+            # I.e. we&#39;d need to do something like:</span>
<span class="gi">+            #</span>
<span class="gi">+            # try:</span>
<span class="gi">+            #     event.wait()</span>
<span class="gi">+            # except trio.Cancelled:</span>
<span class="gi">+            #     with self._version_lock:</span>
<span class="gi">+            #         self._maybe_wakeup_one_waiter_unlocked()</span>
<span class="gi">+            #     raise</span>
<span class="gi">+            #</span>
<span class="gi">+            event.wait()</span>
<span class="gi">+        # Do the deferred version setup.</span>
<span class="gi">+        self._write_txn._setup_version()</span>
<span class="gi">+        return self._write_txn</span>
<span class="gi">+</span>
<span class="gi">+    def _maybe_wakeup_one_waiter_unlocked(self):</span>
<span class="gi">+        if len(self._write_waiters) &gt; 0:</span>
<span class="gi">+            self._write_event = self._write_waiters.popleft()</span>
<span class="gi">+            self._write_event.set()</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=unused-argument</span>
<span class="gi">+    def _default_pruning_policy(self, zone, version):</span>
<span class="gi">+        return True</span>

<span class="gd">-    def set_max_versions(self, max_versions: Optional[int]) -&gt;None:</span>
<span class="gi">+    # pylint: enable=unused-argument</span>
<span class="gi">+</span>
<span class="gi">+    def _prune_versions_unlocked(self):</span>
<span class="gi">+        assert len(self._versions) &gt; 0</span>
<span class="gi">+        # Don&#39;t ever prune a version greater than or equal to one that</span>
<span class="gi">+        # a reader has open.  This pins versions in memory while the</span>
<span class="gi">+        # reader is open, and importantly lets the reader open a txn on</span>
<span class="gi">+        # a successor version (e.g. if generating an IXFR).</span>
<span class="gi">+        #</span>
<span class="gi">+        # Note our definition of least_kept also ensures we do not try to</span>
<span class="gi">+        # delete the greatest version.</span>
<span class="gi">+        if len(self._readers) &gt; 0:</span>
<span class="gi">+            least_kept = min(txn.version.id for txn in self._readers)</span>
<span class="gi">+        else:</span>
<span class="gi">+            least_kept = self._versions[-1].id</span>
<span class="gi">+        while self._versions[0].id &lt; least_kept and self._pruning_policy(</span>
<span class="gi">+            self, self._versions[0]</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._versions.popleft()</span>
<span class="gi">+</span>
<span class="gi">+    def set_max_versions(self, max_versions: Optional[int]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a pruning policy that retains up to the specified number
<span class="w"> </span>        of versions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if max_versions is not None and max_versions &lt; 1:</span>
<span class="gi">+            raise ValueError(&quot;max versions must be at least 1&quot;)</span>
<span class="gi">+        if max_versions is None:</span>
<span class="gi">+</span>
<span class="gi">+            def policy(zone, _):  # pylint: disable=unused-argument</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def policy(zone, _):</span>
<span class="gi">+                return len(zone._versions) &gt; max_versions</span>

<span class="gd">-    def set_pruning_policy(self, policy: Optional[Callable[[&#39;Zone&#39;, Version</span>
<span class="gd">-        ], Optional[bool]]]) -&gt;None:</span>
<span class="gi">+        self.set_pruning_policy(policy)</span>
<span class="gi">+</span>
<span class="gi">+    def set_pruning_policy(</span>
<span class="gi">+        self, policy: Optional[Callable[[&quot;Zone&quot;, Version], Optional[bool]]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the pruning policy for the zone.

<span class="w"> </span>        The *policy* function takes a `Version` and returns `True` if
<span class="gu">@@ -82,4 +226,93 @@ class Zone(dns.zone.Zone):</span>
<span class="w"> </span>        time the function returns `False`, the checking stops.  I.e. the
<span class="w"> </span>        retained versions are always a consecutive sequence.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if policy is None:</span>
<span class="gi">+            policy = self._default_pruning_policy</span>
<span class="gi">+        with self._version_lock:</span>
<span class="gi">+            self._pruning_policy = policy</span>
<span class="gi">+            self._prune_versions_unlocked()</span>
<span class="gi">+</span>
<span class="gi">+    def _end_read(self, txn):</span>
<span class="gi">+        with self._version_lock:</span>
<span class="gi">+            self._readers.remove(txn)</span>
<span class="gi">+            self._prune_versions_unlocked()</span>
<span class="gi">+</span>
<span class="gi">+    def _end_write_unlocked(self, txn):</span>
<span class="gi">+        assert self._write_txn == txn</span>
<span class="gi">+        self._write_txn = None</span>
<span class="gi">+        self._maybe_wakeup_one_waiter_unlocked()</span>
<span class="gi">+</span>
<span class="gi">+    def _end_write(self, txn):</span>
<span class="gi">+        with self._version_lock:</span>
<span class="gi">+            self._end_write_unlocked(txn)</span>
<span class="gi">+</span>
<span class="gi">+    def _commit_version_unlocked(self, txn, version, origin):</span>
<span class="gi">+        self._versions.append(version)</span>
<span class="gi">+        self._prune_versions_unlocked()</span>
<span class="gi">+        self.nodes = version.nodes</span>
<span class="gi">+        if self.origin is None:</span>
<span class="gi">+            self.origin = origin</span>
<span class="gi">+        # txn can be None in __init__ when we make the empty version.</span>
<span class="gi">+        if txn is not None:</span>
<span class="gi">+            self._end_write_unlocked(txn)</span>
<span class="gi">+</span>
<span class="gi">+    def _commit_version(self, txn, version, origin):</span>
<span class="gi">+        with self._version_lock:</span>
<span class="gi">+            self._commit_version_unlocked(txn, version, origin)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_next_version_id(self):</span>
<span class="gi">+        if len(self._versions) &gt; 0:</span>
<span class="gi">+            id = self._versions[-1].id + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            id = 1</span>
<span class="gi">+        return id</span>
<span class="gi">+</span>
<span class="gi">+    def find_node(</span>
<span class="gi">+        self, name: Union[dns.name.Name, str], create: bool = False</span>
<span class="gi">+    ) -&gt; dns.node.Node:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise UseTransaction</span>
<span class="gi">+        return super().find_node(name)</span>
<span class="gi">+</span>
<span class="gi">+    def delete_node(self, name: Union[dns.name.Name, str]) -&gt; None:</span>
<span class="gi">+        raise UseTransaction</span>
<span class="gi">+</span>
<span class="gi">+    def find_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; dns.rdataset.Rdataset:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise UseTransaction</span>
<span class="gi">+        rdataset = super().find_rdataset(name, rdtype, covers)</span>
<span class="gi">+        return dns.rdataset.ImmutableRdataset(rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; Optional[dns.rdataset.Rdataset]:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise UseTransaction</span>
<span class="gi">+        rdataset = super().get_rdataset(name, rdtype, covers)</span>
<span class="gi">+        if rdataset is not None:</span>
<span class="gi">+            return dns.rdataset.ImmutableRdataset(rdataset)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def delete_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise UseTransaction</span>
<span class="gi">+</span>
<span class="gi">+    def replace_rdataset(</span>
<span class="gi">+        self, name: Union[dns.name.Name, str], replacement: dns.rdataset.Rdataset</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise UseTransaction</span>
<span class="gh">diff --git a/dns/win32util.py b/dns/win32util.py</span>
<span class="gh">index aee6d5a..aaa7e93 100644</span>
<span class="gd">--- a/dns/win32util.py</span>
<span class="gi">+++ b/dns/win32util.py</span>
<span class="gu">@@ -1,52 +1,245 @@</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import dns._features
<span class="gd">-if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+</span>
<span class="gi">+if sys.platform == &quot;win32&quot;:</span>
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    import dns.name
<span class="gi">+</span>
<span class="w"> </span>    _prefer_wmi = True
<span class="gd">-    import winreg</span>
<span class="gi">+</span>
<span class="gi">+    import winreg  # pylint: disable=import-error</span>
<span class="gi">+</span>
<span class="gi">+    # Keep pylint quiet on non-windows.</span>
<span class="w"> </span>    try:
<span class="gd">-        WindowsError is None</span>
<span class="gi">+        WindowsError is None  # pylint: disable=used-before-assignment</span>
<span class="w"> </span>    except KeyError:
<span class="w"> </span>        WindowsError = Exception
<span class="gd">-    if dns._features.have(&#39;wmi&#39;):</span>
<span class="gi">+</span>
<span class="gi">+    if dns._features.have(&quot;wmi&quot;):</span>
<span class="w"> </span>        import threading
<span class="gd">-        import pythoncom</span>
<span class="gd">-        import wmi</span>
<span class="gi">+</span>
<span class="gi">+        import pythoncom  # pylint: disable=import-error</span>
<span class="gi">+        import wmi  # pylint: disable=import-error</span>
<span class="gi">+</span>
<span class="w"> </span>        _have_wmi = True
<span class="w"> </span>    else:
<span class="w"> </span>        _have_wmi = False

<span class="gi">+    def _config_domain(domain):</span>
<span class="gi">+        # Sometimes DHCP servers add a &#39;.&#39; prefix to the default domain, and</span>
<span class="gi">+        # Windows just stores such values in the registry (see #687).</span>
<span class="gi">+        # Check for this and fix it.</span>
<span class="gi">+        if domain.startswith(&quot;.&quot;):</span>
<span class="gi">+            domain = domain[1:]</span>
<span class="gi">+        return dns.name.from_text(domain)</span>

<span class="w"> </span>    class DnsInfo:
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self):
<span class="w"> </span>            self.domain = None
<span class="w"> </span>            self.nameservers = []
<span class="w"> </span>            self.search = []
<span class="gd">-    if _have_wmi:</span>

<span class="gi">+    if _have_wmi:</span>

<span class="w"> </span>        class _WMIGetter(threading.Thread):
<span class="gd">-</span>
<span class="w"> </span>            def __init__(self):
<span class="w"> </span>                super().__init__()
<span class="w"> </span>                self.info = DnsInfo()
<span class="gd">-    else:</span>

<span class="gi">+            def run(self):</span>
<span class="gi">+                pythoncom.CoInitialize()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    system = wmi.WMI()</span>
<span class="gi">+                    for interface in system.Win32_NetworkAdapterConfiguration():</span>
<span class="gi">+                        if interface.IPEnabled and interface.DNSServerSearchOrder:</span>
<span class="gi">+                            self.info.nameservers = list(interface.DNSServerSearchOrder)</span>
<span class="gi">+                            if interface.DNSDomain:</span>
<span class="gi">+                                self.info.domain = _config_domain(interface.DNSDomain)</span>
<span class="gi">+                            if interface.DNSDomainSuffixSearchOrder:</span>
<span class="gi">+                                self.info.search = [</span>
<span class="gi">+                                    _config_domain(x)</span>
<span class="gi">+                                    for x in interface.DNSDomainSuffixSearchOrder</span>
<span class="gi">+                                ]</span>
<span class="gi">+                            break</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    pythoncom.CoUninitialize()</span>

<span class="gd">-        class _WMIGetter:</span>
<span class="gd">-            pass</span>
<span class="gi">+            def get(self):</span>
<span class="gi">+                # We always run in a separate thread to avoid any issues with</span>
<span class="gi">+                # the COM threading model.</span>
<span class="gi">+                self.start()</span>
<span class="gi">+                self.join()</span>
<span class="gi">+                return self.info</span>

<span class="gi">+    else:</span>

<span class="gd">-    class _RegistryGetter:</span>
<span class="gi">+        class _WMIGetter:  # type: ignore</span>
<span class="gi">+            pass</span>

<span class="gi">+    class _RegistryGetter:</span>
<span class="w"> </span>        def __init__(self):
<span class="w"> </span>            self.info = DnsInfo()

<span class="gi">+        def _determine_split_char(self, entry):</span>
<span class="gi">+            #</span>
<span class="gi">+            # The windows registry irritatingly changes the list element</span>
<span class="gi">+            # delimiter in between &#39; &#39; and &#39;,&#39; (and vice-versa) in various</span>
<span class="gi">+            # versions of windows.</span>
<span class="gi">+            #</span>
<span class="gi">+            if entry.find(&quot; &quot;) &gt;= 0:</span>
<span class="gi">+                split_char = &quot; &quot;</span>
<span class="gi">+            elif entry.find(&quot;,&quot;) &gt;= 0:</span>
<span class="gi">+                split_char = &quot;,&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                # probably a singleton; treat as a space-separated list.</span>
<span class="gi">+                split_char = &quot; &quot;</span>
<span class="gi">+            return split_char</span>
<span class="gi">+</span>
<span class="gi">+        def _config_nameservers(self, nameservers):</span>
<span class="gi">+            split_char = self._determine_split_char(nameservers)</span>
<span class="gi">+            ns_list = nameservers.split(split_char)</span>
<span class="gi">+            for ns in ns_list:</span>
<span class="gi">+                if ns not in self.info.nameservers:</span>
<span class="gi">+                    self.info.nameservers.append(ns)</span>
<span class="gi">+</span>
<span class="gi">+        def _config_search(self, search):</span>
<span class="gi">+            split_char = self._determine_split_char(search)</span>
<span class="gi">+            search_list = search.split(split_char)</span>
<span class="gi">+            for s in search_list:</span>
<span class="gi">+                s = _config_domain(s)</span>
<span class="gi">+                if s not in self.info.search:</span>
<span class="gi">+                    self.info.search.append(s)</span>
<span class="gi">+</span>
<span class="gi">+        def _config_fromkey(self, key, always_try_domain):</span>
<span class="gi">+            try:</span>
<span class="gi">+                servers, _ = winreg.QueryValueEx(key, &quot;NameServer&quot;)</span>
<span class="gi">+            except WindowsError:</span>
<span class="gi">+                servers = None</span>
<span class="gi">+            if servers:</span>
<span class="gi">+                self._config_nameservers(servers)</span>
<span class="gi">+            if servers or always_try_domain:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    dom, _ = winreg.QueryValueEx(key, &quot;Domain&quot;)</span>
<span class="gi">+                    if dom:</span>
<span class="gi">+                        self.info.domain = _config_domain(dom)</span>
<span class="gi">+                except WindowsError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    servers, _ = winreg.QueryValueEx(key, &quot;DhcpNameServer&quot;)</span>
<span class="gi">+                except WindowsError:</span>
<span class="gi">+                    servers = None</span>
<span class="gi">+                if servers:</span>
<span class="gi">+                    self._config_nameservers(servers)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        dom, _ = winreg.QueryValueEx(key, &quot;DhcpDomain&quot;)</span>
<span class="gi">+                        if dom:</span>
<span class="gi">+                            self.info.domain = _config_domain(dom)</span>
<span class="gi">+                    except WindowsError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                search, _ = winreg.QueryValueEx(key, &quot;SearchList&quot;)</span>
<span class="gi">+            except WindowsError:</span>
<span class="gi">+                search = None</span>
<span class="gi">+            if search is None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    search, _ = winreg.QueryValueEx(key, &quot;DhcpSearchList&quot;)</span>
<span class="gi">+                except WindowsError:</span>
<span class="gi">+                    search = None</span>
<span class="gi">+            if search:</span>
<span class="gi">+                self._config_search(search)</span>
<span class="gi">+</span>
<span class="gi">+        def _is_nic_enabled(self, lm, guid):</span>
<span class="gi">+            # Look in the Windows Registry to determine whether the network</span>
<span class="gi">+            # interface corresponding to the given guid is enabled.</span>
<span class="gi">+            #</span>
<span class="gi">+            # (Code contributed by Paul Marks, thanks!)</span>
<span class="gi">+            #</span>
<span class="gi">+            try:</span>
<span class="gi">+                # This hard-coded location seems to be consistent, at least</span>
<span class="gi">+                # from Windows 2000 through Vista.</span>
<span class="gi">+                connection_key = winreg.OpenKey(</span>
<span class="gi">+                    lm,</span>
<span class="gi">+                    r&quot;SYSTEM\CurrentControlSet\Control\Network&quot;</span>
<span class="gi">+                    r&quot;\{4D36E972-E325-11CE-BFC1-08002BE10318}&quot;</span>
<span class="gi">+                    r&quot;\%s\Connection&quot; % guid,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # The PnpInstanceID points to a key inside Enum</span>
<span class="gi">+                    (pnp_id, ttype) = winreg.QueryValueEx(</span>
<span class="gi">+                        connection_key, &quot;PnpInstanceID&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    if ttype != winreg.REG_SZ:</span>
<span class="gi">+                        raise ValueError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+                    device_key = winreg.OpenKey(</span>
<span class="gi">+                        lm, r&quot;SYSTEM\CurrentControlSet\Enum\%s&quot; % pnp_id</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        # Get ConfigFlags for this device</span>
<span class="gi">+                        (flags, ttype) = winreg.QueryValueEx(device_key, &quot;ConfigFlags&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                        if ttype != winreg.REG_DWORD:</span>
<span class="gi">+                            raise ValueError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+                        # Based on experimentation, bit 0x1 indicates that the</span>
<span class="gi">+                        # device is disabled.</span>
<span class="gi">+                        #</span>
<span class="gi">+                        # XXXRTH I suspect we really want to &amp; with 0x03 so</span>
<span class="gi">+                        # that CONFIGFLAGS_REMOVED devices are also ignored,</span>
<span class="gi">+                        # but we&#39;re shifting to WMI as ConfigFlags is not</span>
<span class="gi">+                        # supposed to be used.</span>
<span class="gi">+                        return not flags &amp; 0x1</span>
<span class="gi">+</span>
<span class="gi">+                    finally:</span>
<span class="gi">+                        device_key.Close()</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    connection_key.Close()</span>
<span class="gi">+            except Exception:  # pragma: no cover</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="w"> </span>        def get(self):
<span class="w"> </span>            &quot;&quot;&quot;Extract resolver configuration from the Windows registry.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+</span>
<span class="gi">+            lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)</span>
<span class="gi">+            try:</span>
<span class="gi">+                tcp_params = winreg.OpenKey(</span>
<span class="gi">+                    lm, r&quot;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._config_fromkey(tcp_params, True)</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    tcp_params.Close()</span>
<span class="gi">+                interfaces = winreg.OpenKey(</span>
<span class="gi">+                    lm,</span>
<span class="gi">+                    r&quot;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+                try:</span>
<span class="gi">+                    i = 0</span>
<span class="gi">+                    while True:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            guid = winreg.EnumKey(interfaces, i)</span>
<span class="gi">+                            i += 1</span>
<span class="gi">+                            key = winreg.OpenKey(interfaces, guid)</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                if not self._is_nic_enabled(lm, guid):</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                                self._config_fromkey(key, False)</span>
<span class="gi">+                            finally:</span>
<span class="gi">+                                key.Close()</span>
<span class="gi">+                        except EnvironmentError:</span>
<span class="gi">+                            break</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    interfaces.Close()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                lm.Close()</span>
<span class="gi">+            return self.info</span>
<span class="gi">+</span>
<span class="w"> </span>    _getter_class: Any
<span class="w"> </span>    if _have_wmi and _prefer_wmi:
<span class="w"> </span>        _getter_class = _WMIGetter
<span class="gu">@@ -55,4 +248,5 @@ if sys.platform == &#39;win32&#39;:</span>

<span class="w"> </span>    def get_dns_info():
<span class="w"> </span>        &quot;&quot;&quot;Extract resolver configuration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        getter = _getter_class()</span>
<span class="gi">+        return getter.get()</span>
<span class="gh">diff --git a/dns/wire.py b/dns/wire.py</span>
<span class="gh">index 13bdace..9f9b157 100644</span>
<span class="gd">--- a/dns/wire.py</span>
<span class="gi">+++ b/dns/wire.py</span>
<span class="gu">@@ -1,16 +1,89 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import struct
<span class="w"> </span>from typing import Iterator, Optional, Tuple
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.name


<span class="w"> </span>class Parser:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, wire: bytes, current: int=0):</span>
<span class="gi">+    def __init__(self, wire: bytes, current: int = 0):</span>
<span class="w"> </span>        self.wire = wire
<span class="w"> </span>        self.current = 0
<span class="w"> </span>        self.end = len(self.wire)
<span class="w"> </span>        if current:
<span class="w"> </span>            self.seek(current)
<span class="w"> </span>        self.furthest = current
<span class="gi">+</span>
<span class="gi">+    def remaining(self) -&gt; int:</span>
<span class="gi">+        return self.end - self.current</span>
<span class="gi">+</span>
<span class="gi">+    def get_bytes(self, size: int) -&gt; bytes:</span>
<span class="gi">+        assert size &gt;= 0</span>
<span class="gi">+        if size &gt; self.remaining():</span>
<span class="gi">+            raise dns.exception.FormError</span>
<span class="gi">+        output = self.wire[self.current : self.current + size]</span>
<span class="gi">+        self.current += size</span>
<span class="gi">+        self.furthest = max(self.furthest, self.current)</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    def get_counted_bytes(self, length_size: int = 1) -&gt; bytes:</span>
<span class="gi">+        length = int.from_bytes(self.get_bytes(length_size), &quot;big&quot;)</span>
<span class="gi">+        return self.get_bytes(length)</span>
<span class="gi">+</span>
<span class="gi">+    def get_remaining(self) -&gt; bytes:</span>
<span class="gi">+        return self.get_bytes(self.remaining())</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint8(self) -&gt; int:</span>
<span class="gi">+        return struct.unpack(&quot;!B&quot;, self.get_bytes(1))[0]</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint16(self) -&gt; int:</span>
<span class="gi">+        return struct.unpack(&quot;!H&quot;, self.get_bytes(2))[0]</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint32(self) -&gt; int:</span>
<span class="gi">+        return struct.unpack(&quot;!I&quot;, self.get_bytes(4))[0]</span>
<span class="gi">+</span>
<span class="gi">+    def get_uint48(self) -&gt; int:</span>
<span class="gi">+        return int.from_bytes(self.get_bytes(6), &quot;big&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_struct(self, format: str) -&gt; Tuple:</span>
<span class="gi">+        return struct.unpack(format, self.get_bytes(struct.calcsize(format)))</span>
<span class="gi">+</span>
<span class="gi">+    def get_name(self, origin: Optional[&quot;dns.name.Name&quot;] = None) -&gt; &quot;dns.name.Name&quot;:</span>
<span class="gi">+        name = dns.name.from_wire_parser(self)</span>
<span class="gi">+        if origin:</span>
<span class="gi">+            name = name.relativize(origin)</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def seek(self, where: int) -&gt; None:</span>
<span class="gi">+        # Note that seeking to the end is OK!  (If you try to read</span>
<span class="gi">+        # after such a seek, you&#39;ll get an exception as expected.)</span>
<span class="gi">+        if where &lt; 0 or where &gt; self.end:</span>
<span class="gi">+            raise dns.exception.FormError</span>
<span class="gi">+        self.current = where</span>
<span class="gi">+</span>
<span class="gi">+    @contextlib.contextmanager</span>
<span class="gi">+    def restrict_to(self, size: int) -&gt; Iterator:</span>
<span class="gi">+        assert size &gt;= 0</span>
<span class="gi">+        if size &gt; self.remaining():</span>
<span class="gi">+            raise dns.exception.FormError</span>
<span class="gi">+        saved_end = self.end</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.end = self.current + size</span>
<span class="gi">+            yield</span>
<span class="gi">+            # We make this check here and not in the finally as we</span>
<span class="gi">+            # don&#39;t want to raise if we&#39;re already raising for some</span>
<span class="gi">+            # other reason.</span>
<span class="gi">+            if self.current != self.end:</span>
<span class="gi">+                raise dns.exception.FormError</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.end = saved_end</span>
<span class="gi">+</span>
<span class="gi">+    @contextlib.contextmanager</span>
<span class="gi">+    def restore_furthest(self) -&gt; Iterator:</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.current = self.furthest</span>
<span class="gh">diff --git a/dns/xfr.py b/dns/xfr.py</span>
<span class="gh">index 3d6d66f..dd247d3 100644</span>
<span class="gd">--- a/dns/xfr.py</span>
<span class="gi">+++ b/dns/xfr.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, List, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.message
<span class="w"> </span>import dns.name
<span class="gu">@@ -15,7 +33,7 @@ class TransferError(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;A zone transfer response got a non-zero rcode.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, rcode):
<span class="gd">-        message = &#39;Zone transfer error: %s&#39; % dns.rcode.to_text(rcode)</span>
<span class="gi">+        message = &quot;Zone transfer error: %s&quot; % dns.rcode.to_text(rcode)</span>
<span class="w"> </span>        super().__init__(message)
<span class="w"> </span>        self.rcode = rcode

<span class="gu">@@ -33,9 +51,13 @@ class Inbound:</span>
<span class="w"> </span>    State machine for zone transfers.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, txn_manager: dns.transaction.TransactionManager,</span>
<span class="gd">-        rdtype: dns.rdatatype.RdataType=dns.rdatatype.AXFR, serial:</span>
<span class="gd">-        Optional[int]=None, is_udp: bool=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        txn_manager: dns.transaction.TransactionManager,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType = dns.rdatatype.AXFR,</span>
<span class="gi">+        serial: Optional[int] = None,</span>
<span class="gi">+        is_udp: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize an inbound zone transfer.

<span class="w"> </span>        *txn_manager* is a :py:class:`dns.transaction.TransactionManager`.
<span class="gu">@@ -53,19 +75,18 @@ class Inbound:</span>
<span class="w"> </span>        self.rdtype = rdtype
<span class="w"> </span>        if rdtype == dns.rdatatype.IXFR:
<span class="w"> </span>            if serial is None:
<span class="gd">-                raise ValueError(&#39;a starting serial must be supplied for IXFRs&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                raise ValueError(&quot;a starting serial must be supplied for IXFRs&quot;)</span>
<span class="w"> </span>        elif is_udp:
<span class="gd">-            raise ValueError(&#39;is_udp specified for AXFR&#39;)</span>
<span class="gi">+            raise ValueError(&quot;is_udp specified for AXFR&quot;)</span>
<span class="w"> </span>        self.serial = serial
<span class="w"> </span>        self.is_udp = is_udp
<span class="gd">-        _, _, self.origin = txn_manager.origin_information()</span>
<span class="gi">+        (_, _, self.origin) = txn_manager.origin_information()</span>
<span class="w"> </span>        self.soa_rdataset: Optional[dns.rdataset.Rdataset] = None
<span class="w"> </span>        self.done = False
<span class="w"> </span>        self.expecting_SOA = False
<span class="w"> </span>        self.delete_mode = False

<span class="gd">-    def process_message(self, message: dns.message.Message) -&gt;bool:</span>
<span class="gi">+    def process_message(self, message: dns.message.Message) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process one message in the transfer.

<span class="w"> </span>        The message should have the same relativization as was specified when
<span class="gu">@@ -74,7 +95,148 @@ class Inbound:</span>

<span class="w"> </span>        Returns `True` if the transfer is complete, and `False` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.txn is None:</span>
<span class="gi">+            replacement = self.rdtype == dns.rdatatype.AXFR</span>
<span class="gi">+            self.txn = self.txn_manager.writer(replacement)</span>
<span class="gi">+        rcode = message.rcode()</span>
<span class="gi">+        if rcode != dns.rcode.NOERROR:</span>
<span class="gi">+            raise TransferError(rcode)</span>
<span class="gi">+        #</span>
<span class="gi">+        # We don&#39;t require a question section, but if it is present is</span>
<span class="gi">+        # should be correct.</span>
<span class="gi">+        #</span>
<span class="gi">+        if len(message.question) &gt; 0:</span>
<span class="gi">+            if message.question[0].name != self.origin:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;wrong question name&quot;)</span>
<span class="gi">+            if message.question[0].rdtype != self.rdtype:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;wrong question rdatatype&quot;)</span>
<span class="gi">+        answer_index = 0</span>
<span class="gi">+        if self.soa_rdataset is None:</span>
<span class="gi">+            #</span>
<span class="gi">+            # This is the first message.  We&#39;re expecting an SOA at</span>
<span class="gi">+            # the origin.</span>
<span class="gi">+            #</span>
<span class="gi">+            if not message.answer or message.answer[0].name != self.origin:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;No answer or RRset not for zone origin&quot;)</span>
<span class="gi">+            rrset = message.answer[0]</span>
<span class="gi">+            rdataset = rrset</span>
<span class="gi">+            if rdataset.rdtype != dns.rdatatype.SOA:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;first RRset is not an SOA&quot;)</span>
<span class="gi">+            answer_index = 1</span>
<span class="gi">+            self.soa_rdataset = rdataset.copy()</span>
<span class="gi">+            if self.rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                if self.soa_rdataset[0].serial == self.serial:</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # We&#39;re already up-to-date.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    self.done = True</span>
<span class="gi">+                elif dns.serial.Serial(self.soa_rdataset[0].serial) &lt; self.serial:</span>
<span class="gi">+                    # It went backwards!</span>
<span class="gi">+                    raise SerialWentBackwards</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if self.is_udp and len(message.answer[answer_index:]) == 0:</span>
<span class="gi">+                        #</span>
<span class="gi">+                        # There are no more records, so this is the</span>
<span class="gi">+                        # &quot;truncated&quot; response.  Say to use TCP</span>
<span class="gi">+                        #</span>
<span class="gi">+                        raise UseTCP</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # Note we&#39;re expecting another SOA so we can detect</span>
<span class="gi">+                    # if this IXFR response is an AXFR-style response.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    self.expecting_SOA = True</span>
<span class="gi">+        #</span>
<span class="gi">+        # Process the answer section (other than the initial SOA in</span>
<span class="gi">+        # the first message).</span>
<span class="gi">+        #</span>
<span class="gi">+        for rrset in message.answer[answer_index:]:</span>
<span class="gi">+            name = rrset.name</span>
<span class="gi">+            rdataset = rrset</span>
<span class="gi">+            if self.done:</span>
<span class="gi">+                raise dns.exception.FormError(&quot;answers after final SOA&quot;)</span>
<span class="gi">+            assert self.txn is not None  # for mypy</span>
<span class="gi">+            if rdataset.rdtype == dns.rdatatype.SOA and name == self.origin:</span>
<span class="gi">+                #</span>
<span class="gi">+                # Every time we see an origin SOA delete_mode inverts</span>
<span class="gi">+                #</span>
<span class="gi">+                if self.rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                    self.delete_mode = not self.delete_mode</span>
<span class="gi">+                #</span>
<span class="gi">+                # If this SOA Rdataset is equal to the first we saw</span>
<span class="gi">+                # then we&#39;re finished. If this is an IXFR we also</span>
<span class="gi">+                # check that we&#39;re seeing the record in the expected</span>
<span class="gi">+                # part of the response.</span>
<span class="gi">+                #</span>
<span class="gi">+                if rdataset == self.soa_rdataset and (</span>
<span class="gi">+                    self.rdtype == dns.rdatatype.AXFR</span>
<span class="gi">+                    or (self.rdtype == dns.rdatatype.IXFR and self.delete_mode)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # This is the final SOA</span>
<span class="gi">+                    #</span>
<span class="gi">+                    if self.expecting_SOA:</span>
<span class="gi">+                        # We got an empty IXFR sequence!</span>
<span class="gi">+                        raise dns.exception.FormError(&quot;empty IXFR sequence&quot;)</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        self.rdtype == dns.rdatatype.IXFR</span>
<span class="gi">+                        and self.serial != rdataset[0].serial</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        raise dns.exception.FormError(&quot;unexpected end of IXFR sequence&quot;)</span>
<span class="gi">+                    self.txn.replace(name, rdataset)</span>
<span class="gi">+                    self.txn.commit()</span>
<span class="gi">+                    self.txn = None</span>
<span class="gi">+                    self.done = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # This is not the final SOA</span>
<span class="gi">+                    #</span>
<span class="gi">+                    self.expecting_SOA = False</span>
<span class="gi">+                    if self.rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                        if self.delete_mode:</span>
<span class="gi">+                            # This is the start of an IXFR deletion set</span>
<span class="gi">+                            if rdataset[0].serial != self.serial:</span>
<span class="gi">+                                raise dns.exception.FormError(</span>
<span class="gi">+                                    &quot;IXFR base serial mismatch&quot;</span>
<span class="gi">+                                )</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            # This is the start of an IXFR addition set</span>
<span class="gi">+                            self.serial = rdataset[0].serial</span>
<span class="gi">+                            self.txn.replace(name, rdataset)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # We saw a non-final SOA for the origin in an AXFR.</span>
<span class="gi">+                        raise dns.exception.FormError(&quot;unexpected origin SOA in AXFR&quot;)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.expecting_SOA:</span>
<span class="gi">+                #</span>
<span class="gi">+                # We made an IXFR request and are expecting another</span>
<span class="gi">+                # SOA RR, but saw something else, so this must be an</span>
<span class="gi">+                # AXFR response.</span>
<span class="gi">+                #</span>
<span class="gi">+                self.rdtype = dns.rdatatype.AXFR</span>
<span class="gi">+                self.expecting_SOA = False</span>
<span class="gi">+                self.delete_mode = False</span>
<span class="gi">+                self.txn.rollback()</span>
<span class="gi">+                self.txn = self.txn_manager.writer(True)</span>
<span class="gi">+                #</span>
<span class="gi">+                # Note we are falling through into the code below</span>
<span class="gi">+                # so whatever rdataset this was gets written.</span>
<span class="gi">+                #</span>
<span class="gi">+            # Add or remove the data</span>
<span class="gi">+            if self.delete_mode:</span>
<span class="gi">+                self.txn.delete_exact(name, rdataset)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.txn.add(name, rdataset)</span>
<span class="gi">+        if self.is_udp and not self.done:</span>
<span class="gi">+            #</span>
<span class="gi">+            # This is a UDP IXFR and we didn&#39;t get to done, and we didn&#39;t</span>
<span class="gi">+            # get the proper &quot;truncated&quot; response</span>
<span class="gi">+            #</span>
<span class="gi">+            raise dns.exception.FormError(&quot;unexpected end of UDP IXFR&quot;)</span>
<span class="gi">+        return self.done</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # Inbounds are context managers.</span>
<span class="gi">+    #</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -85,13 +247,18 @@ class Inbound:</span>
<span class="w"> </span>        return False


<span class="gd">-def make_query(txn_manager: dns.transaction.TransactionManager, serial:</span>
<span class="gd">-    Optional[int]=0, use_edns: Optional[Union[int, bool]]=None, ednsflags:</span>
<span class="gd">-    Optional[int]=None, payload: Optional[int]=None, request_payload:</span>
<span class="gd">-    Optional[int]=None, options: Optional[List[dns.edns.Option]]=None,</span>
<span class="gd">-    keyring: Any=None, keyname: Optional[dns.name.Name]=None, keyalgorithm:</span>
<span class="gd">-    Union[dns.name.Name, str]=dns.tsig.default_algorithm) -&gt;Tuple[dns.</span>
<span class="gd">-    message.QueryMessage, Optional[int]]:</span>
<span class="gi">+def make_query(</span>
<span class="gi">+    txn_manager: dns.transaction.TransactionManager,</span>
<span class="gi">+    serial: Optional[int] = 0,</span>
<span class="gi">+    use_edns: Optional[Union[int, bool]] = None,</span>
<span class="gi">+    ednsflags: Optional[int] = None,</span>
<span class="gi">+    payload: Optional[int] = None,</span>
<span class="gi">+    request_payload: Optional[int] = None,</span>
<span class="gi">+    options: Optional[List[dns.edns.Option]] = None,</span>
<span class="gi">+    keyring: Any = None,</span>
<span class="gi">+    keyname: Optional[dns.name.Name] = None,</span>
<span class="gi">+    keyalgorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,</span>
<span class="gi">+) -&gt; Tuple[dns.message.QueryMessage, Optional[int]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make an AXFR or IXFR query.

<span class="w"> </span>    *txn_manager* is a ``dns.transaction.TransactionManager``, typically a
<span class="gu">@@ -111,10 +278,50 @@ def make_query(txn_manager: dns.transaction.TransactionManager, serial:</span>

<span class="w"> </span>    Returns a `(query, serial)` tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (zone_origin, _, origin) = txn_manager.origin_information()</span>
<span class="gi">+    if zone_origin is None:</span>
<span class="gi">+        raise ValueError(&quot;no zone origin&quot;)</span>
<span class="gi">+    if serial is None:</span>
<span class="gi">+        rdtype = dns.rdatatype.AXFR</span>
<span class="gi">+    elif not isinstance(serial, int):</span>
<span class="gi">+        raise ValueError(&quot;serial is not an integer&quot;)</span>
<span class="gi">+    elif serial == 0:</span>
<span class="gi">+        with txn_manager.reader() as txn:</span>
<span class="gi">+            rdataset = txn.get(origin, &quot;SOA&quot;)</span>
<span class="gi">+            if rdataset:</span>
<span class="gi">+                serial = rdataset[0].serial</span>
<span class="gi">+                rdtype = dns.rdatatype.IXFR</span>
<span class="gi">+            else:</span>
<span class="gi">+                serial = None</span>
<span class="gi">+                rdtype = dns.rdatatype.AXFR</span>
<span class="gi">+    elif serial &gt; 0 and serial &lt; 4294967296:</span>
<span class="gi">+        rdtype = dns.rdatatype.IXFR</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;serial out-of-range&quot;)</span>
<span class="gi">+    rdclass = txn_manager.get_class()</span>
<span class="gi">+    q = dns.message.make_query(</span>
<span class="gi">+        zone_origin,</span>
<span class="gi">+        rdtype,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        use_edns,</span>
<span class="gi">+        False,</span>
<span class="gi">+        ednsflags,</span>
<span class="gi">+        payload,</span>
<span class="gi">+        request_payload,</span>
<span class="gi">+        options,</span>
<span class="gi">+    )</span>
<span class="gi">+    if serial is not None:</span>
<span class="gi">+        rdata = dns.rdata.from_text(rdclass, &quot;SOA&quot;, f&quot;. . {serial} 0 0 0 0&quot;)</span>
<span class="gi">+        rrset = q.find_rrset(</span>
<span class="gi">+            q.authority, zone_origin, rdclass, dns.rdatatype.SOA, create=True</span>
<span class="gi">+        )</span>
<span class="gi">+        rrset.add(rdata, 0)</span>
<span class="gi">+    if keyring is not None:</span>
<span class="gi">+        q.use_tsig(keyring, keyname, algorithm=keyalgorithm)</span>
<span class="gi">+    return (q, serial)</span>


<span class="gd">-def extract_serial_from_query(query: dns.message.Message) -&gt;Optional[int]:</span>
<span class="gi">+def extract_serial_from_query(query: dns.message.Message) -&gt; Optional[int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract the SOA serial number from query if it is an IXFR and return
<span class="w"> </span>    it, otherwise return None.

<span class="gu">@@ -123,4 +330,14 @@ def extract_serial_from_query(query: dns.message.Message) -&gt;Optional[int]:</span>
<span class="w"> </span>    Raises if the query is not an IXFR or AXFR, or if an IXFR doesn&#39;t have
<span class="w"> </span>    an appropriate SOA RRset in the authority section.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(query, dns.message.QueryMessage):</span>
<span class="gi">+        raise ValueError(&quot;query not a QueryMessage&quot;)</span>
<span class="gi">+    question = query.question[0]</span>
<span class="gi">+    if question.rdtype == dns.rdatatype.AXFR:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif question.rdtype != dns.rdatatype.IXFR:</span>
<span class="gi">+        raise ValueError(&quot;query is not an AXFR or IXFR&quot;)</span>
<span class="gi">+    soa = query.find_rrset(</span>
<span class="gi">+        query.authority, question.name, question.rdclass, dns.rdatatype.SOA</span>
<span class="gi">+    )</span>
<span class="gi">+    return soa[0].serial</span>
<span class="gh">diff --git a/dns/zone.py b/dns/zone.py</span>
<span class="gh">index 464b98d..844919e 100644</span>
<span class="gd">--- a/dns/zone.py</span>
<span class="gi">+++ b/dns/zone.py</span>
<span class="gu">@@ -1,9 +1,39 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Zones.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import io
<span class="w"> </span>import os
<span class="w"> </span>import struct
<span class="gd">-from typing import Any, Callable, Iterable, Iterator, List, MutableMapping, Optional, Set, Tuple, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    MutableMapping,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.grange
<span class="w"> </span>import dns.immutable
<span class="gu">@@ -55,6 +85,38 @@ class DigestVerificationFailure(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;The ZONEMD digest failed to verify.&quot;&quot;&quot;


<span class="gi">+def _validate_name(</span>
<span class="gi">+    name: dns.name.Name,</span>
<span class="gi">+    origin: Optional[dns.name.Name],</span>
<span class="gi">+    relativize: bool,</span>
<span class="gi">+) -&gt; dns.name.Name:</span>
<span class="gi">+    # This name validation code is shared by Zone and Version</span>
<span class="gi">+    if origin is None:</span>
<span class="gi">+        # This should probably never happen as other code (e.g.</span>
<span class="gi">+        # _rr_line) will notice the lack of an origin before us, but</span>
<span class="gi">+        # we check just in case!</span>
<span class="gi">+        raise KeyError(&quot;no zone origin is defined&quot;)</span>
<span class="gi">+    if name.is_absolute():</span>
<span class="gi">+        if not name.is_subdomain(origin):</span>
<span class="gi">+            raise KeyError(&quot;name parameter must be a subdomain of the zone origin&quot;)</span>
<span class="gi">+        if relativize:</span>
<span class="gi">+            name = name.relativize(origin)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # We have a relative name.  Make sure that the derelativized name is</span>
<span class="gi">+        # not too long.</span>
<span class="gi">+        try:</span>
<span class="gi">+            abs_name = name.derelativize(origin)</span>
<span class="gi">+        except dns.name.NameTooLong:</span>
<span class="gi">+            # We map dns.name.NameTooLong to KeyError to be consistent with</span>
<span class="gi">+            # the other exceptions above.</span>
<span class="gi">+            raise KeyError(&quot;relative name too long for zone&quot;)</span>
<span class="gi">+        if not relativize:</span>
<span class="gi">+            # We have a relative name in a non-relative zone, so use the</span>
<span class="gi">+            # derelativized name.</span>
<span class="gi">+            name = abs_name</span>
<span class="gi">+    return name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Zone(dns.transaction.TransactionManager):
<span class="w"> </span>    &quot;&quot;&quot;A DNS zone.

<span class="gu">@@ -65,16 +127,20 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>    if the name is relative it is treated as relative to the origin of
<span class="w"> </span>    the zone.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    node_factory: Callable[[], dns.node.Node] = dns.node.Node
<span class="gd">-    map_factory: Callable[[], MutableMapping[dns.name.Name, dns.node.Node]</span>
<span class="gd">-        ] = dict</span>
<span class="gd">-    writable_version_factory: Optional[Callable[[], &#39;WritableVersion&#39;]] = None</span>
<span class="gd">-    immutable_version_factory: Optional[Callable[[], &#39;ImmutableVersion&#39;]</span>
<span class="gd">-        ] = None</span>
<span class="gd">-    __slots__ = [&#39;rdclass&#39;, &#39;origin&#39;, &#39;nodes&#39;, &#39;relativize&#39;]</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, origin: Optional[Union[dns.name.Name, str]], rdclass:</span>
<span class="gd">-        dns.rdataclass.RdataClass=dns.rdataclass.IN, relativize: bool=True):</span>
<span class="gi">+    map_factory: Callable[[], MutableMapping[dns.name.Name, dns.node.Node]] = dict</span>
<span class="gi">+    writable_version_factory: Optional[Callable[[], &quot;WritableVersion&quot;]] = None</span>
<span class="gi">+    immutable_version_factory: Optional[Callable[[], &quot;ImmutableVersion&quot;]] = None</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;rdclass&quot;, &quot;origin&quot;, &quot;nodes&quot;, &quot;relativize&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        origin: Optional[Union[dns.name.Name, str]],</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a zone object.

<span class="w"> </span>        *origin* is the origin of the zone.  It may be a ``dns.name.Name``,
<span class="gu">@@ -86,18 +152,17 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>        *relativize*, a ``bool``, determine&#39;s whether domain names are
<span class="w"> </span>        relativized to the zone&#39;s origin.  The default is ``True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if origin is not None:
<span class="w"> </span>            if isinstance(origin, str):
<span class="w"> </span>                origin = dns.name.from_text(origin)
<span class="w"> </span>            elif not isinstance(origin, dns.name.Name):
<span class="gd">-                raise ValueError(</span>
<span class="gd">-                    &#39;origin parameter must be convertible to a DNS name&#39;)</span>
<span class="gi">+                raise ValueError(&quot;origin parameter must be convertible to a DNS name&quot;)</span>
<span class="w"> </span>            if not origin.is_absolute():
<span class="gd">-                raise ValueError(&#39;origin parameter must be an absolute name&#39;)</span>
<span class="gi">+                raise ValueError(&quot;origin parameter must be an absolute name&quot;)</span>
<span class="w"> </span>        self.origin = origin
<span class="w"> </span>        self.rdclass = rdclass
<span class="gd">-        self.nodes: MutableMapping[dns.name.Name, dns.node.Node</span>
<span class="gd">-            ] = self.map_factory()</span>
<span class="gi">+        self.nodes: MutableMapping[dns.name.Name, dns.node.Node] = self.map_factory()</span>
<span class="w"> </span>        self.relativize = relativize

<span class="w"> </span>    def __eq__(self, other):
<span class="gu">@@ -106,10 +171,14 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if not isinstance(other, Zone):
<span class="w"> </span>            return False
<span class="gd">-        if (self.rdclass != other.rdclass or self.origin != other.origin or</span>
<span class="gd">-            self.nodes != other.nodes):</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.rdclass != other.rdclass</span>
<span class="gi">+            or self.origin != other.origin</span>
<span class="gi">+            or self.nodes != other.nodes</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return False
<span class="w"> </span>        return True

<span class="gu">@@ -118,8 +187,18 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        return not self.__eq__(other)

<span class="gi">+    def _validate_name(self, name: Union[dns.name.Name, str]) -&gt; dns.name.Name:</span>
<span class="gi">+        # Note that any changes in this method should have corresponding changes</span>
<span class="gi">+        # made in the Version _validate_name() method.</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        elif not isinstance(name, dns.name.Name):</span>
<span class="gi">+            raise KeyError(&quot;name parameter must be convertible to a DNS name&quot;)</span>
<span class="gi">+        return _validate_name(name, self.origin, self.relativize)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        key = self._validate_name(key)
<span class="w"> </span>        return self.nodes[key]
<span class="gu">@@ -135,12 +214,26 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return self.nodes.__iter__()

<span class="gi">+    def keys(self):</span>
<span class="gi">+        return self.nodes.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self.nodes.values()</span>
<span class="gi">+</span>
<span class="gi">+    def items(self):</span>
<span class="gi">+        return self.nodes.items()</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key):</span>
<span class="gi">+        key = self._validate_name(key)</span>
<span class="gi">+        return self.nodes.get(key)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __contains__(self, key):
<span class="w"> </span>        key = self._validate_name(key)
<span class="w"> </span>        return key in self.nodes

<span class="gd">-    def find_node(self, name: Union[dns.name.Name, str], create: bool=False</span>
<span class="gd">-        ) -&gt;dns.node.Node:</span>
<span class="gi">+    def find_node(</span>
<span class="gi">+        self, name: Union[dns.name.Name, str], create: bool = False</span>
<span class="gi">+    ) -&gt; dns.node.Node:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find a node in the zone, possibly creating it.

<span class="w"> </span>        *name*: the name of the node to find.
<span class="gu">@@ -156,10 +249,19 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.node.Node``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_node(self, name: Union[dns.name.Name, str], create: bool=False</span>
<span class="gd">-        ) -&gt;Optional[dns.node.Node]:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        node = self.nodes.get(name)</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            if not create:</span>
<span class="gi">+                raise KeyError</span>
<span class="gi">+            node = self.node_factory()</span>
<span class="gi">+            self.nodes[name] = node</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def get_node(</span>
<span class="gi">+        self, name: Union[dns.name.Name, str], create: bool = False</span>
<span class="gi">+    ) -&gt; Optional[dns.node.Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a node in the zone, possibly creating it.

<span class="w"> </span>        This method is like ``find_node()``, except it returns None instead
<span class="gu">@@ -176,9 +278,14 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.node.Node`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def delete_node(self, name: Union[dns.name.Name, str]) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            node = self.find_node(name, create)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            node = None</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def delete_node(self, name: Union[dns.name.Name, str]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete the specified node if it exists.

<span class="w"> </span>        *name*: the name of the node to find.
<span class="gu">@@ -188,12 +295,18 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        It is not an error if the node does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def find_rdataset(self, name: Union[dns.name.Name, str], rdtype: Union[</span>
<span class="gd">-        dns.rdatatype.RdataType, str], covers: Union[dns.rdatatype.</span>
<span class="gd">-        RdataType, str]=dns.rdatatype.NONE, create: bool=False</span>
<span class="gd">-        ) -&gt;dns.rdataset.Rdataset:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        if name in self.nodes:</span>
<span class="gi">+            del self.nodes[name]</span>
<span class="gi">+</span>
<span class="gi">+    def find_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; dns.rdataset.Rdataset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone,
<span class="w"> </span>        and return an rdataset encapsulating it.

<span class="gu">@@ -227,12 +340,20 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_rdataset(self, name: Union[dns.name.Name, str], rdtype: Union[</span>
<span class="gd">-        dns.rdatatype.RdataType, str], covers: Union[dns.rdatatype.</span>
<span class="gd">-        RdataType, str]=dns.rdatatype.NONE, create: bool=False) -&gt;Optional[dns</span>
<span class="gd">-        .rdataset.Rdataset]:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        node = self.find_node(name, create)</span>
<span class="gi">+        return node.find_rdataset(self.rdclass, rdtype, covers, create)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; Optional[dns.rdataset.Rdataset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone.

<span class="w"> </span>        This method is like ``find_rdataset()``, except it returns None instead
<span class="gu">@@ -267,11 +388,19 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def delete_rdataset(self, name: Union[dns.name.Name, str], rdtype:</span>
<span class="gd">-        Union[dns.rdatatype.RdataType, str], covers: Union[dns.rdatatype.</span>
<span class="gd">-        RdataType, str]=dns.rdatatype.NONE) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rdataset = self.find_rdataset(name, rdtype, covers, create)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            rdataset = None</span>
<span class="gi">+        return rdataset</span>
<span class="gi">+</span>
<span class="gi">+    def delete_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete the rdataset matching *rdtype* and *covers*, if it
<span class="w"> </span>        exists at the node specified by *name*.

<span class="gu">@@ -294,10 +423,19 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>        makes RRSIGs much easier to work with than if RRSIGs covering different rdata
<span class="w"> </span>        types were aggregated into a single RRSIG rdataset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def replace_rdataset(self, name: Union[dns.name.Name, str], replacement:</span>
<span class="gd">-        dns.rdataset.Rdataset) -&gt;None:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        node = self.get_node(name)</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            node.delete_rdataset(self.rdclass, rdtype, covers)</span>
<span class="gi">+            if len(node) == 0:</span>
<span class="gi">+                self.delete_node(name)</span>
<span class="gi">+</span>
<span class="gi">+    def replace_rdataset(</span>
<span class="gi">+        self, name: Union[dns.name.Name, str], replacement: dns.rdataset.Rdataset</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace an rdataset at name.

<span class="w"> </span>        It is not an error if there is no rdataset matching I{replacement}.
<span class="gu">@@ -315,11 +453,18 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        *replacement*, a ``dns.rdataset.Rdataset``, the replacement rdataset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def find_rrset(self, name: Union[dns.name.Name, str], rdtype: Union[dns</span>
<span class="gd">-        .rdatatype.RdataType, str], covers: Union[dns.rdatatype.RdataType,</span>
<span class="gd">-        str]=dns.rdatatype.NONE) -&gt;dns.rrset.RRset:</span>
<span class="gi">+        if replacement.rdclass != self.rdclass:</span>
<span class="gi">+            raise ValueError(&quot;replacement.rdclass != zone.rdclass&quot;)</span>
<span class="gi">+        node = self.find_node(name, True)</span>
<span class="gi">+        node.replace_rdataset(replacement)</span>
<span class="gi">+</span>
<span class="gi">+    def find_rrset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; dns.rrset.RRset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone,
<span class="w"> </span>        and return an RRset encapsulating it.

<span class="gu">@@ -357,11 +502,21 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.rrset.RRset`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_rrset(self, name: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="gd">-        rdatatype.RdataType, str], covers: Union[dns.rdatatype.RdataType,</span>
<span class="gd">-        str]=dns.rdatatype.NONE) -&gt;Optional[dns.rrset.RRset]:</span>
<span class="gi">+        vname = self._validate_name(name)</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        rdataset = self.nodes[vname].find_rdataset(self.rdclass, rdtype, covers)</span>
<span class="gi">+        rrset = dns.rrset.RRset(vname, self.rdclass, rdtype, covers)</span>
<span class="gi">+        rrset.update(rdataset)</span>
<span class="gi">+        return rrset</span>
<span class="gi">+</span>
<span class="gi">+    def get_rrset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Union[dns.name.Name, str],</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str],</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; Optional[dns.rrset.RRset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone,
<span class="w"> </span>        and return an RRset encapsulating it.

<span class="gu">@@ -395,12 +550,18 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.rrset.RRset`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def iterate_rdatasets(self, rdtype: Union[dns.rdatatype.RdataType, str]</span>
<span class="gd">-        =dns.rdatatype.ANY, covers: Union[dns.rdatatype.RdataType, str]=dns</span>
<span class="gd">-        .rdatatype.NONE) -&gt;Iterator[Tuple[dns.name.Name, dns.rdataset.Rdataset]</span>
<span class="gd">-        ]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rrset = self.find_rrset(name, rdtype, covers)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            rrset = None</span>
<span class="gi">+        return rrset</span>
<span class="gi">+</span>
<span class="gi">+    def iterate_rdatasets(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.ANY,</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; Iterator[Tuple[dns.name.Name, dns.rdataset.Rdataset]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a generator which yields (name, rdataset) tuples for
<span class="w"> </span>        all rdatasets in the zone which have the specified *rdtype*
<span class="w"> </span>        and *covers*.  If *rdtype* is ``dns.rdatatype.ANY``, the default,
<span class="gu">@@ -418,11 +579,21 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>        covering different rdata types were aggregated into a single
<span class="w"> </span>        RRSIG rdataset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def iterate_rdatas(self, rdtype: Union[dns.rdatatype.RdataType, str]=</span>
<span class="gd">-        dns.rdatatype.ANY, covers: Union[dns.rdatatype.RdataType, str]=dns.</span>
<span class="gd">-        rdatatype.NONE) -&gt;Iterator[Tuple[dns.name.Name, int, dns.rdata.Rdata]]:</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        for name, node in self.items():</span>
<span class="gi">+            for rds in node:</span>
<span class="gi">+                if rdtype == dns.rdatatype.ANY or (</span>
<span class="gi">+                    rds.rdtype == rdtype and rds.covers == covers</span>
<span class="gi">+                ):</span>
<span class="gi">+                    yield (name, rds)</span>
<span class="gi">+</span>
<span class="gi">+    def iterate_rdatas(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.ANY,</span>
<span class="gi">+        covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; Iterator[Tuple[dns.name.Name, int, dns.rdata.Rdata]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a generator which yields (name, ttl, rdata) tuples for
<span class="w"> </span>        all rdatas in the zone which have the specified *rdtype*
<span class="w"> </span>        and *covers*.  If *rdtype* is ``dns.rdatatype.ANY``, the default,
<span class="gu">@@ -440,11 +611,26 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>        covering different rdata types were aggregated into a single
<span class="w"> </span>        RRSIG rdataset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_file(self, f: Any, sorted: bool=True, relativize: bool=True, nl:</span>
<span class="gd">-        Optional[str]=None, want_comments: bool=False, want_origin: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        for name, node in self.items():</span>
<span class="gi">+            for rds in node:</span>
<span class="gi">+                if rdtype == dns.rdatatype.ANY or (</span>
<span class="gi">+                    rds.rdtype == rdtype and rds.covers == covers</span>
<span class="gi">+                ):</span>
<span class="gi">+                    for rdata in rds:</span>
<span class="gi">+                        yield (name, rds.ttl, rdata)</span>
<span class="gi">+</span>
<span class="gi">+    def to_file(</span>
<span class="gi">+        self,</span>
<span class="gi">+        f: Any,</span>
<span class="gi">+        sorted: bool = True,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        nl: Optional[str] = None,</span>
<span class="gi">+        want_comments: bool = False,</span>
<span class="gi">+        want_origin: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a zone to a file.

<span class="w"> </span>        *f*, a file or `str`.  If *f* is a string, it is treated
<span class="gu">@@ -471,11 +657,68 @@ class Zone(dns.transaction.TransactionManager):</span>
<span class="w"> </span>        the start of the file.  If ``False``, the default, do not emit
<span class="w"> </span>        one.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def to_text(self, sorted: bool=True, relativize: bool=True, nl:</span>
<span class="gd">-        Optional[str]=None, want_comments: bool=False, want_origin: bool=False</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        if isinstance(f, str):</span>
<span class="gi">+            cm: contextlib.AbstractContextManager = open(f, &quot;wb&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cm = contextlib.nullcontext(f)</span>
<span class="gi">+        with cm as f:</span>
<span class="gi">+            # must be in this way, f.encoding may contain None, or even</span>
<span class="gi">+            # attribute may not be there</span>
<span class="gi">+            file_enc = getattr(f, &quot;encoding&quot;, None)</span>
<span class="gi">+            if file_enc is None:</span>
<span class="gi">+                file_enc = &quot;utf-8&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if nl is None:</span>
<span class="gi">+                # binary mode, &#39;\n&#39; is not enough</span>
<span class="gi">+                nl_b = os.linesep.encode(file_enc)</span>
<span class="gi">+                nl = &quot;\n&quot;</span>
<span class="gi">+            elif isinstance(nl, str):</span>
<span class="gi">+                nl_b = nl.encode(file_enc)</span>
<span class="gi">+            else:</span>
<span class="gi">+                nl_b = nl</span>
<span class="gi">+                nl = nl.decode()</span>
<span class="gi">+</span>
<span class="gi">+            if want_origin:</span>
<span class="gi">+                assert self.origin is not None</span>
<span class="gi">+                l = &quot;$ORIGIN &quot; + self.origin.to_text()</span>
<span class="gi">+                l_b = l.encode(file_enc)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    f.write(l_b)</span>
<span class="gi">+                    f.write(nl_b)</span>
<span class="gi">+                except TypeError:  # textual mode</span>
<span class="gi">+                    f.write(l)</span>
<span class="gi">+                    f.write(nl)</span>
<span class="gi">+</span>
<span class="gi">+            if sorted:</span>
<span class="gi">+                names = list(self.keys())</span>
<span class="gi">+                names.sort()</span>
<span class="gi">+            else:</span>
<span class="gi">+                names = self.keys()</span>
<span class="gi">+            for n in names:</span>
<span class="gi">+                l = self[n].to_text(</span>
<span class="gi">+                    n,</span>
<span class="gi">+                    origin=self.origin,</span>
<span class="gi">+                    relativize=relativize,</span>
<span class="gi">+                    want_comments=want_comments,</span>
<span class="gi">+                )</span>
<span class="gi">+                l_b = l.encode(file_enc)</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    f.write(l_b)</span>
<span class="gi">+                    f.write(nl_b)</span>
<span class="gi">+                except TypeError:  # textual mode</span>
<span class="gi">+                    f.write(l)</span>
<span class="gi">+                    f.write(nl)</span>
<span class="gi">+</span>
<span class="gi">+    def to_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sorted: bool = True,</span>
<span class="gi">+        relativize: bool = True,</span>
<span class="gi">+        nl: Optional[str] = None,</span>
<span class="gi">+        want_comments: bool = False,</span>
<span class="gi">+        want_origin: bool = False,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a zone&#39;s text as though it were written to a file.

<span class="w"> </span>        *sorted*, a ``bool``.  If True, the default, then the file
<span class="gu">@@ -501,9 +744,13 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        temp_buffer = io.StringIO()</span>
<span class="gi">+        self.to_file(temp_buffer, sorted, relativize, nl, want_comments, want_origin)</span>
<span class="gi">+        return_value = temp_buffer.getvalue()</span>
<span class="gi">+        temp_buffer.close()</span>
<span class="gi">+        return return_value</span>

<span class="gd">-    def check_origin(self) -&gt;None:</span>
<span class="gi">+    def check_origin(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do some simple checking of the zone&#39;s origin.

<span class="w"> </span>        Raises ``dns.zone.NoSOA`` if there is no SOA RRset.
<span class="gu">@@ -512,42 +759,220 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Raises ``KeyError`` if there is no origin node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_soa(self, txn: Optional[dns.transaction.Transaction]=None</span>
<span class="gd">-        ) -&gt;dns.rdtypes.ANY.SOA.SOA:</span>
<span class="gi">+        if self.relativize:</span>
<span class="gi">+            name = dns.name.empty</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert self.origin is not None</span>
<span class="gi">+            name = self.origin</span>
<span class="gi">+        if self.get_rdataset(name, dns.rdatatype.SOA) is None:</span>
<span class="gi">+            raise NoSOA</span>
<span class="gi">+        if self.get_rdataset(name, dns.rdatatype.NS) is None:</span>
<span class="gi">+            raise NoNS</span>
<span class="gi">+</span>
<span class="gi">+    def get_soa(</span>
<span class="gi">+        self, txn: Optional[dns.transaction.Transaction] = None</span>
<span class="gi">+    ) -&gt; dns.rdtypes.ANY.SOA.SOA:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the zone SOA rdata.

<span class="w"> </span>        Raises ``dns.zone.NoSOA`` if there is no SOA RRset.

<span class="w"> </span>        Returns a ``dns.rdtypes.ANY.SOA.SOA`` Rdata.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        if self.relativize:</span>
<span class="gi">+            origin_name = dns.name.empty</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.origin is None:</span>
<span class="gi">+                # get_soa() has been called very early, and there must not be</span>
<span class="gi">+                # an SOA if there is no origin.</span>
<span class="gi">+                raise NoSOA</span>
<span class="gi">+            origin_name = self.origin</span>
<span class="gi">+        soa: Optional[dns.rdataset.Rdataset]</span>
<span class="gi">+        if txn:</span>
<span class="gi">+            soa = txn.get(origin_name, dns.rdatatype.SOA)</span>
<span class="gi">+        else:</span>
<span class="gi">+            soa = self.get_rdataset(origin_name, dns.rdatatype.SOA)</span>
<span class="gi">+        if soa is None:</span>
<span class="gi">+            raise NoSOA</span>
<span class="gi">+        return soa[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _compute_digest(</span>
<span class="gi">+        self,</span>
<span class="gi">+        hash_algorithm: DigestHashAlgorithm,</span>
<span class="gi">+        scheme: DigestScheme = DigestScheme.SIMPLE,</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="gi">+        hashinfo = _digest_hashers.get(hash_algorithm)</span>
<span class="gi">+        if not hashinfo:</span>
<span class="gi">+            raise UnsupportedDigestHashAlgorithm</span>
<span class="gi">+        if scheme != DigestScheme.SIMPLE:</span>
<span class="gi">+            raise UnsupportedDigestScheme</span>
<span class="gi">+</span>
<span class="gi">+        if self.relativize:</span>
<span class="gi">+            origin_name = dns.name.empty</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert self.origin is not None</span>
<span class="gi">+            origin_name = self.origin</span>
<span class="gi">+        hasher = hashinfo()</span>
<span class="gi">+        for name, node in sorted(self.items()):</span>
<span class="gi">+            rrnamebuf = name.to_digestable(self.origin)</span>
<span class="gi">+            for rdataset in sorted(node, key=lambda rds: (rds.rdtype, rds.covers)):</span>
<span class="gi">+                if name == origin_name and dns.rdatatype.ZONEMD in (</span>
<span class="gi">+                    rdataset.rdtype,</span>
<span class="gi">+                    rdataset.covers,</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                rrfixed = struct.pack(</span>
<span class="gi">+                    &quot;!HHI&quot;, rdataset.rdtype, rdataset.rdclass, rdataset.ttl</span>
<span class="gi">+                )</span>
<span class="gi">+                rdatas = [rdata.to_digestable(self.origin) for rdata in rdataset]</span>
<span class="gi">+                for rdata in sorted(rdatas):</span>
<span class="gi">+                    rrlen = struct.pack(&quot;!H&quot;, len(rdata))</span>
<span class="gi">+                    hasher.update(rrnamebuf + rrfixed + rrlen + rdata)</span>
<span class="gi">+        return hasher.digest()</span>
<span class="gi">+</span>
<span class="gi">+    def compute_digest(</span>
<span class="gi">+        self,</span>
<span class="gi">+        hash_algorithm: DigestHashAlgorithm,</span>
<span class="gi">+        scheme: DigestScheme = DigestScheme.SIMPLE,</span>
<span class="gi">+    ) -&gt; dns.rdtypes.ANY.ZONEMD.ZONEMD:</span>
<span class="gi">+        serial = self.get_soa().serial</span>
<span class="gi">+        digest = self._compute_digest(hash_algorithm, scheme)</span>
<span class="gi">+        return dns.rdtypes.ANY.ZONEMD.ZONEMD(</span>
<span class="gi">+            self.rdclass, dns.rdatatype.ZONEMD, serial, scheme, hash_algorithm, digest</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def verify_digest(</span>
<span class="gi">+        self, zonemd: Optional[dns.rdtypes.ANY.ZONEMD.ZONEMD] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        digests: Union[dns.rdataset.Rdataset, List[dns.rdtypes.ANY.ZONEMD.ZONEMD]]</span>
<span class="gi">+        if zonemd:</span>
<span class="gi">+            digests = [zonemd]</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert self.origin is not None</span>
<span class="gi">+            rds = self.get_rdataset(self.origin, dns.rdatatype.ZONEMD)</span>
<span class="gi">+            if rds is None:</span>
<span class="gi">+                raise NoDigest</span>
<span class="gi">+            digests = rds</span>
<span class="gi">+        for digest in digests:</span>
<span class="gi">+            try:</span>
<span class="gi">+                computed = self._compute_digest(digest.hash_algorithm, digest.scheme)</span>
<span class="gi">+                if computed == digest.digest:</span>
<span class="gi">+                    return</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise DigestVerificationFailure</span>
<span class="gi">+</span>
<span class="gi">+    # TransactionManager methods</span>
<span class="gi">+</span>
<span class="gi">+    def reader(self) -&gt; &quot;Transaction&quot;:</span>
<span class="gi">+        return Transaction(self, False, Version(self, 1, self.nodes, self.origin))</span>
<span class="gi">+</span>
<span class="gi">+    def writer(self, replacement: bool = False) -&gt; &quot;Transaction&quot;:</span>
<span class="gi">+        txn = Transaction(self, replacement)</span>
<span class="gi">+        txn._setup_version()</span>
<span class="gi">+        return txn</span>
<span class="gi">+</span>
<span class="gi">+    def origin_information(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Tuple[Optional[dns.name.Name], bool, Optional[dns.name.Name]]:</span>
<span class="gi">+        effective: Optional[dns.name.Name]</span>
<span class="gi">+        if self.relativize:</span>
<span class="gi">+            effective = dns.name.empty</span>
<span class="gi">+        else:</span>
<span class="gi">+            effective = self.origin</span>
<span class="gi">+        return (self.origin, self.relativize, effective)</span>
<span class="gi">+</span>
<span class="gi">+    def get_class(self):</span>
<span class="gi">+        return self.rdclass</span>
<span class="gi">+</span>
<span class="gi">+    # Transaction methods</span>
<span class="gi">+</span>
<span class="gi">+    def _end_read(self, txn):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _end_write(self, txn):</span>
<span class="w"> </span>        pass

<span class="gi">+    def _commit_version(self, _, version, origin):</span>
<span class="gi">+        self.nodes = version.nodes</span>
<span class="gi">+        if self.origin is None:</span>
<span class="gi">+            self.origin = origin</span>
<span class="gi">+</span>
<span class="gi">+    def _get_next_version_id(self):</span>
<span class="gi">+        # Versions are ephemeral and all have id 1</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# These classes used to be in dns.versioned, but have moved here so we can use</span>
<span class="gi">+# the copy-on-write transaction mechanism for both kinds of zones.  In a</span>
<span class="gi">+# regular zone, the version only exists during the transaction, and the nodes</span>
<span class="gi">+# are regular dns.node.Nodes.</span>
<span class="gi">+</span>
<span class="gi">+# A node with a version id.</span>

<span class="gd">-class VersionedNode(dns.node.Node):</span>
<span class="gd">-    __slots__ = [&#39;id&#39;]</span>
<span class="gi">+</span>
<span class="gi">+class VersionedNode(dns.node.Node):  # lgtm[py/missing-equals]</span>
<span class="gi">+    __slots__ = [&quot;id&quot;]</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        super().__init__()
<span class="gi">+        # A proper id will get set by the Version</span>
<span class="w"> </span>        self.id = 0


<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ImmutableVersionedNode(VersionedNode):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, node):
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.id = node.id
<span class="gd">-        self.rdatasets = tuple([dns.rdataset.ImmutableRdataset(rds) for rds in</span>
<span class="gd">-            node.rdatasets])</span>
<span class="gi">+        self.rdatasets = tuple(</span>
<span class="gi">+            [dns.rdataset.ImmutableRdataset(rds) for rds in node.rdatasets]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def find_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; dns.rdataset.Rdataset:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+        return super().find_rdataset(rdclass, rdtype, covers, False)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+        create: bool = False,</span>
<span class="gi">+    ) -&gt; Optional[dns.rdataset.Rdataset]:</span>
<span class="gi">+        if create:</span>
<span class="gi">+            raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+        return super().get_rdataset(rdclass, rdtype, covers, False)</span>
<span class="gi">+</span>
<span class="gi">+    def delete_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -&gt; None:</span>
<span class="gi">+        raise TypeError(&quot;immutable&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def is_immutable(self) -&gt; bool:</span>
<span class="gi">+        return True</span>


<span class="w"> </span>class Version:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, zone: Zone, id: int, nodes: Optional[MutableMapping[</span>
<span class="gd">-        dns.name.Name, dns.node.Node]]=None, origin: Optional[dns.name.Name</span>
<span class="gd">-        ]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        zone: Zone,</span>
<span class="gi">+        id: int,</span>
<span class="gi">+        nodes: Optional[MutableMapping[dns.name.Name, dns.node.Node]] = None,</span>
<span class="gi">+        origin: Optional[dns.name.Name] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.zone = zone
<span class="w"> </span>        self.id = id
<span class="w"> </span>        if nodes is not None:
<span class="gu">@@ -556,48 +981,258 @@ class Version:</span>
<span class="w"> </span>            self.nodes = zone.map_factory()
<span class="w"> </span>        self.origin = origin

<span class="gi">+    def _validate_name(self, name: dns.name.Name) -&gt; dns.name.Name:</span>
<span class="gi">+        return _validate_name(name, self.origin, self.zone.relativize)</span>
<span class="gi">+</span>
<span class="gi">+    def get_node(self, name: dns.name.Name) -&gt; Optional[dns.node.Node]:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        return self.nodes.get(name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType,</span>
<span class="gi">+    ) -&gt; Optional[dns.rdataset.Rdataset]:</span>
<span class="gi">+        node = self.get_node(name)</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return node.get_rdataset(self.zone.rdclass, rdtype, covers)</span>
<span class="gi">+</span>
<span class="gi">+    def keys(self):</span>
<span class="gi">+        return self.nodes.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def items(self):</span>
<span class="gi">+        return self.nodes.items()</span>

<span class="gd">-class WritableVersion(Version):</span>

<span class="gd">-    def __init__(self, zone: Zone, replacement: bool=False):</span>
<span class="gi">+class WritableVersion(Version):</span>
<span class="gi">+    def __init__(self, zone: Zone, replacement: bool = False):</span>
<span class="gi">+        # The zone._versions_lock must be held by our caller in a versioned</span>
<span class="gi">+        # zone.</span>
<span class="w"> </span>        id = zone._get_next_version_id()
<span class="w"> </span>        super().__init__(zone, id)
<span class="w"> </span>        if not replacement:
<span class="gi">+            # We copy the map, because that gives us a simple and thread-safe</span>
<span class="gi">+            # way of doing versions, and we have a garbage collector to help</span>
<span class="gi">+            # us.  We only make new node objects if we actually change the</span>
<span class="gi">+            # node.</span>
<span class="w"> </span>            self.nodes.update(zone.nodes)
<span class="gi">+        # We have to copy the zone origin as it may be None in the first</span>
<span class="gi">+        # version, and we don&#39;t want to mutate the zone until we commit.</span>
<span class="w"> </span>        self.origin = zone.origin
<span class="w"> </span>        self.changed: Set[dns.name.Name] = set()

<span class="gi">+    def _maybe_cow(self, name: dns.name.Name) -&gt; dns.node.Node:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        node = self.nodes.get(name)</span>
<span class="gi">+        if node is None or name not in self.changed:</span>
<span class="gi">+            new_node = self.zone.node_factory()</span>
<span class="gi">+            if hasattr(new_node, &quot;id&quot;):</span>
<span class="gi">+                # We keep doing this for backwards compatibility, as earlier</span>
<span class="gi">+                # code used new_node.id != self.id for the &quot;do we need to CoW?&quot;</span>
<span class="gi">+                # test.  Now we use the changed set as this works with both</span>
<span class="gi">+                # regular zones and versioned zones.</span>
<span class="gi">+                #</span>
<span class="gi">+                # We ignore the mypy error as this is safe but it doesn&#39;t see it.</span>
<span class="gi">+                new_node.id = self.id  # type: ignore</span>
<span class="gi">+            if node is not None:</span>
<span class="gi">+                # moo!  copy on write!</span>
<span class="gi">+                new_node.rdatasets.extend(node.rdatasets)</span>
<span class="gi">+            self.nodes[name] = new_node</span>
<span class="gi">+            self.changed.add(name)</span>
<span class="gi">+            return new_node</span>
<span class="gi">+        else:</span>
<span class="gi">+            return node</span>
<span class="gi">+</span>
<span class="gi">+    def delete_node(self, name: dns.name.Name) -&gt; None:</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        if name in self.nodes:</span>
<span class="gi">+            del self.nodes[name]</span>
<span class="gi">+            self.changed.add(name)</span>
<span class="gi">+</span>
<span class="gi">+    def put_rdataset(</span>
<span class="gi">+        self, name: dns.name.Name, rdataset: dns.rdataset.Rdataset</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        node = self._maybe_cow(name)</span>
<span class="gi">+        node.replace_rdataset(rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def delete_rdataset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: dns.name.Name,</span>
<span class="gi">+        rdtype: dns.rdatatype.RdataType,</span>
<span class="gi">+        covers: dns.rdatatype.RdataType,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        node = self._maybe_cow(name)</span>
<span class="gi">+        node.delete_rdataset(self.zone.rdclass, rdtype, covers)</span>
<span class="gi">+        if len(node) == 0:</span>
<span class="gi">+            del self.nodes[name]</span>
<span class="gi">+</span>

<span class="w"> </span>@dns.immutable.immutable
<span class="w"> </span>class ImmutableVersion(Version):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, version: WritableVersion):
<span class="gi">+        # We tell super() that it&#39;s a replacement as we don&#39;t want it</span>
<span class="gi">+        # to copy the nodes, as we&#39;re about to do that with an</span>
<span class="gi">+        # immutable Dict.</span>
<span class="w"> </span>        super().__init__(version.zone, True)
<span class="gi">+        # set the right id!</span>
<span class="w"> </span>        self.id = version.id
<span class="gi">+        # keep the origin</span>
<span class="w"> </span>        self.origin = version.origin
<span class="gi">+        # Make changed nodes immutable</span>
<span class="w"> </span>        for name in version.changed:
<span class="w"> </span>            node = version.nodes.get(name)
<span class="gi">+            # it might not exist if we deleted it in the version</span>
<span class="w"> </span>            if node:
<span class="w"> </span>                version.nodes[name] = ImmutableVersionedNode(node)
<span class="gd">-        self.nodes = dns.immutable.Dict(version.nodes, True, self.zone.</span>
<span class="gd">-            map_factory)</span>
<span class="gi">+        # We&#39;re changing the type of the nodes dictionary here on purpose, so</span>
<span class="gi">+        # we ignore the mypy error.</span>
<span class="gi">+        self.nodes = dns.immutable.Dict(</span>
<span class="gi">+            version.nodes, True, self.zone.map_factory</span>
<span class="gi">+        )  # type: ignore</span>


<span class="w"> </span>class Transaction(dns.transaction.Transaction):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, zone, replacement, version=None, make_immutable=False):
<span class="w"> </span>        read_only = version is not None
<span class="w"> </span>        super().__init__(zone, replacement, read_only)
<span class="w"> </span>        self.version = version
<span class="w"> </span>        self.make_immutable = make_immutable

<span class="gi">+    @property</span>
<span class="gi">+    def zone(self):</span>
<span class="gi">+        return self.manager</span>
<span class="gi">+</span>
<span class="gi">+    def _setup_version(self):</span>
<span class="gi">+        assert self.version is None</span>
<span class="gi">+        factory = self.manager.writable_version_factory</span>
<span class="gi">+        if factory is None:</span>
<span class="gi">+            factory = WritableVersion</span>
<span class="gi">+        self.version = factory(self.zone, self.replacement)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_rdataset(self, name, rdtype, covers):</span>
<span class="gi">+        return self.version.get_rdataset(name, rdtype, covers)</span>
<span class="gi">+</span>
<span class="gi">+    def _put_rdataset(self, name, rdataset):</span>
<span class="gi">+        assert not self.read_only</span>
<span class="gi">+        self.version.put_rdataset(name, rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def _delete_name(self, name):</span>
<span class="gi">+        assert not self.read_only</span>
<span class="gi">+        self.version.delete_node(name)</span>

<span class="gd">-def from_text(text: str, origin: Optional[Union[dns.name.Name, str]]=None,</span>
<span class="gd">-    rdclass: dns.rdataclass.RdataClass=dns.rdataclass.IN, relativize: bool=</span>
<span class="gd">-    True, zone_factory: Any=Zone, filename: Optional[str]=None,</span>
<span class="gd">-    allow_include: bool=False, check_origin: bool=True, idna_codec:</span>
<span class="gd">-    Optional[dns.name.IDNACodec]=None, allow_directives: Union[bool,</span>
<span class="gd">-    Iterable[str]]=True) -&gt;Zone:</span>
<span class="gi">+    def _delete_rdataset(self, name, rdtype, covers):</span>
<span class="gi">+        assert not self.read_only</span>
<span class="gi">+        self.version.delete_rdataset(name, rdtype, covers)</span>
<span class="gi">+</span>
<span class="gi">+    def _name_exists(self, name):</span>
<span class="gi">+        return self.version.get_node(name) is not None</span>
<span class="gi">+</span>
<span class="gi">+    def _changed(self):</span>
<span class="gi">+        if self.read_only:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return len(self.version.changed) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def _end_transaction(self, commit):</span>
<span class="gi">+        if self.read_only:</span>
<span class="gi">+            self.zone._end_read(self)</span>
<span class="gi">+        elif commit and len(self.version.changed) &gt; 0:</span>
<span class="gi">+            if self.make_immutable:</span>
<span class="gi">+                factory = self.manager.immutable_version_factory</span>
<span class="gi">+                if factory is None:</span>
<span class="gi">+                    factory = ImmutableVersion</span>
<span class="gi">+                version = factory(self.version)</span>
<span class="gi">+            else:</span>
<span class="gi">+                version = self.version</span>
<span class="gi">+            self.zone._commit_version(self, version, self.version.origin)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # rollback</span>
<span class="gi">+            self.zone._end_write(self)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_origin(self, origin):</span>
<span class="gi">+        if self.version.origin is None:</span>
<span class="gi">+            self.version.origin = origin</span>
<span class="gi">+</span>
<span class="gi">+    def _iterate_rdatasets(self):</span>
<span class="gi">+        for name, node in self.version.items():</span>
<span class="gi">+            for rdataset in node:</span>
<span class="gi">+                yield (name, rdataset)</span>
<span class="gi">+</span>
<span class="gi">+    def _iterate_names(self):</span>
<span class="gi">+        return self.version.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_node(self, name):</span>
<span class="gi">+        return self.version.get_node(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _origin_information(self):</span>
<span class="gi">+        (absolute, relativize, effective) = self.manager.origin_information()</span>
<span class="gi">+        if absolute is None and self.version.origin is not None:</span>
<span class="gi">+            # No origin has been committed yet, but we&#39;ve learned one as part of</span>
<span class="gi">+            # this txn.  Use it.</span>
<span class="gi">+            absolute = self.version.origin</span>
<span class="gi">+            if relativize:</span>
<span class="gi">+                effective = dns.name.empty</span>
<span class="gi">+            else:</span>
<span class="gi">+                effective = absolute</span>
<span class="gi">+        return (absolute, relativize, effective)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _from_text(</span>
<span class="gi">+    text: Any,</span>
<span class="gi">+    origin: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+    rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    zone_factory: Any = Zone,</span>
<span class="gi">+    filename: Optional[str] = None,</span>
<span class="gi">+    allow_include: bool = False,</span>
<span class="gi">+    check_origin: bool = True,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    allow_directives: Union[bool, Iterable[str]] = True,</span>
<span class="gi">+) -&gt; Zone:</span>
<span class="gi">+    # See the comments for the public APIs from_text() and from_file() for</span>
<span class="gi">+    # details.</span>
<span class="gi">+</span>
<span class="gi">+    # &#39;text&#39; can also be a file, but we don&#39;t publish that fact</span>
<span class="gi">+    # since it&#39;s an implementation detail.  The official file</span>
<span class="gi">+    # interface is from_file().</span>
<span class="gi">+</span>
<span class="gi">+    if filename is None:</span>
<span class="gi">+        filename = &quot;&lt;string&gt;&quot;</span>
<span class="gi">+    zone = zone_factory(origin, rdclass, relativize=relativize)</span>
<span class="gi">+    with zone.writer(True) as txn:</span>
<span class="gi">+        tok = dns.tokenizer.Tokenizer(text, filename, idna_codec=idna_codec)</span>
<span class="gi">+        reader = dns.zonefile.Reader(</span>
<span class="gi">+            tok,</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            txn,</span>
<span class="gi">+            allow_include=allow_include,</span>
<span class="gi">+            allow_directives=allow_directives,</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            reader.read()</span>
<span class="gi">+        except dns.zonefile.UnknownOrigin:</span>
<span class="gi">+            # for backwards compatibility</span>
<span class="gi">+            raise dns.zone.UnknownOrigin</span>
<span class="gi">+    # Now that we&#39;re done reading, do some basic checking of the zone.</span>
<span class="gi">+    if check_origin:</span>
<span class="gi">+        zone.check_origin()</span>
<span class="gi">+    return zone</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_text(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    origin: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+    rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    zone_factory: Any = Zone,</span>
<span class="gi">+    filename: Optional[str] = None,</span>
<span class="gi">+    allow_include: bool = False,</span>
<span class="gi">+    check_origin: bool = True,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    allow_directives: Union[bool, Iterable[str]] = True,</span>
<span class="gi">+) -&gt; Zone:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build a zone object from a zone file format string.

<span class="w"> </span>    *text*, a ``str``, the zone file format input.
<span class="gu">@@ -646,15 +1281,32 @@ def from_text(text: str, origin: Optional[Union[dns.name.Name, str]]=None,</span>

<span class="w"> </span>    Returns a subclass of ``dns.zone.Zone``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def from_file(f: Any, origin: Optional[Union[dns.name.Name, str]]=None,</span>
<span class="gd">-    rdclass: dns.rdataclass.RdataClass=dns.rdataclass.IN, relativize: bool=</span>
<span class="gd">-    True, zone_factory: Any=Zone, filename: Optional[str]=None,</span>
<span class="gd">-    allow_include: bool=True, check_origin: bool=True, idna_codec: Optional</span>
<span class="gd">-    [dns.name.IDNACodec]=None, allow_directives: Union[bool, Iterable[str]]</span>
<span class="gd">-    =True) -&gt;Zone:</span>
<span class="gi">+    return _from_text(</span>
<span class="gi">+        text,</span>
<span class="gi">+        origin,</span>
<span class="gi">+        rdclass,</span>
<span class="gi">+        relativize,</span>
<span class="gi">+        zone_factory,</span>
<span class="gi">+        filename,</span>
<span class="gi">+        allow_include,</span>
<span class="gi">+        check_origin,</span>
<span class="gi">+        idna_codec,</span>
<span class="gi">+        allow_directives,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_file(</span>
<span class="gi">+    f: Any,</span>
<span class="gi">+    origin: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+    rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    zone_factory: Any = Zone,</span>
<span class="gi">+    filename: Optional[str] = None,</span>
<span class="gi">+    allow_include: bool = True,</span>
<span class="gi">+    check_origin: bool = True,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    allow_directives: Union[bool, Iterable[str]] = True,</span>
<span class="gi">+) -&gt; Zone:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a zone file and build a zone object.

<span class="w"> </span>    *f*, a file or ``str``.  If *f* is a string, it is treated
<span class="gu">@@ -703,11 +1355,35 @@ def from_file(f: Any, origin: Optional[Union[dns.name.Name, str]]=None,</span>

<span class="w"> </span>    Returns a subclass of ``dns.zone.Zone``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def from_xfr(xfr: Any, zone_factory: Any=Zone, relativize: bool=True,</span>
<span class="gd">-    check_origin: bool=True) -&gt;Zone:</span>
<span class="gi">+    if isinstance(f, str):</span>
<span class="gi">+        if filename is None:</span>
<span class="gi">+            filename = f</span>
<span class="gi">+        cm: contextlib.AbstractContextManager = open(f)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = contextlib.nullcontext(f)</span>
<span class="gi">+    with cm as f:</span>
<span class="gi">+        return _from_text(</span>
<span class="gi">+            f,</span>
<span class="gi">+            origin,</span>
<span class="gi">+            rdclass,</span>
<span class="gi">+            relativize,</span>
<span class="gi">+            zone_factory,</span>
<span class="gi">+            filename,</span>
<span class="gi">+            allow_include,</span>
<span class="gi">+            check_origin,</span>
<span class="gi">+            idna_codec,</span>
<span class="gi">+            allow_directives,</span>
<span class="gi">+        )</span>
<span class="gi">+    assert False  # make mypy happy  lgtm[py/unreachable-statement]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_xfr(</span>
<span class="gi">+    xfr: Any,</span>
<span class="gi">+    zone_factory: Any = Zone,</span>
<span class="gi">+    relativize: bool = True,</span>
<span class="gi">+    check_origin: bool = True,</span>
<span class="gi">+) -&gt; Zone:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the output of a zone transfer generator into a zone object.

<span class="w"> </span>    *xfr*, a generator of ``dns.message.Message`` objects, typically
<span class="gu">@@ -732,4 +1408,27 @@ def from_xfr(xfr: Any, zone_factory: Any=Zone, relativize: bool=True,</span>

<span class="w"> </span>    Returns a subclass of ``dns.zone.Zone``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    z = None</span>
<span class="gi">+    for r in xfr:</span>
<span class="gi">+        if z is None:</span>
<span class="gi">+            if relativize:</span>
<span class="gi">+                origin = r.origin</span>
<span class="gi">+            else:</span>
<span class="gi">+                origin = r.answer[0].name</span>
<span class="gi">+            rdclass = r.answer[0].rdclass</span>
<span class="gi">+            z = zone_factory(origin, rdclass, relativize=relativize)</span>
<span class="gi">+        for rrset in r.answer:</span>
<span class="gi">+            znode = z.nodes.get(rrset.name)</span>
<span class="gi">+            if not znode:</span>
<span class="gi">+                znode = z.node_factory()</span>
<span class="gi">+                z.nodes[rrset.name] = znode</span>
<span class="gi">+            zrds = znode.find_rdataset(rrset.rdclass, rrset.rdtype, rrset.covers, True)</span>
<span class="gi">+            zrds.update_ttl(rrset.ttl)</span>
<span class="gi">+            for rd in rrset:</span>
<span class="gi">+                zrds.add(rd)</span>
<span class="gi">+    if z is None:</span>
<span class="gi">+        raise ValueError(&quot;empty transfer&quot;)</span>
<span class="gi">+    if check_origin:</span>
<span class="gi">+        z.check_origin()</span>
<span class="gi">+    return z</span>
<span class="gh">diff --git a/dns/zonefile.py b/dns/zonefile.py</span>
<span class="gh">index c5e5731..af064e7 100644</span>
<span class="gd">--- a/dns/zonefile.py</span>
<span class="gi">+++ b/dns/zonefile.py</span>
<span class="gu">@@ -1,7 +1,26 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Permission to use, copy, modify, and distribute this software and its</span>
<span class="gi">+# documentation for any purpose with or without fee is hereby granted,</span>
<span class="gi">+# provided that the above copyright notice and this permission notice</span>
<span class="gi">+# appear in all copies.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="gi">+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="gi">+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="gi">+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="gi">+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="gi">+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="gi">+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;DNS Zones.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>from typing import Any, Iterable, List, Optional, Set, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import dns.exception
<span class="w"> </span>import dns.grange
<span class="w"> </span>import dns.name
<span class="gu">@@ -24,22 +43,66 @@ class CNAMEAndOtherData(dns.exception.DNSException):</span>
<span class="w"> </span>    &quot;&quot;&quot;A node has a CNAME and other data&quot;&quot;&quot;


<span class="gd">-SavedStateType = Tuple[dns.tokenizer.Tokenizer, Optional[dns.name.Name],</span>
<span class="gd">-    Optional[dns.name.Name], Optional[Any], int, bool, int, bool]</span>
<span class="gi">+def _check_cname_and_other_data(txn, name, rdataset):</span>
<span class="gi">+    rdataset_kind = dns.node.NodeKind.classify_rdataset(rdataset)</span>
<span class="gi">+    node = txn.get_node(name)</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        # empty nodes are neutral.</span>
<span class="gi">+        return</span>
<span class="gi">+    node_kind = node.classify()</span>
<span class="gi">+    if (</span>
<span class="gi">+        node_kind == dns.node.NodeKind.CNAME</span>
<span class="gi">+        and rdataset_kind == dns.node.NodeKind.REGULAR</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise CNAMEAndOtherData(&quot;rdataset type is not compatible with a CNAME node&quot;)</span>
<span class="gi">+    elif (</span>
<span class="gi">+        node_kind == dns.node.NodeKind.REGULAR</span>
<span class="gi">+        and rdataset_kind == dns.node.NodeKind.CNAME</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise CNAMEAndOtherData(</span>
<span class="gi">+            &quot;CNAME rdataset is not compatible with a regular data node&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    # Otherwise at least one of the node and the rdataset is neutral, so</span>
<span class="gi">+    # adding the rdataset is ok</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+SavedStateType = Tuple[</span>
<span class="gi">+    dns.tokenizer.Tokenizer,</span>
<span class="gi">+    Optional[dns.name.Name],  # current_origin</span>
<span class="gi">+    Optional[dns.name.Name],  # last_name</span>
<span class="gi">+    Optional[Any],  # current_file</span>
<span class="gi">+    int,  # last_ttl</span>
<span class="gi">+    bool,  # last_ttl_known</span>
<span class="gi">+    int,  # default_ttl</span>
<span class="gi">+    bool,</span>
<span class="gi">+]  # default_ttl_known</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _upper_dollarize(s):</span>
<span class="gi">+    s = s.upper()</span>
<span class="gi">+    if not s.startswith(&quot;$&quot;):</span>
<span class="gi">+        s = &quot;$&quot; + s</span>
<span class="gi">+    return s</span>


<span class="w"> </span>class Reader:
<span class="w"> </span>    &quot;&quot;&quot;Read a DNS zone file into a transaction.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, tok: dns.tokenizer.Tokenizer, rdclass: dns.</span>
<span class="gd">-        rdataclass.RdataClass, txn: dns.transaction.Transaction,</span>
<span class="gd">-        allow_include: bool=False, allow_directives: Union[bool, Iterable[</span>
<span class="gd">-        str]]=True, force_name: Optional[dns.name.Name]=None, force_ttl:</span>
<span class="gd">-        Optional[int]=None, force_rdclass: Optional[dns.rdataclass.</span>
<span class="gd">-        RdataClass]=None, force_rdtype: Optional[dns.rdatatype.RdataType]=</span>
<span class="gd">-        None, default_ttl: Optional[int]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        tok: dns.tokenizer.Tokenizer,</span>
<span class="gi">+        rdclass: dns.rdataclass.RdataClass,</span>
<span class="gi">+        txn: dns.transaction.Transaction,</span>
<span class="gi">+        allow_include: bool = False,</span>
<span class="gi">+        allow_directives: Union[bool, Iterable[str]] = True,</span>
<span class="gi">+        force_name: Optional[dns.name.Name] = None,</span>
<span class="gi">+        force_ttl: Optional[int] = None,</span>
<span class="gi">+        force_rdclass: Optional[dns.rdataclass.RdataClass] = None,</span>
<span class="gi">+        force_rdtype: Optional[dns.rdatatype.RdataType] = None,</span>
<span class="gi">+        default_ttl: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.tok = tok
<span class="gd">-        self.zone_origin, self.relativize, _ = txn.manager.origin_information()</span>
<span class="gi">+        (self.zone_origin, self.relativize, _) = txn.manager.origin_information()</span>
<span class="w"> </span>        self.current_origin = self.zone_origin
<span class="w"> </span>        self.last_ttl = 0
<span class="w"> </span>        self.last_ttl_known = False
<span class="gu">@@ -58,64 +121,547 @@ class Reader:</span>
<span class="w"> </span>        self.current_file: Optional[Any] = None
<span class="w"> </span>        self.allowed_directives: Set[str]
<span class="w"> </span>        if allow_directives is True:
<span class="gd">-            self.allowed_directives = {&#39;$GENERATE&#39;, &#39;$ORIGIN&#39;, &#39;$TTL&#39;}</span>
<span class="gi">+            self.allowed_directives = {&quot;$GENERATE&quot;, &quot;$ORIGIN&quot;, &quot;$TTL&quot;}</span>
<span class="w"> </span>            if allow_include:
<span class="gd">-                self.allowed_directives.add(&#39;$INCLUDE&#39;)</span>
<span class="gi">+                self.allowed_directives.add(&quot;$INCLUDE&quot;)</span>
<span class="w"> </span>        elif allow_directives is False:
<span class="gi">+            # allow_include was ignored in earlier releases if allow_directives was</span>
<span class="gi">+            # False, so we continue that.</span>
<span class="w"> </span>            self.allowed_directives = set()
<span class="w"> </span>        else:
<span class="gd">-            self.allowed_directives = set(_upper_dollarize(d) for d in</span>
<span class="gd">-                allow_directives)</span>
<span class="gi">+            # Note that if directives are explicitly specified, then allow_include</span>
<span class="gi">+            # is ignored.</span>
<span class="gi">+            self.allowed_directives = set(_upper_dollarize(d) for d in allow_directives)</span>
<span class="w"> </span>        self.force_name = force_name
<span class="w"> </span>        self.force_ttl = force_ttl
<span class="w"> </span>        self.force_rdclass = force_rdclass
<span class="w"> </span>        self.force_rdtype = force_rdtype
<span class="w"> </span>        self.txn.check_put_rdataset(_check_cname_and_other_data)

<span class="gi">+    def _eat_line(self):</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if token.is_eol_or_eof():</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def _get_identifier(self):</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        return token</span>
<span class="gi">+</span>
<span class="w"> </span>    def _rr_line(self):
<span class="w"> </span>        &quot;&quot;&quot;Process one line from a DNS zone file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = None</span>
<span class="gi">+        # Name</span>
<span class="gi">+        if self.force_name is not None:</span>
<span class="gi">+            name = self.force_name</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.current_origin is None:</span>
<span class="gi">+                raise UnknownOrigin</span>
<span class="gi">+            token = self.tok.get(want_leading=True)</span>
<span class="gi">+            if not token.is_whitespace():</span>
<span class="gi">+                self.last_name = self.tok.as_name(token, self.current_origin)</span>
<span class="gi">+            else:</span>
<span class="gi">+                token = self.tok.get()</span>
<span class="gi">+                if token.is_eol_or_eof():</span>
<span class="gi">+                    # treat leading WS followed by EOL/EOF as if they were EOL/EOF.</span>
<span class="gi">+                    return</span>
<span class="gi">+                self.tok.unget(token)</span>
<span class="gi">+            name = self.last_name</span>
<span class="gi">+            if not name.is_subdomain(self.zone_origin):</span>
<span class="gi">+                self._eat_line()</span>
<span class="gi">+                return</span>
<span class="gi">+            if self.relativize:</span>
<span class="gi">+                name = name.relativize(self.zone_origin)</span>
<span class="gi">+</span>
<span class="gi">+        # TTL</span>
<span class="gi">+        if self.force_ttl is not None:</span>
<span class="gi">+            ttl = self.force_ttl</span>
<span class="gi">+            self.last_ttl = ttl</span>
<span class="gi">+            self.last_ttl_known = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            token = self._get_identifier()</span>
<span class="gi">+            ttl = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                ttl = dns.ttl.from_text(token.value)</span>
<span class="gi">+                self.last_ttl = ttl</span>
<span class="gi">+                self.last_ttl_known = True</span>
<span class="gi">+                token = None</span>
<span class="gi">+            except dns.ttl.BadTTL:</span>
<span class="gi">+                self.tok.unget(token)</span>
<span class="gi">+</span>
<span class="gi">+        # Class</span>
<span class="gi">+        if self.force_rdclass is not None:</span>
<span class="gi">+            rdclass = self.force_rdclass</span>
<span class="gi">+        else:</span>
<span class="gi">+            token = self._get_identifier()</span>
<span class="gi">+            try:</span>
<span class="gi">+                rdclass = dns.rdataclass.from_text(token.value)</span>
<span class="gi">+            except dns.exception.SyntaxError:</span>
<span class="gi">+                raise</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                rdclass = self.zone_rdclass</span>
<span class="gi">+                self.tok.unget(token)</span>
<span class="gi">+            if rdclass != self.zone_rdclass:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;RR class is not zone&#39;s class&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if ttl is None:</span>
<span class="gi">+            # support for &lt;class&gt; &lt;ttl&gt; &lt;type&gt; syntax</span>
<span class="gi">+            token = self._get_identifier()</span>
<span class="gi">+            ttl = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                ttl = dns.ttl.from_text(token.value)</span>
<span class="gi">+                self.last_ttl = ttl</span>
<span class="gi">+                self.last_ttl_known = True</span>
<span class="gi">+                token = None</span>
<span class="gi">+            except dns.ttl.BadTTL:</span>
<span class="gi">+                if self.default_ttl_known:</span>
<span class="gi">+                    ttl = self.default_ttl</span>
<span class="gi">+                elif self.last_ttl_known:</span>
<span class="gi">+                    ttl = self.last_ttl</span>
<span class="gi">+                self.tok.unget(token)</span>
<span class="gi">+</span>
<span class="gi">+        # Type</span>
<span class="gi">+        if self.force_rdtype is not None:</span>
<span class="gi">+            rdtype = self.force_rdtype</span>
<span class="gi">+        else:</span>
<span class="gi">+            token = self._get_identifier()</span>
<span class="gi">+            try:</span>
<span class="gi">+                rdtype = dns.rdatatype.from_text(token.value)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;unknown rdatatype &#39;%s&#39;&quot; % token.value)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            rd = dns.rdata.from_text(</span>
<span class="gi">+                rdclass,</span>
<span class="gi">+                rdtype,</span>
<span class="gi">+                self.tok,</span>
<span class="gi">+                self.current_origin,</span>
<span class="gi">+                self.relativize,</span>
<span class="gi">+                self.zone_origin,</span>
<span class="gi">+            )</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            # Catch and reraise.</span>
<span class="gi">+            raise</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # All exceptions that occur in the processing of rdata</span>
<span class="gi">+            # are treated as syntax errors.  This is not strictly</span>
<span class="gi">+            # correct, but it is correct almost all of the time.</span>
<span class="gi">+            # We convert them to syntax errors so that we can emit</span>
<span class="gi">+            # helpful filename:line info.</span>
<span class="gi">+            (ty, va) = sys.exc_info()[:2]</span>
<span class="gi">+            raise dns.exception.SyntaxError(</span>
<span class="gi">+                &quot;caught exception {}: {}&quot;.format(str(ty), str(va))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not self.default_ttl_known and rdtype == dns.rdatatype.SOA:</span>
<span class="gi">+            # The pre-RFC2308 and pre-BIND9 behavior inherits the zone default</span>
<span class="gi">+            # TTL from the SOA minttl if no $TTL statement is present before the</span>
<span class="gi">+            # SOA is parsed.</span>
<span class="gi">+            self.default_ttl = rd.minimum</span>
<span class="gi">+            self.default_ttl_known = True</span>
<span class="gi">+            if ttl is None:</span>
<span class="gi">+                # if we didn&#39;t have a TTL on the SOA, set it!</span>
<span class="gi">+                ttl = rd.minimum</span>
<span class="gi">+</span>
<span class="gi">+        # TTL check.  We had to wait until now to do this as the SOA RR&#39;s</span>
<span class="gi">+        # own TTL can be inferred from its minimum.</span>
<span class="gi">+        if ttl is None:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;Missing default TTL value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.txn.add(name, ttl, rd)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_modify(self, side: str) -&gt; Tuple[str, str, int, int, str]:</span>
<span class="gi">+        # Here we catch everything in &#39;{&#39; &#39;}&#39; in a group so we can replace it</span>
<span class="gi">+        # with &#39;&#39;.</span>
<span class="gi">+        is_generate1 = re.compile(r&quot;^.*\$({(\+|-?)(\d+),(\d+),(.)}).*$&quot;)</span>
<span class="gi">+        is_generate2 = re.compile(r&quot;^.*\$({(\+|-?)(\d+)}).*$&quot;)</span>
<span class="gi">+        is_generate3 = re.compile(r&quot;^.*\$({(\+|-?)(\d+),(\d+)}).*$&quot;)</span>
<span class="gi">+        # Sometimes there are modifiers in the hostname. These come after</span>
<span class="gi">+        # the dollar sign. They are in the form: ${offset[,width[,base]]}.</span>
<span class="gi">+        # Make names</span>
<span class="gi">+        g1 = is_generate1.match(side)</span>
<span class="gi">+        if g1:</span>
<span class="gi">+            mod, sign, offset, width, base = g1.groups()</span>
<span class="gi">+            if sign == &quot;&quot;:</span>
<span class="gi">+                sign = &quot;+&quot;</span>
<span class="gi">+        g2 = is_generate2.match(side)</span>
<span class="gi">+        if g2:</span>
<span class="gi">+            mod, sign, offset = g2.groups()</span>
<span class="gi">+            if sign == &quot;&quot;:</span>
<span class="gi">+                sign = &quot;+&quot;</span>
<span class="gi">+            width = 0</span>
<span class="gi">+            base = &quot;d&quot;</span>
<span class="gi">+        g3 = is_generate3.match(side)</span>
<span class="gi">+        if g3:</span>
<span class="gi">+            mod, sign, offset, width = g3.groups()</span>
<span class="gi">+            if sign == &quot;&quot;:</span>
<span class="gi">+                sign = &quot;+&quot;</span>
<span class="gi">+            base = &quot;d&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if not (g1 or g2 or g3):</span>
<span class="gi">+            mod = &quot;&quot;</span>
<span class="gi">+            sign = &quot;+&quot;</span>
<span class="gi">+            offset = 0</span>
<span class="gi">+            width = 0</span>
<span class="gi">+            base = &quot;d&quot;</span>
<span class="gi">+</span>
<span class="gi">+        offset = int(offset)</span>
<span class="gi">+        width = int(width)</span>
<span class="gi">+</span>
<span class="gi">+        if sign not in [&quot;+&quot;, &quot;-&quot;]:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;invalid offset sign %s&quot; % sign)</span>
<span class="gi">+        if base not in [&quot;d&quot;, &quot;o&quot;, &quot;x&quot;, &quot;X&quot;, &quot;n&quot;, &quot;N&quot;]:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;invalid type %s&quot; % base)</span>
<span class="gi">+</span>
<span class="gi">+        return mod, sign, offset, width, base</span>

<span class="w"> </span>    def _generate_line(self):
<span class="gi">+        # range lhs [ttl] [class] type rhs [ comment ]</span>
<span class="w"> </span>        &quot;&quot;&quot;Process one line containing the GENERATE statement from a DNS
<span class="w"> </span>        zone file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.current_origin is None:</span>
<span class="gi">+            raise UnknownOrigin</span>
<span class="gi">+</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        # Range (required)</span>
<span class="gi">+        try:</span>
<span class="gi">+            start, stop, step = dns.grange.from_text(token.value)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+</span>
<span class="gi">+        # lhs (required)</span>
<span class="gi">+        try:</span>
<span class="gi">+            lhs = token.value</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+</span>
<span class="gi">+        # TTL</span>
<span class="gi">+        try:</span>
<span class="gi">+            ttl = dns.ttl.from_text(token.value)</span>
<span class="gi">+            self.last_ttl = ttl</span>
<span class="gi">+            self.last_ttl_known = True</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except dns.ttl.BadTTL:</span>
<span class="gi">+            if not (self.last_ttl_known or self.default_ttl_known):</span>
<span class="gi">+                raise dns.exception.SyntaxError(&quot;Missing default TTL value&quot;)</span>
<span class="gi">+            if self.default_ttl_known:</span>
<span class="gi">+                ttl = self.default_ttl</span>
<span class="gi">+            elif self.last_ttl_known:</span>
<span class="gi">+                ttl = self.last_ttl</span>
<span class="gi">+        # Class</span>
<span class="gi">+        try:</span>
<span class="gi">+            rdclass = dns.rdataclass.from_text(token.value)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            rdclass = self.zone_rdclass</span>
<span class="gi">+        if rdclass != self.zone_rdclass:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;RR class is not zone&#39;s class&quot;)</span>
<span class="gi">+        # Type</span>
<span class="gi">+        try:</span>
<span class="gi">+            rdtype = dns.rdatatype.from_text(token.value)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if not token.is_identifier():</span>
<span class="gi">+                raise dns.exception.SyntaxError</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;unknown rdatatype &#39;%s&#39;&quot; % token.value)</span>

<span class="gd">-    def read(self) -&gt;None:</span>
<span class="gi">+        # rhs (required)</span>
<span class="gi">+        rhs = token.value</span>
<span class="gi">+</span>
<span class="gi">+        def _calculate_index(counter: int, offset_sign: str, offset: int) -&gt; int:</span>
<span class="gi">+            &quot;&quot;&quot;Calculate the index from the counter and offset.&quot;&quot;&quot;</span>
<span class="gi">+            if offset_sign == &quot;-&quot;:</span>
<span class="gi">+                offset *= -1</span>
<span class="gi">+            return counter + offset</span>
<span class="gi">+</span>
<span class="gi">+        def _format_index(index: int, base: str, width: int) -&gt; str:</span>
<span class="gi">+            &quot;&quot;&quot;Format the index with the given base, and zero-fill it</span>
<span class="gi">+            to the given width.&quot;&quot;&quot;</span>
<span class="gi">+            if base in [&quot;d&quot;, &quot;o&quot;, &quot;x&quot;, &quot;X&quot;]:</span>
<span class="gi">+                return format(index, base).zfill(width)</span>
<span class="gi">+</span>
<span class="gi">+            # base can only be n or N here</span>
<span class="gi">+            hexa = _format_index(index, &quot;x&quot;, width)</span>
<span class="gi">+            nibbles = &quot;.&quot;.join(hexa[::-1])[:width]</span>
<span class="gi">+            if base == &quot;N&quot;:</span>
<span class="gi">+                nibbles = nibbles.upper()</span>
<span class="gi">+            return nibbles</span>
<span class="gi">+</span>
<span class="gi">+        lmod, lsign, loffset, lwidth, lbase = self._parse_modify(lhs)</span>
<span class="gi">+        rmod, rsign, roffset, rwidth, rbase = self._parse_modify(rhs)</span>
<span class="gi">+        for i in range(start, stop + 1, step):</span>
<span class="gi">+            # +1 because bind is inclusive and python is exclusive</span>
<span class="gi">+</span>
<span class="gi">+            lindex = _calculate_index(i, lsign, loffset)</span>
<span class="gi">+            rindex = _calculate_index(i, rsign, roffset)</span>
<span class="gi">+</span>
<span class="gi">+            lzfindex = _format_index(lindex, lbase, lwidth)</span>
<span class="gi">+            rzfindex = _format_index(rindex, rbase, rwidth)</span>
<span class="gi">+</span>
<span class="gi">+            name = lhs.replace(&quot;$%s&quot; % (lmod), lzfindex)</span>
<span class="gi">+            rdata = rhs.replace(&quot;$%s&quot; % (rmod), rzfindex)</span>
<span class="gi">+</span>
<span class="gi">+            self.last_name = dns.name.from_text(</span>
<span class="gi">+                name, self.current_origin, self.tok.idna_codec</span>
<span class="gi">+            )</span>
<span class="gi">+            name = self.last_name</span>
<span class="gi">+            if not name.is_subdomain(self.zone_origin):</span>
<span class="gi">+                self._eat_line()</span>
<span class="gi">+                return</span>
<span class="gi">+            if self.relativize:</span>
<span class="gi">+                name = name.relativize(self.zone_origin)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                rd = dns.rdata.from_text(</span>
<span class="gi">+                    rdclass,</span>
<span class="gi">+                    rdtype,</span>
<span class="gi">+                    rdata,</span>
<span class="gi">+                    self.current_origin,</span>
<span class="gi">+                    self.relativize,</span>
<span class="gi">+                    self.zone_origin,</span>
<span class="gi">+                )</span>
<span class="gi">+            except dns.exception.SyntaxError:</span>
<span class="gi">+                # Catch and reraise.</span>
<span class="gi">+                raise</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                # All exceptions that occur in the processing of rdata</span>
<span class="gi">+                # are treated as syntax errors.  This is not strictly</span>
<span class="gi">+                # correct, but it is correct almost all of the time.</span>
<span class="gi">+                # We convert them to syntax errors so that we can emit</span>
<span class="gi">+                # helpful filename:line info.</span>
<span class="gi">+                (ty, va) = sys.exc_info()[:2]</span>
<span class="gi">+                raise dns.exception.SyntaxError(</span>
<span class="gi">+                    &quot;caught exception %s: %s&quot; % (str(ty), str(va))</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            self.txn.add(name, ttl, rd)</span>
<span class="gi">+</span>
<span class="gi">+    def read(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read a DNS zone file and build a zone object.

<span class="w"> </span>        @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
<span class="w"> </span>        @raises dns.zone.NoNS: No NS RRset was found at the zone origin
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gi">+        try:</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                token = self.tok.get(True, True)</span>
<span class="gi">+                if token.is_eof():</span>
<span class="gi">+                    if self.current_file is not None:</span>
<span class="gi">+                        self.current_file.close()</span>
<span class="gi">+                    if len(self.saved_state) &gt; 0:</span>
<span class="gi">+                        (</span>
<span class="gi">+                            self.tok,</span>
<span class="gi">+                            self.current_origin,</span>
<span class="gi">+                            self.last_name,</span>
<span class="gi">+                            self.current_file,</span>
<span class="gi">+                            self.last_ttl,</span>
<span class="gi">+                            self.last_ttl_known,</span>
<span class="gi">+                            self.default_ttl,</span>
<span class="gi">+                            self.default_ttl_known,</span>
<span class="gi">+                        ) = self.saved_state.pop(-1)</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    break</span>
<span class="gi">+                elif token.is_eol():</span>
<span class="gi">+                    continue</span>
<span class="gi">+                elif token.is_comment():</span>
<span class="gi">+                    self.tok.get_eol()</span>
<span class="gi">+                    continue</span>
<span class="gi">+                elif token.value[0] == &quot;$&quot; and len(self.allowed_directives) &gt; 0:</span>
<span class="gi">+                    # Note that we only run directive processing code if at least</span>
<span class="gi">+                    # one directive is allowed in order to be backwards compatible</span>
<span class="gi">+                    c = token.value.upper()</span>
<span class="gi">+                    if c not in self.allowed_directives:</span>
<span class="gi">+                        raise dns.exception.SyntaxError(</span>
<span class="gi">+                            f&quot;zone file directive &#39;{c}&#39; is not allowed&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    if c == &quot;$TTL&quot;:</span>
<span class="gi">+                        token = self.tok.get()</span>
<span class="gi">+                        if not token.is_identifier():</span>
<span class="gi">+                            raise dns.exception.SyntaxError(&quot;bad $TTL&quot;)</span>
<span class="gi">+                        self.default_ttl = dns.ttl.from_text(token.value)</span>
<span class="gi">+                        self.default_ttl_known = True</span>
<span class="gi">+                        self.tok.get_eol()</span>
<span class="gi">+                    elif c == &quot;$ORIGIN&quot;:</span>
<span class="gi">+                        self.current_origin = self.tok.get_name()</span>
<span class="gi">+                        self.tok.get_eol()</span>
<span class="gi">+                        if self.zone_origin is None:</span>
<span class="gi">+                            self.zone_origin = self.current_origin</span>
<span class="gi">+                        self.txn._set_origin(self.current_origin)</span>
<span class="gi">+                    elif c == &quot;$INCLUDE&quot;:</span>
<span class="gi">+                        token = self.tok.get()</span>
<span class="gi">+                        filename = token.value</span>
<span class="gi">+                        token = self.tok.get()</span>
<span class="gi">+                        new_origin: Optional[dns.name.Name]</span>
<span class="gi">+                        if token.is_identifier():</span>
<span class="gi">+                            new_origin = dns.name.from_text(</span>
<span class="gi">+                                token.value, self.current_origin, self.tok.idna_codec</span>
<span class="gi">+                            )</span>
<span class="gi">+                            self.tok.get_eol()</span>
<span class="gi">+                        elif not token.is_eol_or_eof():</span>
<span class="gi">+                            raise dns.exception.SyntaxError(&quot;bad origin in $INCLUDE&quot;)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            new_origin = self.current_origin</span>
<span class="gi">+                        self.saved_state.append(</span>
<span class="gi">+                            (</span>
<span class="gi">+                                self.tok,</span>
<span class="gi">+                                self.current_origin,</span>
<span class="gi">+                                self.last_name,</span>
<span class="gi">+                                self.current_file,</span>
<span class="gi">+                                self.last_ttl,</span>
<span class="gi">+                                self.last_ttl_known,</span>
<span class="gi">+                                self.default_ttl,</span>
<span class="gi">+                                self.default_ttl_known,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        )</span>
<span class="gi">+                        self.current_file = open(filename, &quot;r&quot;)</span>
<span class="gi">+                        self.tok = dns.tokenizer.Tokenizer(self.current_file, filename)</span>
<span class="gi">+                        self.current_origin = new_origin</span>
<span class="gi">+                    elif c == &quot;$GENERATE&quot;:</span>
<span class="gi">+                        self._generate_line()</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise dns.exception.SyntaxError(</span>
<span class="gi">+                            f&quot;Unknown zone file directive &#39;{c}&#39;&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.tok.unget(token)</span>
<span class="gi">+                self._rr_line()</span>
<span class="gi">+        except dns.exception.SyntaxError as detail:</span>
<span class="gi">+            (filename, line_number) = self.tok.where()</span>
<span class="gi">+            if detail is None:</span>
<span class="gi">+                detail = &quot;syntax error&quot;</span>
<span class="gi">+            ex = dns.exception.SyntaxError(</span>
<span class="gi">+                &quot;%s:%d: %s&quot; % (filename, line_number, detail)</span>
<span class="gi">+            )</span>
<span class="gi">+            tb = sys.exc_info()[2]</span>
<span class="gi">+            raise ex.with_traceback(tb) from None</span>

<span class="gd">-class RRsetsReaderTransaction(dns.transaction.Transaction):</span>

<span class="gi">+class RRsetsReaderTransaction(dns.transaction.Transaction):</span>
<span class="w"> </span>    def __init__(self, manager, replacement, read_only):
<span class="w"> </span>        assert not read_only
<span class="w"> </span>        super().__init__(manager, replacement, read_only)
<span class="w"> </span>        self.rdatasets = {}

<span class="gi">+    def _get_rdataset(self, name, rdtype, covers):</span>
<span class="gi">+        return self.rdatasets.get((name, rdtype, covers))</span>

<span class="gd">-class RRSetsReaderManager(dns.transaction.TransactionManager):</span>
<span class="gi">+    def _get_node(self, name):</span>
<span class="gi">+        rdatasets = []</span>
<span class="gi">+        for (rdataset_name, _, _), rdataset in self.rdatasets.items():</span>
<span class="gi">+            if name == rdataset_name:</span>
<span class="gi">+                rdatasets.append(rdataset)</span>
<span class="gi">+        if len(rdatasets) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        node = dns.node.Node()</span>
<span class="gi">+        node.rdatasets = rdatasets</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def _put_rdataset(self, name, rdataset):</span>
<span class="gi">+        self.rdatasets[(name, rdataset.rdtype, rdataset.covers)] = rdataset</span>
<span class="gi">+</span>
<span class="gi">+    def _delete_name(self, name):</span>
<span class="gi">+        # First remove any changes involving the name</span>
<span class="gi">+        remove = []</span>
<span class="gi">+        for key in self.rdatasets:</span>
<span class="gi">+            if key[0] == name:</span>
<span class="gi">+                remove.append(key)</span>
<span class="gi">+        if len(remove) &gt; 0:</span>
<span class="gi">+            for key in remove:</span>
<span class="gi">+                del self.rdatasets[key]</span>

<span class="gd">-    def __init__(self, origin=dns.name.root, relativize=False, rdclass=dns.</span>
<span class="gd">-        rdataclass.IN):</span>
<span class="gi">+    def _delete_rdataset(self, name, rdtype, covers):</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self.rdatasets[(name, rdtype, covers)]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def _name_exists(self, name):</span>
<span class="gi">+        for n, _, _ in self.rdatasets:</span>
<span class="gi">+            if n == name:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _changed(self):</span>
<span class="gi">+        return len(self.rdatasets) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def _end_transaction(self, commit):</span>
<span class="gi">+        if commit and self._changed():</span>
<span class="gi">+            rrsets = []</span>
<span class="gi">+            for (name, _, _), rdataset in self.rdatasets.items():</span>
<span class="gi">+                rrset = dns.rrset.RRset(</span>
<span class="gi">+                    name, rdataset.rdclass, rdataset.rdtype, rdataset.covers</span>
<span class="gi">+                )</span>
<span class="gi">+                rrset.update(rdataset)</span>
<span class="gi">+                rrsets.append(rrset)</span>
<span class="gi">+            self.manager.set_rrsets(rrsets)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_origin(self, origin):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _iterate_rdatasets(self):</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    def _iterate_names(self):</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class RRSetsReaderManager(dns.transaction.TransactionManager):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, origin=dns.name.root, relativize=False, rdclass=dns.rdataclass.IN</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.origin = origin
<span class="w"> </span>        self.relativize = relativize
<span class="w"> </span>        self.rdclass = rdclass
<span class="w"> </span>        self.rrsets = []

<span class="gi">+    def reader(self):  # pragma: no cover</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def writer(self, replacement=False):</span>
<span class="gi">+        assert replacement is True</span>
<span class="gi">+        return RRsetsReaderTransaction(self, True, False)</span>
<span class="gi">+</span>
<span class="gi">+    def get_class(self):</span>
<span class="gi">+        return self.rdclass</span>
<span class="gi">+</span>
<span class="gi">+    def origin_information(self):</span>
<span class="gi">+        if self.relativize:</span>
<span class="gi">+            effective = dns.name.empty</span>
<span class="gi">+        else:</span>
<span class="gi">+            effective = self.origin</span>
<span class="gi">+        return (self.origin, self.relativize, effective)</span>
<span class="gi">+</span>
<span class="gi">+    def set_rrsets(self, rrsets):</span>
<span class="gi">+        self.rrsets = rrsets</span>
<span class="gi">+</span>

<span class="gd">-def read_rrsets(text: Any, name: Optional[Union[dns.name.Name, str]]=None,</span>
<span class="gd">-    ttl: Optional[int]=None, rdclass: Optional[Union[dns.rdataclass.</span>
<span class="gd">-    RdataClass, str]]=dns.rdataclass.IN, default_rdclass: Union[dns.</span>
<span class="gd">-    rdataclass.RdataClass, str]=dns.rdataclass.IN, rdtype: Optional[Union[</span>
<span class="gd">-    dns.rdatatype.RdataType, str]]=None, default_ttl: Optional[Union[int,</span>
<span class="gd">-    str]]=None, idna_codec: Optional[dns.name.IDNACodec]=None, origin:</span>
<span class="gd">-    Optional[Union[dns.name.Name, str]]=dns.name.root, relativize: bool=False</span>
<span class="gd">-    ) -&gt;List[dns.rrset.RRset]:</span>
<span class="gi">+def read_rrsets(</span>
<span class="gi">+    text: Any,</span>
<span class="gi">+    name: Optional[Union[dns.name.Name, str]] = None,</span>
<span class="gi">+    ttl: Optional[int] = None,</span>
<span class="gi">+    rdclass: Optional[Union[dns.rdataclass.RdataClass, str]] = dns.rdataclass.IN,</span>
<span class="gi">+    default_rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,</span>
<span class="gi">+    rdtype: Optional[Union[dns.rdatatype.RdataType, str]] = None,</span>
<span class="gi">+    default_ttl: Optional[Union[int, str]] = None,</span>
<span class="gi">+    idna_codec: Optional[dns.name.IDNACodec] = None,</span>
<span class="gi">+    origin: Optional[Union[dns.name.Name, str]] = dns.name.root,</span>
<span class="gi">+    relativize: bool = False,</span>
<span class="gi">+) -&gt; List[dns.rrset.RRset]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read one or more rrsets from the specified text, possibly subject
<span class="w"> </span>    to restrictions.

<span class="gu">@@ -165,4 +711,36 @@ def read_rrsets(text: Any, name: Optional[Union[dns.name.Name, str]]=None,</span>
<span class="w"> </span>    if ``False`` then any relative names in the input are made absolute by
<span class="w"> </span>    appending the *origin*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(origin, str):</span>
<span class="gi">+        origin = dns.name.from_text(origin, dns.name.root, idna_codec)</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, origin, idna_codec)</span>
<span class="gi">+    if isinstance(ttl, str):</span>
<span class="gi">+        ttl = dns.ttl.from_text(ttl)</span>
<span class="gi">+    if isinstance(default_ttl, str):</span>
<span class="gi">+        default_ttl = dns.ttl.from_text(default_ttl)</span>
<span class="gi">+    if rdclass is not None:</span>
<span class="gi">+        rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    else:</span>
<span class="gi">+        rdclass = None</span>
<span class="gi">+    default_rdclass = dns.rdataclass.RdataClass.make(default_rdclass)</span>
<span class="gi">+    if rdtype is not None:</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    else:</span>
<span class="gi">+        rdtype = None</span>
<span class="gi">+    manager = RRSetsReaderManager(origin, relativize, default_rdclass)</span>
<span class="gi">+    with manager.writer(True) as txn:</span>
<span class="gi">+        tok = dns.tokenizer.Tokenizer(text, &quot;&lt;input&gt;&quot;, idna_codec=idna_codec)</span>
<span class="gi">+        reader = Reader(</span>
<span class="gi">+            tok,</span>
<span class="gi">+            default_rdclass,</span>
<span class="gi">+            txn,</span>
<span class="gi">+            allow_directives=False,</span>
<span class="gi">+            force_name=name,</span>
<span class="gi">+            force_ttl=ttl,</span>
<span class="gi">+            force_rdclass=rdclass,</span>
<span class="gi">+            force_rdtype=rdtype,</span>
<span class="gi">+            default_ttl=default_ttl,</span>
<span class="gi">+        )</span>
<span class="gi">+        reader.read()</span>
<span class="gi">+    return manager.rrsets</span>
<span class="gh">diff --git a/dns/zonetypes.py b/dns/zonetypes.py</span>
<span class="gh">index 63dfed7..195ee2e 100644</span>
<span class="gd">--- a/dns/zonetypes.py</span>
<span class="gi">+++ b/dns/zonetypes.py</span>
<span class="gu">@@ -1,18 +1,37 @@</span>
<span class="gi">+# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Common zone-related types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# This is a separate file to avoid import circularity between dns.zone and</span>
<span class="gi">+# the implementation of the ZONEMD type.</span>
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="gi">+</span>
<span class="w"> </span>import dns.enum


<span class="w"> </span>class DigestScheme(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;ZONEMD Scheme&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    SIMPLE = 1

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 255</span>
<span class="gi">+</span>

<span class="w"> </span>class DigestHashAlgorithm(dns.enum.IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;ZONEMD Hash Algorithm&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    SHA384 = 1
<span class="w"> </span>    SHA512 = 2

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _maximum(cls):</span>
<span class="gi">+        return 255</span>
<span class="gi">+</span>

<span class="gd">-_digest_hashers = {DigestHashAlgorithm.SHA384: hashlib.sha384,</span>
<span class="gd">-    DigestHashAlgorithm.SHA512: hashlib.sha512}</span>
<span class="gi">+_digest_hashers = {</span>
<span class="gi">+    DigestHashAlgorithm.SHA384: hashlib.sha384,</span>
<span class="gi">+    DigestHashAlgorithm.SHA512: hashlib.sha512,</span>
<span class="gi">+}</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>